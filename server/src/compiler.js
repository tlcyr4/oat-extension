//# 1 "server.bc.runtime.js"
// Generated by js_of_ocaml 3.5.2
(function(joo_global_object)
   {"use strict";
    function caml_int64_is_zero(x){return (x[3] | x[2] | x[1]) == 0}
    function caml_str_repeat(n,s)
     {if(n == 0)return "";
      if(s.repeat)return s.repeat(n);
      var r="",l=0;
      if(n == 0)return r;
      for(;;)
       {if(n & 1)r += s;
        n >>= 1;
        if(n == 0)return r;
        s += s;
        l++;
        if(l == 9)s.slice(0,1)}}
    function caml_int64_of_int32(x)
     {return [255,x & 0xffffff,x >> 24 & 0xffffff,x >> 31 & 0xffff]}
    function caml_obj_dup(x)
     {var l=x.length,a=new Array(l);
      for(var i=0;i < l;i++)a[i] = x[i];
      return a}
    function caml_int64_sub(x,y)
     {var
       z1=x[1] - y[1],
       z2=x[2] - y[2] + (z1 >> 24),
       z3=x[3] - y[3] + (z2 >> 24);
      return [255,z1 & 0xffffff,z2 & 0xffffff,z3 & 0xffff]}
    function caml_int64_ucompare(x,y)
     {if(x[3] > y[3])return 1;
      if(x[3] < y[3])return - 1;
      if(x[2] > y[2])return 1;
      if(x[2] < y[2])return - 1;
      if(x[1] > y[1])return 1;
      if(x[1] < y[1])return - 1;
      return 0}
    function caml_int64_lsl1(x)
     {x[3] = x[3] << 1 | x[2] >> 23;
      x[2] = (x[2] << 1 | x[1] >> 23) & 0xffffff;
      x[1] = x[1] << 1 & 0xffffff}
    function caml_int64_lsr1(x)
     {x[1] = (x[1] >>> 1 | x[2] << 23) & 0xffffff;
      x[2] = (x[2] >>> 1 | x[3] << 23) & 0xffffff;
      x[3] = x[3] >>> 1}
    function caml_int64_udivmod(x,y)
     {var
       offset=0,
       modulus=caml_obj_dup(x),
       divisor=caml_obj_dup(y),
       quotient=[255,0,0,0];
      while(caml_int64_ucompare(modulus,divisor) > 0)
       {offset++;caml_int64_lsl1(divisor)}
      while(offset >= 0)
       {offset--;
        caml_int64_lsl1(quotient);
        if(caml_int64_ucompare(modulus,divisor) >= 0)
         {quotient[1]++;modulus = caml_int64_sub(modulus,divisor)}
        caml_int64_lsr1(divisor)}
      return [0,quotient,modulus]}
    function caml_int64_to_int32(x){return x[1] | x[2] << 24}
    function caml_int64_is_negative(x){return x[3] << 16 < 0}
    function caml_int64_neg(x)
     {var y1=- x[1],y2=- x[2] + (y1 >> 24),y3=- x[3] + (y2 >> 24);
      return [255,y1 & 0xffffff,y2 & 0xffffff,y3 & 0xffff]}
    function raw_array_sub(a,i,l)
     {var b=new Array(l);for(var j=0;j < l;j++)b[j] = a[i + j];return b}
    function caml_subarray_to_string(a,i,len)
     {var f=String.fromCharCode;
      if(i == 0 && len <= 4096 && len == a.length)return f.apply(null,a);
      var s="";
      for(;0 < len;i += 1024,len -= 1024)
       s += f.apply(null,raw_array_sub(a,i,Math.min(len,1024)));
      return s}
    function caml_convert_string_to_bytes(s)
     {if(s.t == 2)
       s.c += caml_str_repeat(s.l - s.c.length,"\0");
      else
       s.c = caml_subarray_to_string(s.c,0,s.c.length);
      s.t = 0}
    function caml_jsbytes_of_string(s)
     {if((s.t & 6) != 0)caml_convert_string_to_bytes(s);return s.c}
    function caml_raise_with_arg(tag,arg){throw [0,tag,arg]}
    function caml_is_ascii(s)
     {if(s.length < 24)
       {for(var i=0;i < s.length;i++)if(s.charCodeAt(i) > 127)return false;
        return true}
      else
       return ! /[^\x00-\x7f]/.test(s)}
    function caml_utf16_of_utf8(s)
     {for(var b="",t="",c,c1,c2,v,i=0,l=s.length;i < l;i++)
       {c1 = s.charCodeAt(i);
        if(c1 < 0x80)
         {for(var j=i + 1;j < l && (c1 = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        v = 1;
        if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
         {c = c2 + (c1 << 6);
          if(c1 < 0xe0)
           {v = c - 0x3080;if(v < 0x80)v = 1}
          else
           {v = 2;
            if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
             {c = c2 + (c << 6);
              if(c1 < 0xf0)
               {v = c - 0xe2080;
                if(v < 0x800 || v >= 0xd7ff && v < 0xe000)v = 2}
              else
               {v = 3;
                if
                 (++i
                  <
                  l
                  &&
                  ((c2 = s.charCodeAt(i)) & - 64)
                  ==
                  128
                  &&
                  c1
                  <
                  0xf5)
                 {v = c2 - 0x3c82080 + (c << 6);
                  if(v < 0x10000 || v > 0x10ffff)v = 3}}}}}
        if(v < 4)
         {i -= v;t += "\ufffd"}
        else
         if(v > 0xffff)
          t += String.fromCharCode(0xd7c0 + (v >> 10),0xdc00 + (v & 0x3FF));
         else
          t += String.fromCharCode(v);
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function caml_to_js_string(s)
     {switch(s.t)
       {case 9:return s.c;
        default:caml_convert_string_to_bytes(s);case 0:
         if(caml_is_ascii(s.c)){s.t = 9;return s.c}s.t = 8;
        case 8:return caml_utf16_of_utf8(s.c)
        }}
    function MlBytes(tag,contents,length)
     {this.t = tag;this.c = contents;this.l = length}
    MlBytes.prototype.toString = function(){return caml_to_js_string(this)};
    MlBytes.prototype.slice
    =
    function()
     {var content=this.t == 4?this.c.slice():this.c;
      return new MlBytes(this.t,content,this.l)};
    function caml_new_string(s){return new MlBytes(0,s,s.length)}
    function caml_raise_with_string(tag,msg)
     {caml_raise_with_arg(tag,caml_new_string(msg))}
    var caml_global_data=[0];
    function caml_invalid_argument(msg)
     {caml_raise_with_string(caml_global_data.Invalid_argument,msg)}
    function caml_parse_format(fmt)
     {fmt = caml_jsbytes_of_string(fmt);
      var len=fmt.length;
      if(len > 31)caml_invalid_argument("format_int: format too long");
      var
       f=
        {justify:"+",
         signstyle:"-",
         filler:" ",
         alternate:false,
         base:0,
         signedconv:false,
         width:0,
         uppercase:false,
         sign:1,
         prec:- 1,
         conv:"f"};
      for(var i=0;i < len;i++)
       {var c=fmt.charAt(i);
        switch(c)
         {case "-":f.justify = "-";break;
          case "+":
          case " ":f.signstyle = c;break;
          case "0":f.filler = "0";break;
          case "#":f.alternate = true;break;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
           f.width = 0;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.width = f.width * 10 + c;i++}
           i--;
           break;
          case ".":
           f.prec = 0;
           i++;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.prec = f.prec * 10 + c;i++}
           i--;
          case "d":
          case "i":f.signedconv = true;
          case "u":f.base = 10;break;
          case "x":f.base = 16;break;
          case "X":f.base = 16;f.uppercase = true;break;
          case "o":f.base = 8;break;
          case "e":
          case "f":
          case "g":f.signedconv = true;f.conv = c;break;
          case "E":
          case "F":
          case "G":
           f.signedconv = true;
           f.uppercase = true;
           f.conv = c.toLowerCase();
           break
          }}
      return f}
    function caml_finish_formatting(f,rawbuffer)
     {if(f.uppercase)rawbuffer = rawbuffer.toUpperCase();
      var len=rawbuffer.length;
      if(f.signedconv && (f.sign < 0 || f.signstyle != "-"))len++;
      if(f.alternate){if(f.base == 8)len += 1;if(f.base == 16)len += 2}
      var buffer="";
      if(f.justify == "+" && f.filler == " ")
       for(var i=len;i < f.width;i++)buffer += " ";
      if(f.signedconv)
       if(f.sign < 0)
        buffer += "-";
       else
        if(f.signstyle != "-")buffer += f.signstyle;
      if(f.alternate && f.base == 8)buffer += "0";
      if(f.alternate && f.base == 16)buffer += "0x";
      if(f.justify == "+" && f.filler == "0")
       for(var i=len;i < f.width;i++)buffer += "0";
      buffer += rawbuffer;
      if(f.justify == "-")for(var i=len;i < f.width;i++)buffer += " ";
      return caml_new_string(buffer)}
    function caml_int64_format(fmt,x)
     {var f=caml_parse_format(fmt);
      if(f.signedconv && caml_int64_is_negative(x))
       {f.sign = - 1;x = caml_int64_neg(x)}
      var
       buffer="",
       wbase=caml_int64_of_int32(f.base),
       cvtbl="0123456789abcdef";
      do
       {var p=caml_int64_udivmod(x,wbase);
        x = p[1];
        buffer = cvtbl.charAt(caml_int64_to_int32(p[2])) + buffer}
      while
       (! caml_int64_is_zero(x));
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - buffer.length;
        if(n > 0)buffer = caml_str_repeat(n,"0") + buffer}
      return caml_finish_formatting(f,buffer)}
    function caml_expm1_float(x)
     {var y=Math.exp(x),z=y - 1;
      return Math.abs(x) > 1?z:z == 0?x:x * z / Math.log(y)}
    if(joo_global_object.process && joo_global_object.process.cwd)
     var caml_current_dir=joo_global_object.process.cwd().replace(/\\/g,"/");
    else
     var caml_current_dir="/static";
    if(caml_current_dir.slice(- 1) !== "/")caml_current_dir += "/";
    function caml_make_path(name)
     {name = name instanceof MlBytes?name.toString():name;
      if(name.charCodeAt(0) != 47)name = caml_current_dir + name;
      var comp=name.split("/"),ncomp=[];
      for(var i=0;i < comp.length;i++)
       switch(comp[i])
        {case "..":if(ncomp.length > 1)ncomp.pop();break;
         case ".":break;
         case "":if(ncomp.length == 0)ncomp.push("");break;
         default:ncomp.push(comp[i]);break}
      ncomp.orig = name;
      return ncomp}
    function caml_raise_sys_error(msg)
     {caml_raise_with_string(caml_global_data.Sys_error,msg)}
    function caml_raise_no_such_file(name)
     {name = name instanceof MlBytes?name.toString():name;
      caml_raise_sys_error(name + ": No such file or directory")}
    function caml_string_of_array(a){return new MlBytes(4,a,a.length)}
    function caml_string_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_bytes_unsafe_get(s,i)
     {switch(s.t & 6)
       {default:if(i >= s.c.length)return 0;case 0:return s.c.charCodeAt(i);
        case 4:return s.c[i]
        }}
    function caml_bytes_get(s,i)
     {if(i >>> 0 >= s.l)caml_string_bound_error();
      return caml_bytes_unsafe_get(s,i)}
    function caml_create_bytes(len)
     {if(len < 0)caml_invalid_argument("Bytes.create");
      return new MlBytes(len?2:9,"",len)}
    function caml_ml_bytes_length(s){return s.l}
    function caml_convert_string_to_array(s)
     {if(joo_global_object.Uint8Array)
       var a=new (joo_global_object.Uint8Array)(s.l);
      else
       var a=new Array(s.l);
      var b=s.c,l=b.length,i=0;
      for(;i < l;i++)a[i] = b.charCodeAt(i);
      for(l = s.l;i < l;i++)a[i] = 0;
      s.c = a;
      s.t = 4;
      return a}
    function caml_blit_bytes(s1,i1,s2,i2,len)
     {if(len == 0)return 0;
      if(i2 == 0 && (len >= s2.l || s2.t == 2 && len >= s2.c.length))
       {s2.c
        =
        s1.t == 4
         ?caml_subarray_to_string(s1.c,i1,len)
         :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
        s2.t = s2.c.length == s2.l?0:2}
      else
       if(s2.t == 2 && i2 == s2.c.length)
        {s2.c
         +=
         s1.t == 4
          ?caml_subarray_to_string(s1.c,i1,len)
          :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
         s2.t = s2.c.length == s2.l?0:2}
       else
        {if(s2.t != 4)caml_convert_string_to_array(s2);
         var c1=s1.c,c2=s2.c;
         if(s1.t == 4)
          if(i2 <= i1)
           for(var i=0;i < len;i++)c2[i2 + i] = c1[i1 + i];
          else
           for(var i=len - 1;i >= 0;i--)c2[i2 + i] = c1[i1 + i];
         else
          {var l=Math.min(len,c1.length - i1);
           for(var i=0;i < l;i++)c2[i2 + i] = c1.charCodeAt(i1 + i);
           for(;i < len;i++)c2[i2 + i] = 0}}
      return 0}
    function MlFile(){}
    function MlFakeFile(content){this.data = content}
    MlFakeFile.prototype = new MlFile();
    MlFakeFile.prototype.truncate
    =
    function(len)
     {var old=this.data;
      this.data = caml_create_bytes(len | 0);
      caml_blit_bytes(old,0,this.data,0,len)};
    MlFakeFile.prototype.length
    =
    function(){return caml_ml_bytes_length(this.data)};
    MlFakeFile.prototype.write
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      if(offset + len >= clen)
       {var new_str=caml_create_bytes(offset + len),old_data=this.data;
        this.data = new_str;
        caml_blit_bytes(old_data,0,this.data,0,clen)}
      caml_blit_bytes(buf,pos,this.data,offset,len);
      return 0};
    MlFakeFile.prototype.read
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      caml_blit_bytes(this.data,offset,buf,pos,len);
      return 0};
    MlFakeFile.prototype.read_one
    =
    function(offset){return caml_bytes_get(this.data,offset)};
    MlFakeFile.prototype.close = function(){};
    MlFakeFile.prototype.constructor = MlFakeFile;
    function MlFakeDevice(root,f)
     {this.content = {};this.root = root;this.lookupFun = f}
    MlFakeDevice.prototype.nm = function(name){return this.root + name};
    MlFakeDevice.prototype.lookup
    =
    function(name)
     {if(! this.content[name] && this.lookupFun)
       {var
         res=
          this.lookupFun(caml_new_string(this.root),caml_new_string(name));
        if(res !== 0)this.content[name] = new MlFakeFile(res[1])}};
    MlFakeDevice.prototype.exists
    =
    function(name)
     {if(name == "")return 1;
      var name_slash=name + "/",r=new RegExp("^" + name_slash);
      for(var n in this.content)if(n.match(r))return 1;
      this.lookup(name);
      return this.content[name]?1:0};
    MlFakeDevice.prototype.readdir
    =
    function(name)
     {var
       name_slash=name == ""?"":name + "/",
       r=new RegExp("^" + name_slash + "([^/]*)"),
       seen={},
       a=[];
      for(var n in this.content)
       {var m=n.match(r);
        if(m && ! seen[m[1]]){seen[m[1]] = true;a.push(m[1])}}
      return a};
    MlFakeDevice.prototype.is_dir
    =
    function(name)
     {var
       name_slash=name == ""?"":name + "/",
       r=new RegExp("^" + name_slash + "([^/]*)"),
       a=[];
      for(var n in this.content){var m=n.match(r);if(m)return 1}
      return 0};
    MlFakeDevice.prototype.unlink
    =
    function(name)
     {var ok=this.content[name]?true:false;
      delete this.content[name];
      return ok};
    MlFakeDevice.prototype.open
    =
    function(name,f)
     {if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      this.lookup(name);
      if(this.content[name])
       {if(this.is_dir(name))
         caml_raise_sys_error(this.nm(name) + " : is a directory");
        if(f.create && f.excl)
         caml_raise_sys_error(this.nm(name) + " : file already exists");
        var file=this.content[name];
        if(f.truncate)file.truncate();
        return file}
      else
       if(f.create)
        {this.content[name] = new MlFakeFile(caml_create_bytes(0));
         return this.content[name]}
       else
        caml_raise_no_such_file(this.nm(name))};
    MlFakeDevice.prototype.register
    =
    function(name,content)
     {if(this.content[name])
       caml_raise_sys_error(this.nm(name) + " : file already exists");
      if(content instanceof MlBytes)
       this.content[name] = new MlFakeFile(content);
      else
       if(content instanceof Array)
        this.content[name] = new MlFakeFile(caml_string_of_array(content));
       else
        if(content.toString)
         {var mlstring=caml_new_string(content.toString());
          this.content[name] = new MlFakeFile(mlstring)}};
    MlFakeDevice.prototype.constructor = MlFakeDevice;
    function caml_array_of_string(s)
     {if(s.t != 4)caml_convert_string_to_array(s);return s.c}
    function caml_bytes_unsafe_set(s,i,c)
     {c &= 0xff;
      if(s.t != 4)
       {if(i == s.c.length)
         {s.c += String.fromCharCode(c);if(i + 1 == s.l)s.t = 0;return 0}
        caml_convert_string_to_array(s)}
      s.c[i] = c;
      return 0}
    function caml_bytes_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_string_bound_error();
      return caml_bytes_unsafe_set(s,i,c)}
    var Buffer=joo_global_object.Buffer;
    function MlNodeFile(fd){this.fs = require("fs");this.fd = fd}
    MlNodeFile.prototype = new MlFile();
    MlNodeFile.prototype.truncate
    =
    function(len){this.fs.ftruncateSync(this.fd,len | 0)};
    MlNodeFile.prototype.length
    =
    function(){return this.fs.fstatSync(this.fd).size};
    MlNodeFile.prototype.write
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_string(buf);
      if(! (a instanceof joo_global_object.Uint8Array))
       a = new (joo_global_object.Uint8Array)(a);
      var buffer=Buffer.from(a);
      this.fs.writeSync(this.fd,buffer,buf_offset,len,offset);
      return 0};
    MlNodeFile.prototype.read
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_string(buf);
      if(! (a instanceof joo_global_object.Uint8Array))
       a = new (joo_global_object.Uint8Array)(a);
      var buffer=Buffer.from(a);
      this.fs.readSync(this.fd,buffer,buf_offset,len,offset);
      for(var i=0;i < len;i++)
       caml_bytes_set(buf,buf_offset + i,buffer[buf_offset + i]);
      return 0};
    MlNodeFile.prototype.read_one
    =
    function(offset)
     {var a=new (joo_global_object.Uint8Array)(1),buffer=Buffer.from(a);
      this.fs.readSync(this.fd,buffer,0,1,offset);
      return buffer[0]};
    MlNodeFile.prototype.close = function(){this.fs.closeSync(this.fd)};
    MlNodeFile.prototype.constructor = MlNodeFile;
    function MlNodeDevice(root){this.fs = require("fs");this.root = root}
    MlNodeDevice.prototype.nm = function(name){return this.root + name};
    MlNodeDevice.prototype.exists
    =
    function(name){return this.fs.existsSync(this.nm(name))?1:0};
    MlNodeDevice.prototype.readdir
    =
    function(name){return this.fs.readdirSync(this.nm(name))};
    MlNodeDevice.prototype.is_dir
    =
    function(name){return this.fs.statSync(this.nm(name)).isDirectory()?1:0};
    MlNodeDevice.prototype.unlink
    =
    function(name)
     {var b=this.fs.existsSync(this.nm(name))?1:0;
      this.fs.unlinkSync(this.nm(name));
      return b};
    MlNodeDevice.prototype.open
    =
    function(name,f)
     {var consts=require("constants"),res=0;
      for(var key in f)
       switch(key)
        {case "rdonly":res |= consts.O_RDONLY;break;
         case "wronly":res |= consts.O_WRONLY;break;
         case "append":res |= consts.O_WRONLY | consts.O_APPEND;break;
         case "create":res |= consts.O_CREAT;break;
         case "truncate":res |= consts.O_TRUNC;break;
         case "excl":res |= consts.O_EXCL;break;
         case "binary":res |= consts.O_BINARY;break;
         case "text":res |= consts.O_TEXT;break;
         case "nonblock":res |= consts.O_NONBLOCK;break
         }
      var fd=this.fs.openSync(this.nm(name),res);
      return new MlNodeFile(fd)};
    MlNodeDevice.prototype.rename
    =
    function(o,n){this.fs.renameSync(this.nm(o),this.nm(n))};
    MlNodeDevice.prototype.constructor = MlNodeDevice;
    var caml_root=caml_current_dir.match(/[^\/]*\//)[0];
    function fs_node_supported()
     {return typeof joo_global_object.process
             !==
             "undefined"
             &&
             typeof joo_global_object.process.versions
             !==
             "undefined"
             &&
             typeof joo_global_object.process.versions.node
             !==
             "undefined"
             &&
             joo_global_object.process.platform
             !==
             "browser"}
    var jsoo_mount_point=[];
    if(fs_node_supported())
     jsoo_mount_point.push
      ({path:caml_root,device:new MlNodeDevice(caml_root)});
    else
     jsoo_mount_point.push
      ({path:caml_root,device:new MlFakeDevice(caml_root)});
    jsoo_mount_point.push
     ({path:caml_root + "static/",
       device:new MlFakeDevice(caml_root + "static/")});
    function resolve_fs_device(name)
     {var
       path=caml_make_path(name),
       name=path.join("/"),
       name_slash=name + "/",
       res;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var m=jsoo_mount_point[i];
        if
         (name_slash.search(m.path)
          ==
          0
          &&
          (! res || res.path.length < m.path.length))
         res
         =
         {path:m.path,
          device:m.device,
          rest:name.substring(m.path.length,name.length)}}
      return res}
    function caml_sys_is_directory(name)
     {var root=resolve_fs_device(name),a=root.device.is_dir(root.rest);
      return a?1:0}
    function caml_string_unsafe_get(s,i)
     {switch(s.t & 6)
       {default:if(i >= s.c.length)return 0;case 0:return s.c.charCodeAt(i);
        case 4:return s.c[i]
        }}
    function caml_utf8_of_utf16(s)
     {for(var b="",t=b,c,d,i=0,l=s.length;i < l;i++)
       {c = s.charCodeAt(i);
        if(c < 0x80)
         {for(var j=i + 1;j < l && (c = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        if(c < 0x800)
         {t += String.fromCharCode(0xc0 | c >> 6);
          t += String.fromCharCode(0x80 | c & 0x3f)}
        else
         if(c < 0xd800 || c >= 0xdfff)
          t
          +=
          String.fromCharCode
           (0xe0 | c >> 12,0x80 | c >> 6 & 0x3f,0x80 | c & 0x3f);
         else
          if
           (c
            >=
            0xdbff
            ||
            i
            +
            1
            ==
            l
            ||
            (d = s.charCodeAt(i + 1))
            <
            0xdc00
            ||
            d
            >
            0xdfff)
           t += "\xef\xbf\xbd";
          else
           {i++;
            c = (c << 10) + d - 0x35fdc00;
            t
            +=
            String.fromCharCode
             (0xf0 | c >> 18,
              0x80 | c >> 12 & 0x3f,
              0x80 | c >> 6 & 0x3f,
              0x80 | c & 0x3f)}
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function caml_js_to_string(s)
     {var tag=9;
      if(! caml_is_ascii(s))tag = 8,s = caml_utf8_of_utf16(s);
      return new MlBytes(tag,s,s.length)}
    function caml_raise_constant(tag){throw tag}
    function caml_raise_not_found()
     {caml_raise_constant(caml_global_data.Not_found)}
    function caml_sys_getenv(name)
     {var g=joo_global_object,n=name.toString();
      if(g.process && g.process.env && g.process.env[n] != undefined)
       return caml_js_to_string(g.process.env[n]);
      if
       (joo_global_object.jsoo_static_env
        &&
        joo_global_object.jsoo_static_env[n])
       return caml_js_to_string(joo_global_object.jsoo_static_env[n]);
      caml_raise_not_found()}
    function shift_right_nat(nat1,ofs1,len1,nat2,ofs2,nbits)
     {if(nbits == 0){nat2.data[ofs2] = 0;return 0}
      var wrap=0;
      for(var i=len1 - 1;i >= 0;i--)
       {var a=nat1.data[ofs1 + i] >>> 0;
        nat1.data[ofs1 + i] = a >>> nbits | wrap;
        wrap = a << 32 - nbits}
      nat2.data[ofs2] = wrap;
      return 0}
    var MlObjectTable;
    if(typeof joo_global_object.WeakMap === "undefined")
     MlObjectTable
     =
     function()
       {function NaiveLookup(objs){this.objs = objs}
        NaiveLookup.prototype.get
        =
        function(v)
         {for(var i=0;i < this.objs.length;i++)if(this.objs[i] === v)return i};
        NaiveLookup.prototype.set = function(){};
        return function()
         {this.objs = [];this.lookup = new NaiveLookup(this.objs)}}
      ();
    else
     MlObjectTable
     =
     function()
      {this.objs = [];this.lookup = new (joo_global_object.WeakMap)()};
    MlObjectTable.prototype.store
    =
    function(v){this.lookup.set(v,this.objs.length);this.objs.push(v)};
    MlObjectTable.prototype.recall
    =
    function(v)
     {var i=this.lookup.get(v);
      return i === undefined?undefined:this.objs.length - i};
    function caml_failwith(msg)
     {caml_raise_with_string(caml_global_data.Failure,msg)}
    function caml_sys_rename(o,n)
     {var o_root=resolve_fs_device(o),n_root=resolve_fs_device(n);
      if(o_root.device != n_root.device)
       caml_failwith
        ("caml_sys_rename: cannot move file between two filesystem");
      if(! o_root.device.rename)
       caml_failwith("caml_sys_rename: no implemented");
      o_root.device.rename(o_root.rest,n_root.rest)}
    function caml_log10_float(x){return Math.LOG10E * Math.log(x)}
    var caml_runtime_warnings=0;
    function caml_ml_enable_runtime_warnings(bool)
     {caml_runtime_warnings = bool;return 0}
    function caml_classify_float(x)
     {if(isFinite(x))
       {if(Math.abs(x) >= 2.2250738585072014e-308)return 0;
        if(x != 0)return 1;
        return 2}
      return isNaN(x)?4:3}
    function caml_ml_refill_input(chan)
     {var str=chan.refill(),str_len=caml_ml_bytes_length(str);
      if(str_len == 0)chan.refill = null;
      chan.file.write(chan.file.length(),str,0,str_len);
      return str_len}
    var caml_ml_channels=new Array();
    function caml_ml_may_refill_input(chanid)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill == null)return;
      if(chan.file.length() != chan.offset)return;
      caml_ml_refill_input(chan)}
    function caml_array_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_ml_input_scan_line(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_may_refill_input(chanid);
      var p=chan.offset,len=chan.file.length();
      if(p >= len)return 0;
      while(true)
       {if(p >= len)return - (p - chan.offset);
        if(chan.file.read_one(p) == 10)return p - chan.offset + 1;
        p++}}
    function caml_gc_minor(){return 0}
    function caml_int64_of_bytes(a)
     {return [255,
              a[7] | a[6] << 8 | a[5] << 16,
              a[4] | a[3] << 8 | a[2] << 16,
              a[1] | a[0] << 8]}
    function caml_ba_uint8_get64(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 7 >= ba.data.length)caml_array_bound_error();
      var
       b1=ba.get(ofs + 0),
       b2=ba.get(ofs + 1),
       b3=ba.get(ofs + 2),
       b4=ba.get(ofs + 3),
       b5=ba.get(ofs + 4),
       b6=ba.get(ofs + 5),
       b7=ba.get(ofs + 6),
       b8=ba.get(ofs + 7);
      return caml_int64_of_bytes([b8,b7,b6,b5,b4,b3,b2,b1])}
    function caml_int64_to_bytes(x)
     {return [x[3] >> 8,
              x[3] & 0xff,
              x[2] >> 16,
              x[2] >> 8 & 0xff,
              x[2] & 0xff,
              x[1] >> 16,
              x[1] >> 8 & 0xff,
              x[1] & 0xff]}
    function caml_int64_marshal(writer,v,sizes)
     {var b=caml_int64_to_bytes(v);
      for(var i=0;i < 8;i++)writer.write(8,b[i]);
      sizes[0] = 8;
      sizes[1] = 8}
    function caml_ba_num_dims(ba){return ba.dims.length}
    if(! Math.imul)
     Math.imul
     =
     function(x,y){y |= 0;return ((x >> 16) * y << 16) + (x & 0xffff) * y | 0};
    var caml_mul=Math.imul;
    function caml_hash_mix_int(h,d)
     {d = caml_mul(d,0xcc9e2d51 | 0);
      d = d << 15 | d >>> 32 - 15;
      d = caml_mul(d,0x1b873593);
      h ^= d;
      h = h << 13 | h >>> 32 - 13;
      return (h + (h << 2) | 0) + (0xe6546b64 | 0) | 0}
    function caml_hash_mix_string_arr(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w = s[i] | s[i + 1] << 8 | s[i + 2] << 16 | s[i + 3] << 24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s[i + 2] << 16;
        case 2:w |= s[i + 1] << 8;
        case 1:w |= s[i];h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_return_exn_constant(tag){return tag}
    var caml_named_values={};
    function caml_named_value(nm){return caml_named_values[nm]}
    function caml_wrap_exception(e)
     {if(e instanceof Array)return e;
      if
       (joo_global_object.RangeError
        &&
        e instanceof joo_global_object.RangeError
        &&
        e.message
        &&
        e.message.match(/maximum call stack/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if
       (joo_global_object.InternalError
        &&
        e instanceof joo_global_object.InternalError
        &&
        e.message
        &&
        e.message.match(/too much recursion/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if(e instanceof joo_global_object.Error && caml_named_value("jsError"))
       return [0,caml_named_value("jsError"),e];
      return [0,caml_global_data.Failure,caml_js_to_string(String(e))]}
    function caml_create_file(name,content)
     {var root=resolve_fs_device(name);
      if(! root.device.register)caml_failwith("cannot register file");
      root.device.register(root.rest,content);
      return 0}
    function caml_fs_init()
     {var tmp=joo_global_object.caml_fs_tmp;
      if(tmp)
       for(var i=0;i < tmp.length;i++)
        caml_create_file(tmp[i].name,tmp[i].content);
      joo_global_object.caml_create_file = caml_create_file;
      joo_global_object.caml_fs_tmp = [];
      return 0}
    function caml_list_of_js_array(a)
     {var l=0;
      for(var i=a.length - 1;i >= 0;i--){var e=a[i];l = [0,e,l]}
      return l}
    function caml_set_parser_trace(){return 0}
    function unix_gettimeofday(){return new Date().getTime() / 1000}
    function num_digits_nat(nat,ofs,len)
     {for(var i=len - 1;i >= 0;i--)if(nat.data[ofs + i] != 0)return i + 1;
      return 1}
    function caml_hash_nat(x)
     {var len=num_digits_nat(x,0,x.data.length),h=0;
      for(var i=0;i < len;i++)h = caml_hash_mix_int(h,x.data[i]);
      return h}
    function raw_array_append_one(a,x)
     {var l=a.length,b=new Array(l + 1),i=0;
      for(;i < l;i++)b[i] = a[i];
      b[i] = x;
      return b}
    function caml_call_gen(f,args)
     {if(f.fun)return caml_call_gen(f.fun,args);
      var n=f.length,argsLen=args.length,d=n - argsLen;
      if(d == 0)
       return f.apply(null,args);
      else
       if(d < 0)
        return caml_call_gen
                (f.apply(null,raw_array_sub(args,0,n)),
                 raw_array_sub(args,n,argsLen - n));
       else
        return function(x)
         {return caml_call_gen(f,raw_array_append_one(args,x))}}
    function caml_js_wrap_callback(f)
     {return function()
       {return arguments.length > 0
                ?caml_call_gen(f,arguments)
                :caml_call_gen(f,[undefined])}}
    function caml_js_wrap_callback_arguments(f)
     {return function(){return caml_js_wrap_callback(f)(arguments)}}
    function caml_sys_chdir(dir)
     {var root=resolve_fs_device(dir);
      if(root.device.exists(root.rest))
       {if(root.rest)
         caml_current_dir = root.path + root.rest + "/";
        else
         caml_current_dir = root.path;
        return 0}
      else
       caml_raise_no_such_file(dir)}
    function caml_gc_counters(){return [254,0,0,0]}
    function caml_hash_mix_string_str(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w
        =
        s.charCodeAt(i)
        |
        s.charCodeAt(i + 1)
        <<
        8
        |
        s.charCodeAt(i + 2)
        <<
        16
        |
        s.charCodeAt(i + 3)
        <<
        24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s.charCodeAt(i + 2) << 16;
        case 2:w |= s.charCodeAt(i + 1) << 8;
        case 1:w |= s.charCodeAt(i);h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    var log2_ok=Math.log2 && Math.log2(1.1235582092889474E+307) == 1020;
    function jsoo_floor_log2(x)
     {if(log2_ok)return Math.floor(Math.log2(x));
      var i=0;
      if(x == 0)return - Infinity;
      if(x >= 1)while(x >= 2){x /= 2;i++}else while(x < 1){x *= 2;i--}
      return i}
    function caml_int32_bits_of_float(x)
     {var float32a=new (joo_global_object.Float32Array)(1);
      float32a[0] = x;
      var int32a=new (joo_global_object.Int32Array)(float32a.buffer);
      return int32a[0] | 0}
    function caml_int64_create_lo_mi_hi(lo,mi,hi){return [255,lo,mi,hi]}
    function caml_int64_bits_of_float(x)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_int64_create_lo_mi_hi(1,0,0x7ff0);
        return x > 0
                ?caml_int64_create_lo_mi_hi(0,0,0x7ff0)
                :caml_int64_create_lo_mi_hi(0,0,0xfff0)}
      var sign=x == 0 && 1 / x == - Infinity?0x8000:x >= 0?0:0x8000;
      if(sign)x = - x;
      var exp=jsoo_floor_log2(x) + 1023;
      if(exp <= 0)
       {exp = 0;x /= Math.pow(2,- 1026)}
      else
       {x /= Math.pow(2,exp - 1027);
        if(x < 16){x *= 2;exp -= 1}
        if(exp == 0)x /= 2}
      var k=Math.pow(2,24),r3=x | 0;
      x = (x - r3) * k;
      var r2=x | 0;
      x = (x - r2) * k;
      var r1=x | 0;
      r3 = r3 & 0xf | sign | exp << 4;
      return caml_int64_create_lo_mi_hi(r1,r2,r3)}
    function caml_ba_serialize(writer,ba,sz)
     {writer.write(32,ba.dims.length);
      writer.write(32,ba.kind | ba.layout << 8);
      for(var i=0;i < ba.dims.length;i++)writer.write(32,ba.dims[i]);
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         for(var i=0;i < ba.data.length;i++)writer.write(8,ba.data[i]);break;
        case 4:
        case 5:
         for(var i=0;i < ba.data.length;i++)writer.write(16,ba.data[i]);break;
        case 6:
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);break;
        case 8:
        case 9:
         writer.write(8,0);
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);
         break;
        case 7:
         for(var i=0;i < ba.data.length / 2;i++)
          {var b=caml_int64_to_bytes(ba.get(i));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 1:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int64_to_bytes(caml_int64_bits_of_float(ba.get(i)));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 0:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int32_bits_of_float(ba.get(i));writer.write(32,b)}
         break;
        case 10:
         for(var i=0;i < ba.data.length / 2;i++)
          {var j=ba.get(i);
           writer.write(32,caml_int32_bits_of_float(j[1]));
           writer.write(32,caml_int32_bits_of_float(j[2]))}
         break;
        case 11:
         for(var i=0;i < ba.data.length / 2;i++)
          {var
            complex=ba.get(i),
            b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[1]));
           for(var j=0;j < 8;j++)writer.write(8,b[j]);
           var b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[2]));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break
        }
      sz[0] = (4 + ba.dims.length) * 4;
      sz[1] = (4 + ba.dims.length) * 8}
    function caml_ba_get_size_per_element(kind)
     {switch(kind){case 7:case 10:case 11:return 2;default:return 1}}
    function caml_ba_create_buffer(kind,size)
     {var g=joo_global_object,view;
      switch(kind)
       {case 0:view = g.Float32Array;break;
        case 1:view = g.Float64Array;break;
        case 2:view = g.Int8Array;break;
        case 3:view = g.Uint8Array;break;
        case 4:view = g.Int16Array;break;
        case 5:view = g.Uint16Array;break;
        case 6:view = g.Int32Array;break;
        case 7:view = g.Int32Array;break;
        case 8:view = g.Int32Array;break;
        case 9:view = g.Int32Array;break;
        case 10:view = g.Float32Array;break;
        case 11:view = g.Float64Array;break;
        case 12:view = g.Uint8Array;break
        }
      if(! view)caml_invalid_argument("Bigarray.create: unsupported kind");
      var data=new view(size * caml_ba_get_size_per_element(kind));
      return data}
    function caml_int32_float_of_bits(x)
     {var int32a=new (joo_global_object.Int32Array)(1);
      int32a[0] = x;
      var float32a=new (joo_global_object.Float32Array)(int32a.buffer);
      return float32a[0]}
    function caml_int64_float_of_bits(x)
     {var lo=x[1],mi=x[2],hi=x[3],exp=(hi & 0x7fff) >> 4;
      if(exp == 2047)
       return (lo | mi | hi & 0xf) == 0?hi & 0x8000?- Infinity:Infinity:NaN;
      var k=Math.pow(2,- 24),res=(lo * k + mi) * k + (hi & 0xf);
      if(exp > 0)
       {res += 16;res *= Math.pow(2,exp - 1027)}
      else
       res *= Math.pow(2,- 1026);
      if(hi & 0x8000)res = - res;
      return res}
    function caml_ba_get_size(dims)
     {var n_dims=dims.length,size=1;
      for(var i=0;i < n_dims;i++)
       {if(dims[i] < 0)
         caml_invalid_argument("Bigarray.create: negative dimension");
        size = size * dims[i]}
      return size}
    function caml_int64_create_lo_hi(lo,hi)
     {return [255,
              lo & 0xffffff,
              lo >>> 24 & 0xff | (hi & 0xffff) << 8,
              hi >>> 16 & 0xffff]}
    function caml_int64_hi32(v){return v[2] >>> 8 & 0xffff | v[3] << 16}
    function caml_int64_lo32(v){return v[1] | (v[2] & 0xff) << 24}
    function Ml_Bigarray(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray.prototype.caml_custom = "_bigarray";
    Ml_Bigarray.prototype.offset
    =
    function(arg)
     {var ofs=0;
      if(typeof arg === "number")arg = [arg];
      if(! (arg instanceof Array))
       caml_invalid_argument("bigarray.js: invalid offset");
      if(this.dims.length != arg.length)
       caml_invalid_argument("Bigarray.get/set: bad number of dimensions");
      if(this.layout == 0)
       for(var i=0;i < this.dims.length;i++)
        {if(arg[i] < 0 || arg[i] >= this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + arg[i]}
      else
       for(var i=this.dims.length - 1;i >= 0;i--)
        {if(arg[i] < 1 || arg[i] > this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + (arg[i] - 1)}
      return ofs};
    Ml_Bigarray.prototype.get
    =
    function(ofs)
     {switch(this.kind)
       {case 7:
         var l=this.data[ofs * 2 + 0],h=this.data[ofs * 2 + 1];
         return caml_int64_create_lo_hi(l,h);
        case 10:
        case 11:
         var r=this.data[ofs * 2 + 0],i=this.data[ofs * 2 + 1];
         return [254,r,i];
        default:return this.data[ofs]}};
    Ml_Bigarray.prototype.set
    =
    function(ofs,v)
     {switch(this.kind)
       {case 7:
         this.data[ofs * 2 + 0] = caml_int64_lo32(v);
         this.data[ofs * 2 + 1] = caml_int64_hi32(v);
         break;
        case 10:
        case 11:
         this.data[ofs * 2 + 0] = v[1];this.data[ofs * 2 + 1] = v[2];break;
        default:this.data[ofs] = v;break}
      return 0};
    Ml_Bigarray.prototype.fill
    =
    function(v)
     {switch(this.kind)
       {case 7:
         var a=caml_int64_lo32(v),b=caml_int64_hi32(v);
         if(a == b)
          this.data.fill(a);
         else
          for(var i=0;i < this.data.length;i++)this.data[i] = i % 2 == 0?a:b;
         break;
        case 10:
        case 11:
         var im=v[1],re=v[2];
         if(im == re)
          this.data.fill(im);
         else
          for(var i=0;i < this.data.length;i++)
           this.data[i] = i % 2 == 0?im:re;
         break;
        default:this.data.fill(v);break}};
    Ml_Bigarray.prototype.compare
    =
    function(b,total)
     {if(this.layout != b.layout || this.kind != b.kind)
       {var k1=this.kind | this.layout << 8,k2=b.kind | b.layout << 8;
        return k2 - k1}
      if(this.dims.length != b.dims.length)
       return b.dims.length - this.dims.length;
      for(var i=0;i < this.dims.length;i++)
       if(this.dims[i] != b.dims[i])return this.dims[i] < b.dims[i]?- 1:1;
      switch(this.kind)
       {case 0:
        case 1:
        case 10:
        case 11:
         var x,y;
         for(var i=0;i < this.data.length;i++)
          {x = this.data[i];
           y = b.data[i];
           if(x < y)return - 1;
           if(x > y)return 1;
           if(x != y)
            {if(! total)return NaN;if(x == x)return 1;if(y == y)return - 1}}
         break;
        case 7:
         for(var i=0;i < this.data.length;i += 2)
          {if(this.data[i + 1] < b.data[i + 1])return - 1;
           if(this.data[i + 1] > b.data[i + 1])return 1;
           if(this.data[i] >>> 0 < b.data[i] >>> 0)return - 1;
           if(this.data[i] >>> 0 > b.data[i] >>> 0)return 1}
         break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 8:
        case 9:
        case 12:
         for(var i=0;i < this.data.length;i++)
          {if(this.data[i] < b.data[i])return - 1;
           if(this.data[i] > b.data[i])return 1}
         break
        }
      return 0};
    function Ml_Bigarray_c_1_1(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray_c_1_1.prototype = new Ml_Bigarray();
    Ml_Bigarray_c_1_1.prototype.offset
    =
    function(arg)
     {if(typeof arg !== "number")
       if(arg instanceof Array && arg.length == 1)
        arg = arg[0];
       else
        caml_invalid_argument("Ml_Bigarray_c_1_1.offset");
      if(arg < 0 || arg >= this.dims[0])caml_array_bound_error();
      return arg};
    Ml_Bigarray_c_1_1.prototype.get = function(ofs){return this.data[ofs]};
    Ml_Bigarray_c_1_1.prototype.set
    =
    function(ofs,v){this.data[ofs] = v;return 0};
    Ml_Bigarray_c_1_1.prototype.fill
    =
    function(v){this.data.fill(v);return 0};
    function caml_ba_create_unsafe(kind,layout,dims,data)
     {var size_per_element=caml_ba_get_size_per_element(kind);
      if(caml_ba_get_size(dims) * size_per_element != data.length)
       caml_invalid_argument("length doesn't match dims");
      if(layout == 0 && dims.length == 1 && size_per_element == 1)
       return new Ml_Bigarray_c_1_1(kind,layout,dims,data);
      return new Ml_Bigarray(kind,layout,dims,data)}
    function caml_ba_deserialize(reader,sz)
     {var num_dims=reader.read32s();
      if(num_dims < 0 || num_dims > 16)
       caml_failwith("input_value: wrong number of bigarray dimensions");
      var tag=reader.read32s(),kind=tag & 0xff,layout=tag >> 8 & 1,dims=[];
      for(var i=0;i < num_dims;i++)dims.push(reader.read32u());
      var
       size=caml_ba_get_size(dims),
       data=caml_ba_create_buffer(kind,size),
       ba=caml_ba_create_unsafe(kind,layout,dims,data);
      switch(kind)
       {case 2:for(var i=0;i < size;i++)data[i] = reader.read8s();break;
        case 3:
        case 12:for(var i=0;i < size;i++)data[i] = reader.read8u();break;
        case 4:for(var i=0;i < size;i++)data[i] = reader.read16s();break;
        case 5:for(var i=0;i < size;i++)data[i] = reader.read16u();break;
        case 6:for(var i=0;i < size;i++)data[i] = reader.read32s();break;
        case 8:
        case 9:
         var sixty=reader.read8u();
         if(sixty)
          caml_failwith
           ("input_value: cannot read bigarray with 64-bit OCaml ints");
         for(var i=0;i < size;i++)data[i] = reader.read32s();
         break;
        case 7:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var int64=caml_int64_of_bytes(t);
           ba.set(i,int64)}
         break;
        case 1:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var f=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,f)}
         break;
        case 0:
         for(var i=0;i < size;i++)
          {var f=caml_int32_float_of_bits(reader.read32s());ba.set(i,f)}
         break;
        case 10:
         for(var i=0;i < size;i++)
          {var
            re=caml_int32_float_of_bits(reader.read32s()),
            im=caml_int32_float_of_bits(reader.read32s());
           ba.set(i,[254,re,im])}
         break;
        case 11:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var re=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var im=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,[254,re,im])}
         break
        }
      sz[0] = (4 + num_dims) * 4;
      return caml_ba_create_unsafe(kind,layout,dims,data)}
    function caml_ba_compare(a,b,total){return a.compare(b,total)}
    function caml_hash_mix_int64(h,v)
     {h = caml_hash_mix_int(h,caml_int64_lo32(v));
      h = caml_hash_mix_int(h,caml_int64_hi32(v));
      return h}
    function caml_hash_mix_float(h,v0)
     {return caml_hash_mix_int64(h,caml_int64_bits_of_float(v0))}
    function caml_ba_hash(ba)
     {var num_elts=caml_ba_get_size(ba.dims),h=0;
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         if(num_elts > 256)num_elts = 256;
         var w=0,i=0;
         for(i = 0;i + 4 <= ba.data.length;i += 4)
          {w
           =
           ba.data[i + 0]
           |
           ba.data[i + 1]
           <<
           8
           |
           ba.data[i + 2]
           <<
           16
           |
           ba.data[i + 3]
           <<
           24;
           h = caml_hash_mix_int(h,w)}
         w = 0;
         switch(num_elts & 3)
          {case 3:w = ba.data[i + 2] << 16;
           case 2:w |= ba.data[i + 1] << 8;
           case 1:w |= ba.data[i + 0];h = caml_hash_mix_int(h,w)
           }
         break;
        case 4:
        case 5:
         if(num_elts > 128)num_elts = 128;
         var w=0,i=0;
         for(i = 0;i + 2 <= ba.data.length;i += 2)
          {w = ba.data[i + 0] | ba.data[i + 1] << 16;
           h = caml_hash_mix_int(h,w)}
         if((num_elts & 1) != 0)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 6:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 8:
        case 9:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 7:
         if(num_elts > 32)num_elts = 32;
         num_elts *= 2;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 10:num_elts *= 2;
        case 0:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break;
        case 11:num_elts *= 2;
        case 1:
         if(num_elts > 32)num_elts = 32;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break
        }
      return h}
    function caml_int32_unmarshal(reader,size)
     {size[0] = 4;return reader.read32s()}
    function caml_nativeint_unmarshal(reader,size)
     {switch(reader.read8u())
       {case 1:size[0] = 4;return reader.read32s();
        case 2:caml_failwith("input_value: native integer value too large");
        default:caml_failwith("input_value: ill-formed native integer")}}
    function caml_int64_unmarshal(reader,size)
     {var t=new Array(8);
      for(var j=0;j < 8;j++)t[j] = reader.read8u();
      size[0] = 8;
      return caml_int64_of_bytes(t)}
    function caml_int64_compare(x,y)
     {var x3=x[3] << 16,y3=y[3] << 16;
      if(x3 > y3)return 1;
      if(x3 < y3)return - 1;
      if(x[2] > y[2])return 1;
      if(x[2] < y[2])return - 1;
      if(x[1] > y[1])return 1;
      if(x[1] < y[1])return - 1;
      return 0}
    function caml_int64_hash(x)
     {var lo=x[1] | (x[2] & 0xff) << 24,hi=x[2] >>> 8 & 0xffff | x[3] << 16;
      return lo ^ hi}
    var
     caml_custom_ops=
      {"_j":
       {deserialize:caml_int64_unmarshal,
        serialize:caml_int64_marshal,
        fixed_length:8,
        compare:caml_int64_compare,
        hash:caml_int64_hash},
       "_i":{deserialize:caml_int32_unmarshal,fixed_length:4},
       "_n":{deserialize:caml_nativeint_unmarshal,fixed_length:4},
       "_bigarray":
       {deserialize:caml_ba_deserialize,
        serialize:caml_ba_serialize,
        compare:caml_ba_compare,
        hash:caml_ba_hash}};
    function caml_compare_val_get_custom(a)
     {return caml_custom_ops[a.caml_custom]
             &&
             caml_custom_ops[a.caml_custom].compare}
    function caml_compare_val_number_custom(num,custom,swap,total)
     {var comp=caml_compare_val_get_custom(custom);
      if(comp)
       {var x=swap > 0?comp(custom,num,total):comp(num,custom,total);
        if(total && x != x)return swap;
        if(+ x != + x)return + x;
        if((x | 0) != 0)return x | 0}
      return swap}
    function caml_compare_val_tag(a)
     {if(typeof a === "number")
       return 1000;
      else
       if(a instanceof MlBytes)
        return 252;
       else
        if(a instanceof Array && a[0] === a[0] >>> 0 && a[0] <= 255)
         {var tag=a[0] | 0;return tag == 254?0:tag}
        else
         if(a instanceof String)
          return 1252;
         else
          if(typeof a == "string")
           return 1252;
          else
           if(a instanceof Number)
            return 1000;
           else
            if(a && a.caml_custom)
             return 1255;
            else
             if(a && a.compare)
              return 1256;
             else
              if(typeof a == "function")
               return 1247;
              else
               if(typeof a == "symbol")return 1251;
      return 1001}
    function caml_int_compare(a,b)
     {if(a < b)return - 1;if(a == b)return 0;return 1}
    function caml_string_compare(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?- 1:s1.c > s2.c?1:0}
    function caml_compare_val(a,b,total)
     {var stack=[];
      for(;;)
       {if(! (total && a === b))
         {var tag_a=caml_compare_val_tag(a);
          if(tag_a == 250){a = a[1];continue}
          var tag_b=caml_compare_val_tag(b);
          if(tag_b == 250){b = b[1];continue}
          if(tag_a !== tag_b)
           {if(tag_a == 1000)
             {if(tag_b == 1255)
               return caml_compare_val_number_custom(a,b,- 1,total);
              return - 1}
            if(tag_b == 1000)
             {if(tag_a == 1255)
               return caml_compare_val_number_custom(b,a,1,total);
              return 1}
            return tag_a < tag_b?- 1:1}
          switch(tag_a)
           {case 247:caml_invalid_argument("compare: functional value");break;
            case 248:
             var x=caml_int_compare(a[2],b[2]);if(x != 0)return x | 0;break;
            case 249:caml_invalid_argument("compare: functional value");break;
            case 250:
             caml_invalid_argument
              ("equal: got Forward_tag, should not happen");
             break;
            case 251:caml_invalid_argument("equal: abstract value");break;
            case 252:
             if(a !== b)
              {var x=caml_string_compare(a,b);if(x != 0)return x | 0}
             break;
            case 253:
             caml_invalid_argument("equal: got Double_tag, should not happen");
             break;
            case 254:
             caml_invalid_argument
              ("equal: got Double_array_tag, should not happen");
             break;
            case 255:
             var x=caml_int64_compare(a,b);if(x != 0)return x | 0;break;
            case 1247:
             caml_invalid_argument("compare: functional value");break;
            case 1255:
             var comp=caml_compare_val_get_custom(a);
             if(comp != caml_compare_val_get_custom(b))
              return a.caml_custom < b.caml_custom?- 1:1;
             if(! comp)caml_invalid_argument("compare: abstract value");
             var x=comp(a,b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1256:
             var x=a.compare(b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1000:
             a = + a;
             b = + b;
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1001:
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1251:if(a !== b){if(! total)return NaN;return 1}break;
            case 1252:
             var a=a.toString(),b=b.toString();
             if(a !== b){if(a < b)return - 1;if(a > b)return 1}
             break;
            case 246:
            case 254:
            default:
             if(a.length != b.length)return a.length < b.length?- 1:1;
             if(a.length > 1)stack.push(a,b,1);
             break}}
        if(stack.length == 0)return 0;
        var i=stack.pop();
        b = stack.pop();
        a = stack.pop();
        if(i + 1 < a.length)stack.push(a,b,i + 1);
        a = a[i];
        b = b[i]}}
    function caml_greaterthan(x,y){return + (caml_compare_val(x,y,false) > 0)}
    function div_helper(a,b,c)
     {var
       x=a * 65536 + (b >>> 16),
       y=Math.floor(x / c) * 65536,
       z=x % c * 65536,
       w=z + (b & 0x0000FFFF);
      return [y + Math.floor(w / c),w % c]}
    function div_digit_nat(natq,ofsq,natr,ofsr,nat1,ofs1,len,nat2,ofs2)
     {var rem=nat1.data[ofs1 + len - 1] >>> 0;
      for(var i=len - 2;i >= 0;i--)
       {var x=div_helper(rem,nat1.data[ofs1 + i] >>> 0,nat2.data[ofs2] >>> 0);
        natq.data[ofsq + i] = x[0];
        rem = x[1]}
      natr.data[ofsr] = rem;
      return 0}
    function num_leading_zero_bits_in_digit(nat,ofs)
     {var a=nat.data[ofs],b=0;
      if(a & 0xFFFF0000){b += 16;a >>>= 16}
      if(a & 0xFF00){b += 8;a >>>= 8}
      if(a & 0xF0){b += 4;a >>>= 4}
      if(a & 12){b += 2;a >>>= 2}
      if(a & 2){b += 1;a >>>= 1}
      if(a & 1)b += 1;
      return 32 - b}
    function shift_left_nat(nat1,ofs1,len1,nat2,ofs2,nbits)
     {if(nbits == 0){nat2.data[ofs2] = 0;return 0}
      var wrap=0;
      for(var i=0;i < len1;i++)
       {var a=nat1.data[ofs1 + i] >>> 0;
        nat1.data[ofs1 + i] = a << nbits | wrap;
        wrap = a >>> 32 - nbits}
      nat2.data[ofs2] = wrap;
      return 0}
    function MlNat(x)
     {this.data = new (joo_global_object.Int32Array)(x);
      this.length = this.data.length + 2}
    MlNat.prototype.caml_custom = "_nat";
    function create_nat(size)
     {var arr=new MlNat(size);
      for(var i=0;i < size;i++)arr.data[i] = - 1;
      return arr}
    function set_to_zero_nat(nat,ofs,len)
     {for(var i=0;i < len;i++)nat.data[ofs + i] = 0;return 0}
    function incr_nat(nat,ofs,len,carry_in)
     {var carry=carry_in;
      for(var i=0;i < len;i++)
       {var x=(nat.data[ofs + i] >>> 0) + carry;
        nat.data[ofs + i] = x | 0;
        if(x == x >>> 0){carry = 0;break}else carry = 1}
      return carry}
    function add_nat(nat1,ofs1,len1,nat2,ofs2,len2,carry_in)
     {var carry=carry_in;
      for(var i=0;i < len2;i++)
       {var
         x=
          (nat1.data[ofs1 + i] >>> 0) + (nat2.data[ofs2 + i] >>> 0) + carry;
        nat1.data[ofs1 + i] = x;
        if(x == x >>> 0)carry = 0;else carry = 1}
      return incr_nat(nat1,ofs1 + len2,len1 - len2,carry)}
    function nat_of_array(l){return new MlNat(l)}
    function mult_digit_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat3,ofs3)
     {var carry=0,a=nat3.data[ofs3] >>> 0;
      for(var i=0;i < len2;i++)
       {var
         x1=
          (nat1.data[ofs1 + i] >>> 0)
          +
          (nat2.data[ofs2 + i] >>> 0)
          *
          (a & 0x0000FFFF)
          +
          carry,
         x2=(nat2.data[ofs2 + i] >>> 0) * (a >>> 16);
        carry = Math.floor(x2 / 65536);
        var x3=x1 + x2 % 65536 * 65536;
        nat1.data[ofs1 + i] = x3;
        carry += Math.floor(x3 / 4294967296)}
      return len2 < len1 && carry
              ?add_nat
                (nat1,ofs1 + len2,len1 - len2,nat_of_array([carry]),0,1,0)
              :carry}
    function decr_nat(nat,ofs,len,carry_in)
     {var borrow=carry_in == 1?0:1;
      for(var i=0;i < len;i++)
       {var x=(nat.data[ofs + i] >>> 0) - borrow;
        nat.data[ofs + i] = x;
        if(x >= 0){borrow = 0;break}else borrow = 1}
      return borrow == 1?0:1}
    function sub_nat(nat1,ofs1,len1,nat2,ofs2,len2,carry_in)
     {var borrow=carry_in == 1?0:1;
      for(var i=0;i < len2;i++)
       {var
         x=
          (nat1.data[ofs1 + i] >>> 0) - (nat2.data[ofs2 + i] >>> 0) - borrow;
        nat1.data[ofs1 + i] = x;
        if(x >= 0)borrow = 0;else borrow = 1}
      return decr_nat(nat1,ofs1 + len2,len1 - len2,borrow == 1?0:1)}
    function compare_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {var a=num_digits_nat(nat1,ofs1,len1),b=num_digits_nat(nat2,ofs2,len2);
      if(a > b)return 1;
      if(a < b)return - 1;
      for(var i=len1 - 1;i >= 0;i--)
       {if(nat1.data[ofs1 + i] >>> 0 > nat2.data[ofs2 + i] >>> 0)return 1;
        if(nat1.data[ofs1 + i] >>> 0 < nat2.data[ofs2 + i] >>> 0)return - 1}
      return 0}
    function div_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {if(len2 == 1)
       {div_digit_nat(nat1,ofs1 + 1,nat1,ofs1,nat1,ofs1,len1,nat2,ofs2);
        return 0}
      var s=num_leading_zero_bits_in_digit(nat2,ofs2 + len2 - 1);
      shift_left_nat(nat2,ofs2,len2,nat_of_array([0]),0,s);
      shift_left_nat(nat1,ofs1,len1,nat_of_array([0]),0,s);
      var d=(nat2.data[ofs2 + len2 - 1] >>> 0) + 1,a=create_nat(len2 + 1);
      for(var i=len1 - 1;i >= len2;i--)
       {var
         quo=
          d == 4294967296
           ?nat1.data[ofs1 + i] >>> 0
           :div_helper
              (nat1.data[ofs1 + i] >>> 0,nat1.data[ofs1 + i - 1] >>> 0,d)
             [0];
        set_to_zero_nat(a,0,len2 + 1);
        mult_digit_nat(a,0,len2 + 1,nat2,ofs2,len2,nat_of_array([quo]),0);
        sub_nat(nat1,ofs1 + i - len2,len2 + 1,a,0,len2 + 1,1);
        while
         (nat1.data[ofs1 + i]
          !=
          0
          ||
          compare_nat(nat1,ofs1 + i - len2,len2,nat2,ofs2,len2)
          >=
          0)
         {quo = quo + 1;
          sub_nat(nat1,ofs1 + i - len2,len2 + 1,nat2,ofs2,len2,1)}
        nat1.data[ofs1 + i] = quo}
      shift_right_nat(nat1,ofs1,len2,nat_of_array([0]),0,s);
      shift_right_nat(nat2,ofs2,len2,nat_of_array([0]),0,s);
      return 0}
    function caml_ba_blit(src,dst)
     {if(dst.dims.length != src.dims.length)
       caml_invalid_argument("Bigarray.blit: dimension mismatch");
      for(var i=0;i < dst.dims.length;i++)
       if(dst.dims[i] != src.dims[i])
        caml_invalid_argument("Bigarray.blit: dimension mismatch");
      dst.data.set(src.data);
      return 0}
    function is_digit_int(nat,ofs){if(nat.data[ofs] >= 0)return 1;return 0}
    function caml_raise_zero_divide()
     {caml_raise_constant(caml_global_data.Division_by_zero)}
    function caml_int64_div(x,y)
     {if(caml_int64_is_zero(y))caml_raise_zero_divide();
      var sign=x[3] ^ y[3];
      if(x[3] & 0x8000)x = caml_int64_neg(x);
      if(y[3] & 0x8000)y = caml_int64_neg(y);
      var q=caml_int64_udivmod(x,y)[1];
      if(sign & 0x8000)q = caml_int64_neg(q);
      return q}
    function caml_js_html_entities(s)
     {var entity=/^&#?[0-9a-zA-Z]+;$/;
      if(s.match(entity))
       {var str,temp=document.createElement("p");
        temp.innerHTML = s;
        str = temp.textContent || temp.innerText;
        temp = null;
        return str}
      else
       caml_failwith("Invalid entity " + s)}
    function caml_string_unsafe_set(s,i,c)
     {return caml_bytes_unsafe_set(s,i,c)}
    var caml_int64_offset=Math.pow(2,- 24);
    function caml_int64_of_float(x)
     {if(x < 0)x = Math.ceil(x);
      return [255,
              x & 0xffffff,
              Math.floor(x * caml_int64_offset) & 0xffffff,
              Math.floor(x * caml_int64_offset * caml_int64_offset) & 0xffff]}
    function caml_ml_channel_size_64(chanid)
     {var chan=caml_ml_channels[chanid];
      return caml_int64_of_float(chan.file.length())}
    function caml_ba_set_2(ba,i0,i1,v){ba.set(ba.offset([i0,i1]),v);return 0}
    var
     caml_argv=
      function()
        {var g=joo_global_object,main="a.out",args=[];
         if(g.process && g.process.argv && g.process.argv.length > 1)
          {var argv=g.process.argv;
           main = argv[1];
           args = raw_array_sub(argv,2,argv.length - 2)}
         var p=caml_js_to_string(main),args2=[0,p];
         for(var i=0;i < args.length;i++)
          args2.push(caml_js_to_string(args[i]));
         return args2}
       (),
     caml_executable_name=caml_argv[1];
    function caml_bytes_compare(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?- 1:s1.c > s2.c?1:0}
    function caml_js_eval_string(s){return eval(s.toString())}
    function caml_CamlinternalMod_init_mod(loc,shape)
     {function undef_module(_x)
       {caml_raise_with_arg(caml_global_data.Undefined_recursive_module,loc)}
      function loop(shape,struct,idx)
       {if(typeof shape === "number")
         switch(shape)
          {case 0:struct[idx] = {fun:undef_module};break;
           case 1:struct[idx] = [246,undef_module];break;
           default:struct[idx] = []}
        else
         switch(shape[0])
          {case 0:
            struct[idx] = [0];
            for(var i=1;i < shape[1].length;i++)
             loop(shape[1][i],struct[idx],i);
            break;
           default:struct[idx] = shape[1]}}
      var res=[];
      loop(shape,res,0);
      return res[0]}
    function serialize_nat(writer,nat,sz)
     {var len=nat.data.length;
      writer.write(32,len);
      for(var i=0;i < len;i++)writer.write(32,nat.data[i]);
      sz[0] = len * 4;
      sz[1] = len * 8}
    function caml_memprof_set(_control){return 0}
    function caml_sys_exit(code)
     {var g=joo_global_object;
      if(g.quit)g.quit(code);
      if(g.process && g.process.exit)g.process.exit(code);
      caml_invalid_argument("Function 'exit' not implemented")}
    function caml_js_from_array(a){return raw_array_sub(a,1,a.length - 1)}
    function caml_ba_reshape(ba,vind)
     {vind = caml_js_from_array(vind);
      var new_dim=[],num_dims=vind.length;
      if(num_dims < 0 || num_dims > 16)
       caml_invalid_argument("Bigarray.reshape: bad number of dimensions");
      var num_elts=1;
      for(var i=0;i < num_dims;i++)
       {new_dim[i] = vind[i];
        if(new_dim[i] < 0)
         caml_invalid_argument("Bigarray.reshape: negative dimension");
        num_elts = num_elts * new_dim[i]}
      var size=caml_ba_get_size(ba.dims);
      if(num_elts != size)
       caml_invalid_argument("Bigarray.reshape: size mismatch");
      return caml_ba_create_unsafe(ba.kind,ba.layout,new_dim,ba.data)}
    var caml_oo_last_id=0;
    function caml_set_oo_id(b){b[2] = caml_oo_last_id++;return b}
    function caml_bigstring_blit_string_to_ba(str1,pos1,ba2,pos2,len)
     {if(12 != ba2.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs2=ba2.offset(pos2);
      if(pos1 + len > str1.l)caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=caml_array_of_string(str1).slice(pos1,pos1 + len);
      ba2.data.set(slice,ofs2);
      return 0}
    function caml_get_global_data(){return caml_global_data}
    function caml_int64_shift_right_unsigned(x,s)
     {s = s & 63;
      if(s == 0)return x;
      if(s < 24)
       return [255,
               (x[1] >> s | x[2] << 24 - s) & 0xffffff,
               (x[2] >> s | x[3] << 24 - s) & 0xffffff,
               x[3] >> s];
      if(s < 48)
       return [255,
               (x[2] >> s - 24 | x[3] << 48 - s) & 0xffffff,
               x[3] >> s - 24,
               0];
      return [255,x[3] >> s - 48,0,0]}
    function caml_ba_uint8_get16(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 1 >= ba.data.length)caml_array_bound_error();
      var b1=ba.get(ofs),b2=ba.get(ofs + 1);
      return b1 | b2 << 8}
    function caml_compare(a,b){return caml_compare_val(a,b,true)}
    function caml_fresh_oo_id(){return caml_oo_last_id++}
    function caml_int64_to_float(x)
     {return (x[3] << 16) * Math.pow(2,32) + x[2] * Math.pow(2,24) + x[1]}
    function caml_ba_get_1(ba,i0){return ba.get(ba.offset(i0))}
    function caml_bigstring_memcmp(s1,pos1,s2,pos2,len)
     {for(var i=0;i < len;i++)
       {var a=caml_ba_get_1(s1,pos1 + i),b=caml_ba_get_1(s2,pos2 + i);
        if(a < b)return - 1;
        if(a > b)return 1}
      return 0}
    function caml_raw_backtrace_length(){return 0}
    function caml_ba_uint8_get32(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 3 >= ba.data.length)caml_array_bound_error();
      var
       b1=ba.get(ofs + 0),
       b2=ba.get(ofs + 1),
       b3=ba.get(ofs + 2),
       b4=ba.get(ofs + 3);
      return b1 << 0 | b2 << 8 | b3 << 16 | b4 << 24}
    function caml_obj_block(tag,size)
     {var o=new Array(size + 1);
      o[0] = tag;
      for(var i=1;i <= size;i++)o[i] = 0;
      return o}
    function bigstring_to_array_buffer(bs){return bs.data.buffer}
    function lxor_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] ^= nat2.data[ofs2];return 0}
    function caml_final_release(){return 0}
    function raw_array_cons(a,x)
     {var l=a.length,b=new Array(l + 1);
      b[0] = x;
      for(var i=1;i <= l;i++)b[i] = a[i - 1];
      return b}
    function caml_js_to_array(a){return raw_array_cons(a,0)}
    function caml_bytes_set64(s,i,i64)
     {if(i >>> 0 >= s.l - 7)caml_string_bound_error();
      var a=caml_int64_to_bytes(i64);
      for(var j=0;j < 8;j++)caml_string_unsafe_set(s,i + 7 - j,a[j]);
      return 0}
    function caml_bytes_set16(s,i,i16)
     {if(i >>> 0 >= s.l - 1)caml_string_bound_error();
      var b2=0xFF & i16 >> 8,b1=0xFF & i16;
      caml_string_unsafe_set(s,i + 0,b1);
      caml_string_unsafe_set(s,i + 1,b2);
      return 0}
    function caml_string_set16(s,i,i16){return caml_bytes_set16(s,i,i16)}
    function caml_int64_bswap(x)
     {var y=caml_int64_to_bytes(x);
      return caml_int64_of_bytes([y[7],y[6],y[5],y[4],y[3],y[2],y[1],y[0]])}
    function caml_fill_bytes(s,i,l,c)
     {if(l > 0)
       if(i == 0 && (l >= s.l || s.t == 2 && l >= s.c.length))
        if(c == 0)
         {s.c = "";s.t = 2}
        else
         {s.c = caml_str_repeat(l,String.fromCharCode(c));s.t = l == s.l?0:2}
       else
        {if(s.t != 4)caml_convert_string_to_array(s);
         for(l += i;i < l;i++)s.c[i] = c}
      return 0}
    var caml_fill_string=caml_fill_bytes;
    function caml_gc_major(){return 0}
    function caml_lex_array(s)
     {s = caml_jsbytes_of_string(s);
      var l=s.length / 2,a=new Array(l);
      for(var i=0;i < l;i++)
       a[i]
       =
       (s.charCodeAt(2 * i) | s.charCodeAt(2 * i + 1) << 8)
       <<
       16
       >>
       16;
      return a}
    function caml_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      var c,state=start_state,buffer=caml_array_of_string(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)return - base - 1;
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        if(tbl.lex_check[base + c] == state)
         state = tbl.lex_trans[base + c];
        else
         state = tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         if(c == 256)lexbuf[lex_eof_reached] = 0}}
    function caml_sys_file_exists(name)
     {var root=resolve_fs_device(name);return root.device.exists(root.rest)}
    function caml_convert_raw_backtrace_slot()
     {caml_failwith("caml_convert_raw_backtrace_slot")}
    function caml_array_sub(a,i,len)
     {var a2=new Array(len + 1);
      a2[0] = 0;
      for(var i2=1,i1=i + 1;i2 <= len;i2++,i1++)a2[i2] = a[i1];
      return a2}
    function caml_bytes_equal(s1,s2)
     {if(s1 === s2)return 1;
      s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c == s2.c?1:0}
    function caml_sys_const_ostype_cygwin(){return 0}
    function caml_cosh_float(x){return (Math.exp(x) + Math.exp(- x)) / 2}
    var caml_ephe_key_offset=3;
    function caml_weak_check(x,i)
     {return x[caml_ephe_key_offset + i]
              !==
              undefined
              &&
              x[caml_ephe_key_offset + i]
              !==
              0
              ?1
              :0}
    var caml_ephe_check_key=caml_weak_check;
    function caml_hash_mix_final(h)
     {h ^= h >>> 16;
      h = caml_mul(h,0x85ebca6b | 0);
      h ^= h >>> 13;
      h = caml_mul(h,0xc2b2ae35 | 0);
      h ^= h >>> 16;
      return h}
    function caml_lex_run_mem(s,i,mem,curr_pos)
     {for(;;)
       {var dst=s.charCodeAt(i);
        i++;
        if(dst == 0xff)return;
        var src=s.charCodeAt(i);
        i++;
        if(src == 0xff)
         mem[dst + 1] = curr_pos;
        else
         mem[dst + 1] = mem[src + 1]}}
    function caml_lex_run_tag(s,i,mem)
     {for(;;)
       {var dst=s.charCodeAt(i);
        i++;
        if(dst == 0xff)return;
        var src=s.charCodeAt(i);
        i++;
        if(src == 0xff)mem[dst + 1] = - 1;else mem[dst + 1] = mem[src + 1]}}
    function caml_new_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_mem=10,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5,
       lex_base_code=6,
       lex_backtrk_code=7,
       lex_default_code=8,
       lex_trans_code=9,
       lex_check_code=10,
       lex_code=11;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      if(! tbl.lex_default_code)
       {tbl.lex_base_code = caml_lex_array(tbl[lex_base_code]);
        tbl.lex_backtrk_code = caml_lex_array(tbl[lex_backtrk_code]);
        tbl.lex_check_code = caml_lex_array(tbl[lex_check_code]);
        tbl.lex_trans_code = caml_lex_array(tbl[lex_trans_code]);
        tbl.lex_default_code = caml_lex_array(tbl[lex_default_code])}
      if(tbl.lex_code == null)
       tbl.lex_code = caml_jsbytes_of_string(tbl[lex_code]);
      var c,state=start_state,buffer=caml_array_of_string(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)
         {var pc_off=tbl.lex_base_code[state];
          caml_lex_run_tag(tbl.lex_code,pc_off,lexbuf[lex_mem]);
          return - base - 1}
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {var pc_off=tbl.lex_backtrk_code[state];
          caml_lex_run_tag(tbl.lex_code,pc_off,lexbuf[lex_mem]);
          lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        var pstate=state;
        if(tbl.lex_check[base + c] == state)
         state = tbl.lex_trans[base + c];
        else
         state = tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         {var base_code=tbl.lex_base_code[pstate],pc_off;
          if(tbl.lex_check_code[base_code + c] == pstate)
           pc_off = tbl.lex_trans_code[base_code + c];
          else
           pc_off = tbl.lex_default_code[pstate];
          if(pc_off > 0)
           caml_lex_run_mem
            (tbl.lex_code,pc_off,lexbuf[lex_mem],lexbuf[lex_curr_pos]);
          if(c == 256)lexbuf[lex_eof_reached] = 0}}}
    function caml_ba_uint8_set64(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 7 >= ba.data.length)caml_array_bound_error();
      var v=caml_int64_to_bytes(v);
      for(var i=0;i < 8;i++)ba.set(ofs + i,v[7 - i]);
      return 0}
    function caml_sys_executable_name(a){return caml_executable_name}
    function caml_lessequal(x,y){return + (caml_compare_val(x,y,false) <= 0)}
    function caml_ml_flush(chanid)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)caml_raise_sys_error("Cannot flush a closed channel");
      if(! chan.buffer || chan.buffer == "")return 0;
      if
       (chan.fd
        &&
        caml_global_data.fds[chan.fd]
        &&
        caml_global_data.fds[chan.fd].output)
       {var output=caml_global_data.fds[chan.fd].output;
        switch(output.length)
         {case 2:output(chanid,chan.buffer);break;default:output(chan.buffer)}}
      chan.buffer = "";
      return 0}
    function caml_ml_seek_out_64(chanid,pos)
     {caml_ml_flush(chanid);
      caml_ml_channels[chanid].offset = caml_int64_to_float(pos);
      return 0}
    function compare_nat_real(nat1,nat2)
     {return compare_nat(nat1,0,nat1.data.length,nat2,0,nat2.data.length)}
    function caml_gc_set(_control){return 0}
    function caml_js_get(o,f){return o[f]}
    function caml_gc_compaction(){return 0}
    function caml_weak_get(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_key");
      return x[caml_ephe_key_offset + i] === undefined
              ?0
              :x[caml_ephe_key_offset + i]}
    var caml_ephe_get_key=caml_weak_get;
    function win_cleanup(){}
    function caml_sys_close(fd){delete caml_global_data.fds[fd];return 0}
    function caml_ml_close_channel(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_flush(chanid);
      chan.opened = false;
      chan.file.close();
      caml_sys_close(chan.fd);
      return 0}
    function caml_exn_with_js_backtrace(exn,force)
     {if(! exn.js_error || force || exn[0] == 248)
       exn.js_error
       =
       new (joo_global_object.Error)("Js exception containing backtrace");
      return exn}
    function caml_sys_isatty(_chan){return 0}
    function is_digit_zero(nat,ofs){if(nat.data[ofs] == 0)return 1;return 0}
    function unix_inet_addr_of_string(){return 0}
    function caml_js_set(o,f,v){o[f] = v;return 0}
    function caml_array_get(array,index)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      return array[index + 1]}
    function caml_spacetime_only_works_for_native_code()
     {caml_failwith("Spacetime profiling only works for native code")}
    function caml_ml_seek_in_64(chanid,pos)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill != null)caml_raise_sys_error("Illegal seek");
      chan.offset = caml_int64_to_float(pos);
      return 0}
    function caml_notequal(x,y){return + (caml_compare_val(x,y,false) != 0)}
    function caml_int64_shift_left(x,s)
     {s = s & 63;
      if(s == 0)return x;
      if(s < 24)
       return [255,
               x[1] << s & 0xffffff,
               (x[2] << s | x[1] >> 24 - s) & 0xffffff,
               (x[3] << s | x[2] >> 24 - s) & 0xffff];
      if(s < 48)
       return [255,
               0,
               x[1] << s - 24 & 0xffffff,
               (x[2] << s - 24 | x[1] >> 48 - s) & 0xffff];
      return [255,0,0,x[1] << s - 48 & 0xffff]}
    function caml_sys_const_int_size(){return 32}
    function caml_js_wrap_meth_callback(f)
     {return function()
       {return caml_call_gen(f,raw_array_cons(arguments,this))}}
    function caml_is_js(){return 1}
    function caml_ba_dim(ba,i)
     {if(i < 0 || i >= ba.dims.length)caml_invalid_argument("Bigarray.dim");
      return ba.dims[i]}
    function caml_ba_dim_1(ba){return caml_ba_dim(ba,0)}
    function unix_localtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(d.getFullYear(),0,1).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000),
       jan=new Date(d.getFullYear(),0,1),
       jul=new Date(d.getFullYear(),6,1),
       stdTimezoneOffset=
        Math.max(jan.getTimezoneOffset(),jul.getTimezoneOffset());
      return [0,
              d.getSeconds(),
              d.getMinutes(),
              d.getHours(),
              d.getDate(),
              d.getMonth(),
              d.getFullYear() - 1900,
              d.getDay(),
              doy,
              d.getTimezoneOffset() < stdTimezoneOffset | 0]}
    function caml_js_meth_call(o,f,args)
     {return o[f.toString()].apply(o,caml_js_from_array(args))}
    function caml_weak_create(n)
     {if(n < 0)caml_invalid_argument("Weak.create");
      var x=[251,"caml_ephe_list_head"];
      x.length = caml_ephe_key_offset + n;
      return x}
    var caml_ephe_create=caml_weak_create;
    function caml_js_to_byte_string(s){return caml_new_string(s)}
    function unix_mktime(tm)
     {var
       d=new Date(tm[6] + 1900,tm[5],tm[4],tm[3],tm[2],tm[1]).getTime(),
       t=Math.floor(d / 1000),
       tm2=unix_localtime(t);
      return [0,t,tm2]}
    function caml_trampoline(res)
     {var c=1;
      while(res && res.joo_tramp)
       {res = res.joo_tramp.apply(null,res.joo_args);c++}
      return res}
    function caml_bytes_get64(s,i)
     {if(i >>> 0 >= s.l - 7)caml_string_bound_error();
      var a=new Array(8);
      for(var j=0;j < 8;j++)a[7 - j] = caml_string_unsafe_get(s,i + j);
      return caml_int64_of_bytes(a)}
    function caml_weak_set(x,i,v)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.set");
      x[caml_ephe_key_offset + i] = v;
      return 0}
    function caml_sys_remove(name)
     {var root=resolve_fs_device(name),ok=root.device.unlink(root.rest);
      if(ok == 0)caml_raise_no_such_file(name);
      return 0}
    function caml_string_get32(s,i)
     {if(i >>> 0 >= s.l - 3)caml_string_bound_error();
      var
       b1=caml_string_unsafe_get(s,i),
       b2=caml_string_unsafe_get(s,i + 1),
       b3=caml_string_unsafe_get(s,i + 2),
       b4=caml_string_unsafe_get(s,i + 3);
      return b4 << 24 | b3 << 16 | b2 << 8 | b1}
    function caml_hypot_float(x,y)
     {var
       x=Math.abs(x),
       y=Math.abs(y),
       a=Math.max(x,y),
       b=Math.min(x,y) / (a?a:1);
      return a * Math.sqrt(1 + b * b)}
    function caml_js_call(f,o,args)
     {return f.apply(o,caml_js_from_array(args))}
    function caml_sys_const_max_wosize(){return 0x7FFFFFFF / 4 | 0}
    function caml_ephe_unset_key(x,i){return caml_weak_set(x,i,0)}
    function caml_bytes_lessthan(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?1:0}
    function caml_gc_quick_stat(){return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
    function caml_raise_end_of_file()
     {caml_raise_constant(caml_global_data.End_of_file)}
    function caml_ml_input_int(chanid)
     {var chan=caml_ml_channels[chanid],file=chan.file;
      while(chan.offset + 3 >= file.length())
       {var l=caml_ml_refill_input(chan);if(l == 0)caml_raise_end_of_file()}
      var
       o=chan.offset,
       r=
        file.read_one(o)
        <<
        24
        |
        file.read_one(o + 1)
        <<
        16
        |
        file.read_one(o + 2)
        <<
        8
        |
        file.read_one(o + 3);
      chan.offset += 4;
      return r}
    function caml_array_blit(a1,i1,a2,i2,len)
     {if(i2 <= i1)
       for(var j=1;j <= len;j++)a2[i2 + j] = a1[i1 + j];
      else
       for(var j=len;j >= 1;j--)a2[i2 + j] = a1[i1 + j];
      return 0}
    function nth_digit_nat(nat,ofs){return nat.data[ofs]}
    function caml_float_of_string(s)
     {var res;
      s = caml_jsbytes_of_string(s);
      res = + s;
      if(s.length > 0 && res === res)return res;
      s = s.replace(/_/g,"");
      res = + s;
      if(s.length > 0 && res === res || /^[+-]?nan$/i.test(s))return res;
      var m=/^ *([+-]?)0x([0-9a-f]+)\.?([0-9a-f]*)p([+-]?[0-9]+)/i.exec(s);
      if(m)
       {var
         m3=m[3].replace(/0+$/,""),
         mantissa=parseInt(m[1] + m[2] + m3,16),
         exponent=(m[4] | 0) - 4 * m3.length;
        res = mantissa * Math.pow(2,exponent);
        return res}
      if(/^\+?inf(inity)?$/i.test(s))return Infinity;
      if(/^-inf(inity)?$/i.test(s))return - Infinity;
      caml_failwith("float_of_string")}
    function caml_sys_getcwd(){return caml_new_string(caml_current_dir)}
    function caml_sys_const_big_endian(){return 0}
    function caml_list_to_js_array(l)
     {var a=[];for(;l !== 0;l = l[2])a.push(l[1]);return a}
    var caml_legacy_custom_code=true;
    function caml_ml_string_length(s){return s.l}
    var
     caml_output_val=
      function()
        {function Writer(){this.chunk = []}
         Writer.prototype
         =
         {chunk_idx:20,
          block_len:0,
          obj_counter:0,
          size_32:0,
          size_64:0,
          write:
          function(size,value)
           {for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          write_at:
          function(pos,size,value)
           {var pos=pos;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[pos++] = value >> i & 0xFF},
          write_code:
          function(size,code,value)
           {this.chunk[this.chunk_idx++] = code;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          write_shared:
          function(offset)
           {if(offset < 1 << 8)
             this.write_code(8,0x04,offset);
            else
             if(offset < 1 << 16)
              this.write_code(16,0x05,offset);
             else
              this.write_code(32,0x06,offset)},
          pos:function(){return this.chunk_idx},
          finalize:
          function()
           {this.block_len = this.chunk_idx - 20;
            this.chunk_idx = 0;
            this.write(32,0x8495A6BE);
            this.write(32,this.block_len);
            this.write(32,this.obj_counter);
            this.write(32,this.size_32);
            this.write(32,this.size_64);
            return this.chunk}};
         return function(v,flags)
          {flags = caml_list_to_js_array(flags);
           var
            no_sharing=flags.indexOf(0) !== - 1,
            closures=flags.indexOf(1) !== - 1;
           if(closures)
            joo_global_object.console.warn
             ("in caml_output_val: flag Marshal.Closures is not supported.");
           var
            writer=new Writer(),
            stack=[],
            intern_obj_table=no_sharing?null:new MlObjectTable();
           function memo(v)
            {if(no_sharing)return false;
             var existing_offset=intern_obj_table.recall(v);
             if(existing_offset)
              {writer.write_shared(existing_offset);return true}
             else
              {intern_obj_table.store(v);return false}}
           function extern_rec(v)
            {if(v.caml_custom || v instanceof Array && v[0] === 255)
              {if(memo(v))return;
               var
                name=v.caml_custom || "_j",
                ops=caml_custom_ops[name],
                sz_32_64=[0,0];
               if(! ops.serialize)
                caml_invalid_argument("output_value: abstract value (Custom)");
               if(caml_legacy_custom_code)
                {writer.write(8,0x12);
                 for(var i=0;i < name.length;i++)
                  writer.write(8,name.charCodeAt(i));
                 writer.write(8,0);
                 ops.serialize(writer,v,sz_32_64)}
               else
                if(ops.fixed_length == undefined)
                 {writer.write(8,0x18);
                  for(var i=0;i < name.length;i++)
                   writer.write(8,name.charCodeAt(i));
                  writer.write(8,0);
                  var header_pos=writer.pos();
                  for(var i=0;i < 12;i++)writer.write(8,0);
                  ops.serialize(writer,v,sz_32_64);
                  writer.write_at(header_pos,32,sz_32_64[0]);
                  writer.write_at(header_pos + 4,32,0);
                  writer.write_at(header_pos + 8,32,sz_32_64[1])}
                else
                 {writer.write(8,0x19);
                  for(var i=0;i < name.length;i++)
                   writer.write(8,name.charCodeAt(i));
                  writer.write(8,0);
                  var old_pos=writer.pos();
                  ops.serialize(writer,v,sz_32_64);
                  if(ops.fixed_length != writer.pos() - old_pos)
                   caml_failwith
                    ("output_value: incorrect fixed sizes specified by " + name)}
               writer.size_32 += 2 + (sz_32_64[0] + 3 >> 2);
               writer.size_64 += 2 + (sz_32_64[1] + 7 >> 3)}
             else
              if(v instanceof Array && v[0] === (v[0] | 0))
               {if(v[0] == 251)
                 caml_failwith("output_value: abstract value (Abstract)");
                if(v.length > 1 && memo(v))return;
                if(v[0] < 16 && v.length - 1 < 8)
                 writer.write(8,0x80 + v[0] + (v.length - 1 << 4));
                else
                 writer.write_code(32,0x08,v.length - 1 << 10 | v[0]);
                writer.size_32 += v.length;
                writer.size_64 += v.length;
                if(v.length > 1)stack.push(v,1)}
              else
               if(v instanceof MlBytes)
                {if(memo(v))return;
                 var len=caml_ml_string_length(v);
                 if(len < 0x20)
                  writer.write(8,0x20 + len);
                 else
                  if(len < 0x100)
                   writer.write_code(8,0x09,len);
                  else
                   writer.write_code(32,0x0A,len);
                 for(var i=0;i < len;i++)
                  writer.write(8,caml_string_unsafe_get(v,i));
                 writer.size_32 += 1 + ((len + 4) / 4 | 0);
                 writer.size_64 += 1 + ((len + 8) / 8 | 0)}
               else
                if(v != (v | 0))
                 {var type_of_v=typeof v;
                  caml_failwith
                   ("output_value: abstract value (" + type_of_v + ")")}
                else
                 if(v >= 0 && v < 0x40)
                  writer.write(8,0X40 + v);
                 else
                  if(v >= - (1 << 7) && v < 1 << 7)
                   writer.write_code(8,0x00,v);
                  else
                   if(v >= - (1 << 15) && v < 1 << 15)
                    writer.write_code(16,0x01,v);
                   else
                    writer.write_code(32,0x02,v)}
           extern_rec(v);
           while(stack.length > 0)
            {var i=stack.pop(),v=stack.pop();
             if(i + 1 < v.length)stack.push(v,i + 1);
             extern_rec(v[i])}
           if(intern_obj_table)
            writer.obj_counter = intern_obj_table.objs.length;
           writer.finalize();
           return writer.chunk}}
       ();
    function caml_output_value_to_string(v,flags)
     {return caml_string_of_array(caml_output_val(v,flags))}
    function caml_raise_not_a_dir(name)
     {name = name instanceof MlBytes?name.toString():name;
      caml_raise_sys_error(name + ": Not a directory")}
    function caml_sys_system_command(cmd)
     {var cmd=cmd.toString();
      joo_global_object.console.log(cmd);
      if
       (typeof require
        !=
        "undefined"
        &&
        require("child_process")
        &&
        require("child_process").execSync)
       try {require("child_process").execSync(cmd);return 0}catch(e){return 1}
      else
       return 127}
    function caml_js_error_of_exception(exn)
     {if(exn.js_error)return exn.js_error;return null}
    function deserialize_nat(reader,sz)
     {var len=reader.read32s(),nat=new MlNat(len);
      for(var i=0;i < len;i++)nat.data[i] = reader.read32s();
      sz[0] = len * 4;
      return nat}
    function initialize_nat()
     {caml_custom_ops["_nat"]
      =
      {deserialize:deserialize_nat,serialize:serialize_nat,hash:caml_hash_nat}}
    function js_print_stdout(s)
     {var s=caml_utf16_of_utf8(s),g=joo_global_object;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stdout.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.log && v.log(s)}}
    function caml_copysign_float(x,y)
     {if(y == 0)y = 1 / y;x = Math.abs(x);return y < 0?- x:x}
    function caml_ba_set_generic(ba,i,v)
     {ba.set(ba.offset(caml_js_from_array(i)),v);return 0}
    function caml_ephe_set_key(x,i,v){return caml_weak_set(x,i,[0,v])}
    function caml_string_lessequal(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c <= s2.c?1:0}
    function caml_string_greaterequal(s1,s2)
     {return caml_string_lessequal(s2,s1)}
    function caml_int64_add(x,y)
     {var
       z1=x[1] + y[1],
       z2=x[2] + y[2] + (z1 >> 24),
       z3=x[3] + y[3] + (z2 >> 24);
      return [255,z1 & 0xffffff,z2 & 0xffffff,z3 & 0xffff]}
    function caml_nextafter_float(x,y)
     {if(isNaN(x) || isNaN(y))return NaN;
      if(x == y)return y;
      if(x == 0)return y < 0?- Math.pow(2,- 1074):Math.pow(2,- 1074);
      var bits=caml_int64_bits_of_float(x),one=caml_int64_of_int32(1);
      if(x < y == x > 0)
       bits = caml_int64_add(bits,one);
      else
       bits = caml_int64_sub(bits,one);
      return caml_int64_float_of_bits(bits)}
    function caml_ml_pos_in(chanid){return caml_ml_channels[chanid].offset}
    function caml_int64_and(x,y)
     {return [255,x[1] & y[1],x[2] & y[2],x[3] & y[3]]}
    function caml_sys_const_word_size(){return 32}
    function caml_std_output(chanid,s)
     {var
       chan=caml_ml_channels[chanid],
       str=caml_new_string(s),
       slen=caml_ml_string_length(str);
      chan.file.write(chan.offset,str,0,slen);
      chan.offset += slen;
      return 0}
    function js_print_stderr(s)
     {var s=caml_utf16_of_utf8(s),g=joo_global_object;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stderr.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.error && v.error(s)}}
    function caml_sys_open_internal(idx,output,file,flags)
     {if(caml_global_data.fds === undefined)
       caml_global_data.fds = new Array();
      flags = flags?flags:{};
      var info={};
      info.file = file;
      info.offset = flags.append?file.length():0;
      info.flags = flags;
      info.output = output;
      caml_global_data.fds[idx] = info;
      if(! caml_global_data.fd_last_idx || idx > caml_global_data.fd_last_idx)
       caml_global_data.fd_last_idx = idx;
      return idx}
    function caml_sys_open(name,flags,_perms)
     {var f={};
      while(flags)
       {switch(flags[1])
         {case 0:f.rdonly = 1;break;
          case 1:f.wronly = 1;break;
          case 2:f.append = 1;break;
          case 3:f.create = 1;break;
          case 4:f.truncate = 1;break;
          case 5:f.excl = 1;break;
          case 6:f.binary = 1;break;
          case 7:f.text = 1;break;
          case 8:f.nonblock = 1;break
          }
        flags = flags[2]}
      if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (name.toString()
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (name.toString()
         +
         " : flags Open_text and Open_binary are not compatible");
      var
       root=resolve_fs_device(name),
       file=root.device.open(root.rest,f),
       idx=caml_global_data.fd_last_idx?caml_global_data.fd_last_idx:0;
      return caml_sys_open_internal(idx + 1,caml_std_output,file,f)}
    caml_sys_open_internal
     (0,caml_std_output,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (1,js_print_stdout,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (2,js_print_stderr,new MlFakeFile(caml_create_bytes(0)));
    function MlBytesReader(s,i){this.s = caml_jsbytes_of_string(s);this.i = i}
    MlBytesReader.prototype
    =
    {read8u:function(){return this.s.charCodeAt(this.i++)},
     read8s:function(){return this.s.charCodeAt(this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 8 | s.charCodeAt(i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 24 >> 16 | s.charCodeAt(i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (s.charCodeAt(i)
               <<
               24
               |
               s.charCodeAt(i + 1)
               <<
               16
               |
               s.charCodeAt(i + 2)
               <<
               8
               |
               s.charCodeAt(i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return s.charCodeAt(i)
              <<
              24
              |
              s.charCodeAt(i + 1)
              <<
              16
              |
              s.charCodeAt(i + 2)
              <<
              8
              |
              s.charCodeAt(i + 3)},
     readstr:
     function(len)
      {var i=this.i;
       this.i = i + len;
       return caml_new_string(this.s.substring(i,i + len))}};
    function caml_float_of_bytes(a)
     {return caml_int64_float_of_bits(caml_int64_of_bytes(a))}
    function caml_input_value_from_reader(reader,ofs)
     {var
       _magic=reader.read32u(),
       _block_len=reader.read32u(),
       num_objects=reader.read32u(),
       _size_32=reader.read32u(),
       _size_64=reader.read32u(),
       stack=[],
       intern_obj_table=num_objects > 0?[]:null,
       obj_counter=0;
      function intern_rec()
       {var code=reader.read8u();
        if(code >= 0x40)
         if(code >= 0x80)
          {var tag=code & 0xF,size=code >> 4 & 0x7,v=[tag];
           if(size == 0)return v;
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           stack.push(v,size);
           return v}
         else
          return code & 0x3F;
        else
         if(code >= 0x20)
          {var len=code & 0x1F,v=reader.readstr(len);
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           return v}
         else
          switch(code)
           {case 0x00:return reader.read8s();
            case 0x01:return reader.read16s();
            case 0x02:return reader.read32s();
            case 0x03:caml_failwith("input_value: integer too large");break;
            case 0x04:
             var offset=reader.read8u();
             return intern_obj_table[obj_counter - offset];
            case 0x05:
             var offset=reader.read16u();
             return intern_obj_table[obj_counter - offset];
            case 0x06:
             var offset=reader.read32u();
             return intern_obj_table[obj_counter - offset];
            case 0x08:
             var
              header=reader.read32u(),
              tag=header & 0xFF,
              size=header >> 10,
              v=[tag];
             if(size == 0)return v;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             stack.push(v,size);
             return v;
            case 0x13:
             caml_failwith("input_value: data block too large");break;
            case 0x09:
             var len=reader.read8u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0A:
             var len=reader.read32u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0C:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[7 - i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0B:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0E:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x0D:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x07:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x0F:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x10:
            case 0x11:caml_failwith("input_value: code pointer");break;
            case 0x12:
            case 0x18:
            case 0x19:
             var c,s="";
             while((c = reader.read8u()) != 0)s += String.fromCharCode(c);
             var ops=caml_custom_ops[s],expected_size;
             if(! ops)
              caml_failwith("input_value: unknown custom block identifier");
             switch(code)
              {case 0x12:break;
               case 0x19:
                if(! ops.fixed_length)
                 caml_failwith
                  ("input_value: expected a fixed-size custom block");
                expected_size = ops.fixed_length;
                break;
               case 0x18:
                expected_size = reader.read32u();
                reader.read32s();
                reader.read32s();
                break
               }
             var old_pos=reader.i,size=[0],v=ops.deserialize(reader,size);
             if(expected_size != undefined)
              if(expected_size != size[0])
               caml_failwith
                ("input_value: incorrect length of serialized custom block");
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            default:caml_failwith("input_value: ill-formed message")}}
      var res=intern_rec();
      while(stack.length > 0)
       {var size=stack.pop(),v=stack.pop(),d=v.length;
        if(d < size)stack.push(v,size);
        v[d] = intern_rec()}
      if(typeof ofs != "number")ofs[0] = reader.i;
      return res}
    function caml_input_value_from_bytes(s,ofs)
     {var reader=new MlBytesReader(s,typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_js_from_string(s){return s.toString()}
    function caml_ba_sub(ba,ofs,len)
     {var changed_dim,mul=1;
      if(ba.layout == 0)
       {for(var i=1;i < ba.dims.length;i++)mul = mul * ba.dims[i];
        changed_dim = 0}
      else
       {for(var i=0;i < ba.dims.length - 1;i++)mul = mul * ba.dims[i];
        changed_dim = ba.dims.length - 1;
        ofs = ofs - 1}
      if(ofs < 0 || len < 0 || ofs + len > ba.dims[changed_dim])
       caml_invalid_argument("Bigarray.sub: bad sub-array");
      var new_dims=[];
      for(var i=0;i < ba.dims.length;i++)new_dims[i] = ba.dims[i];
      new_dims[changed_dim] = len;
      mul *= caml_ba_get_size_per_element(ba.kind);
      var new_data=ba.data.subarray(ofs * mul,(ofs + len) * mul);
      return caml_ba_create_unsafe(ba.kind,ba.layout,new_dims,new_data)}
    function caml_gc_full_major(){return 0}
    function caml_bytes_set32(s,i,i32)
     {if(i >>> 0 >= s.l - 3)caml_string_bound_error();
      var
       b4=0xFF & i32 >> 24,
       b3=0xFF & i32 >> 16,
       b2=0xFF & i32 >> 8,
       b1=0xFF & i32;
      caml_string_unsafe_set(s,i + 0,b1);
      caml_string_unsafe_set(s,i + 1,b2);
      caml_string_unsafe_set(s,i + 2,b3);
      caml_string_unsafe_set(s,i + 3,b4);
      return 0}
    function caml_int64_is_minus_one(x)
     {return x[3] == 0xffff && (x[1] & x[2]) == 0xffffff}
    function caml_ba_uint8_set32(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 3 >= ba.data.length)caml_array_bound_error();
      ba.set(ofs + 0,v & 0xff);
      ba.set(ofs + 1,v >>> 8 & 0xff);
      ba.set(ofs + 2,v >>> 16 & 0xff);
      ba.set(ofs + 3,v >>> 24 & 0xff);
      return 0}
    function caml_sys_const_ostype_unix(){return 1}
    function caml_signbit_float(x){if(x == 0)x = 1 / x;return x < 0?1:0}
    function caml_ml_seek_out(chanid,pos)
     {caml_ml_flush(chanid);caml_ml_channels[chanid].offset = pos;return 0}
    function caml_restore_raw_backtrace(exn,bt){return 0}
    function caml_js_typeof(o){return typeof o}
    function caml_js_wrap_meth_callback_unsafe(f)
     {return function(){f.apply(null,raw_array_cons(arguments,this))}}
    function caml_ba_dim_3(ba){return caml_ba_dim(ba,2)}
    var caml_ephe_data_offset=2;
    function caml_ephe_check_data(x)
     {return x[caml_ephe_data_offset] === undefined?0:1}
    function caml_bytes_get16(s,i)
     {if(i >>> 0 >= s.l - 1)caml_string_bound_error();
      var b1=caml_string_unsafe_get(s,i),b2=caml_string_unsafe_get(s,i + 1);
      return b2 << 8 | b1}
    function caml_obj_make_forward(b,v){b[0] = 250;b[1] = v;return 0}
    function caml_js_from_bool(x){return ! ! x}
    function caml_ml_set_channel_name(){return 0}
    function caml_create_string(len)
     {if(len < 0)caml_invalid_argument("String.create");
      return new MlBytes(len?2:9,"",len)}
    var
     caml_md5_string=
      function()
        {function add(x,y){return x + y | 0}
         function xx(q,a,b,x,s,t)
          {a = add(add(a,q),add(x,t));return add(a << s | a >>> 32 - s,b)}
         function ff(a,b,c,d,x,s,t){return xx(b & c | ~ b & d,a,b,x,s,t)}
         function gg(a,b,c,d,x,s,t){return xx(b & d | c & ~ d,a,b,x,s,t)}
         function hh(a,b,c,d,x,s,t){return xx(b ^ c ^ d,a,b,x,s,t)}
         function ii(a,b,c,d,x,s,t){return xx(c ^ (b | ~ d),a,b,x,s,t)}
         function md5(buffer,length)
          {var i=length;
           buffer[i >> 2] |= 0x80 << 8 * (i & 3);
           for(i = (i & ~ 0x3) + 8;(i & 0x3F) < 60;i += 4)
            buffer[(i >> 2) - 1] = 0;
           buffer[(i >> 2) - 1] = length << 3;
           buffer[i >> 2] = length >> 29 & 0x1FFFFFFF;
           var w=[0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476];
           for(i = 0;i < buffer.length;i += 16)
            {var a=w[0],b=w[1],c=w[2],d=w[3];
             a = ff(a,b,c,d,buffer[i + 0],7,0xD76AA478);
             d = ff(d,a,b,c,buffer[i + 1],12,0xE8C7B756);
             c = ff(c,d,a,b,buffer[i + 2],17,0x242070DB);
             b = ff(b,c,d,a,buffer[i + 3],22,0xC1BDCEEE);
             a = ff(a,b,c,d,buffer[i + 4],7,0xF57C0FAF);
             d = ff(d,a,b,c,buffer[i + 5],12,0x4787C62A);
             c = ff(c,d,a,b,buffer[i + 6],17,0xA8304613);
             b = ff(b,c,d,a,buffer[i + 7],22,0xFD469501);
             a = ff(a,b,c,d,buffer[i + 8],7,0x698098D8);
             d = ff(d,a,b,c,buffer[i + 9],12,0x8B44F7AF);
             c = ff(c,d,a,b,buffer[i + 10],17,0xFFFF5BB1);
             b = ff(b,c,d,a,buffer[i + 11],22,0x895CD7BE);
             a = ff(a,b,c,d,buffer[i + 12],7,0x6B901122);
             d = ff(d,a,b,c,buffer[i + 13],12,0xFD987193);
             c = ff(c,d,a,b,buffer[i + 14],17,0xA679438E);
             b = ff(b,c,d,a,buffer[i + 15],22,0x49B40821);
             a = gg(a,b,c,d,buffer[i + 1],5,0xF61E2562);
             d = gg(d,a,b,c,buffer[i + 6],9,0xC040B340);
             c = gg(c,d,a,b,buffer[i + 11],14,0x265E5A51);
             b = gg(b,c,d,a,buffer[i + 0],20,0xE9B6C7AA);
             a = gg(a,b,c,d,buffer[i + 5],5,0xD62F105D);
             d = gg(d,a,b,c,buffer[i + 10],9,0x02441453);
             c = gg(c,d,a,b,buffer[i + 15],14,0xD8A1E681);
             b = gg(b,c,d,a,buffer[i + 4],20,0xE7D3FBC8);
             a = gg(a,b,c,d,buffer[i + 9],5,0x21E1CDE6);
             d = gg(d,a,b,c,buffer[i + 14],9,0xC33707D6);
             c = gg(c,d,a,b,buffer[i + 3],14,0xF4D50D87);
             b = gg(b,c,d,a,buffer[i + 8],20,0x455A14ED);
             a = gg(a,b,c,d,buffer[i + 13],5,0xA9E3E905);
             d = gg(d,a,b,c,buffer[i + 2],9,0xFCEFA3F8);
             c = gg(c,d,a,b,buffer[i + 7],14,0x676F02D9);
             b = gg(b,c,d,a,buffer[i + 12],20,0x8D2A4C8A);
             a = hh(a,b,c,d,buffer[i + 5],4,0xFFFA3942);
             d = hh(d,a,b,c,buffer[i + 8],11,0x8771F681);
             c = hh(c,d,a,b,buffer[i + 11],16,0x6D9D6122);
             b = hh(b,c,d,a,buffer[i + 14],23,0xFDE5380C);
             a = hh(a,b,c,d,buffer[i + 1],4,0xA4BEEA44);
             d = hh(d,a,b,c,buffer[i + 4],11,0x4BDECFA9);
             c = hh(c,d,a,b,buffer[i + 7],16,0xF6BB4B60);
             b = hh(b,c,d,a,buffer[i + 10],23,0xBEBFBC70);
             a = hh(a,b,c,d,buffer[i + 13],4,0x289B7EC6);
             d = hh(d,a,b,c,buffer[i + 0],11,0xEAA127FA);
             c = hh(c,d,a,b,buffer[i + 3],16,0xD4EF3085);
             b = hh(b,c,d,a,buffer[i + 6],23,0x04881D05);
             a = hh(a,b,c,d,buffer[i + 9],4,0xD9D4D039);
             d = hh(d,a,b,c,buffer[i + 12],11,0xE6DB99E5);
             c = hh(c,d,a,b,buffer[i + 15],16,0x1FA27CF8);
             b = hh(b,c,d,a,buffer[i + 2],23,0xC4AC5665);
             a = ii(a,b,c,d,buffer[i + 0],6,0xF4292244);
             d = ii(d,a,b,c,buffer[i + 7],10,0x432AFF97);
             c = ii(c,d,a,b,buffer[i + 14],15,0xAB9423A7);
             b = ii(b,c,d,a,buffer[i + 5],21,0xFC93A039);
             a = ii(a,b,c,d,buffer[i + 12],6,0x655B59C3);
             d = ii(d,a,b,c,buffer[i + 3],10,0x8F0CCC92);
             c = ii(c,d,a,b,buffer[i + 10],15,0xFFEFF47D);
             b = ii(b,c,d,a,buffer[i + 1],21,0x85845DD1);
             a = ii(a,b,c,d,buffer[i + 8],6,0x6FA87E4F);
             d = ii(d,a,b,c,buffer[i + 15],10,0xFE2CE6E0);
             c = ii(c,d,a,b,buffer[i + 6],15,0xA3014314);
             b = ii(b,c,d,a,buffer[i + 13],21,0x4E0811A1);
             a = ii(a,b,c,d,buffer[i + 4],6,0xF7537E82);
             d = ii(d,a,b,c,buffer[i + 11],10,0xBD3AF235);
             c = ii(c,d,a,b,buffer[i + 2],15,0x2AD7D2BB);
             b = ii(b,c,d,a,buffer[i + 9],21,0xEB86D391);
             w[0] = add(a,w[0]);
             w[1] = add(b,w[1]);
             w[2] = add(c,w[2]);
             w[3] = add(d,w[3])}
           var t=new Array(16);
           for(var i=0;i < 4;i++)
            for(var j=0;j < 4;j++)t[i * 4 + j] = w[i] >> 8 * j & 0xFF;
           return t}
         return function(s,ofs,len)
          {var buf=[];
           switch(s.t & 6)
            {default:caml_convert_string_to_bytes(s);case 0:
              var b=s.c;
              for(var i=0;i < len;i += 4)
               {var j=i + ofs;
                buf[i >> 2]
                =
                b.charCodeAt(j)
                |
                b.charCodeAt(j + 1)
                <<
                8
                |
                b.charCodeAt(j + 2)
                <<
                16
                |
                b.charCodeAt(j + 3)
                <<
                24}
              for(;i < len;i++)
               buf[i >> 2] |= b.charCodeAt(i + ofs) << 8 * (i & 3);
              break;
             case 4:
              var a=s.c;
              for(var i=0;i < len;i += 4)
               {var j=i + ofs;
                buf[i >> 2]
                =
                a[j]
                |
                a[j + 1]
                <<
                8
                |
                a[j + 2]
                <<
                16
                |
                a[j + 3]
                <<
                24}
              for(;i < len;i++)buf[i >> 2] |= a[i + ofs] << 8 * (i & 3)
             }
           return caml_string_of_array(md5(buf,len))}}
       ();
    function caml_md5_chan(chanid,len)
     {var chan=caml_ml_channels[chanid],chan_len=chan.file.length();
      if(len < 0)len = chan_len - chan.offset;
      if(chan.offset + len > chan_len)caml_raise_end_of_file();
      var buf=caml_create_bytes(len);
      chan.file.read(chan.offset,buf,0,len);
      return caml_md5_string(buf,0,len)}
    function caml_weak_get_copy(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_copy");
      var y=caml_weak_get(x,i);
      if(y === 0)return y;
      var z=y[1];
      if(z instanceof Array)return [0,caml_obj_dup(z)];
      return y}
    function caml_ml_output_bytes(chanid,buffer,offset,len)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)
       caml_raise_sys_error("Cannot output to a closed channel");
      var string;
      if(offset == 0 && caml_ml_bytes_length(buffer) == len)
       string = buffer;
      else
       {string = caml_create_bytes(len);
        caml_blit_bytes(buffer,offset,string,0,len)}
      var
       jsstring=caml_jsbytes_of_string(string),
       id=jsstring.lastIndexOf("\n");
      if(id < 0)
       chan.buffer += jsstring;
      else
       {chan.buffer += jsstring.substr(0,id + 1);
        caml_ml_flush(chanid);
        chan.buffer += jsstring.substr(id + 1)}
      return 0}
    function caml_ml_output(chanid,buffer,offset,len)
     {return caml_ml_output_bytes(chanid,buffer,offset,len)}
    function caml_ephe_get_data(x)
     {return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,x[caml_ephe_data_offset]]}
    function caml_trampoline_return(f,args)
     {return {joo_tramp:f,joo_args:args}}
    function caml_array_append(a1,a2)
     {var l1=a1.length,l2=a2.length,l=l1 + l2 - 1,a=new Array(l);
      a[0] = 0;
      var i=1,j=1;
      for(;i < l1;i++)a[i] = a1[i];
      for(;i < l;i++,j++)a[i] = a2[j];
      return a}
    function caml_string_of_bytes(s){return s}
    function caml_ml_set_channel_refill(chanid,f)
     {caml_ml_channels[chanid].refill = f;return 0}
    function caml_js_expr(s)
     {js_print_stderr("caml_js_expr: fallback to runtime evaluation");
      return eval(s.toString())}
    function caml_int64_mul(x,y)
     {var
       z1=x[1] * y[1],
       z2=(z1 * caml_int64_offset | 0) + x[2] * y[1] + x[1] * y[2],
       z3=
        (z2 * caml_int64_offset | 0)
        +
        x[3]
        *
        y[1]
        +
        x[2]
        *
        y[2]
        +
        x[1]
        *
        y[3];
      return [255,z1 & 0xffffff,z2 & 0xffffff,z3 & 0xffff]}
    function caml_ml_runtime_warnings_enabled(_unit)
     {return caml_runtime_warnings}
    function caml_output_value_to_bytes(v,flags)
     {return caml_string_of_array(caml_output_val(v,flags))}
    function caml_hash_univ_param(count,limit,obj)
     {var hash_accu=0;
      function hash_aux(obj)
       {limit--;
        if(count < 0 || limit < 0)return;
        if(obj instanceof Array && obj[0] === (obj[0] | 0))
         switch(obj[0])
          {case 248:count--;hash_accu = hash_accu * 65599 + obj[2] | 0;break;
           case 250:limit++;hash_aux(obj);break;
           case 255:
            count--;
            hash_accu = hash_accu * 65599 + obj[1] + (obj[2] << 24) | 0;
            break;
           default:
            count--;
            hash_accu = hash_accu * 19 + obj[0] | 0;
            for(var i=obj.length - 1;i > 0;i--)hash_aux(obj[i])}
        else
         if(obj instanceof MlBytes)
          {count--;
           switch(obj.t & 6)
            {default:caml_convert_string_to_bytes(obj);case 0:
              for(var b=obj.c,l=obj.l,i=0;i < l;i++)
               hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0;
              break;
             case 2:
              for(var a=obj.c,l=obj.l,i=0;i < l;i++)
               hash_accu = hash_accu * 19 + a[i] | 0
             }}
         else
          if(obj === (obj | 0))
           {count--;hash_accu = hash_accu * 65599 + obj | 0}
          else
           if(obj === + obj)
            {count--;
             var p=caml_int64_to_bytes(caml_int64_bits_of_float(obj));
             for(var i=7;i >= 0;i--)hash_accu = hash_accu * 19 + p[i] | 0}
           else
            if(obj && obj.caml_custom)
             if
              (caml_custom_ops[obj.caml_custom]
               &&
               caml_custom_ops[obj.caml_custom].hash)
              {var h=caml_custom_ops[obj.caml_custom].hash(obj) | 0;
               hash_accu = hash_accu * 65599 + h | 0}}
      hash_aux(obj);
      return hash_accu & 0x3FFFFFFF}
    function caml_string_equal(s1,s2)
     {if(s1 === s2)return 1;
      s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c == s2.c?1:0}
    function raw_array_copy(a)
     {var l=a.length,b=new Array(l);
      for(var i=0;i < l;i++)b[i] = a[i];
      return b}
    function caml_output_value_to_buffer(s,ofs,len,v,flags)
     {var t=caml_output_val(v,flags);
      if(t.length > len)caml_failwith("Marshal.to_buffer: buffer overflow");
      caml_blit_bytes(t,0,s,ofs,t.length);
      return 0}
    function caml_pure_js_expr(s)
     {js_print_stderr("caml_pure_js_expr: fallback to runtime evaluation");
      return eval(s.toString())}
    function caml_blit_string(s1,i1,s2,i2,len)
     {return caml_blit_bytes(s1,i1,s2,i2,len)}
    function blit_nat(nat1,ofs1,nat2,ofs2,len)
     {for(var i=0;i < len;i++)nat1.data[ofs1 + i] = nat2.data[ofs2 + i];
      return 0}
    function caml_int64_ult(x,y){return caml_int64_ucompare(x,y) < 0}
    function caml_int64_xor(x,y)
     {return [255,x[1] ^ y[1],x[2] ^ y[2],x[3] ^ y[3]]}
    function caml_bigstring_blit_ba_to_bytes(ba1,pos1,bytes2,pos2,len)
     {if(12 != ba1.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs1=ba1.offset(pos1);
      if(ofs1 + len > ba1.data.length)caml_array_bound_error();
      if(pos2 + len > bytes2.l)caml_array_bound_error();
      var slice=ba1.data.slice(ofs1,ofs1 + len);
      caml_blit_bytes(caml_string_of_array(slice),0,bytes2,pos2,len);
      return 0}
    function caml_register_named_value(nm,v)
     {caml_named_values[caml_jsbytes_of_string(nm)] = v;return 0}
    function caml_parse_sign_and_base(s)
     {var i=0,len=caml_ml_string_length(s),base=10,sign=1;
      if(len > 0)
       switch(caml_string_unsafe_get(s,i))
        {case 45:i++;sign = - 1;break;case 43:i++;sign = 1;break}
      if(i + 1 < len && caml_string_unsafe_get(s,i) == 48)
       switch(caml_string_unsafe_get(s,i + 1))
        {case 120:
         case 88:base = 16;i += 2;break;
         case 111:
         case 79:base = 8;i += 2;break;
         case 98:
         case 66:base = 2;i += 2;break;
         case 117:
         case 85:sign = 0;i += 2;break
         }
      return [i,sign,base]}
    function caml_parse_digit(c)
     {if(c >= 48 && c <= 57)return c - 48;
      if(c >= 65 && c <= 90)return c - 55;
      if(c >= 97 && c <= 122)return c - 87;
      return - 1}
    function caml_int64_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       base64=caml_int64_of_int32(base),
       threshold=caml_int64_udivmod([255,0xffffff,0xfffffff,0xffff],base64)[1],
       c=caml_string_unsafe_get(s,i),
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=caml_int64_of_int32(d);
      for(;;)
       {i++;
        c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        if(caml_int64_ult(threshold,res))caml_failwith("int_of_string");
        d = caml_int64_of_int32(d);
        res = caml_int64_add(caml_int64_mul(base64,res),d);
        if(caml_int64_ult(res,d))caml_failwith("int_of_string")}
      if(i != caml_ml_string_length(s))caml_failwith("int_of_string");
      if(r[2] == 10 && caml_int64_ult([255,0,0,0x8000],res))
       caml_failwith("int_of_string");
      if(sign < 0)res = caml_int64_neg(res);
      return res}
    function caml_make_vect(len,init)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 0;
      for(var i=1;i < len;i++)b[i] = init;
      return b}
    var caml_blit_string_to_bigstring=caml_bigstring_blit_string_to_ba;
    function caml_ml_seek_in(chanid,pos)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill != null)caml_raise_sys_error("Illegal seek");
      chan.offset = pos;
      return 0}
    function caml_sys_read_directory(name)
     {var
       root=resolve_fs_device(name),
       a=root.device.readdir(root.rest),
       l=new Array(a.length + 1);
      l[0] = 0;
      for(var i=0;i < a.length;i++)l[i + 1] = caml_new_string(a[i]);
      return l}
    function caml_ml_output_char(chanid,c)
     {var s=caml_new_string(String.fromCharCode(c));
      caml_ml_output(chanid,s,0,1);
      return 0}
    function caml_sys_const_ostype_win32(){return 0}
    function caml_obj_is_block(x){return + (x instanceof Array)}
    function caml_ml_input_char(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_may_refill_input(chanid);
      if(chan.offset >= chan.file.length())caml_raise_end_of_file();
      var res=chan.file.read_one(chan.offset);
      chan.offset++;
      return res}
    function caml_js_var(x)
     {var x=x.toString();
      if(! x.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*(\.[a-zA-Z_$][a-zA-Z_$0-9]*)*$/))
       js_print_stderr
        ('caml_js_var: "'
         +
         x
         +
         '" is not a valid JavaScript variable. continuing ..');
      return eval(x)}
    function caml_trunc_float(x){return Math.trunc(x)}
    function caml_ephe_blit_data(src,dst)
     {dst[caml_ephe_data_offset] = src[caml_ephe_data_offset];return 0}
    function caml_is_printable(c){return + (c > 31 && c < 127)}
    function caml_bytes_lessequal(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c <= s2.c?1:0}
    function caml_equal(x,y){return + (caml_compare_val(x,y,false) == 0)}
    function caml_final_register_called_without_value(){return 0}
    function caml_sys_random_seed()
     {var now=new Date().getTime(),x=now ^ 0xffffffff * Math.random();
      return [0,x]}
    function caml_ba_get_2(ba,i0,i1){return ba.get(ba.offset([i0,i1]))}
    function win_handle_fd(x){return x}
    function caml_ba_uint8_set16(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 1 >= ba.data.length)caml_array_bound_error();
      ba.set(ofs + 0,v & 0xff);
      ba.set(ofs + 1,v >>> 8 & 0xff);
      return 0}
    function caml_js_delete(o,f){delete o[f];return 0}
    function caml_int_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       len=caml_ml_string_length(s),
       threshold=- 1 >>> 0,
       c=i < len?caml_string_unsafe_get(s,i):0,
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=d;
      for(i++;i < len;i++)
       {c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        res = base * res + d;
        if(res > threshold)caml_failwith("int_of_string")}
      if(i != len)caml_failwith("int_of_string");
      res = sign * res;
      if(base == 10 && (res | 0) != res)caml_failwith("int_of_string");
      return res | 0}
    function caml_list_mount_point()
     {var prev=0;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var old=prev;prev = [0,caml_new_string(jsoo_mount_point[i].path),old]}
      return prev}
    var
     caml_marshal_constants=
      {PREFIX_SMALL_BLOCK:0x80,
       PREFIX_SMALL_INT:0x40,
       PREFIX_SMALL_STRING:0x20,
       CODE_INT8:0x00,
       CODE_INT16:0x01,
       CODE_INT32:0x02,
       CODE_INT64:0x03,
       CODE_SHARED8:0x04,
       CODE_SHARED16:0x05,
       CODE_SHARED32:0x06,
       CODE_BLOCK32:0x08,
       CODE_BLOCK64:0x13,
       CODE_STRING8:0x09,
       CODE_STRING32:0x0A,
       CODE_DOUBLE_BIG:0x0B,
       CODE_DOUBLE_LITTLE:0x0C,
       CODE_DOUBLE_ARRAY8_BIG:0x0D,
       CODE_DOUBLE_ARRAY8_LITTLE:0x0E,
       CODE_DOUBLE_ARRAY32_BIG:0x0F,
       CODE_DOUBLE_ARRAY32_LITTLE:0x07,
       CODE_CODEPOINTER:0x10,
       CODE_INFIXPOINTER:0x11,
       CODE_CUSTOM:0x12,
       CODE_CUSTOM_LEN:0x18,
       CODE_CUSTOM_FIXED:0x19};
    function caml_js_equals(x,y){return + (x == y)}
    function bigstring_to_typed_array(bs){return bs.data}
    function caml_ba_slice(ba,vind)
     {vind = caml_js_from_array(vind);
      var num_inds=vind.length,index=[],sub_dims=[],ofs;
      if(num_inds > ba.dims.length)
       caml_invalid_argument("Bigarray.slice: too many indices");
      if(ba.layout == 0)
       {for(var i=0;i < num_inds;i++)index[i] = vind[i];
        for(;i < ba.dims.length;i++)index[i] = 0;
        sub_dims = ba.dims.slice(num_inds)}
      else
       {for(var i=0;i < num_inds;i++)
         index[ba.dims.length - num_inds + i] = vind[i];
        for(var i=0;i < ba.dims.length - num_inds;i++)index[i] = 1;
        sub_dims = ba.dims.slice(0,ba.dims.length - num_inds)}
      ofs = ba.offset(index);
      var
       size=caml_ba_get_size(sub_dims),
       size_per_element=caml_ba_get_size_per_element(ba.kind),
       new_data=
        ba.data.subarray
         (ofs * size_per_element,(ofs + size) * size_per_element);
      return caml_ba_create_unsafe(ba.kind,ba.layout,sub_dims,new_data)}
    function caml_marshal_data_size(s,ofs)
     {function get32(s,i)
       {return caml_bytes_unsafe_get(s,i)
               <<
               24
               |
               caml_bytes_unsafe_get(s,i + 1)
               <<
               16
               |
               caml_bytes_unsafe_get(s,i + 2)
               <<
               8
               |
               caml_bytes_unsafe_get(s,i + 3)}
      if(get32(s,ofs) != (0x8495A6BE | 0))
       caml_failwith("Marshal.data_size: bad object");
      return get32(s,ofs + 4)}
    function caml_input_value_from_string(s,ofs)
     {var reader=new MlBytesReader(s,typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_input_value(chanid)
     {var chan=caml_ml_channels[chanid],buf=caml_create_bytes(8);
      chan.file.read(chan.offset,buf,0,8);
      var len=caml_marshal_data_size(buf,0) + 20,buf=caml_create_bytes(len);
      chan.file.read(chan.offset,buf,0,len);
      var offset=[0],res=caml_input_value_from_string(buf,offset);
      chan.offset = chan.offset + offset[0];
      return res}
    function caml_ba_kind(ba){return ba.kind}
    function caml_js_fun_call(f,a)
     {switch(a.length)
       {case 1:return f();
        case 2:return f(a[1]);
        case 3:return f(a[1],a[2]);
        case 4:return f(a[1],a[2],a[3]);
        case 5:return f(a[1],a[2],a[3],a[4]);
        case 6:return f(a[1],a[2],a[3],a[4],a[5]);
        case 7:return f(a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:return f(a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
      return f.apply(null,caml_js_from_array(a))}
    function caml_js_pure_expr(f){return f()}
    function compare_digits_nat(nat1,ofs1,nat2,ofs2)
     {if(nat1.data[ofs1] > nat2.data[ofs2])return 1;
      if(nat1.data[ofs1] < nat2.data[ofs2])return - 1;
      return 0}
    function caml_ml_input(chanid,s,i,l)
     {var chan=caml_ml_channels[chanid],l2=chan.file.length() - chan.offset;
      if(l2 == 0 && chan.refill != null)l2 = caml_ml_refill_input(chan);
      if(l2 < l)l = l2;
      chan.file.read(chan.offset,s,i,l);
      chan.offset += l;
      return l}
    function caml_hash_mix_bigstring(h,bs)
     {return caml_hash_mix_string_arr(h,bs.data)}
    function caml_record_backtrace(){return 0}
    function unix_gmtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(Date.UTC(d.getUTCFullYear(),0,1)).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000);
      return [0,
              d.getUTCSeconds(),
              d.getUTCMinutes(),
              d.getUTCHours(),
              d.getUTCDate(),
              d.getUTCMonth(),
              d.getUTCFullYear() - 1900,
              d.getUTCDay(),
              doy,
              false | 0]}
    function caml_sys_const_backend_type()
     {return [0,caml_new_string("js_of_ocaml")]}
    function caml_sys_get_config(){return [0,caml_new_string("Unix"),32,0]}
    function unix_time(){return Math.floor(unix_gettimeofday())}
    function caml_ml_out_channels_list()
     {var l=0;
      for(var c=0;c < caml_ml_channels.length;c++)
       if
        (caml_ml_channels[c]
         &&
         caml_ml_channels[c].opened
         &&
         caml_ml_channels[c].out)
        l = [0,caml_ml_channels[c].fd,l];
      return l}
    function bigstring_of_array_buffer(ab)
     {var ta=new (joo_global_object.Uint8Array)(ab);
      return caml_ba_create_unsafe(12,0,[ta.length],ta)}
    function caml_mod(x,y){if(y == 0)caml_raise_zero_divide();return x % y}
    function caml_ba_init(){return 0}
    function BigStringReader(bs,i){this.s = bs;this.i = i}
    BigStringReader.prototype
    =
    {read8u:function(){return caml_ba_get_1(this.s,this.i++)},
     read8s:function(){return caml_ba_get_1(this.s,this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return caml_ba_get_1(s,i) << 8 | caml_ba_get_1(s,i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return caml_ba_get_1(s,i) << 24 >> 16 | caml_ba_get_1(s,i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (caml_ba_get_1(s,i)
               <<
               24
               |
               caml_ba_get_1(s,i + 1)
               <<
               16
               |
               caml_ba_get_1(s,i + 2)
               <<
               8
               |
               caml_ba_get_1(s,i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return caml_ba_get_1(s,i)
              <<
              24
              |
              caml_ba_get_1(s,i + 1)
              <<
              16
              |
              caml_ba_get_1(s,i + 2)
              <<
              8
              |
              caml_ba_get_1(s,i + 3)},
     readstr:
     function(len)
      {var i=this.i,arr=new Array(len);
       for(var j=0;j < len;j++)arr[j] = caml_ba_get_1(this.s,i + j);
       this.i = i + len;
       return caml_string_of_array(arr)}};
    function caml_ba_get_generic(ba,i)
     {var ofs=ba.offset(caml_js_from_array(i));return ba.get(ofs)}
    function caml_get_exception_backtrace(){return 0}
    function caml_format_float(fmt,x)
     {function toFixed(x,dp)
       {if(Math.abs(x) < 1.0)
         return x.toFixed(dp);
        else
         {var e=parseInt(x.toString().split("+")[1]);
          if(e > 20)
           {e -= 20;
            x /= Math.pow(10,e);
            x += new Array(e + 1).join("0");
            if(dp > 0)x = x + "." + new Array(dp + 1).join("0");
            return x}
          else
           return x.toFixed(dp)}}
      var s,f=caml_parse_format(fmt),prec=f.prec < 0?6:f.prec;
      if(x < 0 || x == 0 && 1 / x == - Infinity){f.sign = - 1;x = - x}
      if(isNaN(x))
       {s = "nan";f.filler = " "}
      else
       if(! isFinite(x))
        {s = "inf";f.filler = " "}
       else
        switch(f.conv)
         {case "e":
           var s=x.toExponential(prec),i=s.length;
           if(s.charAt(i - 3) == "e")
            s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
           break;
          case "f":s = toFixed(x,prec);break;
          case "g":
           prec = prec?prec:1;
           s = x.toExponential(prec - 1);
           var j=s.indexOf("e"),exp=+ s.slice(j + 1);
           if(exp < - 4 || x >= 1e21 || x.toFixed(0).length > prec)
            {var i=j - 1;
             while(s.charAt(i) == "0")i--;
             if(s.charAt(i) == ".")i--;
             s = s.slice(0,i + 1) + s.slice(j);
             i = s.length;
             if(s.charAt(i - 3) == "e")
              s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
             break}
           else
            {var p=prec;
             if(exp < 0)
              {p -= exp + 1;s = x.toFixed(p)}
             else
              while(s = x.toFixed(p),s.length > prec + 1)p--;
             if(p)
              {var i=s.length - 1;
               while(s.charAt(i) == "0")i--;
               if(s.charAt(i) == ".")i--;
               s = s.slice(0,i + 1)}}
           break
          }
      return caml_finish_formatting(f,s)}
    function caml_mount_autoload(name,f)
     {var path=caml_make_path(name),name=path.join("/") + "/";
      jsoo_mount_point.push({path:name,device:new MlFakeDevice(name,f)});
      return 0}
    function caml_bigstring_blit_ba_to_ba(ba1,pos1,ba2,pos2,len)
     {if(12 != ba1.kind)
       caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
      if(12 != ba2.kind)
       caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs1=ba1.offset(pos1),ofs2=ba2.offset(pos2);
      if(ofs1 + len > ba1.data.length)caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=ba1.data.subarray(ofs1,ofs1 + len);
      ba2.data.set(slice,pos2);
      return 0}
    var caml_blit_bigstring_to_bigstring=caml_bigstring_blit_ba_to_ba;
    function caml_div(x,y)
     {if(y == 0)caml_raise_zero_divide();return x / y | 0}
    function caml_string_lessthan(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?1:0}
    function caml_string_greaterthan(s1,s2)
     {return caml_string_lessthan(s2,s1)}
    function caml_ephe_get_data_copy(x)
     {return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,caml_obj_dup(x[caml_ephe_data_offset])]}
    function caml_sys_get_argv(a){return [0,caml_argv[1],caml_argv]}
    function caml_js_to_bool(x){return + x}
    var caml_ephe_get_key_copy=caml_weak_get_copy;
    function caml_raw_backtrace_next_slot(){return 0}
    function caml_lessthan(x,y){return + (caml_compare_val(x,y,false) < 0)}
    function caml_register_global(n,v,name_opt)
     {if(name_opt && joo_global_object.toplevelReloc)
       n = joo_global_object.toplevelReloc(name_opt);
      caml_global_data[n + 1] = v;
      if(name_opt)caml_global_data[name_opt] = v}
    function mult_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat3,ofs3,len3)
     {var carry=0;
      for(var i=0;i < len3;i++)
       carry
       +=
       mult_digit_nat(nat1,ofs1 + i,len1 - i,nat2,ofs2,len2,nat3,ofs3 + i);
      return carry}
    function square_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {var carry=0;
      carry += add_nat(nat1,ofs1,len1,nat1,ofs1,len1,0);
      carry += mult_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat2,ofs2,len2);
      return carry}
    function caml_floatarray_create(len)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 254;
      for(var i=1;i < len;i++)b[i] = 0;
      return b}
    function caml_js_from_float(x){return x}
    function caml_gc_stat(){return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
    function caml_sys_modify_argv(arg){caml_argv = arg;return 0}
    var caml_method_cache=[];
    function caml_get_public_method(obj,tag,cacheid)
     {var meths=obj[1],ofs=caml_method_cache[cacheid];
      if(ofs === null)
       for(var i=caml_method_cache.length;i < cacheid;i++)
        caml_method_cache[i] = 0;
      else
       if(meths[ofs] === tag)return meths[ofs - 1];
      var li=3,hi=meths[1] * 2 + 1,mi;
      while(li < hi)
       {mi = li + hi >> 1 | 1;if(tag < meths[mi + 1])hi = mi - 2;else li = mi}
      caml_method_cache[cacheid] = li + 1;
      return tag == meths[li + 1]?meths[li]:0}
    function caml_js_get_console()
     {var
       c=joo_global_object.console?joo_global_object.console:{},
       m=
        ["log",
         "debug",
         "info",
         "warn",
         "error",
         "assert",
         "dir",
         "dirxml",
         "trace",
         "group",
         "groupCollapsed",
         "groupEnd",
         "time",
         "timeEnd"];
      function f(){}
      for(var i=0;i < m.length;i++)if(! c[m[i]])c[m[i]] = f;
      return c}
    function caml_ml_open_descriptor_in(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.wronly)caml_raise_sys_error("fd " + fd + " is writeonly");
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:false,
         refill:null};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function bigstring_of_typed_array(ba)
     {var
       ta=
        new
         (joo_global_object.Uint8Array)
         (ba.buffer,ba.byteOffset,ba.length * ba.BYTES_PER_ELEMENT);
      return caml_ba_create_unsafe(12,0,[ta.length],ta)}
    function caml_round_float(x){return Math.round(x)}
    function caml_ojs_new_arr(c,a)
     {switch(a.length)
       {case 0:return new c();
        case 1:return new c(a[0]);
        case 2:return new c(a[0],a[1]);
        case 3:return new c(a[0],a[1],a[2]);
        case 4:return new c(a[0],a[1],a[2],a[3]);
        case 5:return new c(a[0],a[1],a[2],a[3],a[4]);
        case 6:return new c(a[0],a[1],a[2],a[3],a[4],a[5]);
        case 7:return new c(a[0],a[1],a[2],a[3],a[4],a[5],a[6])
        }
      function F(){return c.apply(this,a)}
      F.prototype = c.prototype;
      return new F()}
    function complement_nat(nat,ofs,len)
     {for(var i=0;i < len;i++)
       nat.data[ofs + i] = (- 1 >>> 0) - (nat.data[ofs + i] >>> 0)}
    var caml_js_regexps={amp:/&/g,lt:/</g,quot:/\"/g,all:/[&<\"]/};
    function caml_js_html_escape(s)
     {if(! caml_js_regexps.all.test(s))return s;
      return s.replace(caml_js_regexps.amp,"&amp;").replace
               (caml_js_regexps.lt,"&lt;").replace
              (caml_js_regexps.quot,"&quot;")}
    function caml_ba_dim_2(ba){return caml_ba_dim(ba,1)}
    function caml_js_wrap_meth_callback_arguments(f)
     {return function(){return caml_call_gen(f,[this,arguments])}}
    function caml_sinh_float(x){return (Math.exp(x) - Math.exp(- x)) / 2}
    function caml_ldexp_float(x,exp)
     {exp |= 0;
      if(exp > 1023)
       {exp -= 1023;
        x *= Math.pow(2,1023);
        if(exp > 1023){exp -= 1023;x *= Math.pow(2,1023)}}
      if(exp < - 1023){exp += 1023;x *= Math.pow(2,- 1023)}
      x *= Math.pow(2,exp);
      return x}
    function caml_js_wrap_callback_strict(arity,f)
     {return function()
       {var n=arguments.length;
        if(n == arity)return caml_call_gen(f,arguments);
        var args=new Array(arity);
        for(var i=0;i < n && i < arity;i++)args[i] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_get_current_callstack(){return [0]}
    function caml_ba_set_1(ba,i0,v){ba.set(ba.offset(i0),v);return 0}
    function land_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] &= nat2.data[ofs2];return 0}
    function caml_int64_mod(x,y)
     {if(caml_int64_is_zero(y))caml_raise_zero_divide();
      var sign=x[3];
      if(x[3] & 0x8000)x = caml_int64_neg(x);
      if(y[3] & 0x8000)y = caml_int64_neg(y);
      var r=caml_int64_udivmod(x,y)[2];
      if(sign & 0x8000)r = caml_int64_neg(r);
      return r}
    function caml_obj_set_tag(x,tag){x[0] = tag;return 0}
    function caml_create_file_extern(name,content)
     {if(joo_global_object.caml_create_file)
       joo_global_object.caml_create_file(name,content);
      else
       {if(! joo_global_object.caml_fs_tmp)joo_global_object.caml_fs_tmp = [];
        joo_global_object.caml_fs_tmp.push({name:name,content:content})}
      return 0}
    function caml_int32_bswap(x)
     {return (x & 0x000000FF)
             <<
             24
             |
             (x & 0x0000FF00)
             <<
             8
             |
             (x & 0x00FF0000)
             >>>
             8
             |
             (x & 0xFF000000)
             >>>
             24}
    function win_startup(){}
    function caml_ba_set_3(ba,i0,i1,i2,v)
     {ba.set(ba.offset([i0,i1,i2]),v);return 0}
    function caml_js_instanceof(o,c){return o instanceof c}
    var caml_blit_bigstring_to_string=caml_bigstring_blit_ba_to_bytes;
    function nth_digit_nat_native(nat,ofs){return nat.data[ofs]}
    function set_digit_nat_native(nat,ofs,digit)
     {nat.data[ofs] = digit;return 0}
    function caml_string_set64(s,i,i64){return caml_bytes_set64(s,i,i64)}
    function caml_ba_map_file(vfd,kind,layout,shared,dims,pos)
     {caml_failwith("caml_ba_map_file not implemented")}
    function caml_ba_map_file_bytecode(argv,argn)
     {return caml_ba_map_file(argv[0],argv[1],argv[2],argv[3],argv[4],argv[5])}
    function caml_ba_create_from(data1,data2,jstyp,kind,layout,dims)
     {if(data2 || caml_ba_get_size_per_element(kind) == 2)
       caml_invalid_argument
        ("caml_ba_create_from: use return caml_ba_create_unsafe");
      return caml_ba_create_unsafe(kind,layout,dims,data1)}
    function caml_tanh_float(x)
     {var y=Math.exp(x),z=Math.exp(- x);return (y - z) / (y + z)}
    var JSON=joo_global_object.JSON;
    if(typeof JSON !== "object")JSON = {};
    (function()
       {"use strict";
        var
         rx_one=/^[\],:{}\s]*$/,
         rx_two=/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
         rx_three=
          /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
         rx_four=/(?:^|:|,)(?:\s*\[)+/g,
         rx_escapable=
          /[\\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
         rx_dangerous=
          /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
        function f(n){return n < 10?"0" + n:n}
        function this_value(){return this.valueOf()}
        if(typeof Date.prototype.toJSON !== "function")
         {Date.prototype.toJSON
          =
          function()
           {return isFinite(this.valueOf())
                    ?this.getUTCFullYear()
                     +
                     "-"
                     +
                     f(this.getUTCMonth() + 1)
                     +
                     "-"
                     +
                     f(this.getUTCDate())
                     +
                     "T"
                     +
                     f(this.getUTCHours())
                     +
                     ":"
                     +
                     f(this.getUTCMinutes())
                     +
                     ":"
                     +
                     f(this.getUTCSeconds())
                     +
                     "Z"
                    :null};
          Boolean.prototype.toJSON = this_value;
          Number.prototype.toJSON = this_value;
          String.prototype.toJSON = this_value}
        var gap,indent,meta,rep;
        function quote(string)
         {rx_escapable.lastIndex = 0;
          return rx_escapable.test(string)
                  ?'"'
                   +
                   string.replace
                    (rx_escapable,
                     function(a)
                      {var c=meta[a];
                       return typeof c === "string"
                               ?c
                               :"\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(- 4)})
                   +
                   '"'
                  :'"' + string + '"'}
        function str(key,holder)
         {var i,k,v,length,mind=gap,partial,value=holder[key];
          if
           (value
            &&
            typeof value
            ===
            "object"
            &&
            typeof value.toJSON
            ===
            "function")
           value = value.toJSON(key);
          if(typeof rep === "function")value = rep.call(holder,key,value);
          switch(typeof value)
           {case "string":return quote(value);
            case "number":return isFinite(value)?String(value):"null";
            case "boolean":
            case "null":return String(value);
            case "object":
             if(! value)return "null";
             gap += indent;
             partial = [];
             if(Object.prototype.toString.apply(value) === "[object Array]")
              {length = value.length;
               for(i = 0;i < length;i += 1)
                partial[i] = str(i,value) || "null";
               v
               =
               partial.length === 0
                ?"[]"
                :gap
                  ?"[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]"
                  :"[" + partial.join(",") + "]";
               gap = mind;
               return v}
             if(rep && typeof rep === "object")
              {length = rep.length;
               for(i = 0;i < length;i += 1)
                if(typeof rep[i] === "string")
                 {k = rep[i];
                  v = str(k,value);
                  if(v)partial.push(quote(k) + (gap?": ":":") + v)}}
             else
              for(k in value)
               if(Object.prototype.hasOwnProperty.call(value,k))
                {v = str(k,value);
                 if(v)partial.push(quote(k) + (gap?": ":":") + v)}
             v
             =
             partial.length === 0
              ?"{}"
              :gap
                ?"{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}"
                :"{" + partial.join(",") + "}";
             gap = mind;
             return v
            }}
        if(typeof JSON.stringify !== "function")
         {meta
          =
          {"\b":"\\b",
           "\t":"\\t",
           "\n":"\\n",
           "\f":"\\f",
           "\r":"\\r",
           '"':'\\"',
           "\\":"\\\\"};
          JSON.stringify
          =
          function(value,replacer,space)
           {var i;
            gap = "";
            indent = "";
            if(typeof space === "number")
             for(i = 0;i < space;i += 1)indent += " ";
            else
             if(typeof space === "string")indent = space;
            rep = replacer;
            if
             (replacer
              &&
              typeof replacer
              !==
              "function"
              &&
              (typeof replacer
               !==
               "object"
               ||
               typeof replacer.length
               !==
               "number"))
             throw new Error("JSON.stringify");
            return str("",{"":value})}}
        if(typeof JSON.parse !== "function")
         JSON.parse
         =
         function(text,reviver)
          {var j;
           function walk(holder,key)
            {var k,v,value=holder[key];
             if(value && typeof value === "object")
              for(k in value)
               if(Object.prototype.hasOwnProperty.call(value,k))
                {v = walk(value,k);
                 if(v !== undefined)value[k] = v;else delete value[k]}
             return reviver.call(holder,key,value)}
           text = String(text);
           rx_dangerous.lastIndex = 0;
           if(rx_dangerous.test(text))
            text
            =
            text.replace
             (rx_dangerous,
              function(a)
               {return "\\u"
                       +
                       ("0000" + a.charCodeAt(0).toString(16)).slice(- 4)});
           if
            (rx_one.test
              (text.replace(rx_two,"@").replace(rx_three,"]").replace
                (rx_four,"")))
            {j = eval("(" + text + ")");
             return typeof reviver === "function"?walk({"":j},""):j}
           throw new SyntaxError("JSON.parse")}}
      ());
    function caml_json(){return JSON}
    function caml_unmount(name)
     {var path=caml_make_path(name),name=path.join("/") + "/",idx=- 1;
      for(var i=0;i < jsoo_mount_point.length;i++)
       if(jsoo_mount_point[i].path == name)idx = i;
      if(idx > - 1)jsoo_mount_point.splice(idx,1);
      return 0}
    function caml_ml_pos_in_64(chanid)
     {return caml_int64_of_float(caml_ml_channels[chanid].offset)}
    function caml_register_channel_for_spacetime(_channel){return 0}
    function caml_string_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_string_bound_error();
      return caml_string_unsafe_set(s,i,c)}
    function caml_ml_pos_out(chanid)
     {caml_ml_flush(chanid);return caml_ml_channels[chanid].offset}
    function caml_spacetime_enabled(_unit){return 0}
    function caml_bytes_notequal(s1,s2){return 1 - caml_string_equal(s1,s2)}
    function caml_runtime_parameters(_unit){return caml_new_string("")}
    function caml_js_object(a)
     {var o={};
      for(var i=1;i < a.length;i++){var p=a[i];o[p[1].toString()] = p[2]}
      return o}
    function caml_ba_create(kind,layout,dims_ml)
     {var
       dims=caml_js_from_array(dims_ml),
       data=caml_ba_create_buffer(kind,caml_ba_get_size(dims));
      return caml_ba_create_unsafe(kind,layout,dims,data)}
    function caml_weak_blit(a1,i1,a2,i2,len)
     {caml_array_blit
       (a1,caml_ephe_key_offset + i1 - 1,a2,caml_ephe_key_offset + i2 - 1,len);
      return 0}
    function caml_bswap16(x){return (x & 0x00FF) << 8 | (x & 0xFF00) >> 8}
    function caml_final_register(){return 0}
    function caml_ml_set_binary_mode(chanid,mode)
     {var chan=caml_ml_channels[chanid],data=caml_global_data.fds[chan.fd];
      data.flags.text = ! mode;
      data.flags.binary = mode;
      return 0}
    function caml_string_get16(s,i)
     {if(i >>> 0 >= s.l - 1)caml_string_bound_error();
      var b1=caml_string_unsafe_get(s,i),b2=caml_string_unsafe_get(s,i + 1);
      return b2 << 8 | b1}
    function caml_ephe_unset_data(x,data)
     {x[caml_ephe_data_offset] = undefined;return 0}
    function caml_output_value(chanid,v,flags)
     {var s=caml_output_value_to_string(v,flags);
      caml_ml_output(chanid,s,0,caml_ml_string_length(s));
      return 0}
    function caml_ba_get_3(ba,i0,i1,i2){return ba.get(ba.offset([i0,i1,i2]))}
    var caml_ephe_blit_key=caml_weak_blit;
    function caml_check_bound(array,index)
     {if(index >>> 0 >= array.length - 1)caml_array_bound_error();
      return array}
    function caml_bytes_of_string(s){return s}
    function caml_hash_mix_string(h,v)
     {switch(v.t & 6)
       {default:caml_convert_string_to_bytes(v);case 0:
         h = caml_hash_mix_string_str(h,v.c);break;
        case 2:h = caml_hash_mix_string_arr(h,v.c)
        }
      return h}
    function caml_hash(count,limit,seed,obj)
     {var queue,rd,wr,sz,num,h,v,i,len;
      sz = limit;
      if(sz < 0 || sz > 256)sz = 256;
      num = count;
      h = seed;
      queue = [obj];
      rd = 0;
      wr = 1;
      while(rd < wr && num > 0)
       {v = queue[rd++];
        if(v && v.caml_custom)
         {if
           (caml_custom_ops[v.caml_custom]
            &&
            caml_custom_ops[v.caml_custom].hash)
           {var hh=caml_custom_ops[v.caml_custom].hash(v);
            h = caml_hash_mix_int(h,hh);
            num--}}
        else
         if(v instanceof Array && v[0] === (v[0] | 0))
          switch(v[0])
           {case 248:h = caml_hash_mix_int(h,v[2]);num--;break;
            case 250:queue[--rd] = v[1];break;
            case 255:h = caml_hash_mix_int64(h,v);num--;break;
            default:
             var tag=v.length - 1 << 10 | v[0];
             h = caml_hash_mix_int(h,tag);
             for(i = 1,len = v.length;i < len;i++)
              {if(wr >= sz)break;queue[wr++] = v[i]}
             break}
         else
          if(v instanceof MlBytes)
           {h = caml_hash_mix_string(h,v);num--}
          else
           if(v === (v | 0))
            {h = caml_hash_mix_int(h,v + v + 1);num--}
           else
            if(v === + v){h = caml_hash_mix_float(h,v);num--}}
      h = caml_hash_mix_final(h);
      return h & 0x3FFFFFFF}
    function caml_obj_tag(x)
     {if(x instanceof Array && x[0] == x[0] >>> 0)
       return x[0];
      else
       if(x instanceof MlBytes)
        return 252;
       else
        if(x instanceof Function || typeof x == "function")
         return 247;
        else
         if(x && x.caml_custom)return 255;else return 1000}
    function caml_js_export_var()
     {return typeof module !== "undefined" && module && module.exports
              ?module.exports
              :joo_global_object}
    function caml_bytes_get32(s,i)
     {if(i >>> 0 >= s.l - 3)caml_string_bound_error();
      var
       b1=caml_string_unsafe_get(s,i),
       b2=caml_string_unsafe_get(s,i + 1),
       b3=caml_string_unsafe_get(s,i + 2),
       b4=caml_string_unsafe_get(s,i + 3);
      return b4 << 24 | b3 << 16 | b2 << 8 | b1}
    function caml_frexp_float(x)
     {if(x == 0 || ! isFinite(x))return [0,x,0];
      var neg=x < 0;
      if(neg)x = - x;
      var exp=Math.max(- 1023,jsoo_floor_log2(x) + 1);
      x *= Math.pow(2,- exp);
      while(x < 0.5){x *= 2;exp--}
      while(x >= 1){x *= 0.5;exp++}
      if(neg)x = - x;
      return [0,x,exp]}
    function caml_string_get64(s,i)
     {if(i >>> 0 >= s.l - 7)caml_string_bound_error();
      var a=new Array(8);
      for(var j=0;j < 8;j++)a[7 - j] = caml_string_unsafe_get(s,i + j);
      return caml_int64_of_bytes(a)}
    function caml_ml_pos_out_64(chanid)
     {caml_ml_flush(chanid);
      return caml_int64_of_float(caml_ml_channels[chanid].offset)}
    function caml_set_static_env(k,v)
     {if(! joo_global_object.jsoo_static_env)
       joo_global_object.jsoo_static_env = {};
      joo_global_object.jsoo_static_env[k] = v;
      return 0}
    function caml_ba_change_layout(ba,layout)
     {if(ba.layout == layout)return ba;
      var new_dims=[];
      for(var i=0;i < ba.dims.length;i++)
       new_dims[i] = ba.dims[ba.dims.length - i - 1];
      return caml_ba_create_unsafe(ba.kind,layout,new_dims,ba.data)}
    function caml_js_new(c,a)
     {switch(a.length)
       {case 1:return new c();
        case 2:return new c(a[1]);
        case 3:return new c(a[1],a[2]);
        case 4:return new c(a[1],a[2],a[3]);
        case 5:return new c(a[1],a[2],a[3],a[4]);
        case 6:return new c(a[1],a[2],a[3],a[4],a[5]);
        case 7:return new c(a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:return new c(a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
      function F(){return c.apply(this,caml_js_from_array(a))}
      F.prototype = c.prototype;
      return new F()}
    function caml_format_int(fmt,i)
     {if(caml_jsbytes_of_string(fmt) == "%d")return caml_new_string("" + i);
      var f=caml_parse_format(fmt);
      if(i < 0)if(f.signedconv){f.sign = - 1;i = - i}else i >>>= 0;
      var s=i.toString(f.base);
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - s.length;
        if(n > 0)s = caml_str_repeat(n,"0") + s}
      return caml_finish_formatting(f,s)}
    function caml_obj_truncate(x,s)
     {if(s <= 0 || s + 1 > x.length)caml_invalid_argument("Obj.truncate");
      if(x.length != s + 1)x.length = s + 1;
      return 0}
    function is_digit_odd(nat,ofs){if(nat.data[ofs] & 1)return 1;return 0}
    function caml_runtime_variant(_unit){return caml_new_string("")}
    function caml_array_concat(l)
     {var a=[0];
      while(l !== 0)
       {var b=l[1];for(var i=1;i < b.length;i++)a.push(b[i]);l = l[2]}
      return a}
    function caml_ml_open_descriptor_out(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.rdonly)caml_raise_sys_error("fd " + fd + " is readonly");
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:true,
         buffer:""};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function caml_ephe_set_data(x,data)
     {x[caml_ephe_data_offset] = data;return 0}
    function caml_make_float_vect(len)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 254;
      for(var i=1;i < len;i++)b[i] = 0;
      return b}
    function caml_greaterequal(x,y)
     {return + (caml_compare_val(x,y,false) >= 0)}
    function caml_get_exception_raw_backtrace(){return [0]}
    function caml_log1p_float(x)
     {var y=1 + x,z=y - 1;return z == 0?x:x * Math.log(y) / z}
    function caml_string_get(s,i)
     {if(i >>> 0 >= s.l)caml_string_bound_error();
      return caml_string_unsafe_get(s,i)}
    function caml_int64_or(x,y)
     {return [255,x[1] | y[1],x[2] | y[2],x[3] | y[3]]}
    function caml_lazy_make_forward(v){return [250,v]}
    function lor_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] |= nat2.data[ofs2];return 0}
    function caml_js_on_ie()
     {var
       ua=
        joo_global_object.navigator?joo_global_object.navigator.userAgent:"";
      return ua.indexOf("MSIE") != - 1 && ua.indexOf("Opera") != 0}
    function caml_int64_shift_right(x,s)
     {s = s & 63;
      if(s == 0)return x;
      var h=x[3] << 16 >> 16;
      if(s < 24)
       return [255,
               (x[1] >> s | x[2] << 24 - s) & 0xffffff,
               (x[2] >> s | h << 24 - s) & 0xffffff,
               x[3] << 16 >> s >>> 16];
      var sign=x[3] << 16 >> 31;
      if(s < 48)
       return [255,
               (x[2] >> s - 24 | x[3] << 48 - s) & 0xffffff,
               x[3] << 16 >> s - 24 >> 16 & 0xffffff,
               sign & 0xffff];
      return [255,
              x[3] << 16 >> s - 32 & 0xffffff,
              sign & 0xffffff,
              sign & 0xffff]}
    function caml_ba_layout(ba){return ba.layout}
    function caml_convert_raw_backtrace(){return [0]}
    function caml_array_set(array,index,newval)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      array[index + 1] = newval;
      return 0}
    function caml_bytes_greaterequal(s1,s2)
     {return caml_bytes_lessequal(s2,s1)}
    function set_digit_nat(nat,ofs,digit){nat.data[ofs] = digit;return 0}
    function caml_update_dummy(x,y)
     {if(typeof y === "function"){x.fun = y;return 0}
      if(y.fun){x.fun = y.fun;return 0}
      var i=y.length;
      while(i--)x[i] = y[i];
      return 0}
    function caml_CamlinternalMod_update_mod(shape,real,x)
     {if(typeof shape === "number")
       switch(shape)
        {case 0:real.fun = x;break;case 1:default:caml_update_dummy(real,x)}
      else
       switch(shape[0])
        {case 0:
          for(var i=1;i < shape[1].length;i++)
           caml_CamlinternalMod_update_mod(shape[1][i],real[i],x[i]);
          break
         }
      return 0}
    function caml_ml_output_int(chanid,i)
     {var
       arr=[i >> 24 & 0xFF,i >> 16 & 0xFF,i >> 8 & 0xFF,i & 0xFF],
       s=caml_string_of_array(arr);
      caml_ml_output(chanid,s,0,4);
      return 0}
    function caml_obj_with_tag(tag,x)
     {var l=x.length,a=new Array(l);
      a[0] = tag;
      for(var i=1;i < l;i++)a[i] = x[i];
      return a}
    var caml_initial_time=new Date().getTime() * 0.001;
    function caml_sys_time()
     {var now=new Date().getTime();return now * 0.001 - caml_initial_time}
    function caml_ml_channel_size(chanid)
     {var chan=caml_ml_channels[chanid];return chan.file.length()}
    function caml_raw_backtrace_slot()
     {caml_invalid_argument
       ("Printexc.get_raw_backtrace_slot: index out of bounds")}
    function caml_int64_is_min_int(x)
     {return x[3] == 0x8000 && (x[1] | x[2]) == 0}
    function caml_hexstring_of_float(x,prec,style)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_js_to_string("nan");
        return caml_js_to_string(x > 0?"infinity":"-infinity")}
      var sign=x == 0 && 1 / x == - Infinity?1:x >= 0?0:1;
      if(sign)x = - x;
      var exp=0;
      if(x == 0)
       ;
      else
       if(x < 1)
        while(x < 1 && exp > - 1022){x *= 2;exp--}
       else
        while(x >= 2){x /= 2;exp++}
      var exp_sign=exp < 0?"":"+",sign_str="";
      if(sign)
       sign_str = "-";
      else
       switch(style)
        {case 43:sign_str = "+";break;
         case 32:sign_str = " ";break;
         default:break}
      if(prec >= 0 && prec < 13)
       {var cst=Math.pow(2,prec * 4);x = Math.round(x * cst) / cst}
      var x_str=x.toString(16);
      if(prec >= 0)
       {var idx=x_str.indexOf(".");
        if(idx < 0)
         x_str += "." + caml_str_repeat(prec,"0");
        else
         {var size=idx + 1 + prec;
          if(x_str.length < size)
           x_str += caml_str_repeat(size - x_str.length,"0");
          else
           x_str = x_str.substr(0,size)}}
      return caml_js_to_string
              (sign_str + "0x" + x_str + "p" + exp_sign + exp.toString(10))}
    function caml_js_wrap_meth_callback_strict(arity,f)
     {return function()
       {var n=arguments.length;
        if(n == arity)return caml_call_gen(f,raw_array_cons(arguments,this));
        var args=new Array(arity + 1);
        args[0] = this;
        for(var i=1;i < n && i <= arity;i++)args[i] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_backtrace_status(){return 0}
    function caml_install_signal_handler(){return 0}
    function caml_sys_argv(a){return caml_argv}
    function caml_ba_fill(ba,v){ba.fill(v);return 0}
    function caml_modf_float(x)
     {if(isFinite(x))
       {var neg=1 / x < 0;
        x = Math.abs(x);
        var i=Math.floor(x),f=x - i;
        if(neg){i = - i;f = - f}
        return [0,f,i]}
      if(isNaN(x))return [0,NaN,NaN];
      return [0,1 / x,x]}
    function caml_gc_get(){return [0,0,0,0,0,0,0,0,0]}
    function caml_float_compare(x,y)
     {if(x === y)return 0;
      if(x < y)return - 1;
      if(x > y)return 1;
      if(x === x)return 1;
      if(y === y)return - 1;
      return 0}
    function caml_string_set32(s,i,i32){return caml_bytes_set32(s,i,i32)}
    function caml_parse_engine(tables,env,cmd,arg)
     {var
       ERRCODE=256,
       loop=6,
       testshift=7,
       shift=8,
       shift_recover=9,
       reduce=10,
       READ_TOKEN=0,
       RAISE_PARSE_ERROR=1,
       GROW_STACKS_1=2,
       GROW_STACKS_2=3,
       COMPUTE_SEMANTIC_ACTION=4,
       CALL_ERROR_FUNCTION=5,
       env_s_stack=1,
       env_v_stack=2,
       env_symb_start_stack=3,
       env_symb_end_stack=4,
       env_stacksize=5,
       env_stackbase=6,
       env_curr_char=7,
       env_lval=8,
       env_symb_start=9,
       env_symb_end=10,
       env_asp=11,
       env_rule_len=12,
       env_rule_number=13,
       env_sp=14,
       env_state=15,
       env_errflag=16,
       tbl_transl_const=2,
       tbl_transl_block=3,
       tbl_lhs=4,
       tbl_len=5,
       tbl_defred=6,
       tbl_dgoto=7,
       tbl_sindex=8,
       tbl_rindex=9,
       tbl_gindex=10,
       tbl_tablesize=11,
       tbl_table=12,
       tbl_check=13;
      if(! tables.dgoto)
       {tables.defred = caml_lex_array(tables[tbl_defred]);
        tables.sindex = caml_lex_array(tables[tbl_sindex]);
        tables.check = caml_lex_array(tables[tbl_check]);
        tables.rindex = caml_lex_array(tables[tbl_rindex]);
        tables.table = caml_lex_array(tables[tbl_table]);
        tables.len = caml_lex_array(tables[tbl_len]);
        tables.lhs = caml_lex_array(tables[tbl_lhs]);
        tables.gindex = caml_lex_array(tables[tbl_gindex]);
        tables.dgoto = caml_lex_array(tables[tbl_dgoto])}
      var
       res=0,
       n,
       n1,
       n2,
       state1,
       sp=env[env_sp],
       state=env[env_state],
       errflag=env[env_errflag];
      exit:
      for(;;)
       switch(cmd)
        {case 0:state = 0;errflag = 0;
         case 6:
          n = tables.defred[state];
          if(n != 0){cmd = reduce;break}
          if(env[env_curr_char] >= 0){cmd = testshift;break}
          res = READ_TOKEN;
          break exit;
         case 1:
          if(arg instanceof Array)
           {env[env_curr_char] = tables[tbl_transl_block][arg[0] + 1];
            env[env_lval] = arg[1]}
          else
           {env[env_curr_char] = tables[tbl_transl_const][arg + 1];
            env[env_lval] = 0}
         case 7:
          n1 = tables.sindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {cmd = shift;break}
          n1 = tables.rindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {n = tables.table[n2];cmd = reduce;break}
          if(errflag <= 0){res = CALL_ERROR_FUNCTION;break exit}
         case 5:
          if(errflag < 3)
           {errflag = 3;
            for(;;)
             {state1 = env[env_s_stack][sp + 1];
              n1 = tables.sindex[state1];
              n2 = n1 + ERRCODE;
              if
               (n1
                !=
                0
                &&
                n2
                >=
                0
                &&
                n2
                <=
                tables[tbl_tablesize]
                &&
                tables.check[n2]
                ==
                ERRCODE)
               {cmd = shift_recover;break}
              else
               {if(sp <= env[env_stackbase])return RAISE_PARSE_ERROR;sp--}}}
          else
           {if(env[env_curr_char] == 0)return RAISE_PARSE_ERROR;
            env[env_curr_char] = - 1;
            cmd = loop;
            break}
         case 8:env[env_curr_char] = - 1;if(errflag > 0)errflag--;
         case 9:
          state = tables.table[n2];
          sp++;
          if(sp >= env[env_stacksize]){res = GROW_STACKS_1;break exit}
         case 2:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = env[env_lval];
          env[env_symb_start_stack][sp + 1] = env[env_symb_start];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end];
          cmd = loop;
          break;
         case 10:
          var m=tables.len[n];
          env[env_asp] = sp;
          env[env_rule_number] = n;
          env[env_rule_len] = m;
          sp = sp - m + 1;
          m = tables.lhs[n];
          state1 = env[env_s_stack][sp];
          n1 = tables.gindex[m];
          n2 = n1 + state1;
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            state1)
           state = tables.table[n2];
          else
           state = tables.dgoto[m];
          if(sp >= env[env_stacksize]){res = GROW_STACKS_2;break exit}
         case 3:res = COMPUTE_SEMANTIC_ACTION;break exit;
         case 4:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = arg;
          var asp=env[env_asp];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end_stack][asp + 1];
          if(sp > asp)
           env[env_symb_start_stack][sp + 1]
           =
           env[env_symb_end_stack][asp + 1];
          cmd = loop;
          break;
         default:return RAISE_PARSE_ERROR}
      env[env_sp] = sp;
      env[env_state] = state;
      env[env_errflag] = errflag;
      return res}
    function caml_array_fill(array,ofs,len,v)
     {for(var i=0;i < len;i++)array[ofs + i + 1] = v;return 0}
    function caml_string_notequal(s1,s2){return 1 - caml_string_equal(s1,s2)}
    function caml_bytes_greaterthan(s1,s2){return caml_bytes_lessthan(s2,s1)}
    function caml_ml_set_channel_output(chanid,f)
     {var chan=caml_ml_channels[chanid];
      caml_global_data.fds[chan.fd].output = f;
      return 0}
    function caml_read_file_content(name)
     {var root=resolve_fs_device(name);
      if(root.device.exists(root.rest))
       {var
         file=root.device.open(root.rest,{rdonly:1}),
         len=file.length(),
         buf=caml_create_bytes(len);
        file.read(0,buf,0,len);
        return buf}
      caml_raise_no_such_file(name)}
    function caml_js_to_float(x){return x}
    joo_global_object.jsoo_runtime
    =
    {caml_ephe_check_data:caml_ephe_check_data,
     caml_ephe_unset_data:caml_ephe_unset_data,
     caml_ephe_set_data:caml_ephe_set_data,
     caml_ephe_get_data_copy:caml_ephe_get_data_copy,
     caml_ephe_get_data:caml_ephe_get_data,
     caml_ephe_blit_data:caml_ephe_blit_data,
     caml_ephe_unset_key:caml_ephe_unset_key,
     caml_ephe_set_key:caml_ephe_set_key,
     caml_ephe_check_key:caml_ephe_check_key,
     caml_ephe_get_key_copy:caml_ephe_get_key_copy,
     caml_ephe_get_key:caml_ephe_get_key,
     caml_ephe_blit_key:caml_ephe_blit_key,
     caml_ephe_create:caml_ephe_create,
     caml_weak_blit:caml_weak_blit,
     caml_weak_check:caml_weak_check,
     caml_weak_get_copy:caml_weak_get_copy,
     caml_weak_get:caml_weak_get,
     caml_weak_set:caml_weak_set,
     caml_weak_create:caml_weak_create,
     caml_ephe_data_offset:caml_ephe_data_offset,
     caml_ephe_key_offset:caml_ephe_key_offset,
     win_handle_fd:win_handle_fd,
     win_cleanup:win_cleanup,
     win_startup:win_startup,
     unix_mktime:unix_mktime,
     unix_localtime:unix_localtime,
     unix_gmtime:unix_gmtime,
     unix_time:unix_time,
     unix_gettimeofday:unix_gettimeofday,
     caml_is_js:caml_is_js,
     caml_spacetime_only_works_for_native_code:
     caml_spacetime_only_works_for_native_code,
     caml_register_channel_for_spacetime:caml_register_channel_for_spacetime,
     caml_spacetime_enabled:caml_spacetime_enabled,
     caml_sys_isatty:caml_sys_isatty,
     caml_runtime_parameters:caml_runtime_parameters,
     caml_runtime_variant:caml_runtime_variant,
     caml_ml_runtime_warnings_enabled:caml_ml_runtime_warnings_enabled,
     caml_ml_enable_runtime_warnings:caml_ml_enable_runtime_warnings,
     caml_runtime_warnings:caml_runtime_warnings,
     caml_list_to_js_array:caml_list_to_js_array,
     caml_list_of_js_array:caml_list_of_js_array,
     caml_int64_bswap:caml_int64_bswap,
     caml_int32_bswap:caml_int32_bswap,
     caml_bswap16:caml_bswap16,
     caml_convert_raw_backtrace_slot:caml_convert_raw_backtrace_slot,
     caml_install_signal_handler:caml_install_signal_handler,
     caml_fresh_oo_id:caml_fresh_oo_id,
     caml_set_oo_id:caml_set_oo_id,
     caml_oo_last_id:caml_oo_last_id,
     unix_inet_addr_of_string:unix_inet_addr_of_string,
     caml_sys_executable_name:caml_sys_executable_name,
     caml_sys_modify_argv:caml_sys_modify_argv,
     caml_sys_argv:caml_sys_argv,
     caml_sys_get_argv:caml_sys_get_argv,
     caml_executable_name:caml_executable_name,
     caml_argv:caml_argv,
     caml_sys_exit:caml_sys_exit,
     caml_sys_getenv:caml_sys_getenv,
     caml_set_static_env:caml_set_static_env,
     caml_get_current_callstack:caml_get_current_callstack,
     caml_restore_raw_backtrace:caml_restore_raw_backtrace,
     caml_raw_backtrace_slot:caml_raw_backtrace_slot,
     caml_raw_backtrace_next_slot:caml_raw_backtrace_next_slot,
     caml_raw_backtrace_length:caml_raw_backtrace_length,
     caml_convert_raw_backtrace:caml_convert_raw_backtrace,
     caml_record_backtrace:caml_record_backtrace,
     caml_get_exception_raw_backtrace:caml_get_exception_raw_backtrace,
     caml_get_exception_backtrace:caml_get_exception_backtrace,
     caml_backtrace_status:caml_backtrace_status,
     caml_final_release:caml_final_release,
     caml_final_register_called_without_value:
     caml_final_register_called_without_value,
     caml_final_register:caml_final_register,
     caml_get_public_method:caml_get_public_method,
     caml_array_blit:caml_array_blit,
     caml_array_concat:caml_array_concat,
     caml_array_append:caml_array_append,
     caml_array_sub:caml_array_sub,
     caml_sys_system_command:caml_sys_system_command,
     caml_sys_const_ostype_win32:caml_sys_const_ostype_win32,
     caml_sys_const_ostype_unix:caml_sys_const_ostype_unix,
     caml_sys_const_ostype_cygwin:caml_sys_const_ostype_cygwin,
     caml_sys_const_max_wosize:caml_sys_const_max_wosize,
     caml_sys_const_int_size:caml_sys_const_int_size,
     caml_sys_const_word_size:caml_sys_const_word_size,
     caml_sys_const_big_endian:caml_sys_const_big_endian,
     caml_sys_random_seed:caml_sys_random_seed,
     caml_sys_const_backend_type:caml_sys_const_backend_type,
     caml_sys_get_config:caml_sys_get_config,
     caml_sys_time:caml_sys_time,
     caml_hash:caml_hash,
     caml_hash_mix_string:caml_hash_mix_string,
     caml_hash_mix_string_arr:caml_hash_mix_string_arr,
     caml_hash_mix_string_str:caml_hash_mix_string_str,
     caml_hash_mix_int64:caml_hash_mix_int64,
     caml_hash_mix_float:caml_hash_mix_float,
     caml_hash_mix_final:caml_hash_mix_final,
     caml_hash_mix_int:caml_hash_mix_int,
     caml_hash_univ_param:caml_hash_univ_param,
     caml_format_float:caml_format_float,
     caml_format_int:caml_format_int,
     caml_finish_formatting:caml_finish_formatting,
     caml_parse_format:caml_parse_format,
     caml_is_printable:caml_is_printable,
     caml_float_of_string:caml_float_of_string,
     caml_int_of_string:caml_int_of_string,
     caml_parse_digit:caml_parse_digit,
     caml_parse_sign_and_base:caml_parse_sign_and_base,
     caml_lessthan:caml_lessthan,
     caml_lessequal:caml_lessequal,
     caml_greaterthan:caml_greaterthan,
     caml_greaterequal:caml_greaterequal,
     caml_notequal:caml_notequal,
     caml_equal:caml_equal,
     caml_int_compare:caml_int_compare,
     caml_compare:caml_compare,
     caml_compare_val:caml_compare_val,
     caml_compare_val_number_custom:caml_compare_val_number_custom,
     caml_compare_val_get_custom:caml_compare_val_get_custom,
     caml_compare_val_tag:caml_compare_val_tag,
     caml_floatarray_create:caml_floatarray_create,
     caml_make_float_vect:caml_make_float_vect,
     caml_make_vect:caml_make_vect,
     caml_check_bound:caml_check_bound,
     caml_array_fill:caml_array_fill,
     caml_array_get:caml_array_get,
     caml_array_set:caml_array_set,
     caml_mod:caml_mod,
     caml_div:caml_div,
     caml_mul:caml_mul,
     caml_lazy_make_forward:caml_lazy_make_forward,
     caml_obj_make_forward:caml_obj_make_forward,
     caml_obj_truncate:caml_obj_truncate,
     caml_obj_dup:caml_obj_dup,
     caml_obj_with_tag:caml_obj_with_tag,
     caml_obj_block:caml_obj_block,
     caml_obj_set_tag:caml_obj_set_tag,
     caml_obj_tag:caml_obj_tag,
     caml_obj_is_block:caml_obj_is_block,
     caml_update_dummy:caml_update_dummy,
     caml_array_bound_error:caml_array_bound_error,
     caml_raise_not_found:caml_raise_not_found,
     caml_raise_zero_divide:caml_raise_zero_divide,
     caml_raise_end_of_file:caml_raise_end_of_file,
     caml_invalid_argument:caml_invalid_argument,
     caml_js_error_of_exception:caml_js_error_of_exception,
     caml_exn_with_js_backtrace:caml_exn_with_js_backtrace,
     caml_wrap_exception:caml_wrap_exception,
     caml_failwith:caml_failwith,
     caml_raise_sys_error:caml_raise_sys_error,
     caml_raise_with_string:caml_raise_with_string,
     caml_raise_with_arg:caml_raise_with_arg,
     caml_return_exn_constant:caml_return_exn_constant,
     caml_raise_constant:caml_raise_constant,
     caml_get_global_data:caml_get_global_data,
     caml_register_global:caml_register_global,
     caml_global_data:caml_global_data,
     caml_named_value:caml_named_value,
     caml_register_named_value:caml_register_named_value,
     caml_named_values:caml_named_values,
     caml_call_gen:caml_call_gen,
     raw_array_append_one:raw_array_append_one,
     raw_array_cons:raw_array_cons,
     raw_array_copy:raw_array_copy,
     raw_array_sub:raw_array_sub,
     caml_json:caml_json,
     JSON:JSON,
     caml_set_parser_trace:caml_set_parser_trace,
     caml_parse_engine:caml_parse_engine,
     deserialize_nat:deserialize_nat,
     serialize_nat:serialize_nat,
     lxor_digit_nat:lxor_digit_nat,
     lor_digit_nat:lor_digit_nat,
     land_digit_nat:land_digit_nat,
     compare_nat_real:compare_nat_real,
     compare_nat:compare_nat,
     compare_digits_nat:compare_digits_nat,
     shift_right_nat:shift_right_nat,
     div_nat:div_nat,
     div_digit_nat:div_digit_nat,
     div_helper:div_helper,
     shift_left_nat:shift_left_nat,
     square_nat:square_nat,
     mult_nat:mult_nat,
     mult_digit_nat:mult_digit_nat,
     sub_nat:sub_nat,
     decr_nat:decr_nat,
     complement_nat:complement_nat,
     add_nat:add_nat,
     incr_nat:incr_nat,
     is_digit_odd:is_digit_odd,
     is_digit_zero:is_digit_zero,
     is_digit_int:is_digit_int,
     num_leading_zero_bits_in_digit:num_leading_zero_bits_in_digit,
     num_digits_nat:num_digits_nat,
     nth_digit_nat_native:nth_digit_nat_native,
     set_digit_nat_native:set_digit_nat_native,
     nth_digit_nat:nth_digit_nat,
     set_digit_nat:set_digit_nat,
     blit_nat:blit_nat,
     set_to_zero_nat:set_to_zero_nat,
     create_nat:create_nat,
     nat_of_array:nat_of_array,
     caml_hash_nat:caml_hash_nat,
     MlNat:MlNat,
     initialize_nat:initialize_nat,
     caml_bytes_of_string:caml_bytes_of_string,
     caml_string_of_bytes:caml_string_of_bytes,
     caml_ml_bytes_length:caml_ml_bytes_length,
     caml_ml_string_length:caml_ml_string_length,
     caml_blit_string:caml_blit_string,
     caml_blit_bytes:caml_blit_bytes,
     caml_fill_string:caml_fill_string,
     caml_fill_bytes:caml_fill_bytes,
     caml_bytes_greaterthan:caml_bytes_greaterthan,
     caml_string_greaterthan:caml_string_greaterthan,
     caml_bytes_greaterequal:caml_bytes_greaterequal,
     caml_string_greaterequal:caml_string_greaterequal,
     caml_bytes_lessthan:caml_bytes_lessthan,
     caml_string_lessthan:caml_string_lessthan,
     caml_bytes_lessequal:caml_bytes_lessequal,
     caml_string_lessequal:caml_string_lessequal,
     caml_bytes_notequal:caml_bytes_notequal,
     caml_string_notequal:caml_string_notequal,
     caml_bytes_equal:caml_bytes_equal,
     caml_string_equal:caml_string_equal,
     caml_bytes_compare:caml_bytes_compare,
     caml_string_compare:caml_string_compare,
     caml_string_of_array:caml_string_of_array,
     caml_new_string:caml_new_string,
     caml_create_bytes:caml_create_bytes,
     caml_create_string:caml_create_string,
     caml_js_to_string:caml_js_to_string,
     caml_jsbytes_of_string:caml_jsbytes_of_string,
     caml_array_of_string:caml_array_of_string,
     caml_convert_string_to_array:caml_convert_string_to_array,
     caml_convert_string_to_bytes:caml_convert_string_to_bytes,
     MlBytes:MlBytes,
     caml_bytes_set:caml_bytes_set,
     caml_string_set64:caml_string_set64,
     caml_bytes_set64:caml_bytes_set64,
     caml_string_set32:caml_string_set32,
     caml_bytes_set32:caml_bytes_set32,
     caml_string_set16:caml_string_set16,
     caml_bytes_set16:caml_bytes_set16,
     caml_string_set:caml_string_set,
     caml_bytes_get:caml_bytes_get,
     caml_bytes_get64:caml_bytes_get64,
     caml_string_get64:caml_string_get64,
     caml_bytes_get32:caml_bytes_get32,
     caml_string_get32:caml_string_get32,
     caml_bytes_get16:caml_bytes_get16,
     caml_string_get16:caml_string_get16,
     caml_string_get:caml_string_get,
     caml_string_bound_error:caml_string_bound_error,
     caml_string_unsafe_set:caml_string_unsafe_set,
     caml_bytes_unsafe_set:caml_bytes_unsafe_set,
     caml_bytes_unsafe_get:caml_bytes_unsafe_get,
     caml_string_unsafe_get:caml_string_unsafe_get,
     caml_to_js_string:caml_to_js_string,
     caml_is_ascii:caml_is_ascii,
     caml_utf16_of_utf8:caml_utf16_of_utf8,
     caml_utf8_of_utf16:caml_utf8_of_utf16,
     caml_subarray_to_string:caml_subarray_to_string,
     caml_str_repeat:caml_str_repeat,
     caml_md5_string:caml_md5_string,
     caml_md5_chan:caml_md5_chan,
     caml_output_value_to_buffer:caml_output_value_to_buffer,
     caml_output_value_to_bytes:caml_output_value_to_bytes,
     caml_output_value_to_string:caml_output_value_to_string,
     caml_output_val:caml_output_val,
     caml_legacy_custom_code:caml_legacy_custom_code,
     MlObjectTable:MlObjectTable,
     caml_marshal_data_size:caml_marshal_data_size,
     caml_input_value_from_reader:caml_input_value_from_reader,
     caml_custom_ops:caml_custom_ops,
     caml_nativeint_unmarshal:caml_nativeint_unmarshal,
     caml_int32_unmarshal:caml_int32_unmarshal,
     caml_int64_marshal:caml_int64_marshal,
     caml_int64_unmarshal:caml_int64_unmarshal,
     caml_input_value_from_bytes:caml_input_value_from_bytes,
     caml_input_value_from_string:caml_input_value_from_string,
     caml_float_of_bytes:caml_float_of_bytes,
     BigStringReader:BigStringReader,
     MlBytesReader:MlBytesReader,
     caml_marshal_constants:caml_marshal_constants,
     caml_new_lex_engine:caml_new_lex_engine,
     caml_lex_engine:caml_lex_engine,
     caml_lex_array:caml_lex_array,
     caml_js_export_var:caml_js_export_var,
     caml_js_object:caml_js_object,
     caml_pure_js_expr:caml_pure_js_expr,
     caml_js_expr:caml_js_expr,
     caml_js_eval_string:caml_js_eval_string,
     caml_js_to_byte_string:caml_js_to_byte_string,
     caml_js_equals:caml_js_equals,
     caml_js_wrap_meth_callback_unsafe:caml_js_wrap_meth_callback_unsafe,
     caml_js_wrap_meth_callback_strict:caml_js_wrap_meth_callback_strict,
     caml_js_wrap_meth_callback_arguments:caml_js_wrap_meth_callback_arguments,
     caml_js_wrap_meth_callback:caml_js_wrap_meth_callback,
     caml_js_wrap_callback_strict:caml_js_wrap_callback_strict,
     caml_js_wrap_callback_arguments:caml_js_wrap_callback_arguments,
     caml_js_wrap_callback:caml_js_wrap_callback,
     caml_ojs_new_arr:caml_ojs_new_arr,
     caml_js_new:caml_js_new,
     caml_js_meth_call:caml_js_meth_call,
     caml_js_fun_call:caml_js_fun_call,
     caml_js_call:caml_js_call,
     caml_js_var:caml_js_var,
     caml_js_to_array:caml_js_to_array,
     caml_js_from_array:caml_js_from_array,
     caml_js_from_string:caml_js_from_string,
     caml_js_to_float:caml_js_to_float,
     caml_js_from_float:caml_js_from_float,
     caml_js_to_bool:caml_js_to_bool,
     caml_js_from_bool:caml_js_from_bool,
     js_print_stderr:js_print_stderr,
     js_print_stdout:js_print_stdout,
     caml_trampoline_return:caml_trampoline_return,
     caml_trampoline:caml_trampoline,
     caml_js_get_console:caml_js_get_console,
     caml_js_html_entities:caml_js_html_entities,
     caml_js_html_escape:caml_js_html_escape,
     caml_js_on_ie:caml_js_on_ie,
     caml_js_typeof:caml_js_typeof,
     caml_js_instanceof:caml_js_instanceof,
     caml_js_delete:caml_js_delete,
     caml_js_get:caml_js_get,
     caml_js_set:caml_js_set,
     caml_js_pure_expr:caml_js_pure_expr,
     caml_ml_output_int:caml_ml_output_int,
     caml_ml_pos_out_64:caml_ml_pos_out_64,
     caml_ml_pos_out:caml_ml_pos_out,
     caml_ml_seek_out_64:caml_ml_seek_out_64,
     caml_ml_seek_out:caml_ml_seek_out,
     caml_output_value:caml_output_value,
     caml_ml_output_char:caml_ml_output_char,
     caml_ml_output:caml_ml_output,
     caml_ml_output_bytes:caml_ml_output_bytes,
     caml_ml_flush:caml_ml_flush,
     caml_ml_input_scan_line:caml_ml_input_scan_line,
     caml_ml_pos_in_64:caml_ml_pos_in_64,
     caml_ml_pos_in:caml_ml_pos_in,
     caml_ml_seek_in_64:caml_ml_seek_in_64,
     caml_ml_seek_in:caml_ml_seek_in,
     caml_ml_input_int:caml_ml_input_int,
     caml_ml_input_char:caml_ml_input_char,
     caml_input_value:caml_input_value,
     caml_ml_input:caml_ml_input,
     caml_ml_may_refill_input:caml_ml_may_refill_input,
     caml_ml_refill_input:caml_ml_refill_input,
     caml_ml_set_channel_refill:caml_ml_set_channel_refill,
     caml_ml_set_channel_output:caml_ml_set_channel_output,
     caml_ml_channel_size_64:caml_ml_channel_size_64,
     caml_ml_channel_size:caml_ml_channel_size,
     caml_ml_close_channel:caml_ml_close_channel,
     caml_ml_set_binary_mode:caml_ml_set_binary_mode,
     caml_ml_open_descriptor_in:caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out:caml_ml_open_descriptor_out,
     caml_ml_out_channels_list:caml_ml_out_channels_list,
     caml_ml_channels:caml_ml_channels,
     caml_ml_set_channel_name:caml_ml_set_channel_name,
     caml_sys_open:caml_sys_open,
     caml_std_output:caml_std_output,
     caml_sys_close:caml_sys_close,
     caml_CamlinternalMod_update_mod:caml_CamlinternalMod_update_mod,
     caml_CamlinternalMod_init_mod:caml_CamlinternalMod_init_mod,
     caml_int64_hash:caml_int64_hash,
     caml_int64_to_bytes:caml_int64_to_bytes,
     caml_int64_of_bytes:caml_int64_of_bytes,
     caml_int64_hi32:caml_int64_hi32,
     caml_int64_lo32:caml_int64_lo32,
     caml_int64_create_lo_hi:caml_int64_create_lo_hi,
     caml_int64_create_lo_mi_hi:caml_int64_create_lo_mi_hi,
     caml_int64_of_string:caml_int64_of_string,
     caml_int64_format:caml_int64_format,
     caml_int64_of_float:caml_int64_of_float,
     caml_int64_to_float:caml_int64_to_float,
     caml_int64_to_int32:caml_int64_to_int32,
     caml_int64_of_int32:caml_int64_of_int32,
     caml_int64_mod:caml_int64_mod,
     caml_int64_div:caml_int64_div,
     caml_int64_udivmod:caml_int64_udivmod,
     caml_int64_lsr1:caml_int64_lsr1,
     caml_int64_lsl1:caml_int64_lsl1,
     caml_int64_shift_right:caml_int64_shift_right,
     caml_int64_shift_right_unsigned:caml_int64_shift_right_unsigned,
     caml_int64_shift_left:caml_int64_shift_left,
     caml_int64_xor:caml_int64_xor,
     caml_int64_or:caml_int64_or,
     caml_int64_and:caml_int64_and,
     caml_int64_is_minus_one:caml_int64_is_minus_one,
     caml_int64_is_min_int:caml_int64_is_min_int,
     caml_int64_is_negative:caml_int64_is_negative,
     caml_int64_is_zero:caml_int64_is_zero,
     caml_int64_mul:caml_int64_mul,
     caml_int64_sub:caml_int64_sub,
     caml_int64_add:caml_int64_add,
     caml_int64_neg:caml_int64_neg,
     caml_int64_compare:caml_int64_compare,
     caml_int64_ult:caml_int64_ult,
     caml_int64_ucompare:caml_int64_ucompare,
     caml_int64_offset:caml_int64_offset,
     caml_round_float:caml_round_float,
     caml_tanh_float:caml_tanh_float,
     caml_sinh_float:caml_sinh_float,
     caml_cosh_float:caml_cosh_float,
     caml_log10_float:caml_log10_float,
     caml_hypot_float:caml_hypot_float,
     caml_log1p_float:caml_log1p_float,
     caml_expm1_float:caml_expm1_float,
     caml_signbit_float:caml_signbit_float,
     caml_copysign_float:caml_copysign_float,
     caml_float_compare:caml_float_compare,
     caml_frexp_float:caml_frexp_float,
     caml_ldexp_float:caml_ldexp_float,
     caml_modf_float:caml_modf_float,
     caml_classify_float:caml_classify_float,
     caml_int32_float_of_bits:caml_int32_float_of_bits,
     caml_trunc_float:caml_trunc_float,
     caml_nextafter_float:caml_nextafter_float,
     caml_int64_float_of_bits:caml_int64_float_of_bits,
     caml_hexstring_of_float:caml_hexstring_of_float,
     caml_int32_bits_of_float:caml_int32_bits_of_float,
     caml_int64_bits_of_float:caml_int64_bits_of_float,
     jsoo_floor_log2:jsoo_floor_log2,
     caml_memprof_set:caml_memprof_set,
     caml_gc_get:caml_gc_get,
     caml_gc_set:caml_gc_set,
     caml_gc_stat:caml_gc_stat,
     caml_gc_quick_stat:caml_gc_quick_stat,
     caml_gc_counters:caml_gc_counters,
     caml_gc_compaction:caml_gc_compaction,
     caml_gc_full_major:caml_gc_full_major,
     caml_gc_major:caml_gc_major,
     caml_gc_minor:caml_gc_minor,
     MlNodeFile:MlNodeFile,
     MlNodeDevice:MlNodeDevice,
     fs_node_supported:fs_node_supported,
     MlFakeFile:MlFakeFile,
     MlFakeDevice:MlFakeDevice,
     caml_read_file_content:caml_read_file_content,
     caml_create_file:caml_create_file,
     caml_fs_init:caml_fs_init,
     caml_create_file_extern:caml_create_file_extern,
     caml_ba_map_file_bytecode:caml_ba_map_file_bytecode,
     caml_ba_map_file:caml_ba_map_file,
     caml_sys_rename:caml_sys_rename,
     caml_sys_is_directory:caml_sys_is_directory,
     caml_sys_remove:caml_sys_remove,
     caml_sys_read_directory:caml_sys_read_directory,
     caml_sys_file_exists:caml_sys_file_exists,
     caml_raise_not_a_dir:caml_raise_not_a_dir,
     caml_raise_no_such_file:caml_raise_no_such_file,
     caml_sys_chdir:caml_sys_chdir,
     caml_sys_getcwd:caml_sys_getcwd,
     caml_unmount:caml_unmount,
     caml_mount_autoload:caml_mount_autoload,
     resolve_fs_device:resolve_fs_device,
     caml_list_mount_point:caml_list_mount_point,
     jsoo_mount_point:jsoo_mount_point,
     caml_make_path:caml_make_path,
     MlFile:MlFile,
     caml_root:caml_root,
     caml_current_dir:caml_current_dir,
     caml_bigstring_blit_ba_to_bytes:caml_bigstring_blit_ba_to_bytes,
     caml_bigstring_blit_string_to_ba:caml_bigstring_blit_string_to_ba,
     caml_bigstring_blit_ba_to_ba:caml_bigstring_blit_ba_to_ba,
     caml_bigstring_memcmp:caml_bigstring_memcmp,
     bigstring_of_typed_array:bigstring_of_typed_array,
     bigstring_of_array_buffer:bigstring_of_array_buffer,
     bigstring_to_typed_array:bigstring_to_typed_array,
     bigstring_to_array_buffer:bigstring_to_array_buffer,
     caml_hash_mix_bigstring:caml_hash_mix_bigstring,
     caml_blit_string_to_bigstring:caml_blit_string_to_bigstring,
     caml_blit_bigstring_to_string:caml_blit_bigstring_to_string,
     caml_blit_bigstring_to_bigstring:caml_blit_bigstring_to_bigstring,
     caml_ba_hash:caml_ba_hash,
     caml_ba_create_from:caml_ba_create_from,
     caml_ba_deserialize:caml_ba_deserialize,
     caml_ba_serialize:caml_ba_serialize,
     caml_ba_reshape:caml_ba_reshape,
     caml_ba_slice:caml_ba_slice,
     caml_ba_sub:caml_ba_sub,
     caml_ba_blit:caml_ba_blit,
     caml_ba_fill:caml_ba_fill,
     caml_ba_set_3:caml_ba_set_3,
     caml_ba_set_2:caml_ba_set_2,
     caml_ba_set_1:caml_ba_set_1,
     caml_ba_uint8_set64:caml_ba_uint8_set64,
     caml_ba_uint8_set32:caml_ba_uint8_set32,
     caml_ba_uint8_set16:caml_ba_uint8_set16,
     caml_ba_set_generic:caml_ba_set_generic,
     caml_ba_get_3:caml_ba_get_3,
     caml_ba_get_2:caml_ba_get_2,
     caml_ba_get_1:caml_ba_get_1,
     caml_ba_uint8_get64:caml_ba_uint8_get64,
     caml_ba_uint8_get32:caml_ba_uint8_get32,
     caml_ba_uint8_get16:caml_ba_uint8_get16,
     caml_ba_get_generic:caml_ba_get_generic,
     caml_ba_dim_3:caml_ba_dim_3,
     caml_ba_dim_2:caml_ba_dim_2,
     caml_ba_dim_1:caml_ba_dim_1,
     caml_ba_dim:caml_ba_dim,
     caml_ba_num_dims:caml_ba_num_dims,
     caml_ba_layout:caml_ba_layout,
     caml_ba_kind:caml_ba_kind,
     caml_ba_change_layout:caml_ba_change_layout,
     caml_ba_create:caml_ba_create,
     caml_ba_create_unsafe:caml_ba_create_unsafe,
     caml_ba_compare:caml_ba_compare,
     Ml_Bigarray_c_1_1:Ml_Bigarray_c_1_1,
     Ml_Bigarray:Ml_Bigarray,
     caml_ba_create_buffer:caml_ba_create_buffer,
     caml_ba_get_size_per_element:caml_ba_get_size_per_element,
     caml_ba_get_size:caml_ba_get_size,
     caml_ba_init:caml_ba_init};
    caml_fs_init();
    caml_register_global
     (0,[248,caml_new_string("Out_of_memory"),0],"Out_of_memory");
    caml_register_global(1,[248,caml_new_string("Sys_error"),-1],"Sys_error");
    caml_register_global(2,[248,caml_new_string("Failure"),-2],"Failure");
    caml_register_global
     (3,[248,caml_new_string("Invalid_argument"),-3],"Invalid_argument");
    caml_register_global
     (4,[248,caml_new_string("End_of_file"),-4],"End_of_file");
    caml_register_global
     (5,[248,caml_new_string("Division_by_zero"),-5],"Division_by_zero");
    caml_register_global(6,[248,caml_new_string("Not_found"),-6],"Not_found");
    caml_register_global
     (7,[248,caml_new_string("Match_failure"),-7],"Match_failure");
    caml_register_global
     (8,[248,caml_new_string("Stack_overflow"),-8],"Stack_overflow");
    caml_register_global
     (9,[248,caml_new_string("Sys_blocked_io"),-9],"Sys_blocked_io");
    caml_register_global
     (10,[248,caml_new_string("Assert_failure"),-10],"Assert_failure");
    caml_register_global
     (11,
      [248,caml_new_string("Undefined_recursive_module"),-11],
      "Undefined_recursive_module");
    return}
  (function(){return this}()));


//# 1 "../.js/stdlib/stdlib.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_array_concat=runtime.caml_array_concat,
     caml_array_sub=runtime.caml_array_sub,
     caml_blit_bytes=runtime.caml_blit_bytes,
     caml_blit_string=runtime.caml_blit_string,
     caml_bytes_get=runtime.caml_bytes_get,
     caml_bytes_set=runtime.caml_bytes_set,
     caml_bytes_unsafe_get=runtime.caml_bytes_unsafe_get,
     caml_bytes_unsafe_set=runtime.caml_bytes_unsafe_set,
     caml_check_bound=runtime.caml_check_bound,
     caml_compare=runtime.caml_compare,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_equal=runtime.caml_equal,
     caml_fill_bytes=runtime.caml_fill_bytes,
     caml_float_of_string=runtime.caml_float_of_string,
     caml_format_float=runtime.caml_format_float,
     caml_format_int=runtime.caml_format_int,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_get_exception_raw_backtrace=runtime.caml_get_exception_raw_backtrace,
     caml_get_public_method=runtime.caml_get_public_method,
     caml_greaterequal=runtime.caml_greaterequal,
     caml_greaterthan=runtime.caml_greaterthan,
     caml_hash=runtime.caml_hash,
     caml_input_value=runtime.caml_input_value,
     caml_int64_add=runtime.caml_int64_add,
     caml_int64_compare=runtime.caml_int64_compare,
     caml_int64_float_of_bits=runtime.caml_int64_float_of_bits,
     caml_int64_format=runtime.caml_int64_format,
     caml_int64_of_int32=runtime.caml_int64_of_int32,
     caml_int64_of_string=runtime.caml_int64_of_string,
     caml_int64_or=runtime.caml_int64_or,
     caml_int64_shift_left=runtime.caml_int64_shift_left,
     caml_int64_sub=runtime.caml_int64_sub,
     caml_int_compare=runtime.caml_int_compare,
     caml_int_of_string=runtime.caml_int_of_string,
     caml_lessequal=runtime.caml_lessequal,
     caml_make_vect=runtime.caml_make_vect,
     caml_marshal_data_size=runtime.caml_marshal_data_size,
     caml_md5_string=runtime.caml_md5_string,
     caml_ml_bytes_length=runtime.caml_ml_bytes_length,
     caml_ml_channel_size=runtime.caml_ml_channel_size,
     caml_ml_channel_size_64=runtime.caml_ml_channel_size_64,
     caml_ml_close_channel=runtime.caml_ml_close_channel,
     caml_ml_flush=runtime.caml_ml_flush,
     caml_ml_input=runtime.caml_ml_input,
     caml_ml_input_char=runtime.caml_ml_input_char,
     caml_ml_open_descriptor_in=runtime.caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out=runtime.caml_ml_open_descriptor_out,
     caml_ml_output=runtime.caml_ml_output,
     caml_ml_output_bytes=runtime.caml_ml_output_bytes,
     caml_ml_output_char=runtime.caml_ml_output_char,
     caml_ml_set_binary_mode=runtime.caml_ml_set_binary_mode,
     caml_ml_set_channel_name=runtime.caml_ml_set_channel_name,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_mod=runtime.caml_mod,
     caml_new_string=runtime.caml_new_string,
     caml_notequal=runtime.caml_notequal,
     caml_obj_block=runtime.caml_obj_block,
     caml_obj_set_tag=runtime.caml_obj_set_tag,
     caml_obj_tag=runtime.caml_obj_tag,
     caml_obj_truncate=runtime.caml_obj_truncate,
     caml_output_value=runtime.caml_output_value,
     caml_register_global=runtime.caml_register_global,
     caml_register_named_value=runtime.caml_register_named_value,
     caml_set_oo_id=runtime.caml_set_oo_id,
     caml_spacetime_enabled=runtime.caml_spacetime_enabled,
     caml_spacetime_only_works_for_native_code=
      runtime.caml_spacetime_only_works_for_native_code,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_equal=runtime.caml_string_equal,
     caml_string_get=runtime.caml_string_get,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_sys_getenv=runtime.caml_sys_getenv,
     caml_sys_open=runtime.caml_sys_open,
     caml_sys_random_seed=runtime.caml_sys_random_seed,
     caml_trampoline=runtime.caml_trampoline,
     caml_trampoline_return=runtime.caml_trampoline_return,
     caml_weak_blit=runtime.caml_weak_blit,
     caml_weak_check=runtime.caml_weak_check,
     caml_weak_create=runtime.caml_weak_create,
     caml_weak_get=runtime.caml_weak_get,
     caml_weak_get_copy=runtime.caml_weak_get_copy,
     caml_weak_set=runtime.caml_weak_set,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    var
     global_data=runtime.caml_get_global_data(),
     cst$0=caml_new_string("%,"),
     cst_really_input=caml_new_string("really_input"),
     cst_input=caml_new_string("input"),
     cst_output_substring=caml_new_string("output_substring"),
     cst_output=caml_new_string("output"),
     cst_12g=caml_new_string("%.12g"),
     cst=caml_new_string("."),
     cst_false$1=caml_new_string("false"),
     cst_true$1=caml_new_string("true"),
     cst_false$0=caml_new_string("false"),
     cst_true$0=caml_new_string("true"),
     cst_bool_of_string=caml_new_string("bool_of_string"),
     cst_true=caml_new_string("true"),
     cst_false=caml_new_string("false"),
     cst_char_of_int=caml_new_string("char_of_int"),
     cst_Pervasives_Exit=caml_new_string("Pervasives.Exit"),
     cst_List_map2=caml_new_string("List.map2"),
     cst_List_iter2=caml_new_string("List.iter2"),
     cst_List_fold_left2=caml_new_string("List.fold_left2"),
     cst_List_fold_right2=caml_new_string("List.fold_right2"),
     cst_List_for_all2=caml_new_string("List.for_all2"),
     cst_List_exists2=caml_new_string("List.exists2"),
     cst_List_combine=caml_new_string("List.combine"),
     cst_List_rev_map2=caml_new_string("List.rev_map2"),
     cst_List_init=caml_new_string("List.init"),
     cst_List_nth$0=caml_new_string("List.nth"),
     cst_nth=caml_new_string("nth"),
     cst_List_nth=caml_new_string("List.nth"),
     cst_tl=caml_new_string("tl"),
     cst_hd=caml_new_string("hd"),
     cst$1=caml_new_string("\\\\"),
     cst$2=caml_new_string("\\'"),
     cst_b=caml_new_string("\\b"),
     cst_t=caml_new_string("\\t"),
     cst_n=caml_new_string("\\n"),
     cst_r=caml_new_string("\\r"),
     cst_Char_chr=caml_new_string("Char.chr"),
     cst_is_not_a_latin1_character=
      caml_new_string(" is not a latin1 character"),
     cst_04X=caml_new_string("%04X"),
     cst_U=caml_new_string("U+"),
     cst_is_not_an_Unicode_scalar_value=
      caml_new_string(" is not an Unicode scalar value"),
     cst_X=caml_new_string("%X"),
     err_no_pred=caml_new_string("U+0000 has no predecessor"),
     err_no_succ=caml_new_string("U+10FFFF has no successor"),
     cst_String_rcontains_from_Bytes_rcontains_from=
      caml_new_string("String.rcontains_from / Bytes.rcontains_from"),
     cst_String_contains_from_Bytes_contains_from=
      caml_new_string("String.contains_from / Bytes.contains_from"),
     cst_String_rindex_from_opt_Bytes_rindex_from_opt=
      caml_new_string("String.rindex_from_opt / Bytes.rindex_from_opt"),
     cst_String_rindex_from_Bytes_rindex_from=
      caml_new_string("String.rindex_from / Bytes.rindex_from"),
     cst_String_index_from_opt_Bytes_index_from_opt=
      caml_new_string("String.index_from_opt / Bytes.index_from_opt"),
     cst_String_index_from_Bytes_index_from=
      caml_new_string("String.index_from / Bytes.index_from"),
     cst_Bytes_concat=caml_new_string("Bytes.concat"),
     cst_String_blit_Bytes_blit_string=
      caml_new_string("String.blit / Bytes.blit_string"),
     cst_Bytes_blit=caml_new_string("Bytes.blit"),
     cst_String_fill_Bytes_fill=caml_new_string("String.fill / Bytes.fill"),
     cst_Bytes_extend=caml_new_string("Bytes.extend"),
     cst_String_sub_Bytes_sub=caml_new_string("String.sub / Bytes.sub"),
     cst_String_rcontains_from_Bytes_rcontains_from$0=
      caml_new_string("String.rcontains_from / Bytes.rcontains_from"),
     cst_String_contains_from_Bytes_contains_from$0=
      caml_new_string("String.contains_from / Bytes.contains_from"),
     cst_String_rindex_from_opt_Bytes_rindex_from_opt$0=
      caml_new_string("String.rindex_from_opt / Bytes.rindex_from_opt"),
     cst_String_rindex_from_Bytes_rindex_from$0=
      caml_new_string("String.rindex_from / Bytes.rindex_from"),
     cst_String_index_from_opt_Bytes_index_from_opt$0=
      caml_new_string("String.index_from_opt / Bytes.index_from_opt"),
     cst_String_index_from_Bytes_index_from$0=
      caml_new_string("String.index_from / Bytes.index_from"),
     cst$4=caml_new_string(""),
     cst$3=caml_new_string(""),
     cst_String_concat=caml_new_string("String.concat"),
     cst_Sys_Break=caml_new_string("Sys.Break"),
     ocaml_version=caml_new_string("4.06.0"),
     cst_Sort_array=caml_new_string("Sort.array"),
     cst_Marshal_from_bytes=caml_new_string("Marshal.from_bytes"),
     cst_Marshal_from_bytes$0=caml_new_string("Marshal.from_bytes"),
     cst_Marshal_data_size=caml_new_string("Marshal.data_size"),
     cst_Marshal_to_buffer_substring_out_of_bounds=
      caml_new_string("Marshal.to_buffer: substring out of bounds"),
     cst_Obj_extension_constructor$0=
      caml_new_string("Obj.extension_constructor"),
     cst_Obj_extension_constructor=
      caml_new_string("Obj.extension_constructor"),
     cst_Array_map2_arrays_must_have_the_same_length=
      caml_new_string("Array.map2: arrays must have the same length"),
     cst_Array_iter2_arrays_must_have_the_same_length=
      caml_new_string("Array.iter2: arrays must have the same length"),
     cst_Array_blit=caml_new_string("Array.blit"),
     cst_Array_fill=caml_new_string("Array.fill"),
     cst_Array_sub=caml_new_string("Array.sub"),
     cst_Array_init=caml_new_string("Array.init"),
     cst_Array_Bottom=caml_new_string("Array.Bottom"),
     cst_d=caml_new_string("%d"),
     cst_d$0=caml_new_string("%d"),
     zero$0=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     one$0=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     minus_one$0=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,65535),
     min_int$1=runtime.caml_int64_create_lo_mi_hi(0,0,32768),
     max_int$1=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,32767),
     cst_d$1=caml_new_string("%d"),
     cst_Lexing_lex_refill_cannot_grow_buffer=
      caml_new_string("Lexing.lex_refill: cannot grow buffer"),
     dummy_pos=[0,caml_new_string(""),0,0,-1],
     zero_pos=[0,caml_new_string(""),1,0,0],
     cst_syntax_error=caml_new_string("syntax error"),
     cst_Parsing_YYexit=caml_new_string("Parsing.YYexit"),
     cst_Parsing_Parse_error=caml_new_string("Parsing.Parse_error"),
     cst_Set_remove_min_elt=caml_new_string("Set.remove_min_elt"),
     cst_Set_bal=caml_new_string("Set.bal"),
     cst_Set_bal$0=caml_new_string("Set.bal"),
     cst_Set_bal$1=caml_new_string("Set.bal"),
     cst_Set_bal$2=caml_new_string("Set.bal"),
     cst_Map_remove_min_elt=caml_new_string("Map.remove_min_elt"),
     cst_Map_bal=caml_new_string("Map.bal"),
     cst_Map_bal$0=caml_new_string("Map.bal"),
     cst_Map_bal$1=caml_new_string("Map.bal"),
     cst_Map_bal$2=caml_new_string("Map.bal"),
     cst_Stack_Empty=caml_new_string("Stack.Empty"),
     cst_Queue_Empty=caml_new_string("Queue.Empty"),
     cst_CamlinternalLazy_Undefined=
      caml_new_string("CamlinternalLazy.Undefined"),
     cst_count=caml_new_string("{count = "),
     cst_data=caml_new_string("; data = "),
     cst$5=caml_new_string("}"),
     cst_Sempty=caml_new_string("Sempty"),
     cst_Scons=caml_new_string("Scons ("),
     cst$6=caml_new_string(", "),
     cst$7=caml_new_string(")"),
     cst_Sapp=caml_new_string("Sapp ("),
     cst$8=caml_new_string(", "),
     cst$9=caml_new_string(")"),
     cst_Slazy=caml_new_string("Slazy"),
     cst_Sgen=caml_new_string("Sgen"),
     cst_Sbuffio=caml_new_string("Sbuffio"),
     cst_Stream_Failure=caml_new_string("Stream.Failure"),
     cst_Stream_Error=caml_new_string("Stream.Error"),
     cst_Buffer_truncate=caml_new_string("Buffer.truncate"),
     cst_Buffer_add_channel=caml_new_string("Buffer.add_channel"),
     cst_Buffer_add_substring_add_subbytes=
      caml_new_string("Buffer.add_substring/add_subbytes"),
     cst_Buffer_add_cannot_grow_buffer=
      caml_new_string("Buffer.add: cannot grow buffer"),
     cst_Buffer_nth=caml_new_string("Buffer.nth"),
     cst_Buffer_blit=caml_new_string("Buffer.blit"),
     cst_Buffer_sub=caml_new_string("Buffer.sub"),
     cst_c=caml_new_string("%c"),
     cst_s=caml_new_string("%s"),
     cst_i=caml_new_string("%i"),
     cst_li=caml_new_string("%li"),
     cst_ni=caml_new_string("%ni"),
     cst_Li=caml_new_string("%Li"),
     cst_f=caml_new_string("%f"),
     cst_B=caml_new_string("%B"),
     cst$20=caml_new_string("%{"),
     cst$21=caml_new_string("%}"),
     cst$22=caml_new_string("%("),
     cst$23=caml_new_string("%)"),
     cst_a=caml_new_string("%a"),
     cst_t$0=caml_new_string("%t"),
     cst$24=caml_new_string("%?"),
     cst_r$0=caml_new_string("%r"),
     cst_r$1=caml_new_string("%_r"),
     cst_u$0=caml_new_string("%u"),
     cst_Printf_bad_conversion=caml_new_string("Printf: bad conversion %["),
     cst_Printf_bad_conversion$0=caml_new_string("Printf: bad conversion %_"),
     cst$28=caml_new_string("@{"),
     cst$29=caml_new_string("@["),
     cst$30=caml_new_string("@{"),
     cst$31=caml_new_string("@["),
     cst$32=caml_new_string("@{"),
     cst$33=caml_new_string("@["),
     cst_0=caml_new_string("0"),
     cst_padding=caml_new_string("padding"),
     cst_precision=caml_new_string("precision"),
     cst$38=caml_new_string("'*'"),
     cst$36=caml_new_string("'-'"),
     cst_0$2=caml_new_string("'0'"),
     cst$37=caml_new_string("'*'"),
     cst_0$0=caml_new_string("0"),
     cst_0$1=caml_new_string("0"),
     cst_precision$0=caml_new_string("precision"),
     cst_precision$1=caml_new_string("precision"),
     cst$39=caml_new_string("'+'"),
     cst$40=caml_new_string("'#'"),
     cst$41=caml_new_string("' '"),
     cst_padding$0=caml_new_string("`padding'"),
     cst_precision$2=caml_new_string("`precision'"),
     cst$42=caml_new_string("'+'"),
     cst$43=caml_new_string("'_'"),
     sub_format=[0,0,caml_new_string("")],
     formatting_lit=[0,caml_new_string("@;"),1,0],
     cst_digit=caml_new_string("digit"),
     cst_character=caml_new_string("character ')'"),
     cst_character$0=caml_new_string("character '}'"),
     cst$47=caml_new_string("'#'"),
     cst$46=caml_new_string("'+'"),
     cst$45=caml_new_string("'+'"),
     cst$44=caml_new_string("' '"),
     cst$50=caml_new_string("'+'"),
     cst$49=caml_new_string("'+'"),
     cst$48=caml_new_string("' '"),
     cst_non_zero_widths_are_unsupported_for_c_conversions=
      caml_new_string("non-zero widths are unsupported for %c conversions"),
     cst_unexpected_end_of_format=caml_new_string("unexpected end of format"),
     cst$34=caml_new_string(""),
     cst$35=caml_new_string(""),
     cst_b$0=caml_new_string("b"),
     cst_h=caml_new_string("h"),
     cst_hov=caml_new_string("hov"),
     cst_hv=caml_new_string("hv"),
     cst_v=caml_new_string("v"),
     cst_nan=caml_new_string("nan"),
     cst$27=caml_new_string("."),
     cst_neg_infinity=caml_new_string("neg_infinity"),
     cst_infinity=caml_new_string("infinity"),
     cst_12g$0=caml_new_string("%.12g"),
     cst_nd=caml_new_string("%nd"),
     cst_nd$0=caml_new_string("%+nd"),
     cst_nd$1=caml_new_string("% nd"),
     cst_ni$0=caml_new_string("%ni"),
     cst_ni$1=caml_new_string("%+ni"),
     cst_ni$2=caml_new_string("% ni"),
     cst_nx=caml_new_string("%nx"),
     cst_nx$0=caml_new_string("%#nx"),
     cst_nX=caml_new_string("%nX"),
     cst_nX$0=caml_new_string("%#nX"),
     cst_no=caml_new_string("%no"),
     cst_no$0=caml_new_string("%#no"),
     cst_nu=caml_new_string("%nu"),
     cst_ld=caml_new_string("%ld"),
     cst_ld$0=caml_new_string("%+ld"),
     cst_ld$1=caml_new_string("% ld"),
     cst_li$0=caml_new_string("%li"),
     cst_li$1=caml_new_string("%+li"),
     cst_li$2=caml_new_string("% li"),
     cst_lx=caml_new_string("%lx"),
     cst_lx$0=caml_new_string("%#lx"),
     cst_lX=caml_new_string("%lX"),
     cst_lX$0=caml_new_string("%#lX"),
     cst_lo=caml_new_string("%lo"),
     cst_lo$0=caml_new_string("%#lo"),
     cst_lu=caml_new_string("%lu"),
     cst_Ld=caml_new_string("%Ld"),
     cst_Ld$0=caml_new_string("%+Ld"),
     cst_Ld$1=caml_new_string("% Ld"),
     cst_Li$0=caml_new_string("%Li"),
     cst_Li$1=caml_new_string("%+Li"),
     cst_Li$2=caml_new_string("% Li"),
     cst_Lx=caml_new_string("%Lx"),
     cst_Lx$0=caml_new_string("%#Lx"),
     cst_LX=caml_new_string("%LX"),
     cst_LX$0=caml_new_string("%#LX"),
     cst_Lo=caml_new_string("%Lo"),
     cst_Lo$0=caml_new_string("%#Lo"),
     cst_Lu=caml_new_string("%Lu"),
     cst_d$2=caml_new_string("%d"),
     cst_d$3=caml_new_string("%+d"),
     cst_d$4=caml_new_string("% d"),
     cst_i$0=caml_new_string("%i"),
     cst_i$1=caml_new_string("%+i"),
     cst_i$2=caml_new_string("% i"),
     cst_x=caml_new_string("%x"),
     cst_x$0=caml_new_string("%#x"),
     cst_X$0=caml_new_string("%X"),
     cst_X$1=caml_new_string("%#X"),
     cst_o=caml_new_string("%o"),
     cst_o$0=caml_new_string("%#o"),
     cst_u=caml_new_string("%u"),
     cst$25=caml_new_string("%!"),
     cst$26=caml_new_string("@{"),
     cst_0c=caml_new_string("0c"),
     cst$19=caml_new_string("%%"),
     cst$11=caml_new_string("@]"),
     cst$12=caml_new_string("@}"),
     cst$13=caml_new_string("@?"),
     cst$14=caml_new_string("@\n"),
     cst$15=caml_new_string("@."),
     cst$16=caml_new_string("@@"),
     cst$17=caml_new_string("@%"),
     cst$18=caml_new_string("@"),
     cst$10=caml_new_string(".*"),
     cst_CamlinternalFormat_Type_mismatch=
      caml_new_string("CamlinternalFormat.Type_mismatch"),
     cst$58=caml_new_string(""),
     cst$59=caml_new_string("\n"),
     cst_a_boolean=caml_new_string("a boolean"),
     cst_an_integer=caml_new_string("an integer"),
     cst_an_integer$0=caml_new_string("an integer"),
     cst_a_float=caml_new_string("a float"),
     cst_a_float$0=caml_new_string("a float"),
     cst$55=caml_new_string(""),
     cst$56=caml_new_string(" "),
     cst$57=caml_new_string(""),
     cst_one_of=caml_new_string("one of: "),
     cst_Arg_Expand_is_is_only_allowed_with_Arg_parse_and_expand_argv_dynamic=
      caml_new_string
       ("Arg.Expand is is only allowed with Arg.parse_and_expand_argv_dynamic"),
     cst_no_argument=caml_new_string("no argument"),
     cst$54=caml_new_string("(?)"),
     cst_help$3=caml_new_string("--help"),
     cst_help$4=caml_new_string("-help"),
     cst_help$2=caml_new_string("-help"),
     cst_Display_this_list_of_options=
      caml_new_string(" Display this list of options"),
     cst_help=caml_new_string("-help"),
     cst_help$1=caml_new_string("--help"),
     cst_Display_this_list_of_options$0=
      caml_new_string(" Display this list of options"),
     cst_help$0=caml_new_string("--help"),
     cst$51=caml_new_string("}"),
     cst$52=caml_new_string("|"),
     cst$53=caml_new_string("{"),
     cst_none=caml_new_string("<none>"),
     cst_Arg_Bad=caml_new_string("Arg.Bad"),
     cst_Arg_Help=caml_new_string("Arg.Help"),
     cst_Arg_Stop=caml_new_string("Arg.Stop"),
     cst$61=caml_new_string(""),
     cst_Program_not_linked_with_g_cannot_print_stack_backtrace=
      caml_new_string
       ("(Program not linked with -g, cannot print stack backtrace)\n"),
     cst_Raised_at=caml_new_string("Raised at"),
     cst_Re_raised_at=caml_new_string("Re-raised at"),
     cst_Raised_by_primitive_operation_at=
      caml_new_string("Raised by primitive operation at"),
     cst_Called_from=caml_new_string("Called from"),
     cst_inlined=caml_new_string(" (inlined)"),
     cst$64=caml_new_string(""),
     partial=[4,0,0,0,0],
     cst_Out_of_memory=caml_new_string("Out of memory"),
     cst_Stack_overflow=caml_new_string("Stack overflow"),
     cst_Pattern_matching_failed=caml_new_string("Pattern matching failed"),
     cst_Assertion_failed=caml_new_string("Assertion failed"),
     cst_Undefined_recursive_module=
      caml_new_string("Undefined recursive module"),
     cst$62=caml_new_string(""),
     cst$63=caml_new_string(""),
     cst$60=caml_new_string("_"),
     locfmt=
      [0,
       [11,
        caml_new_string('File "'),
        [2,
         0,
         [11,
          caml_new_string('", line '),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(", characters "),
            [4,0,0,0,[12,45,[4,0,0,0,[11,caml_new_string(": "),[2,0,0]]]]]]]]]],
       caml_new_string('File "%s", line %d, characters %d-%d: %s')],
     cst_Digest_from_hex$0=caml_new_string("Digest.from_hex"),
     cst_Digest_from_hex=caml_new_string("Digest.from_hex"),
     cst_Digest_to_hex=caml_new_string("Digest.to_hex"),
     cst_Digest_substring=caml_new_string("Digest.substring"),
     cst_Random_int64=caml_new_string("Random.int64"),
     cst_Random_int32=caml_new_string("Random.int32"),
     cst_Random_int=caml_new_string("Random.int"),
     cst_x$1=caml_new_string("x"),
     cst_OCAMLRUNPARAM=caml_new_string("OCAMLRUNPARAM"),
     cst_CAMLRUNPARAM=caml_new_string("CAMLRUNPARAM"),
     cst$65=caml_new_string(""),
     cst_Weak_Make_hash_bucket_cannot_grow_more=
      caml_new_string("Weak.Make: hash bucket cannot grow more"),
     cst_Weak_fill=caml_new_string("Weak.fill"),
     cst$71=caml_new_string("."),
     cst$69=caml_new_string(">"),
     cst$70=caml_new_string("<\/"),
     cst$67=caml_new_string(">"),
     cst$68=caml_new_string("<"),
     cst$66=caml_new_string("\n"),
     cst_Format_Empty_queue=caml_new_string("Format.Empty_queue"),
     cst_end_of_input_not_found=caml_new_string("end of input not found"),
     cst_scanf_bad_conversion_a=caml_new_string('scanf: bad conversion "%a"'),
     cst_scanf_bad_conversion_t=caml_new_string('scanf: bad conversion "%t"'),
     cst_scanf_missing_reader=caml_new_string("scanf: missing reader"),
     cst_scanf_bad_conversion_custom_converter=
      caml_new_string('scanf: bad conversion "%?" (custom converter)'),
     cst_scanf_bad_conversion=caml_new_string('scanf: bad conversion "%*"'),
     cst_scanf_bad_conversion$1=caml_new_string('scanf: bad conversion "%*"'),
     cst_scanf_bad_conversion$0=caml_new_string('scanf: bad conversion "%-"'),
     cst_scanf_bad_conversion$2=caml_new_string('scanf: bad conversion "%*"'),
     cst$75=caml_new_string('"'),
     cst$76=caml_new_string('"'),
     cst$74=caml_new_string('"'),
     cst_in_format=caml_new_string(' in format "'),
     cst_an=caml_new_string("an"),
     cst_x$2=caml_new_string("x"),
     cst_nfinity=caml_new_string("nfinity"),
     cst_digits=caml_new_string("digits"),
     cst_decimal_digits=caml_new_string("decimal digits"),
     cst_0b=caml_new_string("0b"),
     cst_0o=caml_new_string("0o"),
     cst_0u=caml_new_string("0u"),
     cst_0x=caml_new_string("0x"),
     cst_false$2=caml_new_string("false"),
     cst_true$2=caml_new_string("true"),
     cst_not_a_valid_float_in_hexadecimal_notation=
      caml_new_string("not a valid float in hexadecimal notation"),
     cst_no_dot_or_exponent_part_found_in_float_token=
      caml_new_string("no dot or exponent part found in float token"),
     cst$73=caml_new_string("-"),
     cst_unnamed_function=caml_new_string("unnamed function"),
     cst_unnamed_character_string=caml_new_string("unnamed character string"),
     cst_unnamed_Pervasives_input_channel=
      caml_new_string("unnamed Pervasives input channel"),
     cst$72=caml_new_string("-"),
     cst_Scanf_Scan_failure=caml_new_string("Scanf.Scan_failure"),
     cst_binary=caml_new_string("binary"),
     cst_octal=caml_new_string("octal"),
     cst_hexadecimal=caml_new_string("hexadecimal"),
     cst_a_Char=caml_new_string("a Char"),
     cst_a_String=caml_new_string("a String"),
     cst$77=caml_new_string(""),
     cst$78=caml_new_string(""),
     cst$79=caml_new_string(""),
     cst$80=caml_new_string(""),
     cst$81=caml_new_string(""),
     cst$83=caml_new_string(""),
     cst$82=caml_new_string(""),
     cst_Illegal_character=caml_new_string("Illegal character "),
     cst_Filename_chop_extension=caml_new_string("Filename.chop_extension"),
     cst$94=caml_new_string(""),
     cst_Filename_chop_suffix=caml_new_string("Filename.chop_suffix"),
     cst$93=caml_new_string(""),
     cst$91=caml_new_string("./"),
     cst$90=caml_new_string(".\\"),
     cst$89=caml_new_string("../"),
     cst$88=caml_new_string("..\\"),
     cst$87=caml_new_string("./"),
     cst$86=caml_new_string("../"),
     cst$85=caml_new_string(""),
     cst$84=caml_new_string(""),
     current_dir_name=caml_new_string("."),
     parent_dir_name=caml_new_string(".."),
     dir_sep=caml_new_string("/"),
     cst_TMPDIR=caml_new_string("TMPDIR"),
     cst_tmp=caml_new_string("/tmp"),
     quotequote=caml_new_string("'\\''"),
     current_dir_name$0=caml_new_string("."),
     parent_dir_name$0=caml_new_string(".."),
     dir_sep$0=caml_new_string("\\"),
     cst_TEMP=caml_new_string("TEMP"),
     cst$92=caml_new_string("."),
     current_dir_name$1=caml_new_string("."),
     parent_dir_name$1=caml_new_string(".."),
     dir_sep$1=caml_new_string("/"),
     cst_Cygwin=caml_new_string("Cygwin"),
     cst_Win32=caml_new_string("Win32"),
     zero$2=[254,0.,0.],
     one$2=[254,1.,0.],
     i=[254,0.,1.],
     cst_Series_is_closed$0=caml_new_string("Series is closed"),
     cst_Series_is_closed=caml_new_string("Series is closed"),
     End_of_file=global_data.End_of_file,
     Sys_error=global_data.Sys_error,
     Failure=global_data.Failure,
     Invalid_argument=global_data.Invalid_argument,
     Not_found=global_data.Not_found,
     Assert_failure=global_data.Assert_failure,
     Out_of_memory=global_data.Out_of_memory,
     Stack_overflow=global_data.Stack_overflow,
     Match_failure=global_data.Match_failure,
     Undefined_recursive_module=global_data.Undefined_recursive_module,
     _l_=[0,0,[0,6,0]],
     _k_=[0,0,[0,7,0]],
     _j_=[0,1,[0,3,[0,4,[0,6,0]]]],
     _i_=[0,1,[0,3,[0,4,[0,7,0]]]],
     _g_=[0,1],
     _h_=[0,0],
     _a_=runtime.caml_int64_create_lo_mi_hi(0,0,32752),
     _b_=runtime.caml_int64_create_lo_mi_hi(0,0,65520),
     _c_=runtime.caml_int64_create_lo_mi_hi(1,0,32752),
     _d_=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,32751),
     _e_=runtime.caml_int64_create_lo_mi_hi(0,0,16),
     _f_=runtime.caml_int64_create_lo_mi_hi(0,0,15536),
     _n_=[0,0,0],
     _o_=[0,caml_new_string("list.ml"),262,11],
     _F_=[0,caml_new_string("array.ml"),233,4],
     _J_=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,65535),
     _I_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _H_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _G_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _K_=[0,0,0,0],
     _L_=[0,0,0],
     _M_=[0,caml_new_string("set.ml"),510,18],
     _N_=[0,0,0,0],
     _O_=[0,caml_new_string("map.ml"),393,10],
     _P_=[0,0,0],
     _Q_=[0,caml_new_string("stream.ml"),53,12],
     _R_=[0,0],
     _S_=[0,caml_new_string("stream.ml"),82,12],
     _Z_=[0,caml_new_string("buffer.ml"),205,9],
     _Y_=[0,caml_new_string("buffer.ml"),141,19],
     _X_=[0,caml_new_string("buffer.ml"),159,8],
     _W_=[0,caml_new_string("buffer.ml"),120,19],
     _V_=[0,caml_new_string("buffer.ml"),138,8],
     _U_=[0,caml_new_string("buffer.ml"),84,19],
     _T_=[0,caml_new_string("buffer.ml"),117,8],
     ___=[0,caml_new_string("camlinternalFormat.ml"),846,23],
     _aj_=[0,caml_new_string("camlinternalFormat.ml"),810,21],
     _ab_=[0,caml_new_string("camlinternalFormat.ml"),811,21],
     _ak_=[0,caml_new_string("camlinternalFormat.ml"),814,21],
     _ac_=[0,caml_new_string("camlinternalFormat.ml"),815,21],
     _al_=[0,caml_new_string("camlinternalFormat.ml"),818,19],
     _ad_=[0,caml_new_string("camlinternalFormat.ml"),819,19],
     _am_=[0,caml_new_string("camlinternalFormat.ml"),822,22],
     _ae_=[0,caml_new_string("camlinternalFormat.ml"),823,22],
     _an_=[0,caml_new_string("camlinternalFormat.ml"),827,30],
     _af_=[0,caml_new_string("camlinternalFormat.ml"),828,30],
     _ah_=[0,caml_new_string("camlinternalFormat.ml"),832,26],
     _$_=[0,caml_new_string("camlinternalFormat.ml"),833,26],
     _ai_=[0,caml_new_string("camlinternalFormat.ml"),842,28],
     _aa_=[0,caml_new_string("camlinternalFormat.ml"),843,28],
     _ag_=[0,caml_new_string("camlinternalFormat.ml"),847,23],
     _ao_=[0,caml_new_string("camlinternalFormat.ml"),1525,4],
     _ap_=[0,caml_new_string("camlinternalFormat.ml"),1593,39],
     _aq_=[0,caml_new_string("camlinternalFormat.ml"),1616,31],
     _ar_=[0,caml_new_string("camlinternalFormat.ml"),1617,31],
     _as_=[0,caml_new_string("camlinternalFormat.ml"),1797,8],
     _aW_=
      [0,
       [11,
        caml_new_string("bad input: format type mismatch between "),
        [3,0,[11,caml_new_string(" and "),[3,0,0]]]],
       caml_new_string("bad input: format type mismatch between %S and %S")],
     _aV_=
      [0,
       [11,
        caml_new_string("bad input: format type mismatch between "),
        [3,0,[11,caml_new_string(" and "),[3,0,0]]]],
       caml_new_string("bad input: format type mismatch between %S and %S")],
     _ay_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,0,0,0,[11,caml_new_string(", duplicate flag "),[1,0]]]]]],
       caml_new_string
        ("invalid format %S: at character number %d, duplicate flag %C")],
     _az_=[0,1,0],
     _aA_=[0,0],
     _aC_=[1,0],
     _aB_=[1,1],
     _aE_=[1,1],
     _aD_=[1,1],
     _aI_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(", flag "),
            [1,
             [11,
              caml_new_string(" is only allowed after the '"),
              [12,
               37,
               [11,caml_new_string("', before padding and precision"),0]]]]]]]]],
       caml_new_string
        ("invalid format %S: at character number %d, flag %C is only allowed after the '%%', before padding and precision")],
     _aF_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(', invalid conversion "'),
            [12,37,[0,[12,34,0]]]]]]]],
       caml_new_string
        ('invalid format %S: at character number %d, invalid conversion "%%%c"')],
     _aG_=[0,0],
     _aH_=[0,0],
     _aJ_=[0,[12,64,0]],
     _aK_=[0,caml_new_string("@ "),1,0],
     _aL_=[0,caml_new_string("@,"),0,0],
     _aM_=[2,60],
     _aN_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": '"),
          [12,
           37,
           [11,
            caml_new_string("' alone is not accepted in character sets, use "),
            [12,
             37,
             [12,
              37,
              [11,
               caml_new_string(" instead at position "),
               [4,0,0,0,[12,46,0]]]]]]]]]],
       caml_new_string
        ("invalid format %S: '%%' alone is not accepted in character sets, use %%%% instead at position %d.")],
     _aO_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": integer "),
          [4,
           0,
           0,
           0,
           [11,caml_new_string(" is greater than the limit "),[4,0,0,0,0]]]]]],
       caml_new_string
        ("invalid format %S: integer %d is greater than the limit %d")],
     _aP_=[0,caml_new_string("camlinternalFormat.ml"),2811,11],
     _aQ_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(': unclosed sub-format, expected "'),
          [12,
           37,
           [0,[11,caml_new_string('" at character number '),[4,0,0,0,0]]]]]]],
       caml_new_string
        ('invalid format %S: unclosed sub-format, expected "%%%c" at character number %d')],
     _aR_=[0,caml_new_string("camlinternalFormat.ml"),2873,34],
     _aS_=[0,caml_new_string("camlinternalFormat.ml"),2906,28],
     _aT_=[0,caml_new_string("camlinternalFormat.ml"),2940,25],
     _aU_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(", "),
            [2,
             0,
             [11,
              caml_new_string(" is incompatible with '"),
              [0,[11,caml_new_string("' in sub-format "),[3,0,0]]]]]]]]]],
       caml_new_string
        ("invalid format %S: at character number %d, %s is incompatible with '%c' in sub-format %S")],
     _ax_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(", "),
            [2,0,[11,caml_new_string(" expected, read "),[1,0]]]]]]]],
       caml_new_string
        ("invalid format %S: at character number %d, %s expected, read %C")],
     _aw_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(", '"),
            [0,[11,caml_new_string("' without "),[2,0,0]]]]]]]],
       caml_new_string
        ("invalid format %S: at character number %d, '%c' without %s")],
     _av_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,0,0,0,[11,caml_new_string(", "),[2,0,0]]]]]],
       caml_new_string("invalid format %S: at character number %d, %s")],
     _au_=
      [0,
       [11,caml_new_string("invalid box description "),[3,0,0]],
       caml_new_string("invalid box description %S")],
     _at_=[0,0,4],
     _bg_=[0,[2,0,[0,0]],caml_new_string("%s%c")],
     _ba_=[0,[2,0,0],caml_new_string("%s")],
     _bb_=[0,[2,0,0],caml_new_string("%s")],
     _a__=[0,[2,0,0],caml_new_string("%s")],
     _a$_=[0,[2,0,0],caml_new_string("%s")],
     _a8_=[0,[2,0,0],caml_new_string("%s")],
     _a9_=[0,[2,0,0],caml_new_string("%s")],
     _a2_=
      [0,
       [2,
        0,
        [11,
         caml_new_string(": unknown option '"),
         [2,0,[11,caml_new_string("'.\n"),0]]]],
       caml_new_string("%s: unknown option '%s'.\n")],
     _a5_=
      [0,
       [2,
        0,
        [11,
         caml_new_string(": wrong argument '"),
         [2,
          0,
          [11,
           caml_new_string("'; option '"),
           [2,
            0,
            [11,
             caml_new_string("' expects "),
             [2,0,[11,caml_new_string(".\n"),0]]]]]]]],
       caml_new_string("%s: wrong argument '%s'; option '%s' expects %s.\n")],
     _a6_=
      [0,
       [2,
        0,
        [11,
         caml_new_string(": option '"),
         [2,0,[11,caml_new_string("' needs an argument.\n"),0]]]],
       caml_new_string("%s: option '%s' needs an argument.\n")],
     _a7_=
      [0,
       [2,0,[11,caml_new_string(": "),[2,0,[11,caml_new_string(".\n"),0]]]],
       caml_new_string("%s: %s.\n")],
     _a3_=[0,caml_new_string("-help")],
     _a4_=[0,caml_new_string("--help")],
     _a1_=[0,[2,0,0],caml_new_string("%s")],
     _a0_=[0,[2,0,[12,10,0]],caml_new_string("%s\n")],
     _aZ_=[0,caml_new_string("-help")],
     _aX_=
      [0,
       [11,caml_new_string("  "),[2,0,[12,32,[2,0,[12,10,0]]]]],
       caml_new_string("  %s %s\n")],
     _aY_=
      [0,
       [11,caml_new_string("  "),[2,0,[12,32,[2,0,[2,0,[12,10,0]]]]]],
       caml_new_string("  %s %s%s\n")],
     _bl_=
      [0,[11,caml_new_string(", "),[2,0,[2,0,0]]],caml_new_string(", %s%s")],
     _bu_=[0,[2,0,[12,10,0]],caml_new_string("%s\n")],
     _bs_=[0,[2,0,[12,10,0]],caml_new_string("%s\n")],
     _bt_=
      [0,
       [11,
        caml_new_string
         ("(Program not linked with -g, cannot print stack backtrace)\n"),
        0],
       caml_new_string
        ("(Program not linked with -g, cannot print stack backtrace)\n")],
     _bq_=
      [0,
       [2,
        0,
        [11,
         caml_new_string(' file "'),
         [2,
          0,
          [12,
           34,
           [2,
            0,
            [11,
             caml_new_string(", line "),
             [4,
              0,
              0,
              0,
              [11,caml_new_string(", characters "),[4,0,0,0,[12,45,partial]]]]]]]]]],
       caml_new_string('%s file "%s"%s, line %d, characters %d-%d')],
     _br_=
      [0,
       [2,0,[11,caml_new_string(" unknown location"),0]],
       caml_new_string("%s unknown location")],
     _bp_=
      [0,
       [11,caml_new_string("Uncaught exception: "),[2,0,[12,10,0]]],
       caml_new_string("Uncaught exception: %s\n")],
     _bo_=
      [0,
       [11,caml_new_string("Uncaught exception: "),[2,0,[12,10,0]]],
       caml_new_string("Uncaught exception: %s\n")],
     _bm_=[0,[12,40,[2,0,[2,0,[12,41,0]]]],caml_new_string("(%s%s)")],
     _bn_=[0,[12,40,[2,0,[12,41,0]]],caml_new_string("(%s)")],
     _bk_=[0,[4,0,0,0,0],caml_new_string("%d")],
     _bj_=[0,[3,0,0],caml_new_string("%S")],
     _bD_=
      [0,
       [11,caml_new_string("minor_collections: "),[4,0,0,0,[12,10,0]]],
       caml_new_string("minor_collections: %d\n")],
     _bE_=
      [0,
       [11,caml_new_string("major_collections: "),[4,0,0,0,[12,10,0]]],
       caml_new_string("major_collections: %d\n")],
     _bF_=
      [0,
       [11,caml_new_string("compactions:       "),[4,0,0,0,[12,10,0]]],
       caml_new_string("compactions:       %d\n")],
     _bG_=[0,[12,10,0],caml_new_string("\n")],
     _bH_=[0,[8,0,0,[0,0],0],caml_new_string("%.0f")],
     _bI_=
      [0,
       [11,caml_new_string("minor_words:    "),[8,0,[1,1],[0,0],[12,10,0]]],
       caml_new_string("minor_words:    %*.0f\n")],
     _bJ_=
      [0,
       [11,caml_new_string("promoted_words: "),[8,0,[1,1],[0,0],[12,10,0]]],
       caml_new_string("promoted_words: %*.0f\n")],
     _bK_=
      [0,
       [11,caml_new_string("major_words:    "),[8,0,[1,1],[0,0],[12,10,0]]],
       caml_new_string("major_words:    %*.0f\n")],
     _bL_=[0,[12,10,0],caml_new_string("\n")],
     _bM_=[0,[4,0,0,0,0],caml_new_string("%d")],
     _bN_=
      [0,
       [11,caml_new_string("top_heap_words: "),[4,0,[1,1],0,[12,10,0]]],
       caml_new_string("top_heap_words: %*d\n")],
     _bO_=
      [0,
       [11,caml_new_string("heap_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_new_string("heap_words:     %*d\n")],
     _bP_=
      [0,
       [11,caml_new_string("live_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_new_string("live_words:     %*d\n")],
     _bQ_=
      [0,
       [11,caml_new_string("free_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_new_string("free_words:     %*d\n")],
     _bR_=
      [0,
       [11,caml_new_string("largest_free:   "),[4,0,[1,1],0,[12,10,0]]],
       caml_new_string("largest_free:   %*d\n")],
     _bS_=
      [0,
       [11,caml_new_string("fragments:      "),[4,0,[1,1],0,[12,10,0]]],
       caml_new_string("fragments:      %*d\n")],
     _bT_=[0,[12,10,0],caml_new_string("\n")],
     _bU_=
      [0,
       [11,caml_new_string("live_blocks: "),[4,0,0,0,[12,10,0]]],
       caml_new_string("live_blocks: %d\n")],
     _bV_=
      [0,
       [11,caml_new_string("free_blocks: "),[4,0,0,0,[12,10,0]]],
       caml_new_string("free_blocks: %d\n")],
     _bW_=
      [0,
       [11,caml_new_string("heap_chunks: "),[4,0,0,0,[12,10,0]]],
       caml_new_string("heap_chunks: %d\n")],
     _bZ_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _b0_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _b1_=
      [0,
       987910699,
       495797812,
       364182224,
       414272206,
       318284740,
       990407751,
       383018966,
       270373319,
       840823159,
       24560019,
       536292337,
       512266505,
       189156120,
       730249596,
       143776328,
       51606627,
       140166561,
       366354223,
       1003410265,
       700563762,
       981890670,
       913149062,
       526082594,
       1021425055,
       784300257,
       667753350,
       630144451,
       949649812,
       48546892,
       415514493,
       258888527,
       511570777,
       89983870,
       283659902,
       308386020,
       242688715,
       482270760,
       865188196,
       1027664170,
       207196989,
       193777847,
       619708188,
       671350186,
       149669678,
       257044018,
       87658204,
       558145612,
       183450813,
       28133145,
       901332182,
       710253903,
       510646120,
       652377910,
       409934019,
       801085050],
     _b5_=[0,0],
     _b4_=[0,caml_new_string("hashtbl.ml"),108,23],
     _b7_=[3,0,3],
     _b6_=[0,caml_new_string("")],
     _cl_=[0,91],
     _ck_=[0,123],
     _cm_=[0,caml_new_string("scanf.ml"),1455,13],
     _cn_=[0,[3,0,[10,0]],caml_new_string("%S%!")],
     _cj_=[0,37,caml_new_string("")],
     _ci_=
      [0,
       [11,
        caml_new_string("scanf: bad input at char number "),
        [4,3,0,0,[11,caml_new_string(": "),[2,0,0]]]],
       caml_new_string("scanf: bad input at char number %i: %s")],
     _ch_=
      [0,
       [11,
        caml_new_string("the character "),
        [1,[11,caml_new_string(" cannot start a boolean"),0]]],
       caml_new_string("the character %C cannot start a boolean")],
     _cg_=
      [0,
       [11,caml_new_string("bad character hexadecimal encoding \\"),[0,[0,0]]],
       caml_new_string("bad character hexadecimal encoding \\%c%c")],
     _cf_=
      [0,
       [11,caml_new_string("bad character decimal encoding \\"),[0,[0,[0,0]]]],
       caml_new_string("bad character decimal encoding \\%c%c%c")],
     _ce_=
      [0,
       [11,
        caml_new_string("character "),
        [1,
         [11,
          caml_new_string(" is not a valid "),
          [2,0,[11,caml_new_string(" digit"),0]]]]],
       caml_new_string("character %C is not a valid %s digit")],
     _cd_=
      [0,
       [11,
        caml_new_string("character "),
        [1,[11,caml_new_string(" is not a decimal digit"),0]]],
       caml_new_string("character %C is not a decimal digit")],
     _cc_=[0,caml_new_string("scanf.ml"),555,9],
     _cb_=
      [0,
       [11,caml_new_string("invalid boolean '"),[2,0,[12,39,0]]],
       caml_new_string("invalid boolean '%s'")],
     _ca_=
      [0,
       [11,
        caml_new_string("looking for "),
        [1,[11,caml_new_string(", found "),[1,0]]]],
       caml_new_string("looking for %C, found %C")],
     _b$_=
      [0,
       [11,
        caml_new_string("scanning of "),
        [2,
         0,
         [11,
          caml_new_string
           (" failed: premature end of file occurred before end of token"),
          0]]],
       caml_new_string
        ("scanning of %s failed: premature end of file occurred before end of token")],
     _b__=
      [0,
       [11,
        caml_new_string("scanning of "),
        [2,
         0,
         [11,
          caml_new_string
           (" failed: the specified length was too short for token"),
          0]]],
       caml_new_string
        ("scanning of %s failed: the specified length was too short for token")],
     _b9_=
      [0,
       [11,caml_new_string("illegal escape character "),[1,0]],
       caml_new_string("illegal escape character %C")],
     _cu_=[0,caml_new_string("camlinternalOO.ml"),438,17],
     _ct_=[0,caml_new_string("camlinternalOO.ml"),420,13],
     _cs_=[0,caml_new_string("camlinternalOO.ml"),417,13],
     _cr_=[0,caml_new_string("camlinternalOO.ml"),414,13],
     _cq_=[0,caml_new_string("camlinternalOO.ml"),411,13],
     _cp_=[0,caml_new_string("camlinternalOO.ml"),408,13],
     _co_=[0,caml_new_string("camlinternalOO.ml"),281,50],
     _cx_=[0,0],
     _cw_=[0,0],
     _cv_=[0,0],
     _cB_=[0,7,0],
     _cA_=[0,1,[0,3,[0,5,0]]],
     _cz_=[0,[2,0,[4,6,[0,2,6],0,[2,0,0]]],caml_new_string("%s%06x%s")],
     _cC_=[254,0.,0.];
    function erase_rel(param)
     {if(typeof param === "number")
       return 0;
      else
       switch(param[0])
        {case 0:var rest=param[1];return [0,erase_rel(rest)];
         case 1:var rest$0=param[1];return [1,erase_rel(rest$0)];
         case 2:var rest$1=param[1];return [2,erase_rel(rest$1)];
         case 3:var rest$2=param[1];return [3,erase_rel(rest$2)];
         case 4:var rest$3=param[1];return [4,erase_rel(rest$3)];
         case 5:var rest$4=param[1];return [5,erase_rel(rest$4)];
         case 6:var rest$5=param[1];return [6,erase_rel(rest$5)];
         case 7:var rest$6=param[1];return [7,erase_rel(rest$6)];
         case 8:
          var rest$7=param[2],ty=param[1];return [8,ty,erase_rel(rest$7)];
         case 9:
          var rest$8=param[3],ty1=param[1];
          return [9,ty1,ty1,erase_rel(rest$8)];
         case 10:var rest$9=param[1];return [10,erase_rel(rest$9)];
         case 11:var rest$10=param[1];return [11,erase_rel(rest$10)];
         case 12:var rest$11=param[1];return [12,erase_rel(rest$11)];
         case 13:var rest$12=param[1];return [13,erase_rel(rest$12)];
         default:var rest$13=param[1];return [14,erase_rel(rest$13)]}}
    function concat_fmtty(fmtty1,fmtty2)
     {if(typeof fmtty1 === "number")
       return fmtty2;
      else
       switch(fmtty1[0])
        {case 0:var rest=fmtty1[1];return [0,concat_fmtty(rest,fmtty2)];
         case 1:var rest$0=fmtty1[1];return [1,concat_fmtty(rest$0,fmtty2)];
         case 2:var rest$1=fmtty1[1];return [2,concat_fmtty(rest$1,fmtty2)];
         case 3:var rest$2=fmtty1[1];return [3,concat_fmtty(rest$2,fmtty2)];
         case 4:var rest$3=fmtty1[1];return [4,concat_fmtty(rest$3,fmtty2)];
         case 5:var rest$4=fmtty1[1];return [5,concat_fmtty(rest$4,fmtty2)];
         case 6:var rest$5=fmtty1[1];return [6,concat_fmtty(rest$5,fmtty2)];
         case 7:var rest$6=fmtty1[1];return [7,concat_fmtty(rest$6,fmtty2)];
         case 8:
          var rest$7=fmtty1[2],ty=fmtty1[1];
          return [8,ty,concat_fmtty(rest$7,fmtty2)];
         case 9:
          var rest$8=fmtty1[3],ty2=fmtty1[2],ty1=fmtty1[1];
          return [9,ty1,ty2,concat_fmtty(rest$8,fmtty2)];
         case 10:var rest$9=fmtty1[1];return [10,concat_fmtty(rest$9,fmtty2)];
         case 11:
          var rest$10=fmtty1[1];return [11,concat_fmtty(rest$10,fmtty2)];
         case 12:
          var rest$11=fmtty1[1];return [12,concat_fmtty(rest$11,fmtty2)];
         case 13:
          var rest$12=fmtty1[1];return [13,concat_fmtty(rest$12,fmtty2)];
         default:
          var rest$13=fmtty1[1];return [14,concat_fmtty(rest$13,fmtty2)]}}
    function concat_fmt(fmt1,fmt2)
     {if(typeof fmt1 === "number")
       return fmt2;
      else
       switch(fmt1[0])
        {case 0:var rest=fmt1[1];return [0,concat_fmt(rest,fmt2)];
         case 1:var rest$0=fmt1[1];return [1,concat_fmt(rest$0,fmt2)];
         case 2:
          var rest$1=fmt1[2],pad=fmt1[1];
          return [2,pad,concat_fmt(rest$1,fmt2)];
         case 3:
          var rest$2=fmt1[2],pad$0=fmt1[1];
          return [3,pad$0,concat_fmt(rest$2,fmt2)];
         case 4:
          var rest$3=fmt1[4],prec=fmt1[3],pad$1=fmt1[2],iconv=fmt1[1];
          return [4,iconv,pad$1,prec,concat_fmt(rest$3,fmt2)];
         case 5:
          var rest$4=fmt1[4],prec$0=fmt1[3],pad$2=fmt1[2],iconv$0=fmt1[1];
          return [5,iconv$0,pad$2,prec$0,concat_fmt(rest$4,fmt2)];
         case 6:
          var rest$5=fmt1[4],prec$1=fmt1[3],pad$3=fmt1[2],iconv$1=fmt1[1];
          return [6,iconv$1,pad$3,prec$1,concat_fmt(rest$5,fmt2)];
         case 7:
          var rest$6=fmt1[4],prec$2=fmt1[3],pad$4=fmt1[2],iconv$2=fmt1[1];
          return [7,iconv$2,pad$4,prec$2,concat_fmt(rest$6,fmt2)];
         case 8:
          var rest$7=fmt1[4],prec$3=fmt1[3],pad$5=fmt1[2],fconv=fmt1[1];
          return [8,fconv,pad$5,prec$3,concat_fmt(rest$7,fmt2)];
         case 9:
          var rest$8=fmt1[2],pad$6=fmt1[1];
          return [9,pad$6,concat_fmt(rest$8,fmt2)];
         case 10:var rest$9=fmt1[1];return [10,concat_fmt(rest$9,fmt2)];
         case 11:
          var rest$10=fmt1[2],str=fmt1[1];
          return [11,str,concat_fmt(rest$10,fmt2)];
         case 12:
          var rest$11=fmt1[2],chr=fmt1[1];
          return [12,chr,concat_fmt(rest$11,fmt2)];
         case 13:
          var rest$12=fmt1[3],fmtty=fmt1[2],pad$7=fmt1[1];
          return [13,pad$7,fmtty,concat_fmt(rest$12,fmt2)];
         case 14:
          var rest$13=fmt1[3],fmtty$0=fmt1[2],pad$8=fmt1[1];
          return [14,pad$8,fmtty$0,concat_fmt(rest$13,fmt2)];
         case 15:var rest$14=fmt1[1];return [15,concat_fmt(rest$14,fmt2)];
         case 16:var rest$15=fmt1[1];return [16,concat_fmt(rest$15,fmt2)];
         case 17:
          var rest$16=fmt1[2],fmting_lit=fmt1[1];
          return [17,fmting_lit,concat_fmt(rest$16,fmt2)];
         case 18:
          var rest$17=fmt1[2],fmting_gen=fmt1[1];
          return [18,fmting_gen,concat_fmt(rest$17,fmt2)];
         case 19:var rest$18=fmt1[1];return [19,concat_fmt(rest$18,fmt2)];
         case 20:
          var rest$19=fmt1[3],char_set=fmt1[2],width_opt=fmt1[1];
          return [20,width_opt,char_set,concat_fmt(rest$19,fmt2)];
         case 21:
          var rest$20=fmt1[2],counter=fmt1[1];
          return [21,counter,concat_fmt(rest$20,fmt2)];
         case 22:var rest$21=fmt1[1];return [22,concat_fmt(rest$21,fmt2)];
         case 23:
          var rest$22=fmt1[2],ign=fmt1[1];
          return [23,ign,concat_fmt(rest$22,fmt2)];
         default:
          var rest$23=fmt1[3],f=fmt1[2],arity=fmt1[1];
          return [24,arity,f,concat_fmt(rest$23,fmt2)]}}
    var CamlinternalFormatBasics=[0,concat_fmtty,erase_rel,concat_fmt];
    caml_register_global
     (637,CamlinternalFormatBasics,"CamlinternalFormatBasics");
    function failwith(s){throw [0,Failure,s]}
    function invalid_arg(s){throw [0,Invalid_argument,s]}
    var Exit=[248,cst_Pervasives_Exit,caml_fresh_oo_id(0)];
    function min(x,y){return caml_lessequal(x,y)?x:y}
    function max(x,y){return caml_greaterequal(x,y)?x:y}
    function abs(x){return 0 <= x?x:- x | 0}
    function lnot(x){return x ^ -1}
    var
     infinity=caml_int64_float_of_bits(_a_),
     neg_infinity=caml_int64_float_of_bits(_b_),
     nan=caml_int64_float_of_bits(_c_),
     max_float=caml_int64_float_of_bits(_d_),
     min_float=caml_int64_float_of_bits(_e_),
     epsilon_float=caml_int64_float_of_bits(_f_),
     max_int=2147483647,
     min_int=-2147483648;
    function symbol(s1,s2)
     {var
       l1=caml_ml_string_length(s1),
       l2=caml_ml_string_length(s2),
       s=caml_create_bytes(l1 + l2 | 0);
      caml_blit_string(s1,0,s,0,l1);
      caml_blit_string(s2,0,s,l1,l2);
      return s}
    function char_of_int(n)
     {if(0 <= n)if(! (255 < n))return n;return invalid_arg(cst_char_of_int)}
    function string_of_bool(b){return b?cst_true:cst_false}
    function bool_of_string(param)
     {return caml_string_notequal(param,cst_false$0)
              ?caml_string_notequal(param,cst_true$0)
                ?invalid_arg(cst_bool_of_string)
                :1
              :0}
    function bool_of_string_opt(param)
     {return caml_string_notequal(param,cst_false$1)
              ?caml_string_notequal(param,cst_true$1)?0:_g_
              :_h_}
    function string_of_int(n){return caml_new_string("" + n)}
    function int_of_string_opt(s)
     {try
       {var _xr_=[0,caml_int_of_string(s)];return _xr_}
      catch(_xs_)
       {_xs_ = caml_wrap_exception(_xs_);
        if(_xs_[1] === Failure)return 0;
        throw _xs_}}
    function valid_float_lexem(s)
     {var l=caml_ml_string_length(s),i=0;
      for(;;)
       {if(l <= i)return symbol(s,cst);
        var
         match=caml_string_get(s,i),
         switch$0=48 <= match?58 <= match?0:1:45 === match?1:0;
        if(switch$0){var i$0=i + 1 | 0,i=i$0;continue}
        return s}}
    function string_of_float(f)
     {return valid_float_lexem(caml_format_float(cst_12g,f))}
    function float_of_string_opt(s)
     {try
       {var _xp_=[0,caml_float_of_string(s)];return _xp_}
      catch(_xq_)
       {_xq_ = caml_wrap_exception(_xq_);
        if(_xq_[1] === Failure)return 0;
        throw _xq_}}
    function append(l1,l2)
     {if(l1){var tl=l1[2],hd=l1[1];return [0,hd,append(tl,l2)]}return l2}
    var
     stdin=caml_ml_open_descriptor_in(0),
     stdout=caml_ml_open_descriptor_out(1),
     stderr=caml_ml_open_descriptor_out(2);
    function open_out_gen(mode,perm,name)
     {var c=caml_ml_open_descriptor_out(caml_sys_open(name,mode,perm));
      caml_ml_set_channel_name(c,name);
      return c}
    function open_out(name){return open_out_gen(_i_,438,name)}
    function open_out_bin(name){return open_out_gen(_j_,438,name)}
    function flush_all(param)
     {function iter(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var l=param$0[2],a=param$0[1];
            try
             {caml_ml_flush(a)}
            catch(_xo_)
             {_xo_ = caml_wrap_exception(_xo_);
              if(_xo_[1] !== Sys_error)throw _xo_;
              var _xn_=_xo_}
            var param$0=l;
            continue}
          return 0}}
      return iter(runtime.caml_ml_out_channels_list(0))}
    function output_bytes(oc,s)
     {return caml_ml_output_bytes(oc,s,0,caml_ml_bytes_length(s))}
    function output_string(oc,s)
     {return caml_ml_output(oc,s,0,caml_ml_string_length(s))}
    function output(oc,s,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(s) - len | 0) < ofs))
         return caml_ml_output_bytes(oc,s,ofs,len);
      return invalid_arg(cst_output)}
    function output_substring(oc,s,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_string_length(s) - len | 0) < ofs))
         return caml_ml_output(oc,s,ofs,len);
      return invalid_arg(cst_output_substring)}
    function output_value(chan,v){return caml_output_value(chan,v,0)}
    function close_out(oc){caml_ml_flush(oc);return caml_ml_close_channel(oc)}
    function close_out_noerr(oc)
     {try {caml_ml_flush(oc)}catch(_xm_){}
      try
       {var _xk_=caml_ml_close_channel(oc);return _xk_}
      catch(_xl_){return 0}}
    function open_in_gen(mode,perm,name)
     {var c=caml_ml_open_descriptor_in(caml_sys_open(name,mode,perm));
      caml_ml_set_channel_name(c,name);
      return c}
    function open_in(name){return open_in_gen(_k_,0,name)}
    function open_in_bin(name){return open_in_gen(_l_,0,name)}
    function input(ic,s,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(s) - len | 0) < ofs))
         return caml_ml_input(ic,s,ofs,len);
      return invalid_arg(cst_input)}
    function unsafe_really_input(ic,s,ofs,len)
     {var ofs$0=ofs,len$0=len;
      for(;;)
       {if(0 < len$0)
         {var r=caml_ml_input(ic,s,ofs$0,len$0);
          if(0 === r)throw End_of_file;
          var len$1=len$0 - r | 0,ofs$1=ofs$0 + r | 0,ofs$0=ofs$1,len$0=len$1;
          continue}
        return 0}}
    function really_input(ic,s,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(s) - len | 0) < ofs))
         return unsafe_really_input(ic,s,ofs,len);
      return invalid_arg(cst_really_input)}
    function really_input_string(ic,len)
     {var s=caml_create_bytes(len);really_input(ic,s,0,len);return s}
    function input_line(chan)
     {function build_result(buf,pos,param)
       {var pos$0=pos,param$0=param;
        for(;;)
         {if(param$0)
           {var tl=param$0[2],hd=param$0[1],len=caml_ml_bytes_length(hd);
            caml_blit_bytes(hd,0,buf,pos$0 - len | 0,len);
            var pos$1=pos$0 - len | 0,pos$0=pos$1,param$0=tl;
            continue}
          return buf}}
      var accu=0,len=0;
      for(;;)
       {var n=runtime.caml_ml_input_scan_line(chan);
        if(0 === n)
         {if(accu)return build_result(caml_create_bytes(len),len,accu);
          throw End_of_file}
        if(0 < n)
         {var res=caml_create_bytes(n - 1 | 0);
          caml_ml_input(chan,res,0,n - 1 | 0);
          caml_ml_input_char(chan);
          if(accu)
           {var len$0=(len + n | 0) - 1 | 0;
            return build_result(caml_create_bytes(len$0),len$0,[0,res,accu])}
          return res}
        var beg=caml_create_bytes(- n | 0);
        caml_ml_input(chan,beg,0,- n | 0);
        var len$1=len - n | 0,accu$0=[0,beg,accu],accu=accu$0,len=len$1;
        continue}}
    function close_in_noerr(ic)
     {try
       {var _xi_=caml_ml_close_channel(ic);return _xi_}
      catch(_xj_){return 0}}
    function print_char(c){return caml_ml_output_char(stdout,c)}
    function print_string(s){return output_string(stdout,s)}
    function print_bytes(s){return output_bytes(stdout,s)}
    function print_int(i)
     {return output_string(stdout,caml_new_string("" + i))}
    function print_float(f){return output_string(stdout,string_of_float(f))}
    function print_endline(s)
     {output_string(stdout,s);
      caml_ml_output_char(stdout,10);
      return caml_ml_flush(stdout)}
    function print_newline(param)
     {caml_ml_output_char(stdout,10);return caml_ml_flush(stdout)}
    function prerr_char(c){return caml_ml_output_char(stderr,c)}
    function prerr_string(s){return output_string(stderr,s)}
    function prerr_bytes(s){return output_bytes(stderr,s)}
    function prerr_int(i)
     {return output_string(stderr,caml_new_string("" + i))}
    function prerr_float(f){return output_string(stderr,string_of_float(f))}
    function prerr_endline(s)
     {output_string(stderr,s);
      caml_ml_output_char(stderr,10);
      return caml_ml_flush(stderr)}
    function prerr_newline(param)
     {caml_ml_output_char(stderr,10);return caml_ml_flush(stderr)}
    function read_line(param){caml_ml_flush(stdout);return input_line(stdin)}
    function read_int(param){return caml_int_of_string(read_line(0))}
    function read_int_opt(param){return int_of_string_opt(read_line(0))}
    function read_float(param){return caml_float_of_string(read_line(0))}
    function read_float_opt(param){return float_of_string_opt(read_line(0))}
    function string_of_format(param){var str=param[2];return str}
    function symbol$0(param,_xg_)
     {var
       str2=_xg_[2],
       fmt2=_xg_[1],
       str1=param[2],
       fmt1=param[1],
       _xh_=symbol(str1,symbol(cst$0,str2));
      return [0,concat_fmt(fmt1,fmt2),_xh_]}
    var exit_function=[0,flush_all];
    function at_exit(f)
     {var g=exit_function[1];
      exit_function[1]
      =
      function(param){caml_call1(f,0);return caml_call1(g,0)};
      return 0}
    function do_at_exit(param){return caml_call1(exit_function[1],0)}
    function exit(retcode)
     {do_at_exit(0);return runtime.caml_sys_exit(retcode)}
    var
     Pervasives=
      [0,
       invalid_arg,
       failwith,
       Exit,
       min,
       max,
       abs,
       max_int,
       min_int,
       lnot,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       symbol,
       char_of_int,
       string_of_bool,
       bool_of_string,
       bool_of_string_opt,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       append,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int,
       read_int_opt,
       read_float,
       read_float_opt,
       open_out,
       open_out_bin,
       open_out_gen,
       caml_ml_flush,
       flush_all,
       caml_ml_output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       caml_ml_output_char,
       runtime.caml_ml_output_int,
       output_value,
       runtime.caml_ml_seek_out,
       runtime.caml_ml_pos_out,
       caml_ml_channel_size,
       close_out,
       close_out_noerr,
       caml_ml_set_binary_mode,
       open_in,
       open_in_bin,
       open_in_gen,
       caml_ml_input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       caml_ml_input_char,
       runtime.caml_ml_input_int,
       caml_input_value,
       runtime.caml_ml_seek_in,
       runtime.caml_ml_pos_in,
       caml_ml_channel_size,
       caml_ml_close_channel,
       close_in_noerr,
       caml_ml_set_binary_mode,
       [0,
        runtime.caml_ml_seek_out_64,
        runtime.caml_ml_pos_out_64,
        caml_ml_channel_size_64,
        runtime.caml_ml_seek_in_64,
        runtime.caml_ml_pos_in_64,
        caml_ml_channel_size_64],
       string_of_format,
       symbol$0,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit];
    caml_register_global(642,Pervasives,"Pervasives");
    function length(l)
     {var len=0,param=l;
      for(;;)
       {if(param)
         {var param$0=param[2],len$0=len + 1 | 0,len=len$0,param=param$0;
          continue}
        return len}}
    function cons(a,l){return [0,a,l]}
    function hd(param)
     {if(param){var a=param[1];return a}return failwith(cst_hd)}
    function tl(param)
     {if(param){var l=param[2];return l}return failwith(cst_tl)}
    function nth(l,n)
     {if(0 <= n)
       {var l$0=l,n$0=n;
        for(;;)
         {if(l$0)
           {var l$1=l$0[2],a=l$0[1];
            if(0 === n$0)return a;
            var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;
            continue}
          return failwith(cst_nth)}}
      return invalid_arg(cst_List_nth)}
    function nth_opt(l,n)
     {if(0 <= n)
       {var l$0=l,n$0=n;
        for(;;)
         {if(l$0)
           {var l$1=l$0[2],a=l$0[1];
            if(0 === n$0)return [0,a];
            var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;
            continue}
          return 0}}
      return invalid_arg(cst_List_nth$0)}
    function rev_append(l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {var l1$1=l1$0[2],a=l1$0[1],l2$1=[0,a,l2$0],l1$0=l1$1,l2$0=l2$1;
          continue}
        return l2$0}}
    function rev(l){return rev_append(l,0)}
    function init_aux(i,n,f)
     {if(n <= i)return 0;
      var r=caml_call1(f,i);
      return [0,r,init_aux(i + 1 | 0,n,f)]}
    function init(len,f)
     {if(0 <= len)
       {if(10000 < len)
         {var acc=0,i=0;
          for(;;)
           {if(len <= i)return rev(acc);
            var i$0=i + 1 | 0,acc$0=[0,caml_call1(f,i),acc],acc=acc$0,i=i$0;
            continue}}
        return init_aux(0,len,f)}
      return invalid_arg(cst_List_init)}
    function flatten(param)
     {if(param){var r=param[2],l=param[1];return append(l,flatten(r))}
      return 0}
    function map(f,param)
     {if(param)
       {var l=param[2],a=param[1],r=caml_call1(f,a);return [0,r,map(f,l)]}
      return 0}
    function _m_(i,f,param)
     {if(param)
       {var l=param[2],a=param[1],r=caml_call2(f,i,a);
        return [0,r,_m_(i + 1 | 0,f,l)]}
      return 0}
    function mapi(f,l){return _m_(0,f,l)}
    function rev_map(f,param)
     {var accu=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           a=param$0[1],
           accu$0=[0,caml_call1(f,a),accu],
           accu=accu$0,
           param$0=l;
          continue}
        return accu}}
    function iter(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1];
          caml_call1(f,a);
          var param$0=l;
          continue}
        return 0}}
    function iteri(f,l$0)
     {var i=0,param=l$0;
      for(;;)
       {if(param)
         {var l=param[2],a=param[1];
          caml_call2(f,i,a);
          var i$0=i + 1 | 0,i=i$0,param=l;
          continue}
        return 0}}
    function fold_left(f,accu,l)
     {var accu$0=accu,l$0=l;
      for(;;)
       {if(l$0)
         {var
           l$1=l$0[2],
           a=l$0[1],
           accu$1=caml_call2(f,accu$0,a),
           accu$0=accu$1,
           l$0=l$1;
          continue}
        return accu$0}}
    function fold_right(f,l,accu)
     {if(l){var l$0=l[2],a=l[1];return caml_call2(f,a,fold_right(f,l$0,accu))}
      return accu}
    function map2(f,l1,l2)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1],r=caml_call2(f,a1,a2);
          return [0,r,map2(f,l1$0,l2$0)]}}
      else
       if(! l2)return 0;
      return invalid_arg(cst_List_map2)}
    function rev_map2(f,l1,l2)
     {var accu=0,l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             accu$0=[0,caml_call2(f,a1,a2),accu],
             accu=accu$0,
             l1$0=l1$1,
             l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return accu;
        return invalid_arg(cst_List_rev_map2)}}
    function iter2(f,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var l2$1=l2$0[2],a2=l2$0[1],l1$1=l1$0[2],a1=l1$0[1];
            caml_call2(f,a1,a2);
            var l1$0=l1$1,l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return 0;
        return invalid_arg(cst_List_iter2)}}
    function fold_left2(f,accu,l1,l2)
     {var accu$0=accu,l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             accu$1=caml_call3(f,accu$0,a1,a2),
             accu$0=accu$1,
             l1$0=l1$1,
             l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return accu$0;
        return invalid_arg(cst_List_fold_left2)}}
    function fold_right2(f,l1,l2,accu)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1];
          return caml_call3(f,a1,a2,fold_right2(f,l1$0,l2$0,accu))}}
      else
       if(! l2)return accu;
      return invalid_arg(cst_List_fold_right2)}
    function for_all(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_xf_=caml_call1(p,a);
          if(_xf_){var param$0=l;continue}
          return _xf_}
        return 1}}
    function exists(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_xe_=caml_call1(p,a);
          if(_xe_)return _xe_;
          var param$0=l;
          continue}
        return 0}}
    function for_all2(p,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             _xd_=caml_call2(p,a1,a2);
            if(_xd_){var l1$0=l1$1,l2$0=l2$1;continue}
            return _xd_}}
        else
         if(! l2$0)return 1;
        return invalid_arg(cst_List_for_all2)}}
    function exists2(p,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             _xc_=caml_call2(p,a1,a2);
            if(_xc_)return _xc_;
            var l1$0=l1$1,l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return 0;
        return invalid_arg(cst_List_exists2)}}
    function mem(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_xb_=0 === caml_compare(a,x)?1:0;
          if(_xb_)return _xb_;
          var param$0=l;
          continue}
        return 0}}
    function memq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_xa_=a === x?1:0;
          if(_xa_)return _xa_;
          var param$0=l;
          continue}
        return 0}}
    function assoc(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(0 === caml_compare(a,x))return b;
          var param$0=l;
          continue}
        throw Not_found}}
    function assoc_opt(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(0 === caml_compare(a,x))return [0,b];
          var param$0=l;
          continue}
        return 0}}
    function assq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(a === x)return b;
          var param$0=l;
          continue}
        throw Not_found}}
    function assq_opt(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(a === x)return [0,b];
          var param$0=l;
          continue}
        return 0}}
    function mem_assoc(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           match=param$0[1],
           a=match[1],
           _w$_=0 === caml_compare(a,x)?1:0;
          if(_w$_)return _w$_;
          var param$0=l;
          continue}
        return 0}}
    function mem_assq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],a=match[1],_w__=a === x?1:0;
          if(_w__)return _w__;
          var param$0=l;
          continue}
        return 0}}
    function remove_assoc(x,param)
     {if(param)
       {var l=param[2],pair=param[1],a=pair[1];
        return 0 === caml_compare(a,x)?l:[0,pair,remove_assoc(x,l)]}
      return 0}
    function remove_assq(x,param)
     {if(param)
       {var l=param[2],pair=param[1],a=pair[1];
        return a === x?l:[0,pair,remove_assq(x,l)]}
      return 0}
    function find(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))return x;
          var param$0=l;
          continue}
        throw Not_found}}
    function find_opt(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))return [0,x];
          var param$0=l;
          continue}
        return 0}}
    function find_all(p)
     {var accu=0;
      return function(param$0)
       {var accu$0=accu,param=param$0;
        for(;;)
         {if(param)
           {var l=param[2],x=param[1];
            if(caml_call1(p,x))
             {var accu$1=[0,x,accu$0],accu$0=accu$1,param=l;continue}
            var param=l;
            continue}
          return rev(accu$0)}}}
    function partition(p,param)
     {var yes=0,no=0,param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))
           {var yes$0=[0,x,yes],yes=yes$0,param$0=l;continue}
          var no$0=[0,x,no],no=no$0,param$0=l;
          continue}
        var _w9_=rev(no);
        return [0,rev(yes),_w9_]}}
    function split(param)
     {if(param)
       {var
         l=param[2],
         match=param[1],
         y=match[2],
         x=match[1],
         match$0=split(l),
         ry=match$0[2],
         rx=match$0[1];
        return [0,[0,x,rx],[0,y,ry]]}
      return _n_}
    function combine(l1,l2)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1];
          return [0,[0,a1,a2],combine(l1$0,l2$0)]}}
      else
       if(! l2)return 0;
      return invalid_arg(cst_List_combine)}
    function merge(cmp,l1,match)
     {if(l1)
       {if(match)
         {var t2=match[2],h2=match[1],t1=l1[2],h1=l1[1];
          return 0 < caml_call2(cmp,h1,h2)
                  ?[0,h2,merge(cmp,l1,t2)]
                  :[0,h1,merge(cmp,t1,match)]}
        return l1}
      return match}
    function chop(k,l)
     {var k$0=k,l$0=l;
      for(;;)
       {if(0 === k$0)return l$0;
        if(l$0){var l$1=l$0[2],k$1=k$0 - 1 | 0,k$0=k$1,l$0=l$1;continue}
        throw [0,Assert_failure,_o_]}}
    function fast_sort(cmp,l)
     {function sort(n,l)
       {if(2 === n)
         {if(l)
           {var _w6_=l[2];
            if(_w6_)
             {var x2=_w6_[1],x1=l[1];
              return 0 < caml_call2(cmp,x1,x2)?[0,x2,[0,x1,0]]:[0,x1,[0,x2,0]]}}}
        else
         if(3 === n)
          if(l)
           {var _w7_=l[2];
            if(_w7_)
             {var _w8_=_w7_[2];
              if(_w8_)
               {var x3=_w8_[1],x2$0=_w7_[1],x1$0=l[1];
                return 0 < caml_call2(cmp,x1$0,x2$0)
                        ?0 < caml_call2(cmp,x1$0,x3)
                          ?0 < caml_call2(cmp,x2$0,x3)
                            ?[0,x3,[0,x2$0,[0,x1$0,0]]]
                            :[0,x2$0,[0,x3,[0,x1$0,0]]]
                          :[0,x2$0,[0,x1$0,[0,x3,0]]]
                        :0 < caml_call2(cmp,x2$0,x3)
                          ?0 < caml_call2(cmp,x1$0,x3)
                            ?[0,x3,[0,x1$0,[0,x2$0,0]]]
                            :[0,x1$0,[0,x3,[0,x2$0,0]]]
                          :[0,x1$0,[0,x2$0,[0,x3,0]]]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         l2$0=chop(n1,l),
         l1$0=rev_sort(n1,l),
         l2$1=rev_sort(n2,l2$0),
         l1=l1$0,
         l2=l2$1,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1];
              if(0 < caml_call2(cmp,h1,h2))
               {var accu$0=[0,h1,accu],l1=t1,accu=accu$0;continue}
              var accu$1=[0,h2,accu],l2=t2,accu=accu$1;
              continue}
            return rev_append(l1,accu)}
          return rev_append(l2,accu)}}
      function rev_sort(n,l)
       {if(2 === n)
         {if(l)
           {var _w3_=l[2];
            if(_w3_)
             {var x2=_w3_[1],x1=l[1];
              return 0 < caml_call2(cmp,x1,x2)?[0,x1,[0,x2,0]]:[0,x2,[0,x1,0]]}}}
        else
         if(3 === n)
          if(l)
           {var _w4_=l[2];
            if(_w4_)
             {var _w5_=_w4_[2];
              if(_w5_)
               {var x3=_w5_[1],x2$0=_w4_[1],x1$0=l[1];
                return 0 < caml_call2(cmp,x1$0,x2$0)
                        ?0 < caml_call2(cmp,x2$0,x3)
                          ?[0,x1$0,[0,x2$0,[0,x3,0]]]
                          :0 < caml_call2(cmp,x1$0,x3)
                            ?[0,x1$0,[0,x3,[0,x2$0,0]]]
                            :[0,x3,[0,x1$0,[0,x2$0,0]]]
                        :0 < caml_call2(cmp,x1$0,x3)
                          ?[0,x2$0,[0,x1$0,[0,x3,0]]]
                          :0 < caml_call2(cmp,x2$0,x3)
                            ?[0,x2$0,[0,x3,[0,x1$0,0]]]
                            :[0,x3,[0,x2$0,[0,x1$0,0]]]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         l2$0=chop(n1,l),
         l1$0=sort(n1,l),
         l2$1=sort(n2,l2$0),
         l1=l1$0,
         l2=l2$1,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1];
              if(0 < caml_call2(cmp,h1,h2))
               {var accu$0=[0,h2,accu],l2=t2,accu=accu$0;continue}
              var accu$1=[0,h1,accu],l1=t1,accu=accu$1;
              continue}
            return rev_append(l1,accu)}
          return rev_append(l2,accu)}}
      var len=length(l);
      return 2 <= len?sort(len,l):l}
    function sort_uniq(cmp,l)
     {function sort(n,l)
       {if(2 === n)
         {if(l)
           {var _w0_=l[2];
            if(_w0_)
             {var x2=_w0_[1],x1=l[1],c$0=caml_call2(cmp,x1,x2);
              return 0 === c$0
                      ?[0,x1,0]
                      :0 <= c$0?[0,x2,[0,x1,0]]:[0,x1,[0,x2,0]]}}}
        else
         if(3 === n)
          if(l)
           {var _w1_=l[2];
            if(_w1_)
             {var _w2_=_w1_[2];
              if(_w2_)
               {var
                 x3=_w2_[1],
                 x2$0=_w1_[1],
                 x1$0=l[1],
                 c$1=caml_call2(cmp,x1$0,x2$0);
                if(0 === c$1)
                 {var c$2=caml_call2(cmp,x2$0,x3);
                  return 0 === c$2
                          ?[0,x2$0,0]
                          :0 <= c$2?[0,x3,[0,x2$0,0]]:[0,x2$0,[0,x3,0]]}
                if(0 <= c$1)
                 {var c$3=caml_call2(cmp,x1$0,x3);
                  if(0 === c$3)return [0,x2$0,[0,x1$0,0]];
                  if(0 <= c$3)
                   {var c$4=caml_call2(cmp,x2$0,x3);
                    return 0 === c$4
                            ?[0,x2$0,[0,x1$0,0]]
                            :0 <= c$4
                              ?[0,x3,[0,x2$0,[0,x1$0,0]]]
                              :[0,x2$0,[0,x3,[0,x1$0,0]]]}
                  return [0,x2$0,[0,x1$0,[0,x3,0]]]}
                var c$5=caml_call2(cmp,x2$0,x3);
                if(0 === c$5)return [0,x1$0,[0,x2$0,0]];
                if(0 <= c$5)
                 {var c$6=caml_call2(cmp,x1$0,x3);
                  return 0 === c$6
                          ?[0,x1$0,[0,x2$0,0]]
                          :0 <= c$6
                            ?[0,x3,[0,x1$0,[0,x2$0,0]]]
                            :[0,x1$0,[0,x3,[0,x2$0,0]]]}
                return [0,x1$0,[0,x2$0,[0,x3,0]]]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         l2$0=chop(n1,l),
         l1$0=rev_sort(n1,l),
         l2$1=rev_sort(n2,l2$0),
         l1=l1$0,
         l2=l2$1,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1],c=caml_call2(cmp,h1,h2);
              if(0 === c)
               {var accu$0=[0,h1,accu],l1=t1,l2=t2,accu=accu$0;continue}
              if(0 < c){var accu$1=[0,h1,accu],l1=t1,accu=accu$1;continue}
              var accu$2=[0,h2,accu],l2=t2,accu=accu$2;
              continue}
            return rev_append(l1,accu)}
          return rev_append(l2,accu)}}
      function rev_sort(n,l)
       {if(2 === n)
         {if(l)
           {var _wX_=l[2];
            if(_wX_)
             {var x2=_wX_[1],x1=l[1],c$0=caml_call2(cmp,x1,x2);
              return 0 === c$0
                      ?[0,x1,0]
                      :0 < c$0?[0,x1,[0,x2,0]]:[0,x2,[0,x1,0]]}}}
        else
         if(3 === n)
          if(l)
           {var _wY_=l[2];
            if(_wY_)
             {var _wZ_=_wY_[2];
              if(_wZ_)
               {var
                 x3=_wZ_[1],
                 x2$0=_wY_[1],
                 x1$0=l[1],
                 c$1=caml_call2(cmp,x1$0,x2$0);
                if(0 === c$1)
                 {var c$2=caml_call2(cmp,x2$0,x3);
                  return 0 === c$2
                          ?[0,x2$0,0]
                          :0 < c$2?[0,x2$0,[0,x3,0]]:[0,x3,[0,x2$0,0]]}
                if(0 < c$1)
                 {var c$3=caml_call2(cmp,x2$0,x3);
                  if(0 === c$3)return [0,x1$0,[0,x2$0,0]];
                  if(0 < c$3)return [0,x1$0,[0,x2$0,[0,x3,0]]];
                  var c$4=caml_call2(cmp,x1$0,x3);
                  return 0 === c$4
                          ?[0,x1$0,[0,x2$0,0]]
                          :0 < c$4
                            ?[0,x1$0,[0,x3,[0,x2$0,0]]]
                            :[0,x3,[0,x1$0,[0,x2$0,0]]]}
                var c$5=caml_call2(cmp,x1$0,x3);
                if(0 === c$5)return [0,x2$0,[0,x1$0,0]];
                if(0 < c$5)return [0,x2$0,[0,x1$0,[0,x3,0]]];
                var c$6=caml_call2(cmp,x2$0,x3);
                return 0 === c$6
                        ?[0,x2$0,[0,x1$0,0]]
                        :0 < c$6
                          ?[0,x2$0,[0,x3,[0,x1$0,0]]]
                          :[0,x3,[0,x2$0,[0,x1$0,0]]]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         l2$0=chop(n1,l),
         l1$0=sort(n1,l),
         l2$1=sort(n2,l2$0),
         l1=l1$0,
         l2=l2$1,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1],c=caml_call2(cmp,h1,h2);
              if(0 === c)
               {var accu$0=[0,h1,accu],l1=t1,l2=t2,accu=accu$0;continue}
              if(0 <= c){var accu$1=[0,h2,accu],l2=t2,accu=accu$1;continue}
              var accu$2=[0,h1,accu],l1=t1,accu=accu$2;
              continue}
            return rev_append(l1,accu)}
          return rev_append(l2,accu)}}
      var len=length(l);
      return 2 <= len?sort(len,l):l}
    function compare_lengths(l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0){var l2$1=l2$0[2],l1$1=l1$0[2],l1$0=l1$1,l2$0=l2$1;continue}
          return 1}
        return l2$0?-1:0}}
    function compare_length_with(l,n)
     {var l$0=l,n$0=n;
      for(;;)
       {if(l$0)
         {var l$1=l$0[2];
          if(0 < n$0){var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;continue}
          return 1}
        return 0 === n$0?0:0 < n$0?-1:1}}
    var
     include=
      [0,
       length,
       compare_lengths,
       compare_length_with,
       cons,
       hd,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       flatten,
       flatten,
       iter,
       iteri,
       map,
       mapi,
       rev_map,
       fold_left,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_all,
       find_all,
       partition,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       fast_sort,
       fast_sort,
       fast_sort,
       sort_uniq,
       merge];
    caml_register_global(645,include,"List");
    function chr(n)
     {if(0 <= n)if(! (255 < n))return n;return invalid_arg(cst_Char_chr)}
    function escaped(c)
     {if(40 <= c)
       {if(92 === c)return cst$1;var switch$0=127 <= c?0:1}
      else
       if(32 <= c)
        {if(39 <= c)return cst$2;var switch$0=1}
       else
        if(14 <= c)
         var switch$0=0;
        else
         switch(c)
          {case 8:return cst_b;
           case 9:return cst_t;
           case 10:return cst_n;
           case 13:return cst_r;
           default:var switch$0=0}
      if(switch$0)
       {var s$0=caml_create_bytes(1);
        caml_bytes_unsafe_set(s$0,0,c);
        return s$0}
      var s=caml_create_bytes(4);
      caml_bytes_unsafe_set(s,0,92);
      caml_bytes_unsafe_set(s,1,48 + (c / 100 | 0) | 0);
      caml_bytes_unsafe_set(s,2,48 + ((c / 10 | 0) % 10 | 0) | 0);
      caml_bytes_unsafe_set(s,3,48 + (c % 10 | 0) | 0);
      return s}
    function lowercase(c)
     {var switch$0=65 <= c?90 < c?0:1:0;
      if(! switch$0)
       {var switch$1=192 <= c?214 < c?0:1:0;
        if(! switch$1)
         {var switch$2=216 <= c?222 < c?1:0:1;if(switch$2)return c}}
      return c + 32 | 0}
    function uppercase(c)
     {var switch$0=97 <= c?122 < c?0:1:0;
      if(! switch$0)
       {var switch$1=224 <= c?246 < c?0:1:0;
        if(! switch$1)
         {var switch$2=248 <= c?254 < c?1:0:1;if(switch$2)return c}}
      return c - 32 | 0}
    function lowercase_ascii(c)
     {if(65 <= c)if(! (90 < c))return c + 32 | 0;return c}
    function uppercase_ascii(c)
     {if(97 <= c)if(! (122 < c))return c - 32 | 0;return c}
    function compare(c1,c2){return c1 - c2 | 0}
    function equal(c1,c2){return 0 === (c1 - c2 | 0)?1:0}
    var
     Char=
      [0,
       chr,
       escaped,
       lowercase,
       uppercase,
       lowercase_ascii,
       uppercase_ascii,
       compare,
       equal];
    caml_register_global(646,Char,"Char");
    var
     min$0=0,
     max$0=1114111,
     lo_bound=55295,
     hi_bound=57344,
     bom=65279,
     rep=65533;
    function succ(u)
     {return u === 55295
              ?hi_bound
              :u === 1114111?invalid_arg(err_no_succ):u + 1 | 0}
    function pred(u)
     {return u === 57344?lo_bound:u === 0?invalid_arg(err_no_pred):u - 1 | 0}
    function is_valid(i)
     {var _wT_=0 <= i?1:0,_wU_=_wT_?i <= 55295?1:0:_wT_;
      if(_wU_)
       var _wV_=_wU_;
      else
       var _wW_=57344 <= i?1:0,_wV_=_wW_?i <= 1114111?1:0:_wW_;
      return _wV_}
    function of_int(i)
     {return is_valid(i)
              ?i
              :invalid_arg
                (symbol
                  (caml_format_int(cst_X,i),
                   cst_is_not_an_Unicode_scalar_value))}
    function is_char(u){return u < 256?1:0}
    function of_char(c){return c}
    function to_char(u)
     {return 255 < u
              ?invalid_arg
                (symbol
                  (cst_U,
                   symbol
                    (caml_format_int(cst_04X,u),cst_is_not_a_latin1_character)))
              :u}
    function unsafe_to_char(_wS_){return _wS_}
    function equal$0(_wR_,_wQ_){return _wR_ === _wQ_?1:0}
    var compare$0=caml_int_compare;
    function hash(_wP_){return _wP_}
    function _p_(_wO_){return _wO_}
    var
     Uchar=
      [0,
       min$0,
       max$0,
       bom,
       rep,
       succ,
       pred,
       is_valid,
       of_int,
       function(_wN_){return _wN_},
       _p_,
       is_char,
       of_char,
       to_char,
       unsafe_to_char,
       equal$0,
       compare$0,
       hash];
    caml_register_global(647,Uchar,"Uchar");
    function make(n,c)
     {var s=caml_create_bytes(n);caml_fill_bytes(s,0,n,c);return s}
    function init$0(n,f)
     {var s=caml_create_bytes(n),_wL_=n - 1 | 0,_wK_=0;
      if(! (_wL_ < 0))
       {var i=_wK_;
        for(;;)
         {caml_bytes_unsafe_set(s,i,caml_call1(f,i));
          var _wM_=i + 1 | 0;
          if(_wL_ !== i){var i=_wM_;continue}
          break}}
      return s}
    var empty=caml_create_bytes(0);
    function copy(s)
     {var len=caml_ml_bytes_length(s),r=caml_create_bytes(len);
      caml_blit_bytes(s,0,r,0,len);
      return r}
    function to_string(b){return copy(b)}
    function of_string(s){return copy(s)}
    function sub(s,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(s) - len | 0) < ofs))
         {var r=caml_create_bytes(len);
          caml_blit_bytes(s,ofs,r,0,len);
          return r}
      return invalid_arg(cst_String_sub_Bytes_sub)}
    function sub_string(b,ofs,len){return sub(b,ofs,len)}
    function symbol$1(a,b)
     {var
       c=a + b | 0,
       _wJ_=b < 0?1:0,
       match=c < 0?1:0,
       switch$0=
        0 === (a < 0?1:0)
         ?0 === _wJ_?0 === match?0:1:0
         :0 === _wJ_?0:0 === match?1:0;
      return switch$0?invalid_arg(cst_Bytes_extend):c}
    function extend(s,left,right)
     {var
       len=symbol$1(symbol$1(caml_ml_bytes_length(s),left),right),
       r=caml_create_bytes(len);
      if(0 <= left)
       var srcoff=0,dstoff=left;
      else
       var srcoff=- left | 0,dstoff=0;
      var cpylen=min(caml_ml_bytes_length(s) - srcoff | 0,len - dstoff | 0);
      if(0 < cpylen)caml_blit_bytes(s,srcoff,r,dstoff,cpylen);
      return r}
    function fill(s,ofs,len,c)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(s) - len | 0) < ofs))
         return caml_fill_bytes(s,ofs,len,c);
      return invalid_arg(cst_String_fill_Bytes_fill)}
    function blit(s1,ofs1,s2,ofs2,len)
     {if(0 <= len)
       if(0 <= ofs1)
        if(! ((caml_ml_bytes_length(s1) - len | 0) < ofs1))
         if(0 <= ofs2)
          if(! ((caml_ml_bytes_length(s2) - len | 0) < ofs2))
           return caml_blit_bytes(s1,ofs1,s2,ofs2,len);
      return invalid_arg(cst_Bytes_blit)}
    function blit$0(s1,ofs1,s2,ofs2,len)
     {if(0 <= len)
       if(0 <= ofs1)
        if(! ((caml_ml_string_length(s1) - len | 0) < ofs1))
         if(0 <= ofs2)
          if(! ((caml_ml_bytes_length(s2) - len | 0) < ofs2))
           return caml_blit_string(s1,ofs1,s2,ofs2,len);
      return invalid_arg(cst_String_blit_Bytes_blit_string)}
    function iter$0(f,a)
     {var _wH_=caml_ml_bytes_length(a) - 1 | 0,_wG_=0;
      if(! (_wH_ < 0))
       {var i=_wG_;
        for(;;)
         {caml_call1(f,caml_bytes_unsafe_get(a,i));
          var _wI_=i + 1 | 0;
          if(_wH_ !== i){var i=_wI_;continue}
          break}}
      return 0}
    function iteri$0(f,a)
     {var _wE_=caml_ml_bytes_length(a) - 1 | 0,_wD_=0;
      if(! (_wE_ < 0))
       {var i=_wD_;
        for(;;)
         {caml_call2(f,i,caml_bytes_unsafe_get(a,i));
          var _wF_=i + 1 | 0;
          if(_wE_ !== i){var i=_wF_;continue}
          break}}
      return 0}
    function concat(sep,l)
     {if(l)
       {var seplen=caml_ml_bytes_length(sep),acc=0,param=l,pos$1=0;
        for(;;)
         {if(param)
           {var _wy_=param[2],_wz_=param[1];
            if(_wy_)
             {var
               x=(caml_ml_bytes_length(_wz_) + seplen | 0) + acc | 0,
               acc$0=acc <= x?x:invalid_arg(cst_Bytes_concat),
               acc=acc$0,
               param=_wy_;
              continue}
            var _wC_=caml_ml_bytes_length(_wz_) + acc | 0}
          else
           var _wC_=acc;
          var dst=caml_create_bytes(_wC_),pos=pos$1,param$0=l;
          for(;;)
           {if(param$0)
             {var _wA_=param$0[2],_wB_=param$0[1];
              if(_wA_)
               {caml_blit_bytes(_wB_,0,dst,pos,caml_ml_bytes_length(_wB_));
                caml_blit_bytes
                 (sep,0,dst,pos + caml_ml_bytes_length(_wB_) | 0,seplen);
                var
                 pos$0=(pos + caml_ml_bytes_length(_wB_) | 0) + seplen | 0,
                 pos=pos$0,
                 param$0=_wA_;
                continue}
              caml_blit_bytes(_wB_,0,dst,pos,caml_ml_bytes_length(_wB_));
              return dst}
            return dst}}}
      return empty}
    function cat(s1,s2)
     {var
       l1=caml_ml_bytes_length(s1),
       l2=caml_ml_bytes_length(s2),
       r=caml_create_bytes(l1 + l2 | 0);
      caml_blit_bytes(s1,0,r,0,l1);
      caml_blit_bytes(s2,0,r,l1,l2);
      return r}
    function is_space(param)
     {var
       _wx_=param - 9 | 0,
       switch$0=4 < _wx_ >>> 0?23 === _wx_?1:0:2 === _wx_?0:1;
      return switch$0?1:0}
    function trim(s)
     {var len=caml_ml_bytes_length(s),i=[0,0];
      for(;;)
       {if(i[1] < len)
         if(is_space(caml_bytes_unsafe_get(s,i[1]))){i[1]++;continue}
        var j=[0,len - 1 | 0];
        for(;;)
         {if(i[1] <= j[1])
           if(is_space(caml_bytes_unsafe_get(s,j[1]))){j[1] += -1;continue}
          return i[1] <= j[1]?sub(s,i[1],(j[1] - i[1] | 0) + 1 | 0):empty}}}
    function escaped$0(s)
     {var n=[0,0],_wq_=caml_ml_bytes_length(s) - 1 | 0,_wp_=0;
      if(! (_wq_ < 0))
       {var i$0=_wp_;
        for(;;)
         {var match=caml_bytes_unsafe_get(s,i$0);
          if(32 <= match)
           {var _wu_=match - 34 | 0;
            if(58 < _wu_ >>> 0)
             if(93 <= _wu_)var switch$0=0,switch$1=0;else var switch$1=1;
            else
             if(56 < (_wu_ - 1 | 0) >>> 0)
              var switch$0=1,switch$1=0;
             else
              var switch$1=1;
            if(switch$1)var _wv_=1,switch$0=2}
          else
           var switch$0=11 <= match?13 === match?1:0:8 <= match?1:0;
          switch(switch$0){case 0:var _wv_=4;break;case 1:var _wv_=2;break}
          n[1] = n[1] + _wv_ | 0;
          var _ww_=i$0 + 1 | 0;
          if(_wq_ !== i$0){var i$0=_ww_;continue}
          break}}
      if(n[1] === caml_ml_bytes_length(s))return copy(s);
      var s$0=caml_create_bytes(n[1]);
      n[1] = 0;
      var _ws_=caml_ml_bytes_length(s) - 1 | 0,_wr_=0;
      if(! (_ws_ < 0))
       {var i=_wr_;
        for(;;)
         {var c=caml_bytes_unsafe_get(s,i);
          if(35 <= c)
           var switch$2=92 === c?1:127 <= c?0:2;
          else
           if(32 <= c)
            var switch$2=34 <= c?1:2;
           else
            if(14 <= c)
             var switch$2=0;
            else
             switch(c)
              {case 8:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],98);
                var switch$2=3;
                break;
               case 9:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],116);
                var switch$2=3;
                break;
               case 10:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],110);
                var switch$2=3;
                break;
               case 13:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],114);
                var switch$2=3;
                break;
               default:var switch$2=0}
          switch(switch$2)
           {case 0:
             caml_bytes_unsafe_set(s$0,n[1],92);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + (c / 100 | 0) | 0);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + ((c / 10 | 0) % 10 | 0) | 0);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + (c % 10 | 0) | 0);
             break;
            case 1:
             caml_bytes_unsafe_set(s$0,n[1],92);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],c);
             break;
            case 2:caml_bytes_unsafe_set(s$0,n[1],c);break
            }
          n[1]++;
          var _wt_=i + 1 | 0;
          if(_ws_ !== i){var i=_wt_;continue}
          break}}
      return s$0}
    function map$0(f,s)
     {var l=caml_ml_bytes_length(s);
      if(0 === l)return s;
      var r=caml_create_bytes(l),_wn_=l - 1 | 0,_wm_=0;
      if(! (_wn_ < 0))
       {var i=_wm_;
        for(;;)
         {caml_bytes_unsafe_set(r,i,caml_call1(f,caml_bytes_unsafe_get(s,i)));
          var _wo_=i + 1 | 0;
          if(_wn_ !== i){var i=_wo_;continue}
          break}}
      return r}
    function mapi$0(f,s)
     {var l=caml_ml_bytes_length(s);
      if(0 === l)return s;
      var r=caml_create_bytes(l),_wk_=l - 1 | 0,_wj_=0;
      if(! (_wk_ < 0))
       {var i=_wj_;
        for(;;)
         {caml_bytes_unsafe_set
           (r,i,caml_call2(f,i,caml_bytes_unsafe_get(s,i)));
          var _wl_=i + 1 | 0;
          if(_wk_ !== i){var i=_wl_;continue}
          break}}
      return r}
    function uppercase_ascii$0(s){return map$0(uppercase_ascii,s)}
    function lowercase_ascii$0(s){return map$0(lowercase_ascii,s)}
    function apply1(f,s)
     {if(0 === caml_ml_bytes_length(s))return s;
      var r=copy(s);
      caml_bytes_unsafe_set(r,0,caml_call1(f,caml_bytes_unsafe_get(s,0)));
      return r}
    function capitalize_ascii(s){return apply1(uppercase_ascii,s)}
    function uncapitalize_ascii(s){return apply1(lowercase_ascii,s)}
    function index_rec(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)throw Not_found;
        if(caml_bytes_unsafe_get(s,i$0) === c)return i$0;
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index(s,c){return index_rec(s,caml_ml_bytes_length(s),0,c)}
    function index_rec_opt(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)return 0;
        if(caml_bytes_unsafe_get(s,i$0) === c)return [0,i$0];
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index_opt(s,c)
     {return index_rec_opt(s,caml_ml_bytes_length(s),0,c)}
    function index_from(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i)if(! (l < i))return index_rec(s,l,i,c);
      return invalid_arg(cst_String_index_from_Bytes_index_from)}
    function index_from_opt(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i)if(! (l < i))return index_rec_opt(s,l,i,c);
      return invalid_arg(cst_String_index_from_opt_Bytes_index_from_opt)}
    function rindex_rec(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_bytes_unsafe_get(s,i$0) === c)return i$0;
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        throw Not_found}}
    function rindex(s,c)
     {return rindex_rec(s,caml_ml_bytes_length(s) - 1 | 0,c)}
    function rindex_from(s,i,c)
     {if(-1 <= i)if(! (caml_ml_bytes_length(s) <= i))return rindex_rec(s,i,c);
      return invalid_arg(cst_String_rindex_from_Bytes_rindex_from)}
    function rindex_rec_opt(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_bytes_unsafe_get(s,i$0) === c)return [0,i$0];
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        return 0}}
    function rindex_opt(s,c)
     {return rindex_rec_opt(s,caml_ml_bytes_length(s) - 1 | 0,c)}
    function rindex_from_opt(s,i,c)
     {if(-1 <= i)
       if(! (caml_ml_bytes_length(s) <= i))return rindex_rec_opt(s,i,c);
      return invalid_arg(cst_String_rindex_from_opt_Bytes_rindex_from_opt)}
    function contains_from(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i)
       if(! (l < i))
        try
         {index_rec(s,l,i,c);var _wh_=1;return _wh_}
        catch(_wi_)
         {_wi_ = caml_wrap_exception(_wi_);
          if(_wi_ === Not_found)return 0;
          throw _wi_}
      return invalid_arg(cst_String_contains_from_Bytes_contains_from)}
    function contains(s,c){return contains_from(s,0,c)}
    function rcontains_from(s,i,c)
     {if(0 <= i)
       if(! (caml_ml_bytes_length(s) <= i))
        try
         {rindex_rec(s,i,c);var _wf_=1;return _wf_}
        catch(_wg_)
         {_wg_ = caml_wrap_exception(_wg_);
          if(_wg_ === Not_found)return 0;
          throw _wg_}
      return invalid_arg(cst_String_rcontains_from_Bytes_rcontains_from)}
    var compare$1=runtime.caml_bytes_compare;
    function uppercase$0(s){return map$0(uppercase,s)}
    function lowercase$0(s){return map$0(lowercase,s)}
    function capitalize(s){return apply1(uppercase,s)}
    function uncapitalize(s){return apply1(lowercase,s)}
    function unsafe_of_string(_we_){return _we_}
    function unsafe_to_string(_wd_){return _wd_}
    var
     equal$1=runtime.caml_bytes_equal,
     include$0=
      [0,
       make,
       init$0,
       empty,
       copy,
       of_string,
       to_string,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit$0,
       concat,
       cat,
       iter$0,
       iteri$0,
       map$0,
       mapi$0,
       trim,
       escaped$0,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase$0,
       lowercase$0,
       capitalize,
       uncapitalize,
       uppercase_ascii$0,
       lowercase_ascii$0,
       capitalize_ascii,
       uncapitalize_ascii,
       compare$1,
       equal$1,
       unsafe_to_string,
       unsafe_of_string];
    caml_register_global(648,include$0,"Bytes");
    function make$0(n,c){return make(n,c)}
    function init$1(n,f){return init$0(n,f)}
    function copy$0(s){return copy(s)}
    function sub$0(s,ofs,len){return sub(s,ofs,len)}
    function concat$0(sep,l)
     {if(l)
       {var seplen=caml_ml_string_length(sep),acc=0,param=l,pos$1=0;
        for(;;)
         {if(param)
           {var _v__=param[2],_v$_=param[1];
            if(_v__)
             {var
               x=(caml_ml_string_length(_v$_) + seplen | 0) + acc | 0,
               acc$0=acc <= x?x:invalid_arg(cst_String_concat),
               acc=acc$0,
               param=_v__;
              continue}
            var _wc_=caml_ml_string_length(_v$_) + acc | 0}
          else
           var _wc_=acc;
          var dst=caml_create_bytes(_wc_),pos=pos$1,param$0=l;
          for(;;)
           {if(param$0)
             {var _wa_=param$0[2],_wb_=param$0[1];
              if(_wa_)
               {caml_blit_string(_wb_,0,dst,pos,caml_ml_string_length(_wb_));
                caml_blit_string
                 (sep,0,dst,pos + caml_ml_string_length(_wb_) | 0,seplen);
                var
                 pos$0=(pos + caml_ml_string_length(_wb_) | 0) + seplen | 0,
                 pos=pos$0,
                 param$0=_wa_;
                continue}
              caml_blit_string(_wb_,0,dst,pos,caml_ml_string_length(_wb_));
              return dst}
            return dst}}}
      return cst$3}
    function iter$1(f,s)
     {var _v8_=caml_ml_string_length(s) - 1 | 0,_v7_=0;
      if(! (_v8_ < 0))
       {var i=_v7_;
        for(;;)
         {caml_call1(f,caml_bytes_unsafe_get(s,i));
          var _v9_=i + 1 | 0;
          if(_v8_ !== i){var i=_v9_;continue}
          break}}
      return 0}
    function iteri$1(f,s)
     {var _v5_=caml_ml_string_length(s) - 1 | 0,_v4_=0;
      if(! (_v5_ < 0))
       {var i=_v4_;
        for(;;)
         {caml_call2(f,i,caml_bytes_unsafe_get(s,i));
          var _v6_=i + 1 | 0;
          if(_v5_ !== i){var i=_v6_;continue}
          break}}
      return 0}
    function map$1(f,s){return map$0(f,s)}
    function mapi$1(f,s){return mapi$0(f,s)}
    function is_space$0(param)
     {var
       _v3_=param - 9 | 0,
       switch$0=4 < _v3_ >>> 0?23 === _v3_?1:0:2 === _v3_?0:1;
      return switch$0?1:0}
    function trim$0(s)
     {if(caml_string_equal(s,cst$4))return s;
      if(! is_space$0(caml_bytes_unsafe_get(s,0)))
       if
        (!
         is_space$0(caml_bytes_unsafe_get(s,caml_ml_string_length(s) - 1 | 0)))
        return s;
      return trim(s)}
    function escaped$1(s)
     {var i=0;
      for(;;)
       {if(caml_ml_string_length(s) <= i)
         var _v2_=0;
        else
         {var match=caml_bytes_unsafe_get(s,i);
          if(32 <= match)
           {var _v1_=match - 34 | 0;
            if(58 < _v1_ >>> 0)
             if(93 <= _v1_)var switch$0=0,switch$1=0;else var switch$1=1;
            else
             if(56 < (_v1_ - 1 | 0) >>> 0)
              var switch$0=1,switch$1=0;
             else
              var switch$1=1;
            if(switch$1){var i$0=i + 1 | 0,i=i$0;continue}}
          else
           var switch$0=11 <= match?13 === match?1:0:8 <= match?1:0;
          var _v2_=switch$0?1:1}
        return _v2_?escaped$0(s):s}}
    function index_rec$0(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)throw Not_found;
        if(caml_bytes_unsafe_get(s,i$0) === c)return i$0;
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index$0(s,c){return index_rec$0(s,caml_ml_string_length(s),0,c)}
    function index_rec_opt$0(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)return 0;
        if(caml_bytes_unsafe_get(s,i$0) === c)return [0,i$0];
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index_opt$0(s,c)
     {return index_rec_opt$0(s,caml_ml_string_length(s),0,c)}
    function index_from$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i)if(! (l < i))return index_rec$0(s,l,i,c);
      return invalid_arg(cst_String_index_from_Bytes_index_from$0)}
    function index_from_opt$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i)if(! (l < i))return index_rec_opt$0(s,l,i,c);
      return invalid_arg(cst_String_index_from_opt_Bytes_index_from_opt$0)}
    function rindex_rec$0(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_bytes_unsafe_get(s,i$0) === c)return i$0;
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        throw Not_found}}
    function rindex$0(s,c)
     {return rindex_rec$0(s,caml_ml_string_length(s) - 1 | 0,c)}
    function rindex_from$0(s,i,c)
     {if(-1 <= i)
       if(! (caml_ml_string_length(s) <= i))return rindex_rec$0(s,i,c);
      return invalid_arg(cst_String_rindex_from_Bytes_rindex_from$0)}
    function rindex_rec_opt$0(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_bytes_unsafe_get(s,i$0) === c)return [0,i$0];
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        return 0}}
    function rindex_opt$0(s,c)
     {return rindex_rec_opt$0(s,caml_ml_string_length(s) - 1 | 0,c)}
    function rindex_from_opt$0(s,i,c)
     {if(-1 <= i)
       if(! (caml_ml_string_length(s) <= i))return rindex_rec_opt$0(s,i,c);
      return invalid_arg(cst_String_rindex_from_opt_Bytes_rindex_from_opt$0)}
    function contains_from$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i)
       if(! (l < i))
        try
         {index_rec$0(s,l,i,c);var _vZ_=1;return _vZ_}
        catch(_v0_)
         {_v0_ = caml_wrap_exception(_v0_);
          if(_v0_ === Not_found)return 0;
          throw _v0_}
      return invalid_arg(cst_String_contains_from_Bytes_contains_from$0)}
    function contains$0(s,c){return contains_from$0(s,0,c)}
    function rcontains_from$0(s,i,c)
     {if(0 <= i)
       if(! (caml_ml_string_length(s) <= i))
        try
         {rindex_rec$0(s,i,c);var _vX_=1;return _vX_}
        catch(_vY_)
         {_vY_ = caml_wrap_exception(_vY_);
          if(_vY_ === Not_found)return 0;
          throw _vY_}
      return invalid_arg(cst_String_rcontains_from_Bytes_rcontains_from$0)}
    function uppercase_ascii$1(s){return uppercase_ascii$0(s)}
    function lowercase_ascii$1(s){return lowercase_ascii$0(s)}
    function capitalize_ascii$0(s){return capitalize_ascii(s)}
    function uncapitalize_ascii$0(s){return uncapitalize_ascii(s)}
    var compare$2=caml_string_compare;
    function split_on_char(sep,s)
     {var
       r=[0,0],
       j=[0,caml_ml_string_length(s)],
       _vT_=caml_ml_string_length(s) - 1 | 0;
      if(! (_vT_ < 0))
       {var i=_vT_;
        for(;;)
         {if(caml_bytes_unsafe_get(s,i) === sep)
           {var _vV_=r[1];
            r[1] = [0,sub$0(s,i + 1 | 0,(j[1] - i | 0) - 1 | 0),_vV_];
            j[1] = i}
          var _vW_=i - 1 | 0;
          if(0 !== i){var i=_vW_;continue}
          break}}
      var _vU_=r[1];
      return [0,sub$0(s,0,j[1]),_vU_]}
    function uppercase$1(s){return uppercase$0(s)}
    function lowercase$1(s){return lowercase$0(s)}
    function capitalize$0(s){return capitalize(s)}
    function uncapitalize$0(s){return uncapitalize(s)}
    var
     equal$2=caml_string_equal,
     include$1=
      [0,
       make$0,
       init$1,
       copy$0,
       sub$0,
       fill,
       blit$0,
       concat$0,
       iter$1,
       iteri$1,
       map$1,
       mapi$1,
       trim$0,
       escaped$1,
       index$0,
       index_opt$0,
       rindex$0,
       rindex_opt$0,
       index_from$0,
       index_from_opt$0,
       rindex_from$0,
       rindex_from_opt$0,
       contains$0,
       contains_from$0,
       rcontains_from$0,
       uppercase$1,
       lowercase$1,
       capitalize$0,
       uncapitalize$0,
       uppercase_ascii$1,
       lowercase_ascii$1,
       capitalize_ascii$0,
       uncapitalize_ascii$0,
       compare$2,
       equal$2,
       split_on_char];
    caml_register_global(649,include$1,"String");
    var
     match=runtime.caml_sys_get_argv(0),
     _q_=match[2],
     match$0=runtime.caml_sys_get_config(0),
     os_type=match$0[1],
     backend_type=runtime.caml_sys_const_backend_type(0),
     unix=runtime.caml_sys_const_ostype_unix(0),
     win32=runtime.caml_sys_const_ostype_win32(0),
     cygwin=runtime.caml_sys_const_ostype_cygwin(0),
     max_array_length=runtime.caml_sys_const_max_wosize(0),
     max_string_length=(4 * max_array_length | 0) - 1 | 0,
     _r_=match[1],
     big_endian=0,
     size=32,
     int_size=32;
    function getenv_opt(s)
     {try
       {var _vR_=[0,caml_sys_getenv(s)];return _vR_}
      catch(_vS_)
       {_vS_ = caml_wrap_exception(_vS_);
        if(_vS_ === Not_found)return 0;
        throw _vS_}}
    var interactive=[0,0];
    function set_signal(sig_num,sig_beh){return 0}
    var
     Break=[248,cst_Sys_Break,caml_fresh_oo_id(0)],
     sigabrt=-1,
     sigalrm=-2,
     sigfpe=-3,
     sighup=-4,
     sigill=-5,
     sigint=-6,
     sigkill=-7,
     sigpipe=-8,
     sigquit=-9,
     sigsegv=-10,
     sigterm=-11,
     sigusr1=-12,
     sigusr2=-13,
     sigchld=-14,
     sigcont=-15,
     sigstop=-16,
     sigtstp=-17,
     sigttin=-18,
     sigttou=-19,
     sigvtalrm=-20,
     sigprof=-21,
     sigbus=-22,
     sigpoll=-23,
     sigsys=-24,
     sigtrap=-25,
     sigurg=-26,
     sigxcpu=-27,
     sigxfsz=-28;
    function catch_break(on){return on?0:0}
    var
     Sys=
      [0,
       _q_,
       _r_,
       getenv_opt,
       interactive,
       os_type,
       backend_type,
       unix,
       win32,
       cygwin,
       size,
       int_size,
       big_endian,
       max_string_length,
       max_array_length,
       set_signal,
       sigabrt,
       sigalrm,
       sigfpe,
       sighup,
       sigill,
       sigint,
       sigkill,
       sigpipe,
       sigquit,
       sigsegv,
       sigterm,
       sigusr1,
       sigusr2,
       sigchld,
       sigcont,
       sigstop,
       sigtstp,
       sigttin,
       sigttou,
       sigvtalrm,
       sigprof,
       sigbus,
       sigpoll,
       sigsys,
       sigtrap,
       sigurg,
       sigxcpu,
       sigxfsz,
       Break,
       catch_break,
       ocaml_version,
       runtime.caml_ml_enable_runtime_warnings,
       runtime.caml_ml_runtime_warnings_enabled];
    caml_register_global(650,Sys,"Sys");
    function merge$0(order,l1,l2)
     {if(l1)
       {var t1=l1[2],h1=l1[1];
        if(l2)
         {var t2=l2[2],h2=l2[1];
          return caml_call2(order,h1,h2)
                  ?[0,h1,merge$0(order,t1,l2)]
                  :[0,h2,merge$0(order,l1,t2)]}
        return l1}
      return l2}
    function list(order,l)
     {function initlist(param)
       {if(param)
         {var _vN_=param[2],_vO_=param[1];
          if(_vN_)
           {var
             rest=_vN_[2],
             e2=_vN_[1],
             _vP_=initlist(rest),
             _vQ_=
              caml_call2(order,_vO_,e2)?[0,_vO_,[0,e2,0]]:[0,e2,[0,_vO_,0]];
            return [0,_vQ_,_vP_]}
          return [0,[0,_vO_,0],0]}
        return 0}
      function merge2(x)
       {if(x)
         {var _vL_=x[2];
          if(_vL_)
           {var rest=_vL_[2],l2=_vL_[1],l1=x[1],_vM_=merge2(rest);
            return [0,merge$0(order,l1,l2),_vM_]}}
        return x}
      var llist$1=initlist(l),llist=llist$1;
      for(;;)
       {if(llist)
         {if(llist[2]){var llist$0=merge2(llist),llist=llist$0;continue}
          var l$0=llist[1];
          return l$0}
        return 0}}
    function swap(arr,i,j)
     {var tmp=arr[1 + i];arr[1 + i] = arr[1 + j];arr[1 + j] = tmp;return 0}
    function array(cmp,arr)
     {function qsort(lo,hi)
       {var lo$0=lo,hi$0=hi;
        a:
        for(;;)
         {var _vI_=6 <= (hi$0 - lo$0 | 0)?1:0;
          if(_vI_)
           {var mid=(lo$0 + hi$0 | 0) >>> 1 | 0;
            if(caml_call2(cmp,arr[1 + mid],arr[1 + lo$0]))swap(arr,mid,lo$0);
            if(caml_call2(cmp,arr[1 + hi$0],arr[1 + mid]))
             {swap(arr,mid,hi$0);
              if(caml_call2(cmp,arr[1 + mid],arr[1 + lo$0]))swap(arr,mid,lo$0)}
            var
             pivot=arr[1 + mid],
             i=[0,lo$0 + 1 | 0],
             j=[0,hi$0 - 1 | 0],
             _vJ_=1 - caml_call2(cmp,pivot,arr[1 + hi$0]),
             _vK_=_vJ_ || 1 - caml_call2(cmp,arr[1 + lo$0],pivot);
            if(_vK_)throw [0,Invalid_argument,cst_Sort_array];
            b:
            for(;;)
             {if(i[1] < j[1])
               for(;;)
                {if(caml_call2(cmp,pivot,arr[1 + i[1]]))
                  for(;;)
                   {if(caml_call2(cmp,arr[1 + j[1]],pivot))
                     {if(i[1] < j[1])swap(arr,i[1],j[1]);
                      i[1]++;
                      j[1] += -1;
                      continue b}
                    j[1] += -1;
                    continue}
                 i[1]++;
                 continue}
              if((j[1] - lo$0 | 0) <= (hi$0 - i[1] | 0))
               {qsort(lo$0,j[1]);var lo$1=i[1],lo$0=lo$1;continue a}
              qsort(i[1],hi$0);
              var hi$1=j[1],hi$0=hi$1;
              continue a}}
          return _vI_}}
      qsort(0,arr.length - 1 - 1 | 0);
      var _vG_=arr.length - 1 - 1 | 0,_vF_=1;
      if(! (_vG_ < 1))
       {var i=_vF_;
        for(;;)
         {var val_i=arr[1 + i];
          if(1 - caml_call2(cmp,arr[1 + (i - 1 | 0)],val_i))
           {arr[1 + i] = arr[1 + (i - 1 | 0)];
            var j=[0,i - 1 | 0];
            for(;;)
             {if(1 <= j[1])
               if(! caml_call2(cmp,arr[1 + (j[1] - 1 | 0)],val_i))
                {arr[1 + j[1]] = arr[1 + (j[1] - 1 | 0)];j[1] += -1;continue}
              arr[1 + j[1]] = val_i;
              break}}
          var _vH_=i + 1 | 0;
          if(_vG_ !== i){var i=_vH_;continue}
          break}}
      return 0}
    var Sort=[0,list,array,merge$0];
    caml_register_global(651,Sort,"Sort");
    function to_buffer(buff,ofs,len,v,flags)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(buff) - len | 0) < ofs))
         return runtime.caml_output_value_to_buffer(buff,ofs,len,v,flags);
      return invalid_arg(cst_Marshal_to_buffer_substring_out_of_bounds)}
    var header_size=20;
    function data_size(buff,ofs)
     {if(0 <= ofs)
       if(! ((caml_ml_bytes_length(buff) - 20 | 0) < ofs))
        return caml_marshal_data_size(buff,ofs);
      return invalid_arg(cst_Marshal_data_size)}
    function total_size(buff,ofs){return 20 + data_size(buff,ofs) | 0}
    function from_bytes(buff,ofs)
     {if(0 <= ofs)
       if(! ((caml_ml_bytes_length(buff) - 20 | 0) < ofs))
        {var len=caml_marshal_data_size(buff,ofs);
         return (caml_ml_bytes_length(buff) - (20 + len | 0) | 0) < ofs
                 ?invalid_arg(cst_Marshal_from_bytes$0)
                 :runtime.caml_input_value_from_string(buff,ofs)}
      return invalid_arg(cst_Marshal_from_bytes)}
    function from_string(buff,ofs){return from_bytes(buff,ofs)}
    var
     Marshal=
      [0,
       caml_output_value,
       to_buffer,
       caml_input_value,
       from_bytes,
       from_string,
       header_size,
       data_size,
       total_size];
    caml_register_global(652,Marshal,"Marshal");
    function is_block(a){return 1 - (typeof a === "number"?1:0)}
    var
     double_field=runtime.caml_array_get,
     set_double_field=runtime.caml_array_set;
    function marshal(obj){return runtime.caml_output_value_to_string(obj,0)}
    function unmarshal(str,pos)
     {var _vE_=pos + total_size(str,pos) | 0;
      return [0,from_bytes(str,pos),_vE_]}
    var
     first_non_constant_constructor_tag=0,
     last_non_constant_constructor_tag=245,
     lazy_tag=246,
     closure_tag=247,
     object_tag=248,
     infix_tag=249,
     forward_tag=250,
     no_scan_tag=251,
     abstract_tag=251,
     string_tag=252,
     double_tag=253,
     double_array_tag=254,
     custom_tag=255,
     int_tag=1000,
     out_of_heap_tag=1001,
     unaligned_tag=1002;
    function extension_constructor(x)
     {if(is_block(x))
       if(caml_obj_tag(x) !== 248)
        if(1 <= x.length - 1)var slot=x[1],switch$0=1;else var switch$0=0;
       else
        var switch$0=0;
      else
       var switch$0=0;
      if(! switch$0)var slot=x;
      if(is_block(slot))
       if(caml_obj_tag(slot) === 248)
        var name=slot[1],switch$1=1;
       else
        var switch$1=0;
      else
       var switch$1=0;
      if(! switch$1)var name=invalid_arg(cst_Obj_extension_constructor$0);
      return caml_obj_tag(name) === 252
              ?slot
              :invalid_arg(cst_Obj_extension_constructor)}
    function extension_name(slot){return slot[1]}
    function extension_id(slot){return slot[2]}
    function length$0(x){return x.length - 1 - 2 | 0}
    var _s_=runtime.caml_ephe_blit_data,_t_=runtime.caml_ephe_check_data;
    function _u_(_vD_){return runtime.caml_ephe_unset_data(_vD_)}
    var
     _v_=runtime.caml_ephe_set_data,
     _w_=runtime.caml_ephe_get_data_copy,
     _x_=runtime.caml_ephe_get_data;
    function _y_(_vC_,_vB_,_vA_,_vz_,_vy_)
     {return runtime.caml_ephe_blit_key(_vC_,_vB_,_vA_,_vz_,_vy_)}
    function _z_(_vx_,_vw_){return runtime.caml_ephe_check_key(_vx_,_vw_)}
    var _A_=runtime.caml_ephe_unset_key,_B_=runtime.caml_ephe_set_key;
    function _C_(_vv_,_vu_){return runtime.caml_ephe_get_key_copy(_vv_,_vu_)}
    function _D_(_vt_,_vs_){return runtime.caml_ephe_get_key(_vt_,_vs_)}
    var
     _E_=
      [0,
       function(_vr_){return runtime.caml_ephe_create(_vr_)},
       length$0,
       _D_,
       _C_,
       _B_,
       _A_,
       _z_,
       _y_,
       _x_,
       _w_,
       _v_,
       _u_,
       _t_,
       _s_],
     Obj=
      [0,
       is_block,
       double_field,
       set_double_field,
       first_non_constant_constructor_tag,
       last_non_constant_constructor_tag,
       lazy_tag,
       closure_tag,
       object_tag,
       infix_tag,
       forward_tag,
       no_scan_tag,
       abstract_tag,
       string_tag,
       double_tag,
       double_array_tag,
       custom_tag,
       custom_tag,
       int_tag,
       out_of_heap_tag,
       unaligned_tag,
       extension_constructor,
       extension_name,
       extension_id,
       marshal,
       unmarshal,
       _E_];
    caml_register_global(653,Obj,"Obj");
    var make_float=runtime.caml_make_float_vect,Floatarray=[0];
    function init$2(l,f)
     {if(0 === l)return [0];
      if(0 <= l)
       {var res=caml_make_vect(l,caml_call1(f,0)),_vp_=l - 1 | 0,_vo_=1;
        if(! (_vp_ < 1))
         {var i=_vo_;
          for(;;)
           {res[1 + i] = caml_call1(f,i);
            var _vq_=i + 1 | 0;
            if(_vp_ !== i){var i=_vq_;continue}
            break}}
        return res}
      return invalid_arg(cst_Array_init)}
    function create_matrix(sx,sy,init)
     {var res=caml_make_vect(sx,[0]),_vm_=sx - 1 | 0,_vl_=0;
      if(! (_vm_ < 0))
       {var x=_vl_;
        for(;;)
         {res[1 + x] = caml_make_vect(sy,init);
          var _vn_=x + 1 | 0;
          if(_vm_ !== x){var x=_vn_;continue}
          break}}
      return res}
    function copy$1(a)
     {var l=a.length - 1;return 0 === l?[0]:caml_array_sub(a,0,l)}
    function append$0(a1,a2)
     {var l1=a1.length - 1;
      return 0 === l1
              ?copy$1(a2)
              :0 === a2.length - 1
                ?caml_array_sub(a1,0,l1)
                :runtime.caml_array_append(a1,a2)}
    function sub$1(a,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((a.length - 1 - len | 0) < ofs))
         return caml_array_sub(a,ofs,len);
      return invalid_arg(cst_Array_sub)}
    function fill$0(a,ofs,len,v)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((a.length - 1 - len | 0) < ofs))
         {var _vj_=(ofs + len | 0) - 1 | 0;
          if(! (_vj_ < ofs))
           {var i=ofs;
            for(;;)
             {a[1 + i] = v;
              var _vk_=i + 1 | 0;
              if(_vj_ !== i){var i=_vk_;continue}
              break}}
          return 0}
      return invalid_arg(cst_Array_fill)}
    function blit$1(a1,ofs1,a2,ofs2,len)
     {if(0 <= len)
       if(0 <= ofs1)
        if(! ((a1.length - 1 - len | 0) < ofs1))
         if(0 <= ofs2)
          if(! ((a2.length - 1 - len | 0) < ofs2))
           return runtime.caml_array_blit(a1,ofs1,a2,ofs2,len);
      return invalid_arg(cst_Array_blit)}
    function iter$2(f,a)
     {var _vh_=a.length - 1 - 1 | 0,_vg_=0;
      if(! (_vh_ < 0))
       {var i=_vg_;
        for(;;)
         {caml_call1(f,a[1 + i]);
          var _vi_=i + 1 | 0;
          if(_vh_ !== i){var i=_vi_;continue}
          break}}
      return 0}
    function iter2$0(f,a,b)
     {if(a.length - 1 !== b.length - 1)
       return invalid_arg(cst_Array_iter2_arrays_must_have_the_same_length);
      var _ve_=a.length - 1 - 1 | 0,_vd_=0;
      if(! (_ve_ < 0))
       {var i=_vd_;
        for(;;)
         {caml_call2(f,a[1 + i],b[1 + i]);
          var _vf_=i + 1 | 0;
          if(_ve_ !== i){var i=_vf_;continue}
          break}}
      return 0}
    function map$2(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call1(f,a[1])),_vb_=l - 1 | 0,_va_=1;
      if(! (_vb_ < 1))
       {var i=_va_;
        for(;;)
         {r[1 + i] = caml_call1(f,a[1 + i]);
          var _vc_=i + 1 | 0;
          if(_vb_ !== i){var i=_vc_;continue}
          break}}
      return r}
    function map2$0(f,a,b)
     {var la=a.length - 1,lb=b.length - 1;
      if(la !== lb)
       return invalid_arg(cst_Array_map2_arrays_must_have_the_same_length);
      if(0 === la)return [0];
      var r=caml_make_vect(la,caml_call2(f,a[1],b[1])),_u__=la - 1 | 0,_u9_=1;
      if(! (_u__ < 1))
       {var i=_u9_;
        for(;;)
         {r[1 + i] = caml_call2(f,a[1 + i],b[1 + i]);
          var _u$_=i + 1 | 0;
          if(_u__ !== i){var i=_u$_;continue}
          break}}
      return r}
    function iteri$2(f,a)
     {var _u7_=a.length - 1 - 1 | 0,_u6_=0;
      if(! (_u7_ < 0))
       {var i=_u6_;
        for(;;)
         {caml_call2(f,i,a[1 + i]);
          var _u8_=i + 1 | 0;
          if(_u7_ !== i){var i=_u8_;continue}
          break}}
      return 0}
    function mapi$2(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call2(f,0,a[1])),_u4_=l - 1 | 0,_u3_=1;
      if(! (_u4_ < 1))
       {var i=_u3_;
        for(;;)
         {r[1 + i] = caml_call2(f,i,a[1 + i]);
          var _u5_=i + 1 | 0;
          if(_u4_ !== i){var i=_u5_;continue}
          break}}
      return r}
    function to_list(a)
     {var i$1=a.length - 1 - 1 | 0,i=i$1,res=0;
      for(;;)
       {if(0 <= i)
         {var res$0=[0,a[1 + i],res],i$0=i - 1 | 0,i=i$0,res=res$0;continue}
        return res}}
    function of_list(l)
     {if(l)
       {var tl=l[2],hd=l[1],accu=0,param=l;
        for(;;)
         {if(param)
           {var
             param$0=param[2],
             accu$0=accu + 1 | 0,
             accu=accu$0,
             param=param$0;
            continue}
          var a=caml_make_vect(accu,hd),i=1,param$1=tl;
          for(;;)
           {if(param$1)
             {var tl$0=param$1[2],hd$0=param$1[1];
              a[1 + i] = hd$0;
              var i$0=i + 1 | 0,i=i$0,param$1=tl$0;
              continue}
            return a}}}
      return [0]}
    function fold_left$0(f,x,a)
     {var r=[0,x],_u1_=a.length - 1 - 1 | 0,_u0_=0;
      if(! (_u1_ < 0))
       {var i=_u0_;
        for(;;)
         {r[1] = caml_call2(f,r[1],a[1 + i]);
          var _u2_=i + 1 | 0;
          if(_u1_ !== i){var i=_u2_;continue}
          break}}
      return r[1]}
    function fold_right$0(f,a,x)
     {var r=[0,x],_uY_=a.length - 1 - 1 | 0;
      if(! (_uY_ < 0))
       {var i=_uY_;
        for(;;)
         {r[1] = caml_call2(f,a[1 + i],r[1]);
          var _uZ_=i - 1 | 0;
          if(0 !== i){var i=_uZ_;continue}
          break}}
      return r[1]}
    function exists$0(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(caml_call1(p,a[1 + i]))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function for_all$0(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 1;
        if(caml_call1(p,a[1 + i])){var i$0=i + 1 | 0,i=i$0;continue}
        return 0}}
    function mem$0(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(0 === caml_compare(a[1 + i],x))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function memq$0(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(x === a[1 + i])return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    var Bottom=[248,cst_Array_Bottom,caml_fresh_oo_id(0)];
    function sort(cmp,a)
     {function maxson(l,i)
       {var i31=((i + i | 0) + i | 0) + 1 | 0,x=[0,i31];
        if((i31 + 2 | 0) < l)
         {var _uR_=i31 + 1 | 0,_uS_=caml_check_bound(a,_uR_)[1 + _uR_];
          if(caml_call2(cmp,caml_check_bound(a,i31)[1 + i31],_uS_) < 0)
           x[1] = i31 + 1 | 0;
          var
           _uT_=i31 + 2 | 0,
           _uU_=caml_check_bound(a,_uT_)[1 + _uT_],
           _uV_=x[1];
          if(caml_call2(cmp,caml_check_bound(a,_uV_)[1 + _uV_],_uU_) < 0)
           x[1] = i31 + 2 | 0;
          return x[1]}
        if((i31 + 1 | 0) < l)
         {var _uW_=i31 + 1 | 0,_uX_=caml_check_bound(a,_uW_)[1 + _uW_];
          if(! (0 <= caml_call2(cmp,caml_check_bound(a,i31)[1 + i31],_uX_)))
           return i31 + 1 | 0}
        if(i31 < l)return i31;
        throw [0,Bottom,i]}
      function trickledown(l,i,e)
       {var i$0=i;
        for(;;)
         {var j=maxson(l,i$0);
          if(0 < caml_call2(cmp,caml_check_bound(a,j)[1 + j],e))
           {var _uQ_=caml_check_bound(a,j)[1 + j];
            caml_check_bound(a,i$0)[1 + i$0] = _uQ_;
            var i$0=j;
            continue}
          caml_check_bound(a,i$0)[1 + i$0] = e;
          return 0}}
      function trickle(l,i,e)
       {try
         {var _uP_=trickledown(l,i,e);return _uP_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom)
           {var i$0=exn[2];caml_check_bound(a,i$0)[1 + i$0] = e;return 0}
          throw exn}}
      function bubbledown(l,i)
       {var i$0=i;
        for(;;)
         {var i$1=maxson(l,i$0),_uO_=caml_check_bound(a,i$1)[1 + i$1];
          caml_check_bound(a,i$0)[1 + i$0] = _uO_;
          var i$0=i$1;
          continue}}
      function bubble(l,i)
       {try
         {var _uN_=bubbledown(l,i);return _uN_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom){var i$0=exn[2];return i$0}
          throw exn}}
      var l=a.length - 1,_uF_=((l + 1 | 0) / 3 | 0) - 1 | 0;
      if(! (_uF_ < 0))
       {var i$2=_uF_;
        for(;;)
         {trickle(l,i$2,caml_check_bound(a,i$2)[1 + i$2]);
          var _uM_=i$2 - 1 | 0;
          if(0 !== i$2){var i$2=_uM_;continue}
          break}}
      var _uG_=l - 1 | 0;
      if(! (_uG_ < 2))
       {var i$0=_uG_;
        a:
        for(;;)
         {var
           e$0=caml_check_bound(a,i$0)[1 + i$0],
           _uK_=caml_check_bound(a,0)[1];
          caml_check_bound(a,i$0)[1 + i$0] = _uK_;
          var i$1=bubble(i$0,0),i=i$1;
          for(;;)
           {var father=(i - 1 | 0) / 3 | 0;
            if(i === father)throw [0,Assert_failure,_F_];
            if
             (0 <= caml_call2(cmp,caml_check_bound(a,father)[1 + father],e$0))
             caml_check_bound(a,i)[1 + i] = e$0;
            else
             {var _uE_=caml_check_bound(a,father)[1 + father];
              caml_check_bound(a,i)[1 + i] = _uE_;
              if(0 < father){var i=father;continue}
              caml_check_bound(a,0)[1] = e$0}
            var _uL_=i$0 - 1 | 0;
            if(2 !== i$0){var i$0=_uL_;continue a}
            break}
          break}}
      var _uH_=1 < l?1:0;
      if(_uH_)
       {var e=caml_check_bound(a,1)[2],_uI_=caml_check_bound(a,0)[1];
        caml_check_bound(a,1)[2] = _uI_;
        caml_check_bound(a,0)[1] = e;
        var _uJ_=0}
      else
       var _uJ_=_uH_;
      return _uJ_}
    function fast_sort$0(cmp,a)
     {function merge(src1ofs,src1len,src2,src2ofs,src2len,dst,dstofs)
       {var
         src1r=src1ofs + src1len | 0,
         src2r=src2ofs + src2len | 0,
         s2$1=caml_check_bound(src2,src2ofs)[1 + src2ofs],
         s1$1=caml_check_bound(a,src1ofs)[1 + src1ofs],
         i1=src1ofs,
         s1=s1$1,
         i2=src2ofs,
         s2=s2$1,
         d=dstofs;
        for(;;)
         {if(0 < caml_call2(cmp,s1,s2))
           {caml_check_bound(dst,d)[1 + d] = s2;
            var i2$0=i2 + 1 | 0;
            if(i2$0 < src2r)
             {var
               d$0=d + 1 | 0,
               s2$0=caml_check_bound(src2,i2$0)[1 + i2$0],
               i2=i2$0,
               s2=s2$0,
               d=d$0;
              continue}
            return blit$1(a,i1,dst,d + 1 | 0,src1r - i1 | 0)}
          caml_check_bound(dst,d)[1 + d] = s1;
          var i1$0=i1 + 1 | 0;
          if(i1$0 < src1r)
           {var
             d$1=d + 1 | 0,
             s1$0=caml_check_bound(a,i1$0)[1 + i1$0],
             i1=i1$0,
             s1=s1$0,
             d=d$1;
            continue}
          return blit$1(src2,i2,dst,d + 1 | 0,src2r - i2 | 0)}}
      function isortto(srcofs,dst,dstofs,len)
       {var _uw_=len - 1 | 0,_uv_=0;
        if(! (_uw_ < 0))
         {var i=_uv_;
          a:
          for(;;)
           {var
             _ux_=srcofs + i | 0,
             e=caml_check_bound(a,_ux_)[1 + _ux_],
             j=[0,(dstofs + i | 0) - 1 | 0];
            for(;;)
             {if(dstofs <= j[1])
               {var _uy_=j[1];
                if(0 < caml_call2(cmp,caml_check_bound(dst,_uy_)[1 + _uy_],e))
                 {var
                   _uz_=j[1],
                   _uA_=caml_check_bound(dst,_uz_)[1 + _uz_],
                   _uB_=j[1] + 1 | 0;
                  caml_check_bound(dst,_uB_)[1 + _uB_] = _uA_;
                  j[1] += -1;
                  continue}}
              var _uC_=j[1] + 1 | 0;
              caml_check_bound(dst,_uC_)[1 + _uC_] = e;
              var _uD_=i + 1 | 0;
              if(_uw_ !== i){var i=_uD_;continue a}
              break}
            break}}
        return 0}
      function sortto(srcofs,dst,dstofs,len)
       {if(len <= 5)return isortto(srcofs,dst,dstofs,len);
        var l1=len / 2 | 0,l2=len - l1 | 0;
        sortto(srcofs + l1 | 0,dst,dstofs + l1 | 0,l2);
        sortto(srcofs,a,srcofs + l2 | 0,l1);
        return merge(srcofs + l2 | 0,l1,dst,dstofs + l1 | 0,l2,dst,dstofs)}
      var l=a.length - 1;
      if(l <= 5)return isortto(0,a,0,l);
      var
       l1=l / 2 | 0,
       l2=l - l1 | 0,
       t=caml_make_vect(l2,caml_check_bound(a,0)[1]);
      sortto(l1,t,0,l2);
      sortto(0,a,l2,l1);
      return merge(l2,l1,t,0,l2,a,0)}
    var
     concat$1=caml_array_concat,
     include$2=
      [0,
       make_float,
       init$2,
       create_matrix,
       create_matrix,
       append$0,
       concat$1,
       sub$1,
       copy$1,
       fill$0,
       blit$1,
       to_list,
       of_list,
       iter$2,
       iteri$2,
       map$2,
       mapi$2,
       fold_left$0,
       fold_right$0,
       iter2$0,
       map2$0,
       for_all$0,
       exists$0,
       mem$0,
       memq$0,
       sort,
       fast_sort$0,
       fast_sort$0,
       Floatarray];
    caml_register_global(654,include$2,"Array");
    var zero=0,one=1,minus_one=-1;
    function succ$0(n){return n + 1 | 0}
    function pred$0(n){return n - 1 | 0}
    function abs$0(n){return caml_greaterequal(n,0)?n:- n | 0}
    var min_int$0=-2147483648,max_int$0=2147483647;
    function lognot(n){return n ^ -1}
    function to_string$0(n){return caml_format_int(cst_d,n)}
    function of_string_opt(s)
     {try
       {var _ut_=[0,caml_int_of_string(s)];return _ut_}
      catch(_uu_)
       {_uu_ = caml_wrap_exception(_uu_);
        if(_uu_[1] === Failure)return 0;
        throw _uu_}}
    var compare$3=caml_int_compare;
    function equal$3(x,y){return 0 === caml_int_compare(x,y)?1:0}
    var
     Int32=
      [0,
       zero,
       one,
       minus_one,
       succ$0,
       pred$0,
       abs$0,
       max_int$0,
       min_int$0,
       lognot,
       of_string_opt,
       to_string$0,
       compare$3,
       equal$3];
    caml_register_global(655,Int32,"Int32");
    function succ$1(n){return caml_int64_add(n,_G_)}
    function pred$1(n){return caml_int64_sub(n,_H_)}
    function abs$1(n)
     {return caml_greaterequal(n,_I_)?n:runtime.caml_int64_neg(n)}
    function lognot$0(n){return runtime.caml_int64_xor(n,_J_)}
    function to_string$1(n){return caml_int64_format(cst_d$0,n)}
    function of_string_opt$0(s)
     {try
       {var _ur_=[0,caml_int64_of_string(s)];return _ur_}
      catch(_us_)
       {_us_ = caml_wrap_exception(_us_);
        if(_us_[1] === Failure)return 0;
        throw _us_}}
    var compare$4=caml_int64_compare;
    function equal$4(x,y){return 0 === caml_int64_compare(x,y)?1:0}
    var
     Int64=
      [0,
       zero$0,
       one$0,
       minus_one$0,
       succ$1,
       pred$1,
       abs$1,
       max_int$1,
       min_int$1,
       lognot$0,
       of_string_opt$0,
       to_string$1,
       compare$4,
       equal$4];
    caml_register_global(656,Int64,"Int64");
    var zero$1=0,one$1=1,minus_one$1=-1;
    function succ$2(n){return n + 1 | 0}
    function pred$2(n){return n - 1 | 0}
    function abs$2(n){return caml_greaterequal(n,0)?n:- n | 0}
    var min_int$2=-2147483648,max_int$2=2147483647;
    function lognot$1(n){return n ^ -1}
    function to_string$2(n){return caml_format_int(cst_d$1,n)}
    function of_string_opt$1(s)
     {try
       {var _up_=[0,caml_int_of_string(s)];return _up_}
      catch(_uq_)
       {_uq_ = caml_wrap_exception(_uq_);
        if(_uq_[1] === Failure)return 0;
        throw _uq_}}
    var compare$5=caml_int_compare;
    function equal$5(x,y){return 0 === caml_int_compare(x,y)?1:0}
    var
     Nativeint=
      [0,
       zero$1,
       one$1,
       minus_one$1,
       succ$2,
       pred$2,
       abs$2,
       size,
       max_int$2,
       min_int$2,
       lognot$1,
       of_string_opt$1,
       to_string$2,
       compare$5,
       equal$5];
    caml_register_global(657,Nativeint,"Nativeint");
    function engine(tbl,state,buf)
     {var result=runtime.caml_lex_engine(tbl,state,buf);
      if(0 <= result)
       {buf[11] = buf[12];
        var _uo_=buf[12];
        buf[12] = [0,_uo_[1],_uo_[2],_uo_[3],buf[4] + buf[6] | 0]}
      return result}
    function new_engine(tbl,state,buf)
     {var result=runtime.caml_new_lex_engine(tbl,state,buf);
      if(0 <= result)
       {buf[11] = buf[12];
        var _un_=buf[12];
        buf[12] = [0,_un_[1],_un_[2],_un_[3],buf[4] + buf[6] | 0]}
      return result}
    function from_function(f)
     {var
       aux_buffer=caml_create_bytes(512),
       _ub_=[0],
       _uc_=0,
       _ud_=0,
       _ue_=0,
       _uf_=0,
       _ug_=0,
       _uh_=0,
       _ui_=0,
       _uj_=caml_create_bytes(1024);
      return [0,
              function(lexbuf)
               {var
                 read=
                  caml_call2(f,aux_buffer,caml_ml_bytes_length(aux_buffer)),
                 n=0 < read?read:(lexbuf[9] = 1,0);
                if(caml_ml_bytes_length(lexbuf[2]) < (lexbuf[3] + n | 0))
                 {if
                   (((lexbuf[3] - lexbuf[5] | 0) + n | 0)
                    <=
                    caml_ml_bytes_length(lexbuf[2]))
                   blit
                    (lexbuf[2],lexbuf[5],lexbuf[2],0,lexbuf[3] - lexbuf[5] | 0);
                  else
                   {var
                     newlen=
                      min
                       (2 * caml_ml_bytes_length(lexbuf[2]) | 0,max_string_length);
                    if(newlen < ((lexbuf[3] - lexbuf[5] | 0) + n | 0))
                     failwith(cst_Lexing_lex_refill_cannot_grow_buffer);
                    var newbuf=caml_create_bytes(newlen);
                    blit(lexbuf[2],lexbuf[5],newbuf,0,lexbuf[3] - lexbuf[5] | 0);
                    lexbuf[2] = newbuf}
                  var s=lexbuf[5];
                  lexbuf[4] = lexbuf[4] + s | 0;
                  lexbuf[6] = lexbuf[6] - s | 0;
                  lexbuf[5] = 0;
                  lexbuf[7] = lexbuf[7] - s | 0;
                  lexbuf[3] = lexbuf[3] - s | 0;
                  var t=lexbuf[10],_ul_=t.length - 1 - 1 | 0,_uk_=0;
                  if(! (_ul_ < 0))
                   {var i=_uk_;
                    for(;;)
                     {var v=caml_check_bound(t,i)[1 + i];
                      if(0 <= v)caml_check_bound(t,i)[1 + i] = v - s | 0;
                      var _um_=i + 1 | 0;
                      if(_ul_ !== i){var i=_um_;continue}
                      break}}}
                blit(aux_buffer,0,lexbuf[2],lexbuf[3],n);
                lexbuf[3] = lexbuf[3] + n | 0;
                return 0},
              _uj_,
              _ui_,
              _uh_,
              _ug_,
              _uf_,
              _ue_,
              _ud_,
              _uc_,
              _ub_,
              zero_pos,
              zero_pos]}
    function from_channel(ic)
     {return from_function(function(buf,n){return input(ic,buf,0,n)})}
    function from_string$0(s)
     {var
       _t4_=[0],
       _t5_=1,
       _t6_=0,
       _t7_=0,
       _t8_=0,
       _t9_=0,
       _t__=0,
       _t$_=caml_ml_string_length(s),
       _ua_=of_string(s);
      return [0,
              function(lexbuf){lexbuf[9] = 1;return 0},
              _ua_,
              _t$_,
              _t__,
              _t9_,
              _t8_,
              _t7_,
              _t6_,
              _t5_,
              _t4_,
              zero_pos,
              zero_pos]}
    function lexeme(lexbuf)
     {var len=lexbuf[6] - lexbuf[5] | 0;
      return sub_string(lexbuf[2],lexbuf[5],len)}
    function sub_lexeme(lexbuf,i1,i2)
     {var len=i2 - i1 | 0;return sub_string(lexbuf[2],i1,len)}
    function sub_lexeme_opt(lexbuf,i1,i2)
     {if(0 <= i1){var len=i2 - i1 | 0;return [0,sub_string(lexbuf[2],i1,len)]}
      return 0}
    function sub_lexeme_char(lexbuf,i){return caml_bytes_get(lexbuf[2],i)}
    function sub_lexeme_char_opt(lexbuf,i)
     {return 0 <= i?[0,caml_bytes_get(lexbuf[2],i)]:0}
    function lexeme_char(lexbuf,i)
     {return caml_bytes_get(lexbuf[2],lexbuf[5] + i | 0)}
    function lexeme_start(lexbuf){return lexbuf[11][4]}
    function lexeme_end(lexbuf){return lexbuf[12][4]}
    function lexeme_start_p(lexbuf){return lexbuf[11]}
    function lexeme_end_p(lexbuf){return lexbuf[12]}
    function new_line(lexbuf)
     {var lcp=lexbuf[12];
      lexbuf[12] = [0,lcp[1],lcp[2] + 1 | 0,lcp[4],lcp[4]];
      return 0}
    function flush_input(lb)
     {lb[6] = 0;
      lb[4] = 0;
      var _t3_=lb[12];
      lb[12] = [0,_t3_[1],_t3_[2],_t3_[3],0];
      lb[3] = 0;
      return 0}
    var
     Lexing=
      [0,
       dummy_pos,
       from_channel,
       from_string$0,
       from_function,
       lexeme,
       lexeme_char,
       lexeme_start,
       lexeme_end,
       lexeme_start_p,
       lexeme_end_p,
       new_line,
       flush_input,
       sub_lexeme,
       sub_lexeme_opt,
       sub_lexeme_char,
       sub_lexeme_char_opt,
       engine,
       new_engine];
    caml_register_global(658,Lexing,"Lexing");
    var
     YYexit=[248,cst_Parsing_YYexit,caml_fresh_oo_id(0)],
     Parse_error=[248,cst_Parsing_Parse_error,caml_fresh_oo_id(0)],
     env=
      [0,
       caml_make_vect(100,0),
       caml_make_vect(100,0),
       caml_make_vect(100,dummy_pos),
       caml_make_vect(100,dummy_pos),
       100,
       0,
       0,
       0,
       dummy_pos,
       dummy_pos,
       0,
       0,
       0,
       0,
       0,
       0];
    function grow_stacks(param)
     {var
       oldsize=env[5],
       newsize=oldsize * 2 | 0,
       new_s=caml_make_vect(newsize,0),
       new_v=caml_make_vect(newsize,0),
       new_start=caml_make_vect(newsize,dummy_pos),
       new_end=caml_make_vect(newsize,dummy_pos);
      blit$1(env[1],0,new_s,0,oldsize);
      env[1] = new_s;
      blit$1(env[2],0,new_v,0,oldsize);
      env[2] = new_v;
      blit$1(env[3],0,new_start,0,oldsize);
      env[3] = new_start;
      blit$1(env[4],0,new_end,0,oldsize);
      env[4] = new_end;
      env[5] = newsize;
      return 0}
    function clear_parser(param)
     {fill$0(env[2],0,env[5],0);env[8] = 0;return 0}
    var current_lookahead_fun=[0,function(param){return 0}];
    function yyparse(tables,start,lexer,lexbuf)
     {var
       init_asp=env[11],
       init_sp=env[14],
       init_stackbase=env[6],
       init_state=env[15],
       init_curr_char=env[7],
       init_lval=env[8],
       init_errflag=env[16];
      env[6] = env[14] + 1 | 0;
      env[7] = start;
      env[10] = lexbuf[12];
      try
       {var cmd=0,arg=0;
        for(;;)
         {var match=runtime.caml_parse_engine(tables,env,cmd,arg);
          switch(match)
           {case 0:
             var arg$0=caml_call1(lexer,lexbuf);
             env[9] = lexbuf[11];
             env[10] = lexbuf[12];
             var cmd=1,arg=arg$0;
             continue;
            case 1:throw Parse_error;
            case 2:grow_stacks(0);var cmd=2,arg=0;continue;
            case 3:grow_stacks(0);var cmd=3,arg=0;continue;
            case 4:
             try
              {var
                _tX_=env[13],
                _tY_=
                 caml_call1(caml_check_bound(tables[1],_tX_)[1 + _tX_],env),
                _tZ_=4,
                cmd$0=_tZ_,
                arg$1=_tY_}
             catch(_t2_)
              {_t2_ = caml_wrap_exception(_t2_);
               if(_t2_ !== Parse_error)throw _t2_;
               var cmd$0=5,arg$1=0,_t0_=_t2_}
             var cmd=cmd$0,arg=arg$1;
             continue;
            default:
             caml_call1(tables[14],cst_syntax_error);var cmd=5,arg=0;continue}}}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        var curr_char=env[7];
        env[11] = init_asp;
        env[14] = init_sp;
        env[6] = init_stackbase;
        env[15] = init_state;
        env[7] = init_curr_char;
        env[8] = init_lval;
        env[16] = init_errflag;
        if(exn[1] === YYexit){var v=exn[2];return v}
        current_lookahead_fun[1]
        =
        function(tok)
         {if(is_block(tok))
           {var _t1_=caml_obj_tag(tok);
            return caml_check_bound(tables[3],_t1_)[1 + _t1_] === curr_char
                    ?1
                    :0}
          return caml_check_bound(tables[2],tok)[1 + tok] === curr_char?1:0};
        throw exn}}
    function peek_val(env,n)
     {var _tW_=env[11] - n | 0;return caml_check_bound(env[2],_tW_)[1 + _tW_]}
    function symbol_start_pos(param)
     {var i=env[12];
      for(;;)
       {if(0 < i)
         {var
           _tT_=(env[11] - i | 0) + 1 | 0,
           st=caml_check_bound(env[3],_tT_)[1 + _tT_],
           _tU_=(env[11] - i | 0) + 1 | 0,
           en=caml_check_bound(env[4],_tU_)[1 + _tU_];
          if(caml_notequal(st,en))return st;
          var i$0=i - 1 | 0,i=i$0;
          continue}
        var _tV_=env[11];
        return caml_check_bound(env[4],_tV_)[1 + _tV_]}}
    function symbol_end_pos(param)
     {var _tS_=env[11];return caml_check_bound(env[4],_tS_)[1 + _tS_]}
    function rhs_start_pos(n)
     {var _tR_=env[11] - (env[12] - n | 0) | 0;
      return caml_check_bound(env[3],_tR_)[1 + _tR_]}
    function rhs_end_pos(n)
     {var _tQ_=env[11] - (env[12] - n | 0) | 0;
      return caml_check_bound(env[4],_tQ_)[1 + _tQ_]}
    function symbol_start(param){return symbol_start_pos(0)[4]}
    function symbol_end(param){return symbol_end_pos(0)[4]}
    function rhs_start(n){return rhs_start_pos(n)[4]}
    function rhs_end(n){return rhs_end_pos(n)[4]}
    function is_current_lookahead(tok)
     {return caml_call1(current_lookahead_fun[1],tok)}
    function parse_error(param){return 0}
    var
     Parsing=
      [0,
       symbol_start,
       symbol_end,
       rhs_start,
       rhs_end,
       symbol_start_pos,
       symbol_end_pos,
       rhs_start_pos,
       rhs_end_pos,
       clear_parser,
       Parse_error,
       function(_tP_){return runtime.caml_set_parser_trace(_tP_)},
       YYexit,
       yyparse,
       peek_val,
       is_current_lookahead,
       parse_error];
    caml_register_global(659,Parsing,"Parsing");
    var
     Set=
      [0,
       function(Ord)
        {function height(param){if(param){var h=param[4];return h}return 0}
         function create(l,v,r)
          {if(l)var h=l[4],hl=h;else var hl=0;
           if(r)var h$0=r[4],hr=h$0;else var hr=0;
           var _tO_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,v,r,_tO_]}
         function bal(l,v,r)
          {if(l)var h=l[4],hl=h;else var hl=0;
           if(r)var h$0=r[4],hr=h$0;else var hr=0;
           if((hr + 2 | 0) < hl)
            {if(l)
              {var lr=l[3],lv=l[2],ll=l[1],_tJ_=height(lr);
               if(_tJ_ <= height(ll))return create(ll,lv,create(lr,v,r));
               if(lr)
                {var lrr=lr[3],lrv=lr[2],lrl=lr[1],_tK_=create(lrr,v,r);
                 return create(create(ll,lv,lrl),lrv,_tK_)}
               return invalid_arg(cst_Set_bal)}
             return invalid_arg(cst_Set_bal$0)}
           if((hl + 2 | 0) < hr)
            {if(r)
              {var rr=r[3],rv=r[2],rl=r[1],_tL_=height(rl);
               if(_tL_ <= height(rr))return create(create(l,v,rl),rv,rr);
               if(rl)
                {var rlr=rl[3],rlv=rl[2],rll=rl[1],_tM_=create(rlr,rv,rr);
                 return create(create(l,v,rll),rlv,_tM_)}
               return invalid_arg(cst_Set_bal$1)}
             return invalid_arg(cst_Set_bal$2)}
           var _tN_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,v,r,_tN_]}
         function add(x,t)
          {if(t)
            {var r=t[3],v=t[2],l=t[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return t;
             if(0 <= c){var rr=add(x,r);return r === rr?t:bal(l,v,rr)}
             var ll=add(x,l);
             return l === ll?t:bal(ll,v,r)}
           return [0,0,x,0,1]}
         function singleton(x){return [0,0,x,0,1]}
         function add_min_element(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1];
             return bal(add_min_element(x,l),v,r)}
           return singleton(x)}
         function add_max_element(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1];
             return bal(l,v,add_max_element(x,r))}
           return singleton(x)}
         function join(l,v,r)
          {if(l)
            {if(r)
              {var
                rh=r[4],
                rr=r[3],
                rv=r[2],
                rl=r[1],
                lh=l[4],
                lr=l[3],
                lv=l[2],
                ll=l[1];
               return (rh + 2 | 0) < lh
                       ?bal(ll,lv,join(lr,v,r))
                       :(lh + 2 | 0) < rh?bal(join(l,v,rl),rv,rr):create(l,v,r)}
             return add_max_element(v,l)}
           return add_min_element(v,r)}
         function min_elt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _tI_=param$0[1];
               if(_tI_){var param$0=_tI_;continue}
               var v=param$0[2];
               return v}
             throw Not_found}}
         function min_elt_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _tH_=param$0[1];
               if(_tH_){var param$0=_tH_;continue}
               var v=param$0[2];
               return [0,v]}
             return 0}}
         function max_elt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _tF_=param$0[3],_tG_=param$0[2];
               if(_tF_){var param$0=_tF_;continue}
               return _tG_}
             throw Not_found}}
         function max_elt_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _tD_=param$0[3],_tE_=param$0[2];
               if(_tD_){var param$0=_tD_;continue}
               return [0,_tE_]}
             return 0}}
         function remove_min_elt(param)
          {if(param)
            {var _tC_=param[1];
             if(_tC_)
              {var r=param[3],v=param[2];return bal(remove_min_elt(_tC_),v,r)}
             var r$0=param[3];
             return r$0}
           return invalid_arg(cst_Set_remove_min_elt)}
         function concat(t,match)
          {if(t)
            {if(match)
              {var _tB_=remove_min_elt(match);
               return join(t,min_elt(match),_tB_)}
             return t}
           return match}
         function split(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return [0,l,1,r];
             if(0 <= c)
              {var match=split(x,r),rr=match[3],pres=match[2],lr=match[1];
               return [0,join(l,v,lr),pres,rr]}
             var
              match$0=split(x,l),
              rl=match$0[3],
              pres$0=match$0[2],
              ll=match$0[1];
             return [0,ll,pres$0,join(rl,v,r)]}
           return _K_}
         var empty=0;
         function is_empty(param){return param?0:1}
         function mem(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v),
                _tA_=0 === c?1:0;
               if(_tA_)return _tA_;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function remove(x,t)
          {if(t)
            {var r=t[3],v=t[2],l=t[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)
              {if(l)
                {if(r)
                  {var _tz_=remove_min_elt(r);return bal(l,min_elt(r),_tz_)}
                 return l}
               return r}
             if(0 <= c){var rr=remove(x,r);return r === rr?t:bal(l,v,rr)}
             var ll=remove(x,l);
             return l === ll?t:bal(ll,v,r)}
           return 0}
         function union(t1,match)
          {if(t1)
            {if(match)
              {var
                h2=match[4],
                r2=match[3],
                v2=match[2],
                l2=match[1],
                h1=t1[4],
                r1=t1[3],
                v1=t1[2],
                l1=t1[1];
               if(h2 <= h1)
                {if(1 === h2)return add(v2,t1);
                 var
                  match$0=split(v1,match),
                  r2$0=match$0[3],
                  l2$0=match$0[1],
                  _tx_=union(r1,r2$0);
                 return join(union(l1,l2$0),v1,_tx_)}
               if(1 === h1)return add(v1,match);
               var
                match$1=split(v2,t1),
                r1$0=match$1[3],
                l1$0=match$1[1],
                _ty_=union(r1$0,r2);
               return join(union(l1$0,l2),v2,_ty_)}
             return t1}
           return match}
         function inter(s1,match)
          {if(s1)
            {if(match)
              {var
                r1=s1[3],
                v1=s1[2],
                l1=s1[1],
                _tt_=split(v1,match),
                _tu_=_tt_[1];
               if(0 === _tt_[2])
                {var r2=_tt_[3],_tv_=inter(r1,r2);
                 return concat(inter(l1,_tu_),_tv_)}
               var r2$0=_tt_[3],_tw_=inter(r1,r2$0);
               return join(inter(l1,_tu_),v1,_tw_)}
             return 0}
           return 0}
         function diff(t1,match)
          {if(t1)
            {if(match)
              {var
                r1=t1[3],
                v1=t1[2],
                l1=t1[1],
                _tp_=split(v1,match),
                _tq_=_tp_[1];
               if(0 === _tp_[2])
                {var r2=_tp_[3],_tr_=diff(r1,r2);
                 return join(diff(l1,_tq_),v1,_tr_)}
               var r2$0=_tp_[3],_ts_=diff(r1,r2$0);
               return concat(diff(l1,_tq_),_ts_)}
             return t1}
           return 0}
         function cons_enum(s,e)
          {var s$0=s,e$0=e;
           for(;;)
            {if(s$0)
              {var
                r=s$0[3],
                v=s$0[2],
                s$1=s$0[1],
                e$1=[0,v,r,e$0],
                s$0=s$1,
                e$0=e$1;
               continue}
             return e$0}}
         function compare(s1,s2)
          {var e2$2=cons_enum(s2,0),e1$2=cons_enum(s1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[3],
                  r2=e2[2],
                  v2=e2[1],
                  e1$0=e1[3],
                  r1=e1[2],
                  v1=e1[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var
                    e2$1=cons_enum(r2,e2$0),
                    e1$1=cons_enum(r1,e1$0),
                    e1=e1$1,
                    e2=e2$1;
                   continue}
                 return c}
               return 1}
             return e2?-1:0}}
         function equal(s1,s2){return 0 === compare(s1,s2)?1:0}
         function subset(s1,s2)
          {var s1$0=s1,s2$0=s2;
           for(;;)
            {if(s1$0)
              {if(s2$0)
                {var
                  r2=s2$0[3],
                  v2=s2$0[2],
                  l2=s2$0[1],
                  r1=s1$0[3],
                  v1=s1$0[2],
                  l1=s1$0[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var _tm_=subset(l1,l2);
                   if(_tm_){var s1$0=r1,s2$0=r2;continue}
                   return _tm_}
                 if(0 <= c)
                  {var _tn_=subset([0,0,v1,r1,0],r2);
                   if(_tn_){var s1$0=l1;continue}
                   return _tn_}
                 var _to_=subset([0,l1,v1,0,0],l2);
                 if(_to_){var s1$0=r1;continue}
                 return _to_}
               return 0}
             return 1}}
         function iter(f,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var r=param$0[3],v=param$0[2],l=param$0[1];
               iter(f,l);
               caml_call1(f,v);
               var param$0=r;
               continue}
             return 0}}
         function fold(f,s,accu)
          {var s$0=s,accu$0=accu;
           for(;;)
            {if(s$0)
              {var
                r=s$0[3],
                v=s$0[2],
                l=s$0[1],
                accu$1=caml_call2(f,v,fold(f,l,accu$0)),
                s$0=r,
                accu$0=accu$1;
               continue}
             return accu$0}}
         function for_all(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _tj_=caml_call1(p,v);
               if(_tj_)
                {var _tk_=for_all(p,l);
                 if(_tk_){var param$0=r;continue}
                 var _tl_=_tk_}
               else
                var _tl_=_tj_;
               return _tl_}
             return 1}}
         function exists(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _tg_=caml_call1(p,v);
               if(_tg_)
                var _th_=_tg_;
               else
                {var _ti_=exists(p,l);
                 if(! _ti_){var param$0=r;continue}
                 var _th_=_ti_}
               return _th_}
             return 0}}
         function filter(p,t)
          {if(t)
            {var
              r=t[3],
              v=t[2],
              l=t[1],
              l$0=filter(p,l),
              pv=caml_call1(p,v),
              r$0=filter(p,r);
             if(pv){if(l === l$0)if(r === r$0)return t;return join(l$0,v,r$0)}
             return concat(l$0,r$0)}
           return 0}
         function partition(p,param)
          {if(param)
            {var
              r=param[3],
              v=param[2],
              l=param[1],
              match=partition(p,l),
              lf=match[2],
              lt=match[1],
              pv=caml_call1(p,v),
              match$0=partition(p,r),
              rf=match$0[2],
              rt=match$0[1];
             if(pv){var _te_=concat(lf,rf);return [0,join(lt,v,rt),_te_]}
             var _tf_=join(lf,v,rf);
             return [0,concat(lt,rt),_tf_]}
           return _L_}
         function cardinal(param)
          {if(param)
            {var r=param[3],l=param[1],_td_=cardinal(r);
             return (cardinal(l) + 1 | 0) + _td_ | 0}
           return 0}
         function elements_aux(accu,param)
          {var accu$0=accu,param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                accu$1=[0,v,elements_aux(accu$0,r)],
                accu$0=accu$1,
                param$0=l;
               continue}
             return accu$0}}
         function elements(s){return elements_aux(0,s)}
         function find(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return v;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             throw Not_found}}
         function find_first(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=l;continue}
                     var param=r;
                     continue}
                   return v0}}
               var param$1=r$0;
               continue}
             throw Not_found}}
         function find_first_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=l;continue}
                     var param=r;
                     continue}
                   return [0,v0]}}
               var param$1=r$0;
               continue}
             return 0}}
         function find_last(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=r;continue}
                     var param=l;
                     continue}
                   return v0}}
               var param$1=l$0;
               continue}
             throw Not_found}}
         function find_last_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=r;continue}
                     var param=l;
                     continue}
                   return [0,v0]}}
               var param$1=l$0;
               continue}
             return 0}}
         function find_opt(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return [0,v];
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function map(f,t)
          {if(t)
            {var
              r=t[3],
              v=t[2],
              l=t[1],
              l$0=map(f,l),
              v$0=caml_call1(f,v),
              r$0=map(f,r);
             if(l === l$0)if(v === v$0)if(r === r$0)return t;
             if(0 === l$0)
              var switch$0=0;
             else
              var
               _tc_=max_elt(l$0),
               switch$0=0 <= caml_call2(Ord[1],_tc_,v$0)?1:0;
             if(! switch$0)
              {if(0 === r$0)
                var switch$1=0;
               else
                var
                 _tb_=min_elt(r$0),
                 switch$1=0 <= caml_call2(Ord[1],v$0,_tb_)?1:0;
               if(! switch$1)return join(l$0,v$0,r$0)}
             return union(l$0,add(v$0,r$0))}
           return 0}
         function of_list(l)
          {if(l)
            {var _s2_=l[2],_s3_=l[1];
             if(_s2_)
              {var _s4_=_s2_[2],_s5_=_s2_[1];
               if(_s4_)
                {var _s6_=_s4_[2],_s7_=_s4_[1];
                 if(_s6_)
                  {var _s8_=_s6_[2],_s9_=_s6_[1];
                   if(_s8_)
                    {if(_s8_[2])
                      {var
                        l$0=sort_uniq(Ord[1],l),
                        sub=
                         function(n,l)
                          {if(! (3 < n >>> 0))
                            switch(n)
                             {case 0:return [0,0,l];
                              case 1:
                               if(l){var l$3=l[2],x0=l[1];return [0,[0,0,x0,0,1],l$3]}
                               break;
                              case 2:
                               if(l)
                                {var _s__=l[2];
                                 if(_s__)
                                  {var l$4=_s__[2],x1=_s__[1],x0$0=l[1];
                                   return [0,[0,[0,0,x0$0,0,1],x1,0,2],l$4]}}
                               break;
                              default:
                               if(l)
                                {var _s$_=l[2];
                                 if(_s$_)
                                  {var _ta_=_s$_[2];
                                   if(_ta_)
                                    {var l$5=_ta_[2],x2=_ta_[1],x1$0=_s$_[1],x0$1=l[1];
                                     return [0,[0,[0,0,x0$1,0,1],x1$0,[0,0,x2,0,1],2],l$5]}}}}
                           var nl=n / 2 | 0,match=sub(nl,l),l$0=match[2],left=match[1];
                           if(l$0)
                            {var
                              l$1=l$0[2],
                              mid=l$0[1],
                              match$0=sub((n - nl | 0) - 1 | 0,l$1),
                              l$2=match$0[2],
                              right=match$0[1];
                             return [0,create(left,mid,right),l$2]}
                           throw [0,Assert_failure,_M_]};
                       return sub(length(l$0),l$0)[1]}
                     var x4=_s8_[1];
                     return add(x4,add(_s9_,add(_s7_,add(_s5_,singleton(_s3_)))))}
                   return add(_s9_,add(_s7_,add(_s5_,singleton(_s3_))))}
                 return add(_s7_,add(_s5_,singleton(_s3_)))}
               return add(_s5_,singleton(_s3_))}
             return singleton(_s3_)}
           return empty}
         return [0,
                 empty,
                 is_empty,
                 mem,
                 add,
                 singleton,
                 remove,
                 union,
                 inter,
                 diff,
                 compare,
                 equal,
                 subset,
                 iter,
                 map,
                 fold,
                 for_all,
                 exists,
                 filter,
                 partition,
                 cardinal,
                 elements,
                 min_elt,
                 min_elt_opt,
                 max_elt,
                 max_elt_opt,
                 min_elt,
                 min_elt_opt,
                 split,
                 find,
                 find_opt,
                 find_first,
                 find_first_opt,
                 find_last,
                 find_last_opt,
                 of_list]}];
    caml_register_global(660,Set,"Set");
    var
     Map=
      [0,
       function(Ord)
        {function height(param){if(param){var h=param[5];return h}return 0}
         function create(l,x,d,r)
          {var hl=height(l),hr=height(r),_s1_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,x,d,r,_s1_]}
         function singleton(x,d){return [0,0,x,d,0,1]}
         function bal(l,x,d,r)
          {if(l)var h=l[5],hl=h;else var hl=0;
           if(r)var h$0=r[5],hr=h$0;else var hr=0;
           if((hr + 2 | 0) < hl)
            {if(l)
              {var lr=l[4],ld=l[3],lv=l[2],ll=l[1],_sW_=height(lr);
               if(_sW_ <= height(ll))return create(ll,lv,ld,create(lr,x,d,r));
               if(lr)
                {var
                  lrr=lr[4],
                  lrd=lr[3],
                  lrv=lr[2],
                  lrl=lr[1],
                  _sX_=create(lrr,x,d,r);
                 return create(create(ll,lv,ld,lrl),lrv,lrd,_sX_)}
               return invalid_arg(cst_Map_bal)}
             return invalid_arg(cst_Map_bal$0)}
           if((hl + 2 | 0) < hr)
            {if(r)
              {var rr=r[4],rd=r[3],rv=r[2],rl=r[1],_sY_=height(rl);
               if(_sY_ <= height(rr))return create(create(l,x,d,rl),rv,rd,rr);
               if(rl)
                {var
                  rlr=rl[4],
                  rld=rl[3],
                  rlv=rl[2],
                  rll=rl[1],
                  _sZ_=create(rlr,rv,rd,rr);
                 return create(create(l,x,d,rll),rlv,rld,_sZ_)}
               return invalid_arg(cst_Map_bal$1)}
             return invalid_arg(cst_Map_bal$2)}
           var _s0_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,x,d,r,_s0_]}
         var empty=0;
         function is_empty(param){return param?0:1}
         function add(x,data,m)
          {if(m)
            {var h=m[5],r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return d === data?m:[0,l,x,data,r,h];
             if(0 <= c){var rr=add(x,data,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=add(x,data,l);
             return l === ll?m:bal(ll,v,d,r)}
           return [0,0,x,data,0,1]}
         function find(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return d;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             throw Not_found}}
         function find_first(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=l;continue}
                     var param=r;
                     continue}
                   return [0,v0,d0]}}
               var param$1=r$0;
               continue}
             throw Not_found}}
         function find_first_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=l;continue}
                     var param=r;
                     continue}
                   return [0,[0,v0,d0]]}}
               var param$1=r$0;
               continue}
             return 0}}
         function find_last(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=r;continue}
                     var param=l;
                     continue}
                   return [0,v0,d0]}}
               var param$1=l$0;
               continue}
             throw Not_found}}
         function find_last_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=r;continue}
                     var param=l;
                     continue}
                   return [0,[0,v0,d0]]}}
               var param$1=l$0;
               continue}
             return 0}}
         function find_opt(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return [0,d];
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function mem(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v),
                _sV_=0 === c?1:0;
               if(_sV_)return _sV_;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function min_binding(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _sU_=param$0[1];
               if(_sU_){var param$0=_sU_;continue}
               var d=param$0[3],v=param$0[2];
               return [0,v,d]}
             throw Not_found}}
         function min_binding_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _sT_=param$0[1];
               if(_sT_){var param$0=_sT_;continue}
               var d=param$0[3],v=param$0[2];
               return [0,[0,v,d]]}
             return 0}}
         function max_binding(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _sQ_=param$0[4],_sR_=param$0[3],_sS_=param$0[2];
               if(_sQ_){var param$0=_sQ_;continue}
               return [0,_sS_,_sR_]}
             throw Not_found}}
         function max_binding_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _sN_=param$0[4],_sO_=param$0[3],_sP_=param$0[2];
               if(_sN_){var param$0=_sN_;continue}
               return [0,[0,_sP_,_sO_]]}
             return 0}}
         function remove_min_binding(param)
          {if(param)
            {var _sM_=param[1];
             if(_sM_)
              {var r=param[4],d=param[3],v=param[2];
               return bal(remove_min_binding(_sM_),v,d,r)}
             var r$0=param[4];
             return r$0}
           return invalid_arg(cst_Map_remove_min_elt)}
         function _sv_(t,match)
          {if(t)
            {if(match)
              {var match$0=min_binding(match),d=match$0[2],x=match$0[1];
               return bal(t,x,d,remove_min_binding(match))}
             return t}
           return match}
         function remove(x,m)
          {if(m)
            {var r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return _sv_(l,r);
             if(0 <= c){var rr=remove(x,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=remove(x,l);
             return l === ll?m:bal(ll,v,d,r)}
           return 0}
         function update(x,f,m)
          {if(m)
            {var h=m[5],r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)
              {var match=caml_call1(f,[0,d]);
               if(match)
                {var data=match[1];return d === data?m:[0,l,x,data,r,h]}
               return _sv_(l,r)}
             if(0 <= c){var rr=update(x,f,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=update(x,f,l);
             return l === ll?m:bal(ll,v,d,r)}
           var match$0=caml_call1(f,0);
           if(match$0){var data$0=match$0[1];return [0,0,x,data$0,0,1]}
           return 0}
         function iter(f,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var r=param$0[4],d=param$0[3],v=param$0[2],l=param$0[1];
               iter(f,l);
               caml_call2(f,v,d);
               var param$0=r;
               continue}
             return 0}}
         function map(f,param)
          {if(param)
            {var
              h=param[5],
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              l$0=map(f,l),
              d$0=caml_call1(f,d),
              r$0=map(f,r);
             return [0,l$0,v,d$0,r$0,h]}
           return 0}
         function mapi(f,param)
          {if(param)
            {var
              h=param[5],
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              l$0=mapi(f,l),
              d$0=caml_call2(f,v,d),
              r$0=mapi(f,r);
             return [0,l$0,v,d$0,r$0,h]}
           return 0}
         function fold(f,m,accu)
          {var m$0=m,accu$0=accu;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                l=m$0[1],
                accu$1=caml_call3(f,v,d,fold(f,l,accu$0)),
                m$0=r,
                accu$0=accu$1;
               continue}
             return accu$0}}
         function for_all(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _sJ_=caml_call2(p,v,d);
               if(_sJ_)
                {var _sK_=for_all(p,l);
                 if(_sK_){var param$0=r;continue}
                 var _sL_=_sK_}
               else
                var _sL_=_sJ_;
               return _sL_}
             return 1}}
         function exists(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _sG_=caml_call2(p,v,d);
               if(_sG_)
                var _sH_=_sG_;
               else
                {var _sI_=exists(p,l);
                 if(! _sI_){var param$0=r;continue}
                 var _sH_=_sI_}
               return _sH_}
             return 0}}
         function add_min_binding(k,x,param)
          {if(param)
            {var r=param[4],d=param[3],v=param[2],l=param[1];
             return bal(add_min_binding(k,x,l),v,d,r)}
           return singleton(k,x)}
         function add_max_binding(k,x,param)
          {if(param)
            {var r=param[4],d=param[3],v=param[2],l=param[1];
             return bal(l,v,d,add_max_binding(k,x,r))}
           return singleton(k,x)}
         function join(l,v,d,r)
          {if(l)
            {if(r)
              {var
                rh=r[5],
                rr=r[4],
                rd=r[3],
                rv=r[2],
                rl=r[1],
                lh=l[5],
                lr=l[4],
                ld=l[3],
                lv=l[2],
                ll=l[1];
               return (rh + 2 | 0) < lh
                       ?bal(ll,lv,ld,join(lr,v,d,r))
                       :(lh + 2 | 0) < rh
                         ?bal(join(l,v,d,rl),rv,rd,rr)
                         :create(l,v,d,r)}
             return add_max_binding(v,d,l)}
           return add_min_binding(v,d,r)}
         function concat(t,match)
          {if(t)
            {if(match)
              {var match$0=min_binding(match),d=match$0[2],x=match$0[1];
               return join(t,x,d,remove_min_binding(match))}
             return t}
           return match}
         function concat_or_join(t1,v,d,t2)
          {if(d){var d$0=d[1];return join(t1,v,d$0,t2)}return concat(t1,t2)}
         function split(x,param)
          {if(param)
            {var
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              c=caml_call2(Ord[1],x,v);
             if(0 === c)return [0,l,[0,d],r];
             if(0 <= c)
              {var match=split(x,r),rr=match[3],pres=match[2],lr=match[1];
               return [0,join(l,v,d,lr),pres,rr]}
             var
              match$0=split(x,l),
              rl=match$0[3],
              pres$0=match$0[2],
              ll=match$0[1];
             return [0,ll,pres$0,join(rl,v,d,r)]}
           return _N_}
         function merge(f,s1,s2)
          {if(s1)
            {var h1=s1[5],r1=s1[4],d1=s1[3],v1=s1[2],l1=s1[1];
             if(height(s2) <= h1)
              {var
                match=split(v1,s2),
                r2=match[3],
                d2=match[2],
                l2=match[1],
                _sC_=merge(f,r1,r2),
                _sD_=caml_call3(f,v1,[0,d1],d2);
               return concat_or_join(merge(f,l1,l2),v1,_sD_,_sC_)}}
           else
            if(! s2)return 0;
           if(s2)
            {var
              r2$0=s2[4],
              d2$0=s2[3],
              v2=s2[2],
              l2$0=s2[1],
              match$0=split(v2,s1),
              r1$0=match$0[3],
              d1$0=match$0[2],
              l1$0=match$0[1],
              _sE_=merge(f,r1$0,r2$0),
              _sF_=caml_call3(f,v2,d1$0,[0,d2$0]);
             return concat_or_join(merge(f,l1$0,l2$0),v2,_sF_,_sE_)}
           throw [0,Assert_failure,_O_]}
         function union(f,s1,s2)
          {if(s1)
            {if(s2)
              {var
                h2=s2[5],
                r2=s2[4],
                d2=s2[3],
                v2=s2[2],
                l2=s2[1],
                h1=s1[5],
                r1=s1[4],
                d1=s1[3],
                v1=s1[2],
                l1=s1[1];
               if(h2 <= h1)
                {var
                  match=split(v1,s2),
                  r2$0=match[3],
                  d2$0=match[2],
                  l2$0=match[1],
                  l=union(f,l1,l2$0),
                  r=union(f,r1,r2$0);
                 if(d2$0)
                  {var d2$1=d2$0[1];
                   return concat_or_join(l,v1,caml_call3(f,v1,d1,d2$1),r)}
                 return join(l,v1,d1,r)}
               var
                match$0=split(v2,s1),
                r1$0=match$0[3],
                d1$0=match$0[2],
                l1$0=match$0[1],
                l$0=union(f,l1$0,l2),
                r$0=union(f,r1$0,r2);
               if(d1$0)
                {var d1$1=d1$0[1];
                 return concat_or_join(l$0,v2,caml_call3(f,v2,d1$1,d2),r$0)}
               return join(l$0,v2,d2,r$0)}
             var s=s1}
           else
            var s=s2;
           return s}
         function filter(p,m)
          {if(m)
            {var
              r=m[4],
              d=m[3],
              v=m[2],
              l=m[1],
              l$0=filter(p,l),
              pvd=caml_call2(p,v,d),
              r$0=filter(p,r);
             if(pvd)
              {if(l === l$0)if(r === r$0)return m;return join(l$0,v,d,r$0)}
             return concat(l$0,r$0)}
           return 0}
         function partition(p,param)
          {if(param)
            {var
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              match=partition(p,l),
              lf=match[2],
              lt=match[1],
              pvd=caml_call2(p,v,d),
              match$0=partition(p,r),
              rf=match$0[2],
              rt=match$0[1];
             if(pvd){var _sA_=concat(lf,rf);return [0,join(lt,v,d,rt),_sA_]}
             var _sB_=join(lf,v,d,rf);
             return [0,concat(lt,rt),_sB_]}
           return _P_}
         function cons_enum(m,e)
          {var m$0=m,e$0=e;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                m$1=m$0[1],
                e$1=[0,v,d,r,e$0],
                m$0=m$1,
                e$0=e$1;
               continue}
             return e$0}}
         function compare(cmp,m1,m2)
          {var e2$2=cons_enum(m2,0),e1$2=cons_enum(m1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[4],
                  r2=e2[3],
                  d2=e2[2],
                  v2=e2[1],
                  e1$0=e1[4],
                  r1=e1[3],
                  d1=e1[2],
                  v1=e1[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var c$0=caml_call2(cmp,d1,d2);
                   if(0 === c$0)
                    {var
                      e2$1=cons_enum(r2,e2$0),
                      e1$1=cons_enum(r1,e1$0),
                      e1=e1$1,
                      e2=e2$1;
                     continue}
                   return c$0}
                 return c}
               return 1}
             return e2?-1:0}}
         function equal(cmp,m1,m2)
          {var e2$2=cons_enum(m2,0),e1$2=cons_enum(m1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[4],
                  r2=e2[3],
                  d2=e2[2],
                  v2=e2[1],
                  e1$0=e1[4],
                  r1=e1[3],
                  d1=e1[2],
                  v1=e1[1],
                  _sx_=0 === caml_call2(Ord[1],v1,v2)?1:0;
                 if(_sx_)
                  {var _sy_=caml_call2(cmp,d1,d2);
                   if(_sy_)
                    {var
                      e2$1=cons_enum(r2,e2$0),
                      e1$1=cons_enum(r1,e1$0),
                      e1=e1$1,
                      e2=e2$1;
                     continue}
                   var _sz_=_sy_}
                 else
                  var _sz_=_sx_;
                 return _sz_}
               return 0}
             return e2?0:1}}
         function cardinal(param)
          {if(param)
            {var r=param[4],l=param[1],_sw_=cardinal(r);
             return (cardinal(l) + 1 | 0) + _sw_ | 0}
           return 0}
         function bindings_aux(accu,param)
          {var accu$0=accu,param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                accu$1=[0,[0,v,d],bindings_aux(accu$0,r)],
                accu$0=accu$1,
                param$0=l;
               continue}
             return accu$0}}
         function bindings(s){return bindings_aux(0,s)}
         return [0,
                 empty,
                 is_empty,
                 mem,
                 add,
                 update,
                 singleton,
                 remove,
                 merge,
                 union,
                 compare,
                 equal,
                 iter,
                 fold,
                 for_all,
                 exists,
                 filter,
                 partition,
                 cardinal,
                 bindings,
                 min_binding,
                 min_binding_opt,
                 max_binding,
                 max_binding_opt,
                 min_binding,
                 min_binding_opt,
                 split,
                 find,
                 find_opt,
                 find_first,
                 find_first_opt,
                 find_last,
                 find_last_opt,
                 map,
                 mapi]}];
    caml_register_global(661,Map,"Map");
    var Empty=[248,cst_Stack_Empty,caml_fresh_oo_id(0)];
    function create(param){return [0,0,0]}
    function clear(s){s[1] = 0;s[2] = 0;return 0}
    function copy$2(s){return [0,s[1],s[2]]}
    function push(x,s){s[1] = [0,x,s[1]];s[2] = s[2] + 1 | 0;return 0}
    function pop(s)
     {var _su_=s[1];
      if(_su_)
       {var tl=_su_[2],hd=_su_[1];s[1] = tl;s[2] = s[2] - 1 | 0;return hd}
      throw Empty}
    function top(s)
     {var _st_=s[1];if(_st_){var hd=_st_[1];return hd}throw Empty}
    function is_empty(s){return 0 === s[1]?1:0}
    function length$1(s){return s[2]}
    function iter$3(f,s){return iter(f,s[1])}
    function fold(f,acc,s){return fold_left(f,acc,s[1])}
    var
     Stack=
      [0,Empty,create,push,pop,top,clear,copy$2,is_empty,length$1,iter$3,fold];
    caml_register_global(662,Stack,"Stack");
    var Empty$0=[248,cst_Queue_Empty,caml_fresh_oo_id(0)];
    function create$0(param){return [0,0,0,0]}
    function clear$0(q){q[1] = 0;q[2] = 0;q[3] = 0;return 0}
    function add(x,q)
     {var cell=[0,x,0],_ss_=q[3];
      return _ss_
              ?(q[1] = q[1] + 1 | 0,_ss_[2] = cell,q[3] = cell,0)
              :(q[1] = 1,q[2] = cell,q[3] = cell,0)}
    function peek(q)
     {var _sr_=q[2];if(_sr_){var content=_sr_[1];return content}throw Empty$0}
    function take(q)
     {var _so_=q[2];
      if(_so_)
       {var _sp_=_so_[1],_sq_=_so_[2];
        return _sq_?(q[1] = q[1] - 1 | 0,q[2] = _sq_,_sp_):(clear$0(q),_sp_)}
      throw Empty$0}
    function copy$3(q)
     {var q_res=[0,q[1],0,0],prev=0,cell=q[2];
      for(;;)
       {if(cell)
         {var content=cell[1],next=cell[2],res=[0,content,0];
          if(prev)prev[2] = res;else q_res[2] = res;
          var prev=res,cell=next;
          continue}
        q_res[3] = prev;
        return q_res}}
    function is_empty$0(q){return 0 === q[1]?1:0}
    function length$2(q){return q[1]}
    function iter$4(f,q)
     {var cell=q[2];
      for(;;)
       {if(cell)
         {var content=cell[1],next=cell[2];
          caml_call1(f,content);
          var cell=next;
          continue}
        return 0}}
    function fold$0(f,accu$1,q)
     {var accu=accu$1,cell=q[2];
      for(;;)
       {if(cell)
         {var
           content=cell[1],
           next=cell[2],
           accu$0=caml_call2(f,accu,content),
           accu=accu$0,
           cell=next;
          continue}
        return accu}}
    function transfer(q1,q2)
     {var _sm_=0 < q1[1]?1:0;
      if(_sm_)
       {var _sn_=q2[3];
        return _sn_
                ?(q2[1]
                  =
                  q2[1]
                  +
                  q1[1]
                  |
                  0,
                  _sn_[2]
                  =
                  q1[2],
                  q2[3]
                  =
                  q1[3],
                  clear$0(q1))
                :(q2[1] = q1[1],q2[2] = q1[2],q2[3] = q1[3],clear$0(q1))}
      return _sm_}
    var
     Queue=
      [0,
       Empty$0,
       create$0,
       add,
       add,
       take,
       take,
       peek,
       peek,
       clear$0,
       copy$3,
       is_empty$0,
       length$2,
       iter$4,
       fold$0,
       transfer];
    caml_register_global(663,Queue,"Queue");
    var Undefined=[248,cst_CamlinternalLazy_Undefined,caml_fresh_oo_id(0)];
    function raise_undefined(param){throw Undefined}
    function force_lazy_block(blk)
     {var closure=blk[1];
      blk[1] = raise_undefined;
      try
       {var result=caml_call1(closure,0);
        blk[1] = result;
        caml_obj_set_tag(blk,250);
        return result}
      catch(e)
       {e = caml_wrap_exception(e);blk[1] = function(param){throw e};throw e}}
    function force_val_lazy_block(blk)
     {var closure=blk[1];
      blk[1] = raise_undefined;
      var result=caml_call1(closure,0);
      blk[1] = result;
      caml_obj_set_tag(blk,250);
      return result}
    function force(lzv)
     {var t=caml_obj_tag(lzv);
      return t === 250?lzv[1]:t !== 246?lzv:force_lazy_block(lzv)}
    function force_val(lzv)
     {var t=caml_obj_tag(lzv);
      return t === 250?lzv[1]:t !== 246?lzv:force_val_lazy_block(lzv)}
    var
     CamlinternalLazy=
      [0,Undefined,force_lazy_block,force_val_lazy_block,force,force_val];
    caml_register_global(664,CamlinternalLazy,"CamlinternalLazy");
    function from_fun(f){var x=caml_obj_block(246,1);x[1] = f;return x}
    function from_val(v)
     {var t=caml_obj_tag(v);
      if(t !== 250)if(t !== 246)if(t !== 253)return v;
      return runtime.caml_lazy_make_forward(v)}
    function is_val(l){return caml_obj_tag(l) !== 246?1:0}
    var
     Lazy=
      [0,
       Undefined,
       force_val,
       from_fun,
       from_val,
       is_val,
       from_fun,
       from_val,
       is_val];
    caml_register_global(665,Lazy,"Lazy");
    var
     Failure$0=[248,cst_Stream_Failure,caml_fresh_oo_id(0)],
     Error=[248,cst_Stream_Error,caml_fresh_oo_id(0)];
    function count(param)
     {if(param){var match=param[1],count=match[1];return count}return 0}
    function data(param)
     {if(param){var match=param[1],data=match[2];return data}return 0}
    function fill_buff(b)
     {b[3] = input(b[1],b[2],0,caml_ml_bytes_length(b[2]));b[4] = 0;return 0}
    function get_data(count,d)
     {var d$0=d;
      for(;;)
       {if(typeof d$0 !== "number")
         switch(d$0[0])
          {case 1:
            var d2=d$0[2],d1=d$0[1],match=get_data(count,d1);
            if(typeof match === "number")
             {var d$0=d2;continue}
            else
             {if(0 === match[0])
               {var d11=match[2],a=match[1];return [0,a,[1,d11,d2]]}
              throw [0,Assert_failure,_Q_]}
           case 2:
            var
             f=d$0[1],
             _si_=caml_obj_tag(f),
             d$1=250 === _si_?f[1]:246 === _si_?force_lazy_block(f):f,
             d$0=d$1;
            continue;
           case 3:
            var _sj_=d$0[1],_sk_=_sj_[1];
            if(_sk_)
             {var _sl_=_sk_[1];
              if(_sl_){var a$0=_sl_[1];_sj_[1] = 0;return [0,a$0,d$0]}
              return 0}
            var match$0=caml_call1(_sj_[2],count);
            if(match$0){var a$1=match$0[1];return [0,a$1,d$0]}
            _sj_[1] = _R_;
            return 0;
           case 4:
            var b=d$0[1];
            if(b[3] <= b[4])fill_buff(b);
            if(0 === b[3])return 0;
            var r=caml_bytes_unsafe_get(b[2],b[4]);
            b[4] = b[4] + 1 | 0;
            return [0,r,d$0]
           }
        return d$0}}
    function peek_data(s)
     {for(;;)
       {var _sd_=s[2];
        if(typeof _sd_ === "number")
         return 0;
        else
         switch(_sd_[0])
          {case 0:var a=_sd_[1];return [0,a];
           case 1:
            var d=get_data(s[1],s[2]);
            if(typeof d === "number")
             return 0;
            else
             {if(0 === d[0]){var a$0=d[1];s[2] = d;return [0,a$0]}
              throw [0,Assert_failure,_S_]}
           case 2:
            var
             f=_sd_[1],
             _se_=caml_obj_tag(f),
             _sf_=250 === _se_?f[1]:246 === _se_?force_lazy_block(f):f;
            s[2] = _sf_;
            continue;
           case 3:
            var _sg_=_sd_[1],_sh_=_sg_[1];
            if(_sh_){var a$1=_sh_[1];return a$1}
            var x=caml_call1(_sg_[2],s[1]);
            _sg_[1] = [0,x];
            return x;
           default:
            var b=_sd_[1];
            if(b[3] <= b[4])fill_buff(b);
            return 0 === b[3]
                    ?(s[2] = 0,0)
                    :[0,caml_bytes_unsafe_get(b[2],b[4])]}}}
    function peek$0(param)
     {if(param){var s=param[1];return peek_data(s)}return 0}
    function junk_data(s)
     {for(;;)
       {var _sb_=s[2];
        if(typeof _sb_ !== "number")
         switch(_sb_[0])
          {case 0:var d=_sb_[2];s[1] = s[1] + 1 | 0;s[2] = d;return 0;
           case 3:
            var _sc_=_sb_[1];
            if(_sc_[1]){s[1] = s[1] + 1 | 0;_sc_[1] = 0;return 0}
            break;
           case 4:
            var b=_sb_[1];s[1] = s[1] + 1 | 0;b[4] = b[4] + 1 | 0;return 0
           }
        var match=peek_data(s);
        if(match)continue;
        return 0}}
    function junk(param)
     {if(param){var data=param[1];return junk_data(data)}return 0}
    function nget_data(n,s)
     {if(0 < n)
       {var match=peek_data(s);
        if(match)
         {var a=match[1];
          junk_data(s);
          var
           match$0=nget_data(n - 1 | 0,s),
           k=match$0[3],
           d=match$0[2],
           al=match$0[1];
          return [0,[0,a,al],[0,a,d],k + 1 | 0]}
        return [0,0,s[2],0]}
      return [0,0,s[2],0]}
    function npeek(n,param)
     {if(param)
       {var
         d$0=param[1],
         match=nget_data(n,d$0),
         len=match[3],
         d=match[2],
         al=match[1];
        d$0[1] = d$0[1] - len | 0;
        d$0[2] = d;
        return al}
      return 0}
    function next(s)
     {var match=peek$0(s);
      if(match){var a=match[1];junk(s);return a}
      throw Failure$0}
    function empty$0(s){var match=peek$0(s);if(match)throw Failure$0;return 0}
    function iter$5(f,strm)
     {for(;;)
       {var match=peek$0(strm);
        if(match){var a=match[1];junk(strm);caml_call1(f,a);continue}
        return 0}}
    function from(f){return [0,[0,0,[3,[0,0,f]]]]}
    function of_list$0(l)
     {var _sa_=0;
      return [0,[0,0,fold_right(function(x,l){return [0,x,l]},l,_sa_)]]}
    function of_string$0(s)
     {var count=[0,0];
      return from
              (function(param)
                {var c=count[1];
                 return c < caml_ml_string_length(s)
                         ?(count[1]++,[0,caml_string_get(s,c)])
                         :0})}
    function of_bytes(s)
     {var count=[0,0];
      return from
              (function(param)
                {var c=count[1];
                 return c < caml_ml_bytes_length(s)
                         ?(count[1]++,[0,caml_bytes_get(s,c)])
                         :0})}
    function of_channel(ic)
     {return [0,[0,0,[4,[0,ic,caml_create_bytes(4096),0,0]]]]}
    function iapp(i,s){var _r$_=data(s);return [0,[0,0,[1,data(i),_r$_]]]}
    function icons(i,s){return [0,[0,0,[0,i,data(s)]]]}
    function ising(i){return [0,[0,0,[0,i,0]]]}
    function lapp(f,s)
     {return [0,
              [0,
               0,
               [2,
                [246,
                 function(_r9_)
                  {var _r__=data(s);return [1,data(caml_call1(f,0)),_r__]}]]]]}
    function lcons(f,s)
     {return [0,
              [0,
               0,
               [2,
                [246,
                 function(_r7_)
                  {var _r8_=data(s);return [0,caml_call1(f,0),_r8_]}]]]]}
    function lsing(f)
     {return [0,[0,0,[2,[246,function(_r6_){return [0,caml_call1(f,0),0]}]]]]}
    var sempty=0;
    function slazy(f)
     {return [0,[0,0,[2,[246,function(_r5_){return data(caml_call1(f,0))}]]]]}
    function dump(f,s)
     {print_string(cst_count);
      print_int(count(s));
      print_string(cst_data);
      dump_data(f,data(s));
      print_string(cst$5);
      return print_newline(0)}
    function dump_data(f,param)
     {if(typeof param === "number")
       return print_string(cst_Sempty);
      else
       switch(param[0])
        {case 0:
          var d=param[2],a=param[1];
          print_string(cst_Scons);
          caml_call1(f,a);
          print_string(cst$6);
          dump_data(f,d);
          return print_string(cst$7);
         case 1:
          var d2=param[2],d1=param[1];
          print_string(cst_Sapp);
          dump_data(f,d1);
          print_string(cst$8);
          dump_data(f,d2);
          return print_string(cst$9);
         case 2:return print_string(cst_Slazy);
         case 3:return print_string(cst_Sgen);
         default:return print_string(cst_Sbuffio)}}
    var
     Stream=
      [0,
       Failure$0,
       Error,
       from,
       of_list$0,
       of_string$0,
       of_bytes,
       of_channel,
       iter$5,
       next,
       empty$0,
       peek$0,
       junk,
       count,
       npeek,
       iapp,
       icons,
       ising,
       lapp,
       lcons,
       lsing,
       sempty,
       slazy,
       dump];
    caml_register_global(666,Stream,"Stream");
    function create$1(n)
     {var
       n$0=1 <= n?n:1,
       n$1=max_string_length < n$0?max_string_length:n$0,
       s=caml_create_bytes(n$1);
      return [0,s,0,n$1,s]}
    function contents(b){return sub_string(b[1],0,b[2])}
    function to_bytes(b){return sub(b[1],0,b[2])}
    function sub$2(b,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((b[2] - len | 0) < ofs))return sub_string(b[1],ofs,len);
      return invalid_arg(cst_Buffer_sub)}
    function blit$2(src,srcoff,dst,dstoff,len)
     {if(0 <= len)
       if(0 <= srcoff)
        if(! ((src[2] - len | 0) < srcoff))
         if(0 <= dstoff)
          if(! ((caml_ml_bytes_length(dst) - len | 0) < dstoff))
           return caml_blit_bytes(src[1],srcoff,dst,dstoff,len);
      return invalid_arg(cst_Buffer_blit)}
    function nth$0(b,ofs)
     {if(0 <= ofs)if(! (b[2] <= ofs))return caml_bytes_unsafe_get(b[1],ofs);
      return invalid_arg(cst_Buffer_nth)}
    function length$3(b){return b[2]}
    function clear$1(b){b[2] = 0;return 0}
    function reset(b)
     {b[2] = 0;b[1] = b[4];b[3] = caml_ml_bytes_length(b[1]);return 0}
    function resize(b,more)
     {var len=b[3],new_len=[0,len];
      for(;;)
       {if(new_len[1] < (b[2] + more | 0))
         {new_len[1] = 2 * new_len[1] | 0;continue}
        if(max_string_length < new_len[1])
         if((b[2] + more | 0) <= max_string_length)
          new_len[1] = max_string_length;
         else
          failwith(cst_Buffer_add_cannot_grow_buffer);
        var new_buffer=caml_create_bytes(new_len[1]);
        blit(b[1],0,new_buffer,0,b[2]);
        b[1] = new_buffer;
        b[3] = new_len[1];
        return 0}}
    function add_char(b,c)
     {var pos=b[2];
      if(b[3] <= pos)resize(b,1);
      caml_bytes_unsafe_set(b[1],pos,c);
      b[2] = pos + 1 | 0;
      return 0}
    function add_utf_8_uchar(b,u)
     {if(0 <= u)
       {if(127 < u)
         {if(2047 < u)
           {if(65535 < u)
             {if(1114111 < u)throw [0,Assert_failure,_T_];
              var pos=b[2];
              if(b[3] < (pos + 4 | 0))resize(b,4);
              caml_bytes_unsafe_set(b[1],pos,240 | u >>> 18 | 0);
              caml_bytes_unsafe_set
               (b[1],pos + 1 | 0,128 | (u >>> 12 | 0) & 63);
              caml_bytes_unsafe_set(b[1],pos + 2 | 0,128 | (u >>> 6 | 0) & 63);
              caml_bytes_unsafe_set(b[1],pos + 3 | 0,128 | u & 63);
              b[2] = pos + 4 | 0;
              return 0}
            var pos$0=b[2];
            if(b[3] < (pos$0 + 3 | 0))resize(b,3);
            caml_bytes_unsafe_set(b[1],pos$0,224 | u >>> 12 | 0);
            caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,128 | (u >>> 6 | 0) & 63);
            caml_bytes_unsafe_set(b[1],pos$0 + 2 | 0,128 | u & 63);
            b[2] = pos$0 + 3 | 0;
            return 0}
          var pos$1=b[2];
          if(b[3] < (pos$1 + 2 | 0))resize(b,2);
          caml_bytes_unsafe_set(b[1],pos$1,192 | u >>> 6 | 0);
          caml_bytes_unsafe_set(b[1],pos$1 + 1 | 0,128 | u & 63);
          b[2] = pos$1 + 2 | 0;
          return 0}
        return add_char(b,u)}
      throw [0,Assert_failure,_U_]}
    function add_utf_16be_uchar(b,u)
     {if(0 <= u)
       {if(65535 < u)
         {if(1114111 < u)throw [0,Assert_failure,_V_];
          var
           u$0=u - 65536 | 0,
           hi=55296 | u$0 >>> 10 | 0,
           lo=56320 | u$0 & 1023,
           pos=b[2];
          if(b[3] < (pos + 4 | 0))resize(b,4);
          caml_bytes_unsafe_set(b[1],pos,hi >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 1 | 0,hi & 255);
          caml_bytes_unsafe_set(b[1],pos + 2 | 0,lo >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 3 | 0,lo & 255);
          b[2] = pos + 4 | 0;
          return 0}
        var pos$0=b[2];
        if(b[3] < (pos$0 + 2 | 0))resize(b,2);
        caml_bytes_unsafe_set(b[1],pos$0,u >>> 8 | 0);
        caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,u & 255);
        b[2] = pos$0 + 2 | 0;
        return 0}
      throw [0,Assert_failure,_W_]}
    function add_utf_16le_uchar(b,u)
     {if(0 <= u)
       {if(65535 < u)
         {if(1114111 < u)throw [0,Assert_failure,_X_];
          var
           u$0=u - 65536 | 0,
           hi=55296 | u$0 >>> 10 | 0,
           lo=56320 | u$0 & 1023,
           pos=b[2];
          if(b[3] < (pos + 4 | 0))resize(b,4);
          caml_bytes_unsafe_set(b[1],pos,hi & 255);
          caml_bytes_unsafe_set(b[1],pos + 1 | 0,hi >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 2 | 0,lo & 255);
          caml_bytes_unsafe_set(b[1],pos + 3 | 0,lo >>> 8 | 0);
          b[2] = pos + 4 | 0;
          return 0}
        var pos$0=b[2];
        if(b[3] < (pos$0 + 2 | 0))resize(b,2);
        caml_bytes_unsafe_set(b[1],pos$0,u & 255);
        caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,u >>> 8 | 0);
        b[2] = pos$0 + 2 | 0;
        return 0}
      throw [0,Assert_failure,_Y_]}
    function add_substring(b,s,offset,len)
     {var _r2_=offset < 0?1:0;
      if(_r2_)
       var _r3_=_r2_;
      else
       var
        _r4_=len < 0?1:0,
        _r3_=_r4_ || ((caml_ml_string_length(s) - len | 0) < offset?1:0);
      if(_r3_)invalid_arg(cst_Buffer_add_substring_add_subbytes);
      var new_position=b[2] + len | 0;
      if(b[3] < new_position)resize(b,len);
      blit$0(s,offset,b[1],b[2],len);
      b[2] = new_position;
      return 0}
    function add_subbytes(b,s,offset,len)
     {return add_substring(b,s,offset,len)}
    function add_string(b,s)
     {var len=caml_ml_string_length(s),new_position=b[2] + len | 0;
      if(b[3] < new_position)resize(b,len);
      blit$0(s,0,b[1],b[2],len);
      b[2] = new_position;
      return 0}
    function add_bytes(b,s){return add_string(b,s)}
    function add_buffer(b,bs){return add_subbytes(b,bs[1],0,bs[2])}
    function add_channel(b,ic,len$1)
     {var _r0_=len$1 < 0?1:0,_r1_=_r0_ || (max_string_length < len$1?1:0);
      if(_r1_)invalid_arg(cst_Buffer_add_channel);
      if(b[3] < (b[2] + len$1 | 0))resize(b,len$1);
      var len=len$1;
      for(;;)
       {var _rZ_=0 < len?1:0;
        if(_rZ_)
         {var n=input(ic,b[1],b[2],len);
          b[2] = b[2] + n | 0;
          if(0 === n)throw End_of_file;
          var len$0=len - n | 0,len=len$0;
          continue}
        return _rZ_}}
    function output_buffer(oc,b){return output(oc,b[1],0,b[2])}
    function add_substitute(b,f,s)
     {var lim$1=caml_ml_string_length(s),previous=32,i$7=0;
      for(;;)
       {if(i$7 < lim$1)
         {var current=caml_string_get(s,i$7);
          if(36 === current)
           {if(92 === previous)
             {add_char(b,current);
              var i$8=i$7 + 1 | 0,previous=32,i$7=i$8;
              continue}
            var start=i$7 + 1 | 0;
            if(lim$1 <= start)throw Not_found;
            var opening=caml_string_get(s,start);
            if(40 === opening)
             var switch$0=0;
            else
             if(123 === opening)
              var switch$0=0;
             else
              {var i$6=start + 1 | 0,lim$0=caml_ml_string_length(s),i$3=i$6;
               for(;;)
                {if(lim$0 <= i$3)
                  var stop=lim$0;
                 else
                  {var
                    match=caml_string_get(s,i$3),
                    switch$1=
                     91 <= match
                      ?97 <= match?123 <= match?0:1:95 === match?1:0
                      :58 <= match?65 <= match?1:0:48 <= match?1:0;
                   if(switch$1){var i$4=i$3 + 1 | 0,i$3=i$4;continue}
                   var stop=i$3}
                 var
                  match$0=[0,sub$0(s,start,stop - start | 0),stop],
                  switch$0=1;
                 break}}
            if(! switch$0)
             {var i$5=start + 1 | 0,k$2=0;
              if(40 === opening)
               var _rX_=41;
              else
               {if(123 !== opening)throw [0,Assert_failure,_Z_];var _rX_=125}
              var lim=caml_ml_string_length(s),k=k$2,i=i$5;
              for(;;)
               {if(lim <= i)throw Not_found;
                if(caml_string_get(s,i) === opening)
                 {var i$0=i + 1 | 0,k$0=k + 1 | 0,k=k$0,i=i$0;continue}
                if(caml_string_get(s,i) !== _rX_)
                 {var i$2=i + 1 | 0,i=i$2;continue}
                if(0 !== k)
                 {var i$1=i + 1 | 0,k$1=k - 1 | 0,k=k$1,i=i$1;continue}
                var
                 match$0=
                  [0,sub$0(s,i$5,(i - start | 0) - 1 | 0),i + 1 | 0];
                break}}
            var next_i=match$0[2],ident=match$0[1];
            add_string(b,caml_call1(f,ident));
            var previous=32,i$7=next_i;
            continue}
          if(92 === previous)
           {add_char(b,92);
            add_char(b,current);
            var i$9=i$7 + 1 | 0,previous=32,i$7=i$9;
            continue}
          if(92 === current)
           {var i$10=i$7 + 1 | 0,previous=current,i$7=i$10;continue}
          add_char(b,current);
          var i$11=i$7 + 1 | 0,previous=current,i$7=i$11;
          continue}
        var _rY_=92 === previous?1:0;
        return _rY_?add_char(b,previous):_rY_}}
    function truncate(b,len)
     {if(0 <= len)if(! (b[2] < len)){b[2] = len;return 0}
      return invalid_arg(cst_Buffer_truncate)}
    var
     Buffer=
      [0,
       create$1,
       contents,
       to_bytes,
       sub$2,
       blit$2,
       nth$0,
       length$3,
       clear$1,
       reset,
       add_char,
       add_utf_8_uchar,
       add_utf_16le_uchar,
       add_utf_16be_uchar,
       add_string,
       add_bytes,
       add_substring,
       add_subbytes,
       add_substitute,
       add_buffer,
       add_channel,
       output_buffer,
       truncate];
    caml_register_global(667,Buffer,"Buffer");
    function create_char_set(param){return make(32,0)}
    function add_in_char_set(char_set,c)
     {var str_ind=c >>> 3 | 0,mask=1 << (c & 7);
      return caml_bytes_set
              (char_set,
               str_ind,
               char_of_int(caml_bytes_get(char_set,str_ind) | mask))}
    function freeze_char_set(char_set){return to_string(char_set)}
    function rev_char_set(char_set)
     {var char_set$0=create_char_set(0),i=0;
      for(;;)
       {caml_bytes_set
         (char_set$0,i,char_of_int(caml_string_get(char_set,i) ^ 255));
        var _rW_=i + 1 | 0;
        if(31 !== i){var i=_rW_;continue}
        return char_set$0}}
    function is_in_char_set(char_set,c)
     {var str_ind=c >>> 3 | 0,mask=1 << (c & 7);
      return 0 !== (caml_string_get(char_set,str_ind) & mask)?1:0}
    function pad_of_pad_opt(pad_opt)
     {if(pad_opt){var width=pad_opt[1];return [0,1,width]}return 0}
    function param_format_of_ignored_format(ign,fmt)
     {if(typeof ign === "number")
       switch(ign)
        {case 0:return [0,[0,fmt]];
         case 1:return [0,[1,fmt]];
         case 2:return [0,[19,fmt]];
         default:return [0,[22,fmt]]}
      else
       switch(ign[0])
        {case 0:var pad_opt=ign[1];return [0,[2,pad_of_pad_opt(pad_opt),fmt]];
         case 1:
          var pad_opt$0=ign[1];return [0,[3,pad_of_pad_opt(pad_opt$0),fmt]];
         case 2:
          var pad_opt$1=ign[2],iconv=ign[1];
          return [0,[4,iconv,pad_of_pad_opt(pad_opt$1),0,fmt]];
         case 3:
          var pad_opt$2=ign[2],iconv$0=ign[1];
          return [0,[5,iconv$0,pad_of_pad_opt(pad_opt$2),0,fmt]];
         case 4:
          var pad_opt$3=ign[2],iconv$1=ign[1];
          return [0,[6,iconv$1,pad_of_pad_opt(pad_opt$3),0,fmt]];
         case 5:
          var pad_opt$4=ign[2],iconv$2=ign[1];
          return [0,[7,iconv$2,pad_of_pad_opt(pad_opt$4),0,fmt]];
         case 6:
          var prec_opt=ign[2],pad_opt$5=ign[1];
          if(prec_opt)var ndec=prec_opt[1],_rV_=[0,ndec];else var _rV_=0;
          return [0,[8,0,pad_of_pad_opt(pad_opt$5),_rV_,fmt]];
         case 7:
          var pad_opt$6=ign[1];return [0,[9,pad_of_pad_opt(pad_opt$6),fmt]];
         case 8:
          var fmtty=ign[2],pad_opt$7=ign[1];
          return [0,[13,pad_opt$7,fmtty,fmt]];
         case 9:
          var fmtty$0=ign[2],pad_opt$8=ign[1];
          return [0,[14,pad_opt$8,fmtty$0,fmt]];
         case 10:
          var char_set=ign[2],width_opt=ign[1];
          return [0,[20,width_opt,char_set,fmt]];
         default:var counter=ign[1];return [0,[21,counter,fmt]]}}
    var default_float_precision=-6;
    function buffer_create(init_size)
     {return [0,0,caml_create_bytes(init_size)]}
    function buffer_check_size(buf,overhead)
     {var
       len=caml_ml_bytes_length(buf[2]),
       min_len=buf[1] + overhead | 0,
       _rT_=len < min_len?1:0;
      if(_rT_)
       {var
         new_len=max(len * 2 | 0,min_len),
         new_str=caml_create_bytes(new_len);
        blit(buf[2],0,new_str,0,len);
        buf[2] = new_str;
        var _rU_=0}
      else
       var _rU_=_rT_;
      return _rU_}
    function buffer_add_char(buf,c)
     {buffer_check_size(buf,1);
      caml_bytes_set(buf[2],buf[1],c);
      buf[1] = buf[1] + 1 | 0;
      return 0}
    function buffer_add_string(buf,s)
     {var str_len=caml_ml_string_length(s);
      buffer_check_size(buf,str_len);
      blit$0(s,0,buf[2],buf[1],str_len);
      buf[1] = buf[1] + str_len | 0;
      return 0}
    function buffer_contents(buf){return sub_string(buf[2],0,buf[1])}
    function char_of_iconv(iconv)
     {switch(iconv)
       {case 12:return 117;
        case 6:
        case 7:return 120;
        case 8:
        case 9:return 88;
        case 10:
        case 11:return 111;
        case 0:
        case 1:
        case 2:return 100;
        default:return 105}}
    function char_of_fconv(fconv)
     {switch(fconv)
       {case 15:return 70;
        case 0:
        case 1:
        case 2:return 102;
        case 3:
        case 4:
        case 5:return 101;
        case 6:
        case 7:
        case 8:return 69;
        case 9:
        case 10:
        case 11:return 103;
        case 12:
        case 13:
        case 14:return 71;
        case 16:
        case 17:
        case 18:return 104;
        default:return 72}}
    function bprint_padty(buf,padty)
     {switch(padty)
       {case 0:return buffer_add_char(buf,45);
        case 1:return 0;
        default:return buffer_add_char(buf,48)}}
    function bprint_ignored_flag(buf,ign_flag)
     {return ign_flag?buffer_add_char(buf,95):ign_flag}
    function bprint_pad_opt(buf,pad_opt)
     {if(pad_opt)
       {var width=pad_opt[1];
        return buffer_add_string(buf,caml_new_string("" + width))}
      return 0}
    function bprint_padding(buf,pad)
     {if(typeof pad === "number")
       return 0;
      else
       {if(0 === pad[0])
         {var n=pad[2],padty=pad[1];
          bprint_padty(buf,padty);
          return buffer_add_string(buf,caml_new_string("" + n))}
        var padty$0=pad[1];
        bprint_padty(buf,padty$0);
        return buffer_add_char(buf,42)}}
    function bprint_precision(buf,prec)
     {if(typeof prec === "number")
       return 0 === prec?0:buffer_add_string(buf,cst$10);
      var n=prec[1];
      buffer_add_char(buf,46);
      return buffer_add_string(buf,caml_new_string("" + n))}
    function bprint_iconv_flag(buf,iconv)
     {switch(iconv)
       {case 1:
        case 4:return buffer_add_char(buf,43);
        case 2:
        case 5:return buffer_add_char(buf,32);
        case 7:
        case 9:
        case 11:return buffer_add_char(buf,35);
        default:return 0}}
    function bprint_altint_fmt(buf,ign_flag,iconv,pad,prec,c)
     {buffer_add_char(buf,37);
      bprint_ignored_flag(buf,ign_flag);
      bprint_iconv_flag(buf,iconv);
      bprint_padding(buf,pad);
      bprint_precision(buf,prec);
      buffer_add_char(buf,c);
      return buffer_add_char(buf,char_of_iconv(iconv))}
    function bprint_fconv_flag(buf,fconv)
     {switch(fconv)
       {case 1:
        case 4:
        case 7:
        case 10:
        case 13:
        case 17:
        case 20:return buffer_add_char(buf,43);
        case 2:
        case 5:
        case 8:
        case 11:
        case 14:
        case 18:
        case 21:return buffer_add_char(buf,32);
        default:return 0}}
    function string_of_formatting_lit(formatting_lit)
     {if(typeof formatting_lit === "number")
       switch(formatting_lit)
        {case 0:return cst$11;
         case 1:return cst$12;
         case 2:return cst$13;
         case 3:return cst$14;
         case 4:return cst$15;
         case 5:return cst$16;
         default:return cst$17}
      else
       switch(formatting_lit[0])
        {case 0:var str=formatting_lit[1];return str;
         case 1:var str$0=formatting_lit[1];return str$0;
         default:var c=formatting_lit[1];return symbol(cst$18,make$0(1,c))}}
    function string_of_formatting_gen(formatting_gen)
     {if(0 === formatting_gen[0])
       {var match=formatting_gen[1],str=match[2];return str}
      var match$0=formatting_gen[1],str$0=match$0[2];
      return str$0}
    function bprint_char_literal(buf,chr)
     {return 37 === chr?buffer_add_string(buf,cst$19):buffer_add_char(buf,chr)}
    function bprint_string_literal(buf,str)
     {var _rR_=caml_ml_string_length(str) - 1 | 0,_rQ_=0;
      if(! (_rR_ < 0))
       {var i=_rQ_;
        for(;;)
         {bprint_char_literal(buf,caml_string_get(str,i));
          var _rS_=i + 1 | 0;
          if(_rR_ !== i){var i=_rS_;continue}
          break}}
      return 0}
    function bprint_fmtty(buf,fmtty)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        return 0;
       else
        switch(fmtty$0[0])
         {case 0:
           var rest=fmtty$0[1];
           buffer_add_string(buf,cst_c);
           var fmtty$0=rest;
           continue;
          case 1:
           var rest$0=fmtty$0[1];
           buffer_add_string(buf,cst_s);
           var fmtty$0=rest$0;
           continue;
          case 2:
           var rest$1=fmtty$0[1];
           buffer_add_string(buf,cst_i);
           var fmtty$0=rest$1;
           continue;
          case 3:
           var rest$2=fmtty$0[1];
           buffer_add_string(buf,cst_li);
           var fmtty$0=rest$2;
           continue;
          case 4:
           var rest$3=fmtty$0[1];
           buffer_add_string(buf,cst_ni);
           var fmtty$0=rest$3;
           continue;
          case 5:
           var rest$4=fmtty$0[1];
           buffer_add_string(buf,cst_Li);
           var fmtty$0=rest$4;
           continue;
          case 6:
           var rest$5=fmtty$0[1];
           buffer_add_string(buf,cst_f);
           var fmtty$0=rest$5;
           continue;
          case 7:
           var rest$6=fmtty$0[1];
           buffer_add_string(buf,cst_B);
           var fmtty$0=rest$6;
           continue;
          case 8:
           var rest$7=fmtty$0[2],sub_fmtty=fmtty$0[1];
           buffer_add_string(buf,cst$20);
           bprint_fmtty(buf,sub_fmtty);
           buffer_add_string(buf,cst$21);
           var fmtty$0=rest$7;
           continue;
          case 9:
           var rest$8=fmtty$0[3],sub_fmtty$0=fmtty$0[1];
           buffer_add_string(buf,cst$22);
           bprint_fmtty(buf,sub_fmtty$0);
           buffer_add_string(buf,cst$23);
           var fmtty$0=rest$8;
           continue;
          case 10:
           var rest$9=fmtty$0[1];
           buffer_add_string(buf,cst_a);
           var fmtty$0=rest$9;
           continue;
          case 11:
           var rest$10=fmtty$0[1];
           buffer_add_string(buf,cst_t$0);
           var fmtty$0=rest$10;
           continue;
          case 12:
           var rest$11=fmtty$0[1];
           buffer_add_string(buf,cst$24);
           var fmtty$0=rest$11;
           continue;
          case 13:
           var rest$12=fmtty$0[1];
           buffer_add_string(buf,cst_r$0);
           var fmtty$0=rest$12;
           continue;
          default:
           var rest$13=fmtty$0[1];
           buffer_add_string(buf,cst_r$1);
           var fmtty$0=rest$13;
           continue}}
    function int_of_custom_arity(param)
     {if(param){var x=param[1];return 1 + int_of_custom_arity(x) | 0}return 0}
    function string_of_fmt(fmt$1)
     {var buf=buffer_create(16),fmt=fmt$1,ign_flag=0;
      a:
      for(;;)
       if(typeof fmt === "number")
        return buffer_contents(buf);
       else
        switch(fmt[0])
         {case 0:
           var rest=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,99);
           var fmt=rest,ign_flag=0;
           continue;
          case 1:
           var rest$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,67);
           var fmt=rest$0,ign_flag=0;
           continue;
          case 2:
           var rest$1=fmt[2],pad=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad);
           buffer_add_char(buf,115);
           var fmt=rest$1,ign_flag=0;
           continue;
          case 3:
           var rest$2=fmt[2],pad$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad$0);
           buffer_add_char(buf,83);
           var fmt=rest$2,ign_flag=0;
           continue;
          case 4:
           var rest$3=fmt[4],prec=fmt[3],pad$1=fmt[2],iconv=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_iconv_flag(buf,iconv);
           bprint_padding(buf,pad$1);
           bprint_precision(buf,prec);
           buffer_add_char(buf,char_of_iconv(iconv));
           var fmt=rest$3,ign_flag=0;
           continue;
          case 5:
           var rest$4=fmt[4],prec$0=fmt[3],pad$2=fmt[2],iconv$0=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$0,pad$2,prec$0,108);
           var fmt=rest$4,ign_flag=0;
           continue;
          case 6:
           var rest$5=fmt[4],prec$1=fmt[3],pad$3=fmt[2],iconv$1=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$1,pad$3,prec$1,110);
           var fmt=rest$5,ign_flag=0;
           continue;
          case 7:
           var rest$6=fmt[4],prec$2=fmt[3],pad$4=fmt[2],iconv$2=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$2,pad$4,prec$2,76);
           var fmt=rest$6,ign_flag=0;
           continue;
          case 8:
           var rest$7=fmt[4],prec$3=fmt[3],pad$5=fmt[2],fconv=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_fconv_flag(buf,fconv);
           bprint_padding(buf,pad$5);
           bprint_precision(buf,prec$3);
           buffer_add_char(buf,char_of_fconv(fconv));
           var fmt=rest$7,ign_flag=0;
           continue;
          case 9:
           var rest$8=fmt[2],pad$6=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad$6);
           buffer_add_char(buf,66);
           var fmt=rest$8,ign_flag=0;
           continue;
          case 10:
           var rest$9=fmt[1];
           buffer_add_string(buf,cst$25);
           var fmt=rest$9;
           continue;
          case 11:
           var rest$10=fmt[2],str=fmt[1];
           bprint_string_literal(buf,str);
           var fmt=rest$10;
           continue;
          case 12:
           var rest$11=fmt[2],chr$0=fmt[1];
           bprint_char_literal(buf,chr$0);
           var fmt=rest$11;
           continue;
          case 13:
           var rest$12=fmt[3],fmtty=fmt[2],pad_opt=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,pad_opt);
           buffer_add_char(buf,123);
           bprint_fmtty(buf,fmtty);
           buffer_add_char(buf,37);
           buffer_add_char(buf,125);
           var fmt=rest$12,ign_flag=0;
           continue;
          case 14:
           var rest$13=fmt[3],fmtty$0=fmt[2],pad_opt$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,pad_opt$0);
           buffer_add_char(buf,40);
           bprint_fmtty(buf,fmtty$0);
           buffer_add_char(buf,37);
           buffer_add_char(buf,41);
           var fmt=rest$13,ign_flag=0;
           continue;
          case 15:
           var rest$14=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,97);
           var fmt=rest$14,ign_flag=0;
           continue;
          case 16:
           var rest$15=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,116);
           var fmt=rest$15,ign_flag=0;
           continue;
          case 17:
           var rest$16=fmt[2],fmting_lit=fmt[1];
           bprint_string_literal(buf,string_of_formatting_lit(fmting_lit));
           var fmt=rest$16;
           continue;
          case 18:
           var rest$17=fmt[2],fmting_gen=fmt[1];
           bprint_string_literal(buf,cst$26);
           bprint_string_literal(buf,string_of_formatting_gen(fmting_gen));
           var fmt=rest$17;
           continue;
          case 19:
           var rest$18=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,114);
           var fmt=rest$18,ign_flag=0;
           continue;
          case 20:
           var rest$19=fmt[3],char_set=fmt[2],width_opt=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,width_opt);
           var
            print_char=
             function(buf,i)
              {var c=char_of_int(i);
               return 37 === c
                       ?(buffer_add_char(buf,37),buffer_add_char(buf,37))
                       :64 === c
                         ?(buffer_add_char(buf,37),buffer_add_char(buf,64))
                         :buffer_add_char(buf,c)};
           buffer_add_char(buf,91);
           var
            _rG_=
             is_in_char_set(char_set,0)
              ?(buffer_add_char(buf,94),rev_char_set(char_set))
              :char_set,
            is_alone$0=
             function(_rL_)
              {function is_alone(c)
                {var
                  after=chr(c + 1 | 0),
                  before=chr(c - 1 | 0),
                  _rM_=is_in_char_set(_rL_,c);
                 if(_rM_)
                  var
                   _rN_=is_in_char_set(_rL_,before),
                   _rO_=_rN_?is_in_char_set(_rL_,after):_rN_,
                   _rP_=1 - _rO_;
                 else
                  var _rP_=_rM_;
                 return _rP_}
               return is_alone},
            is_alone=is_alone$0(_rG_);
           if(is_alone(93))buffer_add_char(buf,93);
           var i=1;
           b:
           for(;;)
            {if(i < 256)
              {if(! is_in_char_set(_rG_,char_of_int(i)))
                {var i$0=i + 1 | 0,i=i$0;continue}
               var match=char_of_int(i),switcher=match - 45 | 0;
               if(48 < switcher >>> 0)
                var switch$0=210 <= switcher?(print_char(buf,255),1):0;
               else
                {var switcher$0=switcher - 1 | 0;
                 if(46 < switcher$0 >>> 0){var i$2=i + 1 | 0,i=i$2;continue}
                 var switch$0=0}
               if(! switch$0)
                {var i$1=i + 1 | 0;
                 if(! is_in_char_set(_rG_,char_of_int(i$1)))
                  {print_char(buf,i$1 - 1 | 0);
                   var i$6=i$1 + 1 | 0,i=i$6;
                   continue}
                 var match$0=char_of_int(i$1),switcher$1=match$0 - 45 | 0;
                 if(48 < switcher$1 >>> 0)
                  var
                   switch$1=
                    210 <= switcher$1
                     ?(print_char(buf,254),print_char(buf,255),1)
                     :0;
                 else
                  {var switcher$2=switcher$1 - 1 | 0;
                   if(46 < switcher$2 >>> 0)
                    {if(! is_in_char_set(_rG_,char_of_int(i$1 + 1 | 0)))
                      {print_char(buf,i$1 - 1 | 0);
                       var i$5=i$1 + 1 | 0,i=i$5;
                       continue}
                     var switch$1=0}
                   else
                    var switch$1=0}
                 if(! switch$1)
                  {if(! is_in_char_set(_rG_,char_of_int(i$1 + 1 | 0)))
                    {print_char(buf,i$1 - 1 | 0);
                     print_char(buf,i$1);
                     var i$4=i$1 + 2 | 0,i=i$4;
                     continue}
                   var j=i$1 + 2 | 0,i$3=i$1 - 1 | 0,j$0=j;
                   for(;;)
                    {if(256 !== j$0)
                      if(is_in_char_set(_rG_,char_of_int(j$0)))
                       {var j$1=j$0 + 1 | 0,j$0=j$1;continue}
                     print_char(buf,i$3);
                     print_char(buf,45);
                     print_char(buf,j$0 - 1 | 0);
                     if(j$0 < 256){var i$7=j$0 + 1 | 0,i=i$7;continue b}
                     break}}}}
             if(is_alone(45))buffer_add_char(buf,45);
             buffer_add_char(buf,93);
             var fmt=rest$19,ign_flag=0;
             continue a}
          case 21:
           var rest$20=fmt[2],counter=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           switch(counter)
            {case 0:var _rH_=108;break;
             case 1:var _rH_=110;break;
             default:var _rH_=78}
           buffer_add_char(buf,_rH_);
           var fmt=rest$20,ign_flag=0;
           continue;
          case 22:
           var rest$21=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_string_literal(buf,cst_0c);
           var fmt=rest$21,ign_flag=0;
           continue;
          case 23:
           var
            rest$22=fmt[2],
            ign=fmt[1],
            match$1=param_format_of_ignored_format(ign,rest$22),
            fmt$0=match$1[1],
            fmt=fmt$0,
            ign_flag=1;
           continue;
          default:
           var
            rest$23=fmt[3],
            arity=fmt[1],
            _rJ_=int_of_custom_arity(arity),
            _rI_=1;
           if(! (_rJ_ < 1))
            {var i$8=_rI_;
             for(;;)
              {buffer_add_char(buf,37);
               bprint_ignored_flag(buf,ign_flag);
               buffer_add_char(buf,63);
               var _rK_=i$8 + 1 | 0;
               if(_rJ_ !== i$8){var i$8=_rK_;continue}
               break}}
           var fmt=rest$23,ign_flag=0;
           continue}}
    function symm(param)
     {if(typeof param === "number")
       return 0;
      else
       switch(param[0])
        {case 0:var rest=param[1];return [0,symm(rest)];
         case 1:var rest$0=param[1];return [1,symm(rest$0)];
         case 2:var rest$1=param[1];return [2,symm(rest$1)];
         case 3:var rest$2=param[1];return [3,symm(rest$2)];
         case 4:var rest$3=param[1];return [4,symm(rest$3)];
         case 5:var rest$4=param[1];return [5,symm(rest$4)];
         case 6:var rest$5=param[1];return [6,symm(rest$5)];
         case 7:var rest$6=param[1];return [7,symm(rest$6)];
         case 8:var rest$7=param[2],ty=param[1];return [8,ty,symm(rest$7)];
         case 9:
          var rest$8=param[3],ty2=param[2],ty1=param[1];
          return [9,ty2,ty1,symm(rest$8)];
         case 10:var rest$9=param[1];return [10,symm(rest$9)];
         case 11:var rest$10=param[1];return [11,symm(rest$10)];
         case 12:var rest$11=param[1];return [12,symm(rest$11)];
         case 13:var rest$12=param[1];return [13,symm(rest$12)];
         default:var rest$13=param[1];return [14,symm(rest$13)]}}
    function fmtty_rel_det(param)
     {if(typeof param === "number")
       {var
         _ri_=function(param){return 0},
         _rj_=function(param){return 0},
         _rk_=function(param){return 0};
        return [0,function(param){return 0},_rk_,_rj_,_ri_]}
      else
       switch(param[0])
        {case 0:
          var
           rest=param[1],
           match=fmtty_rel_det(rest),
           de=match[4],
           ed=match[3],
           af=match[2],
           fa=match[1],
           _rl_=function(param){caml_call1(af,0);return 0};
          return [0,function(param){caml_call1(fa,0);return 0},_rl_,ed,de];
         case 1:
          var
           rest$0=param[1],
           match$0=fmtty_rel_det(rest$0),
           de$0=match$0[4],
           ed$0=match$0[3],
           af$0=match$0[2],
           fa$0=match$0[1],
           _rm_=function(param){caml_call1(af$0,0);return 0};
          return [0,
                  function(param){caml_call1(fa$0,0);return 0},
                  _rm_,
                  ed$0,
                  de$0];
         case 2:
          var
           rest$1=param[1],
           match$1=fmtty_rel_det(rest$1),
           de$1=match$1[4],
           ed$1=match$1[3],
           af$1=match$1[2],
           fa$1=match$1[1],
           _rn_=function(param){caml_call1(af$1,0);return 0};
          return [0,
                  function(param){caml_call1(fa$1,0);return 0},
                  _rn_,
                  ed$1,
                  de$1];
         case 3:
          var
           rest$2=param[1],
           match$2=fmtty_rel_det(rest$2),
           de$2=match$2[4],
           ed$2=match$2[3],
           af$2=match$2[2],
           fa$2=match$2[1],
           _ro_=function(param){caml_call1(af$2,0);return 0};
          return [0,
                  function(param){caml_call1(fa$2,0);return 0},
                  _ro_,
                  ed$2,
                  de$2];
         case 4:
          var
           rest$3=param[1],
           match$3=fmtty_rel_det(rest$3),
           de$3=match$3[4],
           ed$3=match$3[3],
           af$3=match$3[2],
           fa$3=match$3[1],
           _rp_=function(param){caml_call1(af$3,0);return 0};
          return [0,
                  function(param){caml_call1(fa$3,0);return 0},
                  _rp_,
                  ed$3,
                  de$3];
         case 5:
          var
           rest$4=param[1],
           match$4=fmtty_rel_det(rest$4),
           de$4=match$4[4],
           ed$4=match$4[3],
           af$4=match$4[2],
           fa$4=match$4[1],
           _rq_=function(param){caml_call1(af$4,0);return 0};
          return [0,
                  function(param){caml_call1(fa$4,0);return 0},
                  _rq_,
                  ed$4,
                  de$4];
         case 6:
          var
           rest$5=param[1],
           match$5=fmtty_rel_det(rest$5),
           de$5=match$5[4],
           ed$5=match$5[3],
           af$5=match$5[2],
           fa$5=match$5[1],
           _rr_=function(param){caml_call1(af$5,0);return 0};
          return [0,
                  function(param){caml_call1(fa$5,0);return 0},
                  _rr_,
                  ed$5,
                  de$5];
         case 7:
          var
           rest$6=param[1],
           match$6=fmtty_rel_det(rest$6),
           de$6=match$6[4],
           ed$6=match$6[3],
           af$6=match$6[2],
           fa$6=match$6[1],
           _rs_=function(param){caml_call1(af$6,0);return 0};
          return [0,
                  function(param){caml_call1(fa$6,0);return 0},
                  _rs_,
                  ed$6,
                  de$6];
         case 8:
          var
           rest$7=param[2],
           match$7=fmtty_rel_det(rest$7),
           de$7=match$7[4],
           ed$7=match$7[3],
           af$7=match$7[2],
           fa$7=match$7[1],
           _rt_=function(param){caml_call1(af$7,0);return 0};
          return [0,
                  function(param){caml_call1(fa$7,0);return 0},
                  _rt_,
                  ed$7,
                  de$7];
         case 9:
          var
           rest$8=param[3],
           ty2=param[2],
           ty1=param[1],
           match$8=fmtty_rel_det(rest$8),
           de$8=match$8[4],
           ed$8=match$8[3],
           af$8=match$8[2],
           fa$8=match$8[1],
           ty=trans(symm(ty1),ty2),
           match$9=fmtty_rel_det(ty),
           jd=match$9[4],
           dj=match$9[3],
           ga=match$9[2],
           ag=match$9[1],
           _ru_=function(param){caml_call1(jd,0);caml_call1(de$8,0);return 0},
           _rv_=function(param){caml_call1(ed$8,0);caml_call1(dj,0);return 0},
           _rw_=function(param){caml_call1(ga,0);caml_call1(af$8,0);return 0};
          return [0,
                  function(param)
                   {caml_call1(fa$8,0);caml_call1(ag,0);return 0},
                  _rw_,
                  _rv_,
                  _ru_];
         case 10:
          var
           rest$9=param[1],
           match$10=fmtty_rel_det(rest$9),
           de$9=match$10[4],
           ed$9=match$10[3],
           af$9=match$10[2],
           fa$9=match$10[1],
           _rx_=function(param){caml_call1(af$9,0);return 0};
          return [0,
                  function(param){caml_call1(fa$9,0);return 0},
                  _rx_,
                  ed$9,
                  de$9];
         case 11:
          var
           rest$10=param[1],
           match$11=fmtty_rel_det(rest$10),
           de$10=match$11[4],
           ed$10=match$11[3],
           af$10=match$11[2],
           fa$10=match$11[1],
           _ry_=function(param){caml_call1(af$10,0);return 0};
          return [0,
                  function(param){caml_call1(fa$10,0);return 0},
                  _ry_,
                  ed$10,
                  de$10];
         case 12:
          var
           rest$11=param[1],
           match$12=fmtty_rel_det(rest$11),
           de$11=match$12[4],
           ed$11=match$12[3],
           af$11=match$12[2],
           fa$11=match$12[1],
           _rz_=function(param){caml_call1(af$11,0);return 0};
          return [0,
                  function(param){caml_call1(fa$11,0);return 0},
                  _rz_,
                  ed$11,
                  de$11];
         case 13:
          var
           rest$12=param[1],
           match$13=fmtty_rel_det(rest$12),
           de$12=match$13[4],
           ed$12=match$13[3],
           af$12=match$13[2],
           fa$12=match$13[1],
           _rA_=function(param){caml_call1(de$12,0);return 0},
           _rB_=function(param){caml_call1(ed$12,0);return 0},
           _rC_=function(param){caml_call1(af$12,0);return 0};
          return [0,
                  function(param){caml_call1(fa$12,0);return 0},
                  _rC_,
                  _rB_,
                  _rA_];
         default:
          var
           rest$13=param[1],
           match$14=fmtty_rel_det(rest$13),
           de$13=match$14[4],
           ed$13=match$14[3],
           af$13=match$14[2],
           fa$13=match$14[1],
           _rD_=function(param){caml_call1(de$13,0);return 0},
           _rE_=function(param){caml_call1(ed$13,0);return 0},
           _rF_=function(param){caml_call1(af$13,0);return 0};
          return [0,
                  function(param){caml_call1(fa$13,0);return 0},
                  _rF_,
                  _rE_,
                  _rD_]}}
    function trans(ty1,match)
     {if(typeof ty1 === "number")
       if(typeof match === "number")
        return 0;
       else
        switch(match[0])
         {case 10:var switch$0=0;break;
          case 11:var switch$0=1;break;
          case 12:var switch$0=2;break;
          case 13:var switch$0=3;break;
          case 14:var switch$0=4;break;
          case 8:var switch$0=5;break;
          case 9:var switch$0=6;break;
          default:throw [0,Assert_failure,___]}
      else
       switch(ty1[0])
        {case 0:
          var _q1_=ty1[1];
          if(typeof match === "number")
           var switch$1=1;
          else
           switch(match[0])
            {case 0:var rest2=match[1];return [0,trans(_q1_,rest2)];
             case 8:var switch$0=5,switch$1=0;break;
             case 9:var switch$0=6,switch$1=0;break;
             case 10:var switch$0=0,switch$1=0;break;
             case 11:var switch$0=1,switch$1=0;break;
             case 12:var switch$0=2,switch$1=0;break;
             case 13:var switch$0=3,switch$1=0;break;
             case 14:var switch$0=4,switch$1=0;break;
             default:var switch$1=1}
          if(switch$1)var switch$0=7;
          break;
         case 1:
          var _q2_=ty1[1];
          if(typeof match === "number")
           var switch$2=1;
          else
           switch(match[0])
            {case 1:var rest2$0=match[1];return [1,trans(_q2_,rest2$0)];
             case 8:var switch$0=5,switch$2=0;break;
             case 9:var switch$0=6,switch$2=0;break;
             case 10:var switch$0=0,switch$2=0;break;
             case 11:var switch$0=1,switch$2=0;break;
             case 12:var switch$0=2,switch$2=0;break;
             case 13:var switch$0=3,switch$2=0;break;
             case 14:var switch$0=4,switch$2=0;break;
             default:var switch$2=1}
          if(switch$2)var switch$0=7;
          break;
         case 2:
          var _q3_=ty1[1];
          if(typeof match === "number")
           var switch$3=1;
          else
           switch(match[0])
            {case 2:var rest2$1=match[1];return [2,trans(_q3_,rest2$1)];
             case 8:var switch$0=5,switch$3=0;break;
             case 9:var switch$0=6,switch$3=0;break;
             case 10:var switch$0=0,switch$3=0;break;
             case 11:var switch$0=1,switch$3=0;break;
             case 12:var switch$0=2,switch$3=0;break;
             case 13:var switch$0=3,switch$3=0;break;
             case 14:var switch$0=4,switch$3=0;break;
             default:var switch$3=1}
          if(switch$3)var switch$0=7;
          break;
         case 3:
          var _q4_=ty1[1];
          if(typeof match === "number")
           var switch$4=1;
          else
           switch(match[0])
            {case 3:var rest2$2=match[1];return [3,trans(_q4_,rest2$2)];
             case 8:var switch$0=5,switch$4=0;break;
             case 9:var switch$0=6,switch$4=0;break;
             case 10:var switch$0=0,switch$4=0;break;
             case 11:var switch$0=1,switch$4=0;break;
             case 12:var switch$0=2,switch$4=0;break;
             case 13:var switch$0=3,switch$4=0;break;
             case 14:var switch$0=4,switch$4=0;break;
             default:var switch$4=1}
          if(switch$4)var switch$0=7;
          break;
         case 4:
          var _q5_=ty1[1];
          if(typeof match === "number")
           var switch$5=1;
          else
           switch(match[0])
            {case 4:var rest2$3=match[1];return [4,trans(_q5_,rest2$3)];
             case 8:var switch$0=5,switch$5=0;break;
             case 9:var switch$0=6,switch$5=0;break;
             case 10:var switch$0=0,switch$5=0;break;
             case 11:var switch$0=1,switch$5=0;break;
             case 12:var switch$0=2,switch$5=0;break;
             case 13:var switch$0=3,switch$5=0;break;
             case 14:var switch$0=4,switch$5=0;break;
             default:var switch$5=1}
          if(switch$5)var switch$0=7;
          break;
         case 5:
          var _q6_=ty1[1];
          if(typeof match === "number")
           var switch$6=1;
          else
           switch(match[0])
            {case 5:var rest2$4=match[1];return [5,trans(_q6_,rest2$4)];
             case 8:var switch$0=5,switch$6=0;break;
             case 9:var switch$0=6,switch$6=0;break;
             case 10:var switch$0=0,switch$6=0;break;
             case 11:var switch$0=1,switch$6=0;break;
             case 12:var switch$0=2,switch$6=0;break;
             case 13:var switch$0=3,switch$6=0;break;
             case 14:var switch$0=4,switch$6=0;break;
             default:var switch$6=1}
          if(switch$6)var switch$0=7;
          break;
         case 6:
          var _q7_=ty1[1];
          if(typeof match === "number")
           var switch$7=1;
          else
           switch(match[0])
            {case 6:var rest2$5=match[1];return [6,trans(_q7_,rest2$5)];
             case 8:var switch$0=5,switch$7=0;break;
             case 9:var switch$0=6,switch$7=0;break;
             case 10:var switch$0=0,switch$7=0;break;
             case 11:var switch$0=1,switch$7=0;break;
             case 12:var switch$0=2,switch$7=0;break;
             case 13:var switch$0=3,switch$7=0;break;
             case 14:var switch$0=4,switch$7=0;break;
             default:var switch$7=1}
          if(switch$7)var switch$0=7;
          break;
         case 7:
          var _q8_=ty1[1];
          if(typeof match === "number")
           var switch$8=1;
          else
           switch(match[0])
            {case 7:var rest2$6=match[1];return [7,trans(_q8_,rest2$6)];
             case 8:var switch$0=5,switch$8=0;break;
             case 9:var switch$0=6,switch$8=0;break;
             case 10:var switch$0=0,switch$8=0;break;
             case 11:var switch$0=1,switch$8=0;break;
             case 12:var switch$0=2,switch$8=0;break;
             case 13:var switch$0=3,switch$8=0;break;
             case 14:var switch$0=4,switch$8=0;break;
             default:var switch$8=1}
          if(switch$8)var switch$0=7;
          break;
         case 8:
          var _q9_=ty1[2],_q__=ty1[1];
          if(typeof match === "number")
           var switch$9=1;
          else
           switch(match[0])
            {case 8:
              var rest2$7=match[2],ty2=match[1],_q$_=trans(_q9_,rest2$7);
              return [8,trans(_q__,ty2),_q$_];
             case 10:var switch$0=0,switch$9=0;break;
             case 11:var switch$0=1,switch$9=0;break;
             case 12:var switch$0=2,switch$9=0;break;
             case 13:var switch$0=3,switch$9=0;break;
             case 14:var switch$0=4,switch$9=0;break;
             default:var switch$9=1}
          if(switch$9)throw [0,Assert_failure,_ah_];
          break;
         case 9:
          var _ra_=ty1[3],_rb_=ty1[2],_rc_=ty1[1];
          if(typeof match === "number")
           var switch$10=1;
          else
           switch(match[0])
            {case 8:var switch$0=5,switch$10=0;break;
             case 9:
              var
               rest2$8=match[3],
               ty22=match[2],
               ty21=match[1],
               ty=trans(symm(_rb_),ty21),
               match$0=fmtty_rel_det(ty),
               f4=match$0[4],
               f2=match$0[2];
              caml_call1(f2,0);
              caml_call1(f4,0);
              return [9,_rc_,ty22,trans(_ra_,rest2$8)];
             case 10:var switch$0=0,switch$10=0;break;
             case 11:var switch$0=1,switch$10=0;break;
             case 12:var switch$0=2,switch$10=0;break;
             case 13:var switch$0=3,switch$10=0;break;
             case 14:var switch$0=4,switch$10=0;break;
             default:var switch$10=1}
          if(switch$10)throw [0,Assert_failure,_ai_];
          break;
         case 10:
          var _rd_=ty1[1];
          if(typeof match !== "number" && 10 === match[0])
           {var rest2$9=match[1];return [10,trans(_rd_,rest2$9)]}
          throw [0,Assert_failure,_aj_];
         case 11:
          var _re_=ty1[1];
          if(typeof match === "number")
           var switch$11=1;
          else
           switch(match[0])
            {case 10:var switch$0=0,switch$11=0;break;
             case 11:var rest2$10=match[1];return [11,trans(_re_,rest2$10)];
             default:var switch$11=1}
          if(switch$11)throw [0,Assert_failure,_ak_];
          break;
         case 12:
          var _rf_=ty1[1];
          if(typeof match === "number")
           var switch$12=1;
          else
           switch(match[0])
            {case 10:var switch$0=0,switch$12=0;break;
             case 11:var switch$0=1,switch$12=0;break;
             case 12:var rest2$11=match[1];return [12,trans(_rf_,rest2$11)];
             default:var switch$12=1}
          if(switch$12)throw [0,Assert_failure,_al_];
          break;
         case 13:
          var _rg_=ty1[1];
          if(typeof match === "number")
           var switch$13=1;
          else
           switch(match[0])
            {case 10:var switch$0=0,switch$13=0;break;
             case 11:var switch$0=1,switch$13=0;break;
             case 12:var switch$0=2,switch$13=0;break;
             case 13:var rest2$12=match[1];return [13,trans(_rg_,rest2$12)];
             default:var switch$13=1}
          if(switch$13)throw [0,Assert_failure,_am_];
          break;
         default:
          var _rh_=ty1[1];
          if(typeof match === "number")
           var switch$14=1;
          else
           switch(match[0])
            {case 10:var switch$0=0,switch$14=0;break;
             case 11:var switch$0=1,switch$14=0;break;
             case 12:var switch$0=2,switch$14=0;break;
             case 13:var switch$0=3,switch$14=0;break;
             case 14:var rest2$13=match[1];return [14,trans(_rh_,rest2$13)];
             default:var switch$14=1}
          if(switch$14)throw [0,Assert_failure,_an_]}
      switch(switch$0)
       {case 0:throw [0,Assert_failure,_ab_];
        case 1:throw [0,Assert_failure,_ac_];
        case 2:throw [0,Assert_failure,_ad_];
        case 3:throw [0,Assert_failure,_ae_];
        case 4:throw [0,Assert_failure,_af_];
        case 5:throw [0,Assert_failure,_$_];
        case 6:throw [0,Assert_failure,_aa_];
        default:throw [0,Assert_failure,_ag_]}}
    function fmtty_of_padding_fmtty(pad,fmtty)
     {return typeof pad === "number"?fmtty:0 === pad[0]?fmtty:[2,fmtty]}
    function fmtty_of_custom(arity,fmtty)
     {if(arity)
       {var arity$0=arity[1];return [12,fmtty_of_custom(arity$0,fmtty)]}
      return fmtty}
    function fmtty_of_fmt(fmtty)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        return 0;
       else
        switch(fmtty$0[0])
         {case 0:var rest=fmtty$0[1];return [0,fmtty_of_fmt(rest)];
          case 1:var rest$0=fmtty$0[1];return [0,fmtty_of_fmt(rest$0)];
          case 2:
           var rest$1=fmtty$0[2],pad=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad,[1,fmtty_of_fmt(rest$1)]);
          case 3:
           var rest$2=fmtty$0[2],pad$0=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad$0,[1,fmtty_of_fmt(rest$2)]);
          case 4:
           var
            rest$3=fmtty$0[4],
            prec=fmtty$0[3],
            pad$1=fmtty$0[2],
            ty_rest=fmtty_of_fmt(rest$3),
            prec_ty=fmtty_of_precision_fmtty(prec,[2,ty_rest]);
           return fmtty_of_padding_fmtty(pad$1,prec_ty);
          case 5:
           var
            rest$4=fmtty$0[4],
            prec$0=fmtty$0[3],
            pad$2=fmtty$0[2],
            ty_rest$0=fmtty_of_fmt(rest$4),
            prec_ty$0=fmtty_of_precision_fmtty(prec$0,[3,ty_rest$0]);
           return fmtty_of_padding_fmtty(pad$2,prec_ty$0);
          case 6:
           var
            rest$5=fmtty$0[4],
            prec$1=fmtty$0[3],
            pad$3=fmtty$0[2],
            ty_rest$1=fmtty_of_fmt(rest$5),
            prec_ty$1=fmtty_of_precision_fmtty(prec$1,[4,ty_rest$1]);
           return fmtty_of_padding_fmtty(pad$3,prec_ty$1);
          case 7:
           var
            rest$6=fmtty$0[4],
            prec$2=fmtty$0[3],
            pad$4=fmtty$0[2],
            ty_rest$2=fmtty_of_fmt(rest$6),
            prec_ty$2=fmtty_of_precision_fmtty(prec$2,[5,ty_rest$2]);
           return fmtty_of_padding_fmtty(pad$4,prec_ty$2);
          case 8:
           var
            rest$7=fmtty$0[4],
            prec$3=fmtty$0[3],
            pad$5=fmtty$0[2],
            ty_rest$3=fmtty_of_fmt(rest$7),
            prec_ty$3=fmtty_of_precision_fmtty(prec$3,[6,ty_rest$3]);
           return fmtty_of_padding_fmtty(pad$5,prec_ty$3);
          case 9:
           var rest$8=fmtty$0[2],pad$6=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad$6,[7,fmtty_of_fmt(rest$8)]);
          case 10:var fmtty$1=fmtty$0[1],fmtty$0=fmtty$1;continue;
          case 11:var fmtty$2=fmtty$0[2],fmtty$0=fmtty$2;continue;
          case 12:var fmtty$3=fmtty$0[2],fmtty$0=fmtty$3;continue;
          case 13:
           var rest$9=fmtty$0[3],ty=fmtty$0[2];
           return [8,ty,fmtty_of_fmt(rest$9)];
          case 14:
           var rest$10=fmtty$0[3],ty$0=fmtty$0[2];
           return [9,ty$0,ty$0,fmtty_of_fmt(rest$10)];
          case 15:var rest$11=fmtty$0[1];return [10,fmtty_of_fmt(rest$11)];
          case 16:var rest$12=fmtty$0[1];return [11,fmtty_of_fmt(rest$12)];
          case 17:var fmtty$4=fmtty$0[2],fmtty$0=fmtty$4;continue;
          case 18:
           var
            rest$13=fmtty$0[2],
            fmting_gen=fmtty$0[1],
            _qZ_=fmtty_of_fmt(rest$13);
           if(0 === fmting_gen[0])
            var match=fmting_gen[1],fmt=match[1],_q0_=fmtty_of_fmt(fmt);
           else
            var
             match$0=fmting_gen[1],
             fmt$0=match$0[1],
             _q0_=fmtty_of_fmt(fmt$0);
           return concat_fmtty(_q0_,_qZ_);
          case 19:var rest$14=fmtty$0[1];return [13,fmtty_of_fmt(rest$14)];
          case 20:var rest$15=fmtty$0[3];return [1,fmtty_of_fmt(rest$15)];
          case 21:var rest$16=fmtty$0[2];return [2,fmtty_of_fmt(rest$16)];
          case 22:var rest$17=fmtty$0[1];return [0,fmtty_of_fmt(rest$17)];
          case 23:
           var rest$18=fmtty$0[2],ign=fmtty$0[1];
           if(typeof ign === "number")
            switch(ign)
             {case 0:var fmtty$0=rest$18;continue;
              case 1:var fmtty$0=rest$18;continue;
              case 2:return [14,fmtty_of_fmt(rest$18)];
              default:var fmtty$0=rest$18;continue}
           else
            switch(ign[0])
             {case 0:var fmtty$0=rest$18;continue;
              case 1:var fmtty$0=rest$18;continue;
              case 2:var fmtty$0=rest$18;continue;
              case 3:var fmtty$0=rest$18;continue;
              case 4:var fmtty$0=rest$18;continue;
              case 5:var fmtty$0=rest$18;continue;
              case 6:var fmtty$0=rest$18;continue;
              case 7:var fmtty$0=rest$18;continue;
              case 8:var fmtty$0=rest$18;continue;
              case 9:
               var fmtty$5=ign[2];
               return concat_fmtty(fmtty$5,fmtty_of_fmt(rest$18));
              case 10:var fmtty$0=rest$18;continue;
              default:var fmtty$0=rest$18;continue}
          default:
           var rest$19=fmtty$0[3],arity=fmtty$0[1];
           return fmtty_of_custom(arity,fmtty_of_fmt(rest$19))}}
    function fmtty_of_precision_fmtty(prec,fmtty)
     {return typeof prec === "number"?0 === prec?fmtty:[2,fmtty]:fmtty}
    var
     Type_mismatch=
      [248,cst_CamlinternalFormat_Type_mismatch,caml_fresh_oo_id(0)];
    function type_padding(pad,match)
     {if(typeof pad === "number")
       return [0,0,match];
      else
       {if(0 === pad[0])
         {var w=pad[2],padty=pad[1];return [0,[0,padty,w],match]}
        if(typeof match !== "number" && 2 === match[0])
         {var rest=match[1],padty$0=pad[1];return [0,[1,padty$0],rest]}
        throw Type_mismatch}}
    function type_padprec(pad,prec,fmtty)
     {var match=type_padding(pad,fmtty);
      if(typeof prec === "number")
       {if(0 === prec)
         {var rest=match[2],pad$0=match[1];return [0,pad$0,0,rest]}
        var _qY_=match[2];
        if(typeof _qY_ !== "number" && 2 === _qY_[0])
         {var rest$0=_qY_[1],pad$1=match[1];return [0,pad$1,1,rest$0]}
        throw Type_mismatch}
      var rest$1=match[2],pad$2=match[1],p=prec[1];
      return [0,pad$2,[0,p],rest$1]}
    function type_format(fmt,fmtty)
     {var _qX_=type_format_gen(fmt,fmtty);
      if(typeof _qX_[2] === "number"){var fmt$0=_qX_[1];return fmt$0}
      throw Type_mismatch}
    function type_ignored_param_one(ign,fmt,fmtty)
     {var match=type_format_gen(fmt,fmtty),fmtty$0=match[2],fmt$0=match[1];
      return [0,[23,ign,fmt$0],fmtty$0]}
    function type_format_gen(fmt,fmtty)
     {if(typeof fmt === "number")
       return [0,0,fmtty];
      else
       switch(fmt[0])
        {case 0:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest=fmtty[1],
             fmt_rest=fmt[1],
             match=type_format_gen(fmt_rest,fmtty_rest),
             fmtty$0=match[2],
             fmt$0=match[1];
            return [0,[0,fmt$0],fmtty$0]}
          break;
         case 1:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest$0=fmtty[1],
             fmt_rest$0=fmt[1],
             match$0=type_format_gen(fmt_rest$0,fmtty_rest$0),
             fmtty$1=match$0[2],
             fmt$1=match$0[1];
            return [0,[1,fmt$1],fmtty$1]}
          break;
         case 2:
          var
           fmt_rest$1=fmt[2],
           pad=fmt[1],
           _qs_=type_padding(pad,fmtty),
           _qt_=_qs_[2],
           _qu_=_qs_[1];
          if(typeof _qt_ !== "number" && 1 === _qt_[0])
           {var
             fmtty_rest$1=_qt_[1],
             match$1=type_format_gen(fmt_rest$1,fmtty_rest$1),
             fmtty$2=match$1[2],
             fmt$2=match$1[1];
            return [0,[2,_qu_,fmt$2],fmtty$2]}
          throw Type_mismatch;
         case 3:
          var
           fmt_rest$2=fmt[2],
           pad$0=fmt[1],
           _qv_=type_padding(pad$0,fmtty),
           _qw_=_qv_[2],
           _qx_=_qv_[1];
          if(typeof _qw_ !== "number" && 1 === _qw_[0])
           {var
             fmtty_rest$2=_qw_[1],
             match$2=type_format_gen(fmt_rest$2,fmtty_rest$2),
             fmtty$3=match$2[2],
             fmt$3=match$2[1];
            return [0,[3,_qx_,fmt$3],fmtty$3]}
          throw Type_mismatch;
         case 4:
          var
           fmt_rest$3=fmt[4],
           prec=fmt[3],
           pad$1=fmt[2],
           iconv=fmt[1],
           _qy_=type_padprec(pad$1,prec,fmtty),
           _qz_=_qy_[3],
           _qA_=_qy_[2],
           _qB_=_qy_[1];
          if(typeof _qz_ !== "number" && 2 === _qz_[0])
           {var
             fmtty_rest$3=_qz_[1],
             match$3=type_format_gen(fmt_rest$3,fmtty_rest$3),
             fmtty$4=match$3[2],
             fmt$4=match$3[1];
            return [0,[4,iconv,_qB_,_qA_,fmt$4],fmtty$4]}
          throw Type_mismatch;
         case 5:
          var
           fmt_rest$4=fmt[4],
           prec$0=fmt[3],
           pad$2=fmt[2],
           iconv$0=fmt[1],
           _qC_=type_padprec(pad$2,prec$0,fmtty),
           _qD_=_qC_[3],
           _qE_=_qC_[2],
           _qF_=_qC_[1];
          if(typeof _qD_ !== "number" && 3 === _qD_[0])
           {var
             fmtty_rest$4=_qD_[1],
             match$4=type_format_gen(fmt_rest$4,fmtty_rest$4),
             fmtty$5=match$4[2],
             fmt$5=match$4[1];
            return [0,[5,iconv$0,_qF_,_qE_,fmt$5],fmtty$5]}
          throw Type_mismatch;
         case 6:
          var
           fmt_rest$5=fmt[4],
           prec$1=fmt[3],
           pad$3=fmt[2],
           iconv$1=fmt[1],
           _qG_=type_padprec(pad$3,prec$1,fmtty),
           _qH_=_qG_[3],
           _qI_=_qG_[2],
           _qJ_=_qG_[1];
          if(typeof _qH_ !== "number" && 4 === _qH_[0])
           {var
             fmtty_rest$5=_qH_[1],
             match$5=type_format_gen(fmt_rest$5,fmtty_rest$5),
             fmtty$6=match$5[2],
             fmt$6=match$5[1];
            return [0,[6,iconv$1,_qJ_,_qI_,fmt$6],fmtty$6]}
          throw Type_mismatch;
         case 7:
          var
           fmt_rest$6=fmt[4],
           prec$2=fmt[3],
           pad$4=fmt[2],
           iconv$2=fmt[1],
           _qK_=type_padprec(pad$4,prec$2,fmtty),
           _qL_=_qK_[3],
           _qM_=_qK_[2],
           _qN_=_qK_[1];
          if(typeof _qL_ !== "number" && 5 === _qL_[0])
           {var
             fmtty_rest$6=_qL_[1],
             match$6=type_format_gen(fmt_rest$6,fmtty_rest$6),
             fmtty$7=match$6[2],
             fmt$7=match$6[1];
            return [0,[7,iconv$2,_qN_,_qM_,fmt$7],fmtty$7]}
          throw Type_mismatch;
         case 8:
          var
           fmt_rest$7=fmt[4],
           prec$3=fmt[3],
           pad$5=fmt[2],
           fconv=fmt[1],
           _qO_=type_padprec(pad$5,prec$3,fmtty),
           _qP_=_qO_[3],
           _qQ_=_qO_[2],
           _qR_=_qO_[1];
          if(typeof _qP_ !== "number" && 6 === _qP_[0])
           {var
             fmtty_rest$7=_qP_[1],
             match$7=type_format_gen(fmt_rest$7,fmtty_rest$7),
             fmtty$8=match$7[2],
             fmt$8=match$7[1];
            return [0,[8,fconv,_qR_,_qQ_,fmt$8],fmtty$8]}
          throw Type_mismatch;
         case 9:
          var
           fmt_rest$8=fmt[2],
           pad$6=fmt[1],
           _qS_=type_padding(pad$6,fmtty),
           _qT_=_qS_[2],
           _qU_=_qS_[1];
          if(typeof _qT_ !== "number" && 7 === _qT_[0])
           {var
             fmtty_rest$8=_qT_[1],
             match$8=type_format_gen(fmt_rest$8,fmtty_rest$8),
             fmtty$9=match$8[2],
             fmt$9=match$8[1];
            return [0,[9,_qU_,fmt$9],fmtty$9]}
          throw Type_mismatch;
         case 10:
          var
           fmt_rest$9=fmt[1],
           match$9=type_format_gen(fmt_rest$9,fmtty),
           fmtty$10=match$9[2],
           fmt$10=match$9[1];
          return [0,[10,fmt$10],fmtty$10];
         case 11:
          var
           fmt_rest$10=fmt[2],
           str=fmt[1],
           match$10=type_format_gen(fmt_rest$10,fmtty),
           fmtty$11=match$10[2],
           fmt$11=match$10[1];
          return [0,[11,str,fmt$11],fmtty$11];
         case 12:
          var
           fmt_rest$11=fmt[2],
           chr=fmt[1],
           match$11=type_format_gen(fmt_rest$11,fmtty),
           fmtty$12=match$11[2],
           fmt$12=match$11[1];
          return [0,[12,chr,fmt$12],fmtty$12];
         case 13:
          if(typeof fmtty !== "number" && 8 === fmtty[0])
           {var
             fmtty_rest$9=fmtty[2],
             sub_fmtty=fmtty[1],
             fmt_rest$12=fmt[3],
             sub_fmtty$0=fmt[2],
             pad_opt=fmt[1];
            if(caml_notequal([0,sub_fmtty$0],[0,sub_fmtty]))
             throw Type_mismatch;
            var
             match$12=type_format_gen(fmt_rest$12,fmtty_rest$9),
             fmtty$13=match$12[2],
             fmt$13=match$12[1];
            return [0,[13,pad_opt,sub_fmtty,fmt$13],fmtty$13]}
          break;
         case 14:
          if(typeof fmtty !== "number" && 9 === fmtty[0])
           {var
             fmtty_rest$10=fmtty[3],
             sub_fmtty1=fmtty[1],
             fmt_rest$13=fmt[3],
             sub_fmtty$1=fmt[2],
             pad_opt$0=fmt[1],
             _qV_=[0,erase_rel(sub_fmtty1)];
            if(caml_notequal([0,erase_rel(sub_fmtty$1)],_qV_))
             throw Type_mismatch;
            var
             match$13=type_format_gen(fmt_rest$13,erase_rel(fmtty_rest$10)),
             fmtty$14=match$13[2],
             fmt$14=match$13[1];
            return [0,[14,pad_opt$0,sub_fmtty1,fmt$14],fmtty$14]}
          break;
         case 15:
          if(typeof fmtty !== "number" && 10 === fmtty[0])
           {var
             fmtty_rest$11=fmtty[1],
             fmt_rest$14=fmt[1],
             match$14=type_format_gen(fmt_rest$14,fmtty_rest$11),
             fmtty$15=match$14[2],
             fmt$15=match$14[1];
            return [0,[15,fmt$15],fmtty$15]}
          break;
         case 16:
          if(typeof fmtty !== "number" && 11 === fmtty[0])
           {var
             fmtty_rest$12=fmtty[1],
             fmt_rest$15=fmt[1],
             match$15=type_format_gen(fmt_rest$15,fmtty_rest$12),
             fmtty$16=match$15[2],
             fmt$16=match$15[1];
            return [0,[16,fmt$16],fmtty$16]}
          break;
         case 17:
          var
           fmt_rest$16=fmt[2],
           formatting_lit=fmt[1],
           match$16=type_format_gen(fmt_rest$16,fmtty),
           fmtty$17=match$16[2],
           fmt$17=match$16[1];
          return [0,[17,formatting_lit,fmt$17],fmtty$17];
         case 18:
          var fmt_rest$17=fmt[2],formatting_gen=fmt[1];
          if(0 === formatting_gen[0])
           {var
             match$20=formatting_gen[1],
             str$0=match$20[2],
             fmt1=match$20[1],
             match$21=type_format_gen(fmt1,fmtty),
             fmtty2=match$21[2],
             fmt2=match$21[1],
             match$22=type_format_gen(fmt_rest$17,fmtty2),
             fmtty3=match$22[2],
             fmt3=match$22[1];
            return [0,[18,[0,[0,fmt2,str$0]],fmt3],fmtty3]}
          var
           match$23=formatting_gen[1],
           str$1=match$23[2],
           fmt1$0=match$23[1],
           match$24=type_format_gen(fmt1$0,fmtty),
           fmtty2$0=match$24[2],
           fmt2$0=match$24[1],
           match$25=type_format_gen(fmt_rest$17,fmtty2$0),
           fmtty3$0=match$25[2],
           fmt3$0=match$25[1];
          return [0,[18,[1,[0,fmt2$0,str$1]],fmt3$0],fmtty3$0];
         case 19:
          if(typeof fmtty !== "number" && 13 === fmtty[0])
           {var
             fmtty_rest$13=fmtty[1],
             fmt_rest$18=fmt[1],
             match$17=type_format_gen(fmt_rest$18,fmtty_rest$13),
             fmtty$18=match$17[2],
             fmt$18=match$17[1];
            return [0,[19,fmt$18],fmtty$18]}
          break;
         case 20:
          if(typeof fmtty !== "number" && 1 === fmtty[0])
           {var
             fmtty_rest$14=fmtty[1],
             fmt_rest$19=fmt[3],
             char_set=fmt[2],
             width_opt=fmt[1],
             match$18=type_format_gen(fmt_rest$19,fmtty_rest$14),
             fmtty$19=match$18[2],
             fmt$19=match$18[1];
            return [0,[20,width_opt,char_set,fmt$19],fmtty$19]}
          break;
         case 21:
          if(typeof fmtty !== "number" && 2 === fmtty[0])
           {var
             fmtty_rest$15=fmtty[1],
             fmt_rest$20=fmt[2],
             counter=fmt[1],
             match$19=type_format_gen(fmt_rest$20,fmtty_rest$15),
             fmtty$20=match$19[2],
             fmt$20=match$19[1];
            return [0,[21,counter,fmt$20],fmtty$20]}
          break;
         case 23:
          var rest=fmt[2],ign=fmt[1];
          if(typeof ign === "number")
           switch(ign)
            {case 0:return type_ignored_param_one(ign,rest,fmtty);
             case 1:return type_ignored_param_one(ign,rest,fmtty);
             case 2:
              if(typeof fmtty !== "number" && 14 === fmtty[0])
               {var
                 fmtty_rest$16=fmtty[1],
                 match$26=type_format_gen(rest,fmtty_rest$16),
                 fmtty$21=match$26[2],
                 fmt$21=match$26[1];
                return [0,[23,2,fmt$21],fmtty$21]}
              throw Type_mismatch;
             default:return type_ignored_param_one(ign,rest,fmtty)}
          else
           switch(ign[0])
            {case 0:return type_ignored_param_one(ign,rest,fmtty);
             case 1:return type_ignored_param_one(ign,rest,fmtty);
             case 2:return type_ignored_param_one(ign,rest,fmtty);
             case 3:return type_ignored_param_one(ign,rest,fmtty);
             case 4:return type_ignored_param_one(ign,rest,fmtty);
             case 5:return type_ignored_param_one(ign,rest,fmtty);
             case 6:return type_ignored_param_one(ign,rest,fmtty);
             case 7:return type_ignored_param_one(ign,rest,fmtty);
             case 8:
              var sub_fmtty$2=ign[2],pad_opt$1=ign[1];
              return type_ignored_param_one
                      ([8,pad_opt$1,sub_fmtty$2],rest,fmtty);
             case 9:
              var
               sub_fmtty$3=ign[2],
               pad_opt$2=ign[1],
               _qW_=type_ignored_format_substitution(sub_fmtty$3,rest,fmtty),
               match$27=_qW_[2],
               fmtty$22=match$27[2],
               fmt$22=match$27[1],
               sub_fmtty$4=_qW_[1];
              return [0,[23,[9,pad_opt$2,sub_fmtty$4],fmt$22],fmtty$22];
             case 10:return type_ignored_param_one(ign,rest,fmtty);
             default:return type_ignored_param_one(ign,rest,fmtty)}
         }
      throw Type_mismatch}
    function type_ignored_format_substitution(sub_fmtty,fmt,match)
     {if(typeof sub_fmtty === "number")
       return [0,0,type_format_gen(fmt,match)];
      else
       switch(sub_fmtty[0])
        {case 0:
          if(typeof match !== "number" && 0 === match[0])
           {var
             fmtty_rest=match[1],
             sub_fmtty_rest=sub_fmtty[1],
             match$0=
              type_ignored_format_substitution(sub_fmtty_rest,fmt,fmtty_rest),
             fmt$0=match$0[2],
             sub_fmtty_rest$0=match$0[1];
            return [0,[0,sub_fmtty_rest$0],fmt$0]}
          break;
         case 1:
          if(typeof match !== "number" && 1 === match[0])
           {var
             fmtty_rest$0=match[1],
             sub_fmtty_rest$1=sub_fmtty[1],
             match$1=
              type_ignored_format_substitution
               (sub_fmtty_rest$1,fmt,fmtty_rest$0),
             fmt$1=match$1[2],
             sub_fmtty_rest$2=match$1[1];
            return [0,[1,sub_fmtty_rest$2],fmt$1]}
          break;
         case 2:
          if(typeof match !== "number" && 2 === match[0])
           {var
             fmtty_rest$1=match[1],
             sub_fmtty_rest$3=sub_fmtty[1],
             match$2=
              type_ignored_format_substitution
               (sub_fmtty_rest$3,fmt,fmtty_rest$1),
             fmt$2=match$2[2],
             sub_fmtty_rest$4=match$2[1];
            return [0,[2,sub_fmtty_rest$4],fmt$2]}
          break;
         case 3:
          if(typeof match !== "number" && 3 === match[0])
           {var
             fmtty_rest$2=match[1],
             sub_fmtty_rest$5=sub_fmtty[1],
             match$3=
              type_ignored_format_substitution
               (sub_fmtty_rest$5,fmt,fmtty_rest$2),
             fmt$3=match$3[2],
             sub_fmtty_rest$6=match$3[1];
            return [0,[3,sub_fmtty_rest$6],fmt$3]}
          break;
         case 4:
          if(typeof match !== "number" && 4 === match[0])
           {var
             fmtty_rest$3=match[1],
             sub_fmtty_rest$7=sub_fmtty[1],
             match$4=
              type_ignored_format_substitution
               (sub_fmtty_rest$7,fmt,fmtty_rest$3),
             fmt$4=match$4[2],
             sub_fmtty_rest$8=match$4[1];
            return [0,[4,sub_fmtty_rest$8],fmt$4]}
          break;
         case 5:
          if(typeof match !== "number" && 5 === match[0])
           {var
             fmtty_rest$4=match[1],
             sub_fmtty_rest$9=sub_fmtty[1],
             match$5=
              type_ignored_format_substitution
               (sub_fmtty_rest$9,fmt,fmtty_rest$4),
             fmt$5=match$5[2],
             sub_fmtty_rest$10=match$5[1];
            return [0,[5,sub_fmtty_rest$10],fmt$5]}
          break;
         case 6:
          if(typeof match !== "number" && 6 === match[0])
           {var
             fmtty_rest$5=match[1],
             sub_fmtty_rest$11=sub_fmtty[1],
             match$6=
              type_ignored_format_substitution
               (sub_fmtty_rest$11,fmt,fmtty_rest$5),
             fmt$6=match$6[2],
             sub_fmtty_rest$12=match$6[1];
            return [0,[6,sub_fmtty_rest$12],fmt$6]}
          break;
         case 7:
          if(typeof match !== "number" && 7 === match[0])
           {var
             fmtty_rest$6=match[1],
             sub_fmtty_rest$13=sub_fmtty[1],
             match$7=
              type_ignored_format_substitution
               (sub_fmtty_rest$13,fmt,fmtty_rest$6),
             fmt$7=match$7[2],
             sub_fmtty_rest$14=match$7[1];
            return [0,[7,sub_fmtty_rest$14],fmt$7]}
          break;
         case 8:
          if(typeof match !== "number" && 8 === match[0])
           {var
             fmtty_rest$7=match[2],
             sub2_fmtty=match[1],
             sub_fmtty_rest$15=sub_fmtty[2],
             sub2_fmtty$0=sub_fmtty[1];
            if(caml_notequal([0,sub2_fmtty$0],[0,sub2_fmtty]))
             throw Type_mismatch;
            var
             match$8=
              type_ignored_format_substitution
               (sub_fmtty_rest$15,fmt,fmtty_rest$7),
             fmt$8=match$8[2],
             sub_fmtty_rest$16=match$8[1];
            return [0,[8,sub2_fmtty,sub_fmtty_rest$16],fmt$8]}
          break;
         case 9:
          if(typeof match !== "number" && 9 === match[0])
           {var
             fmtty_rest$8=match[3],
             sub2_fmtty$1=match[2],
             sub1_fmtty=match[1],
             sub_fmtty_rest$17=sub_fmtty[3],
             sub2_fmtty$2=sub_fmtty[2],
             sub1_fmtty$0=sub_fmtty[1],
             _qq_=[0,erase_rel(sub1_fmtty)];
            if(caml_notequal([0,erase_rel(sub1_fmtty$0)],_qq_))
             throw Type_mismatch;
            var _qr_=[0,erase_rel(sub2_fmtty$1)];
            if(caml_notequal([0,erase_rel(sub2_fmtty$2)],_qr_))
             throw Type_mismatch;
            var
             sub_fmtty$0=trans(symm(sub1_fmtty),sub2_fmtty$1),
             match$9=fmtty_rel_det(sub_fmtty$0),
             f4=match$9[4],
             f2=match$9[2];
            caml_call1(f2,0);
            caml_call1(f4,0);
            var
             match$10=
              type_ignored_format_substitution
               (erase_rel(sub_fmtty_rest$17),fmt,fmtty_rest$8),
             fmt$9=match$10[2],
             sub_fmtty_rest$18=match$10[1];
            return [0,
                    [9,sub1_fmtty,sub2_fmtty$1,symm(sub_fmtty_rest$18)],
                    fmt$9]}
          break;
         case 10:
          if(typeof match !== "number" && 10 === match[0])
           {var
             fmtty_rest$9=match[1],
             sub_fmtty_rest$19=sub_fmtty[1],
             match$11=
              type_ignored_format_substitution
               (sub_fmtty_rest$19,fmt,fmtty_rest$9),
             fmt$10=match$11[2],
             sub_fmtty_rest$20=match$11[1];
            return [0,[10,sub_fmtty_rest$20],fmt$10]}
          break;
         case 11:
          if(typeof match !== "number" && 11 === match[0])
           {var
             fmtty_rest$10=match[1],
             sub_fmtty_rest$21=sub_fmtty[1],
             match$12=
              type_ignored_format_substitution
               (sub_fmtty_rest$21,fmt,fmtty_rest$10),
             fmt$11=match$12[2],
             sub_fmtty_rest$22=match$12[1];
            return [0,[11,sub_fmtty_rest$22],fmt$11]}
          break;
         case 13:
          if(typeof match !== "number" && 13 === match[0])
           {var
             fmtty_rest$11=match[1],
             sub_fmtty_rest$23=sub_fmtty[1],
             match$13=
              type_ignored_format_substitution
               (sub_fmtty_rest$23,fmt,fmtty_rest$11),
             fmt$12=match$13[2],
             sub_fmtty_rest$24=match$13[1];
            return [0,[13,sub_fmtty_rest$24],fmt$12]}
          break;
         case 14:
          if(typeof match !== "number" && 14 === match[0])
           {var
             fmtty_rest$12=match[1],
             sub_fmtty_rest$25=sub_fmtty[1],
             match$14=
              type_ignored_format_substitution
               (sub_fmtty_rest$25,fmt,fmtty_rest$12),
             fmt$13=match$14[2],
             sub_fmtty_rest$26=match$14[1];
            return [0,[14,sub_fmtty_rest$26],fmt$13]}
          break
         }
      throw Type_mismatch}
    function recast(fmt,fmtty){return type_format(fmt,erase_rel(symm(fmtty)))}
    function fix_padding(padty,width,str)
     {var
       len=caml_ml_string_length(str),
       padty$0=0 <= width?padty:0,
       width$0=abs(width);
      if(width$0 <= len)return str;
      var _qp_=2 === padty$0?48:32,res=make(width$0,_qp_);
      switch(padty$0)
       {case 0:blit$0(str,0,res,0,len);break;
        case 1:blit$0(str,0,res,width$0 - len | 0,len);break;
        default:
         if(0 < len)
          {if(43 === caml_string_get(str,0))
            var switch$1=1;
           else
            if(45 === caml_string_get(str,0))
             var switch$1=1;
            else
             if(32 === caml_string_get(str,0))
              var switch$1=1;
             else
              var switch$0=0,switch$1=0;
           if(switch$1)
            {caml_bytes_set(res,0,caml_string_get(str,0));
             blit$0(str,1,res,(width$0 - len | 0) + 1 | 0,len - 1 | 0);
             var switch$0=1}}
         else
          var switch$0=0;
         if(! switch$0)
          {if(1 < len)
            if(48 === caml_string_get(str,0))
             {if(120 === caml_string_get(str,1))
               var switch$3=1;
              else
               if(88 === caml_string_get(str,1))
                var switch$3=1;
               else
                var switch$2=0,switch$3=0;
              if(switch$3)
               {caml_bytes_set(res,1,caml_string_get(str,1));
                blit$0(str,2,res,(width$0 - len | 0) + 2 | 0,len - 2 | 0);
                var switch$2=1}}
            else
             var switch$2=0;
           else
            var switch$2=0;
           if(! switch$2)blit$0(str,0,res,width$0 - len | 0,len)}}
      return res}
    function fix_int_precision(prec,str)
     {var
       prec$0=abs(prec),
       len=caml_ml_string_length(str),
       c=caml_string_get(str,0);
      if(58 <= c)
       var switch$0=71 <= c?5 < (c - 97 | 0) >>> 0?1:0:65 <= c?0:1;
      else
       {if(32 === c)
         var switch$1=1;
        else
         if(43 <= c)
          {var switcher=c - 43 | 0;
           switch(switcher)
            {case 5:
              if(len < (prec$0 + 2 | 0))
               if(1 < len)
                {var
                  switch$2=
                   120 === caml_string_get(str,1)
                    ?0
                    :88 === caml_string_get(str,1)?0:1;
                 if(! switch$2)
                  {var res$1=make(prec$0 + 2 | 0,48);
                   caml_bytes_set(res$1,1,caml_string_get(str,1));
                   blit$0(str,2,res$1,(prec$0 - len | 0) + 4 | 0,len - 2 | 0);
                   return res$1}}
              var switch$0=0,switch$1=0;
              break;
             case 0:
             case 2:var switch$1=1;break;
             case 1:
             case 3:
             case 4:var switch$0=1,switch$1=0;break;
             default:var switch$0=0,switch$1=0}}
         else
          var switch$0=1,switch$1=0;
        if(switch$1)
         {if(len < (prec$0 + 1 | 0))
           {var res$0=make(prec$0 + 1 | 0,48);
            caml_bytes_set(res$0,0,c);
            blit$0(str,1,res$0,(prec$0 - len | 0) + 2 | 0,len - 1 | 0);
            return res$0}
          var switch$0=1}}
      if(! switch$0)
       if(len < prec$0)
        {var res=make(prec$0,48);
         blit$0(str,0,res,prec$0 - len | 0,len);
         return res}
      return str}
    function string_to_caml_string(str)
     {var
       str$0=escaped$1(str),
       l=caml_ml_string_length(str$0),
       res=make(l + 2 | 0,34);
      caml_blit_string(str$0,0,res,1,l);
      return res}
    function convert_int(iconv,n)
     {switch(iconv)
       {case 0:var _qo_=cst_d$2;break;
        case 1:var _qo_=cst_d$3;break;
        case 2:var _qo_=cst_d$4;break;
        case 3:var _qo_=cst_i$0;break;
        case 4:var _qo_=cst_i$1;break;
        case 5:var _qo_=cst_i$2;break;
        case 6:var _qo_=cst_x;break;
        case 7:var _qo_=cst_x$0;break;
        case 8:var _qo_=cst_X$0;break;
        case 9:var _qo_=cst_X$1;break;
        case 10:var _qo_=cst_o;break;
        case 11:var _qo_=cst_o$0;break;
        default:var _qo_=cst_u}
      return caml_format_int(_qo_,n)}
    function convert_int32(iconv,n)
     {switch(iconv)
       {case 0:var _qn_=cst_ld;break;
        case 1:var _qn_=cst_ld$0;break;
        case 2:var _qn_=cst_ld$1;break;
        case 3:var _qn_=cst_li$0;break;
        case 4:var _qn_=cst_li$1;break;
        case 5:var _qn_=cst_li$2;break;
        case 6:var _qn_=cst_lx;break;
        case 7:var _qn_=cst_lx$0;break;
        case 8:var _qn_=cst_lX;break;
        case 9:var _qn_=cst_lX$0;break;
        case 10:var _qn_=cst_lo;break;
        case 11:var _qn_=cst_lo$0;break;
        default:var _qn_=cst_lu}
      return caml_format_int(_qn_,n)}
    function convert_nativeint(iconv,n)
     {switch(iconv)
       {case 0:var _qm_=cst_nd;break;
        case 1:var _qm_=cst_nd$0;break;
        case 2:var _qm_=cst_nd$1;break;
        case 3:var _qm_=cst_ni$0;break;
        case 4:var _qm_=cst_ni$1;break;
        case 5:var _qm_=cst_ni$2;break;
        case 6:var _qm_=cst_nx;break;
        case 7:var _qm_=cst_nx$0;break;
        case 8:var _qm_=cst_nX;break;
        case 9:var _qm_=cst_nX$0;break;
        case 10:var _qm_=cst_no;break;
        case 11:var _qm_=cst_no$0;break;
        default:var _qm_=cst_nu}
      return caml_format_int(_qm_,n)}
    function convert_int64(iconv,n)
     {switch(iconv)
       {case 0:var _ql_=cst_Ld;break;
        case 1:var _ql_=cst_Ld$0;break;
        case 2:var _ql_=cst_Ld$1;break;
        case 3:var _ql_=cst_Li$0;break;
        case 4:var _ql_=cst_Li$1;break;
        case 5:var _ql_=cst_Li$2;break;
        case 6:var _ql_=cst_Lx;break;
        case 7:var _ql_=cst_Lx$0;break;
        case 8:var _ql_=cst_LX;break;
        case 9:var _ql_=cst_LX$0;break;
        case 10:var _ql_=cst_Lo;break;
        case 11:var _ql_=cst_Lo$0;break;
        default:var _ql_=cst_Lu}
      return caml_int64_format(_ql_,n)}
    function convert_float(fconv,prec$0,x)
     {if(16 <= fconv)
       {if(17 <= fconv)
         switch(fconv - 17 | 0)
          {case 2:var switch$0=0;break;
           case 0:
           case 3:var sign=43,switch$0=1;break;
           default:var sign=32,switch$0=1}
        else
         var switch$0=0;
        if(! switch$0)var sign=45;
        var str=runtime.caml_hexstring_of_float(x,prec$0,sign);
        return 19 <= fconv?uppercase_ascii$1(str):str}
      if(15 === fconv)
       var _qi_=cst_12g$0;
      else
       {var prec=abs(prec$0),symb=char_of_fconv(fconv),buf=buffer_create(16);
        buffer_add_char(buf,37);
        bprint_fconv_flag(buf,fconv);
        buffer_add_char(buf,46);
        buffer_add_string(buf,caml_new_string("" + prec));
        buffer_add_char(buf,symb);
        var _qi_=buffer_contents(buf)}
      var str$0=caml_format_float(_qi_,x);
      if(15 === fconv)
       {var
         len=caml_ml_string_length(str$0),
         match$0=runtime.caml_classify_float(x);
        if(3 === match$0)return x < 0.?cst_neg_infinity:cst_infinity;
        if(4 <= match$0)return cst_nan;
        var i=0;
        for(;;)
         {if(i === len)
           var _qk_=0;
          else
           {var
             match=caml_string_get(str$0,i),
             _qj_=match - 46 | 0,
             switch$1=
              23 < _qj_ >>> 0?55 === _qj_?1:0:21 < (_qj_ - 1 | 0) >>> 0?1:0;
            if(! switch$1){var i$0=i + 1 | 0,i=i$0;continue}
            var _qk_=1}
          return _qk_?str$0:symbol(str$0,cst$27)}}
      return str$0}
    function string_of_fmtty(fmtty)
     {var buf=buffer_create(16);
      bprint_fmtty(buf,fmtty);
      return buffer_contents(buf)}
    function make_int_padding_precision(k,o,acc,fmt,pad,match,trans,iconv)
     {if(typeof pad === "number")
       {if(typeof match === "number")
         return 0 === match
                 ?function(x)
                   {var str=caml_call2(trans,iconv,x);
                    return make_printf(k,o,[4,acc,str],fmt)}
                 :function(p,x)
                   {var str=fix_int_precision(p,caml_call2(trans,iconv,x));
                    return make_printf(k,o,[4,acc,str],fmt)};
        var p=match[1];
        return function(x)
         {var str=fix_int_precision(p,caml_call2(trans,iconv,x));
          return make_printf(k,o,[4,acc,str],fmt)}}
      else
       {if(0 === pad[0])
         {var _qf_=pad[2],_qg_=pad[1];
          if(typeof match === "number")
           return 0 === match
                   ?function(x)
                     {var str=fix_padding(_qg_,_qf_,caml_call2(trans,iconv,x));
                      return make_printf(k,o,[4,acc,str],fmt)}
                   :function(p,x)
                     {var
                       str=
                        fix_padding
                         (_qg_,_qf_,fix_int_precision(p,caml_call2(trans,iconv,x)));
                      return make_printf(k,o,[4,acc,str],fmt)};
          var p$0=match[1];
          return function(x)
           {var
             str=
              fix_padding
               (_qg_,_qf_,fix_int_precision(p$0,caml_call2(trans,iconv,x)));
            return make_printf(k,o,[4,acc,str],fmt)}}
        var _qh_=pad[1];
        if(typeof match === "number")
         return 0 === match
                 ?function(w,x)
                   {var str=fix_padding(_qh_,w,caml_call2(trans,iconv,x));
                    return make_printf(k,o,[4,acc,str],fmt)}
                 :function(w,p,x)
                   {var
                     str=
                      fix_padding
                       (_qh_,w,fix_int_precision(p,caml_call2(trans,iconv,x)));
                    return make_printf(k,o,[4,acc,str],fmt)};
        var p$1=match[1];
        return function(w,x)
         {var
           str=
            fix_padding
             (_qh_,w,fix_int_precision(p$1,caml_call2(trans,iconv,x)));
          return make_printf(k,o,[4,acc,str],fmt)}}}
    function make_padding(k,o,acc,fmt,pad,trans)
     {if(typeof pad === "number")
       return function(x)
        {var new_acc=[4,acc,caml_call1(trans,x)];
         return make_printf(k,o,new_acc,fmt)};
      else
       {if(0 === pad[0])
         {var width=pad[2],padty=pad[1];
          return function(x)
           {var new_acc=[4,acc,fix_padding(padty,width,caml_call1(trans,x))];
            return make_printf(k,o,new_acc,fmt)}}
        var padty$0=pad[1];
        return function(w,x)
         {var new_acc=[4,acc,fix_padding(padty$0,w,caml_call1(trans,x))];
          return make_printf(k,o,new_acc,fmt)}}}
    function make_printf$0(counter,k,o,acc,fmt)
     {var k$0=k,acc$0=acc,fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call2(k$0,o,acc$0);
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1];
           return function(c)
            {var new_acc=[5,acc$0,c];return make_printf(k$0,o,new_acc,rest)};
          case 1:
           var rest$0=fmt$0[1];
           return function(c)
            {var
              str=escaped(c),
              l=caml_ml_string_length(str),
              res=make(l + 2 | 0,39);
             caml_blit_string(str,0,res,1,l);
             var new_acc=[4,acc$0,res];
             return make_printf(k$0,o,new_acc,rest$0)};
          case 2:
           var rest$1=fmt$0[2],pad=fmt$0[1];
           return make_padding
                   (k$0,o,acc$0,rest$1,pad,function(str){return str});
          case 3:
           var rest$2=fmt$0[2],pad$0=fmt$0[1];
           return make_padding(k$0,o,acc$0,rest$2,pad$0,string_to_caml_string);
          case 4:
           var rest$3=fmt$0[4],prec=fmt$0[3],pad$1=fmt$0[2],iconv=fmt$0[1];
           return make_int_padding_precision
                   (k$0,o,acc$0,rest$3,pad$1,prec,convert_int,iconv);
          case 5:
           var
            rest$4=fmt$0[4],
            prec$0=fmt$0[3],
            pad$2=fmt$0[2],
            iconv$0=fmt$0[1];
           return make_int_padding_precision
                   (k$0,o,acc$0,rest$4,pad$2,prec$0,convert_int32,iconv$0);
          case 6:
           var
            rest$5=fmt$0[4],
            prec$1=fmt$0[3],
            pad$3=fmt$0[2],
            iconv$1=fmt$0[1];
           return make_int_padding_precision
                   (k$0,o,acc$0,rest$5,pad$3,prec$1,convert_nativeint,iconv$1);
          case 7:
           var
            rest$6=fmt$0[4],
            prec$2=fmt$0[3],
            pad$4=fmt$0[2],
            iconv$2=fmt$0[1];
           return make_int_padding_precision
                   (k$0,o,acc$0,rest$6,pad$4,prec$2,convert_int64,iconv$2);
          case 8:
           var rest$7=fmt$0[4],prec$3=fmt$0[3],pad$5=fmt$0[2],fconv=fmt$0[1];
           if(typeof pad$5 === "number")
            {if(typeof prec$3 === "number")
              return 0 === prec$3
                      ?function(x)
                        {var str=convert_float(fconv,default_float_precision,x);
                         return make_printf(k$0,o,[4,acc$0,str],rest$7)}
                      :function(p,x)
                        {var str=convert_float(fconv,p,x);
                         return make_printf(k$0,o,[4,acc$0,str],rest$7)};
             var p=prec$3[1];
             return function(x)
              {var str=convert_float(fconv,p,x);
               return make_printf(k$0,o,[4,acc$0,str],rest$7)}}
           else
            {if(0 === pad$5[0])
              {var _qc_=pad$5[2],_qd_=pad$5[1];
               if(typeof prec$3 === "number")
                return 0 === prec$3
                        ?function(x)
                          {var
                            str=convert_float(fconv,default_float_precision,x),
                            str$0=fix_padding(_qd_,_qc_,str);
                           return make_printf(k$0,o,[4,acc$0,str$0],rest$7)}
                        :function(p,x)
                          {var str=fix_padding(_qd_,_qc_,convert_float(fconv,p,x));
                           return make_printf(k$0,o,[4,acc$0,str],rest$7)};
               var p$0=prec$3[1];
               return function(x)
                {var str=fix_padding(_qd_,_qc_,convert_float(fconv,p$0,x));
                 return make_printf(k$0,o,[4,acc$0,str],rest$7)}}
             var _qe_=pad$5[1];
             if(typeof prec$3 === "number")
              return 0 === prec$3
                      ?function(w,x)
                        {var
                          str=convert_float(fconv,default_float_precision,x),
                          str$0=fix_padding(_qe_,w,str);
                         return make_printf(k$0,o,[4,acc$0,str$0],rest$7)}
                      :function(w,p,x)
                        {var str=fix_padding(_qe_,w,convert_float(fconv,p,x));
                         return make_printf(k$0,o,[4,acc$0,str],rest$7)};
             var p$1=prec$3[1];
             return function(w,x)
              {var str=fix_padding(_qe_,w,convert_float(fconv,p$1,x));
               return make_printf(k$0,o,[4,acc$0,str],rest$7)}}
          case 9:
           var rest$8=fmt$0[2],pad$6=fmt$0[1];
           return make_padding(k$0,o,acc$0,rest$8,pad$6,string_of_bool);
          case 10:
           var fmt$1=fmt$0[1],acc$1=[7,acc$0],acc$0=acc$1,fmt$0=fmt$1;
           continue;
          case 11:
           var
            fmt$2=fmt$0[2],
            str=fmt$0[1],
            acc$2=[2,acc$0,str],
            acc$0=acc$2,
            fmt$0=fmt$2;
           continue;
          case 12:
           var
            fmt$3=fmt$0[2],
            chr=fmt$0[1],
            acc$3=[3,acc$0,chr],
            acc$0=acc$3,
            fmt$0=fmt$3;
           continue;
          case 13:
           var
            rest$9=fmt$0[3],
            sub_fmtty=fmt$0[2],
            ty=string_of_fmtty(sub_fmtty);
           return function(str)
            {return make_printf(k$0,o,[4,acc$0,ty],rest$9)};
          case 14:
           var rest$10=fmt$0[3],fmtty=fmt$0[2];
           return function(param)
            {var fmt=param[1];
             return make_printf
                     (k$0,o,acc$0,concat_fmt(recast(fmt,fmtty),rest$10))};
          case 15:
           var rest$11=fmt$0[1];
           return function(f,x)
            {return make_printf
                     (k$0,
                      o,
                      [6,acc$0,function(o){return caml_call2(f,o,x)}],
                      rest$11)};
          case 16:
           var rest$12=fmt$0[1];
           return function(f){return make_printf(k$0,o,[6,acc$0,f],rest$12)};
          case 17:
           var
            fmt$4=fmt$0[2],
            fmting_lit=fmt$0[1],
            acc$4=[0,acc$0,fmting_lit],
            acc$0=acc$4,
            fmt$0=fmt$4;
           continue;
          case 18:
           var _qa_=fmt$0[1];
           if(0 === _qa_[0])
            {var
              rest$13=fmt$0[2],
              match=_qa_[1],
              fmt$5=match[1],
              k$3=
               function(acc,k,rest)
                {function k$0(koc,kacc)
                  {return make_printf(k,koc,[1,acc,[0,kacc]],rest)}
                 return k$0},
              k$1=k$3(acc$0,k$0,rest$13),
              k$0=k$1,
              acc$0=0,
              fmt$0=fmt$5;
             continue}
           var
            rest$14=fmt$0[2],
            match$0=_qa_[1],
            fmt$6=match$0[1],
            k$4=
             function(acc,k,rest)
              {function k$0(koc,kacc)
                {return make_printf(k,koc,[1,acc,[1,kacc]],rest)}
               return k$0},
            k$2=k$4(acc$0,k$0,rest$14),
            k$0=k$2,
            acc$0=0,
            fmt$0=fmt$6;
           continue;
          case 19:throw [0,Assert_failure,_ao_];
          case 20:
           var rest$15=fmt$0[3],new_acc=[8,acc$0,cst_Printf_bad_conversion];
           return function(param){return make_printf(k$0,o,new_acc,rest$15)};
          case 21:
           var rest$16=fmt$0[2];
           return function(n)
            {var new_acc=[4,acc$0,caml_format_int(cst_u$0,n)];
             return make_printf(k$0,o,new_acc,rest$16)};
          case 22:
           var rest$17=fmt$0[1];
           return function(c)
            {var new_acc=[5,acc$0,c];
             return make_printf(k$0,o,new_acc,rest$17)};
          case 23:
           var rest$18=fmt$0[2],ign=fmt$0[1];
           if(counter < 50)
            {var counter$1=counter + 1 | 0;
             return make_ignored_param$0(counter$1,k$0,o,acc$0,ign,rest$18)}
           return caml_trampoline_return
                   (make_ignored_param$0,[0,k$0,o,acc$0,ign,rest$18]);
          default:
           var
            rest$19=fmt$0[3],
            f=fmt$0[2],
            arity=fmt$0[1],
            _qb_=caml_call1(f,0);
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return make_custom$0(counter$0,k$0,o,acc$0,rest$19,arity,_qb_)}
           return caml_trampoline_return
                   (make_custom$0,[0,k$0,o,acc$0,rest$19,arity,_qb_])}}
    function make_ignored_param$0(counter,k,o,acc,ign,fmt)
     {if(typeof ign === "number")
       switch(ign)
        {case 0:
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return make_invalid_arg(counter$0,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 1:
          if(counter < 50)
           {var counter$1=counter + 1 | 0;
            return make_invalid_arg(counter$1,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 2:throw [0,Assert_failure,_ap_];
         default:
          if(counter < 50)
           {var counter$2=counter + 1 | 0;
            return make_invalid_arg(counter$2,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt])}
      else
       switch(ign[0])
        {case 0:
          if(counter < 50)
           {var counter$3=counter + 1 | 0;
            return make_invalid_arg(counter$3,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 1:
          if(counter < 50)
           {var counter$4=counter + 1 | 0;
            return make_invalid_arg(counter$4,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 2:
          if(counter < 50)
           {var counter$5=counter + 1 | 0;
            return make_invalid_arg(counter$5,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 3:
          if(counter < 50)
           {var counter$6=counter + 1 | 0;
            return make_invalid_arg(counter$6,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 4:
          if(counter < 50)
           {var counter$7=counter + 1 | 0;
            return make_invalid_arg(counter$7,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 5:
          if(counter < 50)
           {var counter$8=counter + 1 | 0;
            return make_invalid_arg(counter$8,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 6:
          if(counter < 50)
           {var counter$9=counter + 1 | 0;
            return make_invalid_arg(counter$9,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 7:
          if(counter < 50)
           {var counter$10=counter + 1 | 0;
            return make_invalid_arg(counter$10,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 8:
          if(counter < 50)
           {var counter$11=counter + 1 | 0;
            return make_invalid_arg(counter$11,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 9:
          var fmtty=ign[2];
          if(counter < 50)
           {var counter$14=counter + 1 | 0;
            return make_from_fmtty$0(counter$14,k,o,acc,fmtty,fmt)}
          return caml_trampoline_return
                  (make_from_fmtty$0,[0,k,o,acc,fmtty,fmt]);
         case 10:
          if(counter < 50)
           {var counter$12=counter + 1 | 0;
            return make_invalid_arg(counter$12,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         default:
          if(counter < 50)
           {var counter$13=counter + 1 | 0;
            return make_invalid_arg(counter$13,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt])}}
    function make_from_fmtty$0(counter,k,o,acc,fmtty,fmt)
     {if(typeof fmtty === "number")
       {if(counter < 50)
         {var counter$0=counter + 1 | 0;
          return make_invalid_arg(counter$0,k,o,acc,fmt)}
        return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt])}
      else
       switch(fmtty[0])
        {case 0:
          var rest=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest,fmt)};
         case 1:
          var rest$0=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$0,fmt)};
         case 2:
          var rest$1=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$1,fmt)};
         case 3:
          var rest$2=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$2,fmt)};
         case 4:
          var rest$3=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$3,fmt)};
         case 5:
          var rest$4=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$4,fmt)};
         case 6:
          var rest$5=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$5,fmt)};
         case 7:
          var rest$6=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$6,fmt)};
         case 8:
          var rest$7=fmtty[2];
          return function(param){return make_from_fmtty(k,o,acc,rest$7,fmt)};
         case 9:
          var
           rest$8=fmtty[3],
           ty2=fmtty[2],
           ty1=fmtty[1],
           ty=trans(symm(ty1),ty2);
          return function(param)
           {return make_from_fmtty(k,o,acc,concat_fmtty(ty,rest$8),fmt)};
         case 10:
          var rest$9=fmtty[1];
          return function(param,_p$_)
           {return make_from_fmtty(k,o,acc,rest$9,fmt)};
         case 11:
          var rest$10=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$10,fmt)};
         case 12:
          var rest$11=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$11,fmt)};
         case 13:throw [0,Assert_failure,_aq_];
         default:throw [0,Assert_failure,_ar_]}}
    function make_invalid_arg(counter,k,o,acc,fmt)
     {var _p__=[8,acc,cst_Printf_bad_conversion$0];
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_printf$0(counter$0,k,o,_p__,fmt)}
      return caml_trampoline_return(make_printf$0,[0,k,o,_p__,fmt])}
    function make_custom$0(counter,k,o,acc,rest,arity,f)
     {if(arity)
       {var arity$0=arity[1];
        return function(x)
         {return make_custom(k,o,acc,rest,arity$0,caml_call1(f,x))}}
      var _p9_=[4,acc,f];
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_printf$0(counter$0,k,o,_p9_,rest)}
      return caml_trampoline_return(make_printf$0,[0,k,o,_p9_,rest])}
    function make_printf(k,o,acc,fmt)
     {return caml_trampoline(make_printf$0(0,k,o,acc,fmt))}
    function make_ignored_param(k,o,acc,ign,fmt)
     {return caml_trampoline(make_ignored_param$0(0,k,o,acc,ign,fmt))}
    function make_from_fmtty(k,o,acc,fmtty,fmt)
     {return caml_trampoline(make_from_fmtty$0(0,k,o,acc,fmtty,fmt))}
    function make_custom(k,o,acc,rest,arity,f)
     {return caml_trampoline(make_custom$0(0,k,o,acc,rest,arity,f))}
    function fn_of_padding_precision(k,o,fmt,pad,prec)
     {if(typeof pad === "number")
       {if(typeof prec === "number")
         {if(0 === prec)
           {var _pF_=make_iprintf(k,o,fmt);return function(_pX_){return _pF_}}
          var _pG_=make_iprintf(k,o,fmt),_pH_=function(_pW_){return _pG_};
          return function(_pV_){return _pH_}}
        var _pI_=make_iprintf(k,o,fmt);
        return function(_pU_){return _pI_}}
      else
       {if(0 === pad[0])
         {if(typeof prec === "number")
           {if(0 === prec)
             {var _pJ_=make_iprintf(k,o,fmt);
              return function(_p8_){return _pJ_}}
            var _pK_=make_iprintf(k,o,fmt),_pL_=function(_p7_){return _pK_};
            return function(_p6_){return _pL_}}
          var _pM_=make_iprintf(k,o,fmt);
          return function(_p5_){return _pM_}}
        if(typeof prec === "number")
         {if(0 === prec)
           {var _pN_=make_iprintf(k,o,fmt),_pO_=function(_p4_){return _pN_};
            return function(_p3_){return _pO_}}
          var
           _pP_=make_iprintf(k,o,fmt),
           _pQ_=function(_p2_){return _pP_},
           _pR_=function(_p1_){return _pQ_};
          return function(_p0_){return _pR_}}
        var _pS_=make_iprintf(k,o,fmt),_pT_=function(_pZ_){return _pS_};
        return function(_pY_){return _pT_}}}
    function make_iprintf$0(counter,k,o,fmt)
     {var k$0=k,fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k$0,o);
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1],_oW_=make_iprintf(k$0,o,rest);
           return function(_pE_){return _oW_};
          case 1:
           var rest$0=fmt$0[1],_oX_=make_iprintf(k$0,o,rest$0);
           return function(_pD_){return _oX_};
          case 2:
           var _oY_=fmt$0[1];
           if(typeof _oY_ === "number")
            {var rest$1=fmt$0[2],_oZ_=make_iprintf(k$0,o,rest$1);
             return function(_pz_){return _oZ_}}
           else
            {if(0 === _oY_[0])
              {var rest$2=fmt$0[2],_o0_=make_iprintf(k$0,o,rest$2);
               return function(_pC_){return _o0_}}
             var
              rest$3=fmt$0[2],
              _o1_=make_iprintf(k$0,o,rest$3),
              _o2_=function(_pB_){return _o1_};
             return function(_pA_){return _o2_}}
          case 3:
           var _o3_=fmt$0[1];
           if(typeof _o3_ === "number")
            {var rest$4=fmt$0[2],_o4_=make_iprintf(k$0,o,rest$4);
             return function(_pv_){return _o4_}}
           else
            {if(0 === _o3_[0])
              {var rest$5=fmt$0[2],_o5_=make_iprintf(k$0,o,rest$5);
               return function(_py_){return _o5_}}
             var
              rest$6=fmt$0[2],
              _o6_=make_iprintf(k$0,o,rest$6),
              _o7_=function(_px_){return _o6_};
             return function(_pw_){return _o7_}}
          case 4:
           var rest$7=fmt$0[4],prec=fmt$0[3],pad=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$7,pad,prec);
          case 5:
           var rest$8=fmt$0[4],prec$0=fmt$0[3],pad$0=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$8,pad$0,prec$0);
          case 6:
           var rest$9=fmt$0[4],prec$1=fmt$0[3],pad$1=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$9,pad$1,prec$1);
          case 7:
           var rest$10=fmt$0[4],prec$2=fmt$0[3],pad$2=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$10,pad$2,prec$2);
          case 8:
           var rest$11=fmt$0[4],prec$3=fmt$0[3],pad$3=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$11,pad$3,prec$3);
          case 9:
           var _o8_=fmt$0[1];
           if(typeof _o8_ === "number")
            {var rest$12=fmt$0[2],_o9_=make_iprintf(k$0,o,rest$12);
             return function(_pr_){return _o9_}}
           else
            {if(0 === _o8_[0])
              {var rest$13=fmt$0[2],_o__=make_iprintf(k$0,o,rest$13);
               return function(_pu_){return _o__}}
             var
              rest$14=fmt$0[2],
              _o$_=make_iprintf(k$0,o,rest$14),
              _pa_=function(_pt_){return _o$_};
             return function(_ps_){return _pa_}}
          case 10:var fmt$1=fmt$0[1],fmt$0=fmt$1;continue;
          case 11:var fmt$2=fmt$0[2],fmt$0=fmt$2;continue;
          case 12:var fmt$3=fmt$0[2],fmt$0=fmt$3;continue;
          case 13:
           var rest$15=fmt$0[3],_pb_=make_iprintf(k$0,o,rest$15);
           return function(_pq_){return _pb_};
          case 14:
           var rest$16=fmt$0[3],fmtty=fmt$0[2];
           return function(param)
            {var fmt=param[1];
             return make_iprintf(k$0,o,concat_fmt(recast(fmt,fmtty),rest$16))};
          case 15:
           var
            rest$17=fmt$0[1],
            _pc_=make_iprintf(k$0,o,rest$17),
            _pd_=function(_pp_){return _pc_};
           return function(_po_){return _pd_};
          case 16:
           var rest$18=fmt$0[1],_pe_=make_iprintf(k$0,o,rest$18);
           return function(_pn_){return _pe_};
          case 17:var fmt$4=fmt$0[2],fmt$0=fmt$4;continue;
          case 18:
           var _pf_=fmt$0[1];
           if(0 === _pf_[0])
            {var
              rest$19=fmt$0[2],
              match=_pf_[1],
              fmt$5=match[1],
              k$3=
               function(k,rest)
                {function k$0(koc){return make_iprintf(k,koc,rest)}return k$0},
              k$1=k$3(k$0,rest$19),
              k$0=k$1,
              fmt$0=fmt$5;
             continue}
           var
            rest$20=fmt$0[2],
            match$0=_pf_[1],
            fmt$6=match$0[1],
            k$4=
             function(k,rest)
              {function k$0(koc){return make_iprintf(k,koc,rest)}return k$0},
            k$2=k$4(k$0,rest$20),
            k$0=k$2,
            fmt$0=fmt$6;
           continue;
          case 19:throw [0,Assert_failure,_as_];
          case 20:
           var rest$21=fmt$0[3],_pg_=make_iprintf(k$0,o,rest$21);
           return function(_pm_){return _pg_};
          case 21:
           var rest$22=fmt$0[2],_ph_=make_iprintf(k$0,o,rest$22);
           return function(_pl_){return _ph_};
          case 22:
           var rest$23=fmt$0[1],_pi_=make_iprintf(k$0,o,rest$23);
           return function(_pk_){return _pi_};
          case 23:
           var rest$24=fmt$0[2],ign=fmt$0[1],_pj_=0;
           return make_ignored_param
                   (function(x,param){return caml_call1(k$0,x)},
                    o,
                    _pj_,
                    ign,
                    rest$24);
          default:
           var rest$25=fmt$0[3],arity=fmt$0[1];
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return fn_of_custom_arity$0(counter$0,k$0,o,rest$25,arity)}
           return caml_trampoline_return
                   (fn_of_custom_arity$0,[0,k$0,o,rest$25,arity])}}
    function fn_of_custom_arity$0(counter,k,o,fmt,param)
     {if(param)
       {var arity=param[1],_oU_=fn_of_custom_arity(k,o,fmt,arity);
        return function(_oV_){return _oU_}}
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_iprintf$0(counter$0,k,o,fmt)}
      return caml_trampoline_return(make_iprintf$0,[0,k,o,fmt])}
    function make_iprintf(k,o,fmt)
     {return caml_trampoline(make_iprintf$0(0,k,o,fmt))}
    function fn_of_custom_arity(k,o,fmt,param)
     {return caml_trampoline(fn_of_custom_arity$0(0,k,o,fmt,param))}
    function output_acc(o,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           output_acc(o,p);
           return output_string(o,s);
          case 1:
           var _oS_=acc$0[2],_oT_=acc$0[1];
           if(0 === _oS_[0])
            {var acc$1=_oS_[1];
             output_acc(o,_oT_);
             output_string(o,cst$28);
             var acc$0=acc$1;
             continue}
           var acc$2=_oS_[1];
           output_acc(o,_oT_);
           output_string(o,cst$29);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           output_acc(o,p$2);
           return caml_call1(f,o);
          case 7:var p$3=acc$0[1];output_acc(o,p$3);return caml_ml_flush(o);
          case 8:
           var msg=acc$0[2],p$4=acc$0[1];
           output_acc(o,p$4);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           output_acc(o,p$0);
           return output_string(o,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];
           output_acc(o,p$1);
           return caml_ml_output_char(o,c)}}
    function bufput_acc(b,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           bufput_acc(b,p);
           return add_string(b,s);
          case 1:
           var _oQ_=acc$0[2],_oR_=acc$0[1];
           if(0 === _oQ_[0])
            {var acc$1=_oQ_[1];
             bufput_acc(b,_oR_);
             add_string(b,cst$30);
             var acc$0=acc$1;
             continue}
           var acc$2=_oQ_[1];
           bufput_acc(b,_oR_);
           add_string(b,cst$31);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           bufput_acc(b,p$2);
           return caml_call1(f,b);
          case 7:var acc$3=acc$0[1],acc$0=acc$3;continue;
          case 8:
           var msg=acc$0[2],p$3=acc$0[1];
           bufput_acc(b,p$3);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           bufput_acc(b,p$0);
           return add_string(b,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];bufput_acc(b,p$1);return add_char(b,c)}}
    function strput_acc(b,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           strput_acc(b,p);
           return add_string(b,s);
          case 1:
           var _oO_=acc$0[2],_oP_=acc$0[1];
           if(0 === _oO_[0])
            {var acc$1=_oO_[1];
             strput_acc(b,_oP_);
             add_string(b,cst$32);
             var acc$0=acc$1;
             continue}
           var acc$2=_oO_[1];
           strput_acc(b,_oP_);
           add_string(b,cst$33);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           strput_acc(b,p$2);
           return add_string(b,caml_call1(f,0));
          case 7:var acc$3=acc$0[1],acc$0=acc$3;continue;
          case 8:
           var msg=acc$0[2],p$3=acc$0[1];
           strput_acc(b,p$3);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           strput_acc(b,p$0);
           return add_string(b,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];strput_acc(b,p$1);return add_char(b,c)}}
    function failwith_message(param)
     {var fmt=param[1],buf=create$1(256);
      function k(param,acc)
       {strput_acc(buf,acc);return failwith(contents(buf))}
      return make_printf(k,0,0,fmt)}
    function open_box_of_string(str)
     {if(caml_string_equal(str,cst$34))return _at_;
      var len=caml_ml_string_length(str);
      function invalid_box(param)
       {return caml_call1(failwith_message(_au_),str)}
      function parse_spaces(i)
       {var i$0=i;
        for(;;)
         {if(i$0 === len)return i$0;
          var match=caml_string_get(str,i$0);
          if(9 !== match)if(32 !== match)return i$0;
          var i$1=i$0 + 1 | 0,i$0=i$1;
          continue}}
      function parse_lword(i,j)
       {var j$0=j;
        for(;;)
         {if(j$0 === len)return j$0;
          var match=caml_string_get(str,j$0),switcher=match - 97 | 0;
          if(25 < switcher >>> 0)return j$0;
          var j$1=j$0 + 1 | 0,j$0=j$1;
          continue}}
      function parse_int(i,j)
       {var j$0=j;
        for(;;)
         {if(j$0 === len)return j$0;
          var
           match=caml_string_get(str,j$0),
           switch$0=48 <= match?58 <= match?0:1:45 === match?1:0;
          if(switch$0){var j$1=j$0 + 1 | 0,j$0=j$1;continue}
          return j$0}}
      var
       wstart=parse_spaces(0),
       wend=parse_lword(wstart,wstart),
       box_name=sub$0(str,wstart,wend - wstart | 0),
       nstart=parse_spaces(wend),
       nend=parse_int(nstart,nstart);
      if(nstart === nend)
       var indent=0;
      else
       try
        {var
          _oM_=caml_int_of_string(sub$0(str,nstart,nend - nstart | 0)),
          indent=_oM_}
       catch(_oN_)
        {_oN_ = caml_wrap_exception(_oN_);
         if(_oN_[1] !== Failure)throw _oN_;
         var indent=invalid_box(0)}
      var exp_end=parse_spaces(nend);
      if(exp_end !== len)invalid_box(0);
      if(caml_string_notequal(box_name,cst$35))
       if(caml_string_notequal(box_name,cst_b$0))
        if(caml_string_notequal(box_name,cst_h))
         if(caml_string_notequal(box_name,cst_hov))
          if(caml_string_notequal(box_name,cst_hv))
           if(caml_string_notequal(box_name,cst_v))
            var box_type=invalid_box(0),switch$0=1;
           else
            var box_type=1,switch$0=1;
          else
           var box_type=2,switch$0=1;
         else
          var box_type=3,switch$0=1;
        else
         var box_type=0,switch$0=1;
       else
        var switch$0=0;
      else
       var switch$0=0;
      if(! switch$0)var box_type=4;
      return [0,indent,box_type]}
    function make_padding_fmt_ebb(pad,fmt)
     {if(typeof pad === "number")
       return [0,0,fmt];
      else
       {if(0 === pad[0]){var w=pad[2],s=pad[1];return [0,[0,s,w],fmt]}
        var s$0=pad[1];
        return [0,[1,s$0],fmt]}}
    function make_padprec_fmt_ebb(pad,prec,fmt)
     {if(typeof prec === "number")
       var match=0 === prec?[0,0,fmt]:[0,1,fmt];
      else
       var p=prec[1],match=[0,[0,p],fmt];
      var prec$0=match[1];
      if(typeof pad === "number")
       return [0,0,prec$0,fmt];
      else
       {if(0 === pad[0]){var w=pad[2],s=pad[1];return [0,[0,s,w],prec$0,fmt]}
        var s$0=pad[1];
        return [0,[1,s$0],prec$0,fmt]}}
    function fmt_ebb_of_string(legacy_behavior,str)
     {if(legacy_behavior)
       var flag=legacy_behavior[1],legacy_behavior$0=flag;
      else
       var legacy_behavior$0=1;
      function invalid_format_message(str_ind,msg)
       {return caml_call3(failwith_message(_av_),str,str_ind,msg)}
      function unexpected_end_of_format(end_ind)
       {return invalid_format_message(end_ind,cst_unexpected_end_of_format)}
      function invalid_format_without(str_ind,c,s)
       {return caml_call4(failwith_message(_aw_),str,str_ind,c,s)}
      function expected_character(str_ind,expected,read)
       {return caml_call4(failwith_message(_ax_),str,str_ind,expected,read)}
      function add_literal(lit_start,str_ind,fmt)
       {var size=str_ind - lit_start | 0;
        return 0 === size
                ?[0,fmt]
                :1 === size
                  ?[0,[12,caml_string_get(str,lit_start),fmt]]
                  :[0,[11,sub$0(str,lit_start,size),fmt]]}
      function parse(lit_start,end_ind)
       {var str_ind=lit_start;
        for(;;)
         {if(str_ind === end_ind)return add_literal(lit_start,str_ind,0);
          var match=caml_string_get(str,str_ind);
          if(37 === match)
           {var str_ind$2=str_ind + 1 | 0;
            if(str_ind$2 === end_ind)unexpected_end_of_format(end_ind);
            var
             match$1=caml_string_get(str,str_ind$2),
             _oL_=
              95 === match$1
               ?parse_flags(str_ind,str_ind$2 + 1 | 0,end_ind,1)
               :parse_flags(str_ind,str_ind$2,end_ind,0),
             fmt_rest=_oL_[1];
            return add_literal(lit_start,str_ind,fmt_rest)}
          if(64 === match)
           {var str_ind$0=str_ind + 1 | 0;
            if(str_ind$0 === end_ind)
             var match$0=_aJ_;
            else
             {var c=caml_string_get(str,str_ind$0);
              if(65 <= c)
               if(94 <= c)
                {var switcher=c - 123 | 0;
                 if(2 < switcher >>> 0)
                  var switch$0=0;
                 else
                  switch(switcher)
                   {case 0:
                     var
                      match$0=parse_tag(1,str_ind$0 + 1 | 0,end_ind),
                      switch$0=1;
                     break;
                    case 1:var switch$0=0;break;
                    default:
                     var
                      match$3=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$2=match$3[1],
                      match$0=[0,[17,1,fmt_rest$2]],
                      switch$0=1}}
               else
                if(91 <= c)
                 {var switcher$0=c - 91 | 0;
                  switch(switcher$0)
                   {case 0:
                     var
                      match$0=parse_tag(0,str_ind$0 + 1 | 0,end_ind),
                      switch$0=1;
                     break;
                    case 1:var switch$0=0;break;
                    default:
                     var
                      match$4=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$3=match$4[1],
                      match$0=[0,[17,0,fmt_rest$3]],
                      switch$0=1}}
                else
                 var switch$0=0;
              else
               if(10 === c)
                var
                 match$5=parse(str_ind$0 + 1 | 0,end_ind),
                 fmt_rest$4=match$5[1],
                 match$0=[0,[17,3,fmt_rest$4]],
                 switch$0=1;
               else
                if(32 <= c)
                 {var switcher$1=c - 32 | 0;
                  switch(switcher$1)
                   {case 0:
                     var
                      match$6=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$5=match$6[1],
                      match$0=[0,[17,_aK_,fmt_rest$5]],
                      switch$0=1;
                     break;
                    case 5:
                     if((str_ind$0 + 1 | 0) < end_ind)
                      if(37 === caml_string_get(str,str_ind$0 + 1 | 0))
                       var
                        match$7=parse(str_ind$0 + 2 | 0,end_ind),
                        fmt_rest$6=match$7[1],
                        match$0=[0,[17,6,fmt_rest$6]],
                        switch$0=1,
                        switch$1=0;
                      else
                       var switch$1=1;
                     else
                      var switch$1=1;
                     if(switch$1)
                      var
                       match$8=parse(str_ind$0,end_ind),
                       fmt_rest$7=match$8[1],
                       match$0=[0,[12,64,fmt_rest$7]],
                       switch$0=1;
                     break;
                    case 12:
                     var
                      match$9=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$8=match$9[1],
                      match$0=[0,[17,_aL_,fmt_rest$8]],
                      switch$0=1;
                     break;
                    case 14:
                     var
                      match$10=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$9=match$10[1],
                      match$0=[0,[17,4,fmt_rest$9]],
                      switch$0=1;
                     break;
                    case 27:
                     var
                      match$0=parse_good_break(str_ind$0 + 1 | 0,end_ind),
                      switch$0=1;
                     break;
                    case 28:
                     var
                      match$0=parse_magic_size(str_ind$0 + 1 | 0,end_ind),
                      switch$0=1;
                     break;
                    case 31:
                     var
                      match$11=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$10=match$11[1],
                      match$0=[0,[17,2,fmt_rest$10]],
                      switch$0=1;
                     break;
                    case 32:
                     var
                      match$12=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$11=match$12[1],
                      match$0=[0,[17,5,fmt_rest$11]],
                      switch$0=1;
                     break;
                    default:var switch$0=0}}
                else
                 var switch$0=0;
              if(! switch$0)
               var
                match$2=parse(str_ind$0 + 1 | 0,end_ind),
                fmt_rest$1=match$2[1],
                match$0=[0,[17,[2,c],fmt_rest$1]]}
            var fmt_rest$0=match$0[1];
            return add_literal(lit_start,str_ind,fmt_rest$0)}
          var str_ind$1=str_ind + 1 | 0,str_ind=str_ind$1;
          continue}}
      function parse_conversion
       (pct_ind,str_ind,end_ind,plus,hash,space,ign,pad,prec,padprec,symb)
       {var
         plus_used=[0,0],
         hash_used=[0,0],
         space_used=[0,0],
         ign_used=[0,0],
         pad_used=[0,0],
         prec_used=[0,0];
        function get_plus(param){plus_used[1] = 1;return plus}
        function get_hash(param){hash_used[1] = 1;return hash}
        function get_space(param){space_used[1] = 1;return space}
        function get_ign(param){ign_used[1] = 1;return ign}
        function get_pad(param){pad_used[1] = 1;return pad}
        function get_prec(param){prec_used[1] = 1;return prec}
        function get_padprec(param){pad_used[1] = 1;return padprec}
        function get_int_pad(param)
         {var pad=get_pad(0),match=get_prec(0);
          if(typeof match === "number")if(0 === match)return pad;
          if(typeof pad === "number")
           return 0;
          else
           {if(0 === pad[0])
             {if(2 <= pad[1])
               {var n=pad[2];
                return legacy_behavior$0
                        ?[0,1,n]
                        :incompatible_flag(pct_ind,str_ind,48,cst_precision$0)}
              return pad}
            return 2 <= pad[1]
                    ?legacy_behavior$0
                      ?_aD_
                      :incompatible_flag(pct_ind,str_ind,48,cst_precision$1)
                    :pad}}
        function check_no_0(symb,pad)
         {if(typeof pad === "number")
           return pad;
          else
           {if(0 === pad[0])
             {if(2 <= pad[1])
               {var width=pad[2];
                return legacy_behavior$0
                        ?[0,1,width]
                        :incompatible_flag(pct_ind,str_ind,symb,cst_0$0)}
              return pad}
            return 2 <= pad[1]
                    ?legacy_behavior$0
                      ?_aE_
                      :incompatible_flag(pct_ind,str_ind,symb,cst_0$1)
                    :pad}}
        function opt_of_pad(c,pad)
         {if(typeof pad === "number")
           return 0;
          else
           {if(0 === pad[0])
             switch(pad[1])
              {case 0:
                var width=pad[2];
                return legacy_behavior$0
                        ?[0,width]
                        :incompatible_flag(pct_ind,str_ind,c,cst$36);
               case 1:var width$0=pad[2];return [0,width$0];
               default:
                var width$1=pad[2];
                return legacy_behavior$0
                        ?[0,width$1]
                        :incompatible_flag(pct_ind,str_ind,c,cst_0$2)}
            return incompatible_flag(pct_ind,str_ind,c,cst$37)}}
        function get_pad_opt(c){return opt_of_pad(c,get_pad(0))}
        function get_padprec_opt(c){return opt_of_pad(c,get_padprec(0))}
        if(124 <= symb)
         var switch$0=0;
        else
         switch(symb)
          {case 33:
            var
             match$6=parse(str_ind,end_ind),
             fmt_rest$5=match$6[1],
             fmt_result=[0,[10,fmt_rest$5]],
             switch$0=1;
            break;
           case 40:
            var
             sub_end=search_subformat_end(str_ind,end_ind,41),
             match$8=parse(sub_end + 2 | 0,end_ind),
             fmt_rest$7=match$8[1],
             match$9=parse(str_ind,sub_end),
             sub_fmt=match$9[1],
             sub_fmtty=fmtty_of_fmt(sub_fmt);
            if(get_ign(0))
             var
              ignored$2=[9,get_pad_opt(95),sub_fmtty],
              _ok_=[0,[23,ignored$2,fmt_rest$7]];
            else
             var _ok_=[0,[14,get_pad_opt(40),sub_fmtty,fmt_rest$7]];
            var fmt_result=_ok_,switch$0=1;
            break;
           case 44:var fmt_result=parse(str_ind,end_ind),switch$0=1;break;
           case 67:
            var
             match$12=parse(str_ind,end_ind),
             fmt_rest$10=match$12[1],
             _om_=get_ign(0)?[0,[23,1,fmt_rest$10]]:[0,[1,fmt_rest$10]],
             fmt_result=_om_,
             switch$0=1;
            break;
           case 78:
            var
             match$16=parse(str_ind,end_ind),
             fmt_rest$14=match$16[1],
             counter$0=2;
            if(get_ign(0))
             var ignored$6=[11,counter$0],_os_=[0,[23,ignored$6,fmt_rest$14]];
            else
             var _os_=[0,[21,counter$0,fmt_rest$14]];
            var fmt_result=_os_,switch$0=1;
            break;
           case 83:
            var
             pad$6=check_no_0(symb,get_padprec(0)),
             match$17=parse(str_ind,end_ind),
             fmt_rest$15=match$17[1];
            if(get_ign(0))
             var
              ignored$7=[1,get_padprec_opt(95)],
              _ot_=[0,[23,ignored$7,fmt_rest$15]];
            else
             var
              match$18=make_padding_fmt_ebb(pad$6,fmt_rest$15),
              fmt_rest$16=match$18[2],
              pad$7=match$18[1],
              _ot_=[0,[3,pad$7,fmt_rest$16]];
            var fmt_result=_ot_,switch$0=1;
            break;
           case 91:
            if(str_ind === end_ind)unexpected_end_of_format(end_ind);
            var
             char_set=create_char_set(0),
             add_char=function(c){return add_in_char_set(char_set,c)},
             add_range=
              function(c$0,c)
               {if(! (c < c$0))
                 {var i=c$0;
                  for(;;)
                   {add_in_char_set(char_set,char_of_int(i));
                    var _oK_=i + 1 | 0;
                    if(c !== i){var i=_oK_;continue}
                    break}}
                return 0},
             fail_single_percent=
              function(str_ind)
               {return caml_call2(failwith_message(_aN_),str,str_ind)},
             parse_char_set_content=
              function(counter,str_ind,end_ind)
               {var str_ind$0=str_ind;
                for(;;)
                 {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
                  var c=caml_string_get(str,str_ind$0);
                  if(45 === c)
                   {add_char(45);
                    var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;
                    continue}
                  if(93 === c)return str_ind$0 + 1 | 0;
                  var _oJ_=str_ind$0 + 1 | 0;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return parse_char_set_after_char$0(counter$0,_oJ_,end_ind,c)}
                  return caml_trampoline_return
                          (parse_char_set_after_char$0,[0,_oJ_,end_ind,c])}},
             parse_char_set_after_char$0=
              function(counter,str_ind,end_ind,c)
               {var str_ind$0=str_ind,c$0=c;
                for(;;)
                 {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
                  var c$1=caml_string_get(str,str_ind$0);
                  if(46 <= c$1)
                   if(64 === c$1)
                    var switch$0=0;
                   else
                    {if(93 === c$1){add_char(c$0);return str_ind$0 + 1 | 0}
                     var switch$0=1}
                  else
                   if(37 === c$1)
                    var switch$0=0;
                   else
                    {if(45 <= c$1)
                      {var str_ind$2=str_ind$0 + 1 | 0;
                       if(str_ind$2 === end_ind)unexpected_end_of_format(end_ind);
                       var c$2=caml_string_get(str,str_ind$2);
                       if(37 === c$2)
                        {if((str_ind$2 + 1 | 0) === end_ind)
                          unexpected_end_of_format(end_ind);
                         var c$3=caml_string_get(str,str_ind$2 + 1 | 0);
                         if(37 !== c$3)
                          if(64 !== c$3)return fail_single_percent(str_ind$2);
                         add_range(c$0,c$3);
                         var _oH_=str_ind$2 + 2 | 0;
                         if(counter < 50)
                          {var counter$2=counter + 1 | 0;
                           return parse_char_set_content(counter$2,_oH_,end_ind)}
                         return caml_trampoline_return
                                 (parse_char_set_content,[0,_oH_,end_ind])}
                       if(93 === c$2)
                        {add_char(c$0);add_char(45);return str_ind$2 + 1 | 0}
                       add_range(c$0,c$2);
                       var _oI_=str_ind$2 + 1 | 0;
                       if(counter < 50)
                        {var counter$1=counter + 1 | 0;
                         return parse_char_set_content(counter$1,_oI_,end_ind)}
                       return caml_trampoline_return
                               (parse_char_set_content,[0,_oI_,end_ind])}
                     var switch$0=1}
                  if(! switch$0)
                   if(37 === c$0)
                    {add_char(c$1);
                     var _oG_=str_ind$0 + 1 | 0;
                     if(counter < 50)
                      {var counter$0=counter + 1 | 0;
                       return parse_char_set_content(counter$0,_oG_,end_ind)}
                     return caml_trampoline_return
                             (parse_char_set_content,[0,_oG_,end_ind])}
                  if(37 === c$0)fail_single_percent(str_ind$0);
                  add_char(c$0);
                  var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1,c$0=c$1;
                  continue}},
             parse_char_set_after_char=
              function(str_ind,end_ind,c)
               {return caml_trampoline
                        (parse_char_set_after_char$0(0,str_ind,end_ind,c))};
            if(str_ind === end_ind)unexpected_end_of_format(end_ind);
            var match$31=caml_string_get(str,str_ind);
            if(94 === match$31)
             var str_ind$0=str_ind + 1 | 0,str_ind$1=str_ind$0,reverse=1;
            else
             var str_ind$1=str_ind,reverse=0;
            if(str_ind$1 === end_ind)unexpected_end_of_format(end_ind);
            var
             c=caml_string_get(str,str_ind$1),
             next_ind=parse_char_set_after_char(str_ind$1 + 1 | 0,end_ind,c),
             char_set$0=freeze_char_set(char_set),
             char_set$1=reverse?rev_char_set(char_set$0):char_set$0,
             match$21=parse(next_ind,end_ind),
             fmt_rest$19=match$21[1];
            if(get_ign(0))
             var
              ignored$9=[10,get_pad_opt(95),char_set$1],
              _oy_=[0,[23,ignored$9,fmt_rest$19]];
            else
             var _oy_=[0,[20,get_pad_opt(91),char_set$1,fmt_rest$19]];
            var fmt_result=_oy_,switch$0=1;
            break;
           case 97:
            var
             match$22=parse(str_ind,end_ind),
             fmt_rest$20=match$22[1],
             fmt_result=[0,[15,fmt_rest$20]],
             switch$0=1;
            break;
           case 99:
            var
             char_format=
              function(fmt_rest)
               {return get_ign(0)?[0,[23,0,fmt_rest]]:[0,[0,fmt_rest]]},
             match$23=parse(str_ind,end_ind),
             fmt_rest$21=match$23[1],
             match$24=get_pad_opt(99);
            if(match$24)
             {if(0 === match$24[1])
               var
                _oz_=get_ign(0)?[0,[23,3,fmt_rest$21]]:[0,[22,fmt_rest$21]],
                _oA_=_oz_;
              else
               var
                _oA_=
                 legacy_behavior$0
                  ?char_format(fmt_rest$21)
                  :invalid_format_message
                    (str_ind,
                     cst_non_zero_widths_are_unsupported_for_c_conversions);
              var _oB_=_oA_}
            else
             var _oB_=char_format(fmt_rest$21);
            var fmt_result=_oB_,switch$0=1;
            break;
           case 114:
            var
             match$25=parse(str_ind,end_ind),
             fmt_rest$22=match$25[1],
             _oC_=get_ign(0)?[0,[23,2,fmt_rest$22]]:[0,[19,fmt_rest$22]],
             fmt_result=_oC_,
             switch$0=1;
            break;
           case 115:
            var
             pad$9=check_no_0(symb,get_padprec(0)),
             match$26=parse(str_ind,end_ind),
             fmt_rest$23=match$26[1];
            if(get_ign(0))
             var
              ignored$10=[0,get_padprec_opt(95)],
              _oD_=[0,[23,ignored$10,fmt_rest$23]];
            else
             var
              match$27=make_padding_fmt_ebb(pad$9,fmt_rest$23),
              fmt_rest$24=match$27[2],
              pad$10=match$27[1],
              _oD_=[0,[2,pad$10,fmt_rest$24]];
            var fmt_result=_oD_,switch$0=1;
            break;
           case 116:
            var
             match$28=parse(str_ind,end_ind),
             fmt_rest$25=match$28[1],
             fmt_result=[0,[16,fmt_rest$25]],
             switch$0=1;
            break;
           case 123:
            var
             sub_end$0=search_subformat_end(str_ind,end_ind,125),
             match$29=parse(str_ind,sub_end$0),
             sub_fmt$0=match$29[1],
             match$30=parse(sub_end$0 + 2 | 0,end_ind),
             fmt_rest$26=match$30[1],
             sub_fmtty$0=fmtty_of_fmt(sub_fmt$0);
            if(get_ign(0))
             var
              ignored$11=[8,get_pad_opt(95),sub_fmtty$0],
              _oE_=[0,[23,ignored$11,fmt_rest$26]];
            else
             var _oE_=[0,[13,get_pad_opt(123),sub_fmtty$0,fmt_rest$26]];
            var fmt_result=_oE_,switch$0=1;
            break;
           case 66:
           case 98:
            var
             pad$3=check_no_0(symb,get_padprec(0)),
             match$10=parse(str_ind,end_ind),
             fmt_rest$8=match$10[1];
            if(get_ign(0))
             var
              ignored$3=[7,get_padprec_opt(95)],
              _ol_=[0,[23,ignored$3,fmt_rest$8]];
            else
             var
              match$11=make_padding_fmt_ebb(pad$3,fmt_rest$8),
              fmt_rest$9=match$11[2],
              pad$4=match$11[1],
              _ol_=[0,[9,pad$4,fmt_rest$9]];
            var fmt_result=_ol_,switch$0=1;
            break;
           case 37:
           case 64:
            var
             match$7=parse(str_ind,end_ind),
             fmt_rest$6=match$7[1],
             fmt_result=[0,[12,symb,fmt_rest$6]],
             switch$0=1;
            break;
           case 76:
           case 108:
           case 110:
            if(str_ind === end_ind)
             var switch$1=1;
            else
             {var symb$0=caml_string_get(str,str_ind),_oF_=symb$0 - 88 | 0;
              if(32 < _oF_ >>> 0)
               var switch$2=0;
              else
               switch(_oF_)
                {case 0:
                 case 12:
                 case 17:
                 case 23:
                 case 29:
                 case 32:var _or_=1,switch$2=1;break;
                 default:var switch$2=0}
              if(! switch$2)var _or_=0;
              if(_or_)var switch$0=0,switch$1=0;else var switch$1=1}
            if(switch$1)
             {var match$15=parse(str_ind,end_ind),fmt_rest$13=match$15[1];
              if(108 <= symb)
               if(111 <= symb)
                var switch$3=0;
               else
                {var switcher$0=symb - 108 | 0;
                 switch(switcher$0)
                  {case 0:var counter=0,switch$3=1;break;
                   case 1:var switch$3=0;break;
                   default:var counter=1,switch$3=1}}
              else
               if(76 === symb)var counter=2,switch$3=1;else var switch$3=0;
              if(! switch$3)throw [0,Assert_failure,_aR_];
              if(get_ign(0))
               var ignored$5=[11,counter],_oq_=[0,[23,ignored$5,fmt_rest$13]];
              else
               var _oq_=[0,[21,counter,fmt_rest$13]];
              var fmt_result=_oq_,switch$0=1}
            break;
           case 32:
           case 35:
           case 43:
           case 45:
           case 95:
            var
             fmt_result=caml_call3(failwith_message(_aI_),str,pct_ind,symb),
             switch$0=1;
            break;
           case 88:
           case 100:
           case 105:
           case 111:
           case 117:
           case 120:
            var
             _ou_=get_space(0),
             _ov_=get_hash(0),
             iconv$2=
              compute_int_conv(pct_ind,str_ind,get_plus(0),_ov_,_ou_,symb),
             match$19=parse(str_ind,end_ind),
             fmt_rest$17=match$19[1];
            if(get_ign(0))
             var
              ignored$8=[2,iconv$2,get_pad_opt(95)],
              _ow_=[0,[23,ignored$8,fmt_rest$17]];
            else
             var
              _ox_=get_prec(0),
              match$20=make_padprec_fmt_ebb(get_int_pad(0),_ox_,fmt_rest$17),
              fmt_rest$18=match$20[3],
              prec$4=match$20[2],
              pad$8=match$20[1],
              _ow_=[0,[4,iconv$2,pad$8,prec$4,fmt_rest$18]];
            var fmt_result=_ow_,switch$0=1;
            break;
           case 69:
           case 70:
           case 71:
           case 72:
           case 101:
           case 102:
           case 103:
           case 104:
            var
             space$1=get_space(0),
             plus$2=get_plus(0),
             plus$3=plus$2,
             space$2=space$1;
            for(;;)
             {if(0 === plus$3)
               if(0 === space$2)
                {if(73 <= symb)
                  {var switcher$1=symb - 101 | 0;
                   if(3 < switcher$1 >>> 0)
                    var switch$4=0;
                   else
                    switch(switcher$1)
                     {case 0:var fconv=3,switch$4=1;break;
                      case 1:var fconv=0,switch$4=1;break;
                      case 2:var fconv=9,switch$4=1;break;
                      default:var fconv=16,switch$4=1}}
                 else
                  if(69 <= symb)
                   {var switcher$2=symb - 69 | 0;
                    switch(switcher$2)
                     {case 0:var fconv=6,switch$4=1;break;
                      case 1:var fconv=15,switch$4=1;break;
                      case 2:var fconv=12,switch$4=1;break;
                      default:var fconv=19,switch$4=1}}
                  else
                   var switch$4=0;
                 if(! switch$4)throw [0,Assert_failure,_aT_]}
               else
                {if(73 <= symb)
                  {var switcher$3=symb - 101 | 0;
                   if(3 < switcher$3 >>> 0)
                    var switch$5=0;
                   else
                    switch(switcher$3)
                     {case 0:var fconv=5,switch$5=1;break;
                      case 1:var fconv=2,switch$5=1;break;
                      case 2:var fconv=11,switch$5=1;break;
                      default:var fconv=18,switch$5=1}}
                 else
                  if(69 <= symb)
                   {var switcher$4=symb - 69 | 0;
                    switch(switcher$4)
                     {case 0:var fconv=8,switch$5=1;break;
                      case 1:var switch$5=0;break;
                      case 2:var fconv=14,switch$5=1;break;
                      default:var fconv=21,switch$5=1}}
                  else
                   var switch$5=0;
                 if(! switch$5)
                  {if(legacy_behavior$0){var space$2=0;continue}
                   var fconv=incompatible_flag(pct_ind,str_ind,symb,cst$48)}}
              else
               if(0 === space$2)
                {if(73 <= symb)
                  {var switcher$5=symb - 101 | 0;
                   if(3 < switcher$5 >>> 0)
                    var switch$6=0;
                   else
                    switch(switcher$5)
                     {case 0:var fconv=4,switch$6=1;break;
                      case 1:var fconv=1,switch$6=1;break;
                      case 2:var fconv=10,switch$6=1;break;
                      default:var fconv=17,switch$6=1}}
                 else
                  if(69 <= symb)
                   {var switcher$6=symb - 69 | 0;
                    switch(switcher$6)
                     {case 0:var fconv=7,switch$6=1;break;
                      case 1:var switch$6=0;break;
                      case 2:var fconv=13,switch$6=1;break;
                      default:var fconv=20,switch$6=1}}
                  else
                   var switch$6=0;
                 if(! switch$6)
                  {if(legacy_behavior$0){var plus$3=0;continue}
                   var fconv=incompatible_flag(pct_ind,str_ind,symb,cst$49)}}
               else
                {if(legacy_behavior$0){var space$2=0;continue}
                 var fconv=incompatible_flag(pct_ind,str_ind,32,cst$50)}
              var match$13=parse(str_ind,end_ind),fmt_rest$11=match$13[1];
              if(get_ign(0))
               {var match=get_prec(0);
                if(typeof match === "number")
                 var
                  _on_=
                   0 === match?0:incompatible_flag(pct_ind,str_ind,95,cst$38);
                else
                 var ndec=match[1],_on_=[0,ndec];
                var
                 ignored$4=[6,get_pad_opt(95),_on_],
                 _oo_=[0,[23,ignored$4,fmt_rest$11]]}
              else
               var
                _op_=get_prec(0),
                match$14=make_padprec_fmt_ebb(get_pad(0),_op_,fmt_rest$11),
                fmt_rest$12=match$14[3],
                prec$3=match$14[2],
                pad$5=match$14[1],
                _oo_=[0,[8,fconv,pad$5,prec$3,fmt_rest$12]];
              var fmt_result=_oo_,switch$0=1;
              break}
            break;
           default:var switch$0=0}
        if(! switch$0)
         {if(108 <= symb)
           if(111 <= symb)
            var switch$7=0;
           else
            {var switcher=symb - 108 | 0;
             switch(switcher)
              {case 0:
                var
                 _n6_=caml_string_get(str,str_ind),
                 _n7_=get_space(0),
                 _n8_=get_hash(0),
                 iconv=
                  compute_int_conv
                   (pct_ind,str_ind + 1 | 0,get_plus(0),_n8_,_n7_,_n6_),
                 match$0=parse(str_ind + 1 | 0,end_ind),
                 fmt_rest=match$0[1];
                if(get_ign(0))
                 var
                  ignored=[3,iconv,get_pad_opt(95)],
                  _n9_=[0,[23,ignored,fmt_rest]];
                else
                 var
                  _n$_=get_prec(0),
                  match$1=make_padprec_fmt_ebb(get_int_pad(0),_n$_,fmt_rest),
                  fmt_rest$0=match$1[3],
                  prec$0=match$1[2],
                  pad$0=match$1[1],
                  _n9_=[0,[5,iconv,pad$0,prec$0,fmt_rest$0]];
                var _n__=_n9_,switch$8=1;
                break;
               case 1:var switch$7=0,switch$8=0;break;
               default:
                var
                 _oa_=caml_string_get(str,str_ind),
                 _ob_=get_space(0),
                 _oc_=get_hash(0),
                 iconv$0=
                  compute_int_conv
                   (pct_ind,str_ind + 1 | 0,get_plus(0),_oc_,_ob_,_oa_),
                 match$2=parse(str_ind + 1 | 0,end_ind),
                 fmt_rest$1=match$2[1];
                if(get_ign(0))
                 var
                  ignored$0=[4,iconv$0,get_pad_opt(95)],
                  _od_=[0,[23,ignored$0,fmt_rest$1]];
                else
                 var
                  _oe_=get_prec(0),
                  match$3=make_padprec_fmt_ebb(get_int_pad(0),_oe_,fmt_rest$1),
                  fmt_rest$2=match$3[3],
                  prec$1=match$3[2],
                  pad$1=match$3[1],
                  _od_=[0,[6,iconv$0,pad$1,prec$1,fmt_rest$2]];
                var _n__=_od_,switch$8=1}
             if(switch$8)var fmt_result=_n__,switch$7=1}
          else
           if(76 === symb)
            {var
              _of_=caml_string_get(str,str_ind),
              _og_=get_space(0),
              _oh_=get_hash(0),
              iconv$1=
               compute_int_conv
                (pct_ind,str_ind + 1 | 0,get_plus(0),_oh_,_og_,_of_),
              match$4=parse(str_ind + 1 | 0,end_ind),
              fmt_rest$3=match$4[1];
             if(get_ign(0))
              var
               ignored$1=[5,iconv$1,get_pad_opt(95)],
               _oi_=[0,[23,ignored$1,fmt_rest$3]];
             else
              var
               _oj_=get_prec(0),
               match$5=make_padprec_fmt_ebb(get_int_pad(0),_oj_,fmt_rest$3),
               fmt_rest$4=match$5[3],
               prec$2=match$5[2],
               pad$2=match$5[1],
               _oi_=[0,[7,iconv$1,pad$2,prec$2,fmt_rest$4]];
             var fmt_result=_oi_,switch$7=1}
           else
            var switch$7=0;
          if(! switch$7)
           var
            fmt_result=
             caml_call3(failwith_message(_aF_),str,str_ind - 1 | 0,symb)}
        if(1 - legacy_behavior$0)
         {var _nX_=1 - plus_used[1],plus$0=_nX_?plus:_nX_;
          if(plus$0)incompatible_flag(pct_ind,str_ind,symb,cst$39);
          var _nY_=1 - hash_used[1],hash$0=_nY_?hash:_nY_;
          if(hash$0)incompatible_flag(pct_ind,str_ind,symb,cst$40);
          var _nZ_=1 - space_used[1],space$0=_nZ_?space:_nZ_;
          if(space$0)incompatible_flag(pct_ind,str_ind,symb,cst$41);
          var _n0_=1 - pad_used[1],_n1_=_n0_?caml_notequal([0,pad],_aG_):_n0_;
          if(_n1_)incompatible_flag(pct_ind,str_ind,symb,cst_padding$0);
          var
           _n2_=1 - prec_used[1],
           _n3_=_n2_?caml_notequal([0,prec],_aH_):_n2_;
          if(_n3_)
           {var _n4_=ign?95:symb;
            incompatible_flag(pct_ind,str_ind,_n4_,cst_precision$2)}
          var plus$1=ign?plus:ign;
          if(plus$1)incompatible_flag(pct_ind,str_ind,95,cst$42)}
        var _n5_=1 - ign_used[1],ign$0=_n5_?ign:_n5_;
        if(ign$0)
         {var
           switch$9=
            38 <= symb
             ?44 === symb?0:64 === symb?0:1
             :33 === symb?0:37 <= symb?0:1,
           switch$10=switch$9?0:legacy_behavior$0?1:0;
          if(! switch$10)incompatible_flag(pct_ind,str_ind,symb,cst$43)}
        return fmt_result}
      function parse_after_precision
       (pct_ind,str_ind,end_ind,minus,plus,hash,space,ign,pad,match)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        function parse_conv(padprec)
         {return parse_conversion
                  (pct_ind,
                   str_ind + 1 | 0,
                   end_ind,
                   plus,
                   hash,
                   space,
                   ign,
                   pad,
                   match,
                   padprec,
                   caml_string_get(str,str_ind))}
        if(typeof pad === "number")
         {if(typeof match === "number")if(0 === match)return parse_conv(0);
          if(0 === minus)
           {if(typeof match === "number")return parse_conv(_aB_);
            var n=match[1];
            return parse_conv([0,1,n])}
          if(typeof match === "number")return parse_conv(_aC_);
          var n$0=match[1];
          return parse_conv([0,0,n$0])}
        return parse_conv(pad)}
      function parse_after_padding
       (pct_ind,str_ind,end_ind,minus,plus,hash,space,ign,pad)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        var symb=caml_string_get(str,str_ind);
        if(46 === symb)
         {var str_ind$0=str_ind + 1 | 0;
          if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var
           parse_literal=
            function(minus,str_ind)
             {var
               match=parse_positive(str_ind,end_ind,0),
               prec=match[2],
               new_ind=match[1];
              return parse_after_precision
                      (pct_ind,
                       new_ind,
                       end_ind,
                       minus,
                       plus,
                       hash,
                       space,
                       ign,
                       pad,
                       [0,prec])},
           symb$0=caml_string_get(str,str_ind$0);
          if(48 <= symb$0)
           {if(! (58 <= symb$0))return parse_literal(minus,str_ind$0)}
          else
           if(42 <= symb$0)
            {var switcher=symb$0 - 42 | 0;
             switch(switcher)
              {case 0:
                return parse_after_precision
                        (pct_ind,
                         str_ind$0 + 1 | 0,
                         end_ind,
                         minus,
                         plus,
                         hash,
                         space,
                         ign,
                         pad,
                         1);
               case 1:
               case 3:
                if(legacy_behavior$0)
                 {var
                   _nW_=str_ind$0 + 1 | 0,
                   minus$0=minus || (45 === symb$0?1:0);
                  return parse_literal(minus$0,_nW_)}
                break
               }}
          return legacy_behavior$0
                  ?parse_after_precision
                    (pct_ind,
                     str_ind$0,
                     end_ind,
                     minus,
                     plus,
                     hash,
                     space,
                     ign,
                     pad,
                     _aA_)
                  :invalid_format_without(str_ind$0 - 1 | 0,46,cst_precision)}
        return parse_conversion
                (pct_ind,
                 str_ind + 1 | 0,
                 end_ind,
                 plus,
                 hash,
                 space,
                 ign,
                 pad,
                 0,
                 pad,
                 symb)}
      function parse_flags(pct_ind,str_ind,end_ind,ign)
       {var zero=[0,0],minus=[0,0],plus=[0,0],space=[0,0],hash=[0,0];
        function set_flag(str_ind,flag)
         {var _nT_=flag[1],_nU_=_nT_?1 - legacy_behavior$0:_nT_;
          if(_nU_)
           {var _nV_=caml_string_get(str,str_ind);
            caml_call3(failwith_message(_ay_),str,str_ind,_nV_)}
          flag[1] = 1;
          return 0}
        var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var match=caml_string_get(str,str_ind$0),switcher=match - 32 | 0;
          if(! (16 < switcher >>> 0))
           switch(switcher)
            {case 0:
              set_flag(str_ind$0,space);
              var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;
              continue;
             case 3:
              set_flag(str_ind$0,hash);
              var str_ind$2=str_ind$0 + 1 | 0,str_ind$0=str_ind$2;
              continue;
             case 11:
              set_flag(str_ind$0,plus);
              var str_ind$3=str_ind$0 + 1 | 0,str_ind$0=str_ind$3;
              continue;
             case 13:
              set_flag(str_ind$0,minus);
              var str_ind$4=str_ind$0 + 1 | 0,str_ind$0=str_ind$4;
              continue;
             case 16:
              set_flag(str_ind$0,zero);
              var str_ind$5=str_ind$0 + 1 | 0,str_ind$0=str_ind$5;
              continue
             }
          var
           _nO_=space[1],
           _nP_=hash[1],
           _nQ_=plus[1],
           _nR_=minus[1],
           _nS_=zero[1];
          if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var
           padty=
            0 === _nS_
             ?0 === _nR_?1:0
             :0 === _nR_
               ?2
               :legacy_behavior$0
                 ?0
                 :incompatible_flag(pct_ind,str_ind$0,45,cst_0),
           match$0=caml_string_get(str,str_ind$0);
          if(48 <= match$0)
           {if(! (58 <= match$0))
             {var
               match$1=parse_positive(str_ind$0,end_ind,0),
               width=match$1[2],
               new_ind=match$1[1];
              return parse_after_padding
                      (pct_ind,
                       new_ind,
                       end_ind,
                       _nR_,
                       _nQ_,
                       _nP_,
                       _nO_,
                       ign,
                       [0,padty,width])}}
          else
           if(42 === match$0)
            return parse_after_padding
                    (pct_ind,
                     str_ind$0 + 1 | 0,
                     end_ind,
                     _nR_,
                     _nQ_,
                     _nP_,
                     _nO_,
                     ign,
                     [1,padty]);
          switch(padty)
           {case 0:
             if(1 - legacy_behavior$0)
              invalid_format_without(str_ind$0 - 1 | 0,45,cst_padding);
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_nR_,_nQ_,_nP_,_nO_,ign,0);
            case 1:
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_nR_,_nQ_,_nP_,_nO_,ign,0);
            default:
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_nR_,_nQ_,_nP_,_nO_,ign,_az_)}}}
      function parse_tag(is_open_tag,str_ind,end_ind)
       {try
         {if(str_ind === end_ind)throw Not_found;
          var match$0=caml_string_get(str,str_ind);
          if(60 === match$0)
           {var ind=index_from$0(str,str_ind + 1 | 0,62);
            if(end_ind <= ind)throw Not_found;
            var
             sub_str=sub$0(str,str_ind,(ind - str_ind | 0) + 1 | 0),
             match$1=parse(ind + 1 | 0,end_ind),
             fmt_rest$0=match$1[1],
             match$2=parse(str_ind,ind + 1 | 0),
             sub_fmt=match$2[1],
             sub_format$0=[0,sub_fmt,sub_str];
            if(is_open_tag)
             var formatting$0=[0,sub_format$0];
            else
             {if(typeof sub_fmt === "number")
               var switch$0=0;
              else
               if(11 === sub_fmt[0])
                if(typeof sub_fmt[2] === "number")
                 {var str$0=sub_fmt[1];
                  try
                   {open_box_of_string(str$0);var switch$1=1}
                  catch(_nN_)
                   {_nN_ = caml_wrap_exception(_nN_);
                    if(_nN_[1] !== Failure)throw _nN_;
                    var switch$0=1,switch$1=0}
                  if(switch$1)var switch$0=1}
                else
                 var switch$0=0;
               else
                var switch$0=0;
              var formatting$0=[1,sub_format$0]}
            var _nL_=[0,[18,formatting$0,fmt_rest$0]];
            return _nL_}
          throw Not_found}
        catch(_nM_)
         {_nM_ = caml_wrap_exception(_nM_);
          if(_nM_ === Not_found)
           {var
             match=parse(str_ind,end_ind),
             fmt_rest=match[1],
             formatting=is_open_tag?[0,sub_format]:[1,sub_format];
            return [0,[18,formatting,fmt_rest]]}
          throw _nM_}}
      function parse_good_break(str_ind,end_ind)
       {try
         {var
           _nE_=str_ind === end_ind?1:0,
           _nF_=_nE_ || (60 !== caml_string_get(str,str_ind)?1:0);
          if(_nF_)throw Not_found;
          var
           str_ind_1=parse_spaces(str_ind + 1 | 0,end_ind),
           match$0=caml_string_get(str,str_ind_1),
           switch$0=48 <= match$0?58 <= match$0?0:1:45 === match$0?1:0;
          if(! switch$0)throw Not_found;
          var
           match$1=parse_integer(str_ind_1,end_ind),
           width=match$1[2],
           str_ind_2=match$1[1],
           str_ind_3=parse_spaces(str_ind_2,end_ind),
           match$2=caml_string_get(str,str_ind_3),
           switcher=match$2 - 45 | 0;
          if(12 < switcher >>> 0)
           if(17 === switcher)
            var
             s=sub$0(str,str_ind - 2 | 0,(str_ind_3 - str_ind | 0) + 3 | 0),
             _nG_=[0,s,width,0],
             _nH_=str_ind_3 + 1 | 0,
             next_ind=_nH_,
             formatting_lit$0=_nG_,
             switch$1=1;
           else
            var switch$1=0;
          else
           {var switcher$0=switcher - 1 | 0;
            if(1 < switcher$0 >>> 0)
             {var
               match$3=parse_integer(str_ind_3,end_ind),
               offset=match$3[2],
               str_ind_4=match$3[1],
               str_ind_5=parse_spaces(str_ind_4,end_ind);
              if(62 !== caml_string_get(str,str_ind_5))throw Not_found;
              var
               s$0=
                sub$0(str,str_ind - 2 | 0,(str_ind_5 - str_ind | 0) + 3 | 0),
               _nI_=[0,s$0,width,offset],
               _nJ_=str_ind_5 + 1 | 0,
               next_ind=_nJ_,
               formatting_lit$0=_nI_,
               switch$1=1}
            else
             var switch$1=0}
          if(! switch$1)throw Not_found}
        catch(_nK_)
         {_nK_ = caml_wrap_exception(_nK_);
          if(_nK_ !== Not_found)if(_nK_[1] !== Failure)throw _nK_;
          var next_ind=str_ind,formatting_lit$0=formatting_lit}
        var match=parse(next_ind,end_ind),fmt_rest=match[1];
        return [0,[17,formatting_lit$0,fmt_rest]]}
      function parse_magic_size(str_ind,end_ind)
       {try
         {var
           str_ind_1=parse_spaces(str_ind,end_ind),
           match$2=caml_string_get(str,str_ind_1),
           switch$0=48 <= match$2?58 <= match$2?0:1:45 === match$2?1:0;
          if(switch$0)
           {var
             match$3=parse_integer(str_ind_1,end_ind),
             size=match$3[2],
             str_ind_2=match$3[1],
             str_ind_3=parse_spaces(str_ind_2,end_ind);
            if(62 !== caml_string_get(str,str_ind_3))throw Not_found;
            var
             s=sub$0(str,str_ind - 2 | 0,(str_ind_3 - str_ind | 0) + 3 | 0),
             _nC_=[0,[0,str_ind_3 + 1 | 0,[1,s,size]]]}
          else
           var _nC_=0;
          var _nB_=_nC_}
        catch(_nD_)
         {_nD_ = caml_wrap_exception(_nD_);
          if(_nD_ !== Not_found)if(_nD_[1] !== Failure)throw _nD_;
          var _nB_=0}
        if(_nB_)
         {var
           match=_nB_[1],
           formatting_lit=match[2],
           next_ind=match[1],
           match$0=parse(next_ind,end_ind),
           fmt_rest=match$0[1];
          return [0,[17,formatting_lit,fmt_rest]]}
        var match$1=parse(str_ind,end_ind),fmt_rest$0=match$1[1];
        return [0,[17,_aM_,fmt_rest$0]]}
      function parse_spaces(str_ind,end_ind)
       {var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          if(32 === caml_string_get(str,str_ind$0))
           {var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;continue}
          return str_ind$0}}
      function parse_positive(str_ind,end_ind,acc)
       {var str_ind$0=str_ind,acc$0=acc;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var c=caml_string_get(str,str_ind$0),switcher=c - 48 | 0;
          if(9 < switcher >>> 0)return [0,str_ind$0,acc$0];
          var acc$1=(acc$0 * 10 | 0) + (c - 48 | 0) | 0;
          if(max_string_length < acc$1)
           return caml_call3
                   (failwith_message(_aO_),str,acc$1,max_string_length);
          var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1,acc$0=acc$1;
          continue}}
      function parse_integer(str_ind,end_ind)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        var match=caml_string_get(str,str_ind);
        if(48 <= match)
         {if(! (58 <= match))return parse_positive(str_ind,end_ind,0)}
        else
         if(45 === match)
          {if((str_ind + 1 | 0) === end_ind)unexpected_end_of_format(end_ind);
           var c=caml_string_get(str,str_ind + 1 | 0),switcher=c - 48 | 0;
           if(9 < switcher >>> 0)
            return expected_character(str_ind + 1 | 0,cst_digit,c);
           var
            match$0=parse_positive(str_ind + 1 | 0,end_ind,0),
            n=match$0[2],
            next_ind=match$0[1];
           return [0,next_ind,- n | 0]}
        throw [0,Assert_failure,_aP_]}
      function search_subformat_end(str_ind,end_ind,c)
       {var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)
           caml_call3(failwith_message(_aQ_),str,c,end_ind);
          var match=caml_string_get(str,str_ind$0);
          if(37 === match)
           {if((str_ind$0 + 1 | 0) === end_ind)
             unexpected_end_of_format(end_ind);
            if(caml_string_get(str,str_ind$0 + 1 | 0) === c)return str_ind$0;
            var match$0=caml_string_get(str,str_ind$0 + 1 | 0);
            if(95 <= match$0)
             {if(123 <= match$0)
               {if(! (126 <= match$0))
                 {var switcher=match$0 - 123 | 0;
                  switch(switcher)
                   {case 0:
                     var
                      sub_end=search_subformat_end(str_ind$0 + 2 | 0,end_ind,125),
                      str_ind$2=sub_end + 2 | 0,
                      str_ind$0=str_ind$2;
                     continue;
                    case 1:break;
                    default:
                     return expected_character
                             (str_ind$0 + 1 | 0,cst_character,125)}}}
              else
               if(! (96 <= match$0))
                {if((str_ind$0 + 2 | 0) === end_ind)
                  unexpected_end_of_format(end_ind);
                 var match$1=caml_string_get(str,str_ind$0 + 2 | 0);
                 if(40 === match$1)
                  {var
                    sub_end$0=search_subformat_end(str_ind$0 + 3 | 0,end_ind,41),
                    str_ind$3=sub_end$0 + 2 | 0,
                    str_ind$0=str_ind$3;
                   continue}
                 if(123 === match$1)
                  {var
                    sub_end$1=
                     search_subformat_end(str_ind$0 + 3 | 0,end_ind,125),
                    str_ind$4=sub_end$1 + 2 | 0,
                    str_ind$0=str_ind$4;
                   continue}
                 var str_ind$5=str_ind$0 + 3 | 0,str_ind$0=str_ind$5;
                 continue}}
            else
             {if(40 === match$0)
               {var
                 sub_end$2=search_subformat_end(str_ind$0 + 2 | 0,end_ind,41),
                 str_ind$6=sub_end$2 + 2 | 0,
                 str_ind$0=str_ind$6;
                continue}
              if(41 === match$0)
               return expected_character(str_ind$0 + 1 | 0,cst_character$0,41)}
            var str_ind$1=str_ind$0 + 2 | 0,str_ind$0=str_ind$1;
            continue}
          var str_ind$7=str_ind$0 + 1 | 0,str_ind$0=str_ind$7;
          continue}}
      function incompatible_flag(pct_ind,str_ind,symb,option)
       {var subfmt=sub$0(str,pct_ind,str_ind - pct_ind | 0);
        return caml_call5
                (failwith_message(_aU_),str,pct_ind,option,symb,subfmt)}
      function compute_int_conv(pct_ind,str_ind,plus,hash,space,symb)
       {var plus$0=plus,hash$0=hash,space$0=space;
        for(;;)
         {if(0 === plus$0)
           if(0 === hash$0)
            if(0 === space$0)
             {var switcher=symb - 88 | 0;
              if(32 < switcher >>> 0)
               var switch$0=1;
              else
               switch(switcher)
                {case 0:return 8;
                 case 12:return 0;
                 case 17:return 3;
                 case 23:return 10;
                 case 29:return 12;
                 case 32:return 6;
                 default:var switch$0=1}}
            else
             {if(100 === symb)return 2;
              if(105 === symb)return 5;
              var switch$0=1}
           else
            if(0 === space$0)
             {if(88 === symb)return 9;
              if(111 === symb)return 11;
              if(120 === symb)return 7;
              var switch$0=0}
            else
             var switch$0=0;
          else
           if(0 === hash$0)
            if(0 === space$0)
             {if(100 === symb)return 1;
              if(105 === symb)return 4;
              var switch$0=1}
            else
             var switch$0=1;
           else
            var switch$0=0;
          if(! switch$0)
           {var switcher$0=symb - 88 | 0;
            if(! (32 < switcher$0 >>> 0))
             switch(switcher$0)
              {case 0:if(legacy_behavior$0)return 9;break;
               case 23:if(legacy_behavior$0)return 11;break;
               case 32:if(legacy_behavior$0)return 7;break;
               case 12:
               case 17:
               case 29:
                if(legacy_behavior$0){var hash$0=0;continue}
                return incompatible_flag(pct_ind,str_ind,symb,cst$47)
               }}
          if(0 === plus$0)
           {if(0 === space$0)throw [0,Assert_failure,_aS_];
            if(legacy_behavior$0){var space$0=0;continue}
            return incompatible_flag(pct_ind,str_ind,symb,cst$44)}
          if(0 === space$0)
           {if(legacy_behavior$0){var plus$0=0;continue}
            return incompatible_flag(pct_ind,str_ind,symb,cst$45)}
          if(legacy_behavior$0){var space$0=0;continue}
          return incompatible_flag(pct_ind,str_ind,32,cst$46)}}
      return parse(0,caml_ml_string_length(str))}
    function format_of_string_fmtty(str,fmtty)
     {var match=fmt_ebb_of_string(0,str),fmt=match[1];
      try
       {var _nz_=[0,type_format(fmt,fmtty),str];return _nz_}
      catch(_nA_)
       {_nA_ = caml_wrap_exception(_nA_);
        if(_nA_ === Type_mismatch)
         {var _ny_=string_of_fmtty(fmtty);
          return caml_call2(failwith_message(_aV_),str,_ny_)}
        throw _nA_}}
    function format_of_string_format(str,param)
     {var
       str$0=param[2],
       fmt=param[1],
       match=fmt_ebb_of_string(0,str),
       fmt$0=match[1];
      try
       {var _nw_=[0,type_format(fmt$0,fmtty_of_fmt(fmt)),str];return _nw_}
      catch(_nx_)
       {_nx_ = caml_wrap_exception(_nx_);
        if(_nx_ === Type_mismatch)
         return caml_call2(failwith_message(_aW_),str,str$0);
        throw _nx_}}
    var
     CamlinternalFormat=
      [0,
       is_in_char_set,
       rev_char_set,
       create_char_set,
       add_in_char_set,
       freeze_char_set,
       param_format_of_ignored_format,
       make_printf,
       make_iprintf,
       output_acc,
       bufput_acc,
       strput_acc,
       type_format,
       fmt_ebb_of_string,
       format_of_string_fmtty,
       format_of_string_format,
       char_of_iconv,
       string_of_formatting_lit,
       string_of_formatting_gen,
       string_of_fmtty,
       string_of_fmt,
       open_box_of_string,
       symm,
       trans,
       recast];
    caml_register_global(668,CamlinternalFormat,"CamlinternalFormat");
    function kfprintf(k,o,param)
     {var fmt=param[1],_nv_=0;
      return make_printf
              (function(o,acc){output_acc(o,acc);return caml_call1(k,o)},
               o,
               _nv_,
               fmt)}
    function kbprintf(k,b,param)
     {var fmt=param[1],_nu_=0;
      return make_printf
              (function(b,acc){bufput_acc(b,acc);return caml_call1(k,b)},
               b,
               _nu_,
               fmt)}
    function ikfprintf(k,oc,param)
     {var fmt=param[1];return make_iprintf(k,oc,fmt)}
    function fprintf(oc,fmt){return kfprintf(function(_nt_){return 0},oc,fmt)}
    function bprintf(b,fmt){return kbprintf(function(_ns_){return 0},b,fmt)}
    function ifprintf(oc,fmt)
     {return ikfprintf(function(_nr_){return 0},oc,fmt)}
    function printf(fmt){return fprintf(stdout,fmt)}
    function eprintf(fmt){return fprintf(stderr,fmt)}
    function ksprintf(k,param)
     {var fmt=param[1];
      function k$0(param,acc)
       {var buf=create$1(64);
        strput_acc(buf,acc);
        return caml_call1(k,contents(buf))}
      return make_printf(k$0,0,0,fmt)}
    function sprintf(fmt){return ksprintf(function(s){return s},fmt)}
    var
     Printf=
      [0,
       fprintf,
       printf,
       eprintf,
       sprintf,
       bprintf,
       ifprintf,
       kfprintf,
       ikfprintf,
       ksprintf,
       kbprintf,
       ksprintf];
    caml_register_global(669,Printf,"Printf");
    var
     Bad=[248,cst_Arg_Bad,caml_fresh_oo_id(0)],
     Help=[248,cst_Arg_Help,caml_fresh_oo_id(0)],
     Stop=[248,cst_Arg_Stop,caml_fresh_oo_id(0)];
    function assoc3(x,l)
     {var l$0=l;
      for(;;)
       {if(l$0)
         {var t=l$0[2],match=l$0[1],y2=match[2],y1=match[1];
          if(caml_equal(y1,x))return y2;
          var l$0=t;
          continue}
        throw Not_found}}
    function split$0(s)
     {var
       i=index$0(s,61),
       len=caml_ml_string_length(s),
       _nq_=sub$0(s,i + 1 | 0,len - (i + 1 | 0) | 0);
      return [0,sub$0(s,0,i),_nq_]}
    function make_symlist(prefix,sep,suffix,l)
     {if(l)
       {var t=l[2],h=l[1],_np_=symbol(prefix,h);
        return symbol
                (fold_left
                  (function(x,y){return symbol(x,symbol(sep,y))},_np_,t),
                 suffix)}
      return cst_none}
    function help_action(param){throw [0,Stop,_aZ_]}
    function add_help(speclist)
     {try
       {assoc3(cst_help$2,speclist);var _nm_=0,_nk_=_nm_}
      catch(_no_)
       {_no_ = caml_wrap_exception(_no_);
        if(_no_ !== Not_found)throw _no_;
        var
         _nk_=
          [0,[0,cst_help,[0,help_action],cst_Display_this_list_of_options],0]}
      try
       {assoc3(cst_help$1,speclist);var _nl_=0,add2=_nl_}
      catch(_nn_)
       {_nn_ = caml_wrap_exception(_nn_);
        if(_nn_ !== Not_found)throw _nn_;
        var
         add2=
          [0,
           [0,cst_help$0,[0,help_action],cst_Display_this_list_of_options$0],
           0]}
      return append(speclist,append(_nk_,add2))}
    function usage_b(buf,speclist,errmsg)
     {caml_call1(bprintf(buf,_a0_),errmsg);
      var _nh_=add_help(speclist);
      return iter
              (function(param)
                {var
                  doc=param[3],
                  spec=param[2],
                  key=param[1],
                  _ni_=0 < caml_ml_string_length(doc)?1:0;
                 if(_ni_)
                  {if(11 === spec[0])
                    {var l=spec[1],_nj_=make_symlist(cst$53,cst$52,cst$51,l);
                     return caml_call3(bprintf(buf,_aY_),key,_nj_,doc)}
                   return caml_call2(bprintf(buf,_aX_),key,doc)}
                 return _ni_},
               _nh_)}
    function usage_string(speclist,errmsg)
     {var b=create$1(200);usage_b(b,speclist,errmsg);return contents(b)}
    function usage(speclist,errmsg)
     {var _ng_=usage_string(speclist,errmsg);
      return caml_call1(eprintf(_a1_),_ng_)}
    var current=[0,0];
    function bool_of_string_opt$0(x)
     {try
       {var _ne_=[0,bool_of_string(x)];return _ne_}
      catch(_nf_)
       {_nf_ = caml_wrap_exception(_nf_);
        if(_nf_[1] === Invalid_argument)return 0;
        throw _nf_}}
    function int_of_string_opt$0(x)
     {try
       {var _nc_=[0,caml_int_of_string(x)];return _nc_}
      catch(_nd_)
       {_nd_ = caml_wrap_exception(_nd_);
        if(_nd_[1] === Failure)return 0;
        throw _nd_}}
    function float_of_string_opt$0(x)
     {try
       {var _na_=[0,caml_float_of_string(x)];return _na_}
      catch(_nb_)
       {_nb_ = caml_wrap_exception(_nb_);
        if(_nb_[1] === Failure)return 0;
        throw _nb_}}
    function parse_and_expand_argv_dynamic_aux
     (allow_expand,current,argv,speclist,anonfun,errmsg)
     {var initpos=current[1];
      function convert_error(error)
       {var
         b=create$1(200),
         progname=
          initpos < argv[1].length - 1
           ?caml_check_bound(argv[1],initpos)[1 + initpos]
           :cst$54;
        switch(error[0])
         {case 0:
           var _m$_=error[1];
           if(caml_string_notequal(_m$_,cst_help$3))
            if(caml_string_notequal(_m$_,cst_help$4))
             caml_call2(bprintf(b,_a2_),progname,_m$_);
           break;
          case 1:
           var expected=error[3],arg=error[2],opt=error[1];
           caml_call4(bprintf(b,_a5_),progname,arg,opt,expected);
           break;
          case 2:var s=error[1];caml_call2(bprintf(b,_a6_),progname,s);break;
          default:var s$0=error[1];caml_call2(bprintf(b,_a7_),progname,s$0)}
        usage_b(b,speclist[1],errmsg);
        if(! caml_equal(error,_a3_))
         if(! caml_equal(error,_a4_))return [0,Bad,contents(b)];
        return [0,Help,contents(b)]}
      current[1]++;
      for(;;)
       {if(current[1] < argv[1].length - 1)
         {try
           {var _m2_=current[1],s=caml_check_bound(argv[1],_m2_)[1 + _m2_];
            if(1 <= caml_ml_string_length(s))
             if(45 === caml_string_get(s,0))
              {try
                {var
                  follow$1=0,
                  _m4_=assoc3(s,speclist[1]),
                  action=_m4_,
                  follow$0=follow$1}
               catch(_m9_)
                {_m9_ = caml_wrap_exception(_m9_);
                 if(_m9_ !== Not_found)throw _m9_;
                 try
                  {var
                    match=split$0(s),
                    arg=match[2],
                    keyword=match[1],
                    follow=[0,arg],
                    _m3_=assoc3(keyword,speclist[1])}
                 catch(_m__)
                  {_m__ = caml_wrap_exception(_m__);
                   if(_m__ === Not_found)throw [0,Stop,[0,s]];
                   throw _m__;
                   var _m5_=_m__}
                 var action=_m3_,follow$0=follow,_m6_=_m9_}
               var
                no_arg$0=
                 function(s,follow)
                  {function no_arg(param)
                    {if(follow)
                      {var arg=follow[1];throw [0,Stop,[1,s,arg,cst_no_argument]]}
                     return 0}
                   return no_arg},
                no_arg=no_arg$0(s,follow$0),
                get_arg$0=
                 function(s,follow)
                  {function get_arg(param)
                    {if(follow){var arg=follow[1];return arg}
                     if((current[1] + 1 | 0) < argv[1].length - 1)
                      {var _m8_=current[1] + 1 | 0;
                       return caml_check_bound(argv[1],_m8_)[1 + _m8_]}
                     throw [0,Stop,[2,s]]}
                   return get_arg},
                get_arg=get_arg$0(s,follow$0),
                consume_arg$0=
                 function(follow)
                  {function consume_arg(param)
                    {return follow?0:(current[1]++,0)}
                   return consume_arg},
                consume_arg=consume_arg$0(follow$0),
                treat_action$0=
                 function(s,no_arg,get_arg,consume_arg)
                  {function treat_action(param)
                    {switch(param[0])
                      {case 0:var f=param[1];return caml_call1(f,0);
                       case 1:
                        var
                         f$0=param[1],
                         arg=get_arg(0),
                         match=bool_of_string_opt$0(arg);
                        if(match)
                         {var s$0=match[1];caml_call1(f$0,s$0);return consume_arg(0)}
                        throw [0,Stop,[1,s,arg,cst_a_boolean]];
                       case 2:var r=param[1];no_arg(0);r[1] = 1;return 0;
                       case 3:var r$0=param[1];no_arg(0);r$0[1] = 0;return 0;
                       case 4:
                        var f$1=param[1],arg$0=get_arg(0);
                        caml_call1(f$1,arg$0);
                        return consume_arg(0);
                       case 5:
                        var r$1=param[1];r$1[1] = get_arg(0);return consume_arg(0);
                       case 6:
                        var
                         f$2=param[1],
                         arg$1=get_arg(0),
                         match$0=int_of_string_opt$0(arg$1);
                        if(match$0)
                         {var x=match$0[1];caml_call1(f$2,x);return consume_arg(0)}
                        throw [0,Stop,[1,s,arg$1,cst_an_integer]];
                       case 7:
                        var
                         r$2=param[1],
                         arg$2=get_arg(0),
                         match$1=int_of_string_opt$0(arg$2);
                        if(match$1)
                         {var x$0=match$1[1];r$2[1] = x$0;return consume_arg(0)}
                        throw [0,Stop,[1,s,arg$2,cst_an_integer$0]];
                       case 8:
                        var
                         f$3=param[1],
                         arg$3=get_arg(0),
                         match$2=float_of_string_opt$0(arg$3);
                        if(match$2)
                         {var x$1=match$2[1];
                          caml_call1(f$3,x$1);
                          return consume_arg(0)}
                        throw [0,Stop,[1,s,arg$3,cst_a_float]];
                       case 9:
                        var
                         r$3=param[1],
                         arg$4=get_arg(0),
                         match$3=float_of_string_opt$0(arg$4);
                        if(match$3)
                         {var x$2=match$3[1];r$3[1] = x$2;return consume_arg(0)}
                        throw [0,Stop,[1,s,arg$4,cst_a_float$0]];
                       case 10:var specs=param[1];return iter(treat_action,specs);
                       case 11:
                        var f$4=param[2],symb=param[1],arg$5=get_arg(0);
                        if(mem(arg$5,symb))
                         {caml_call1(f$4,arg$5);return consume_arg(0)}
                        throw [0,
                               Stop,
                               [1,
                                s,
                                arg$5,
                                symbol(cst_one_of,make_symlist(cst$57,cst$56,cst$55,symb))]];
                       case 12:
                        var f$5=param[1];
                        for(;;)
                         {if(current[1] < (argv[1].length - 1 - 1 | 0))
                           {var _m7_=current[1] + 1 | 0;
                            caml_call1(f$5,caml_check_bound(argv[1],_m7_)[1 + _m7_]);
                            consume_arg(0);
                            continue}
                          return 0}
                       default:
                        var f$6=param[1];
                        if(1 - allow_expand)
                         throw [0,
                                Invalid_argument,
                                cst_Arg_Expand_is_is_only_allowed_with_Arg_parse_and_expand_argv_dynamic];
                        var arg$6=get_arg(0),newarg=caml_call1(f$6,arg$6);
                        consume_arg(0);
                        var
                         before=sub$1(argv[1],0,current[1] + 1 | 0),
                         after=
                          sub$1
                           (argv[1],
                            current[1] + 1 | 0,
                            (argv[1].length - 1 - current[1] | 0) - 1 | 0);
                        argv[1]
                        =
                        caml_array_concat([0,before,[0,newarg,[0,after,0]]]);
                        return 0}}
                   return treat_action},
                treat_action=treat_action$0(s,no_arg,get_arg,consume_arg);
               treat_action(action);
               var switch$0=1}
             else
              var switch$0=0;
            else
             var switch$0=0;
            if(! switch$0)caml_call1(anonfun,s)}
          catch(exn$0)
           {exn$0 = caml_wrap_exception(exn$0);
            if(exn$0[1] === Bad){var m=exn$0[2];throw convert_error([3,m])}
            if(exn$0[1] === Stop){var e=exn$0[2];throw convert_error(e)}
            throw exn$0;
            var exn=exn$0}
          current[1]++;
          continue}
        return 0}}
    function parse_and_expand_argv_dynamic
     (current,argv,speclist,anonfun,errmsg)
     {return parse_and_expand_argv_dynamic_aux
              (1,current,argv,speclist,anonfun,errmsg)}
    function parse_argv_dynamic(opt,argv,speclist,anonfun,errmsg)
     {if(opt)var sth=opt[1],current$0=sth;else var current$0=current;
      return parse_and_expand_argv_dynamic_aux
              (0,current$0,[0,argv],speclist,anonfun,errmsg)}
    function parse_argv(opt,argv,speclist,anonfun,errmsg)
     {if(opt)var sth=opt[1],current$0=sth;else var current$0=current;
      return parse_argv_dynamic
              ([0,current$0],argv,[0,speclist],anonfun,errmsg)}
    function parse(l,f,msg)
     {try
       {var _m1_=parse_argv(0,_q_,l,f,msg);return _m1_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_a8_),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_a9_),msg$1);return exit(0)}
        throw exn}}
    function parse_dynamic(l,f,msg)
     {try
       {var _m0_=parse_argv_dynamic(0,_q_,l,f,msg);return _m0_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_a__),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_a$_),msg$1);return exit(0)}
        throw exn}}
    function parse_expand(l,f,msg)
     {try
       {var
         argv=[0,_q_],
         spec=[0,l],
         current$0=[0,current[1]],
         _mZ_=parse_and_expand_argv_dynamic(current$0,argv,spec,f,msg);
        return _mZ_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_ba_),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_bb_),msg$1);return exit(0)}
        throw exn}}
    function second_word(s)
     {var len=caml_ml_string_length(s);
      function loop(n)
       {var n$0=n;
        for(;;)
         {if(len <= n$0)return len;
          if(32 === caml_string_get(s,n$0))
           {var n$1=n$0 + 1 | 0,n$0=n$1;continue}
          return n$0}}
      try
       {var n$0=index$0(s,9)}
      catch(_mX_)
       {_mX_ = caml_wrap_exception(_mX_);
        if(_mX_ === Not_found)
         {try
           {var n=index$0(s,32)}
          catch(_mY_)
           {_mY_ = caml_wrap_exception(_mY_);
            if(_mY_ === Not_found)return len;
            throw _mY_}
          return loop(n + 1 | 0)}
        throw _mX_}
      return loop(n$0 + 1 | 0)}
    function max_arg_len(cur,param)
     {var doc=param[3],spec=param[2],kwd=param[1];
      return 11 === spec[0]
              ?max(cur,caml_ml_string_length(kwd))
              :max(cur,caml_ml_string_length(kwd) + second_word(doc) | 0)}
    function replace_leading_tab(s)
     {var seen=[0,0];
      return map$1
              (function(c)
                {if(9 === c)if(! seen[1]){seen[1] = 1;return 32}return c},
               s)}
    function align(opt,speclist)
     {if(opt)var sth=opt[1],limit=sth;else var limit=max_int;
      var
       completed=add_help(speclist),
       len=fold_left(max_arg_len,0,completed),
       len$0=min(len,limit);
      return map
              (function(ksd)
                {var _mV_=ksd[2],_mW_=ksd[1];
                 if(caml_string_notequal(ksd[3],cst$58))
                  {if(11 === _mV_[0])
                    {var
                      msg$0=ksd[3],
                      cutcol$0=second_word(msg$0),
                      spaces$0=make$0(max(0,len$0 - cutcol$0 | 0) + 3 | 0,32);
                     return [0,
                             _mW_,
                             _mV_,
                             symbol(cst$59,symbol(spaces$0,replace_leading_tab(msg$0)))]}
                   var
                    msg=ksd[3],
                    cutcol=second_word(msg),
                    kwd_len=caml_ml_string_length(_mW_),
                    diff=(len$0 - kwd_len | 0) - cutcol | 0;
                   if(0 < diff)
                    {var
                      spaces=make$0(diff,32),
                      prefix=sub$0(replace_leading_tab(msg),0,cutcol),
                      suffix=
                       sub$0(msg,cutcol,caml_ml_string_length(msg) - cutcol | 0);
                     return [0,_mW_,_mV_,symbol(prefix,symbol(spaces,suffix))]}
                   return [0,_mW_,_mV_,replace_leading_tab(msg)]}
                 return ksd},
               completed)}
    function read_aux(trim,sep,file)
     {var ic=open_in_bin(file),buf=create$1(200),words=[0,0];
      function stash(param)
       {var s=contents(buf);
        if(trim)
         {var len=caml_ml_string_length(s);
          if(0 < len)
           if(13 === caml_string_get(s,len - 1 | 0))
            var _mU_=sub$0(s,0,len - 1 | 0),switch$0=1;
           else
            var switch$0=0;
          else
           var switch$0=0;
          if(! switch$0)var _mU_=s;
          var word=_mU_}
        else
         var word=s;
        words[1] = [0,word,words[1]];
        return clear$1(buf)}
      function read(param)
       {try
         {var
           c=caml_ml_input_char(ic),
           _mS_=c === sep?(stash(0),read(0)):(add_char(buf,c),read(0));
          return _mS_}
        catch(_mT_)
         {_mT_ = caml_wrap_exception(_mT_);
          if(_mT_ === End_of_file)
           {var _mR_=0 < buf[2]?1:0;return _mR_?stash(0):_mR_}
          throw _mT_}}
      read(0);
      caml_ml_close_channel(ic);
      return of_list(rev(words[1]))}
    var _bc_=10,_bd_=1;
    function read_arg(_mQ_){return read_aux(_bd_,_bc_,_mQ_)}
    var _be_=0,_bf_=0;
    function read_arg0(_mP_){return read_aux(_bf_,_be_,_mP_)}
    function write_aux(sep,file,args)
     {var oc=open_out_bin(file);
      iter$2(function(s){return caml_call2(fprintf(oc,_bg_),s,sep)},args);
      return close_out(oc)}
    var _bh_=10;
    function write_arg(_mN_,_mO_){return write_aux(_bh_,_mN_,_mO_)}
    var _bi_=0;
    function write_arg0(_mL_,_mM_){return write_aux(_bi_,_mL_,_mM_)}
    var
     Arg=
      [0,
       parse,
       parse_dynamic,
       parse_argv,
       parse_argv_dynamic,
       parse_and_expand_argv_dynamic,
       parse_expand,
       Help,
       Bad,
       usage,
       usage_string,
       align,
       current,
       read_arg,
       read_arg0,
       write_arg,
       write_arg0];
    caml_register_global(670,Arg,"Arg");
    var printers=[0,0];
    function field(x,i)
     {var f=x[1 + i];
      return is_block(f)
              ?caml_obj_tag(f) === 252
                ?caml_call1(sprintf(_bj_),f)
                :caml_obj_tag(f) === 253?string_of_float(f):cst$60
              :caml_call1(sprintf(_bk_),f)}
    function other_fields(x,i)
     {if(x.length - 1 <= i)return cst$61;
      var _mJ_=other_fields(x,i + 1 | 0),_mK_=field(x,i);
      return caml_call2(sprintf(_bl_),_mK_,_mJ_)}
    function fields(x)
     {var match=x.length - 1;
      if(2 < match >>> 0)
       {var _mG_=other_fields(x,2),_mH_=field(x,1);
        return caml_call2(sprintf(_bm_),_mH_,_mG_)}
      switch(match)
       {case 0:return cst$62;
        case 1:return cst$63;
        default:var _mI_=field(x,1);return caml_call1(sprintf(_bn_),_mI_)}}
    function to_string$3(x)
     {function conv(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var tl=param$0[2],hd=param$0[1];
            try {var _mE_=caml_call1(hd,x),_mD_=_mE_}catch(_mF_){var _mD_=0}
            if(_mD_){var s=_mD_[1];return s}
            var param$0=tl;
            continue}
          if(x === Out_of_memory)return cst_Out_of_memory;
          if(x === Stack_overflow)return cst_Stack_overflow;
          if(x[1] === Match_failure)
           {var match=x[2],char$0=match[3],line=match[2],file=match[1];
            return caml_call5
                    (sprintf(locfmt),
                     file,
                     line,
                     char$0,
                     char$0 + 5 | 0,
                     cst_Pattern_matching_failed)}
          if(x[1] === Assert_failure)
           {var
             match$0=x[2],
             char$1=match$0[3],
             line$0=match$0[2],
             file$0=match$0[1];
            return caml_call5
                    (sprintf(locfmt),
                     file$0,
                     line$0,
                     char$1,
                     char$1 + 6 | 0,
                     cst_Assertion_failed)}
          if(x[1] === Undefined_recursive_module)
           {var
             match$1=x[2],
             char$2=match$1[3],
             line$1=match$1[2],
             file$1=match$1[1];
            return caml_call5
                    (sprintf(locfmt),
                     file$1,
                     line$1,
                     char$2,
                     char$2 + 6 | 0,
                     cst_Undefined_recursive_module)}
          if(0 === caml_obj_tag(x))
           {var constructor=x[1][1];return symbol(constructor,fields(x))}
          return x[1]}}
      return conv(printers[1])}
    function print(fct,arg)
     {try
       {var _mC_=caml_call1(fct,arg);return _mC_}
      catch(x)
       {x = caml_wrap_exception(x);
        var _mB_=to_string$3(x);
        caml_call1(eprintf(_bo_),_mB_);
        caml_ml_flush(stderr);
        throw x}}
    function catch$0(fct,arg)
     {try
       {var _mA_=caml_call1(fct,arg);return _mA_}
      catch(x)
       {x = caml_wrap_exception(x);
        caml_ml_flush(stdout);
        var _mz_=to_string$3(x);
        caml_call1(eprintf(_bp_),_mz_);
        return exit(2)}}
    function convert_raw_backtrace(bt)
     {return [0,runtime.caml_convert_raw_backtrace(bt)]}
    function format_backtrace_slot(pos,slot)
     {function info(is_raise)
       {return is_raise
                ?0 === pos?cst_Raised_at:cst_Re_raised_at
                :0 === pos
                  ?cst_Raised_by_primitive_operation_at
                  :cst_Called_from}
      if(0 === slot[0])
       {var
         _ms_=slot[5],
         _mt_=slot[4],
         _mu_=slot[3],
         _mv_=slot[6]?cst_inlined:cst$64,
         _mw_=slot[2],
         _mx_=info(slot[1]);
        return [0,caml_call6(sprintf(_bq_),_mx_,_mw_,_mv_,_mu_,_mt_,_ms_)]}
      if(slot[1])return 0;
      var _my_=info(0);
      return [0,caml_call1(sprintf(_br_),_my_)]}
    function print_raw_backtrace(outchan,raw_backtrace)
     {var backtrace=convert_raw_backtrace(raw_backtrace);
      if(backtrace)
       {var a=backtrace[1],_mq_=a.length - 1 - 1 | 0,_mp_=0;
        if(! (_mq_ < 0))
         {var i=_mp_;
          for(;;)
           {var match=format_backtrace_slot(i,caml_check_bound(a,i)[1 + i]);
            if(match){var str=match[1];caml_call1(fprintf(outchan,_bs_),str)}
            var _mr_=i + 1 | 0;
            if(_mq_ !== i){var i=_mr_;continue}
            break}}
        return 0}
      return fprintf(outchan,_bt_)}
    function print_backtrace(outchan)
     {return print_raw_backtrace(outchan,caml_get_exception_raw_backtrace(0))}
    function raw_backtrace_to_string(raw_backtrace)
     {var backtrace=convert_raw_backtrace(raw_backtrace);
      if(backtrace)
       {var a=backtrace[1],b=create$1(1024),_mn_=a.length - 1 - 1 | 0,_mm_=0;
        if(! (_mn_ < 0))
         {var i=_mm_;
          for(;;)
           {var match=format_backtrace_slot(i,caml_check_bound(a,i)[1 + i]);
            if(match){var str=match[1];caml_call1(bprintf(b,_bu_),str)}
            var _mo_=i + 1 | 0;
            if(_mn_ !== i){var i=_mo_;continue}
            break}}
        return contents(b)}
      return cst_Program_not_linked_with_g_cannot_print_stack_backtrace}
    function backtrace_slot_is_raise(param)
     {return 0 === param[0]?param[1]:param[1]}
    function backtrace_slot_is_inline(param){return 0 === param[0]?param[6]:0}
    function backtrace_slot_location(param)
     {return 0 === param[0]?[0,[0,param[2],param[3],param[4],param[5]]]:0}
    function backtrace_slots(raw_backtrace)
     {var match=convert_raw_backtrace(raw_backtrace);
      if(match)
       {var backtrace=match[1],i$1=backtrace.length - 1 - 1 | 0,i=i$1;
        for(;;)
         {if(-1 === i)
           var _ml_=0;
          else
           {var
             param=caml_check_bound(backtrace,i)[1 + i],
             _mk_=0 === param[0]?1:0;
            if(! _mk_){var i$0=i - 1 | 0,i=i$0;continue}
            var _ml_=_mk_}
          return _ml_?[0,backtrace]:0}}
      return 0}
    function get_backtrace(param)
     {return raw_backtrace_to_string(caml_get_exception_raw_backtrace(0))}
    function register_printer(fn){printers[1] = [0,fn,printers[1]];return 0}
    function exn_slot(x){return 0 === caml_obj_tag(x)?x[1]:x}
    function exn_slot_id(x){var slot=exn_slot(x);return slot[2]}
    function exn_slot_name(x){var slot=exn_slot(x);return slot[1]}
    var uncaught_exception_handler=[0,0];
    function set_uncaught_exception_handler(fn)
     {uncaught_exception_handler[1] = [0,fn];return 0}
    function _bv_(_mj_){return runtime.caml_raw_backtrace_next_slot(_mj_)}
    function _bw_(_mi_){return runtime.caml_convert_raw_backtrace_slot(_mi_)}
    function _bx_(_mh_,_mg_)
     {return runtime.caml_raw_backtrace_slot(_mh_,_mg_)}
    function _by_(_mf_){return runtime.caml_raw_backtrace_length(_mf_)}
    var
     _bz_=
      [0,
       backtrace_slot_is_raise,
       backtrace_slot_is_inline,
       backtrace_slot_location,
       format_backtrace_slot];
    function _bA_(_me_){return runtime.caml_get_current_callstack(_me_)}
    function _bB_(_md_){return caml_get_exception_raw_backtrace(_md_)}
    function _bC_(_mc_){return runtime.caml_backtrace_status(_mc_)}
    var
     Printexc=
      [0,
       to_string$3,
       print,
       catch$0,
       print_backtrace,
       get_backtrace,
       function(_mb_){return runtime.caml_record_backtrace(_mb_)},
       _bC_,
       register_printer,
       _bB_,
       print_raw_backtrace,
       raw_backtrace_to_string,
       _bA_,
       set_uncaught_exception_handler,
       backtrace_slots,
       _bz_,
       _by_,
       _bx_,
       _bw_,
       _bv_,
       exn_slot_id,
       exn_slot_name];
    caml_register_global(675,Printexc,"Printexc");
    function print_stat(c)
     {var st=runtime.caml_gc_stat(0),_lW_=st[4];
      caml_call1(fprintf(c,_bD_),_lW_);
      var _lX_=st[5];
      caml_call1(fprintf(c,_bE_),_lX_);
      var _lY_=st[14];
      caml_call1(fprintf(c,_bF_),_lY_);
      fprintf(c,_bG_);
      var
       _lZ_=st[1],
       l1=caml_ml_string_length(caml_call1(sprintf(_bH_),_lZ_)),
       _l0_=st[1];
      caml_call2(fprintf(c,_bI_),l1,_l0_);
      var _l1_=st[2];
      caml_call2(fprintf(c,_bJ_),l1,_l1_);
      var _l2_=st[3];
      caml_call2(fprintf(c,_bK_),l1,_l2_);
      fprintf(c,_bL_);
      var
       _l3_=st[15],
       l2=caml_ml_string_length(caml_call1(sprintf(_bM_),_l3_)),
       _l4_=st[15];
      caml_call2(fprintf(c,_bN_),l2,_l4_);
      var _l5_=st[6];
      caml_call2(fprintf(c,_bO_),l2,_l5_);
      var _l6_=st[8];
      caml_call2(fprintf(c,_bP_),l2,_l6_);
      var _l7_=st[10];
      caml_call2(fprintf(c,_bQ_),l2,_l7_);
      var _l8_=st[12];
      caml_call2(fprintf(c,_bR_),l2,_l8_);
      var _l9_=st[13];
      caml_call2(fprintf(c,_bS_),l2,_l9_);
      fprintf(c,_bT_);
      var _l__=st[9];
      caml_call1(fprintf(c,_bU_),_l__);
      var _l$_=st[11];
      caml_call1(fprintf(c,_bV_),_l$_);
      var _ma_=st[7];
      return caml_call1(fprintf(c,_bW_),_ma_)}
    function allocated_bytes(param)
     {var
       match=runtime.caml_gc_counters(0),
       ma=match[3],
       pro=match[2],
       mi=match[1];
      return (mi + ma - pro) * 4}
    function create_alarm(f){return [0,1]}
    function delete_alarm(a){a[1] = 0;return 0}
    function _bX_(_lV_){return runtime.caml_final_release(_lV_)}
    function _bY_(_lU_,_lT_)
     {return runtime.caml_final_register_called_without_value(_lU_,_lT_)}
    var
     Gc=
      [0,
       print_stat,
       allocated_bytes,
       function(_lS_,_lR_){return runtime.caml_final_register(_lS_,_lR_)},
       _bY_,
       _bX_,
       create_alarm,
       delete_alarm];
    caml_register_global(676,Gc,"Gc");
    function string(str)
     {return caml_md5_string(str,0,caml_ml_string_length(str))}
    function bytes(b){return string(b)}
    function substring(str,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_string_length(str) - len | 0) < ofs))
         return caml_md5_string(str,ofs,len);
      return invalid_arg(cst_Digest_substring)}
    function subbytes(b,ofs,len){return substring(b,ofs,len)}
    function file(filename)
     {var ic=open_in_bin(filename);
      try
       {var d=runtime.caml_md5_chan(ic,-1)}
      catch(e){e = caml_wrap_exception(e);caml_ml_close_channel(ic);throw e}
      caml_ml_close_channel(ic);
      return d}
    function output$0(chan,digest){return output_string(chan,digest)}
    function input$0(chan){return really_input_string(chan,16)}
    function char_hex(n){var _lQ_=10 <= n?87:48;return n + _lQ_ | 0}
    function to_hex(d)
     {if(16 !== caml_ml_string_length(d))invalid_arg(cst_Digest_to_hex);
      var result=caml_create_bytes(32),i=0;
      for(;;)
       {var x=caml_string_get(d,i);
        caml_bytes_unsafe_set(result,i * 2 | 0,char_hex(x >>> 4 | 0));
        caml_bytes_unsafe_set(result,(i * 2 | 0) + 1 | 0,char_hex(x & 15));
        var _lP_=i + 1 | 0;
        if(15 !== i){var i=_lP_;continue}
        return result}}
    function from_hex(s)
     {if(32 !== caml_ml_string_length(s))invalid_arg(cst_Digest_from_hex);
      function digit(c)
       {if(65 <= c)
         {if(97 <= c)
           {if(! (103 <= c))return (c - 97 | 0) + 10 | 0}
          else
           if(! (71 <= c))return (c - 65 | 0) + 10 | 0}
        else
         {var switcher=c - 48 | 0;if(! (9 < switcher >>> 0))return c - 48 | 0}
        throw [0,Invalid_argument,cst_Digest_from_hex$0]}
      var result=caml_create_bytes(16),i=0;
      for(;;)
       {var i$0=2 * i | 0,_lN_=digit(caml_string_get(s,i$0 + 1 | 0));
        caml_bytes_set
         (result,i,chr((digit(caml_string_get(s,i$0)) << 4) + _lN_ | 0));
        var _lO_=i + 1 | 0;
        if(15 !== i){var i=_lO_;continue}
        return result}}
    var
     Digest=
      [0,
       compare$2,
       equal$2,
       string,
       bytes,
       substring,
       subbytes,
       file,
       output$0,
       input$0,
       to_hex,
       from_hex];
    caml_register_global(677,Digest,"Digest");
    function new_state(param){return [0,caml_make_vect(55,0),0]}
    function assign(st1,st2)
     {blit$1(st2[1],0,st1[1],0,55);st1[2] = st2[2];return 0}
    function full_init(s,seed)
     {var seed$0=0 === seed.length - 1?[0,0]:seed,l=seed$0.length - 1,i$0=0;
      for(;;)
       {caml_check_bound(s[1],i$0)[1 + i$0] = i$0;
        var _lM_=i$0 + 1 | 0;
        if(54 !== i$0){var i$0=_lM_;continue}
        var accu=[0,cst_x$1],_lI_=54 + max(55,l) | 0,_lH_=0;
        if(! (_lI_ < 0))
         {var i=_lH_;
          for(;;)
           {var
             j=i % 55 | 0,
             k=caml_mod(i,l),
             x=caml_check_bound(seed$0,k)[1 + k];
            accu[1] = string(symbol(accu[1],caml_new_string("" + x)));
            var
             _lJ_=accu[1],
             _lD_=caml_string_get(_lJ_,3) << 24,
             _lE_=caml_string_get(_lJ_,2) << 16,
             _lF_=caml_string_get(_lJ_,1) << 8,
             _lG_=((caml_string_get(_lJ_,0) + _lF_ | 0) + _lE_ | 0) + _lD_ | 0,
             _lK_=(caml_check_bound(s[1],j)[1 + j] ^ _lG_) & 1073741823;
            caml_check_bound(s[1],j)[1 + j] = _lK_;
            var _lL_=i + 1 | 0;
            if(_lI_ !== i){var i=_lL_;continue}
            break}}
        s[2] = 0;
        return 0}}
    function make$1(seed)
     {var result=new_state(0);full_init(result,seed);return result}
    function make_self_init(param){return make$1(caml_sys_random_seed(0))}
    function copy$4(s){var result=new_state(0);assign(result,s);return result}
    function bits(s)
     {s[2] = (s[2] + 1 | 0) % 55 | 0;
      var
       _lA_=s[2],
       curval=caml_check_bound(s[1],_lA_)[1 + _lA_],
       _lB_=(s[2] + 24 | 0) % 55 | 0,
       newval=
        caml_check_bound(s[1],_lB_)[1 + _lB_]
        +
        (curval ^ (curval >>> 25 | 0) & 31)
        |
        0,
       newval30=newval & 1073741823,
       _lC_=s[2];
      caml_check_bound(s[1],_lC_)[1 + _lC_] = newval30;
      return newval30}
    function int$0(s,bound)
     {if(! (1073741823 < bound))
       if(0 < bound)
        for(;;)
         {var r=bits(s),v=caml_mod(r,bound);
          if(((1073741823 - bound | 0) + 1 | 0) < (r - v | 0))continue;
          return v}
      return invalid_arg(cst_Random_int)}
    function int32(s,bound)
     {if(caml_lessequal(bound,0))return invalid_arg(cst_Random_int32);
      for(;;)
       {var b1=bits(s),b2=(bits(s) & 1) << 30,r=b1 | b2,v=caml_mod(r,bound);
        if(caml_greaterthan(r - v | 0,(2147483647 - bound | 0) + 1 | 0))
         continue;
        return v}}
    function int64(s,bound)
     {if(caml_lessequal(bound,_b0_))return invalid_arg(cst_Random_int64);
      for(;;)
       {var
         b1=caml_int64_of_int32(bits(s)),
         b2=caml_int64_shift_left(caml_int64_of_int32(bits(s)),30),
         b3=caml_int64_shift_left(caml_int64_of_int32(bits(s) & 7),60),
         r=caml_int64_or(b1,caml_int64_or(b2,b3)),
         v=runtime.caml_int64_mod(r,bound);
        if
         (caml_greaterthan
           (caml_int64_sub(r,v),
            caml_int64_add(caml_int64_sub(max_int$1,bound),_bZ_)))
         continue;
        return v}}
    function nativeint(s,bound){return int32(s,bound)}
    function float$0(s,bound)
     {var r1=bits(s),r2=bits(s);
      return (r1 / 1073741824. + r2) / 1073741824. * bound}
    function bool(s){return 0 === (bits(s) & 1)?1:0}
    var default$0=[0,_b1_.slice(),0];
    function bits$0(param){return bits(default$0)}
    function int$1(bound){return int$0(default$0,bound)}
    function int32$0(bound){return int32(default$0,bound)}
    function nativeint$0(bound){return nativeint(default$0,bound)}
    function int64$0(bound){return int64(default$0,bound)}
    function float$1(scale){return float$0(default$0,scale)}
    function bool$0(param){return bool(default$0)}
    function full_init$0(seed){return full_init(default$0,seed)}
    function init$3(seed){return full_init(default$0,[0,seed])}
    function self_init(param){return full_init$0(caml_sys_random_seed(0))}
    function get_state(param){return copy$4(default$0)}
    function set_state(s){return assign(default$0,s)}
    var
     _b2_=
      [0,
       make$1,
       make_self_init,
       copy$4,
       bits,
       int$0,
       int32,
       nativeint,
       int64,
       float$0,
       bool],
     Random=
      [0,
       init$3,
       full_init$0,
       self_init,
       bits$0,
       int$1,
       int32$0,
       nativeint$0,
       int64$0,
       float$1,
       bool$0,
       _b2_,
       get_state,
       set_state];
    caml_register_global(678,Random,"Random");
    function hash$0(x){return caml_hash(10,100,0,x)}
    function hash_param(n1,n2,x){return caml_hash(n1,n2,0,x)}
    function seeded_hash(seed,x){return caml_hash(10,100,seed,x)}
    function ongoing_traversal(h)
     {var _ly_=h.length - 1 < 4?1:0,_lz_=_ly_ || (h[4] < 0?1:0);return _lz_}
    function flip_ongoing_traversal(h){h[4] = - h[4] | 0;return 0}
    try
     {var _cH_=caml_sys_getenv(cst_OCAMLRUNPARAM),params=_cH_}
    catch(_lw_)
     {_lw_ = caml_wrap_exception(_lw_);
      if(_lw_ !== Not_found)throw _lw_;
      try
       {var _cG_=caml_sys_getenv(cst_CAMLRUNPARAM),_b3_=_cG_}
      catch(_lx_)
       {_lx_ = caml_wrap_exception(_lx_);
        if(_lx_ !== Not_found)throw _lx_;
        var _b3_=cst$65}
      var params=_b3_}
    var
     randomized_default=contains$0(params,82),
     randomized=[0,randomized_default];
    function randomize(param){randomized[1] = 1;return 0}
    function is_randomized(param){return randomized[1]}
    var prng=[246,function(_lv_){return caml_call1(_b2_[2],0)}];
    function create$2(opt,initial_size)
     {if(opt)var sth=opt[1],random=sth;else var random=randomized[1];
      var x=16;
      for(;;)
       {if(! (initial_size <= x))
         if(! (max_array_length < (x * 2 | 0)))
          {var x$0=x * 2 | 0,x=x$0;continue}
        if(random)
         var
          _lt_=caml_obj_tag(prng),
          _lu_=250 === _lt_?prng[1]:246 === _lt_?force_lazy_block(prng):prng,
          seed=caml_call1(_b2_[4],_lu_);
        else
         var seed=0;
        return [0,0,caml_make_vect(x,0),seed,x]}}
    function clear$2(h)
     {h[1] = 0;
      var len=h[2].length - 1,_lr_=len - 1 | 0,_lq_=0;
      if(! (_lr_ < 0))
       {var i=_lq_;
        for(;;)
         {caml_check_bound(h[2],i)[1 + i] = 0;
          var _ls_=i + 1 | 0;
          if(_lr_ !== i){var i=_ls_;continue}
          break}}
      return 0}
    function reset$0(h)
     {var len=h[2].length - 1;
      if(4 <= h.length - 1)
       if(len !== abs(h[4]))
        {h[1] = 0;h[2] = caml_make_vect(abs(h[4]),0);return 0}
      return clear$2(h)}
    function copy_bucketlist(param)
     {if(param)
       {var
         key=param[1],
         data=param[2],
         next=param[3],
         prec$0=[0,key,data,next],
         prec=prec$0,
         param$0=next;
        for(;;)
         {if(param$0)
           {var
             key$0=param$0[1],
             data$0=param$0[2],
             next$0=param$0[3],
             r=[0,key$0,data$0,next$0];
            if(prec){prec[3] = r;var prec=r,param$0=next$0;continue}
            throw [0,Assert_failure,_b4_]}
          return prec$0}}
      return 0}
    function copy$5(init)
     {var _ln_=init[4],_lo_=init[3],_lp_=map$2(copy_bucketlist,init[2]);
      return [0,init[1],_lp_,_lo_,_ln_]}
    function length$4(h){return h[1]}
    function resize$0(indexfun,h)
     {var
       odata=h[2],
       osize=odata.length - 1,
       nsize=osize * 2 | 0,
       _le_=nsize < max_array_length?1:0;
      if(_le_)
       {var
         ndata=caml_make_vect(nsize,0),
         ndata_tail=caml_make_vect(nsize,0),
         inplace=1 - ongoing_traversal(h);
        h[2] = ndata;
        var _lg_=osize - 1 | 0,_lf_=0;
        if(! (_lg_ < 0))
         {var i$0=_lf_;
          a:
          for(;;)
           {var cell$1=caml_check_bound(odata,i$0)[1 + i$0],cell=cell$1;
            for(;;)
             {if(cell)
               {var
                 key=cell[1],
                 data=cell[2],
                 next=cell[3],
                 cell$0=inplace?cell:[0,key,data,0],
                 nidx=caml_call2(indexfun,h,key),
                 match=caml_check_bound(ndata_tail,nidx)[1 + nidx];
                if(match)
                 match[3] = cell$0;
                else
                 caml_check_bound(ndata,nidx)[1 + nidx] = cell$0;
                caml_check_bound(ndata_tail,nidx)[1 + nidx] = cell$0;
                var cell=next;
                continue}
              var _lm_=i$0 + 1 | 0;
              if(_lg_ !== i$0){var i$0=_lm_;continue a}
              break}
            break}}
        if(inplace)
         {var _li_=nsize - 1 | 0,_lh_=0;
          if(! (_li_ < 0))
           {var i=_lh_;
            for(;;)
             {var match$0=caml_check_bound(ndata_tail,i)[1 + i];
              if(match$0)match$0[3] = 0;
              var _ll_=i + 1 | 0;
              if(_li_ !== i){var i=_ll_;continue}
              break}}
          var _lj_=0}
        else
         var _lj_=inplace;
        var _lk_=_lj_}
      else
       var _lk_=_le_;
      return _lk_}
    function key_index(h,key)
     {return 3 <= h.length - 1
              ?caml_hash(10,100,h[3],key) & (h[2].length - 1 - 1 | 0)
              :caml_mod
                (runtime.caml_hash_univ_param(10,100,key),h[2].length - 1)}
    function add$0(h,key,data)
     {var
       i=key_index(h,key),
       bucket=[0,key,data,caml_check_bound(h[2],i)[1 + i]];
      caml_check_bound(h[2],i)[1 + i] = bucket;
      h[1] = h[1] + 1 | 0;
      var _ld_=h[2].length - 1 << 1 < h[1]?1:0;
      return _ld_?resize$0(key_index,h):_ld_}
    function remove(h,key)
     {var i=key_index(h,key),c$0=caml_check_bound(h[2],i)[1 + i],prec=0,c=c$0;
      for(;;)
       {if(c)
         {var k=c[1],next=c[3];
          if(0 === caml_compare(k,key))
           {h[1] = h[1] - 1 | 0;
            return prec
                    ?(prec[3] = next,0)
                    :(caml_check_bound(h[2],i)[1 + i] = next,0)}
          var prec=c,c=next;
          continue}
        return 0}}
    function find$0(h,key)
     {var _lc_=key_index(h,key),match=caml_check_bound(h[2],_lc_)[1 + _lc_];
      if(match)
       {var k1=match[1],d1=match[2],next1=match[3];
        if(0 === caml_compare(key,k1))return d1;
        if(next1)
         {var k2=next1[1],d2=next1[2],next2=next1[3];
          if(0 === caml_compare(key,k2))return d2;
          if(next2)
           {var k3=next2[1],d3=next2[2],next3=next2[3];
            if(0 === caml_compare(key,k3))return d3;
            var param=next3;
            for(;;)
             {if(param)
               {var k=param[1],data=param[2],next=param[3];
                if(0 === caml_compare(key,k))return data;
                var param=next;
                continue}
              throw Not_found}}
          throw Not_found}
        throw Not_found}
      throw Not_found}
    function find_opt$0(h,key)
     {var _lb_=key_index(h,key),match=caml_check_bound(h[2],_lb_)[1 + _lb_];
      if(match)
       {var k1=match[1],d1=match[2],next1=match[3];
        if(0 === caml_compare(key,k1))return [0,d1];
        if(next1)
         {var k2=next1[1],d2=next1[2],next2=next1[3];
          if(0 === caml_compare(key,k2))return [0,d2];
          if(next2)
           {var k3=next2[1],d3=next2[2],next3=next2[3];
            if(0 === caml_compare(key,k3))return [0,d3];
            var param=next3;
            for(;;)
             {if(param)
               {var k=param[1],data=param[2],next=param[3];
                if(0 === caml_compare(key,k))return [0,data];
                var param=next;
                continue}
              return 0}}
          return 0}
        return 0}
      return 0}
    function find_all$0(h,key)
     {function find_in_bucket(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var k=param$0[1],data=param$0[2],next=param$0[3];
            if(0 === caml_compare(k,key))return [0,data,find_in_bucket(next)];
            var param$0=next;
            continue}
          return 0}}
      var _la_=key_index(h,key);
      return find_in_bucket(caml_check_bound(h[2],_la_)[1 + _la_])}
    function replace(h,key,data)
     {var
       i=key_index(h,key),
       param$0=caml_check_bound(h[2],i)[1 + i],
       param=param$0;
      for(;;)
       {if(param)
         {var k=param[1],next=param[3];
          if(0 !== caml_compare(k,key)){var param=next;continue}
          param[1] = key;
          param[2] = data;
          var _k9_=0}
        else
         var _k9_=1;
        if(_k9_)
         {caml_check_bound(h[2],i)[1 + i] = [0,key,data,param$0];
          h[1] = h[1] + 1 | 0;
          var _k__=h[2].length - 1 << 1 < h[1]?1:0;
          if(_k__)return resize$0(key_index,h);
          var _k$_=_k__}
        else
         var _k$_=_k9_;
        return _k$_}}
    function mem$1(h,key)
     {var
       _k8_=key_index(h,key),
       param$0=caml_check_bound(h[2],_k8_)[1 + _k8_],
       param=param$0;
      for(;;)
       {if(param)
         {var k=param[1],next=param[3],_k7_=0 === caml_compare(k,key)?1:0;
          if(_k7_)return _k7_;
          var param=next;
          continue}
        return 0}}
    function iter$6(f,h)
     {function do_bucket(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var key=param$0[1],data=param$0[2],next=param$0[3];
            caml_call2(f,key,data);
            var param$0=next;
            continue}
          return 0}}
      var old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var d=h[2],_k3_=d.length - 1 - 1 | 0,_k2_=0;
        if(! (_k3_ < 0))
         {var i=_k2_;
          for(;;)
           {do_bucket(caml_check_bound(d,i)[1 + i]);
            var _k6_=i + 1 | 0;
            if(_k3_ !== i){var i=_k6_;continue}
            break}}
        var _k4_=1 - old_trav,_k5_=_k4_?flip_ongoing_traversal(h):_k4_;
        return _k5_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function filter_map_inplace_bucket(f,h,i,prec,slot)
     {var prec$0=prec,slot$0=slot;
      for(;;)
       {if(slot$0)
         {var
           key=slot$0[1],
           data=slot$0[2],
           next=slot$0[3],
           match=caml_call2(f,key,data);
          if(match)
           {var data$0=match[1];
            if(prec$0)
             prec$0[3] = slot$0;
            else
             caml_check_bound(h[2],i)[1 + i] = slot$0;
            slot$0[2] = data$0;
            var prec$0=slot$0,slot$0=next;
            continue}
          h[1] = h[1] - 1 | 0;
          var slot$0=next;
          continue}
        return prec$0
                ?(prec$0[3] = 0,0)
                :(caml_check_bound(h[2],i)[1 + i] = 0,0)}}
    function filter_map_inplace(f,h)
     {var d=h[2],old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var _kZ_=d.length - 1 - 1 | 0,_kY_=0;
        if(! (_kZ_ < 0))
         {var i=_kY_;
          for(;;)
           {filter_map_inplace_bucket(f,h,i,0,caml_check_bound(h[2],i)[1 + i]);
            var _k1_=i + 1 | 0;
            if(_kZ_ !== i){var i=_k1_;continue}
            break}}
        var _k0_=0;
        return _k0_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function fold$1(f,h,init)
     {function do_bucket(b,accu)
       {var b$0=b,accu$0=accu;
        for(;;)
         {if(b$0)
           {var
             key=b$0[1],
             data=b$0[2],
             next=b$0[3],
             accu$1=caml_call3(f,key,data,accu$0),
             b$0=next,
             accu$0=accu$1;
            continue}
          return accu$0}}
      var old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var d=h[2],accu=[0,init],_kU_=d.length - 1 - 1 | 0,_kT_=0;
        if(! (_kU_ < 0))
         {var i=_kT_;
          for(;;)
           {var _kW_=accu[1];
            accu[1] = do_bucket(caml_check_bound(d,i)[1 + i],_kW_);
            var _kX_=i + 1 | 0;
            if(_kU_ !== i){var i=_kX_;continue}
            break}}
        if(1 - old_trav)flip_ongoing_traversal(h);
        var _kV_=accu[1];
        return _kV_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function bucket_length(accu,param)
     {var accu$0=accu,param$0=param;
      for(;;)
       {if(param$0)
         {var
           param$1=param$0[3],
           accu$1=accu$0 + 1 | 0,
           accu$0=accu$1,
           param$0=param$1;
          continue}
        return accu$0}}
    function stats(h)
     {var
       _kQ_=h[2],
       _kR_=0,
       mbl=
        fold_left$0(function(m,b){return max(m,bucket_length(0,b))},_kR_,_kQ_),
       histo=caml_make_vect(mbl + 1 | 0,0),
       _kS_=h[2];
      iter$2
       (function(b)
         {var l=bucket_length(0,b);
          histo[1 + l] = caml_check_bound(histo,l)[1 + l] + 1 | 0;
          return 0},
        _kS_);
      return [0,h[1],h[2].length - 1,mbl,histo]}
    function MakeSeeded(H)
     {function key_index(h,key)
       {var _kP_=h[2].length - 1 - 1 | 0;
        return caml_call2(H[2],h[3],key) & _kP_}
      function add(h,key,data)
       {var
         i=key_index(h,key),
         bucket=[0,key,data,caml_check_bound(h[2],i)[1 + i]];
        caml_check_bound(h[2],i)[1 + i] = bucket;
        h[1] = h[1] + 1 | 0;
        var _kO_=h[2].length - 1 << 1 < h[1]?1:0;
        return _kO_?resize$0(key_index,h):_kO_}
      function remove(h,key)
       {var
         i=key_index(h,key),
         c$0=caml_check_bound(h[2],i)[1 + i],
         prec=0,
         c=c$0;
        for(;;)
         {if(c)
           {var k=c[1],next=c[3];
            if(caml_call2(H[1],k,key))
             {h[1] = h[1] - 1 | 0;
              return prec
                      ?(prec[3] = next,0)
                      :(caml_check_bound(h[2],i)[1 + i] = next,0)}
            var prec=c,c=next;
            continue}
          return 0}}
      function find(h,key)
       {var _kN_=key_index(h,key),match=caml_check_bound(h[2],_kN_)[1 + _kN_];
        if(match)
         {var k1=match[1],d1=match[2],next1=match[3];
          if(caml_call2(H[1],key,k1))return d1;
          if(next1)
           {var k2=next1[1],d2=next1[2],next2=next1[3];
            if(caml_call2(H[1],key,k2))return d2;
            if(next2)
             {var k3=next2[1],d3=next2[2],next3=next2[3];
              if(caml_call2(H[1],key,k3))return d3;
              var param=next3;
              for(;;)
               {if(param)
                 {var k=param[1],data=param[2],next=param[3];
                  if(caml_call2(H[1],key,k))return data;
                  var param=next;
                  continue}
                throw Not_found}}
            throw Not_found}
          throw Not_found}
        throw Not_found}
      function find_opt(h,key)
       {var _kM_=key_index(h,key),match=caml_check_bound(h[2],_kM_)[1 + _kM_];
        if(match)
         {var k1=match[1],d1=match[2],next1=match[3];
          if(caml_call2(H[1],key,k1))return [0,d1];
          if(next1)
           {var k2=next1[1],d2=next1[2],next2=next1[3];
            if(caml_call2(H[1],key,k2))return [0,d2];
            if(next2)
             {var k3=next2[1],d3=next2[2],next3=next2[3];
              if(caml_call2(H[1],key,k3))return [0,d3];
              var param=next3;
              for(;;)
               {if(param)
                 {var k=param[1],data=param[2],next=param[3];
                  if(caml_call2(H[1],key,k))return [0,data];
                  var param=next;
                  continue}
                return 0}}
            return 0}
          return 0}
        return 0}
      function find_all(h,key)
       {function find_in_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var k=param$0[1],d=param$0[2],next=param$0[3];
              if(caml_call2(H[1],k,key))return [0,d,find_in_bucket(next)];
              var param$0=next;
              continue}
            return 0}}
        var _kL_=key_index(h,key);
        return find_in_bucket(caml_check_bound(h[2],_kL_)[1 + _kL_])}
      function replace(h,key,data)
       {var
         i=key_index(h,key),
         param$0=caml_check_bound(h[2],i)[1 + i],
         param=param$0;
        for(;;)
         {if(param)
           {var k=param[1],next=param[3];
            if(! caml_call2(H[1],k,key)){var param=next;continue}
            param[1] = key;
            param[2] = data;
            var _kI_=0}
          else
           var _kI_=1;
          if(_kI_)
           {caml_check_bound(h[2],i)[1 + i] = [0,key,data,param$0];
            h[1] = h[1] + 1 | 0;
            var _kJ_=h[2].length - 1 << 1 < h[1]?1:0;
            if(_kJ_)return resize$0(key_index,h);
            var _kK_=_kJ_}
          else
           var _kK_=_kI_;
          return _kK_}}
      function mem(h,key)
       {var
         _kH_=key_index(h,key),
         param$0=caml_check_bound(h[2],_kH_)[1 + _kH_],
         param=param$0;
        for(;;)
         {if(param)
           {var k=param[1],next=param[3],_kG_=caml_call2(H[1],k,key);
            if(_kG_)return _kG_;
            var param=next;
            continue}
          return 0}}
      return [0,
              create$2,
              clear$2,
              reset$0,
              copy$5,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter$6,
              filter_map_inplace,
              fold$1,
              length$4,
              stats]}
    function Make(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       _kF_=include[1];
      function create(sz){return caml_call2(_kF_,_b5_,sz)}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats]}
    var
     Hashtbl=
      [0,
       create$2,
       clear$2,
       reset$0,
       copy$5,
       add$0,
       find$0,
       find_opt$0,
       find_all$0,
       mem$1,
       remove,
       replace,
       iter$6,
       filter_map_inplace,
       fold$1,
       length$4,
       randomize,
       is_randomized,
       stats,
       Make,
       MakeSeeded,
       hash$0,
       seeded_hash,
       hash_param,
       caml_hash];
    caml_register_global(679,Hashtbl,"Hashtbl");
    function length$5(x){return x.length - 1 - 2 | 0}
    function fill$1(ar,ofs,len,x)
     {if(0 <= ofs)
       if(0 <= len)
        if(! (length$5(ar) < (ofs + len | 0)))
         {var _kD_=(ofs + len | 0) - 1 | 0;
          if(! (_kD_ < ofs))
           {var i=ofs;
            for(;;)
             {caml_weak_set(ar,i,x);
              var _kE_=i + 1 | 0;
              if(_kD_ !== i){var i=_kE_;continue}
              break}}
          return 0}
      throw [0,Invalid_argument,cst_Weak_fill]}
    function Make$0(H)
     {var emptybucket=caml_weak_create(0);
      function get_index(t,h){return caml_mod(h & 2147483647,t[1].length - 1)}
      var limit=7;
      function create(sz)
       {var
         sz$0=7 <= sz?sz:7,
         sz$1=max_array_length < sz$0?max_array_length:sz$0;
        return [0,
                caml_make_vect(sz$1,emptybucket),
                caml_make_vect(sz$1,[0]),
                limit,
                0,
                0]}
      function clear(t)
       {var _kB_=t[1].length - 1 - 1 | 0,_kA_=0;
        if(! (_kB_ < 0))
         {var i=_kA_;
          for(;;)
           {caml_check_bound(t[1],i)[1 + i] = emptybucket;
            caml_check_bound(t[2],i)[1 + i] = [0];
            var _kC_=i + 1 | 0;
            if(_kB_ !== i){var i=_kC_;continue}
            break}}
        t[3] = limit;
        t[4] = 0;
        return 0}
      function fold(f,t,init)
       {var _kz_=t[1],i=0;
        return fold_right$0
                (function(b,accu$1)
                  {var i$0=i,accu=accu$1;
                   for(;;)
                    {if(length$5(b) <= i$0)return accu;
                     var match=caml_weak_get(b,i$0);
                     if(match)
                      {var
                        v=match[1],
                        accu$0=caml_call2(f,v,accu),
                        i$1=i$0 + 1 | 0,
                        i$0=i$1,
                        accu=accu$0;
                       continue}
                     var i$2=i$0 + 1 | 0,i$0=i$2;
                     continue}},
                 _kz_,
                 init)}
      function iter(f,t)
       {var _ky_=t[1],i=0;
        return iter$2
                (function(b)
                  {var i$0=i;
                   for(;;)
                    {if(length$5(b) <= i$0)return 0;
                     var match=caml_weak_get(b,i$0);
                     if(match)
                      {var v=match[1];
                       caml_call1(f,v);
                       var i$1=i$0 + 1 | 0,i$0=i$1;
                       continue}
                     var i$2=i$0 + 1 | 0,i$0=i$2;
                     continue}},
                 _ky_)}
      function count_bucket(i,b,accu)
       {var i$0=i,accu$0=accu;
        for(;;)
         {if(length$5(b) <= i$0)return accu$0;
          var
           _kx_=caml_weak_check(b,i$0)?1:0,
           accu$1=accu$0 + _kx_ | 0,
           i$1=i$0 + 1 | 0,
           i$0=i$1,
           accu$0=accu$1;
          continue}}
      function count(t)
       {var _ks_=0,_kt_=t[1],_ku_=0;
        return fold_right$0
                (function(_kv_,_kw_){return count_bucket(_ku_,_kv_,_kw_)},
                 _kt_,
                 _ks_)}
      function add_aux(t,setter,d,h,index)
       {var
         bucket$0=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket$0),
         i$3=0;
        for(;;)
         {if(sz <= i$3)
           {var
             newsz=
              min(((3 * sz | 0) / 2 | 0) + 3 | 0,max_array_length - 2 | 0);
            if(newsz <= sz)
             failwith(cst_Weak_Make_hash_bucket_cannot_grow_more);
            var
             newbucket=caml_weak_create(newsz),
             newhashes=caml_make_vect(newsz,0);
            caml_weak_blit(bucket$0,0,newbucket,0,sz);
            blit$1(hashes,0,newhashes,0,sz);
            caml_call3(setter,newbucket,sz,d);
            caml_check_bound(newhashes,sz)[1 + sz] = h;
            caml_check_bound(t[1],index)[1 + index] = newbucket;
            caml_check_bound(t[2],index)[1 + index] = newhashes;
            var _ko_=sz <= t[3]?1:0,_kp_=_ko_?t[3] < newsz?1:0:_ko_;
            if(_kp_)
             {t[4] = t[4] + 1 | 0;
              var i$4=0;
              for(;;)
               {var
                 _kh_=t[5],
                 bucket=caml_check_bound(t[1],_kh_)[1 + _kh_],
                 _ki_=t[5],
                 hbucket=caml_check_bound(t[2],_ki_)[1 + _ki_],
                 n=length$5(bucket),
                 prev_len=(((n - 3 | 0) * 2 | 0) + 2 | 0) / 3 | 0,
                 live=count_bucket(0,bucket,0);
                if(live <= prev_len)
                 {var j$2=length$5(bucket) - 1 | 0,i$0=0,j=j$2;
                  for(;;)
                   {if(prev_len <= j)
                     {if(caml_weak_check(bucket,i$0))
                       {var i$1=i$0 + 1 | 0,i$0=i$1;continue}
                      if(caml_weak_check(bucket,j))
                       {caml_weak_blit(bucket,j,bucket,i$0,1);
                        var _kj_=caml_check_bound(hbucket,j)[1 + j];
                        caml_check_bound(hbucket,i$0)[1 + i$0] = _kj_;
                        var j$0=j - 1 | 0,i$2=i$0 + 1 | 0,i$0=i$2,j=j$0;
                        continue}
                      var j$1=j - 1 | 0,j=j$1;
                      continue}
                    if(0 === prev_len)
                     {var _kk_=t[5];
                      caml_check_bound(t[1],_kk_)[1 + _kk_] = emptybucket;
                      var _kl_=t[5];
                      caml_check_bound(t[2],_kl_)[1 + _kl_] = [0]}
                    else
                     {caml_obj_truncate(bucket,prev_len + 2 | 0);
                      caml_obj_truncate(hbucket,prev_len)}
                    var _km_=t[3] < n?1:0,_kn_=_km_?prev_len <= t[3]?1:0:_km_;
                    if(_kn_)t[4] = t[4] - 1 | 0;
                    break}}
                t[5] = caml_mod(t[5] + 1 | 0,t[1].length - 1);
                var _kr_=i$4 + 1 | 0;
                if(2 !== i$4){var i$4=_kr_;continue}
                break}}
            var _kq_=((t[1].length - 1) / 2 | 0) < t[4]?1:0;
            if(_kq_)
             {var
               n$0=t[1].length - 1,
               newlen=min(((3 * n$0 | 0) / 2 | 0) + 3 | 0,max_array_length);
              if(n$0 < newlen)
               {var newt=create(newlen),_kg_=t[1],i=0;
                iteri$2
                 (function(j,ob)
                   {var i$0=i;
                    for(;;)
                     {if(length$5(ob) <= i$0)return 0;
                      var match=caml_weak_check(ob,i$0);
                      if(0 === match){var i$1=i$0 + 1 | 0,i$0=i$1;continue}
                      var
                       oh=caml_check_bound(t[2],j)[1 + j],
                       setter$0=
                        function(i)
                         {function setter(nb,ni,param)
                           {return caml_weak_blit(ob,i,nb,ni,1)}
                          return setter},
                       setter=setter$0(i$0),
                       h=caml_check_bound(oh,i$0)[1 + i$0];
                      add_aux(newt,setter,0,h,get_index(newt,h));
                      var i$2=i$0 + 1 | 0,i$0=i$2;
                      continue}},
                  _kg_);
                t[1] = newt[1];
                t[2] = newt[2];
                t[3] = newt[3];
                t[4] = newt[4];
                t[5] = caml_mod(t[5],newt[1].length - 1);
                return 0}
              t[3] = max_int;
              t[4] = 0;
              return 0}
            return _kq_}
          if(caml_weak_check(bucket$0,i$3))
           {var i$5=i$3 + 1 | 0,i$3=i$5;continue}
          caml_call3(setter,bucket$0,i$3,d);
          caml_check_bound(hashes,i$3)[1 + i$3] = h;
          return 0}}
      function add(t,d)
       {var h=caml_call1(H[2],d);
        return add_aux(t,caml_weak_set,[0,d],h,get_index(t,h))}
      function find_or(t,d,ifnotfound)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return caml_call2(ifnotfound,h,index);
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=caml_weak_get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var match$0=caml_weak_get(bucket,i);
                if(match$0){var v$0=match$0[1];return v$0}
                var i$0=i + 1 | 0,i=i$0;
                continue}}
            var i$1=i + 1 | 0,i=i$1;
            continue}
          var i$2=i + 1 | 0,i=i$2;
          continue}}
      function merge(t,d)
       {return find_or
                (t,
                 d,
                 function(h,index)
                  {add_aux(t,caml_weak_set,[0,d],h,index);return d})}
      function find(t,d)
       {return find_or(t,d,function(h,index){throw Not_found})}
      function find_opt(t,d)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return 0;
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=caml_weak_get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var v$0=caml_weak_get(bucket,i);
                if(v$0)return v$0;
                var i$0=i + 1 | 0,i=i$0;
                continue}}
            var i$1=i + 1 | 0,i=i$1;
            continue}
          var i$2=i + 1 | 0,i=i$2;
          continue}}
      function find_shadow(t,d,iffound,ifnotfound)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return ifnotfound;
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=caml_weak_get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))return caml_call2(iffound,bucket,i)}
            var i$0=i + 1 | 0,i=i$0;
            continue}
          var i$1=i + 1 | 0,i=i$1;
          continue}}
      function remove(t,d)
       {var _kf_=0;
        return find_shadow
                (t,d,function(w,i){return caml_weak_set(w,i,0)},_kf_)}
      function mem(t,d)
       {var _ke_=0;return find_shadow(t,d,function(w,i){return 1},_ke_)}
      function find_all(t,d)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0,
         accu=0;
        for(;;)
         {if(sz <= i)return accu;
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=caml_weak_get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var match$0=caml_weak_get(bucket,i);
                if(match$0)
                 {var
                   v$0=match$0[1],
                   accu$0=[0,v$0,accu],
                   i$0=i + 1 | 0,
                   i=i$0,
                   accu=accu$0;
                  continue}
                var i$1=i + 1 | 0,i=i$1;
                continue}}
            var i$2=i + 1 | 0,i=i$2;
            continue}
          var i$3=i + 1 | 0,i=i$3;
          continue}}
      function stats(t)
       {var len=t[1].length - 1,lens=map$2(length$5,t[1]);
        sort(caml_int_compare,lens);
        var
         _j8_=0,
         totlen=
          fold_left$0(function(_kd_,_kc_){return _kd_ + _kc_ | 0},_j8_,lens),
         _j9_=len - 1 | 0,
         _j$_=len / 2 | 0,
         _j__=caml_check_bound(lens,_j9_)[1 + _j9_],
         _ka_=caml_check_bound(lens,_j$_)[1 + _j$_],
         _kb_=caml_check_bound(lens,0)[1];
        return [0,len,count(t),totlen,_kb_,_ka_,_j__]}
      return [0,
              create,
              clear,
              merge,
              add,
              remove,
              find,
              find_opt,
              find_all,
              mem,
              iter,
              fold,
              count,
              stats]}
    var
     Weak=
      [0,
       caml_weak_create,
       length$5,
       caml_weak_set,
       caml_weak_get,
       caml_weak_get_copy,
       caml_weak_check,
       fill$1,
       caml_weak_blit,
       Make$0];
    caml_register_global(680,Weak,"Weak");
    function add_queue(x,q)
     {var c=[0,x,0],_j7_=q[1];
      return _j7_?(q[1] = c,_j7_[2] = c,0):(q[1] = c,q[2] = c,0)}
    var Empty_queue=[248,cst_Format_Empty_queue,caml_fresh_oo_id(0)];
    function take_queue(q)
     {var _j6_=q[2];
      if(_j6_)
       {var x=_j6_[1],tl=_j6_[2];q[2] = tl;if(0 === tl)q[1] = 0;return x}
      throw Empty_queue}
    function pp_enqueue(state,token)
     {var len=token[3];
      state[13] = state[13] + len | 0;
      return add_queue(token,state[28])}
    var pp_infinity=1000000010;
    function pp_output_string(state,s)
     {return caml_call3(state[17],s,0,caml_ml_string_length(s))}
    function pp_output_newline(state){return caml_call1(state[19],0)}
    function break_new_line(state,offset,width)
     {pp_output_newline(state);
      state[11] = 1;
      var
       indent=(state[6] - width | 0) + offset | 0,
       real_indent=min(state[8],indent);
      state[10] = real_indent;
      state[9] = state[6] - state[10] | 0;
      return caml_call1(state[21],state[10])}
    function break_line(state,width){return break_new_line(state,0,width)}
    function break_same_line(state,width)
     {state[9] = state[9] - width | 0;return caml_call1(state[20],width)}
    function pp_force_break_line(state)
     {var _j3_=state[2];
      if(_j3_)
       {var
         match=_j3_[1],
         width=match[2],
         bl_ty=match[1],
         _j4_=state[9] < width?1:0;
        if(_j4_)
         {if(0 !== bl_ty)return 5 <= bl_ty?0:break_line(state,width);
          var _j5_=0}
        else
         var _j5_=_j4_;
        return _j5_}
      return pp_output_newline(state)}
    function pp_skip_token(state)
     {var match=take_queue(state[28]),size=match[1],len=match[3];
      state[12] = state[12] - len | 0;
      state[9] = state[9] + size | 0;
      return 0}
    function format_pp_token(state,size,param)
     {if(typeof param === "number")
       switch(param)
        {case 0:
          var _jS_=state[3];
          if(_jS_)
           {var
             match=_jS_[1],
             tabs=match[1],
             add_tab=
              function(n,ls)
               {if(ls)
                 {var l=ls[2],x=ls[1];
                  return runtime.caml_lessthan(n,x)
                          ?[0,n,ls]
                          :[0,x,add_tab(n,l)]}
                return [0,n,0]};
            tabs[1] = add_tab(state[6] - state[9] | 0,tabs[1]);
            return 0}
          return 0;
         case 1:
          var _jT_=state[2];
          if(_jT_){var ls=_jT_[2];state[2] = ls;return 0}
          return 0;
         case 2:
          var _jU_=state[3];
          if(_jU_){var ls$0=_jU_[2];state[3] = ls$0;return 0}
          return 0;
         case 3:
          var _jV_=state[2];
          if(_jV_)
           {var match$0=_jV_[1],width=match$0[2];
            return break_line(state,width)}
          return pp_output_newline(state);
         case 4:
          var _jW_=state[10] !== (state[6] - state[9] | 0)?1:0;
          return _jW_?pp_skip_token(state):_jW_;
         default:
          var _jX_=state[5];
          if(_jX_)
           {var
             tags=_jX_[2],
             tag_name=_jX_[1],
             marker=caml_call1(state[25],tag_name);
            pp_output_string(state,marker);
            state[5] = tags;
            return 0}
          return 0}
      else
       switch(param[0])
        {case 0:
          var s=param[1];
          state[9] = state[9] - size | 0;
          pp_output_string(state,s);
          state[11] = 0;
          return 0;
         case 1:
          var off=param[2],n=param[1],_jY_=state[2];
          if(_jY_)
           {var match$1=_jY_[1],width$0=match$1[2],ty=match$1[1];
            switch(ty)
             {case 0:return break_same_line(state,n);
              case 1:return break_new_line(state,off,width$0);
              case 2:return break_new_line(state,off,width$0);
              case 3:
               return state[9] < size
                       ?break_new_line(state,off,width$0)
                       :break_same_line(state,n);
              case 4:
               return state[11]
                       ?break_same_line(state,n)
                       :state[9] < size
                         ?break_new_line(state,off,width$0)
                         :((state[6] - width$0 | 0) + off | 0) < state[10]
                           ?break_new_line(state,off,width$0)
                           :break_same_line(state,n);
              default:return break_same_line(state,n)}}
          return 0;
         case 2:
          var
           off$0=param[2],
           n$0=param[1],
           insertion_point=state[6] - state[9] | 0,
           _jZ_=state[3];
          if(_jZ_)
           {var
             match$2=_jZ_[1],
             tabs$0=match$2[1],
             find=
              function(n,param)
               {var param$0=param;
                for(;;)
                 {if(param$0)
                   {var l=param$0[2],x=param$0[1];
                    if(caml_greaterequal(x,n))return x;
                    var param$0=l;
                    continue}
                  throw Not_found}},
             _j0_=tabs$0[1];
            if(_j0_)
             {var x=_j0_[1];
              try
               {var _j1_=find(insertion_point,tabs$0[1]),x$0=_j1_}
              catch(_j2_)
               {_j2_ = caml_wrap_exception(_j2_);
                if(_j2_ !== Not_found)throw _j2_;
                var x$0=x}
              var tab=x$0}
            else
             var tab=insertion_point;
            var offset=tab - insertion_point | 0;
            return 0 <= offset
                    ?break_same_line(state,offset + n$0 | 0)
                    :break_new_line(state,tab + off$0 | 0,state[6])}
          return 0;
         case 3:
          var
           ty$0=param[2],
           off$1=param[1],
           insertion_point$0=state[6] - state[9] | 0;
          if(state[8] < insertion_point$0)pp_force_break_line(state);
          var
           offset$0=state[9] - off$1 | 0,
           bl_type=1 === ty$0?1:state[9] < size?ty$0:5;
          state[2] = [0,[0,bl_type,offset$0],state[2]];
          return 0;
         case 4:var tbox=param[1];state[3] = [0,tbox,state[3]];return 0;
         default:
          var tag_name$0=param[1],marker$0=caml_call1(state[24],tag_name$0);
          pp_output_string(state,marker$0);
          state[5] = [0,tag_name$0,state[5]];
          return 0}}
    function advance_loop(state)
     {for(;;)
       {var _jO_=state[28][2];
        if(_jO_)
         {var
           x=_jO_[1],
           size=x[1],
           len=x[3],
           tok=x[2],
           _jP_=size < 0?1:0,
           _jQ_=_jP_?(state[13] - state[12] | 0) < state[9]?1:0:_jP_,
           _jR_=1 - _jQ_;
          if(_jR_)
           {take_queue(state[28]);
            var size$0=0 <= size?size:pp_infinity;
            format_pp_token(state,size$0,tok);
            state[12] = len + state[12] | 0;
            continue}
          return _jR_}
        throw Empty_queue}}
    function advance_left(state)
     {try
       {var _jM_=advance_loop(state);return _jM_}
      catch(_jN_)
       {_jN_ = caml_wrap_exception(_jN_);
        if(_jN_ === Empty_queue)return 0;
        throw _jN_}}
    function enqueue_advance(state,tok)
     {pp_enqueue(state,tok);return advance_left(state)}
    function enqueue_string_as(state,size,s)
     {return enqueue_advance(state,[0,size,[0,s],size])}
    var q_elem=[0,-1,_b6_,0],scan_stack_bottom=[0,[0,-1,q_elem],0];
    function clear_scan_stack(state){state[1] = scan_stack_bottom;return 0}
    function set_size(state,ty)
     {var _jI_=state[1];
      if(_jI_)
       {var
         match=_jI_[1],
         queue_elem=match[2],
         left_tot=match[1],
         size=queue_elem[1],
         t=_jI_[2],
         tok=queue_elem[2];
        if(left_tot < state[12])return clear_scan_stack(state);
        if(typeof tok !== "number")
         switch(tok[0])
          {case 3:
            var
             _jK_=1 - ty,
             _jL_=
              _jK_?(queue_elem[1] = state[13] + size | 0,state[1] = t,0):_jK_;
            return _jL_;
           case 1:
           case 2:
            var
             _jJ_=
              ty?(queue_elem[1] = state[13] + size | 0,state[1] = t,0):ty;
            return _jJ_
           }
        return 0}
      return 0}
    function scan_push(state,b,tok)
     {pp_enqueue(state,tok);
      if(b)set_size(state,1);
      state[1] = [0,[0,state[13],tok],state[1]];
      return 0}
    function pp_open_box_gen(state,indent,br_ty)
     {state[14] = state[14] + 1 | 0;
      if(state[14] < state[15])
       {var elem=[0,- state[13] | 0,[3,indent,br_ty],0];
        return scan_push(state,0,elem)}
      var _jG_=state[14] === state[15]?1:0;
      if(_jG_)
       {var _jH_=state[16],len=caml_ml_string_length(_jH_);
        return enqueue_string_as(state,len,_jH_)}
      return _jG_}
    function pp_close_box(state,param)
     {var _jE_=1 < state[14]?1:0;
      if(_jE_)
       {if(state[14] < state[15])
         {pp_enqueue(state,[0,0,1,0]);set_size(state,1);set_size(state,0)}
        state[14] = state[14] - 1 | 0;
        var _jF_=0}
      else
       var _jF_=_jE_;
      return _jF_}
    function pp_open_tag(state,tag_name)
     {if(state[22])
       {state[4] = [0,tag_name,state[4]];caml_call1(state[26],tag_name)}
      var _jD_=state[23];
      return _jD_?pp_enqueue(state,[0,0,[5,tag_name],0]):_jD_}
    function pp_close_tag(state,param)
     {if(state[23])pp_enqueue(state,[0,0,5,0]);
      var _jA_=state[22];
      if(_jA_)
       {var _jB_=state[4];
        if(_jB_)
         {var tags=_jB_[2],tag_name=_jB_[1];
          caml_call1(state[27],tag_name);
          state[4] = tags;
          return 0}
        var _jC_=0}
      else
       var _jC_=_jA_;
      return _jC_}
    function pp_set_print_tags(state,b){state[22] = b;return 0}
    function pp_set_mark_tags(state,b){state[23] = b;return 0}
    function pp_get_print_tags(state,param){return state[22]}
    function pp_get_mark_tags(state,param){return state[23]}
    function pp_set_tags(state,b)
     {pp_set_print_tags(state,b);return pp_set_mark_tags(state,b)}
    function pp_get_formatter_tag_functions(state,param)
     {return [0,state[24],state[25],state[26],state[27]]}
    function pp_set_formatter_tag_functions(state,param)
     {var pct=param[4],pot=param[3],mct=param[2],mot=param[1];
      state[24] = mot;
      state[25] = mct;
      state[26] = pot;
      state[27] = pct;
      return 0}
    function pp_rinit(state)
     {state[12] = 1;
      state[13] = 1;
      var _jz_=state[28];
      _jz_[1] = 0;
      _jz_[2] = 0;
      clear_scan_stack(state);
      state[2] = 0;
      state[3] = 0;
      state[4] = 0;
      state[5] = 0;
      state[10] = 0;
      state[14] = 0;
      state[9] = state[6];
      return pp_open_box_gen(state,0,3)}
    function pp_flush_queue(state,b)
     {var _jy_=state[4];
      iter(function(param){return pp_close_tag(state,0)},_jy_);
      for(;;)
       {if(1 < state[14]){pp_close_box(state,0);continue}
        state[13] = pp_infinity;
        advance_left(state);
        if(b)pp_output_newline(state);
        return pp_rinit(state)}}
    function pp_print_as_size(state,size,s)
     {var _jx_=state[14] < state[15]?1:0;
      return _jx_?enqueue_string_as(state,size,s):_jx_}
    function pp_print_as(state,isize,s)
     {return pp_print_as_size(state,isize,s)}
    function pp_print_string(state,s)
     {return pp_print_as(state,caml_ml_string_length(s),s)}
    function pp_print_int(state,i)
     {return pp_print_string(state,caml_new_string("" + i))}
    function pp_print_float(state,f)
     {return pp_print_string(state,string_of_float(f))}
    function pp_print_bool(state,b)
     {return pp_print_string(state,string_of_bool(b))}
    function pp_print_char(state,c){return pp_print_as(state,1,make$0(1,c))}
    function pp_open_hbox(state,param){return pp_open_box_gen(state,0,0)}
    function pp_open_vbox(state,indent)
     {return pp_open_box_gen(state,indent,1)}
    function pp_open_hvbox(state,indent)
     {return pp_open_box_gen(state,indent,2)}
    function pp_open_hovbox(state,indent)
     {return pp_open_box_gen(state,indent,3)}
    function pp_open_box(state,indent){return pp_open_box_gen(state,indent,4)}
    function pp_print_newline(state,param)
     {pp_flush_queue(state,1);return caml_call1(state[18],0)}
    function pp_print_flush(state,param)
     {pp_flush_queue(state,0);return caml_call1(state[18],0)}
    function pp_force_newline(state,param)
     {var _jw_=state[14] < state[15]?1:0;
      return _jw_?enqueue_advance(state,[0,0,3,0]):_jw_}
    function pp_print_if_newline(state,param)
     {var _jv_=state[14] < state[15]?1:0;
      return _jv_?enqueue_advance(state,[0,0,4,0]):_jv_}
    function pp_print_break(state,width,offset)
     {var _ju_=state[14] < state[15]?1:0;
      if(_ju_)
       {var elem=[0,- state[13] | 0,[1,width,offset],width];
        return scan_push(state,1,elem)}
      return _ju_}
    function pp_print_space(state,param){return pp_print_break(state,1,0)}
    function pp_print_cut(state,param){return pp_print_break(state,0,0)}
    function pp_open_tbox(state,param)
     {state[14] = state[14] + 1 | 0;
      var _jt_=state[14] < state[15]?1:0;
      if(_jt_)
       {var elem=[0,0,[4,[0,[0,0]]],0];return enqueue_advance(state,elem)}
      return _jt_}
    function pp_close_tbox(state,param)
     {var _jq_=1 < state[14]?1:0;
      if(_jq_)
       {var _jr_=state[14] < state[15]?1:0;
        if(_jr_)
         {var elem=[0,0,2,0];
          enqueue_advance(state,elem);
          state[14] = state[14] - 1 | 0;
          var _js_=0}
        else
         var _js_=_jr_}
      else
       var _js_=_jq_;
      return _js_}
    function pp_print_tbreak(state,width,offset)
     {var _jp_=state[14] < state[15]?1:0;
      if(_jp_)
       {var elem=[0,- state[13] | 0,[2,width,offset],width];
        return scan_push(state,1,elem)}
      return _jp_}
    function pp_print_tab(state,param){return pp_print_tbreak(state,0,0)}
    function pp_set_tab(state,param)
     {var _jo_=state[14] < state[15]?1:0;
      if(_jo_){var elem=[0,0,0,0];return enqueue_advance(state,elem)}
      return _jo_}
    function pp_set_max_boxes(state,n)
     {var _jm_=1 < n?1:0,_jn_=_jm_?(state[15] = n,0):_jm_;return _jn_}
    function pp_get_max_boxes(state,param){return state[15]}
    function pp_over_max_boxes(state,param)
     {return state[14] === state[15]?1:0}
    function pp_set_ellipsis_text(state,s){state[16] = s;return 0}
    function pp_get_ellipsis_text(state,param){return state[16]}
    function pp_limit(n){return n < 1000000010?n:1000000009}
    function pp_set_max_indent(state,n$0)
     {var n$1=state[6] - n$0 | 0,_jl_=1 <= n$1?1:0;
      if(_jl_)
       {var n=pp_limit(n$1);
        state[7] = n;
        state[8] = state[6] - state[7] | 0;
        return pp_rinit(state)}
      return _jl_}
    function pp_get_max_indent(state,param){return state[8]}
    function pp_set_margin(state,n)
     {var _jk_=1 <= n?1:0;
      if(_jk_)
       {var n$0=pp_limit(n);
        state[6] = n$0;
        var
         new_max_indent=
          state[8] <= state[6]
           ?state[8]
           :max(max(state[6] - state[7] | 0,state[6] / 2 | 0),1);
        return pp_set_max_indent(state,new_max_indent)}
      return _jk_}
    function pp_get_margin(state,param){return state[6]}
    function pp_set_formatter_out_functions(state,param)
     {var j=param[5],i=param[4],h=param[3],g=param[2],f=param[1];
      state[17] = f;
      state[18] = g;
      state[19] = h;
      state[20] = i;
      state[21] = j;
      return 0}
    function pp_get_formatter_out_functions(state,param)
     {return [0,state[17],state[18],state[19],state[20],state[21]]}
    function pp_set_formatter_output_functions(state,f,g)
     {state[17] = f;state[18] = g;return 0}
    function pp_get_formatter_output_functions(state,param)
     {return [0,state[17],state[18]]}
    function display_newline(state,param)
     {return caml_call3(state[17],cst$66,0,1)}
    var blank_line=make$0(80,32);
    function display_indent(state,n)
     {var n$0=n;
      for(;;)
       {var _jj_=0 < n$0?1:0;
        if(_jj_)
         {if(80 < n$0)
           {caml_call3(state[17],blank_line,0,80);
            var n$1=n$0 - 80 | 0,n$0=n$1;
            continue}
          return caml_call3(state[17],blank_line,0,n$0)}
        return _jj_}}
    function pp_set_formatter_out_channel(state,oc)
     {state[17]
      =
      function(_jg_,_jh_,_ji_){return output_substring(oc,_jg_,_jh_,_ji_)};
      state[18] = function(param){return caml_ml_flush(oc)};
      state[19] = function(_jf_){return display_newline(state,_jf_)};
      state[20] = function(_je_){return display_indent(state,_je_)};
      state[21] = function(_jd_){return display_indent(state,_jd_)};
      return 0}
    function default_pp_mark_open_tag(s)
     {return symbol(cst$68,symbol(s,cst$67))}
    function default_pp_mark_close_tag(s)
     {return symbol(cst$70,symbol(s,cst$69))}
    function default_pp_print_open_tag(_jc_){return 0}
    function default_pp_print_close_tag(_jb_){return 0}
    function pp_make_formatter(f,g,h,i,j)
     {var pp_queue=[0,0,0],sys_tok=[0,-1,_b7_,0];
      add_queue(sys_tok,pp_queue);
      var sys_scan_stack=[0,[0,1,sys_tok],scan_stack_bottom];
      return [0,
              sys_scan_stack,
              0,
              0,
              0,
              0,
              78,
              10,
              68,
              78,
              0,
              1,
              1,
              1,
              1,
              max_int,
              cst$71,
              f,
              g,
              h,
              i,
              j,
              0,
              0,
              default_pp_mark_open_tag,
              default_pp_mark_close_tag,
              default_pp_print_open_tag,
              default_pp_print_close_tag,
              pp_queue]}
    function formatter_of_out_functions(out_funs)
     {return pp_make_formatter
              (out_funs[1],out_funs[2],out_funs[3],out_funs[4],out_funs[5])}
    function make_formatter(output,flush)
     {function _i5_(_ja_){return 0}
      function _i6_(_i$_){return 0}
      var
       ppf=
        pp_make_formatter(output,flush,function(_i__){return 0},_i6_,_i5_);
      ppf[19] = function(_i9_){return display_newline(ppf,_i9_)};
      ppf[20] = function(_i8_){return display_indent(ppf,_i8_)};
      ppf[21] = function(_i7_){return display_indent(ppf,_i7_)};
      return ppf}
    function formatter_of_out_channel(oc)
     {function _i1_(param){return caml_ml_flush(oc)}
      return make_formatter
              (function(_i2_,_i3_,_i4_)
                {return output_substring(oc,_i2_,_i3_,_i4_)},
               _i1_)}
    function formatter_of_buffer(b)
     {function _iW_(_i0_){return 0}
      return make_formatter
              (function(_iX_,_iY_,_iZ_)
                {return add_substring(b,_iX_,_iY_,_iZ_)},
               _iW_)}
    var pp_buffer_size=512;
    function pp_make_buffer(param){return create$1(pp_buffer_size)}
    var
     stdbuf=pp_make_buffer(0),
     std_formatter=formatter_of_out_channel(stdout),
     err_formatter=formatter_of_out_channel(stderr),
     str_formatter=formatter_of_buffer(stdbuf);
    function flush_buffer_formatter(buf,ppf)
     {pp_flush_queue(ppf,0);var s=contents(buf);reset(buf);return s}
    function flush_str_formatter(param)
     {return flush_buffer_formatter(stdbuf,str_formatter)}
    function make_symbolic_output_buffer(param){return [0,0]}
    function clear_symbolic_output_buffer(sob){sob[1] = 0;return 0}
    function get_symbolic_output_buffer(sob){return rev(sob[1])}
    function flush_symbolic_output_buffer(sob)
     {var items=get_symbolic_output_buffer(sob);
      clear_symbolic_output_buffer(sob);
      return items}
    function add_symbolic_output_item(sob,item)
     {sob[1] = [0,item,sob[1]];return 0}
    function formatter_of_symbolic_output_buffer(sob)
     {function f(s,i,n){return add_symbolic_output_item(sob,[0,sub$0(s,i,n)])}
      function g(_iV_){return add_symbolic_output_item(sob,0)}
      function h(_iU_){return add_symbolic_output_item(sob,1)}
      function i(n){return add_symbolic_output_item(sob,[1,n])}
      function j(n){return add_symbolic_output_item(sob,[2,n])}
      return pp_make_formatter(f,g,h,i,j)}
    function open_hbox(_iT_){return pp_open_hbox(std_formatter,_iT_)}
    function open_vbox(_iS_){return pp_open_vbox(std_formatter,_iS_)}
    function open_hvbox(_iR_){return pp_open_hvbox(std_formatter,_iR_)}
    function open_hovbox(_iQ_){return pp_open_hovbox(std_formatter,_iQ_)}
    function open_box(_iP_){return pp_open_box(std_formatter,_iP_)}
    function close_box(_iO_){return pp_close_box(std_formatter,_iO_)}
    function open_tag(_iN_){return pp_open_tag(std_formatter,_iN_)}
    function close_tag(_iM_){return pp_close_tag(std_formatter,_iM_)}
    function print_as(_iK_,_iL_){return pp_print_as(std_formatter,_iK_,_iL_)}
    function print_string$0(_iJ_){return pp_print_string(std_formatter,_iJ_)}
    function print_int$0(_iI_){return pp_print_int(std_formatter,_iI_)}
    function print_float$0(_iH_){return pp_print_float(std_formatter,_iH_)}
    function print_char$0(_iG_){return pp_print_char(std_formatter,_iG_)}
    function print_bool(_iF_){return pp_print_bool(std_formatter,_iF_)}
    function print_break(_iD_,_iE_)
     {return pp_print_break(std_formatter,_iD_,_iE_)}
    function print_cut(_iC_){return pp_print_cut(std_formatter,_iC_)}
    function print_space(_iB_){return pp_print_space(std_formatter,_iB_)}
    function force_newline(_iA_){return pp_force_newline(std_formatter,_iA_)}
    function print_flush(_iz_){return pp_print_flush(std_formatter,_iz_)}
    function print_newline$0(_iy_)
     {return pp_print_newline(std_formatter,_iy_)}
    function print_if_newline(_ix_)
     {return pp_print_if_newline(std_formatter,_ix_)}
    function open_tbox(_iw_){return pp_open_tbox(std_formatter,_iw_)}
    function close_tbox(_iv_){return pp_close_tbox(std_formatter,_iv_)}
    function print_tbreak(_it_,_iu_)
     {return pp_print_tbreak(std_formatter,_it_,_iu_)}
    function set_tab(_is_){return pp_set_tab(std_formatter,_is_)}
    function print_tab(_ir_){return pp_print_tab(std_formatter,_ir_)}
    function set_margin(_iq_){return pp_set_margin(std_formatter,_iq_)}
    function get_margin(_ip_){return std_formatter[6]}
    function set_max_indent(_io_)
     {return pp_set_max_indent(std_formatter,_io_)}
    function get_max_indent(_in_){return std_formatter[8]}
    function set_max_boxes(_im_){return pp_set_max_boxes(std_formatter,_im_)}
    function get_max_boxes(_il_){return std_formatter[15]}
    function over_max_boxes(_ik_)
     {return pp_over_max_boxes(std_formatter,_ik_)}
    function set_ellipsis_text(_ij_)
     {return pp_set_ellipsis_text(std_formatter,_ij_)}
    function get_ellipsis_text(_ii_){return std_formatter[16]}
    function set_formatter_out_channel(_ih_)
     {return pp_set_formatter_out_channel(std_formatter,_ih_)}
    function set_formatter_out_functions(_ig_)
     {return pp_set_formatter_out_functions(std_formatter,_ig_)}
    function get_formatter_out_functions(_if_)
     {return pp_get_formatter_out_functions(std_formatter,_if_)}
    function set_formatter_output_functions(_id_,_ie_)
     {return pp_set_formatter_output_functions(std_formatter,_id_,_ie_)}
    function get_formatter_output_functions(_ic_)
     {return pp_get_formatter_output_functions(std_formatter,_ic_)}
    function set_formatter_tag_functions(_ib_)
     {return pp_set_formatter_tag_functions(std_formatter,_ib_)}
    function get_formatter_tag_functions(_ia_)
     {return pp_get_formatter_tag_functions(std_formatter,_ia_)}
    function set_print_tags(_h$_)
     {return pp_set_print_tags(std_formatter,_h$_)}
    function get_print_tags(_h__){return std_formatter[22]}
    function set_mark_tags(_h9_){return pp_set_mark_tags(std_formatter,_h9_)}
    function get_mark_tags(_h8_){return std_formatter[23]}
    function set_tags(_h7_){return pp_set_tags(std_formatter,_h7_)}
    function pp_print_list(opt,pp_v,ppf,param)
     {var opt$0=opt,param$0=param;
      for(;;)
       {if(opt$0)var sth=opt$0[1],pp_sep=sth;else var pp_sep=pp_print_cut;
        if(param$0)
         {var _h5_=param$0[2],_h6_=param$0[1];
          if(_h5_)
           {caml_call2(pp_v,ppf,_h6_);
            caml_call2(pp_sep,ppf,0);
            var opt$1=[0,pp_sep],opt$0=opt$1,param$0=_h5_;
            continue}
          return caml_call2(pp_v,ppf,_h6_)}
        return 0}}
    function pp_print_text(ppf,s)
     {var len=caml_ml_string_length(s),left=[0,0],right=[0,0];
      function flush(param)
       {pp_print_string(ppf,sub$0(s,left[1],right[1] - left[1] | 0));
        right[1]++;
        left[1] = right[1];
        return 0}
      for(;;)
       {if(right[1] !== len)
         {var match=caml_string_get(s,right[1]);
          if(10 === match)
           {flush(0);pp_force_newline(ppf,0)}
          else
           if(32 === match){flush(0);pp_print_space(ppf,0)}else right[1]++;
          continue}
        var _h4_=left[1] !== len?1:0;
        return _h4_?flush(0):_h4_}}
    function compute_tag(output,tag_acc)
     {var buf=create$1(16),ppf=formatter_of_buffer(buf);
      caml_call2(output,ppf,tag_acc);
      pp_print_flush(ppf,0);
      var len=buf[2];
      return 2 <= len?sub$2(buf,1,len - 2 | 0):contents(buf)}
    function output_formatting_lit(ppf,fmting_lit)
     {if(typeof fmting_lit === "number")
       switch(fmting_lit)
        {case 0:return pp_close_box(ppf,0);
         case 1:return pp_close_tag(ppf,0);
         case 2:return pp_print_flush(ppf,0);
         case 3:return pp_force_newline(ppf,0);
         case 4:return pp_print_newline(ppf,0);
         case 5:return pp_print_char(ppf,64);
         default:return pp_print_char(ppf,37)}
      else
       switch(fmting_lit[0])
        {case 0:
          var offset=fmting_lit[3],width=fmting_lit[2];
          return pp_print_break(ppf,width,offset);
         case 1:return 0;
         default:
          var c=fmting_lit[1];
          pp_print_char(ppf,64);
          return pp_print_char(ppf,c)}}
    function output_acc$0(ppf,acc)
     {if(typeof acc === "number")
       return 0;
      else
       switch(acc[0])
        {case 0:
          var f=acc[2],p=acc[1];
          output_acc$0(ppf,p);
          return output_formatting_lit(ppf,f);
         case 1:
          var _hU_=acc[2],_hV_=acc[1];
          if(0 === _hU_[0])
           {var acc$0=_hU_[1];
            output_acc$0(ppf,_hV_);
            return pp_open_tag(ppf,compute_tag(output_acc$0,acc$0))}
          var acc$1=_hU_[1];
          output_acc$0(ppf,_hV_);
          var
           match=open_box_of_string(compute_tag(output_acc$0,acc$1)),
           bty=match[2],
           indent=match[1];
          return pp_open_box_gen(ppf,indent,bty);
         case 2:
          var _hW_=acc[1];
          if(typeof _hW_ === "number")
           var switch$1=1;
          else
           if(0 === _hW_[0])
            {var _hX_=_hW_[2];
             if(typeof _hX_ === "number")
              var switch$2=1;
             else
              if(1 === _hX_[0])
               var
                s$0=acc[2],
                size=_hX_[2],
                p$1=_hW_[1],
                switch$0=0,
                switch$1=0,
                switch$2=0;
              else
               var switch$2=1;
             if(switch$2)var switch$1=1}
           else
            var switch$1=1;
          if(switch$1)var s=acc[2],p$0=_hW_,switch$0=2;
          break;
         case 3:
          var _hY_=acc[1];
          if(typeof _hY_ === "number")
           var switch$3=1;
          else
           if(0 === _hY_[0])
            {var _hZ_=_hY_[2];
             if(typeof _hZ_ === "number")
              var switch$4=1;
             else
              if(1 === _hZ_[0])
               var
                c$0=acc[2],
                size$0=_hZ_[2],
                p$3=_hY_[1],
                switch$0=1,
                switch$3=0,
                switch$4=0;
              else
               var switch$4=1;
             if(switch$4)var switch$3=1}
           else
            var switch$3=1;
          if(switch$3)var c=acc[2],p$2=_hY_,switch$0=3;
          break;
         case 4:
          var _h0_=acc[1];
          if(typeof _h0_ === "number")
           var switch$5=1;
          else
           if(0 === _h0_[0])
            {var _h1_=_h0_[2];
             if(typeof _h1_ === "number")
              var switch$6=1;
             else
              if(1 === _h1_[0])
               var
                s$0=acc[2],
                size=_h1_[2],
                p$1=_h0_[1],
                switch$0=0,
                switch$5=0,
                switch$6=0;
              else
               var switch$6=1;
             if(switch$6)var switch$5=1}
           else
            var switch$5=1;
          if(switch$5)var s=acc[2],p$0=_h0_,switch$0=2;
          break;
         case 5:
          var _h2_=acc[1];
          if(typeof _h2_ === "number")
           var switch$7=1;
          else
           if(0 === _h2_[0])
            {var _h3_=_h2_[2];
             if(typeof _h3_ === "number")
              var switch$8=1;
             else
              if(1 === _h3_[0])
               var
                c$0=acc[2],
                size$0=_h3_[2],
                p$3=_h2_[1],
                switch$0=1,
                switch$7=0,
                switch$8=0;
              else
               var switch$8=1;
             if(switch$8)var switch$7=1}
           else
            var switch$7=1;
          if(switch$7)var c=acc[2],p$2=_h2_,switch$0=3;
          break;
         case 6:
          var f$0=acc[2],p$4=acc[1];
          output_acc$0(ppf,p$4);
          return caml_call1(f$0,ppf);
         case 7:
          var p$5=acc[1];output_acc$0(ppf,p$5);return pp_print_flush(ppf,0);
         default:
          var msg=acc[2],p$6=acc[1];
          output_acc$0(ppf,p$6);
          return invalid_arg(msg)}
      switch(switch$0)
       {case 0:output_acc$0(ppf,p$1);return pp_print_as_size(ppf,size,s$0);
        case 1:
         output_acc$0(ppf,p$3);
         return pp_print_as_size(ppf,size$0,make$0(1,c$0));
        case 2:output_acc$0(ppf,p$0);return pp_print_string(ppf,s);
        default:output_acc$0(ppf,p$2);return pp_print_char(ppf,c)}}
    function strput_acc$0(ppf,acc)
     {if(typeof acc === "number")
       return 0;
      else
       switch(acc[0])
        {case 0:
          var f=acc[2],p=acc[1];
          strput_acc$0(ppf,p);
          return output_formatting_lit(ppf,f);
         case 1:
          var _hI_=acc[2],_hJ_=acc[1];
          if(0 === _hI_[0])
           {var acc$0=_hI_[1];
            strput_acc$0(ppf,_hJ_);
            return pp_open_tag(ppf,compute_tag(strput_acc$0,acc$0))}
          var acc$1=_hI_[1];
          strput_acc$0(ppf,_hJ_);
          var
           match=open_box_of_string(compute_tag(strput_acc$0,acc$1)),
           bty=match[2],
           indent=match[1];
          return pp_open_box_gen(ppf,indent,bty);
         case 2:
          var _hK_=acc[1];
          if(typeof _hK_ === "number")
           var switch$1=1;
          else
           if(0 === _hK_[0])
            {var _hL_=_hK_[2];
             if(typeof _hL_ === "number")
              var switch$2=1;
             else
              if(1 === _hL_[0])
               var
                s$0=acc[2],
                size=_hL_[2],
                p$1=_hK_[1],
                switch$0=0,
                switch$1=0,
                switch$2=0;
              else
               var switch$2=1;
             if(switch$2)var switch$1=1}
           else
            var switch$1=1;
          if(switch$1)var s=acc[2],p$0=_hK_,switch$0=2;
          break;
         case 3:
          var _hM_=acc[1];
          if(typeof _hM_ === "number")
           var switch$3=1;
          else
           if(0 === _hM_[0])
            {var _hN_=_hM_[2];
             if(typeof _hN_ === "number")
              var switch$4=1;
             else
              if(1 === _hN_[0])
               var
                c$0=acc[2],
                size$0=_hN_[2],
                p$3=_hM_[1],
                switch$0=1,
                switch$3=0,
                switch$4=0;
              else
               var switch$4=1;
             if(switch$4)var switch$3=1}
           else
            var switch$3=1;
          if(switch$3)var c=acc[2],p$2=_hM_,switch$0=3;
          break;
         case 4:
          var _hO_=acc[1];
          if(typeof _hO_ === "number")
           var switch$5=1;
          else
           if(0 === _hO_[0])
            {var _hP_=_hO_[2];
             if(typeof _hP_ === "number")
              var switch$6=1;
             else
              if(1 === _hP_[0])
               var
                s$0=acc[2],
                size=_hP_[2],
                p$1=_hO_[1],
                switch$0=0,
                switch$5=0,
                switch$6=0;
              else
               var switch$6=1;
             if(switch$6)var switch$5=1}
           else
            var switch$5=1;
          if(switch$5)var s=acc[2],p$0=_hO_,switch$0=2;
          break;
         case 5:
          var _hQ_=acc[1];
          if(typeof _hQ_ === "number")
           var switch$7=1;
          else
           if(0 === _hQ_[0])
            {var _hR_=_hQ_[2];
             if(typeof _hR_ === "number")
              var switch$8=1;
             else
              if(1 === _hR_[0])
               var
                c$0=acc[2],
                size$0=_hR_[2],
                p$3=_hQ_[1],
                switch$0=1,
                switch$7=0,
                switch$8=0;
              else
               var switch$8=1;
             if(switch$8)var switch$7=1}
           else
            var switch$7=1;
          if(switch$7)var c=acc[2],p$2=_hQ_,switch$0=3;
          break;
         case 6:
          var _hS_=acc[1];
          if(typeof _hS_ !== "number" && 0 === _hS_[0])
           {var _hT_=_hS_[2];
            if(typeof _hT_ !== "number" && 1 === _hT_[0])
             {var f$1=acc[2],size$1=_hT_[2],p$4=_hS_[1];
              strput_acc$0(ppf,p$4);
              return pp_print_as_size(ppf,size$1,caml_call1(f$1,0))}}
          var f$0=acc[2];
          strput_acc$0(ppf,_hS_);
          return pp_print_string(ppf,caml_call1(f$0,0));
         case 7:
          var p$5=acc[1];strput_acc$0(ppf,p$5);return pp_print_flush(ppf,0);
         default:
          var msg=acc[2],p$6=acc[1];
          strput_acc$0(ppf,p$6);
          return invalid_arg(msg)}
      switch(switch$0)
       {case 0:strput_acc$0(ppf,p$1);return pp_print_as_size(ppf,size,s$0);
        case 1:
         strput_acc$0(ppf,p$3);
         return pp_print_as_size(ppf,size$0,make$0(1,c$0));
        case 2:strput_acc$0(ppf,p$0);return pp_print_string(ppf,s);
        default:strput_acc$0(ppf,p$2);return pp_print_char(ppf,c)}}
    function kfprintf$0(k,ppf,param)
     {var fmt=param[1],_hH_=0;
      return make_printf
              (function(ppf,acc)
                {output_acc$0(ppf,acc);return caml_call1(k,ppf)},
               ppf,
               _hH_,
               fmt)}
    function ikfprintf$0(k,ppf,param)
     {var fmt=param[1];return make_iprintf(k,ppf,fmt)}
    function fprintf$0(ppf)
     {function _hE_(_hG_){return 0}
      return function(_hF_){return kfprintf$0(_hE_,ppf,_hF_)}}
    function ifprintf$0(ppf)
     {function _hB_(_hD_){return 0}
      return function(_hC_){return ikfprintf$0(_hB_,ppf,_hC_)}}
    function printf$0(fmt){return caml_call1(fprintf$0(std_formatter),fmt)}
    function eprintf$0(fmt){return caml_call1(fprintf$0(err_formatter),fmt)}
    function ksprintf$0(k,param)
     {var fmt=param[1],b=pp_make_buffer(0),ppf=formatter_of_buffer(b);
      function k$0(param,acc)
       {strput_acc$0(ppf,acc);
        return caml_call1(k,flush_buffer_formatter(b,ppf))}
      return make_printf(k$0,0,0,fmt)}
    function sprintf$0(fmt){return ksprintf$0(function(s){return s},fmt)}
    function kasprintf(k,param)
     {var fmt=param[1],b=pp_make_buffer(0),ppf=formatter_of_buffer(b);
      function k$0(ppf,acc)
       {output_acc$0(ppf,acc);
        return caml_call1(k,flush_buffer_formatter(b,ppf))}
      return make_printf(k$0,ppf,0,fmt)}
    function asprintf(fmt){return kasprintf(function(s){return s},fmt)}
    at_exit(print_flush);
    function pp_set_all_formatter_output_functions(state,f,g,h,i)
     {pp_set_formatter_output_functions(state,f,g);
      state[19] = h;
      state[20] = i;
      return 0}
    function pp_get_all_formatter_output_functions(state,param)
     {return [0,state[17],state[18],state[19],state[20]]}
    function set_all_formatter_output_functions(_hx_,_hy_,_hz_,_hA_)
     {return pp_set_all_formatter_output_functions
              (std_formatter,_hx_,_hy_,_hz_,_hA_)}
    function get_all_formatter_output_functions(_hw_)
     {return pp_get_all_formatter_output_functions(std_formatter,_hw_)}
    function bprintf$0(b,param)
     {var fmt=param[1];
      function k(ppf,acc){output_acc$0(ppf,acc);return pp_flush_queue(ppf,0)}
      return make_printf(k,formatter_of_buffer(b),0,fmt)}
    var
     Format=
      [0,
       pp_open_box,
       open_box,
       pp_close_box,
       close_box,
       pp_open_hbox,
       open_hbox,
       pp_open_vbox,
       open_vbox,
       pp_open_hvbox,
       open_hvbox,
       pp_open_hovbox,
       open_hovbox,
       pp_print_string,
       print_string$0,
       pp_print_as,
       print_as,
       pp_print_int,
       print_int$0,
       pp_print_float,
       print_float$0,
       pp_print_char,
       print_char$0,
       pp_print_bool,
       print_bool,
       pp_print_space,
       print_space,
       pp_print_cut,
       print_cut,
       pp_print_break,
       print_break,
       pp_force_newline,
       force_newline,
       pp_print_if_newline,
       print_if_newline,
       pp_print_flush,
       print_flush,
       pp_print_newline,
       print_newline$0,
       pp_set_margin,
       set_margin,
       pp_get_margin,
       get_margin,
       pp_set_max_indent,
       set_max_indent,
       pp_get_max_indent,
       get_max_indent,
       pp_set_max_boxes,
       set_max_boxes,
       pp_get_max_boxes,
       get_max_boxes,
       pp_over_max_boxes,
       over_max_boxes,
       pp_open_tbox,
       open_tbox,
       pp_close_tbox,
       close_tbox,
       pp_set_tab,
       set_tab,
       pp_print_tab,
       print_tab,
       pp_print_tbreak,
       print_tbreak,
       pp_set_ellipsis_text,
       set_ellipsis_text,
       pp_get_ellipsis_text,
       get_ellipsis_text,
       pp_open_tag,
       open_tag,
       pp_close_tag,
       close_tag,
       pp_set_tags,
       set_tags,
       pp_set_print_tags,
       set_print_tags,
       pp_set_mark_tags,
       set_mark_tags,
       pp_get_print_tags,
       get_print_tags,
       pp_get_mark_tags,
       get_mark_tags,
       pp_set_formatter_out_channel,
       set_formatter_out_channel,
       pp_set_formatter_output_functions,
       set_formatter_output_functions,
       pp_get_formatter_output_functions,
       get_formatter_output_functions,
       pp_set_formatter_out_functions,
       set_formatter_out_functions,
       pp_get_formatter_out_functions,
       get_formatter_out_functions,
       pp_set_formatter_tag_functions,
       set_formatter_tag_functions,
       pp_get_formatter_tag_functions,
       get_formatter_tag_functions,
       formatter_of_out_channel,
       std_formatter,
       err_formatter,
       formatter_of_buffer,
       stdbuf,
       str_formatter,
       flush_str_formatter,
       make_formatter,
       formatter_of_out_functions,
       make_symbolic_output_buffer,
       clear_symbolic_output_buffer,
       get_symbolic_output_buffer,
       flush_symbolic_output_buffer,
       add_symbolic_output_item,
       formatter_of_symbolic_output_buffer,
       pp_print_list,
       pp_print_text,
       fprintf$0,
       printf$0,
       eprintf$0,
       sprintf$0,
       asprintf,
       ifprintf$0,
       kfprintf$0,
       ikfprintf$0,
       ksprintf$0,
       kasprintf,
       bprintf$0,
       ksprintf$0,
       set_all_formatter_output_functions,
       get_all_formatter_output_functions,
       pp_set_all_formatter_output_functions,
       pp_get_all_formatter_output_functions];
    caml_register_global(681,Format,"Format");
    var null_char=0;
    function next_char(ib)
     {try
       {var c=caml_call1(ib[7],0);
        ib[2] = c;
        ib[3] = 1;
        ib[4] = ib[4] + 1 | 0;
        if(10 === c)ib[5] = ib[5] + 1 | 0;
        return c}
      catch(_hv_)
       {_hv_ = caml_wrap_exception(_hv_);
        if(_hv_ === End_of_file)
         {ib[2] = null_char;ib[3] = 0;ib[1] = 1;return null_char}
        throw _hv_}}
    function peek_char(ib){return ib[3]?ib[2]:next_char(ib)}
    function checked_peek_char(ib)
     {var c=peek_char(ib);if(ib[1])throw End_of_file;return c}
    function end_of_input(ib){peek_char(ib);return ib[1]}
    function beginning_of_input(ib){return 0 === ib[4]?1:0}
    function name_of_input(ib)
     {var _hu_=ib[9];
      if(typeof _hu_ === "number")
       return 0 === _hu_?cst_unnamed_function:cst_unnamed_character_string;
      else
       {if(0 === _hu_[0])return cst_unnamed_Pervasives_input_channel;
        var fname=_hu_[1];
        return fname}}
    function char_count(ib){return ib[3]?ib[4] - 1 | 0:ib[4]}
    function reset_token(ib){return reset(ib[8])}
    function invalidate_current_char(ib){ib[3] = 0;return 0}
    function token_string(ib)
     {var token_buffer=ib[8],tok=contents(token_buffer);
      clear$1(token_buffer);
      ib[6] = ib[6] + 1 | 0;
      return tok}
    function skip_char(width,ib){invalidate_current_char(ib);return width}
    function ignore_char(width,ib){return skip_char(width - 1 | 0,ib)}
    function store_char(width,ib,c)
     {add_char(ib[8],c);return ignore_char(width,ib)}
    var default_token_buffer_size=1024;
    function create$3(iname,next)
     {return [0,
              0,
              null_char,
              0,
              0,
              0,
              0,
              next,
              create$1(default_token_buffer_size),
              iname]}
    function from_string$1(s)
     {var i=[0,0],len=caml_ml_string_length(s);
      function next(param)
       {if(len <= i[1])throw End_of_file;
        var c=caml_string_get(s,i[1]);
        i[1]++;
        return c}
      return create$3(1,next)}
    var _b8_=0;
    function from_function$0(_ht_){return create$3(_b8_,_ht_)}
    var len=1024;
    function scan_close_at_end(ic)
     {caml_ml_close_channel(ic);throw End_of_file}
    function scan_raise_at_end(ic){throw End_of_file}
    function from_ic(scan_close_ic,iname,ic)
     {var buf=caml_create_bytes(1024),i=[0,0],lim=[0,0],eof=[0,0];
      function next(param)
       {if(i[1] < lim[1]){var c=caml_bytes_get(buf,i[1]);i[1]++;return c}
        if(eof[1])throw End_of_file;
        lim[1] = input(ic,buf,0,len);
        return 0 === lim[1]
                ?(eof[1] = 1,caml_call1(scan_close_ic,ic))
                :(i[1] = 1,caml_bytes_get(buf,0))}
      return create$3(iname,next)}
    var stdib=from_ic(scan_raise_at_end,[1,cst$72,stdin],stdin);
    function open_in_file(open_in,fname)
     {if(caml_string_notequal(fname,cst$73))
       {var ic=caml_call1(open_in,fname);
        return from_ic(scan_close_at_end,[1,fname,ic],ic)}
      return stdib}
    function from_file(_hs_){return open_in_file(open_in,_hs_)}
    function from_file_bin(_hr_){return open_in_file(open_in_bin,_hr_)}
    function from_channel$0(ic){return from_ic(scan_raise_at_end,[0,ic],ic)}
    function close_in(ib)
     {var _hq_=ib[9];
      if(typeof _hq_ === "number")
       return 0;
      else
       {if(0 === _hq_[0]){var ic=_hq_[1];return caml_ml_close_channel(ic)}
        var ic$0=_hq_[2];
        return caml_ml_close_channel(ic$0)}}
    var memo=[0,0];
    function memo_from_ic(scan_close_ic,ic)
     {try
       {var _ho_=assq(ic,memo[1]);return _ho_}
      catch(_hp_)
       {_hp_ = caml_wrap_exception(_hp_);
        if(_hp_ === Not_found)
         {var ib=from_ic(scan_close_ic,[0,ic],ic);
          memo[1] = [0,[0,ic,ib],memo[1]];
          return ib}
        throw _hp_}}
    function memo_from_channel(_hn_)
     {return memo_from_ic(scan_raise_at_end,_hn_)}
    var Scan_failure=[248,cst_Scanf_Scan_failure,caml_fresh_oo_id(0)];
    function bad_input(s){throw [0,Scan_failure,s]}
    function bad_input_escape(c)
     {return bad_input(caml_call1(sprintf(_b9_),c))}
    function bad_token_length(message)
     {return bad_input(caml_call1(sprintf(_b__),message))}
    function bad_float(param)
     {return bad_input(cst_no_dot_or_exponent_part_found_in_float_token)}
    function bad_hex_float(param)
     {return bad_input(cst_not_a_valid_float_in_hexadecimal_notation)}
    function character_mismatch(c,ci)
     {return bad_input(caml_call2(sprintf(_ca_),c,ci))}
    function check_this_char(ib,c)
     {var ci=checked_peek_char(ib);
      return ci === c?invalidate_current_char(ib):character_mismatch(c,ci)}
    function check_char(ib,c$0)
     {if(10 === c$0)
       {var ci=checked_peek_char(ib);
        return 10 === ci
                ?invalidate_current_char(ib)
                :13 === ci
                  ?(invalidate_current_char(ib),check_this_char(ib,10))
                  :character_mismatch(10,ci)}
      if(32 === c$0)
       for(;;)
        {var c=peek_char(ib),_hl_=1 - ib[1];
         if(_hl_)
          {var
            _hm_=c - 9 | 0,
            switch$0=
             4 < _hm_ >>> 0?23 === _hm_?1:0:1 < (_hm_ - 2 | 0) >>> 0?1:0;
           if(switch$0){invalidate_current_char(ib);continue}
           return 0}
         return _hl_}
      return check_this_char(ib,c$0)}
    function token_char(ib){return caml_string_get(token_string(ib),0)}
    function token_bool(ib)
     {var s=token_string(ib);
      return caml_string_notequal(s,cst_false$2)
              ?caml_string_notequal(s,cst_true$2)
                ?bad_input(caml_call1(sprintf(_cb_),s))
                :1
              :0}
    function integer_conversion_of_char(param)
     {var switcher=param - 88 | 0;
      if(! (32 < switcher >>> 0))
       switch(switcher)
        {case 10:return 0;
         case 12:return 1;
         case 17:return 2;
         case 23:return 3;
         case 29:return 4;
         case 0:
         case 32:return 5
         }
      throw [0,Assert_failure,_cc_]}
    function token_int_literal(conv,ib)
     {switch(conv)
       {case 0:var tok=symbol(cst_0b,token_string(ib));break;
        case 3:var tok=symbol(cst_0o,token_string(ib));break;
        case 4:var tok=symbol(cst_0u,token_string(ib));break;
        case 5:var tok=symbol(cst_0x,token_string(ib));break;
        default:var tok=token_string(ib)}
      var l=caml_ml_string_length(tok);
      if(0 !== l)
       if(43 === caml_string_get(tok,0))return sub$0(tok,1,l - 1 | 0);
      return tok}
    function token_float(ib){return caml_float_of_string(token_string(ib))}
    function scan_decimal_digit_star(width,ib)
     {var width$0=width;
      for(;;)
       {if(0 === width$0)return width$0;
        var c=peek_char(ib);
        if(ib[1])return width$0;
        if(58 <= c)
         {if(95 === c)
           {var width$1=ignore_char(width$0,ib),width$0=width$1;continue}}
        else
         if(48 <= c)
          {var width$2=store_char(width$0,ib,c),width$0=width$2;continue}
        return width$0}}
    function scan_unsigned_decimal_int(width,ib)
     {if(0 === width)return bad_token_length(cst_decimal_digits);
      var c=checked_peek_char(ib),switcher=c - 48 | 0;
      if(9 < switcher >>> 0)return bad_input(caml_call1(sprintf(_cd_),c));
      var width$0=store_char(width,ib,c);
      return scan_decimal_digit_star(width$0,ib)}
    function scan_digit_plus(basis,digitp,width$2,ib)
     {if(0 === width$2)return bad_token_length(cst_digits);
      var c$0=checked_peek_char(ib);
      if(caml_call1(digitp,c$0))
       {var width$3=store_char(width$2,ib,c$0),width=width$3;
        for(;;)
         {if(0 === width)return width;
          var c=peek_char(ib);
          if(ib[1])return width;
          if(caml_call1(digitp,c))
           {var width$0=store_char(width,ib,c),width=width$0;continue}
          if(95 === c)
           {var width$1=ignore_char(width,ib),width=width$1;continue}
          return width}}
      return bad_input(caml_call2(sprintf(_ce_),c$0,basis))}
    function is_binary_digit(param)
     {var switcher=param - 48 | 0;return 1 < switcher >>> 0?0:1}
    function scan_binary_int(_hj_,_hk_)
     {return scan_digit_plus(cst_binary,is_binary_digit,_hj_,_hk_)}
    function is_octal_digit(param)
     {var switcher=param - 48 | 0;return 7 < switcher >>> 0?0:1}
    function scan_octal_int(_hh_,_hi_)
     {return scan_digit_plus(cst_octal,is_octal_digit,_hh_,_hi_)}
    function is_hexa_digit(param)
     {var
       _hg_=param - 48 | 0,
       switch$0=
        22 < _hg_ >>> 0
         ?5 < (_hg_ - 49 | 0) >>> 0?0:1
         :6 < (_hg_ - 10 | 0) >>> 0?1:0;
      return switch$0?1:0}
    function scan_hexadecimal_int(_he_,_hf_)
     {return scan_digit_plus(cst_hexadecimal,is_hexa_digit,_he_,_hf_)}
    function scan_sign(width,ib)
     {var c=checked_peek_char(ib),switcher=c - 43 | 0;
      if(! (2 < switcher >>> 0))
       switch(switcher)
        {case 0:return store_char(width,ib,c);
         case 1:break;
         default:return store_char(width,ib,c)}
      return width}
    function scan_optionally_signed_decimal_int(width,ib)
     {var width$0=scan_sign(width,ib);
      return scan_unsigned_decimal_int(width$0,ib)}
    function scan_int_conversion(conv,width$1,ib)
     {switch(conv)
       {case 0:return scan_binary_int(width$1,ib);
        case 1:return scan_optionally_signed_decimal_int(width$1,ib);
        case 2:
         var width$0=scan_sign(width$1,ib),c=checked_peek_char(ib);
         if(48 === c)
          {var width=store_char(width$0,ib,c);
           if(0 === width)return width;
           var c$0=peek_char(ib);
           if(ib[1])return width;
           if(99 <= c$0)
            {if(111 === c$0)
              return scan_octal_int(store_char(width,ib,c$0),ib);
             var switch$0=120 === c$0?1:0}
           else
            if(88 === c$0)
             var switch$0=1;
            else
             {if(98 <= c$0)
               return scan_binary_int(store_char(width,ib,c$0),ib);
              var switch$0=0}
           return switch$0
                   ?scan_hexadecimal_int(store_char(width,ib,c$0),ib)
                   :scan_decimal_digit_star(width,ib)}
         return scan_unsigned_decimal_int(width$0,ib);
        case 3:return scan_octal_int(width$1,ib);
        case 4:return scan_unsigned_decimal_int(width$1,ib);
        default:return scan_hexadecimal_int(width$1,ib)}}
    function scan_fractional_part(width,ib)
     {if(0 === width)return width;
      var c=peek_char(ib);
      if(ib[1])return width;
      var switcher=c - 48 | 0;
      return 9 < switcher >>> 0
              ?width
              :scan_decimal_digit_star(store_char(width,ib,c),ib)}
    function scan_exponent_part(width,ib)
     {if(0 === width)return width;
      var c=peek_char(ib);
      if(ib[1])return width;
      if(69 !== c)if(101 !== c)return width;
      return scan_optionally_signed_decimal_int(store_char(width,ib,c),ib)}
    function scan_float(width$1,precision,ib)
     {var
       width=scan_sign(width$1,ib),
       width$0=scan_decimal_digit_star(width,ib);
      if(0 === width$0)return [0,width$0,precision];
      var c=peek_char(ib);
      if(ib[1])return [0,width$0,precision];
      if(46 === c)
       {var
         width$2=store_char(width$0,ib,c),
         precision$0=min(width$2,precision),
         width$3=
          width$2
          -
          (precision$0 - scan_fractional_part(precision$0,ib) | 0)
          |
          0;
        return [0,scan_exponent_part(width$3,ib),precision$0]}
      return [0,scan_exponent_part(width$0,ib),precision]}
    function check_case_insensitive_string(width,ib,error,str)
     {function lowercase(c)
       {var switcher=c - 65 | 0;
        return 25 < switcher >>> 0?c:char_of_int((c - 65 | 0) + 97 | 0)}
      var
       len=caml_ml_string_length(str),
       width$0=[0,width],
       _hb_=len - 1 | 0,
       _ha_=0;
      if(! (_hb_ < 0))
       {var i=_ha_;
        for(;;)
         {var c=peek_char(ib),_hc_=lowercase(caml_string_get(str,i));
          if(lowercase(c) !== _hc_)caml_call1(error,0);
          if(0 === width$0[1])caml_call1(error,0);
          width$0[1] = store_char(width$0[1],ib,c);
          var _hd_=i + 1 | 0;
          if(_hb_ !== i){var i=_hd_;continue}
          break}}
      return width$0[1]}
    function scan_hex_float(width,precision,ib)
     {var _gZ_=0 === width?1:0,_g0_=_gZ_ || end_of_input(ib);
      if(_g0_)bad_hex_float(0);
      var
       width$0=scan_sign(width,ib),
       _g1_=0 === width$0?1:0,
       _g2_=_g1_ || end_of_input(ib);
      if(_g2_)bad_hex_float(0);
      var c=peek_char(ib);
      if(78 <= c)
       {var switcher=c - 79 | 0;
        if(30 < switcher >>> 0)
         {if(! (32 <= switcher))
           {var
             width$1=store_char(width$0,ib,c),
             _g3_=0 === width$1?1:0,
             _g4_=_g3_ || end_of_input(ib);
            if(_g4_)bad_hex_float(0);
            return check_case_insensitive_string
                    (width$1,ib,bad_hex_float,cst_an)}
          var switch$0=0}
        else
         var switch$0=26 === switcher?1:0}
      else
       {if(48 === c)
         {var
           width$3=store_char(width$0,ib,c),
           _g7_=0 === width$3?1:0,
           _g8_=_g7_ || end_of_input(ib);
          if(_g8_)bad_hex_float(0);
          var
           width$4=
            check_case_insensitive_string(width$3,ib,bad_hex_float,cst_x$2);
          if(0 !== width$4)
           if(! end_of_input(ib))
            {var
              match=peek_char(ib),
              _g9_=match - 46 | 0,
              switch$1=
               34 < _g9_ >>> 0?66 === _g9_?1:0:32 < (_g9_ - 1 | 0) >>> 0?1:0,
              width$5=switch$1?width$4:scan_hexadecimal_int(width$4,ib);
             if(0 !== width$5)
              if(! end_of_input(ib))
               {var c$0=peek_char(ib);
                if(46 === c$0)
                 {var width$6=store_char(width$5,ib,c$0);
                  if(0 === width$6)
                   var switch$2=0;
                  else
                   if(end_of_input(ib))
                    var switch$2=0;
                   else
                    {var match$0=peek_char(ib);
                     if(80 === match$0)
                      var switch$3=0;
                     else
                      if(112 === match$0)
                       var switch$3=0;
                      else
                       var
                        precision$0=min(width$6,precision),
                        width$10=
                         width$6
                         -
                         (precision$0 - scan_hexadecimal_int(precision$0,ib) | 0)
                         |
                         0,
                        switch$3=1;
                     if(! switch$3)var width$10=width$6;
                     var width$7=width$10,switch$2=1}
                  if(! switch$2)var width$7=width$6;
                  var width$8=width$7}
                else
                 var width$8=width$5;
                if(0 !== width$8)
                 if(! end_of_input(ib))
                  {var c$1=peek_char(ib);
                   if(80 !== c$1)if(112 !== c$1)return width$8;
                   var
                    width$9=store_char(width$8,ib,c$1),
                    _g__=0 === width$9?1:0,
                    _g$_=_g__ || end_of_input(ib);
                   if(_g$_)bad_hex_float(0);
                   return scan_optionally_signed_decimal_int(width$9,ib)}
                return width$8}
             return width$5}
          return width$4}
        var switch$0=73 === c?1:0}
      if(switch$0)
       {var
         width$2=store_char(width$0,ib,c),
         _g5_=0 === width$2?1:0,
         _g6_=_g5_ || end_of_input(ib);
        if(_g6_)bad_hex_float(0);
        return check_case_insensitive_string
                (width$2,ib,bad_hex_float,cst_nfinity)}
      return bad_hex_float(0)}
    function scan_caml_float_rest(width,precision,ib)
     {var _gV_=0 === width?1:0,_gW_=_gV_ || end_of_input(ib);
      if(_gW_)bad_float(0);
      var
       width$0=scan_decimal_digit_star(width,ib),
       _gX_=0 === width$0?1:0,
       _gY_=_gX_ || end_of_input(ib);
      if(_gY_)bad_float(0);
      var c=peek_char(ib),switcher=c - 69 | 0;
      if(32 < switcher >>> 0)
       {if(-23 === switcher)
         {var
           width$1=store_char(width$0,ib,c),
           precision$0=min(width$1,precision),
           width_precision=scan_fractional_part(precision$0,ib),
           frac_width=precision$0 - width_precision | 0,
           width$2=width$1 - frac_width | 0;
          return scan_exponent_part(width$2,ib)}}
      else
       {var switcher$0=switcher - 1 | 0;
        if(30 < switcher$0 >>> 0)return scan_exponent_part(width$0,ib)}
      return bad_float(0)}
    function scan_caml_float(width,precision,ib)
     {var _gH_=0 === width?1:0,_gI_=_gH_ || end_of_input(ib);
      if(_gI_)bad_float(0);
      var
       width$0=scan_sign(width,ib),
       _gJ_=0 === width$0?1:0,
       _gK_=_gJ_ || end_of_input(ib);
      if(_gK_)bad_float(0);
      var c=peek_char(ib);
      if(49 <= c)
       {if(! (58 <= c))
         {var
           width$1=store_char(width$0,ib,c),
           _gL_=0 === width$1?1:0,
           _gM_=_gL_ || end_of_input(ib);
          if(_gM_)bad_float(0);
          return scan_caml_float_rest(width$1,precision,ib)}}
      else
       if(48 <= c)
        {var
          width$2=store_char(width$0,ib,c),
          _gN_=0 === width$2?1:0,
          _gO_=_gN_ || end_of_input(ib);
         if(_gO_)bad_float(0);
         var c$0=peek_char(ib);
         if(88 !== c$0)
          if(120 !== c$0)return scan_caml_float_rest(width$2,precision,ib);
         var
          width$3=store_char(width$2,ib,c$0),
          _gP_=0 === width$3?1:0,
          _gQ_=_gP_ || end_of_input(ib);
         if(_gQ_)bad_float(0);
         var
          width$4=scan_hexadecimal_int(width$3,ib),
          _gR_=0 === width$4?1:0,
          _gS_=_gR_ || end_of_input(ib);
         if(_gS_)bad_float(0);
         var c$1=peek_char(ib),switcher=c$1 - 80 | 0;
         if(32 < switcher >>> 0)
          if(-34 === switcher)
           {var width$5=store_char(width$4,ib,c$1);
            if(0 === width$5)
             var switch$1=0;
            else
             if(end_of_input(ib))
              var switch$1=0;
             else
              {var match=peek_char(ib);
               if(80 === match)
                var switch$2=0;
               else
                if(112 === match)
                 var switch$2=0;
                else
                 var
                  precision$0=min(width$5,precision),
                  width$10=
                   width$5
                   -
                   (precision$0 - scan_hexadecimal_int(precision$0,ib) | 0)
                   |
                   0,
                  switch$2=1;
               if(! switch$2)var width$10=width$5;
               var width$6=width$10,switch$1=1}
            if(! switch$1)var width$6=width$5;
            var width$7=width$6,switch$0=0}
          else
           var switch$0=1;
         else
          {var switcher$0=switcher - 1 | 0;
           if(30 < switcher$0 >>> 0)
            var width$7=width$4,switch$0=0;
           else
            var switch$0=1}
         var width$8=switch$0?bad_float(0):width$7;
         if(0 !== width$8)
          if(! end_of_input(ib))
           {var c$2=peek_char(ib);
            if(80 !== c$2)if(112 !== c$2)return width$8;
            var
             width$9=store_char(width$8,ib,c$2),
             _gT_=0 === width$9?1:0,
             _gU_=_gT_ || end_of_input(ib);
            if(_gU_)bad_hex_float(0);
            return scan_optionally_signed_decimal_int(width$9,ib)}
         return width$8}
      return bad_float(0)}
    function scan_string(stp,width,ib)
     {var width$0=width;
      for(;;)
       {if(0 === width$0)return width$0;
        var c=peek_char(ib);
        if(ib[1])return width$0;
        if(stp)
         {var c$0=stp[1];
          if(c === c$0)return skip_char(width$0,ib);
          var width$1=store_char(width$0,ib,c),width$0=width$1;
          continue}
        var
         _gG_=c - 9 | 0,
         switch$0=4 < _gG_ >>> 0?23 === _gG_?1:0:1 < (_gG_ - 2 | 0) >>> 0?1:0;
        if(switch$0)return width$0;
        var width$2=store_char(width$0,ib,c),width$0=width$2;
        continue}}
    function scan_char(width,ib)
     {return store_char(width,ib,checked_peek_char(ib))}
    function hexadecimal_value_of_char(d)
     {return 97 <= d?d - 87 | 0:65 <= d?d - 55 | 0:d - 48 | 0}
    function check_next_char(message,width,ib)
     {if(0 === width)return bad_token_length(message);
      var c=peek_char(ib);
      return ib[1]?bad_input(caml_call1(sprintf(_b$_),message)):c}
    function check_next_char_for_char(_gE_,_gF_)
     {return check_next_char(cst_a_Char,_gE_,_gF_)}
    function check_next_char_for_string(_gC_,_gD_)
     {return check_next_char(cst_a_String,_gC_,_gD_)}
    function scan_backslash_char(width,ib)
     {var c0=check_next_char_for_char(width,ib);
      if(40 <= c0)
       if(58 <= c0)
        {var switcher$0=c0 - 92 | 0;
         if(28 < switcher$0 >>> 0)
          var switch$0=0;
         else
          switch(switcher$0)
           {case 28:
             var
              get_digit=
               function(param)
                {var
                  c=next_char(ib),
                  _gB_=c - 48 | 0,
                  switch$0=
                   22 < _gB_ >>> 0
                    ?5 < (_gB_ - 49 | 0) >>> 0?0:1
                    :6 < (_gB_ - 10 | 0) >>> 0?1:0;
                 return switch$0?c:bad_input_escape(c)},
              c1=get_digit(0),
              c2=get_digit(0),
              _gx_=hexadecimal_value_of_char(c2),
              c$0=(16 * hexadecimal_value_of_char(c1) | 0) + _gx_ | 0;
             if(0 <= c$0)
              if(255 < c$0)
               var switch$1=0;
              else
               var _gz_=char_of_int(c$0),switch$1=1;
             else
              var switch$1=0;
             if(! switch$1)
              var _gz_=bad_input(caml_call2(sprintf(_cg_),c1,c2));
             return store_char(width - 2 | 0,ib,_gz_);
            case 0:
            case 6:
            case 18:
            case 22:
            case 24:var switch$0=1;break;
            default:var switch$0=0}}
       else
        {if(48 <= c0)
          {var
            get_digit$0=
             function(param)
              {var c=next_char(ib),switcher=c - 48 | 0;
               return 9 < switcher >>> 0?bad_input_escape(c):c},
            c1$0=get_digit$0(0),
            c2$0=get_digit$0(0),
            c=
             ((100 * (c0 - 48 | 0) | 0) + (10 * (c1$0 - 48 | 0) | 0) | 0)
             +
             (c2$0 - 48 | 0)
             |
             0;
           if(0 <= c)
            if(255 < c)var switch$2=0;else var _gA_=char_of_int(c),switch$2=1;
           else
            var switch$2=0;
           if(! switch$2)
            var _gA_=bad_input(caml_call3(sprintf(_cf_),c0,c1$0,c2$0));
           return store_char(width - 2 | 0,ib,_gA_)}
         var switch$0=0}
      else
       var switch$0=34 === c0?1:39 <= c0?1:0;
      if(switch$0)
       {if(110 <= c0)
         if(117 <= c0)
          var switch$3=0;
         else
          {var switcher=c0 - 110 | 0;
           switch(switcher)
            {case 0:var _gy_=10,switch$3=1;break;
             case 4:var _gy_=13,switch$3=1;break;
             case 6:var _gy_=9,switch$3=1;break;
             default:var switch$3=0}}
        else
         if(98 === c0)var _gy_=8,switch$3=1;else var switch$3=0;
        if(! switch$3)var _gy_=c0;
        return store_char(width,ib,_gy_)}
      return bad_input_escape(c0)}
    function scan_caml_char(width,ib)
     {function find_stop(width)
       {var c=check_next_char_for_char(width,ib);
        return 39 === c?ignore_char(width,ib):character_mismatch(39,c)}
      var c=checked_peek_char(ib);
      if(39 === c)
       {var
         width$0=ignore_char(width,ib),
         c$0=check_next_char_for_char(width$0,ib);
        return 92 === c$0
                ?find_stop(scan_backslash_char(ignore_char(width$0,ib),ib))
                :find_stop(store_char(width$0,ib,c$0))}
      return character_mismatch(39,c)}
    function scan_caml_string(width,ib)
     {function find_stop$0(counter,width)
       {var width$0=width;
        for(;;)
         {var c=check_next_char_for_string(width$0,ib);
          if(34 === c)return ignore_char(width$0,ib);
          if(92 === c)
           {var
             width$1=ignore_char(width$0,ib),
             match=check_next_char_for_string(width$1,ib);
            if(10 === match)
             {var _gv_=ignore_char(width$1,ib);
              if(counter < 50)
               {var counter$0=counter + 1 | 0;
                return skip_spaces(counter$0,_gv_)}
              return caml_trampoline_return(skip_spaces,[0,_gv_])}
            if(13 === match)
             {var
               width$3=ignore_char(width$1,ib),
               match$0=check_next_char_for_string(width$3,ib);
              if(10 === match$0)
               {var _gw_=ignore_char(width$3,ib);
                if(counter < 50)
                 {var counter$1=counter + 1 | 0;
                  return skip_spaces(counter$1,_gw_)}
                return caml_trampoline_return(skip_spaces,[0,_gw_])}
              var width$5=store_char(width$3,ib,13),width$0=width$5;
              continue}
            var width$4=scan_backslash_char(width$1,ib),width$0=width$4;
            continue}
          var width$2=store_char(width$0,ib,c),width$0=width$2;
          continue}}
      function skip_spaces(counter,width)
       {var width$0=width;
        for(;;)
         {var match=check_next_char_for_string(width$0,ib);
          if(32 === match)
           {var width$1=ignore_char(width$0,ib),width$0=width$1;continue}
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return find_stop$0(counter$0,width$0)}
          return caml_trampoline_return(find_stop$0,[0,width$0])}}
      function find_stop(width){return caml_trampoline(find_stop$0(0,width))}
      var c=checked_peek_char(ib);
      return 34 === c
              ?find_stop(ignore_char(width,ib))
              :character_mismatch(34,c)}
    function scan_chars_in_char_set(char_set,scan_indic,width,ib)
     {function scan_chars(i,stp)
       {var i$0=i;
        for(;;)
         {var c=peek_char(ib),_gr_=0 < i$0?1:0;
          if(_gr_)
           {var _gs_=1 - ib[1];
            if(_gs_)
             var _gt_=is_in_char_set(char_set,c),_gu_=_gt_?c !== stp?1:0:_gt_;
            else
             var _gu_=_gs_}
          else
           var _gu_=_gr_;
          if(_gu_)
           {store_char(max_int,ib,c);var i$1=i$0 - 1 | 0,i$0=i$1;continue}
          return _gu_}}
      if(scan_indic)
       {var c=scan_indic[1];
        scan_chars(width,c);
        var _gq_=1 - ib[1];
        if(_gq_)
         {var ci=peek_char(ib);
          return c === ci?invalidate_current_char(ib):character_mismatch(c,ci)}
        return _gq_}
      return scan_chars(width,-1)}
    function scanf_bad_input(ib,x)
     {if(x[1] === Scan_failure)
       var s=x[2];
      else
       {if(x[1] !== Failure)throw x;var s=x[2]}
      var i=char_count(ib);
      return bad_input(caml_call2(sprintf(_ci_),i,s))}
    function get_counter(ib,counter)
     {switch(counter)
       {case 0:return ib[5];case 1:return char_count(ib);default:return ib[6]}}
    function width_of_pad_opt(pad_opt)
     {if(pad_opt){var width=pad_opt[1];return width}return max_int}
    function stopper_of_formatting_lit(fmting)
     {if(6 === fmting)return _cj_;
      var
       str=string_of_formatting_lit(fmting),
       stp=caml_string_get(str,1),
       sub_str=sub$0(str,2,caml_ml_string_length(str) - 2 | 0);
      return [0,stp,sub_str]}
    function take_format_readers$0(counter,k,fmt)
     {var fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k,0);
       else
        switch(fmt$0[0])
         {case 0:var fmt$1=fmt$0[1],fmt$0=fmt$1;continue;
          case 1:var fmt$2=fmt$0[1],fmt$0=fmt$2;continue;
          case 2:var fmt$3=fmt$0[2],fmt$0=fmt$3;continue;
          case 3:var fmt$4=fmt$0[2],fmt$0=fmt$4;continue;
          case 4:var fmt$5=fmt$0[4],fmt$0=fmt$5;continue;
          case 5:var fmt$6=fmt$0[4],fmt$0=fmt$6;continue;
          case 6:var fmt$7=fmt$0[4],fmt$0=fmt$7;continue;
          case 7:var fmt$8=fmt$0[4],fmt$0=fmt$8;continue;
          case 8:var fmt$9=fmt$0[4],fmt$0=fmt$9;continue;
          case 9:var fmt$10=fmt$0[2],fmt$0=fmt$10;continue;
          case 10:var fmt$11=fmt$0[1],fmt$0=fmt$11;continue;
          case 11:var fmt$12=fmt$0[2],fmt$0=fmt$12;continue;
          case 12:var fmt$13=fmt$0[2],fmt$0=fmt$13;continue;
          case 13:var fmt$14=fmt$0[3],fmt$0=fmt$14;continue;
          case 14:
           var rest=fmt$0[3],fmtty=fmt$0[2],_go_=erase_rel(symm(fmtty));
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return take_fmtty_format_readers$0(counter$0,k,_go_,rest)}
           return caml_trampoline_return
                   (take_fmtty_format_readers$0,[0,k,_go_,rest]);
          case 15:var fmt$15=fmt$0[1],fmt$0=fmt$15;continue;
          case 16:var fmt$16=fmt$0[1],fmt$0=fmt$16;continue;
          case 17:var fmt$17=fmt$0[2],fmt$0=fmt$17;continue;
          case 18:
           var _gp_=fmt$0[1];
           if(0 === _gp_[0])
            {var
              rest$0=fmt$0[2],
              match=_gp_[1],
              fmt$18=match[1],
              fmt$19=concat_fmt(fmt$18,rest$0),
              fmt$0=fmt$19;
             continue}
           var
            rest$1=fmt$0[2],
            match$0=_gp_[1],
            fmt$20=match$0[1],
            fmt$21=concat_fmt(fmt$20,rest$1),
            fmt$0=fmt$21;
           continue;
          case 19:
           var fmt_rest=fmt$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_format_readers(new_k,fmt_rest)};
          case 20:var fmt$22=fmt$0[3],fmt$0=fmt$22;continue;
          case 21:var fmt$23=fmt$0[2],fmt$0=fmt$23;continue;
          case 22:var fmt$24=fmt$0[1],fmt$0=fmt$24;continue;
          case 23:
           var rest$2=fmt$0[2],ign=fmt$0[1];
           if(typeof ign === "number")
            switch(ign)
             {case 0:var fmt$0=rest$2;continue;
              case 1:var fmt$0=rest$2;continue;
              case 2:
               return function(reader)
                {function new_k(readers_rest)
                  {return caml_call1(k,[0,reader,readers_rest])}
                 return take_format_readers(new_k,rest$2)};
              default:var fmt$0=rest$2;continue}
           else
            switch(ign[0])
             {case 0:var fmt$0=rest$2;continue;
              case 1:var fmt$0=rest$2;continue;
              case 2:var fmt$0=rest$2;continue;
              case 3:var fmt$0=rest$2;continue;
              case 4:var fmt$0=rest$2;continue;
              case 5:var fmt$0=rest$2;continue;
              case 6:var fmt$0=rest$2;continue;
              case 7:var fmt$0=rest$2;continue;
              case 8:var fmt$0=rest$2;continue;
              case 9:
               var fmtty$0=ign[2];
               if(counter < 50)
                {var counter$1=counter + 1 | 0;
                 return take_fmtty_format_readers$0
                         (counter$1,k,fmtty$0,rest$2)}
               return caml_trampoline_return
                       (take_fmtty_format_readers$0,[0,k,fmtty$0,rest$2]);
              case 10:var fmt$0=rest$2;continue;
              default:var fmt$0=rest$2;continue}
          default:var fmt$25=fmt$0[3],fmt$0=fmt$25;continue}}
    function take_fmtty_format_readers$0(counter,k,fmtty,fmt)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        {if(counter < 50)
          {var counter$0=counter + 1 | 0;
           return take_format_readers$0(counter$0,k,fmt)}
         return caml_trampoline_return(take_format_readers$0,[0,k,fmt])}
       else
        switch(fmtty$0[0])
         {case 0:var fmtty$1=fmtty$0[1],fmtty$0=fmtty$1;continue;
          case 1:var fmtty$2=fmtty$0[1],fmtty$0=fmtty$2;continue;
          case 2:var fmtty$3=fmtty$0[1],fmtty$0=fmtty$3;continue;
          case 3:var fmtty$4=fmtty$0[1],fmtty$0=fmtty$4;continue;
          case 4:var fmtty$5=fmtty$0[1],fmtty$0=fmtty$5;continue;
          case 5:var fmtty$6=fmtty$0[1],fmtty$0=fmtty$6;continue;
          case 6:var fmtty$7=fmtty$0[1],fmtty$0=fmtty$7;continue;
          case 7:var fmtty$8=fmtty$0[1],fmtty$0=fmtty$8;continue;
          case 8:var fmtty$9=fmtty$0[2],fmtty$0=fmtty$9;continue;
          case 9:
           var
            rest=fmtty$0[3],
            ty2=fmtty$0[2],
            ty1=fmtty$0[1],
            ty=trans(symm(ty1),ty2),
            fmtty$10=concat_fmtty(ty,rest),
            fmtty$0=fmtty$10;
           continue;
          case 10:var fmtty$11=fmtty$0[1],fmtty$0=fmtty$11;continue;
          case 11:var fmtty$12=fmtty$0[1],fmtty$0=fmtty$12;continue;
          case 12:var fmtty$13=fmtty$0[1],fmtty$0=fmtty$13;continue;
          case 13:
           var fmt_rest=fmtty$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_fmtty_format_readers(new_k,fmt_rest,fmt)};
          default:
           var fmt_rest$0=fmtty$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_fmtty_format_readers(new_k,fmt_rest$0,fmt)}}}
    function take_format_readers(k,fmt)
     {return caml_trampoline(take_format_readers$0(0,k,fmt))}
    function take_fmtty_format_readers(k,fmtty,fmt)
     {return caml_trampoline(take_fmtty_format_readers$0(0,k,fmtty,fmt))}
    function pad_prec_scanf(ib,fmt,readers,pad,prec,scan,token)
     {if(typeof pad === "number")
       {if(typeof prec === "number")
         {if(0 === prec)
           {caml_call3(scan,max_int,max_int,ib);
            var x=caml_call1(token,ib);
            return [0,x,make_scanf(ib,fmt,readers)]}
          return invalid_arg(cst_scanf_bad_conversion)}
        var p=prec[1];
        caml_call3(scan,max_int,p,ib);
        var x$0=caml_call1(token,ib);
        return [0,x$0,make_scanf(ib,fmt,readers)]}
      else
       {if(0 === pad[0])
         {if(0 === pad[1])return invalid_arg(cst_scanf_bad_conversion$0);
          var _gn_=pad[2];
          if(typeof prec === "number")
           {if(0 === prec)
             {caml_call3(scan,_gn_,max_int,ib);
              var x$1=caml_call1(token,ib);
              return [0,x$1,make_scanf(ib,fmt,readers)]}
            return invalid_arg(cst_scanf_bad_conversion$1)}
          var p$0=prec[1];
          caml_call3(scan,_gn_,p$0,ib);
          var x$2=caml_call1(token,ib);
          return [0,x$2,make_scanf(ib,fmt,readers)]}
        return invalid_arg(cst_scanf_bad_conversion$2)}}
    function make_scanf(ib,fmt,readers)
     {var fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return 0;
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1];
           scan_char(0,ib);
           var c=token_char(ib);
           return [0,c,make_scanf(ib,rest,readers)];
          case 1:
           var rest$0=fmt$0[1];
           scan_caml_char(0,ib);
           var c$0=token_char(ib);
           return [0,c$0,make_scanf(ib,rest$0,readers)];
          case 2:
           var _f__=fmt$0[2],_f$_=fmt$0[1];
           if(typeof _f__ !== "number")
            switch(_f__[0])
             {case 17:
               var
                rest$1=_f__[2],
                fmting_lit=_f__[1],
                match=stopper_of_formatting_lit(fmting_lit),
                str=match[2],
                stp=match[1],
                scan$0=
                 function(width,param,ib)
                  {return scan_string([0,stp],width,ib)},
                str_rest=[11,str,rest$1];
               return pad_prec_scanf
                       (ib,str_rest,readers,_f$_,0,scan$0,token_string);
              case 18:
               var _ga_=_f__[1];
               if(0 === _ga_[0])
                {var
                  rest$2=_f__[2],
                  match$0=_ga_[1],
                  fmt$1=match$0[1],
                  scan$1=
                   function(width,param,ib){return scan_string(_ck_,width,ib)};
                 return pad_prec_scanf
                         (ib,
                          concat_fmt(fmt$1,rest$2),
                          readers,
                          _f$_,
                          0,
                          scan$1,
                          token_string)}
               var
                rest$3=_f__[2],
                match$1=_ga_[1],
                fmt$2=match$1[1],
                scan$2=
                 function(width,param,ib){return scan_string(_cl_,width,ib)};
               return pad_prec_scanf
                       (ib,
                        concat_fmt(fmt$2,rest$3),
                        readers,
                        _f$_,
                        0,
                        scan$2,
                        token_string)
              }
           var scan=function(width,param,ib){return scan_string(0,width,ib)};
           return pad_prec_scanf(ib,_f__,readers,_f$_,0,scan,token_string);
          case 3:
           var
            rest$4=fmt$0[2],
            pad=fmt$0[1],
            scan$3=function(width,param,ib){return scan_caml_string(width,ib)};
           return pad_prec_scanf(ib,rest$4,readers,pad,0,scan$3,token_string);
          case 4:
           var
            rest$5=fmt$0[4],
            prec=fmt$0[3],
            pad$0=fmt$0[2],
            iconv=fmt$0[1],
            conv=integer_conversion_of_char(char_of_iconv(iconv)),
            scan$4=
             function(width,param,ib)
              {return scan_int_conversion(conv,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$5,
                    readers,
                    pad$0,
                    prec,
                    scan$4,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv,ib))});
          case 5:
           var
            rest$6=fmt$0[4],
            prec$0=fmt$0[3],
            pad$1=fmt$0[2],
            iconv$0=fmt$0[1],
            conv$0=integer_conversion_of_char(char_of_iconv(iconv$0)),
            scan$5=
             function(width,param,ib)
              {return scan_int_conversion(conv$0,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$6,
                    readers,
                    pad$1,
                    prec$0,
                    scan$5,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv$0,ib))});
          case 6:
           var
            rest$7=fmt$0[4],
            prec$1=fmt$0[3],
            pad$2=fmt$0[2],
            iconv$1=fmt$0[1],
            conv$1=integer_conversion_of_char(char_of_iconv(iconv$1)),
            scan$6=
             function(width,param,ib)
              {return scan_int_conversion(conv$1,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$7,
                    readers,
                    pad$2,
                    prec$1,
                    scan$6,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv$1,ib))});
          case 7:
           var
            rest$8=fmt$0[4],
            prec$2=fmt$0[3],
            pad$3=fmt$0[2],
            iconv$2=fmt$0[1],
            conv$2=integer_conversion_of_char(char_of_iconv(iconv$2)),
            scan$7=
             function(width,param,ib)
              {return scan_int_conversion(conv$2,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$8,
                    readers,
                    pad$3,
                    prec$2,
                    scan$7,
                    function(ib)
                     {return caml_int64_of_string(token_int_literal(conv$2,ib))});
          case 8:
           var _gb_=fmt$0[1];
           if(15 === _gb_)
            {var rest$9=fmt$0[4],prec$3=fmt$0[3],pad$4=fmt$0[2];
             return pad_prec_scanf
                     (ib,rest$9,readers,pad$4,prec$3,scan_caml_float,token_float)}
           if(16 <= _gb_)
            {var rest$10=fmt$0[4],prec$4=fmt$0[3],pad$5=fmt$0[2];
             return pad_prec_scanf
                     (ib,rest$10,readers,pad$5,prec$4,scan_hex_float,token_float)}
           var rest$11=fmt$0[4],prec$5=fmt$0[3],pad$6=fmt$0[2];
           return pad_prec_scanf
                   (ib,rest$11,readers,pad$6,prec$5,scan_float,token_float);
          case 9:
           var
            rest$12=fmt$0[2],
            pad$7=fmt$0[1],
            scan$8=
             function(param,_gm_,ib)
              {var
                c=checked_peek_char(ib),
                m=
                 102 === c
                  ?5
                  :116 === c?4:bad_input(caml_call1(sprintf(_ch_),c));
               return scan_string(0,m,ib)};
           return pad_prec_scanf(ib,rest$12,readers,pad$7,0,scan$8,token_bool);
          case 10:
           var rest$13=fmt$0[1];
           if(end_of_input(ib)){var fmt$0=rest$13;continue}
           return bad_input(cst_end_of_input_not_found);
          case 11:
           var rest$14=fmt$0[2],str$0=fmt$0[1];
           iter$1(function(_gl_){return check_char(ib,_gl_)},str$0);
           var fmt$0=rest$14;
           continue;
          case 12:
           var rest$15=fmt$0[2],chr=fmt$0[1];
           check_char(ib,chr);
           var fmt$0=rest$15;
           continue;
          case 13:
           var rest$16=fmt$0[3],fmtty=fmt$0[2],pad_opt=fmt$0[1];
           scan_caml_string(width_of_pad_opt(pad_opt),ib);
           var s=token_string(ib);
           try
            {var _gc_=format_of_string_fmtty(s,fmtty),fmt$3=_gc_}
           catch(exn)
            {exn = caml_wrap_exception(exn);
             if(exn[1] !== Failure)throw exn;
             var msg=exn[2],fmt$3=bad_input(msg)}
           return [0,fmt$3,make_scanf(ib,rest$16,readers)];
          case 14:
           var rest$17=fmt$0[3],fmtty$0=fmt$0[2],pad_opt$0=fmt$0[1];
           scan_caml_string(width_of_pad_opt(pad_opt$0),ib);
           var s$0=token_string(ib);
           try
            {var
              match$2=fmt_ebb_of_string(0,s$0),
              fmt$6=match$2[1],
              match$3=fmt_ebb_of_string(0,s$0),
              fmt$7=match$3[1],
              fmt$8=type_format(fmt$7,erase_rel(symm(fmtty$0))),
              _ge_=type_format(fmt$6,erase_rel(fmtty$0)),
              fmt$5=_ge_,
              fmt$4=fmt$8}
           catch(exn)
            {exn = caml_wrap_exception(exn);
             if(exn[1] !== Failure)throw exn;
             var
              msg$0=exn[2],
              _gd_=bad_input(msg$0),
              fmt$5=_gd_[1],
              fmt$4=_gd_[2]}
           return [0,
                   [0,fmt$5,s$0],
                   make_scanf(ib,concat_fmt(fmt$4,rest$17),readers)];
          case 15:return invalid_arg(cst_scanf_bad_conversion_a);
          case 16:return invalid_arg(cst_scanf_bad_conversion_t);
          case 17:
           var
            rest$18=fmt$0[2],
            formatting_lit=fmt$0[1],
            _gf_=string_of_formatting_lit(formatting_lit);
           iter$1(function(_gk_){return check_char(ib,_gk_)},_gf_);
           var fmt$0=rest$18;
           continue;
          case 18:
           var _gg_=fmt$0[1];
           if(0 === _gg_[0])
            {var rest$19=fmt$0[2],match$4=_gg_[1],fmt$9=match$4[1];
             check_char(ib,64);
             check_char(ib,123);
             var fmt$10=concat_fmt(fmt$9,rest$19),fmt$0=fmt$10;
             continue}
           var rest$20=fmt$0[2],match$5=_gg_[1],fmt$11=match$5[1];
           check_char(ib,64);
           check_char(ib,91);
           var fmt$12=concat_fmt(fmt$11,rest$20),fmt$0=fmt$12;
           continue;
          case 19:
           var fmt_rest=fmt$0[1];
           if(readers)
            {var
              readers_rest=readers[2],
              reader=readers[1],
              x=caml_call1(reader,ib);
             return [0,x,make_scanf(ib,fmt_rest,readers_rest)]}
           return invalid_arg(cst_scanf_missing_reader);
          case 20:
           var _gh_=fmt$0[3],_gi_=fmt$0[2],_gj_=fmt$0[1];
           if(typeof _gh_ !== "number" && 17 === _gh_[0])
            {var
              rest$21=_gh_[2],
              fmting_lit$0=_gh_[1],
              match$6=stopper_of_formatting_lit(fmting_lit$0),
              str$1=match$6[2],
              stp$0=match$6[1],
              width$0=width_of_pad_opt(_gj_);
             scan_chars_in_char_set(_gi_,[0,stp$0],width$0,ib);
             var s$2=token_string(ib),str_rest$0=[11,str$1,rest$21];
             return [0,s$2,make_scanf(ib,str_rest$0,readers)]}
           var width=width_of_pad_opt(_gj_);
           scan_chars_in_char_set(_gi_,0,width,ib);
           var s$1=token_string(ib);
           return [0,s$1,make_scanf(ib,_gh_,readers)];
          case 21:
           var
            rest$22=fmt$0[2],
            counter=fmt$0[1],
            count=get_counter(ib,counter);
           return [0,count,make_scanf(ib,rest$22,readers)];
          case 22:
           var rest$23=fmt$0[1],c$1=checked_peek_char(ib);
           return [0,c$1,make_scanf(ib,rest$23,readers)];
          case 23:
           var
            rest$24=fmt$0[2],
            ign=fmt$0[1],
            match$7=param_format_of_ignored_format(ign,rest$24),
            fmt$13=match$7[1],
            match$8=make_scanf(ib,fmt$13,readers);
           if(match$8){var arg_rest=match$8[2];return arg_rest}
           throw [0,Assert_failure,_cm_];
          default:
           return invalid_arg(cst_scanf_bad_conversion_custom_converter)}}
    function kscanf(ib,ef,param)
     {var str=param[2],fmt=param[1];
      function apply(f,args)
       {var f$0=f,args$0=args;
        for(;;)
         {if(args$0)
           {var
             r=args$0[2],
             x=args$0[1],
             f$1=caml_call1(f$0,x),
             f$0=f$1,
             args$0=r;
            continue}
          return f$0}}
      function k(readers,f)
       {reset_token(ib);
        try
         {var _f9_=[0,make_scanf(ib,fmt,readers)],_f8_=_f9_}
        catch(exc)
         {exc = caml_wrap_exception(exc);
          if(exc[1] === Scan_failure)
           var switch$0=0;
          else
           if(exc[1] === Failure)
            var switch$0=0;
           else
            if(exc === End_of_file)
             var switch$0=0;
            else
             {if(exc[1] !== Invalid_argument)throw exc;
              var
               msg=exc[2],
               _f7_=
                invalid_arg
                 (symbol
                   (msg,symbol(cst_in_format,symbol(escaped$1(str),cst$74)))),
               switch$0=1}
          if(! switch$0)var _f7_=[1,exc];
          var _f8_=_f7_}
        if(0 === _f8_[0]){var args=_f8_[1];return apply(f,args)}
        var exc=_f8_[1];
        return caml_call2(ef,ib,exc)}
      return take_format_readers(k,fmt)}
    function bscanf(ib,fmt){return kscanf(ib,scanf_bad_input,fmt)}
    function ksscanf(s,ef,fmt){return kscanf(from_string$1(s),ef,fmt)}
    function sscanf(s,fmt)
     {return kscanf(from_string$1(s),scanf_bad_input,fmt)}
    function scanf(fmt){return kscanf(stdib,scanf_bad_input,fmt)}
    function bscanf_format(ib,format,f)
     {scan_caml_string(max_int,ib);
      var str=token_string(ib);
      try
       {var _f6_=format_of_string_format(str,format),fmt=_f6_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] !== Failure)throw exn;
        var msg=exn[2],fmt=bad_input(msg)}
      return caml_call1(f,fmt)}
    function sscanf_format(s,format,f)
     {return bscanf_format(from_string$1(s),format,f)}
    function format_from_string(s,fmt)
     {var l=caml_ml_string_length(s);
      function _f5_(x){return x}
      var b=create$1(l + 2 | 0);
      add_char(b,34);
      var _f3_=l - 1 | 0,_f2_=0;
      if(! (_f3_ < 0))
       {var i=_f2_;
        for(;;)
         {var c=caml_string_get(s,i);
          if(34 === c)add_char(b,92);
          add_char(b,c);
          var _f4_=i + 1 | 0;
          if(_f3_ !== i){var i=_f4_;continue}
          break}}
      add_char(b,34);
      return sscanf_format(contents(b),fmt,_f5_)}
    function unescaped(s)
     {function _f1_(x){return x}
      return caml_call1(sscanf(symbol(cst$76,symbol(s,cst$75)),_cn_),_f1_)}
    function kfscanf(ic,ef,fmt){return kscanf(memo_from_channel(ic),ef,fmt)}
    function fscanf(ic,fmt)
     {return kscanf(memo_from_channel(ic),scanf_bad_input,fmt)}
    var
     Scanf=
      [0,
       [0,
        stdib,
        from_file,
        from_file_bin,
        close_in,
        from_file,
        from_file_bin,
        from_string$1,
        from_function$0,
        from_channel$0,
        end_of_input,
        beginning_of_input,
        name_of_input,
        stdib],
       Scan_failure,
       bscanf,
       sscanf,
       scanf,
       kscanf,
       ksscanf,
       bscanf_format,
       sscanf_format,
       format_from_string,
       unescaped,
       fscanf,
       kfscanf];
    caml_register_global(682,Scanf,"Scanf");
    var register=caml_register_named_value;
    function register_exception(name,exn)
     {var slot=caml_obj_tag(exn) === 248?exn:exn[1];
      return caml_register_named_value(name,slot)}
    var Callback=[0,register,register_exception];
    caml_register_global(683,Callback,"Callback");
    function copy$6(o){var o$0=o.slice();return caml_set_oo_id(o$0)}
    var params$0=[0,1,1,1,3,16],initial_object_size=2,dummy_item=0;
    function public_method_label(s)
     {var accu=[0,0],_fY_=caml_ml_string_length(s) - 1 | 0,_fX_=0;
      if(! (_fY_ < 0))
       {var i=_fX_;
        for(;;)
         {var _fZ_=caml_string_get(s,i);
          accu[1] = (223 * accu[1] | 0) + _fZ_ | 0;
          var _f0_=i + 1 | 0;
          if(_fY_ !== i){var i=_f0_;continue}
          break}}
      accu[1] = accu[1] & 2147483647;
      var tag=1073741823 < accu[1]?accu[1] + 2147483648 | 0:accu[1];
      return tag}
    var
     compare$6=caml_string_compare,
     Vars=caml_call1(Map[1],[0,compare$6]),
     compare$7=caml_string_compare,
     Meths=caml_call1(Map[1],[0,compare$7]),
     compare$8=caml_int_compare,
     Labs=caml_call1(Map[1],[0,compare$8]),
     dummy_table=[0,0,[0,dummy_item],Meths[1],Labs[1],0,0,Vars[1],0],
     table_count=[0,0],
     dummy_met=caml_obj_block(0,0);
    function fit_size(n){return 2 < n?fit_size((n + 1 | 0) / 2 | 0) * 2 | 0:n}
    function new_table(pub_labels)
     {table_count[1]++;
      var
       len=pub_labels.length - 1,
       methods=caml_make_vect((len * 2 | 0) + 2 | 0,dummy_met);
      caml_check_bound(methods,0)[1] = len;
      var _fR_=((fit_size(len) * 32 | 0) / 8 | 0) - 1 | 0;
      caml_check_bound(methods,1)[2] = _fR_;
      var _fT_=len - 1 | 0,_fS_=0;
      if(! (_fT_ < 0))
       {var i=_fS_;
        for(;;)
         {var
           _fV_=(i * 2 | 0) + 3 | 0,
           _fU_=caml_check_bound(pub_labels,i)[1 + i];
          caml_check_bound(methods,_fV_)[1 + _fV_] = _fU_;
          var _fW_=i + 1 | 0;
          if(_fT_ !== i){var i=_fW_;continue}
          break}}
      return [0,initial_object_size,methods,Meths[1],Labs[1],0,0,Vars[1],0]}
    function resize$1(array,new_size)
     {var old_size=array[2].length - 1,_fP_=old_size < new_size?1:0;
      if(_fP_)
       {var new_buck=caml_make_vect(new_size,dummy_met);
        blit$1(array[2],0,new_buck,0,old_size);
        array[2] = new_buck;
        var _fQ_=0}
      else
       var _fQ_=_fP_;
      return _fQ_}
    var method_count=[0,0],inst_var_count=[0,0];
    function new_method(table)
     {var index=table[2].length - 1;
      resize$1(table,index + 1 | 0);
      return index}
    function get_method_label(table,name)
     {try
       {var _fN_=caml_call2(Meths[27],name,table[3]);return _fN_}
      catch(_fO_)
       {_fO_ = caml_wrap_exception(_fO_);
        if(_fO_ === Not_found)
         {var label=new_method(table);
          table[3] = caml_call3(Meths[4],name,label,table[3]);
          table[4] = caml_call3(Labs[4],label,1,table[4]);
          return label}
        throw _fO_}}
    function get_method_labels(table,names)
     {return map$2(function(_fM_){return get_method_label(table,_fM_)},names)}
    function set_method(table,label,element)
     {method_count[1]++;
      return caml_call2(Labs[27],label,table[4])
              ?(resize$1(table,label + 1 | 0),
                caml_check_bound(table[2],label)[1 + label]
                =
                element,
                0)
              :(table[6] = [0,[0,label,element],table[6]],0)}
    function get_method(table,label)
     {try
       {var _fK_=assoc(label,table[6]);return _fK_}
      catch(_fL_)
       {_fL_ = caml_wrap_exception(_fL_);
        if(_fL_ === Not_found)
         return caml_check_bound(table[2],label)[1 + label];
        throw _fL_}}
    function to_list$0(arr){return arr === 0?0:to_list(arr)}
    function narrow(table,vars,virt_meths,concr_meths)
     {var
       vars$0=to_list$0(vars),
       virt_meths$0=to_list$0(virt_meths),
       concr_meths$0=to_list$0(concr_meths),
       virt_meth_labs=
        map(function(_fJ_){return get_method_label(table,_fJ_)},virt_meths$0),
       concr_meth_labs=
        map(function(_fI_){return get_method_label(table,_fI_)},concr_meths$0);
      table[5]
      =
      [0,
       [0,table[3],table[4],table[6],table[7],virt_meth_labs,vars$0],
       table[5]];
      var _fz_=Vars[1],_fA_=table[7];
      function _fB_(lab,info,tvars)
       {return mem(lab,vars$0)?caml_call3(Vars[4],lab,info,tvars):tvars}
      table[7] = caml_call3(Vars[13],_fB_,_fA_,_fz_);
      var by_name=[0,Meths[1]],by_label=[0,Labs[1]];
      iter2
       (function(met,label)
         {by_name[1] = caml_call3(Meths[4],met,label,by_name[1]);
          var _fE_=by_label[1];
          try
           {var _fG_=caml_call2(Labs[27],label,table[4]),_fF_=_fG_}
          catch(_fH_)
           {_fH_ = caml_wrap_exception(_fH_);
            if(_fH_ !== Not_found)throw _fH_;
            var _fF_=1}
          by_label[1] = caml_call3(Labs[4],label,_fF_,_fE_);
          return 0},
        concr_meths$0,
        concr_meth_labs);
      iter2
       (function(met,label)
         {by_name[1] = caml_call3(Meths[4],met,label,by_name[1]);
          by_label[1] = caml_call3(Labs[4],label,0,by_label[1]);
          return 0},
        virt_meths$0,
        virt_meth_labs);
      table[3] = by_name[1];
      table[4] = by_label[1];
      var _fC_=0,_fD_=table[6];
      table[6]
      =
      fold_right
       (function(met,hm)
         {var lab=met[1];return mem(lab,virt_meth_labs)?hm:[0,met,hm]},
        _fD_,
        _fC_);
      return 0}
    function widen(table)
     {var
       match=hd(table[5]),
       vars=match[6],
       virt_meths=match[5],
       saved_vars=match[4],
       saved_hidden_meths=match[3],
       by_label=match[2],
       by_name=match[1];
      table[5] = tl(table[5]);
      table[7]
      =
      fold_left
       (function(s,v)
         {var _fy_=caml_call2(Vars[27],v,table[7]);
          return caml_call3(Vars[4],v,_fy_,s)},
        saved_vars,
        vars);
      table[3] = by_name;
      table[4] = by_label;
      var _fx_=table[6];
      table[6]
      =
      fold_right
       (function(met,hm)
         {var lab=met[1];return mem(lab,virt_meths)?hm:[0,met,hm]},
        _fx_,
        saved_hidden_meths);
      return 0}
    function new_slot(table)
     {var index=table[1];table[1] = index + 1 | 0;return index}
    function new_variable(table,name)
     {try
       {var _fv_=caml_call2(Vars[27],name,table[7]);return _fv_}
      catch(_fw_)
       {_fw_ = caml_wrap_exception(_fw_);
        if(_fw_ === Not_found)
         {var index=new_slot(table);
          if(caml_string_notequal(name,cst$77))
           table[7] = caml_call3(Vars[4],name,index,table[7]);
          return index}
        throw _fw_}}
    function to_array(arr){return caml_equal(arr,0)?[0]:arr}
    function new_methods_variables(table,meths,vals)
     {var
       meths$0=to_array(meths),
       nmeths=meths$0.length - 1,
       nvals=vals.length - 1,
       res=caml_make_vect(nmeths + nvals | 0,0),
       _fn_=nmeths - 1 | 0,
       _fm_=0;
      if(! (_fn_ < 0))
       {var i$0=_fm_;
        for(;;)
         {var
           _ft_=
            get_method_label(table,caml_check_bound(meths$0,i$0)[1 + i$0]);
          caml_check_bound(res,i$0)[1 + i$0] = _ft_;
          var _fu_=i$0 + 1 | 0;
          if(_fn_ !== i$0){var i$0=_fu_;continue}
          break}}
      var _fp_=nvals - 1 | 0,_fo_=0;
      if(! (_fp_ < 0))
       {var i=_fo_;
        for(;;)
         {var
           _fr_=i + nmeths | 0,
           _fq_=new_variable(table,caml_check_bound(vals,i)[1 + i]);
          caml_check_bound(res,_fr_)[1 + _fr_] = _fq_;
          var _fs_=i + 1 | 0;
          if(_fp_ !== i){var i=_fs_;continue}
          break}}
      return res}
    function get_variable(table,name)
     {try
       {var _fk_=caml_call2(Vars[27],name,table[7]);return _fk_}
      catch(_fl_)
       {_fl_ = caml_wrap_exception(_fl_);
        if(_fl_ === Not_found)throw [0,Assert_failure,_co_];
        throw _fl_}}
    function get_variables(table,names)
     {return map$2(function(_fj_){return get_variable(table,_fj_)},names)}
    function add_initializer(table,f){table[8] = [0,f,table[8]];return 0}
    function create_table(public_methods)
     {if(public_methods === 0)return new_table([0]);
      var
       tags=map$2(public_method_label,public_methods),
       table=new_table(tags);
      iteri$2
       (function(i,met)
         {var lab=(i * 2 | 0) + 2 | 0;
          table[3] = caml_call3(Meths[4],met,lab,table[3]);
          table[4] = caml_call3(Labs[4],lab,1,table[4]);
          return 0},
        public_methods);
      return table}
    function init_class(table)
     {inst_var_count[1] = (inst_var_count[1] + table[1] | 0) - 1 | 0;
      table[8] = rev(table[8]);
      return resize$1
              (table,
               3 + ((caml_check_bound(table[2],1)[2] * 16 | 0) / 32 | 0) | 0)}
    function inherits(cla,vals,virt_meths,concr_meths,param,top)
     {var env=param[4],super$0=param[2];
      narrow(cla,vals,virt_meths,concr_meths);
      var init=top?caml_call2(super$0,cla,env):caml_call1(super$0,cla);
      widen(cla);
      var
       _fe_=0,
       _ff_=to_array(concr_meths),
       _fg_=
        [0,
         map$2
          (function(nm){return get_method(cla,get_method_label(cla,nm))},_ff_),
         _fe_],
       _fh_=to_array(vals);
      return caml_array_concat
              ([0,
                [0,init],
                [0,
                 map$2(function(_fi_){return get_variable(cla,_fi_)},_fh_),
                 _fg_]])}
    function make_class(pub_meths,class_init)
     {var table=create_table(pub_meths),env_init=caml_call1(class_init,table);
      init_class(table);
      return [0,caml_call1(env_init,0),class_init,env_init,0]}
    function make_class_store(pub_meths,class_init,init_table)
     {var table=create_table(pub_meths),env_init=caml_call1(class_init,table);
      init_class(table);
      init_table[2] = class_init;
      init_table[1] = env_init;
      return 0}
    function dummy_class(loc)
     {function undef(param){throw [0,Undefined_recursive_module,loc]}
      return [0,undef,undef,undef,0]}
    function create_object(table)
     {var obj=caml_obj_block(248,table[1]);
      obj[1] = table[2];
      return caml_set_oo_id(obj)}
    function create_object_opt(obj_0,table)
     {if(obj_0)return obj_0;
      var obj=caml_obj_block(248,table[1]);
      obj[1] = table[2];
      return caml_set_oo_id(obj)}
    function iter_f(obj,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],f=param$0[1];
          caml_call1(f,obj);
          var param$0=l;
          continue}
        return 0}}
    function run_initializers(obj,table)
     {var inits=table[8],_fd_=0 !== inits?1:0;
      return _fd_?iter_f(obj,inits):_fd_}
    function run_initializers_opt(obj_0,obj,table)
     {if(obj_0)return obj;
      var inits=table[8];
      if(0 !== inits)iter_f(obj,inits);
      return obj}
    function create_object_and_run_initializers(obj_0,table)
     {if(obj_0)return obj_0;
      var obj=create_object(table);
      run_initializers(obj,table);
      return obj}
    function get_data$0(param)
     {if(param)return param[2];throw [0,Assert_failure,_cs_]}
    function build_path(n,keys,tables)
     {var res=[0,0,0,0],r=[0,res],_e$_=0;
      if(! (n < 0))
       {var i=_e$_;
        for(;;)
         {var _fb_=r[1];
          r[1] = [0,caml_check_bound(keys,i)[1 + i],_fb_,0];
          var _fc_=i + 1 | 0;
          if(n !== i){var i=_fc_;continue}
          break}}
      var _fa_=r[1];
      if(tables){tables[2] = _fa_;return res}
      throw [0,Assert_failure,_cp_]}
    function lookup_tables(root,keys)
     {var tables$2=get_data$0(root);
      if(tables$2)
       {var i$1=keys.length - 1 - 1 | 0,i=i$1,tables=tables$2;
        a:
        for(;;)
         {if(0 <= i)
           {var key=caml_check_bound(keys,i)[1 + i],tables$0=tables;
            for(;;)
             {if(tables$0)
               {if(tables$0[1] === key)
                 {var tables$1=get_data$0(tables$0);
                  if(tables$1)
                   {var i$0=i - 1 | 0,i=i$0,tables=tables$1;continue a}
                  throw [0,Assert_failure,_cu_]}
                if(tables$0)
                 {var _e__=tables$0[3];
                  if(_e__){var tables$0=_e__;continue}
                  var v=[0,key,0,0];
                  if(tables$0)
                   {tables$0[3] = v;return build_path(i - 1 | 0,keys,v)}
                  throw [0,Assert_failure,_cq_]}
                throw [0,Assert_failure,_ct_]}
              throw [0,Assert_failure,_cr_]}}
          return tables}}
      return build_path(keys.length - 1 - 1 | 0,keys,root)}
    function new_cache(table)
     {var n=new_method(table);
      if(0 === (n % 2 | 0))
       var switch$0=0;
      else
       if((2 + ((caml_check_bound(table[2],1)[2] * 16 | 0) / 32 | 0) | 0) < n)
        var switch$0=0;
       else
        var n$0=new_method(table),switch$0=1;
      if(! switch$0)var n$0=n;
      caml_check_bound(table[2],n$0)[1 + n$0] = 0;
      return n$0}
    function set_methods(table,methods)
     {var len=methods.length - 1,i=[0,0];
      for(;;)
       {if(i[1] < len)
         {var
           _e4_=i[1],
           label=caml_check_bound(methods,_e4_)[1 + _e4_],
           next=
            function(param)
             {i[1]++;
              var _e9_=i[1];
              return caml_check_bound(methods,_e9_)[1 + _e9_]},
           clo=next(0);
          if(typeof clo === "number")
           switch(clo)
            {case 0:
              var
               x=next(0),
               clo$0=function(x){return function(obj){return x}}(x);
              break;
             case 1:
              var
               n=next(0),
               clo$0=function(n){return function(obj){return obj[1 + n]}}(n);
              break;
             case 2:
              var
               e=next(0),
               n$0=next(0),
               clo$0=
                function(e,n){return function(obj){return obj[1 + e][1 + n]}}
                 (e,n$0);
              break;
             case 3:
              var
               n$1=next(0),
               clo$0=
                function(n)
                  {return function(obj){return caml_call1(obj[1][1 + n],obj)}}
                 (n$1);
              break;
             case 4:
              var
               n$2=next(0),
               clo$0=
                function(n){return function(obj,x){obj[1 + n] = x;return 0}}
                 (n$2);
              break;
             case 5:
              var
               f=next(0),
               x$0=next(0),
               clo$0=
                function(f,x){return function(obj){return caml_call1(f,x)}}
                 (f,x$0);
              break;
             case 6:
              var
               f$0=next(0),
               n$3=next(0),
               clo$0=
                function(f,n)
                  {return function(obj){return caml_call1(f,obj[1 + n])}}
                 (f$0,n$3);
              break;
             case 7:
              var
               f$1=next(0),
               e$0=next(0),
               n$4=next(0),
               clo$0=
                function(f,e,n)
                  {return function(obj)
                    {return caml_call1(f,obj[1 + e][1 + n])}}
                 (f$1,e$0,n$4);
              break;
             case 8:
              var
               f$2=next(0),
               n$5=next(0),
               clo$0=
                function(f,n)
                  {return function(obj)
                    {return caml_call1(f,caml_call1(obj[1][1 + n],obj))}}
                 (f$2,n$5);
              break;
             case 9:
              var
               f$3=next(0),
               x$1=next(0),
               y=next(0),
               clo$0=
                function(f,x,y)
                  {return function(obj){return caml_call2(f,x,y)}}
                 (f$3,x$1,y);
              break;
             case 10:
              var
               f$4=next(0),
               x$2=next(0),
               n$6=next(0),
               clo$0=
                function(f,x,n)
                  {return function(obj){return caml_call2(f,x,obj[1 + n])}}
                 (f$4,x$2,n$6);
              break;
             case 11:
              var
               f$5=next(0),
               x$3=next(0),
               e$1=next(0),
               n$7=next(0),
               clo$0=
                function(f,x,e,n)
                  {return function(obj)
                    {return caml_call2(f,x,obj[1 + e][1 + n])}}
                 (f$5,x$3,e$1,n$7);
              break;
             case 12:
              var
               f$6=next(0),
               x$4=next(0),
               n$8=next(0),
               clo$0=
                function(f,x,n)
                  {return function(obj)
                    {return caml_call2(f,x,caml_call1(obj[1][1 + n],obj))}}
                 (f$6,x$4,n$8);
              break;
             case 13:
              var
               f$7=next(0),
               n$9=next(0),
               x$5=next(0),
               clo$0=
                function(f,n,x)
                  {return function(obj){return caml_call2(f,obj[1 + n],x)}}
                 (f$7,n$9,x$5);
              break;
             case 14:
              var
               f$8=next(0),
               e$2=next(0),
               n$10=next(0),
               x$6=next(0),
               clo$0=
                function(f,e,n,x)
                  {return function(obj)
                    {return caml_call2(f,obj[1 + e][1 + n],x)}}
                 (f$8,e$2,n$10,x$6);
              break;
             case 15:
              var
               f$9=next(0),
               n$11=next(0),
               x$7=next(0),
               clo$0=
                function(f,n,x)
                  {return function(obj)
                    {return caml_call2(f,caml_call1(obj[1][1 + n],obj),x)}}
                 (f$9,n$11,x$7);
              break;
             case 16:
              var
               n$12=next(0),
               x$8=next(0),
               clo$0=
                function(n,x)
                  {return function(obj)
                    {return caml_call2(obj[1][1 + n],obj,x)}}
                 (n$12,x$8);
              break;
             case 17:
              var
               n$13=next(0),
               m=next(0),
               clo$0=
                function(n,m)
                  {return function(obj)
                    {return caml_call2(obj[1][1 + n],obj,obj[1 + m])}}
                 (n$13,m);
              break;
             case 18:
              var
               n$14=next(0),
               e$3=next(0),
               m$0=next(0),
               clo$0=
                function(n,e,m)
                  {return function(obj)
                    {return caml_call2(obj[1][1 + n],obj,obj[1 + e][1 + m])}}
                 (n$14,e$3,m$0);
              break;
             case 19:
              var
               n$15=next(0),
               m$1=next(0),
               clo$0=
                function(n,m)
                  {return function(obj)
                    {var _e7_=caml_call1(obj[1][1 + m],obj);
                     return caml_call2(obj[1][1 + n],obj,_e7_)}}
                 (n$15,m$1);
              break;
             case 20:
              var m$2=next(0),x$9=next(0);
              new_cache(table);
              var
               clo$0=
                function(m,x)
                  {return function(obj)
                    {return caml_call1(caml_get_public_method(x,m,0),x)}}
                 (m$2,x$9);
              break;
             case 21:
              var m$3=next(0),n$16=next(0);
              new_cache(table);
              var
               clo$0=
                function(m,n)
                  {return function(obj)
                    {var _e6_=obj[1 + n];
                     return caml_call1(caml_get_public_method(_e6_,m,0),_e6_)}}
                 (m$3,n$16);
              break;
             case 22:
              var m$4=next(0),e$4=next(0),n$17=next(0);
              new_cache(table);
              var
               clo$0=
                function(m,e,n)
                  {return function(obj)
                    {var _e5_=obj[1 + e][1 + n];
                     return caml_call1(caml_get_public_method(_e5_,m,0),_e5_)}}
                 (m$4,e$4,n$17);
              break;
             default:
              var m$5=next(0),n$18=next(0);
              new_cache(table);
              var
               clo$0=
                function(m,n)
                  {return function(obj)
                    {var _e8_=caml_call1(obj[1][1 + n],obj);
                     return caml_call1(caml_get_public_method(_e8_,m,0),_e8_)}}
                 (m$5,n$18)}
          else
           var clo$0=clo;
          set_method(table,label,clo$0);
          i[1]++;
          continue}
        return 0}}
    function stats$0(param)
     {return [0,table_count[1],method_count[1],inst_var_count[1]]}
    var
     CamlinternalOO=
      [0,
       public_method_label,
       new_method,
       new_variable,
       new_methods_variables,
       get_variable,
       get_variables,
       get_method_label,
       get_method_labels,
       get_method,
       set_method,
       set_methods,
       narrow,
       widen,
       add_initializer,
       dummy_table,
       create_table,
       init_class,
       inherits,
       make_class,
       make_class_store,
       dummy_class,
       copy$6,
       create_object,
       create_object_opt,
       run_initializers,
       run_initializers_opt,
       create_object_and_run_initializers,
       lookup_tables,
       params$0,
       stats$0];
    caml_register_global(684,CamlinternalOO,"CamlinternalOO");
    var Oo=[0,copy$6,public_method_label,public_method_label];
    caml_register_global(685,Oo,"Oo");
    var
     update_mod=runtime.caml_CamlinternalMod_update_mod,
     init_mod=runtime.caml_CamlinternalMod_init_mod,
     CamlinternalMod=[0,init_mod,update_mod];
    caml_register_global(686,CamlinternalMod,"CamlinternalMod");
    var
     initial_buffer=caml_create_bytes(32),
     buffer=[0,initial_buffer],
     bufpos=[0,0];
    function reset_buffer(param)
     {buffer[1] = initial_buffer;bufpos[1] = 0;return 0}
    function store(c)
     {if(caml_ml_bytes_length(buffer[1]) <= bufpos[1])
       {var newbuffer=caml_create_bytes(2 * bufpos[1] | 0);
        blit(buffer[1],0,newbuffer,0,bufpos[1]);
        buffer[1] = newbuffer}
      caml_bytes_set(buffer[1],bufpos[1],c);
      bufpos[1]++;
      return 0}
    function get_string(param)
     {var s=sub_string(buffer[1],0,bufpos[1]);
      buffer[1] = initial_buffer;
      return s}
    function make_lexer(keywords)
     {var kwd_table=caml_call2(Hashtbl[1],0,17);
      iter
       (function(s){return caml_call3(Hashtbl[5],kwd_table,s,[0,s])},keywords);
      function ident_or_keyword(id)
       {try
         {var _e2_=caml_call2(Hashtbl[6],kwd_table,id);return _e2_}
        catch(_e3_)
         {_e3_ = caml_wrap_exception(_e3_);
          if(_e3_ === Not_found)return [1,id];
          throw _e3_}}
      function keyword_or_error(c)
       {var s=make$0(1,c);
        try
         {var _e0_=caml_call2(Hashtbl[6],kwd_table,s);return _e0_}
        catch(_e1_)
         {_e1_ = caml_wrap_exception(_e1_);
          if(_e1_ === Not_found)
           throw [0,Error,symbol(cst_Illegal_character,s)];
          throw _e1_}}
      function end_exponent_part(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _eZ_=match[1],switcher=_eZ_ - 48 | 0;
            if(! (9 < switcher >>> 0)){junk(strm);store(_eZ_);continue}}
          return [0,[3,caml_float_of_string(get_string(0))]]}}
      function exponent_part(strm)
       {var match=peek$0(strm);
        if(match)
         {var _eY_=match[1],switch$0=43 === _eY_?0:45 === _eY_?0:1;
          if(! switch$0)
           {junk(strm);store(_eY_);return end_exponent_part(strm)}}
        return end_exponent_part(strm)}
      function number(s)
       {for(;;)
         {var match=peek$0(s);
          if(match)
           {var _eV_=match[1];
            if(58 <= _eV_)
             {var switch$0=69 === _eV_?0:101 === _eV_?0:1;
              if(! switch$0){junk(s);store(69);return exponent_part(s)}}
            else
             {if(46 === _eV_)
               {junk(s);
                store(46);
                for(;;)
                 {var match$0=peek$0(s);
                  if(match$0)
                   {var _eW_=match$0[1],_eX_=_eW_ - 69 | 0;
                    if(32 < _eX_ >>> 0)
                     {var switcher=_eX_ + 21 | 0;
                      if(! (9 < switcher >>> 0)){junk(s);store(_eW_);continue}}
                    else
                     {var switcher$0=_eX_ - 1 | 0;
                      if(30 < switcher$0 >>> 0)
                       {junk(s);store(69);return exponent_part(s)}}}
                  return [0,[3,caml_float_of_string(get_string(0))]]}}
              if(48 <= _eV_){junk(s);store(_eV_);continue}}}
          return [0,[2,caml_int_of_string(get_string(0))]]}}
      function ident2(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _eT_=match[1];
            if(94 <= _eT_)
             var
              _eU_=_eT_ - 95 | 0,
              switch$0=30 < _eU_ >>> 0?32 <= _eU_?1:0:29 === _eU_?0:1;
            else
             if(65 <= _eT_)
              var switch$0=92 === _eT_?0:1;
             else
              if(33 <= _eT_)
               switch(_eT_ - 33 | 0)
                {case 0:
                 case 2:
                 case 3:
                 case 4:
                 case 5:
                 case 9:
                 case 10:
                 case 12:
                 case 14:
                 case 25:
                 case 27:
                 case 28:
                 case 29:
                 case 30:
                 case 31:var switch$0=0;break;
                 default:var switch$0=1}
              else
               var switch$0=1;
            if(! switch$0){junk(strm);store(_eT_);continue}}
          return [0,ident_or_keyword(get_string(0))]}}
      function neg_number(s)
       {var match=peek$0(s);
        if(match)
         {var _eS_=match[1],switcher=_eS_ - 48 | 0;
          if(! (9 < switcher >>> 0))
           {junk(s);reset_buffer(0);store(45);store(_eS_);return number(s)}}
        reset_buffer(0);
        store(45);
        return ident2(s)}
      function ident(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _eQ_=match[1];
            if(91 <= _eQ_)
             var
              _eR_=_eQ_ - 95 | 0,
              switch$0=27 < _eR_ >>> 0?97 <= _eR_?0:1:1 === _eR_?1:0;
            else
             var
              switch$0=
               48 <= _eQ_?6 < (_eQ_ - 58 | 0) >>> 0?0:1:39 === _eQ_?0:1;
            if(! switch$0){junk(strm);store(_eQ_);continue}}
          return [0,ident_or_keyword(get_string(0))]}}
      function next_token$0(counter,strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _eG_=match[1];
            if(124 <= _eG_)
             var switch$0=127 <= _eG_?192 <= _eG_?1:0:125 === _eG_?0:2;
            else
             {var _eH_=_eG_ - 65 | 0;
              if(57 < _eH_ >>> 0)
               if(58 <= _eH_)
                var switch$0=0;
               else
                {var switcher=_eH_ + 65 | 0;
                 switch(switcher)
                  {case 34:
                    junk(strm);
                    reset_buffer(0);
                    for(;;)
                     {var match$1=peek$0(strm);
                      if(match$1)
                       {var _eJ_=match$1[1];
                        if(34 === _eJ_){junk(strm);return [0,[4,get_string(0)]]}
                        if(92 === _eJ_)
                         {junk(strm);
                          try
                           {var c$0=escape(strm)}
                          catch(_eP_)
                           {_eP_ = caml_wrap_exception(_eP_);
                            if(_eP_ === Failure$0)throw [0,Error,cst$80];
                            throw _eP_;
                            var _eM_=_eP_}
                          store(c$0);
                          continue}
                        junk(strm);
                        store(_eJ_);
                        continue}
                      throw Failure$0}
                   case 39:
                    junk(strm);
                    try
                     {var match$2=peek$0(strm);
                      if(! match$2)throw Failure$0;
                      var _eK_=match$2[1];
                      if(92 === _eK_)
                       {junk(strm);
                        try
                         {var _eL_=escape(strm)}
                        catch(_eO_)
                         {_eO_ = caml_wrap_exception(_eO_);
                          if(_eO_ === Failure$0)throw [0,Error,cst$81];
                          throw _eO_}
                        var c=_eL_}
                      else
                       {junk(strm);var c=_eK_}}
                    catch(_eN_)
                     {_eN_ = caml_wrap_exception(_eN_);
                      if(_eN_ === Failure$0)throw [0,Error,cst$78];
                      throw _eN_}
                    var match$0=peek$0(strm);
                    if(match$0)
                     if(39 === match$0[1]){junk(strm);return [0,[5,c]]}
                    throw [0,Error,cst$79];
                   case 40:
                    junk(strm);
                    if(counter < 50)
                     {var counter$0=counter + 1 | 0;
                      return maybe_comment(counter$0,strm)}
                    return caml_trampoline_return(maybe_comment,[0,strm]);
                   case 45:junk(strm);return neg_number(strm);
                   case 9:
                   case 10:
                   case 12:
                   case 13:
                   case 26:
                   case 32:junk(strm);continue;
                   case 48:
                   case 49:
                   case 50:
                   case 51:
                   case 52:
                   case 53:
                   case 54:
                   case 55:
                   case 56:
                   case 57:
                    junk(strm);reset_buffer(0);store(_eG_);return number(strm);
                   case 33:
                   case 35:
                   case 36:
                   case 37:
                   case 38:
                   case 42:
                   case 43:
                   case 47:
                   case 58:
                   case 60:
                   case 61:
                   case 62:
                   case 63:
                   case 64:var switch$0=2;break;
                   default:var switch$0=0}}
              else
               {var _eI_=_eH_ - 26 | 0;
                if(5 < _eI_ >>> 0)
                 var switch$0=1;
                else
                 switch(_eI_)
                  {case 4:var switch$0=1;break;
                   case 1:
                   case 3:var switch$0=2;break;
                   default:var switch$0=0}}}
            switch(switch$0)
             {case 0:junk(strm);return [0,keyword_or_error(_eG_)];
              case 1:
               junk(strm);reset_buffer(0);store(_eG_);return ident(strm);
              default:
               junk(strm);reset_buffer(0);store(_eG_);return ident2(strm)}}
          return 0}}
      function maybe_comment(counter,strm)
       {var match=peek$0(strm);
        if(match)
         if(42 === match[1])
          {junk(strm);
           comment(strm);
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return next_token$0(counter$0,strm)}
           return caml_trampoline_return(next_token$0,[0,strm])}
        return [0,keyword_or_error(40)]}
      function next_token(strm){return caml_trampoline(next_token$0(0,strm))}
      function escape(strm)
       {var match=peek$0(strm);
        if(match)
         {var _eD_=match[1];
          if(58 <= _eD_)
           {var switcher=_eD_ - 110 | 0;
            if(! (6 < switcher >>> 0))
             switch(switcher)
              {case 0:junk(strm);return 10;
               case 4:junk(strm);return 13;
               case 6:junk(strm);return 9
               }}
          else
           if(48 <= _eD_)
            {junk(strm);
             var match$0=peek$0(strm);
             if(match$0)
              {var _eE_=match$0[1],switcher$0=_eE_ - 48 | 0;
               if(! (9 < switcher$0 >>> 0))
                {junk(strm);
                 var match$1=peek$0(strm);
                 if(match$1)
                  {var _eF_=match$1[1],switcher$1=_eF_ - 48 | 0;
                   if(! (9 < switcher$1 >>> 0))
                    {junk(strm);
                     return chr
                             ((((_eD_ - 48 | 0) * 100 | 0)
                               +
                               ((_eE_ - 48 | 0) * 10 | 0)
                               |
                               0)
                              +
                              (_eF_ - 48 | 0)
                              |
                              0)}}
                 throw [0,Error,cst$83]}}
             throw [0,Error,cst$82]}
          junk(strm);
          return _eD_}
        throw Failure$0}
      function comment(strm)
       {a:
        for(;;)
         {var match=peek$0(strm);
          if(match)
           {var switcher=match[1] - 40 | 0;
            if(! (2 < switcher >>> 0))
             switch(switcher)
              {case 0:
                junk(strm);
                var match$0=peek$0(strm);
                if(match$0)
                 {if(42 === match$0[1]){junk(strm);comment(strm);continue}
                  junk(strm);
                  continue}
                throw Failure$0;
               case 1:break;
               default:
                junk(strm);
                for(;;)
                 {var match$1=peek$0(strm);
                  if(match$1)
                   {var _eC_=match$1[1];
                    if(41 === _eC_){junk(strm);return 0}
                    if(42 === _eC_){junk(strm);continue}
                    junk(strm);
                    continue a}
                  throw Failure$0}}
            junk(strm);
            continue}
          throw Failure$0}}
      return function(input)
       {return from(function(count){return next_token(input)})}}
    var Genlex=[0,make_lexer];
    caml_register_global(687,Genlex,"Genlex");
    function MakeSeeded$0(H)
     {var prng=[246,function(_eB_){return caml_call1(_b2_[2],0)}];
      function create(opt,initial_size)
       {if(opt)
         var sth=opt[1],random=sth;
        else
         var random=caml_call1(Hashtbl[17],0);
        var x=16;
        for(;;)
         {if(! (initial_size <= x))
           if(! (max_array_length < (x * 2 | 0)))
            {var x$0=x * 2 | 0,x=x$0;continue}
          if(random)
           var
            _ez_=caml_obj_tag(prng),
            _eA_=250 === _ez_?prng[1]:246 === _ez_?force_lazy_block(prng):prng,
            seed=caml_call1(_b2_[4],_eA_);
          else
           var seed=0;
          return [0,0,caml_make_vect(x,0),seed,x]}}
      function clear(h)
       {h[1] = 0;
        var len=h[2].length - 1,_ex_=len - 1 | 0,_ew_=0;
        if(! (_ex_ < 0))
         {var i=_ew_;
          for(;;)
           {caml_check_bound(h[2],i)[1 + i] = 0;
            var _ey_=i + 1 | 0;
            if(_ex_ !== i){var i=_ey_;continue}
            break}}
        return 0}
      function reset(h)
       {var len=h[2].length - 1;
        return len === h[4]
                ?clear(h)
                :(h[1] = 0,h[2] = caml_make_vect(h[4],0),0)}
      function copy(init)
       {var _et_=init[4],_eu_=init[3],_ev_=copy$1(init[2]);
        return [0,init[1],_ev_,_eu_,_et_]}
      function key_index(h,hkey){return hkey & (h[2].length - 1 - 1 | 0)}
      function clean(h)
       {function do_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var rest=param$0[3],c=param$0[2],hkey=param$0[1];
              if(caml_call1(H[7],c))return [0,hkey,c,do_bucket(rest)];
              h[1] = h[1] - 1 | 0;
              var param$0=rest;
              continue}
            return 0}}
        var d=h[2],_eq_=d.length - 1 - 1 | 0,_ep_=0;
        if(! (_eq_ < 0))
         {var i=_ep_;
          for(;;)
           {var _er_=do_bucket(caml_check_bound(d,i)[1 + i]);
            caml_check_bound(d,i)[1 + i] = _er_;
            var _es_=i + 1 | 0;
            if(_eq_ !== i){var i=_es_;continue}
            break}}
        return 0}
      function resize(h)
       {var odata=h[2],osize=odata.length - 1,nsize=osize * 2 | 0;
        clean(h);
        var
         _ej_=nsize < max_array_length?1:0,
         _ek_=_ej_?(osize >>> 1 | 0) <= h[1]?1:0:_ej_;
        if(_ek_)
         {var ndata=caml_make_vect(nsize,0);
          h[2] = ndata;
          var
           insert_bucket=
            function(param)
             {if(param)
               {var rest=param[3],data=param[2],hkey=param[1];
                insert_bucket(rest);
                var nidx=key_index(h,hkey);
                ndata[1 + nidx]
                =
                [0,hkey,data,caml_check_bound(ndata,nidx)[1 + nidx]];
                return 0}
              return 0},
           _em_=osize - 1 | 0,
           _el_=0;
          if(! (_em_ < 0))
           {var i=_el_;
            for(;;)
             {insert_bucket(caml_check_bound(odata,i)[1 + i]);
              var _eo_=i + 1 | 0;
              if(_em_ !== i){var i=_eo_;continue}
              break}}
          var _en_=0}
        else
         var _en_=_ek_;
        return _en_}
      function add(h,key,info)
       {var
         hkey=caml_call2(H[2],h[3],key),
         i=key_index(h,hkey),
         container=caml_call2(H[1],key,info),
         bucket=[0,hkey,container,caml_check_bound(h[2],i)[1 + i]];
        caml_check_bound(h[2],i)[1 + i] = bucket;
        h[1] = h[1] + 1 | 0;
        var _ei_=h[2].length - 1 << 1 < h[1]?1:0;
        return _ei_?resize(h):_ei_}
      function remove(h,key)
       {var hkey=caml_call2(H[2],h[3],key);
        function remove_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var next=param$0[3],c=param$0[2],hk=param$0[1];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                switch(match)
                 {case 0:h[1] = h[1] - 1 | 0;return next;
                  case 1:return [0,hk,c,remove_bucket(next)];
                  default:h[1] = h[1] - 1 | 0;var param$0=next;continue}}
              return [0,hk,c,remove_bucket(next)]}
            return 0}}
        var
         i=key_index(h,hkey),
         _eh_=remove_bucket(caml_check_bound(h[2],i)[1 + i]);
        caml_check_bound(h[2],i)[1 + i] = _eh_;
        return 0}
      function find(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _eg_=key_index(h,hkey),
         param$0=caml_check_bound(h[2],_eg_)[1 + _eg_],
         param=param$0;
        for(;;)
         {if(param)
           {var rest=param[3],c=param[2],hk=param[1];
            if(hkey === hk)
             {var match=caml_call2(H[3],c,key);
              switch(match)
               {case 0:
                 var match$0=caml_call1(H[4],c);
                 if(match$0){var d=match$0[1];return d}
                 var param=rest;
                 continue;
                case 1:var param=rest;continue;
                default:var param=rest;continue}}
            var param=rest;
            continue}
          throw Not_found}}
      function find_opt(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _ef_=key_index(h,hkey),
         param$0=caml_check_bound(h[2],_ef_)[1 + _ef_],
         param=param$0;
        for(;;)
         {if(param)
           {var rest=param[3],c=param[2],hk=param[1];
            if(hkey === hk)
             {var match=caml_call2(H[3],c,key);
              switch(match)
               {case 0:
                 var d=caml_call1(H[4],c);
                 if(d)return d;
                 var param=rest;
                 continue;
                case 1:var param=rest;continue;
                default:var param=rest;continue}}
            var param=rest;
            continue}
          return 0}}
      function find_all(h,key)
       {var hkey=caml_call2(H[2],h[3],key);
        function find_in_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var rest=param$0[3],c=param$0[2],hk=param$0[1];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                switch(match)
                 {case 0:
                   var match$0=caml_call1(H[4],c);
                   if(match$0)
                    {var d=match$0[1];return [0,d,find_in_bucket(rest)]}
                   var param$0=rest;
                   continue;
                  case 1:var param$0=rest;continue;
                  default:var param$0=rest;continue}}
              var param$0=rest;
              continue}
            return 0}}
        var _ee_=key_index(h,hkey);
        return find_in_bucket(caml_check_bound(h[2],_ee_)[1 + _ee_])}
      function replace(h,key,info)
       {var hkey=caml_call2(H[2],h[3],key);
        function replace_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var next=param$0[3],c=param$0[2],hk=param$0[1];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                if(0 === match)return caml_call3(H[6],c,key,info);
                var param$0=next;
                continue}
              var param$0=next;
              continue}
            throw Not_found}}
        var i=key_index(h,hkey),l=caml_check_bound(h[2],i)[1 + i];
        try
         {var _ec_=replace_bucket(l);return _ec_}
        catch(_ed_)
         {_ed_ = caml_wrap_exception(_ed_);
          if(_ed_ === Not_found)
           {var container=caml_call2(H[1],key,info);
            caml_check_bound(h[2],i)[1 + i] = [0,hkey,container,l];
            h[1] = h[1] + 1 | 0;
            var _eb_=h[2].length - 1 << 1 < h[1]?1:0;
            return _eb_?resize(h):_eb_}
          throw _ed_}}
      function mem(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _ea_=key_index(h,hkey),
         param$0=caml_check_bound(h[2],_ea_)[1 + _ea_],
         param=param$0;
        for(;;)
         {if(param)
           {var rest=param[3],c=param[2],hk=param[1];
            if(hk === hkey)
             {var match=caml_call2(H[3],c,key);
              if(0 === match)return 1;
              var param=rest;
              continue}
            var param=rest;
            continue}
          return 0}}
      function iter(f,h)
       {var d$0=h[2],_d__=d$0.length - 1 - 1 | 0,_d9_=0;
        if(! (_d__ < 0))
         {var i=_d9_;
          a:
          for(;;)
           {var param$0=caml_check_bound(d$0,i)[1 + i],param=param$0;
            for(;;)
             {if(param)
               {var
                 rest=param[3],
                 c=param[2],
                 match=caml_call1(H[5],c),
                 match$0=caml_call1(H[4],c);
                if(match)
                 if(match$0)
                  {var d=match$0[1],k=match[1];
                   caml_call2(f,k,d);
                   var switch$0=1}
                 else
                  var switch$0=0;
                else
                 var switch$0=0;
                var param=rest;
                continue}
              var _d$_=i + 1 | 0;
              if(_d__ !== i){var i=_d$_;continue a}
              break}
            break}}
        return 0}
      function fold(f,h,init)
       {var d$0=h[2],accu$1=[0,init],_d6_=d$0.length - 1 - 1 | 0,_d5_=0;
        if(! (_d6_ < 0))
         {var i=_d5_;
          a:
          for(;;)
           {var
             _d7_=accu$1[1],
             b$0=caml_check_bound(d$0,i)[1 + i],
             b=b$0,
             accu=_d7_;
            for(;;)
             {if(b)
               {var
                 rest=b[3],
                 c=b[2],
                 match=caml_call1(H[5],c),
                 match$0=caml_call1(H[4],c);
                if(match)
                 if(match$0)
                  var
                   d=match$0[1],
                   k=match[1],
                   accu$0=caml_call3(f,k,d,accu),
                   switch$0=1;
                 else
                  var switch$0=0;
                else
                 var switch$0=0;
                if(! switch$0)var accu$0=accu;
                var b=rest,accu=accu$0;
                continue}
              accu$1[1] = accu;
              var _d8_=i + 1 | 0;
              if(_d6_ !== i){var i=_d8_;continue a}
              break}
            break}}
        return accu$1[1]}
      function filter_map_inplace(f,h)
       {function do_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var
               rest=param$0[3],
               c=param$0[2],
               hk=param$0[1],
               match=caml_call1(H[5],c),
               match$0=caml_call1(H[4],c);
              if(match)
               if(match$0)
                {var d=match$0[1],k=match[1],match$1=caml_call2(f,k,d);
                 if(match$1)
                  {var new_d=match$1[1];
                   caml_call3(H[6],c,k,new_d);
                   return [0,hk,c,do_bucket(rest)]}
                 var param$0=rest;
                 continue}
              var param$0=rest;
              continue}
            return 0}}
        var d=h[2],_d2_=d.length - 1 - 1 | 0,_d1_=0;
        if(! (_d2_ < 0))
         {var i=_d1_;
          for(;;)
           {var _d3_=do_bucket(caml_check_bound(d,i)[1 + i]);
            caml_check_bound(d,i)[1 + i] = _d3_;
            var _d4_=i + 1 | 0;
            if(_d2_ !== i){var i=_d4_;continue}
            break}}
        return 0}
      function length(h){return h[1]}
      function bucket_length(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {if(param$0)
           {var
             param$1=param$0[3],
             accu$1=accu$0 + 1 | 0,
             accu$0=accu$1,
             param$0=param$1;
            continue}
          return accu$0}}
      function stats(h)
       {var
         _dY_=h[2],
         _dZ_=0,
         mbl=
          fold_left$0
           (function(m,b){return max(m,bucket_length(0,b))},_dZ_,_dY_),
         histo=caml_make_vect(mbl + 1 | 0,0),
         _d0_=h[2];
        iter$2
         (function(b)
           {var l=bucket_length(0,b);
            histo[1 + l] = caml_check_bound(histo,l)[1 + l] + 1 | 0;
            return 0},
          _d0_);
        return [0,h[1],h[2].length - 1,mbl,histo]}
      function bucket_length_alive(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {if(param$0)
           {var rest=param$0[3],c=param$0[2];
            if(caml_call1(H[7],c))
             {var accu$1=accu$0 + 1 | 0,accu$0=accu$1,param$0=rest;continue}
            var param$0=rest;
            continue}
          return accu$0}}
      function stats_alive(h)
       {var
         size=[0,0],
         _dV_=h[2],
         _dW_=0,
         mbl=
          fold_left$0
           (function(m,b){return max(m,bucket_length_alive(0,b))},_dW_,_dV_),
         histo=caml_make_vect(mbl + 1 | 0,0),
         _dX_=h[2];
        iter$2
         (function(b)
           {var l=bucket_length_alive(0,b);
            size[1] = size[1] + l | 0;
            histo[1 + l] = caml_check_bound(histo,l)[1 + l] + 1 | 0;
            return 0},
          _dX_);
        return [0,size[1],h[2].length - 1,mbl,histo]}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              clean,
              stats_alive]}
    function create$4(param){return caml_call1(_E_[1],1)}
    function get_key(t){return caml_call2(_E_[3],t,0)}
    function get_key_copy(t){return caml_call2(_E_[4],t,0)}
    function set_key(t,k){return caml_call3(_E_[5],t,0,k)}
    function unset_key(t){return caml_call2(_E_[6],t,0)}
    function check_key(t){return caml_call2(_E_[7],t,0)}
    function blit_key(t1,t2){return caml_call5(_E_[8],t1,0,t2,0,1)}
    function get_data$1(t){return caml_call1(_E_[9],t)}
    function get_data_copy(t){return caml_call1(_E_[10],t)}
    function set_data(t,d){return caml_call2(_E_[11],t,d)}
    function unset_data(t){return caml_call1(_E_[12],t)}
    function check_data(t){return caml_call1(_E_[13],t)}
    function blit_data(t1,t2){return caml_call2(_E_[14],t1,t2)}
    function MakeSeeded$1(H)
     {function create(k,d)
       {var c=create$4(0);set_data(c,d);set_key(c,k);return c}
      var hash=H[2];
      function equal(c,k)
       {var match=get_key(c);
        if(match){var k$0=match[1];return caml_call2(H[1],k,k$0)?0:1}
        return 2}
      function set_key_data(c,k,d)
       {unset_data(c);set_key(c,k);return set_data(c,d)}
      return MakeSeeded$0
              ([0,create,hash,equal,get_data$1,get_key,set_key_data,check_key])}
    function Make$1(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded$1([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       clean=include[17],
       stats_alive=include[18],
       _dU_=include[1];
      function create(sz){return caml_call2(_dU_,_cv_,sz)}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              clean,
              stats_alive]}
    function create$5(param){return caml_call1(_E_[1],2)}
    function get_key1(t){return caml_call2(_E_[3],t,0)}
    function get_key1_copy(t){return caml_call2(_E_[4],t,0)}
    function set_key1(t,k){return caml_call3(_E_[5],t,0,k)}
    function unset_key1(t){return caml_call2(_E_[6],t,0)}
    function check_key1(t){return caml_call2(_E_[7],t,0)}
    function get_key2(t){return caml_call2(_E_[3],t,1)}
    function get_key2_copy(t){return caml_call2(_E_[4],t,1)}
    function set_key2(t,k){return caml_call3(_E_[5],t,1,k)}
    function unset_key2(t){return caml_call2(_E_[6],t,1)}
    function check_key2(t){return caml_call2(_E_[7],t,1)}
    function blit_key1(t1,t2){return caml_call5(_E_[8],t1,0,t2,0,1)}
    function blit_key2(t1,t2){return caml_call5(_E_[8],t1,1,t2,1,1)}
    function blit_key12(t1,t2){return caml_call5(_E_[8],t1,0,t2,0,2)}
    function get_data$2(t){return caml_call1(_E_[9],t)}
    function get_data_copy$0(t){return caml_call1(_E_[10],t)}
    function set_data$0(t,d){return caml_call2(_E_[11],t,d)}
    function unset_data$0(t){return caml_call1(_E_[12],t)}
    function check_data$0(t){return caml_call1(_E_[13],t)}
    function blit_data$0(t1,t2){return caml_call2(_E_[14],t1,t2)}
    function MakeSeeded$2(H1,H2)
     {function create(param,d)
       {var k2=param[2],k1=param[1],c=create$5(0);
        set_data$0(c,d);
        set_key1(c,k1);
        set_key2(c,k2);
        return c}
      function hash(seed,param)
       {var
         k2=param[2],
         k1=param[1],
         _dT_=caml_call2(H2[2],seed,k2) * 65599 | 0;
        return caml_call2(H1[2],seed,k1) + _dT_ | 0}
      function equal(c,param)
       {var k2=param[2],k1=param[1],match=get_key1(c),match$0=get_key2(c);
        if(match)
         if(match$0)
          {var k2$0=match$0[1],k1$0=match[1];
           if(caml_call2(H1[1],k1,k1$0))if(caml_call2(H2[1],k2,k2$0))return 0;
           return 1}
        return 2}
      function get_key(c)
       {var match=get_key1(c),match$0=get_key2(c);
        if(match)
         if(match$0){var k2=match$0[1],k1=match[1];return [0,[0,k1,k2]]}
        return 0}
      function set_key_data(c,param,d)
       {var k2=param[2],k1=param[1];
        unset_data$0(c);
        set_key1(c,k1);
        set_key2(c,k2);
        return set_data$0(c,d)}
      function check_key(c)
       {var _dS_=check_key1(c);return _dS_?check_key2(c):_dS_}
      return MakeSeeded$0
              ([0,create,hash,equal,get_data$2,get_key,set_key_data,check_key])}
    function Make$2(H1,H2)
     {var equal=H2[1];
      function hash(seed,x){return caml_call1(H2[2],x)}
      var equal$0=H1[1],_dQ_=[0,equal,hash];
      function hash$0(seed,x){return caml_call1(H1[2],x)}
      var
       include=MakeSeeded$2([0,equal$0,hash$0],_dQ_),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       clean=include[17],
       stats_alive=include[18],
       _dR_=include[1];
      function create(sz){return caml_call2(_dR_,_cw_,sz)}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              clean,
              stats_alive]}
    function create$6(n){return caml_call1(_E_[1],n)}
    function length$6(k){return caml_call1(_E_[2],k)}
    function get_key$0(t,n){return caml_call2(_E_[3],t,n)}
    function get_key_copy$0(t,n){return caml_call2(_E_[4],t,n)}
    function set_key$0(t,n,k){return caml_call3(_E_[5],t,n,k)}
    function unset_key$0(t,n){return caml_call2(_E_[6],t,n)}
    function check_key$0(t,n){return caml_call2(_E_[7],t,n)}
    function blit_key$0(t1,o1,t2,o2,l)
     {return caml_call5(_E_[8],t1,o1,t2,o2,l)}
    function get_data$3(t){return caml_call1(_E_[9],t)}
    function get_data_copy$1(t){return caml_call1(_E_[10],t)}
    function set_data$1(t,d){return caml_call2(_E_[11],t,d)}
    function unset_data$1(t){return caml_call1(_E_[12],t)}
    function check_data$1(t){return caml_call1(_E_[13],t)}
    function blit_data$1(t1,t2){return caml_call2(_E_[14],t1,t2)}
    function MakeSeeded$3(H)
     {function create(k,d)
       {var c=create$6(k.length - 1);
        set_data$1(c,d);
        var _dO_=k.length - 1 - 1 | 0,_dN_=0;
        if(! (_dO_ < 0))
         {var i=_dN_;
          for(;;)
           {set_key$0(c,i,caml_check_bound(k,i)[1 + i]);
            var _dP_=i + 1 | 0;
            if(_dO_ !== i){var i=_dP_;continue}
            break}}
        return c}
      function hash(seed,k)
       {var h=[0,0],_dJ_=k.length - 1 - 1 | 0,_dI_=0;
        if(! (_dJ_ < 0))
         {var i=_dI_;
          for(;;)
           {var _dK_=h[1],_dL_=caml_check_bound(k,i)[1 + i];
            h[1] = (caml_call2(H[2],seed,_dL_) * 65599 | 0) + _dK_ | 0;
            var _dM_=i + 1 | 0;
            if(_dJ_ !== i){var i=_dM_;continue}
            break}}
        return h[1]}
      function equal(c,k)
       {var len=k.length - 1,len$0=length$6(c);
        if(len !== len$0)return 1;
        var i$1=len - 1 | 0,i=i$1;
        for(;;)
         {if(0 <= i)
           {var match=get_key$0(c,i);
            if(match)
             {var ki=match[1],_dH_=caml_check_bound(k,i)[1 + i];
              if(caml_call2(H[1],_dH_,ki)){var i$0=i - 1 | 0,i=i$0;continue}
              return 1}
            return 2}
          return 0}}
      function get_key(c)
       {var len=length$6(c);
        if(0 === len)return [0,[0]];
        var match=get_key$0(c,0);
        if(match)
         {var k0=match[1],a=caml_make_vect(len,k0),i$1=len - 1 | 0,i=i$1;
          for(;;)
           {if(1 <= i)
             {var match$0=get_key$0(c,i);
              if(match$0)
               {var ki=match$0[1];
                caml_check_bound(a,i)[1 + i] = ki;
                var i$0=i - 1 | 0,i=i$0;
                continue}
              return 0}
            return [0,a]}}
        return 0}
      function set_key_data(c,k,d)
       {unset_data$1(c);
        var _dF_=k.length - 1 - 1 | 0,_dE_=0;
        if(! (_dF_ < 0))
         {var i=_dE_;
          for(;;)
           {set_key$0(c,i,caml_check_bound(k,i)[1 + i]);
            var _dG_=i + 1 | 0;
            if(_dF_ !== i){var i=_dG_;continue}
            break}}
        return set_data$1(c,d)}
      function check_key(c)
       {var i$1=length$6(c) - 1 | 0,i=i$1;
        for(;;)
         {var _dB_=i < 0?1:0;
          if(_dB_)
           var _dC_=_dB_;
          else
           {var _dD_=check_key$0(c,i);
            if(_dD_){var i$0=i - 1 | 0,i=i$0;continue}
            var _dC_=_dD_}
          return _dC_}}
      return MakeSeeded$0
              ([0,create,hash,equal,get_data$3,get_key,set_key_data,check_key])}
    function Make$3(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded$3([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       clean=include[17],
       stats_alive=include[18],
       _dA_=include[1];
      function create(sz){return caml_call2(_dA_,_cx_,sz)}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              clean,
              stats_alive]}
    var
     Ephemeron=
      [0,
       [0,
        create$4,
        get_key,
        get_key_copy,
        set_key,
        unset_key,
        check_key,
        blit_key,
        get_data$1,
        get_data_copy,
        set_data,
        unset_data,
        check_data,
        blit_data,
        Make$1,
        MakeSeeded$1],
       [0,
        create$5,
        get_key1,
        get_key1_copy,
        set_key1,
        unset_key1,
        check_key1,
        get_key2,
        get_key2_copy,
        set_key2,
        unset_key2,
        check_key2,
        blit_key1,
        blit_key2,
        blit_key12,
        get_data$2,
        get_data_copy$0,
        set_data$0,
        unset_data$0,
        check_data$0,
        blit_data$0,
        Make$2,
        MakeSeeded$2],
       [0,
        create$6,
        get_key$0,
        get_key_copy$0,
        set_key$0,
        unset_key$0,
        check_key$0,
        blit_key$0,
        get_data$3,
        get_data_copy$1,
        set_data$1,
        unset_data$1,
        check_data$1,
        blit_data$1,
        Make$3,
        MakeSeeded$3],
       [0,
        function(_dz_)
         {return MakeSeeded$0
                  ([0,_dz_[3],_dz_[1],_dz_[2],_dz_[5],_dz_[4],_dz_[6],_dz_[7]])}]];
    caml_register_global(688,Ephemeron,"Ephemeron");
    function generic_basename(is_dir_sep,current_dir_name,name)
     {if(caml_string_equal(name,cst$84))return current_dir_name;
      var n$3=caml_ml_string_length(name) - 1 | 0,n=n$3;
      for(;;)
       {if(0 <= n)
         {if(caml_call2(is_dir_sep,name,n)){var n$0=n - 1 | 0,n=n$0;continue}
          var p=n + 1 | 0,n$1=n;
          for(;;)
           {if(0 <= n$1)
             {if(caml_call2(is_dir_sep,name,n$1))
               return sub$0(name,n$1 + 1 | 0,(p - n$1 | 0) - 1 | 0);
              var n$2=n$1 - 1 | 0,n$1=n$2;
              continue}
            return sub$0(name,0,p)}}
        return sub$0(name,0,1)}}
    function generic_dirname(is_dir_sep,current_dir_name,name)
     {if(caml_string_equal(name,cst$85))return current_dir_name;
      var n$5=caml_ml_string_length(name) - 1 | 0,n=n$5;
      for(;;)
       {if(0 <= n)
         {if(caml_call2(is_dir_sep,name,n)){var n$0=n - 1 | 0,n=n$0;continue}
          var n$1=n;
          for(;;)
           {if(0 <= n$1)
             {if(caml_call2(is_dir_sep,name,n$1))
               {var n$3=n$1;
                for(;;)
                 {if(0 <= n$3)
                   {if(caml_call2(is_dir_sep,name,n$3))
                     {var n$4=n$3 - 1 | 0,n$3=n$4;continue}
                    return sub$0(name,0,n$3 + 1 | 0)}
                  return sub$0(name,0,1)}}
              var n$2=n$1 - 1 | 0,n$1=n$2;
              continue}
            return current_dir_name}}
        return sub$0(name,0,1)}}
    function is_dir_sep(s,i){return 47 === caml_string_get(s,i)?1:0}
    function is_relative(n)
     {var
       _dx_=caml_ml_string_length(n) < 1?1:0,
       _dy_=_dx_ || (47 !== caml_string_get(n,0)?1:0);
      return _dy_}
    function is_implicit(n)
     {var _ds_=is_relative(n);
      if(_ds_)
       {var
         _dt_=caml_ml_string_length(n) < 2?1:0,
         _du_=_dt_ || caml_string_notequal(sub$0(n,0,2),cst$87);
        if(_du_)
         var
          _dv_=caml_ml_string_length(n) < 3?1:0,
          _dw_=_dv_ || caml_string_notequal(sub$0(n,0,3),cst$86);
        else
         var _dw_=_du_}
      else
       var _dw_=_ds_;
      return _dw_}
    function check_suffix(name,suff)
     {var
       _dq_=caml_ml_string_length(suff) <= caml_ml_string_length(name)?1:0,
       _dr_=
        _dq_
         ?caml_string_equal
           (sub$0
             (name,
              caml_ml_string_length(name) - caml_ml_string_length(suff) | 0,
              caml_ml_string_length(suff)),
            suff)
         :_dq_;
      return _dr_}
    try
     {var _cF_=caml_sys_getenv(cst_TMPDIR),_cy_=_cF_}
    catch(_dp_)
     {_dp_ = caml_wrap_exception(_dp_);
      if(_dp_ !== Not_found)throw _dp_;
      var _cy_=cst_tmp}
    function quote(s)
     {var l=caml_ml_string_length(s),b=create$1(l + 20 | 0);
      add_char(b,39);
      var _dn_=l - 1 | 0,_dm_=0;
      if(! (_dn_ < 0))
       {var i=_dm_;
        for(;;)
         {if(39 === caml_string_get(s,i))
           add_string(b,quotequote);
          else
           add_char(b,caml_string_get(s,i));
          var _do_=i + 1 | 0;
          if(_dn_ !== i){var i=_do_;continue}
          break}}
      add_char(b,39);
      return contents(b)}
    function basename(_dl_)
     {return generic_basename(is_dir_sep,current_dir_name,_dl_)}
    function dirname(_dk_)
     {return generic_dirname(is_dir_sep,current_dir_name,_dk_)}
    function is_dir_sep$0(s,i)
     {var c=caml_string_get(s,i),_dh_=47 === c?1:0;
      if(_dh_)
       var _di_=_dh_;
      else
       var _dj_=92 === c?1:0,_di_=_dj_ || (58 === c?1:0);
      return _di_}
    function is_relative$0(n)
     {var
       _db_=caml_ml_string_length(n) < 1?1:0,
       _dc_=_db_ || (47 !== caml_string_get(n,0)?1:0);
      if(_dc_)
       {var
         _dd_=caml_ml_string_length(n) < 1?1:0,
         _de_=_dd_ || (92 !== caml_string_get(n,0)?1:0);
        if(_de_)
         var
          _df_=caml_ml_string_length(n) < 2?1:0,
          _dg_=_df_ || (58 !== caml_string_get(n,1)?1:0);
        else
         var _dg_=_de_}
      else
       var _dg_=_dc_;
      return _dg_}
    function is_implicit$0(n)
     {var _c4_=is_relative$0(n);
      if(_c4_)
       {var
         _c5_=caml_ml_string_length(n) < 2?1:0,
         _c6_=_c5_ || caml_string_notequal(sub$0(n,0,2),cst$91);
        if(_c6_)
         {var
           _c7_=caml_ml_string_length(n) < 2?1:0,
           _c8_=_c7_ || caml_string_notequal(sub$0(n,0,2),cst$90);
          if(_c8_)
           {var
             _c9_=caml_ml_string_length(n) < 3?1:0,
             _c__=_c9_ || caml_string_notequal(sub$0(n,0,3),cst$89);
            if(_c__)
             var
              _c$_=caml_ml_string_length(n) < 3?1:0,
              _da_=_c$_ || caml_string_notequal(sub$0(n,0,3),cst$88);
            else
             var _da_=_c__}
          else
           var _da_=_c8_}
        else
         var _da_=_c6_}
      else
       var _da_=_c4_;
      return _da_}
    function check_suffix$0(name,suff)
     {var _c1_=caml_ml_string_length(suff) <= caml_ml_string_length(name)?1:0;
      if(_c1_)
       var
        s=
         sub$0
          (name,
           caml_ml_string_length(name) - caml_ml_string_length(suff) | 0,
           caml_ml_string_length(suff)),
        _c2_=lowercase_ascii$1(suff),
        _c3_=caml_string_equal(lowercase_ascii$1(s),_c2_);
      else
       var _c3_=_c1_;
      return _c3_}
    try
     {var _cE_=caml_sys_getenv(cst_TEMP),temp_dir_name=_cE_}
    catch(_c0_)
     {_c0_ = caml_wrap_exception(_c0_);
      if(_c0_ !== Not_found)throw _c0_;
      var temp_dir_name=cst$92}
    function quote$0(s)
     {var l=caml_ml_string_length(s),b=create$1(l + 20 | 0);
      add_char(b,34);
      function add_bs(n)
       {var _cY_=1;
        if(! (n < 1))
         {var j=_cY_;
          for(;;)
           {add_char(b,92);
            var _cZ_=j + 1 | 0;
            if(n !== j){var j=_cZ_;continue}
            break}}
        return 0}
      function loop$0(counter,i)
       {var i$0=i;
        for(;;)
         {if(i$0 === l)return add_char(b,34);
          var c=caml_string_get(s,i$0);
          if(34 === c)
           {var _cW_=0;
            if(counter < 50)
             {var counter$1=counter + 1 | 0;
              return loop_bs(counter$1,_cW_,i$0)}
            return caml_trampoline_return(loop_bs,[0,_cW_,i$0])}
          if(92 === c)
           {var _cX_=0;
            if(counter < 50)
             {var counter$0=counter + 1 | 0;
              return loop_bs(counter$0,_cX_,i$0)}
            return caml_trampoline_return(loop_bs,[0,_cX_,i$0])}
          add_char(b,c);
          var i$1=i$0 + 1 | 0,i$0=i$1;
          continue}}
      function loop_bs(counter,n,i)
       {var n$0=n,i$0=i;
        for(;;)
         {if(i$0 === l){add_char(b,34);return add_bs(n$0)}
          var match=caml_string_get(s,i$0);
          if(34 === match)
           {add_bs((2 * n$0 | 0) + 1 | 0);
            add_char(b,34);
            var _cV_=i$0 + 1 | 0;
            if(counter < 50)
             {var counter$1=counter + 1 | 0;return loop$0(counter$1,_cV_)}
            return caml_trampoline_return(loop$0,[0,_cV_])}
          if(92 === match)
           {var i$1=i$0 + 1 | 0,n$1=n$0 + 1 | 0,n$0=n$1,i$0=i$1;continue}
          add_bs(n$0);
          if(counter < 50)
           {var counter$0=counter + 1 | 0;return loop$0(counter$0,i$0)}
          return caml_trampoline_return(loop$0,[0,i$0])}}
      function loop(i){return caml_trampoline(loop$0(0,i))}
      loop(0);
      return contents(b)}
    function drive_and_path(s)
     {var _cR_=2 <= caml_ml_string_length(s)?1:0;
      if(_cR_)
       var
        param=caml_string_get(s,0),
        switch$0=91 <= param?25 < (param - 97 | 0) >>> 0?0:1:65 <= param?1:0,
        _cS_=switch$0?1:0,
        _cT_=_cS_?58 === caml_string_get(s,1)?1:0:_cS_;
      else
       var _cT_=_cR_;
      if(_cT_)
       {var _cU_=sub$0(s,2,caml_ml_string_length(s) - 2 | 0);
        return [0,sub$0(s,0,2),_cU_]}
      return [0,cst$93,s]}
    function dirname$0(s)
     {var
       match=drive_and_path(s),
       path=match[2],
       drive=match[1],
       dir=generic_dirname(is_dir_sep$0,current_dir_name$0,path);
      return symbol(drive,dir)}
    function basename$0(s)
     {var match=drive_and_path(s),path=match[2];
      return generic_basename(is_dir_sep$0,current_dir_name$0,path)}
    function basename$1(_cQ_)
     {return generic_basename(is_dir_sep$0,current_dir_name$1,_cQ_)}
    function dirname$1(_cP_)
     {return generic_dirname(is_dir_sep$0,current_dir_name$1,_cP_)}
    if(caml_string_notequal(os_type,cst_Cygwin))
     if(caml_string_notequal(os_type,cst_Win32))
      var
       current_dir_name$2=current_dir_name,
       parent_dir_name$2=parent_dir_name,
       dir_sep$2=dir_sep,
       is_dir_sep$1=is_dir_sep,
       is_relative$1=is_relative,
       is_implicit$1=is_implicit,
       check_suffix$1=check_suffix,
       temp_dir_name$0=_cy_,
       quote$1=quote,
       basename$2=basename,
       dirname$2=dirname,
       switch$0=1;
     else
      var
       _cD_=
        [0,
         current_dir_name$0,
         parent_dir_name$0,
         dir_sep$0,
         is_dir_sep$0,
         is_relative$0,
         is_implicit$0,
         check_suffix$0,
         temp_dir_name,
         quote$0,
         basename$0,
         dirname$0],
       switch$0=0;
    else
     var
      _cD_=
       [0,
        current_dir_name$1,
        parent_dir_name$1,
        dir_sep$1,
        is_dir_sep$0,
        is_relative$0,
        is_implicit$0,
        check_suffix$0,
        _cy_,
        quote,
        basename$1,
        dirname$1],
      switch$0=0;
    if(! switch$0)
     var
      current_dir_name$2=_cD_[1],
      parent_dir_name$2=_cD_[2],
      dir_sep$2=_cD_[3],
      is_dir_sep$1=is_dir_sep$0,
      is_relative$1=is_relative$0,
      is_implicit$1=is_implicit$0,
      check_suffix$1=check_suffix$0,
      temp_dir_name$0=_cD_[8],
      quote$1=_cD_[9],
      basename$2=_cD_[10],
      dirname$2=_cD_[11];
    function concat$2(dirname,filename)
     {var l=caml_ml_string_length(dirname);
      if(0 !== l)
       if(! is_dir_sep$1(dirname,l - 1 | 0))
        return symbol(dirname,symbol(dir_sep$2,filename));
      return symbol(dirname,filename)}
    function chop_suffix(name,suff)
     {var n=caml_ml_string_length(name) - caml_ml_string_length(suff) | 0;
      return 0 <= n?sub$0(name,0,n):invalid_arg(cst_Filename_chop_suffix)}
    function extension_len(name)
     {var i$4=caml_ml_string_length(name) - 1 | 0,i$1=i$4;
      for(;;)
       {if(0 <= i$1)
         if(! is_dir_sep$1(name,i$1))
          {if(46 === caml_string_get(name,i$1))
            {var i$2=i$1 - 1 | 0,i=i$2;
             for(;;)
              {if(0 <= i)
                if(! is_dir_sep$1(name,i))
                 {if(46 === caml_string_get(name,i))
                   {var i$0=i - 1 | 0,i=i$0;continue}
                  return caml_ml_string_length(name) - i$1 | 0}
               return 0}}
           var i$3=i$1 - 1 | 0,i$1=i$3;
           continue}
        return 0}}
    function extension(name)
     {var l=extension_len(name);
      return 0 === l?cst$94:sub$0(name,caml_ml_string_length(name) - l | 0,l)}
    function chop_extension(name)
     {var l=extension_len(name);
      return 0 === l
              ?invalid_arg(cst_Filename_chop_extension)
              :sub$0(name,0,caml_ml_string_length(name) - l | 0)}
    function remove_extension(name)
     {var l=extension_len(name);
      return 0 === l?name:sub$0(name,0,caml_ml_string_length(name) - l | 0)}
    var prng$0=[246,function(_cO_){return caml_call1(_b2_[2],0)}];
    function temp_file_name(temp_dir,prefix,suffix)
     {var
       _cM_=caml_obj_tag(prng$0),
       _cN_=
        250 === _cM_?prng$0[1]:246 === _cM_?force_lazy_block(prng$0):prng$0,
       rnd=caml_call1(_b2_[4],_cN_) & 16777215;
      return concat$2(temp_dir,caml_call3(sprintf(_cz_),prefix,rnd,suffix))}
    var current_temp_dir_name=[0,temp_dir_name$0];
    function set_temp_dir_name(s){current_temp_dir_name[1] = s;return 0}
    function get_temp_dir_name(param){return current_temp_dir_name[1]}
    function temp_file(opt,prefix,suffix)
     {if(opt)
       var sth=opt[1],temp_dir=sth;
      else
       var temp_dir=current_temp_dir_name[1];
      function try_name(counter)
       {var counter$0=counter;
        for(;;)
         {var name=temp_file_name(temp_dir,prefix,suffix);
          try
           {runtime.caml_sys_close(caml_sys_open(name,_cA_,384));return name}
          catch(e)
           {e = caml_wrap_exception(e);
            if(e[1] === Sys_error)
             {if(1000 <= counter$0)throw e;
              var counter$1=counter$0 + 1 | 0,counter$0=counter$1;
              continue}
            throw e}}}
      return try_name(0)}
    function open_temp_file(opt,_cK_,_cJ_,prefix,suffix)
     {if(opt)var sth=opt[1],mode=sth;else var mode=_cB_;
      if(_cK_)var sth$0=_cK_[1],perms=sth$0;else var perms=384;
      if(_cJ_)
       var sth$1=_cJ_[1],temp_dir=sth$1;
      else
       var temp_dir=current_temp_dir_name[1];
      function try_name(counter)
       {var counter$0=counter;
        for(;;)
         {var name=temp_file_name(temp_dir,prefix,suffix);
          try
           {var _cL_=[0,name,open_out_gen([0,1,[0,3,[0,5,mode]]],perms,name)];
            return _cL_}
          catch(e)
           {e = caml_wrap_exception(e);
            if(e[1] === Sys_error)
             {if(1000 <= counter$0)throw e;
              var counter$1=counter$0 + 1 | 0,counter$0=counter$1;
              continue}
            throw e}}}
      return try_name(0)}
    var
     Filename=
      [0,
       current_dir_name$2,
       parent_dir_name$2,
       dir_sep$2,
       concat$2,
       is_relative$1,
       is_implicit$1,
       check_suffix$1,
       chop_suffix,
       extension,
       remove_extension,
       chop_extension,
       basename$2,
       dirname$2,
       temp_file,
       open_temp_file,
       get_temp_dir_name,
       set_temp_dir_name,
       temp_dir_name$0,
       quote$1];
    caml_register_global(689,Filename,"Filename");
    function add$1(x,y){return [254,x[1] + y[1],x[2] + y[2]]}
    function sub$3(x,y){return [254,x[1] - y[1],x[2] - y[2]]}
    function neg(x){return [254,- x[1],- x[2]]}
    function conj(x){return [254,x[1],- x[2]]}
    function mul(x,y)
     {return [254,x[1] * y[1] - x[2] * y[2],x[1] * y[2] + x[2] * y[1]]}
    function div(x,y)
     {if(Math.abs(y[2]) <= Math.abs(y[1]))
       {var r=y[2] / y[1],d=y[1] + r * y[2];
        return [254,(x[1] + r * x[2]) / d,(x[2] - r * x[1]) / d]}
      var r$0=y[1] / y[2],d$0=y[2] + r$0 * y[1];
      return [254,(r$0 * x[1] + x[2]) / d$0,(r$0 * x[2] - x[1]) / d$0]}
    function inv(x){return div(one$2,x)}
    function norm2(x){return x[1] * x[1] + x[2] * x[2]}
    function norm(x)
     {var r=Math.abs(x[1]),i=Math.abs(x[2]);
      if(r == 0.)return i;
      if(i == 0.)return r;
      if(i <= r){var q=i / r;return r * Math.sqrt(1. + q * q)}
      var q$0=r / i;
      return i * Math.sqrt(1. + q$0 * q$0)}
    function arg(x){return Math.atan2(x[2],x[1])}
    function polar(n,a){return [254,Math.cos(a) * n,Math.sin(a) * n]}
    function sqrt(x)
     {if(x[1] == 0.)if(x[2] == 0.)return _cC_;
      var r=Math.abs(x[1]),i=Math.abs(x[2]);
      if(i <= r)
       var
        q=i / r,
        w=Math.sqrt(r) * Math.sqrt(0.5 * (1. + Math.sqrt(1. + q * q)));
      else
       var
        q$0=r / i,
        w=Math.sqrt(i) * Math.sqrt(0.5 * (q$0 + Math.sqrt(1. + q$0 * q$0)));
      if(0. <= x[1])return [254,w,0.5 * x[2] / w];
      var w$0=0. <= x[2]?w:- w;
      return [254,0.5 * i / w,w$0]}
    function exp(x)
     {var e=Math.exp(x[1]);return [254,e * Math.cos(x[2]),e * Math.sin(x[2])]}
    function log(x)
     {var _cI_=Math.atan2(x[2],x[1]);return [254,Math.log(norm(x)),_cI_]}
    function pow(x,y){return exp(mul(y,log(x)))}
    var
     Complex=
      [0,
       zero$2,
       one$2,
       i,
       neg,
       conj,
       add$1,
       sub$3,
       mul,
       inv,
       div,
       sqrt,
       norm2,
       norm,
       arg,
       polar,
       exp,
       log,
       pow];
    caml_register_global(690,Complex,"Complex");
    var
     ArrayLabels=
      [0,
       init$2,
       create_matrix,
       create_matrix,
       append$0,
       concat$1,
       sub$1,
       copy$1,
       fill$0,
       blit$1,
       to_list,
       of_list,
       iter$2,
       map$2,
       iteri$2,
       mapi$2,
       fold_left$0,
       fold_right$0,
       iter2$0,
       map2$0,
       exists$0,
       for_all$0,
       mem$0,
       memq$0,
       make_float,
       sort,
       fast_sort$0,
       fast_sort$0,
       Floatarray];
    caml_register_global(691,ArrayLabels,"ArrayLabels");
    var
     ListLabels=
      [0,
       length,
       hd,
       compare_lengths,
       compare_length_with,
       cons,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       flatten,
       flatten,
       iter,
       iteri,
       map,
       mapi,
       rev_map,
       fold_left,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_all,
       find_all,
       partition,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       fast_sort,
       fast_sort,
       fast_sort,
       sort_uniq,
       merge];
    caml_register_global(692,ListLabels,"ListLabels");
    var
     BytesLabels=
      [0,
       make,
       init$0,
       empty,
       copy,
       of_string,
       to_string,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit$0,
       concat,
       cat,
       iter$0,
       iteri$0,
       map$0,
       mapi$0,
       trim,
       escaped$0,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase$0,
       lowercase$0,
       capitalize,
       uncapitalize,
       uppercase_ascii$0,
       lowercase_ascii$0,
       capitalize_ascii,
       uncapitalize_ascii,
       compare$1,
       equal$1,
       unsafe_to_string,
       unsafe_of_string];
    caml_register_global(693,BytesLabels,"BytesLabels");
    var
     StringLabels=
      [0,
       make$0,
       init$1,
       copy$0,
       sub$0,
       fill,
       blit$0,
       concat$0,
       iter$1,
       iteri$1,
       map$1,
       mapi$1,
       trim$0,
       escaped$1,
       index$0,
       index_opt$0,
       rindex$0,
       rindex_opt$0,
       index_from$0,
       index_from_opt$0,
       rindex_from$0,
       rindex_from_opt$0,
       contains$0,
       contains_from$0,
       rcontains_from$0,
       uppercase$1,
       lowercase$1,
       capitalize$0,
       uncapitalize$0,
       uppercase_ascii$1,
       lowercase_ascii$1,
       capitalize_ascii$0,
       uncapitalize_ascii$0,
       compare$2,
       equal$2,
       split_on_char];
    caml_register_global(694,StringLabels,"StringLabels");
    var MoreLabels=[0,Hashtbl,Map,Set];
    caml_register_global(695,MoreLabels,"MoreLabels");
    var StdLabels=[0,0,0,0,0];
    caml_register_global(696,StdLabels,"StdLabels");
    var enabled=caml_spacetime_enabled(0);
    function if_spacetime_enabled(f){return enabled?caml_call1(f,0):0}
    function create$7(path)
     {if(caml_spacetime_enabled(0))
       {var channel=open_out(path),t=[0,channel,0];
        caml_spacetime_only_works_for_native_code(t[1]);
        return t}
      return [0,stdout,1]}
    function save_event(time,t,event_name)
     {return if_spacetime_enabled
              (function(param)
                {return caml_spacetime_only_works_for_native_code
                         (time,t[1],event_name)})}
    function save_and_close(time,t)
     {return if_spacetime_enabled
              (function(param)
                {if(t[2])failwith(cst_Series_is_closed);
                 caml_spacetime_only_works_for_native_code(time,t[1]);
                 close_out(t[1]);
                 t[2] = 1;
                 return 0})}
    var Series=[0,create$7,save_event,save_and_close];
    function take$0(time,param)
     {var channel=param[1],closed=param[2];
      return if_spacetime_enabled
              (function(param)
                {if(closed)failwith(cst_Series_is_closed$0);
                 runtime.caml_gc_minor(0);
                 return caml_spacetime_only_works_for_native_code
                         (time,channel)})}
    var Snapshot=[0,take$0];
    function save_event_for_automatic_snapshots(event_name)
     {return if_spacetime_enabled
              (function(param)
                {return caml_spacetime_only_works_for_native_code(event_name)})}
    var
     Spacetime=
      [0,enabled,Series,Snapshot,save_event_for_automatic_snapshots];
    caml_register_global(697,Spacetime,"Spacetime");
    var CamlinternalBigarray=[0];
    caml_register_global(698,CamlinternalBigarray,"CamlinternalBigarray");
    return}
  (function(){return this}()));


//# 1 "../.js/unix/unix.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_check_bound=runtime.caml_check_bound,
     caml_ml_bytes_length=runtime.caml_ml_bytes_length,
     caml_ml_open_descriptor_in=runtime.caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out=runtime.caml_ml_open_descriptor_out,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_new_string=runtime.caml_new_string,
     caml_register_global=runtime.caml_register_global,
     caml_string_equal=runtime.caml_string_equal,
     caml_sys_exit=runtime.caml_sys_exit,
     caml_wrap_exception=runtime.caml_wrap_exception,
     unix_inet_addr_of_string=runtime.unix_inet_addr_of_string;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_close_process_full=caml_new_string("close_process_full"),
     cst_close_process=caml_new_string("close_process"),
     cst_close_process_out=caml_new_string("close_process_out"),
     cst_close_process_in=caml_new_string("close_process_in"),
     cst$9=caml_new_string(""),
     shell=caml_new_string("/bin/sh"),
     cst_c$0=caml_new_string("-c"),
     cst_c=caml_new_string("-c"),
     cst_bin_sh$0=caml_new_string("/bin/sh"),
     cst_bin_sh$1=caml_new_string("/bin/sh"),
     cst$8=caml_new_string(""),
     cst_udp$1=caml_new_string("udp"),
     cst_tcp$1=caml_new_string("tcp"),
     cst$5=caml_new_string(""),
     cst$7=caml_new_string(""),
     cst_tcp=caml_new_string("tcp"),
     cst_udp=caml_new_string("udp"),
     cst_udp$0=caml_new_string("udp"),
     cst_tcp$0=caml_new_string("tcp"),
     cst$6=caml_new_string(""),
     cst_0_0_0_0$0=caml_new_string("0.0.0.0"),
     cst_127_0_0_1$0=caml_new_string("127.0.0.1"),
     cst_Unix_sendto=caml_new_string("Unix.sendto"),
     cst_Unix_send=caml_new_string("Unix.send"),
     cst_Unix_recvfrom=caml_new_string("Unix.recvfrom"),
     cst_Unix_recv=caml_new_string("Unix.recv"),
     cst_Unix_single_write=caml_new_string("Unix.single_write"),
     cst_Unix_write=caml_new_string("Unix.write"),
     cst_Unix_read=caml_new_string("Unix.read"),
     cst$4=caml_new_string(""),
     cst_execvpe=caml_new_string("execvpe"),
     cst_bin_sh=caml_new_string("/bin/sh"),
     cst_PATH=caml_new_string("PATH"),
     cst_bin_usr_bin=caml_new_string("/bin:/usr/bin"),
     cst$1=caml_new_string(': "'),
     cst_failed=caml_new_string('" failed'),
     cst_on=caml_new_string(' on "'),
     cst$2=caml_new_string('"'),
     cst$3=caml_new_string(": "),
     cst_E2BIG=caml_new_string("E2BIG"),
     cst_EACCES=caml_new_string("EACCES"),
     cst_EAGAIN=caml_new_string("EAGAIN"),
     cst_EBADF=caml_new_string("EBADF"),
     cst_EBUSY=caml_new_string("EBUSY"),
     cst_ECHILD=caml_new_string("ECHILD"),
     cst_EDEADLK=caml_new_string("EDEADLK"),
     cst_EDOM=caml_new_string("EDOM"),
     cst_EEXIST=caml_new_string("EEXIST"),
     cst_EFAULT=caml_new_string("EFAULT"),
     cst_EFBIG=caml_new_string("EFBIG"),
     cst_EINTR=caml_new_string("EINTR"),
     cst_EINVAL=caml_new_string("EINVAL"),
     cst_EIO=caml_new_string("EIO"),
     cst_EISDIR=caml_new_string("EISDIR"),
     cst_EMFILE=caml_new_string("EMFILE"),
     cst_EMLINK=caml_new_string("EMLINK"),
     cst_ENAMETOOLONG=caml_new_string("ENAMETOOLONG"),
     cst_ENFILE=caml_new_string("ENFILE"),
     cst_ENODEV=caml_new_string("ENODEV"),
     cst_ENOENT=caml_new_string("ENOENT"),
     cst_ENOEXEC=caml_new_string("ENOEXEC"),
     cst_ENOLCK=caml_new_string("ENOLCK"),
     cst_ENOMEM=caml_new_string("ENOMEM"),
     cst_ENOSPC=caml_new_string("ENOSPC"),
     cst_ENOSYS=caml_new_string("ENOSYS"),
     cst_ENOTDIR=caml_new_string("ENOTDIR"),
     cst_ENOTEMPTY=caml_new_string("ENOTEMPTY"),
     cst_ENOTTY=caml_new_string("ENOTTY"),
     cst_ENXIO=caml_new_string("ENXIO"),
     cst_EPERM=caml_new_string("EPERM"),
     cst_EPIPE=caml_new_string("EPIPE"),
     cst_ERANGE=caml_new_string("ERANGE"),
     cst_EROFS=caml_new_string("EROFS"),
     cst_ESPIPE=caml_new_string("ESPIPE"),
     cst_ESRCH=caml_new_string("ESRCH"),
     cst_EXDEV=caml_new_string("EXDEV"),
     cst_EWOULDBLOCK=caml_new_string("EWOULDBLOCK"),
     cst_EINPROGRESS=caml_new_string("EINPROGRESS"),
     cst_EALREADY=caml_new_string("EALREADY"),
     cst_ENOTSOCK=caml_new_string("ENOTSOCK"),
     cst_EDESTADDRREQ=caml_new_string("EDESTADDRREQ"),
     cst_EMSGSIZE=caml_new_string("EMSGSIZE"),
     cst_EPROTOTYPE=caml_new_string("EPROTOTYPE"),
     cst_ENOPROTOOPT=caml_new_string("ENOPROTOOPT"),
     cst_EPROTONOSUPPORT=caml_new_string("EPROTONOSUPPORT"),
     cst_ESOCKTNOSUPPORT=caml_new_string("ESOCKTNOSUPPORT"),
     cst_EOPNOTSUPP=caml_new_string("EOPNOTSUPP"),
     cst_EPFNOSUPPORT=caml_new_string("EPFNOSUPPORT"),
     cst_EAFNOSUPPORT=caml_new_string("EAFNOSUPPORT"),
     cst_EADDRINUSE=caml_new_string("EADDRINUSE"),
     cst_EADDRNOTAVAIL=caml_new_string("EADDRNOTAVAIL"),
     cst_ENETDOWN=caml_new_string("ENETDOWN"),
     cst_ENETUNREACH=caml_new_string("ENETUNREACH"),
     cst_ENETRESET=caml_new_string("ENETRESET"),
     cst_ECONNABORTED=caml_new_string("ECONNABORTED"),
     cst_ECONNRESET=caml_new_string("ECONNRESET"),
     cst_ENOBUFS=caml_new_string("ENOBUFS"),
     cst_EISCONN=caml_new_string("EISCONN"),
     cst_ENOTCONN=caml_new_string("ENOTCONN"),
     cst_ESHUTDOWN=caml_new_string("ESHUTDOWN"),
     cst_ETOOMANYREFS=caml_new_string("ETOOMANYREFS"),
     cst_ETIMEDOUT=caml_new_string("ETIMEDOUT"),
     cst_ECONNREFUSED=caml_new_string("ECONNREFUSED"),
     cst_EHOSTDOWN=caml_new_string("EHOSTDOWN"),
     cst_EHOSTUNREACH=caml_new_string("EHOSTUNREACH"),
     cst_ELOOP=caml_new_string("ELOOP"),
     cst_EOVERFLOW=caml_new_string("EOVERFLOW"),
     cst_Unix_Unix_error=caml_new_string("Unix.Unix_error"),
     cst=caml_new_string(""),
     cst$0=caml_new_string(""),
     cst_Unix_Unix_error$0=caml_new_string("Unix.Unix_error"),
     cst_0_0_0_0=caml_new_string("0.0.0.0"),
     cst_127_0_0_1=caml_new_string("127.0.0.1"),
     cst$10=caml_new_string("::"),
     cst_1=caml_new_string("::1"),
     Pervasives=global_data.Pervasives,
     Sys_error=global_data.Sys_error,
     Hashtbl=global_data.Hashtbl,
     Not_found=global_data.Not_found,
     Invalid_argument=global_data.Invalid_argument,
     List=global_data.List,
     Failure=global_data.Failure,
     Array=global_data.Array,
     Bytes=global_data.Bytes,
     Filename=global_data.Filename,
     String=global_data.String,
     Sys=global_data.Sys,
     Printf=global_data.Printf,
     Callback=global_data.Callback,
     Printexc=global_data.Printexc,
     Unix_error=[248,cst_Unix_Unix_error,runtime.caml_fresh_oo_id(0)];
    caml_call2(Callback[2],cst_Unix_Unix_error$0,[0,Unix_error,0,cst$0,cst]);
    var
     _p_=[0,1],
     _q_=[0,1],
     _o_=[0,1],
     _l_=[0,1],
     _m_=[0,1],
     _n_=[0,1],
     _j_=[0,1],
     _k_=[0,1],
     _i_=[0,1],
     _h_=[0,1],
     _e_=[0,0],
     _f_=[0,0],
     _g_=[0,0],
     _d_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _c_=
      [0,
       [11,caml_new_string("EUNKNOWNERR "),[4,0,0,0,0]],
       caml_new_string("EUNKNOWNERR %d")],
     _b_=
      [0,
       [11,
        caml_new_string("Unix.Unix_error(Unix."),
        [2,
         0,
         [11,
          caml_new_string(", "),
          [3,0,[11,caml_new_string(", "),[3,0,[12,41,0]]]]]]],
       caml_new_string("Unix.Unix_error(Unix.%s, %S, %S)")];
    function _a_(param)
     {if(param[1] === Unix_error)
       {var s=param[4],s$0=param[3],e=param[2];
        if(typeof e === "number")
         {var _dx_=e;
          if(34 <= _dx_)
           switch(_dx_)
            {case 34:var msg=cst_ESPIPE;break;
             case 35:var msg=cst_ESRCH;break;
             case 36:var msg=cst_EXDEV;break;
             case 37:var msg=cst_EWOULDBLOCK;break;
             case 38:var msg=cst_EINPROGRESS;break;
             case 39:var msg=cst_EALREADY;break;
             case 40:var msg=cst_ENOTSOCK;break;
             case 41:var msg=cst_EDESTADDRREQ;break;
             case 42:var msg=cst_EMSGSIZE;break;
             case 43:var msg=cst_EPROTOTYPE;break;
             case 44:var msg=cst_ENOPROTOOPT;break;
             case 45:var msg=cst_EPROTONOSUPPORT;break;
             case 46:var msg=cst_ESOCKTNOSUPPORT;break;
             case 47:var msg=cst_EOPNOTSUPP;break;
             case 48:var msg=cst_EPFNOSUPPORT;break;
             case 49:var msg=cst_EAFNOSUPPORT;break;
             case 50:var msg=cst_EADDRINUSE;break;
             case 51:var msg=cst_EADDRNOTAVAIL;break;
             case 52:var msg=cst_ENETDOWN;break;
             case 53:var msg=cst_ENETUNREACH;break;
             case 54:var msg=cst_ENETRESET;break;
             case 55:var msg=cst_ECONNABORTED;break;
             case 56:var msg=cst_ECONNRESET;break;
             case 57:var msg=cst_ENOBUFS;break;
             case 58:var msg=cst_EISCONN;break;
             case 59:var msg=cst_ENOTCONN;break;
             case 60:var msg=cst_ESHUTDOWN;break;
             case 61:var msg=cst_ETOOMANYREFS;break;
             case 62:var msg=cst_ETIMEDOUT;break;
             case 63:var msg=cst_ECONNREFUSED;break;
             case 64:var msg=cst_EHOSTDOWN;break;
             case 65:var msg=cst_EHOSTUNREACH;break;
             case 66:var msg=cst_ELOOP;break;
             default:var msg=cst_EOVERFLOW}
          else
           switch(_dx_)
            {case 0:var msg=cst_E2BIG;break;
             case 1:var msg=cst_EACCES;break;
             case 2:var msg=cst_EAGAIN;break;
             case 3:var msg=cst_EBADF;break;
             case 4:var msg=cst_EBUSY;break;
             case 5:var msg=cst_ECHILD;break;
             case 6:var msg=cst_EDEADLK;break;
             case 7:var msg=cst_EDOM;break;
             case 8:var msg=cst_EEXIST;break;
             case 9:var msg=cst_EFAULT;break;
             case 10:var msg=cst_EFBIG;break;
             case 11:var msg=cst_EINTR;break;
             case 12:var msg=cst_EINVAL;break;
             case 13:var msg=cst_EIO;break;
             case 14:var msg=cst_EISDIR;break;
             case 15:var msg=cst_EMFILE;break;
             case 16:var msg=cst_EMLINK;break;
             case 17:var msg=cst_ENAMETOOLONG;break;
             case 18:var msg=cst_ENFILE;break;
             case 19:var msg=cst_ENODEV;break;
             case 20:var msg=cst_ENOENT;break;
             case 21:var msg=cst_ENOEXEC;break;
             case 22:var msg=cst_ENOLCK;break;
             case 23:var msg=cst_ENOMEM;break;
             case 24:var msg=cst_ENOSPC;break;
             case 25:var msg=cst_ENOSYS;break;
             case 26:var msg=cst_ENOTDIR;break;
             case 27:var msg=cst_ENOTEMPTY;break;
             case 28:var msg=cst_ENOTTY;break;
             case 29:var msg=cst_ENXIO;break;
             case 30:var msg=cst_EPERM;break;
             case 31:var msg=cst_EPIPE;break;
             case 32:var msg=cst_ERANGE;break;
             default:var msg=cst_EROFS}}
        else
         var x=e[1],msg=caml_call2(Printf[4],_c_,x);
        return [0,caml_call4(Printf[4],_b_,msg,s$0,s)]}
      return 0}
    caml_call1(Printexc[8],_a_);
    function handle_unix_error(f,arg)
     {try
       {var _dw_=caml_call1(f,arg);return _dw_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Unix_error)
         {var
           arg$0=exn[4],
           fun_name=exn[3],
           err=exn[2],
           _du_=caml_check_bound(Sys[1],0)[1];
          caml_call1(Pervasives[37],_du_);
          caml_call1(Pervasives[37],cst$1);
          caml_call1(Pervasives[37],fun_name);
          caml_call1(Pervasives[37],cst_failed);
          if(0 < caml_ml_string_length(arg$0))
           {caml_call1(Pervasives[37],cst_on);
            caml_call1(Pervasives[37],arg$0);
            caml_call1(Pervasives[37],cst$2)}
          caml_call1(Pervasives[37],cst$3);
          var _dv_=runtime.unix_error_message(err);
          caml_call1(Pervasives[41],_dv_);
          return caml_call1(Pervasives[87],2)}
        throw exn}}
    function execvpe(name,args,env)
     {try
       {var _do_=runtime.unix_execvpe(name,args,env);return _do_}
      catch(_dp_)
       {_dp_ = caml_wrap_exception(_dp_);
        if(_dp_[1] === Unix_error)
         {var _dn_=_dp_[2];
          if(typeof _dn_ === "number")
           if(25 === _dn_)
            {var
              exec=
               function(file)
                {try
                  {var _ds_=runtime.unix_execve(file,args,env);return _ds_}
                 catch(_dt_)
                  {_dt_ = caml_wrap_exception(_dt_);
                   if(_dt_[1] === Unix_error)
                    {var _dr_=_dt_[2];
                     if(typeof _dr_ === "number")
                      if(21 === _dr_)
                       {var
                         argc=args.length - 1,
                         args$0=
                          0 === argc?args:caml_call3(Array[7],args,1,argc - 1 | 0),
                         new_args=caml_call2(Array[5],[0,cst_bin_sh,file],args$0);
                        return runtime.unix_execve
                                (caml_check_bound(new_args,0)[1],new_args,env)}}
                   throw _dt_}};
             if(caml_call2(String[22],name,47))return exec(name);
             try
              {var _dm_=runtime.caml_sys_unsafe_getenv(cst_PATH),_dl_=_dm_}
             catch(_dq_)
              {_dq_ = caml_wrap_exception(_dq_);
               if(_dq_ !== Not_found)throw _dq_;
               var _dl_=cst_bin_usr_bin}
             var
              param$0=caml_call2(String[35],58,_dl_),
              eacces=0,
              param=param$0;
             for(;;)
              {if(param)
                {var
                  rem=param[2],
                  dir=param[1],
                  dir$0=caml_string_equal(dir,cst$4)?Filename[1]:dir;
                 try
                  {var _dj_=exec(caml_call2(Filename[4],dir$0,name));
                   return _dj_}
                 catch(exn)
                  {exn = caml_wrap_exception(exn);
                   if(exn[1] === Unix_error)
                    {var err=exn[2];
                     if(typeof err === "number")
                      {var _di_=err - 62 | 0;
                       if(4 < _di_ >>> 0)
                        if(-35 <= _di_)
                         var switch$0=0;
                        else
                         {var switcher=_di_ + 62 | 0;
                          switch(switcher)
                           {case 1:var eacces=1,param=rem;continue;
                            case 14:
                            case 17:
                            case 19:
                            case 20:
                            case 26:var switch$0=1;break;
                            default:var switch$0=0}}
                       else
                        var switch$0=2 < (_di_ - 1 | 0) >>> 0?1:0;
                       if(switch$0){var param=rem;continue}}
                     throw exn}
                   throw exn}}
               var _dk_=eacces?1:20;
               throw [0,Unix_error,_dk_,cst_execvpe,name]}}}
        throw _dp_}}
    var stdin=0,stdout=1,stderr=2;
    function read(fd,buf,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(buf) - len | 0) < ofs))
         return runtime.unix_read(fd,buf,ofs,len);
      return caml_call1(Pervasives[1],cst_Unix_read)}
    function write(fd,buf,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(buf) - len | 0) < ofs))
         return runtime.unix_write(fd,buf,ofs,len);
      return caml_call1(Pervasives[1],cst_Unix_write)}
    function single_write(fd,buf,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(buf) - len | 0) < ofs))
         return runtime.unix_single_write(fd,buf,ofs,len);
      return caml_call1(Pervasives[1],cst_Unix_single_write)}
    function write_substring(fd,buf,ofs,len)
     {return write(fd,caml_call1(Bytes[43],buf),ofs,len)}
    function single_write_substring(fd,buf,ofs,len)
     {return single_write(fd,caml_call1(Bytes[43],buf),ofs,len)}
    function map_file(fd,opt,kind,layout,shared,dims)
     {if(opt)var sth=opt[1],pos=sth;else var pos=_d_;
      return runtime.caml_unix_map_file_bytecode
              (fd,kind,layout,shared,dims,pos)}
    function pause(param)
     {var sigs=runtime.unix_sigprocmask(1,0);
      return runtime.unix_sigsuspend(sigs)}
    function sleep(duration){return runtime.unix_sleep(duration)}
    var
     inet_addr_any=unix_inet_addr_of_string(cst_0_0_0_0),
     inet_addr_loopback=unix_inet_addr_of_string(cst_127_0_0_1);
    try
     {var _z_=unix_inet_addr_of_string(cst$10),inet_addr_any$0=_z_}
    catch(_dh_)
     {_dh_ = caml_wrap_exception(_dh_);
      if(_dh_[1] !== Failure)throw _dh_;
      var inet_addr_any$0=inet_addr_any}
    try
     {var _y_=unix_inet_addr_of_string(cst_1),inet6_addr_loopback=_y_}
    catch(_dg_)
     {_dg_ = caml_wrap_exception(_dg_);
      if(_dg_[1] !== Failure)throw _dg_;
      var inet6_addr_loopback=inet_addr_loopback}
    function domain_of_sockaddr(param)
     {if(0 === param[0])return 0;
      var a=param[1];
      return 16 === caml_ml_string_length(a)?2:1}
    function recv(fd,buf,ofs,len,flags)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(buf) - len | 0) < ofs))
         return runtime.unix_recv(fd,buf,ofs,len,flags);
      return caml_call1(Pervasives[1],cst_Unix_recv)}
    function recvfrom(fd,buf,ofs,len,flags)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(buf) - len | 0) < ofs))
         return runtime.unix_recvfrom(fd,buf,ofs,len,flags);
      return caml_call1(Pervasives[1],cst_Unix_recvfrom)}
    function send(fd,buf,ofs,len,flags)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(buf) - len | 0) < ofs))
         return runtime.unix_send(fd,buf,ofs,len,flags);
      return caml_call1(Pervasives[1],cst_Unix_send)}
    function sendto(fd,buf,ofs,len,flags,addr)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(buf) - len | 0) < ofs))
         return runtime.unix_sendto(fd,buf,ofs,len,flags,addr);
      return caml_call1(Pervasives[1],cst_Unix_sendto)}
    function send_substring(fd,buf,ofs,len,flags)
     {return send(fd,caml_call1(Bytes[43],buf),ofs,len,flags)}
    function sendto_substring(fd,buf,ofs,len,flags,addr)
     {return sendto(fd,caml_call1(Bytes[43],buf),ofs,len,flags,addr)}
    function getsockopt(fd,opt){return runtime.unix_getsockopt(0,fd,opt)}
    function setsockopt(fd,opt,v){return runtime.unix_setsockopt(0,fd,opt,v)}
    function getsockopt_int(fd,opt){return runtime.unix_getsockopt(1,fd,opt)}
    function setsockopt_int(fd,opt,v)
     {return runtime.unix_setsockopt(1,fd,opt,v)}
    function getsockopt_optint(fd,opt)
     {return runtime.unix_getsockopt(2,fd,opt)}
    function setsockopt_optint(fd,opt,v)
     {return runtime.unix_setsockopt(2,fd,opt,v)}
    function getsockopt_float(fd,opt)
     {return runtime.unix_getsockopt(3,fd,opt)}
    function setsockopt_float(fd,opt,v)
     {return runtime.unix_setsockopt(3,fd,opt,v)}
    function getsockopt_error(fd){return runtime.unix_getsockopt(4,fd,0)}
    function getaddrinfo(node,service,opts)
     {try
       {var
         _c8_=runtime.unix_getaddrinfo(node,service,opts),
         _c9_=caml_call1(List[9],_c8_);
        return _c9_}
      catch(_c__)
       {_c__ = caml_wrap_exception(_c__);
        if(_c__[1] === Invalid_argument)
         {var
           opt_socktype=[0,0],
           opt_protocol=[0,0],
           opt_passive=[0,0],
           _cV_=
            function(param)
             {if(typeof param === "number")
               {if(2 === param){opt_passive[1] = 1;return 0}}
              else
               switch(param[0])
                {case 1:var s=param[1];opt_socktype[1] = [0,s];return 0;
                 case 2:var p=param[1];opt_protocol[1] = p;return 0
                 }
              return 0};
          caml_call2(List[15],_cV_,opts);
          var
           get_port=
            function(ty,kind)
             {if(caml_string_equal(service,cst$5))return [0,[0,ty,0],0];
              try
               {var _dd_=[0,[0,ty,runtime.caml_int_of_string(service)],0];
                return _dd_}
              catch(_de_)
               {_de_ = caml_wrap_exception(_de_);
                if(_de_[1] === Failure)
                 try
                  {var
                    _dc_=
                     [0,[0,ty,runtime.unix_getservbyname(service,kind)[3]],0];
                   return _dc_}
                 catch(_df_)
                  {_df_ = caml_wrap_exception(_df_);
                   if(_df_ === Not_found)return 0;
                   throw _df_}
                throw _de_}},
           _cW_=opt_socktype[1];
          if(_cW_)
           var
            _cX_=_cW_[1],
            _cY_=
             1 === _cX_
              ?get_port(1,cst_udp)
              :0 === _cX_
                ?get_port(0,cst_tcp)
                :caml_string_equal(service,cst$7)?[0,[0,_cX_,0],0]:0,
            ports=_cY_;
          else
           var
            _c6_=get_port(1,cst_udp$0),
            _c7_=get_port(0,cst_tcp$0),
            ports=caml_call2(Pervasives[25],_c7_,_c6_);
          if(caml_string_equal(node,cst$6))
           var
            addresses=
             caml_call2(List[31],2,opts)
              ?[0,[0,inet_addr_any,cst_0_0_0_0$0],0]
              :[0,[0,inet_addr_loopback,cst_127_0_0_1$0],0];
          else
           try
            {var
              _c5_=[0,[0,unix_inet_addr_of_string(node),node],0],
              addresses=_c5_}
           catch(_da_)
            {_da_ = caml_wrap_exception(_da_);
             if(_da_[1] !== Failure)throw _da_;
             try
              {var
                he=runtime.unix_gethostbyname(node),
                _c2_=caml_call1(Array[11],he[4]),
                _c3_=function(a){return [0,a,he[1]]},
                _c4_=caml_call2(List[17],_c3_,_c2_),
                _c1_=_c4_}
             catch(_db_)
              {_db_ = caml_wrap_exception(_db_);
               if(_db_ !== Not_found)throw _db_;
               var _c1_=0}
             var addresses=_c1_}
          var
           _cZ_=
            function(param)
             {var port=param[2],ty=param[1];
              function _c$_(param)
               {var name=param[2],addr=param[1];
                return [0,1,ty,opt_protocol[1],[1,addr,port],name]}
              return caml_call2(List[17],_c$_,addresses)},
           _c0_=caml_call2(List[17],_cZ_,ports);
          return caml_call1(List[14],_c0_)}
        throw _c__}}
    function getnameinfo(addr,opts)
     {try
       {var _cR_=runtime.unix_getnameinfo(addr,opts);return _cR_}
      catch(_cS_)
       {_cS_ = caml_wrap_exception(_cS_);
        if(_cS_[1] === Invalid_argument)
         {if(0 === addr[0]){var f=addr[1];return [0,cst$8,f]}
          var p=addr[2],a=addr[1];
          try
           {if(caml_call2(List[31],1,opts))throw Not_found;
            var _cQ_=runtime.unix_gethostbyaddr(a)[1],hostname=_cQ_}
          catch(_cU_)
           {_cU_ = caml_wrap_exception(_cU_);
            if(_cU_ !== Not_found)throw _cU_;
            if(caml_call2(List[31],2,opts))throw Not_found;
            var hostname=runtime.unix_string_of_inet_addr(a)}
          try
           {if(caml_call2(List[31],3,opts))throw Not_found;
            var
             kind=caml_call2(List[31],4,opts)?cst_udp$1:cst_tcp$1,
             _cP_=runtime.unix_getservbyport(p,kind)[1],
             service=_cP_}
          catch(_cT_)
           {_cT_ = caml_wrap_exception(_cT_);
            if(_cT_ !== Not_found)throw _cT_;
            var service=caml_call1(Pervasives[21],p)}
          return [0,hostname,service]}
        throw _cS_}}
    function waitpid_non_intr(pid)
     {for(;;)
       try
        {var _cN_=runtime.unix_waitpid(0,pid);return _cN_}
       catch(_cO_)
        {_cO_ = caml_wrap_exception(_cO_);
         if(_cO_[1] === Unix_error)
          {var _cM_=_cO_[2];
           if(typeof _cM_ === "number")if(11 === _cM_)continue}
         throw _cO_}}
    function system(cmd)
     {var id=runtime.unix_fork(0);
      if(0 === id)
       try
        {var _cK_=runtime.unix_execv(cst_bin_sh$1,[0,cst_bin_sh$0,cst_c,cmd]);
         return _cK_}
       catch(_cL_){return caml_sys_exit(127)}
      return waitpid_non_intr(id)[2]}
    function file_descr_not_standard(fd)
     {var fd$0=fd;
      for(;;)
       {if(3 <= fd$0)return fd$0;
        var fd$1=runtime.unix_dup(0,fd$0),fd$0=fd$1;
        continue}}
    function safe_close(fd)
     {try
       {var _cI_=runtime.unix_close(fd);return _cI_}
      catch(_cJ_)
       {_cJ_ = caml_wrap_exception(_cJ_);
        if(_cJ_[1] === Unix_error)return 0;
        throw _cJ_}}
    function perform_redirections(new_stdin,new_stdout,new_stderr)
     {var
       new_stdin$0=file_descr_not_standard(new_stdin),
       new_stdout$0=file_descr_not_standard(new_stdout),
       new_stderr$0=file_descr_not_standard(new_stderr);
      runtime.unix_dup2(_e_,new_stdin$0,0);
      runtime.unix_dup2(_f_,new_stdout$0,1);
      runtime.unix_dup2(_g_,new_stderr$0,2);
      safe_close(new_stdin$0);
      safe_close(new_stdout$0);
      return safe_close(new_stderr$0)}
    function create_process(cmd,args,new_stdin,new_stdout,new_stderr)
     {var id=runtime.unix_fork(0);
      if(0 === id)
       try
        {perform_redirections(new_stdin,new_stdout,new_stderr);
         var _cG_=runtime.unix_execvp(cmd,args);
         return _cG_}
       catch(_cH_){return caml_sys_exit(127)}
      return id}
    function create_process_env(cmd,args,env,new_stdin,new_stdout,new_stderr)
     {var id=runtime.unix_fork(0);
      if(0 === id)
       try
        {perform_redirections(new_stdin,new_stdout,new_stderr);
         var _cE_=execvpe(cmd,args,env);
         return _cE_}
       catch(_cF_){return caml_sys_exit(127)}
      return id}
    var popen_processes=caml_call2(Hashtbl[1],0,7);
    function open_proc(cmd,envopt,proc,input,output,error)
     {var id=runtime.unix_fork(0);
      if(0 === id)
       {perform_redirections(input,output,error);
        var argv=[0,shell,cst_c$0,cmd];
        try
         {if(envopt)
           var env=envopt[1],_cC_=runtime.unix_execve(shell,argv,env);
          else
           var _cC_=runtime.unix_execv(shell,argv);
          return _cC_}
        catch(_cD_){return caml_sys_exit(127)}}
      return caml_call3(Hashtbl[5],popen_processes,proc,id)}
    function open_process_in(cmd)
     {var
       match=runtime.unix_pipe(_h_,0),
       in_write=match[2],
       in_read=match[1],
       inchan=caml_ml_open_descriptor_in(in_read);
      try
       {open_proc(cmd,0,[1,inchan],stdin,in_write,stderr)}
      catch(e)
       {e = caml_wrap_exception(e);
        caml_call1(Pervasives[81],inchan);
        runtime.unix_close(in_write);
        throw e}
      runtime.unix_close(in_write);
      return inchan}
    function open_process_out(cmd)
     {var
       match=runtime.unix_pipe(_i_,0),
       out_write=match[2],
       out_read=match[1],
       outchan=caml_ml_open_descriptor_out(out_write);
      try
       {open_proc(cmd,0,[2,outchan],out_read,stdout,stderr)}
      catch(e)
       {e = caml_wrap_exception(e);
        caml_call1(Pervasives[64],outchan);
        runtime.unix_close(out_read);
        throw e}
      runtime.unix_close(out_read);
      return outchan}
    function open_process(cmd)
     {var match=runtime.unix_pipe(_j_,0),in_write=match[2],in_read=match[1];
      try
       {var match$0=runtime.unix_pipe(_k_,0)}
      catch(e)
       {e = caml_wrap_exception(e);
        runtime.unix_close(in_read);
        runtime.unix_close(in_write);
        throw e}
      var
       out_write=match$0[2],
       out_read=match$0[1],
       inchan=caml_ml_open_descriptor_in(in_read),
       outchan=caml_ml_open_descriptor_out(out_write);
      try
       {open_proc(cmd,0,[0,inchan,outchan],out_read,in_write,stderr)}
      catch(e)
       {e = caml_wrap_exception(e);
        runtime.unix_close(out_read);
        runtime.unix_close(out_write);
        runtime.unix_close(in_read);
        runtime.unix_close(in_write);
        throw e}
      runtime.unix_close(out_read);
      runtime.unix_close(in_write);
      return [0,inchan,outchan]}
    function open_process_full(cmd,env)
     {var match=runtime.unix_pipe(_l_,0),in_write=match[2],in_read=match[1];
      try
       {var match$0=runtime.unix_pipe(_m_,0)}
      catch(e)
       {e = caml_wrap_exception(e);
        runtime.unix_close(in_read);
        runtime.unix_close(in_write);
        throw e}
      var out_write=match$0[2],out_read=match$0[1];
      try
       {var match$1=runtime.unix_pipe(_n_,0)}
      catch(e)
       {e = caml_wrap_exception(e);
        runtime.unix_close(in_read);
        runtime.unix_close(in_write);
        runtime.unix_close(out_read);
        runtime.unix_close(out_write);
        throw e}
      var
       err_write=match$1[2],
       err_read=match$1[1],
       inchan=caml_ml_open_descriptor_in(in_read),
       outchan=caml_ml_open_descriptor_out(out_write),
       errchan=caml_ml_open_descriptor_in(err_read);
      try
       {open_proc
         (cmd,[0,env],[3,inchan,outchan,errchan],out_read,in_write,err_write)}
      catch(e)
       {e = caml_wrap_exception(e);
        runtime.unix_close(out_read);
        runtime.unix_close(out_write);
        runtime.unix_close(in_read);
        runtime.unix_close(in_write);
        runtime.unix_close(err_read);
        runtime.unix_close(err_write);
        throw e}
      runtime.unix_close(out_read);
      runtime.unix_close(in_write);
      runtime.unix_close(err_write);
      return [0,inchan,outchan,errchan]}
    function find_proc_id(fun_name,proc)
     {try
       {var pid=caml_call2(Hashtbl[6],popen_processes,proc);
        caml_call2(Hashtbl[10],popen_processes,proc);
        return pid}
      catch(_cB_)
       {_cB_ = caml_wrap_exception(_cB_);
        if(_cB_ === Not_found)throw [0,Unix_error,3,fun_name,cst$9];
        throw _cB_}}
    function close_process_in(inchan)
     {var pid=find_proc_id(cst_close_process_in,[1,inchan]);
      caml_call1(Pervasives[81],inchan);
      return waitpid_non_intr(pid)[2]}
    function close_process_out(outchan)
     {var pid=find_proc_id(cst_close_process_out,[2,outchan]);
      try
       {caml_call1(Pervasives[64],outchan)}
      catch(_cA_)
       {_cA_ = caml_wrap_exception(_cA_);if(_cA_[1] !== Sys_error)throw _cA_}
      return waitpid_non_intr(pid)[2]}
    function close_process(param)
     {var
       outchan=param[2],
       inchan=param[1],
       pid=find_proc_id(cst_close_process,[0,inchan,outchan]);
      caml_call1(Pervasives[81],inchan);
      try
       {caml_call1(Pervasives[64],outchan)}
      catch(_cz_)
       {_cz_ = caml_wrap_exception(_cz_);if(_cz_[1] !== Sys_error)throw _cz_}
      return waitpid_non_intr(pid)[2]}
    function close_process_full(param)
     {var
       errchan=param[3],
       outchan=param[2],
       inchan=param[1],
       pid=find_proc_id(cst_close_process_full,[3,inchan,outchan,errchan]);
      caml_call1(Pervasives[81],inchan);
      try
       {caml_call1(Pervasives[64],outchan)}
      catch(_cy_)
       {_cy_ = caml_wrap_exception(_cy_);if(_cy_[1] !== Sys_error)throw _cy_}
      caml_call1(Pervasives[81],errchan);
      return waitpid_non_intr(pid)[2]}
    function open_connection(sockaddr)
     {var sock=runtime.unix_socket(_o_,domain_of_sockaddr(sockaddr),0,0);
      try
       {runtime.unix_connect(sock,sockaddr);
        var
         _cw_=caml_ml_open_descriptor_out(sock),
         _cx_=[0,caml_ml_open_descriptor_in(sock),_cw_];
        return _cx_}
      catch(exn)
       {exn = caml_wrap_exception(exn);runtime.unix_close(sock);throw exn}}
    function shutdown_connection(inchan)
     {return runtime.unix_shutdown(runtime.caml_channel_descriptor(inchan),1)}
    function accept_non_intr(s)
     {for(;;)
       try
        {var _cu_=runtime.unix_accept(_p_,s);return _cu_}
       catch(_cv_)
        {_cv_ = caml_wrap_exception(_cv_);
         if(_cv_[1] === Unix_error)
          {var _ct_=_cv_[2];
           if(typeof _ct_ === "number")if(11 === _ct_)continue}
         throw _cv_}}
    function establish_server(server_fun,sockaddr)
     {var sock=runtime.unix_socket(_q_,domain_of_sockaddr(sockaddr),0,0);
      runtime.unix_setsockopt(0,sock,2,1);
      runtime.unix_bind(sock,sockaddr);
      runtime.unix_listen(sock,5);
      for(;;)
       {var match=accept_non_intr(sock),s=match[1],id=runtime.unix_fork(0);
        if(0 === id)
         {if(0 !== runtime.unix_fork(0))caml_sys_exit(0);
          runtime.unix_close(sock);
          var
           inchan=caml_ml_open_descriptor_in(s),
           outchan=caml_ml_open_descriptor_out(s);
          caml_call2(server_fun,inchan,outchan);
          caml_call1(Pervasives[87],0)}
        else
         {runtime.unix_close(s);waitpid_non_intr(id)}
        continue}}
    function setsid(_cs_){return runtime.unix_setsid(_cs_)}
    function tcflow(_cr_,_cq_){return runtime.unix_tcflow(_cr_,_cq_)}
    function tcflush(_cp_,_co_){return runtime.unix_tcflush(_cp_,_co_)}
    function tcdrain(_cn_){return runtime.unix_tcdrain(_cn_)}
    function tcsendbreak(_cm_,_cl_)
     {return runtime.unix_tcsendbreak(_cm_,_cl_)}
    function tcsetattr(_ck_,_cj_,_ci_)
     {return runtime.unix_tcsetattr(_ck_,_cj_,_ci_)}
    function tcgetattr(_ch_){return runtime.unix_tcgetattr(_ch_)}
    function getservbyport(_cg_,_cf_)
     {return runtime.unix_getservbyport(_cg_,_cf_)}
    function getservbyname(_ce_,_cd_)
     {return runtime.unix_getservbyname(_ce_,_cd_)}
    function getprotobynumber(_cc_)
     {return runtime.unix_getprotobynumber(_cc_)}
    function getprotobyname(_cb_){return runtime.unix_getprotobyname(_cb_)}
    function gethostbyaddr(_ca_){return runtime.unix_gethostbyaddr(_ca_)}
    function gethostbyname(_b$_){return runtime.unix_gethostbyname(_b$_)}
    function gethostname(_b__){return runtime.unix_gethostname(_b__)}
    function getpeername(_b9_){return runtime.unix_getpeername(_b9_)}
    function getsockname(_b8_){return runtime.unix_getsockname(_b8_)}
    function shutdown(_b7_,_b6_){return runtime.unix_shutdown(_b7_,_b6_)}
    function listen(_b5_,_b4_){return runtime.unix_listen(_b5_,_b4_)}
    function connect(_b3_,_b2_){return runtime.unix_connect(_b3_,_b2_)}
    function bind(_b1_,_b0_){return runtime.unix_bind(_b1_,_b0_)}
    function accept(_bZ_,_bY_){return runtime.unix_accept(_bZ_,_bY_)}
    function socketpair(_bX_,_bW_,_bV_,_bU_)
     {return runtime.unix_socketpair(_bX_,_bW_,_bV_,_bU_)}
    function socket(_bT_,_bS_,_bR_,_bQ_)
     {return runtime.unix_socket(_bT_,_bS_,_bR_,_bQ_)}
    function string_of_inet_addr(_bP_)
     {return runtime.unix_string_of_inet_addr(_bP_)}
    function inet_addr_of_string(_bO_){return unix_inet_addr_of_string(_bO_)}
    function getgrgid(_bN_){return runtime.unix_getgrgid(_bN_)}
    function getpwuid(_bM_){return runtime.unix_getpwuid(_bM_)}
    function getgrnam(_bL_){return runtime.unix_getgrnam(_bL_)}
    function getpwnam(_bK_){return runtime.unix_getpwnam(_bK_)}
    function getlogin(_bJ_){return runtime.unix_getlogin(_bJ_)}
    function initgroups(_bI_,_bH_){return runtime.unix_initgroups(_bI_,_bH_)}
    function setgroups(_bG_){return runtime.unix_setgroups(_bG_)}
    function getgroups(_bF_){return runtime.unix_getgroups(_bF_)}
    function setgid(_bE_){return runtime.unix_setgid(_bE_)}
    function getegid(_bD_){return runtime.unix_getegid(_bD_)}
    function getgid(_bC_){return runtime.unix_getgid(_bC_)}
    function setuid(_bB_){return runtime.unix_setuid(_bB_)}
    function geteuid(_bA_){return runtime.unix_geteuid(_bA_)}
    function getuid(_bz_){return runtime.unix_getuid(_bz_)}
    function setitimer(_by_,_bx_){return runtime.unix_setitimer(_by_,_bx_)}
    function getitimer(_bw_){return runtime.unix_getitimer(_bw_)}
    function utimes(_bv_,_bu_,_bt_)
     {return runtime.unix_utimes(_bv_,_bu_,_bt_)}
    function times(_bs_){return runtime.unix_times(_bs_)}
    function _r_(_br_){return runtime.unix_sleep(_br_)}
    function alarm(_bq_){return runtime.unix_alarm(_bq_)}
    var
     mktime=runtime.unix_mktime,
     localtime=runtime.unix_localtime,
     gmtime=runtime.unix_gmtime;
    function gettimeofday(_bp_){return runtime.unix_gettimeofday(_bp_)}
    function time(_bo_){return runtime.unix_time(_bo_)}
    function sigsuspend(_bn_){return runtime.unix_sigsuspend(_bn_)}
    function sigpending(_bm_){return runtime.unix_sigpending(_bm_)}
    function sigprocmask(_bl_,_bk_)
     {return runtime.unix_sigprocmask(_bl_,_bk_)}
    function kill(_bj_,_bi_){return runtime.unix_kill(_bj_,_bi_)}
    function lockf(_bh_,_bg_,_bf_){return runtime.unix_lockf(_bh_,_bg_,_bf_)}
    function select(_be_,_bd_,_bc_,_bb_)
     {return runtime.unix_select(_be_,_bd_,_bc_,_bb_)}
    function readlink(_ba_){return runtime.unix_readlink(_ba_)}
    function has_symlink(_a$_){return runtime.unix_has_symlink(_a$_)}
    function symlink(_a__,_a9_,_a8_)
     {return runtime.unix_symlink(_a__,_a9_,_a8_)}
    function mkfifo(_a7_,_a6_){return runtime.unix_mkfifo(_a7_,_a6_)}
    function pipe(_a5_,_a4_){return runtime.unix_pipe(_a5_,_a4_)}
    function closedir(_a3_){return runtime.unix_closedir(_a3_)}
    function rewinddir(_a2_){return runtime.unix_rewinddir(_a2_)}
    function readdir(_a1_){return runtime.unix_readdir(_a1_)}
    function opendir(_a0_){return runtime.unix_opendir(_a0_)}
    function chroot(_aZ_){return runtime.unix_chroot(_aZ_)}
    function getcwd(_aY_){return runtime.unix_getcwd(_aY_)}
    function chdir(_aX_){return runtime.unix_chdir(_aX_)}
    function rmdir(_aW_){return runtime.unix_rmdir(_aW_)}
    function mkdir(_aV_,_aU_){return runtime.unix_mkdir(_aV_,_aU_)}
    function clear_close_on_exec(_aT_)
     {return runtime.unix_clear_close_on_exec(_aT_)}
    function set_close_on_exec(_aS_)
     {return runtime.unix_set_close_on_exec(_aS_)}
    function clear_nonblock(_aR_){return runtime.unix_clear_nonblock(_aR_)}
    function set_nonblock(_aQ_){return runtime.unix_set_nonblock(_aQ_)}
    function dup2(_aP_,_aO_,_aN_){return runtime.unix_dup2(_aP_,_aO_,_aN_)}
    function dup(_aM_,_aL_){return runtime.unix_dup(_aM_,_aL_)}
    function access(_aK_,_aJ_){return runtime.unix_access(_aK_,_aJ_)}
    function umask(_aI_){return runtime.unix_umask(_aI_)}
    function fchown(_aH_,_aG_,_aF_)
     {return runtime.unix_fchown(_aH_,_aG_,_aF_)}
    function chown(_aE_,_aD_,_aC_){return runtime.unix_chown(_aE_,_aD_,_aC_)}
    function fchmod(_aB_,_aA_){return runtime.unix_fchmod(_aB_,_aA_)}
    function chmod(_az_,_ay_){return runtime.unix_chmod(_az_,_ay_)}
    function link(_ax_,_aw_){return runtime.unix_link(_ax_,_aw_)}
    function rename(_av_,_au_){return runtime.unix_rename(_av_,_au_)}
    function unlink(_at_){return runtime.unix_unlink(_at_)}
    function _s_(_as_){return runtime.unix_fstat_64(_as_)}
    function _t_(_ar_){return runtime.unix_lstat_64(_ar_)}
    function _u_(_aq_){return runtime.unix_stat_64(_aq_)}
    function _v_(_ap_,_ao_){return runtime.unix_ftruncate_64(_ap_,_ao_)}
    function _w_(_an_,_am_){return runtime.unix_truncate_64(_an_,_am_)}
    var
     LargeFile=
      [0,
       function(_al_,_ak_,_aj_){return runtime.unix_lseek_64(_al_,_ak_,_aj_)},
       _w_,
       _v_,
       _u_,
       _t_,
       _s_];
    function isatty(_ai_){return runtime.unix_isatty(_ai_)}
    function fstat(_ah_){return runtime.unix_fstat(_ah_)}
    function lstat(_ag_){return runtime.unix_lstat(_ag_)}
    function stat(_af_){return runtime.unix_stat(_af_)}
    function ftruncate(_ae_,_ad_){return runtime.unix_ftruncate(_ae_,_ad_)}
    function truncate(_ac_,_ab_){return runtime.unix_truncate(_ac_,_ab_)}
    function lseek(_aa_,_$_,___){return runtime.unix_lseek(_aa_,_$_,___)}
    function descr_of_out_channel(_Z_)
     {return runtime.caml_channel_descriptor(_Z_)}
    function descr_of_in_channel(_Y_)
     {return runtime.caml_channel_descriptor(_Y_)}
    var
     out_channel_of_descr=caml_ml_open_descriptor_out,
     in_channel_of_descr=caml_ml_open_descriptor_in;
    function close(_X_){return runtime.unix_close(_X_)}
    function openfile(_W_,_V_,_U_){return runtime.unix_open(_W_,_V_,_U_)}
    function nice(_T_){return runtime.unix_nice(_T_)}
    function getppid(_S_){return runtime.unix_getppid(_S_)}
    function getpid(_R_){return runtime.unix_getpid(_R_)}
    function waitpid(_Q_,_P_){return runtime.unix_waitpid(_Q_,_P_)}
    function wait(_O_){return runtime.unix_wait(_O_)}
    function fork(_N_){return runtime.unix_fork(_N_)}
    function execvp(_M_,_L_){return runtime.unix_execvp(_M_,_L_)}
    function execve(_K_,_J_,_I_){return runtime.unix_execve(_K_,_J_,_I_)}
    function execv(_H_,_G_){return runtime.unix_execv(_H_,_G_)}
    function putenv(_F_,_E_){return runtime.unix_putenv(_F_,_E_)}
    function unsafe_getenv(_D_){return runtime.caml_sys_unsafe_getenv(_D_)}
    var getenv=runtime.caml_sys_getenv;
    function _x_(_C_){return runtime.unix_environment_unsafe(_C_)}
    function environment(_B_){return runtime.unix_environment(_B_)}
    function error_message(_A_){return runtime.unix_error_message(_A_)}
    var
     include=
      [0,
       Unix_error,
       error_message,
       handle_unix_error,
       environment,
       _x_,
       getenv,
       unsafe_getenv,
       putenv,
       execv,
       execve,
       execvp,
       execvpe,
       fork,
       wait,
       waitpid,
       system,
       getpid,
       getppid,
       nice,
       stdin,
       stdout,
       stderr,
       openfile,
       close,
       read,
       write,
       single_write,
       write_substring,
       single_write_substring,
       in_channel_of_descr,
       out_channel_of_descr,
       descr_of_in_channel,
       descr_of_out_channel,
       lseek,
       truncate,
       ftruncate,
       stat,
       lstat,
       fstat,
       isatty,
       LargeFile,
       map_file,
       unlink,
       rename,
       link,
       chmod,
       fchmod,
       chown,
       fchown,
       umask,
       access,
       dup,
       dup2,
       set_nonblock,
       clear_nonblock,
       set_close_on_exec,
       clear_close_on_exec,
       mkdir,
       rmdir,
       chdir,
       getcwd,
       chroot,
       opendir,
       readdir,
       rewinddir,
       closedir,
       pipe,
       mkfifo,
       create_process,
       create_process_env,
       open_process_in,
       open_process_out,
       open_process,
       open_process_full,
       close_process_in,
       close_process_out,
       close_process,
       close_process_full,
       symlink,
       has_symlink,
       readlink,
       select,
       lockf,
       kill,
       sigprocmask,
       sigpending,
       sigsuspend,
       pause,
       time,
       gettimeofday,
       gmtime,
       localtime,
       mktime,
       alarm,
       sleep,
       _r_,
       times,
       utimes,
       getitimer,
       setitimer,
       getuid,
       geteuid,
       setuid,
       getgid,
       getegid,
       setgid,
       getgroups,
       setgroups,
       initgroups,
       getlogin,
       getpwnam,
       getgrnam,
       getpwuid,
       getgrgid,
       inet_addr_of_string,
       string_of_inet_addr,
       inet_addr_any,
       inet_addr_loopback,
       inet_addr_any$0,
       inet6_addr_loopback,
       socket,
       domain_of_sockaddr,
       socketpair,
       accept,
       bind,
       connect,
       listen,
       shutdown,
       getsockname,
       getpeername,
       recv,
       recvfrom,
       send,
       send_substring,
       sendto,
       sendto_substring,
       getsockopt,
       setsockopt,
       getsockopt_int,
       setsockopt_int,
       getsockopt_optint,
       setsockopt_optint,
       getsockopt_float,
       setsockopt_float,
       getsockopt_error,
       open_connection,
       shutdown_connection,
       establish_server,
       gethostname,
       gethostbyname,
       gethostbyaddr,
       getprotobyname,
       getprotobynumber,
       getservbyname,
       getservbyport,
       getaddrinfo,
       getnameinfo,
       tcgetattr,
       tcsetattr,
       tcsendbreak,
       tcdrain,
       tcflush,
       tcflow,
       setsid];
    caml_register_global(146,include,"Unix");
    var
     UnixLabels=
      [0,
       Unix_error,
       error_message,
       handle_unix_error,
       environment,
       getenv,
       unsafe_getenv,
       putenv,
       execv,
       execve,
       execvp,
       execvpe,
       fork,
       wait,
       waitpid,
       system,
       getpid,
       getppid,
       nice,
       stdin,
       stdout,
       stderr,
       openfile,
       close,
       read,
       write,
       single_write,
       write_substring,
       single_write_substring,
       in_channel_of_descr,
       out_channel_of_descr,
       descr_of_in_channel,
       descr_of_out_channel,
       lseek,
       truncate,
       ftruncate,
       stat,
       lstat,
       fstat,
       isatty,
       LargeFile,
       map_file,
       unlink,
       rename,
       link,
       chmod,
       fchmod,
       chown,
       fchown,
       umask,
       access,
       dup,
       dup2,
       set_nonblock,
       clear_nonblock,
       set_close_on_exec,
       clear_close_on_exec,
       mkdir,
       rmdir,
       chdir,
       getcwd,
       chroot,
       opendir,
       readdir,
       rewinddir,
       closedir,
       pipe,
       mkfifo,
       create_process,
       create_process_env,
       open_process_in,
       open_process_out,
       open_process,
       open_process_full,
       close_process_in,
       close_process_out,
       close_process,
       close_process_full,
       symlink,
       has_symlink,
       readlink,
       select,
       lockf,
       kill,
       sigprocmask,
       sigpending,
       sigsuspend,
       pause,
       time,
       gettimeofday,
       gmtime,
       localtime,
       mktime,
       alarm,
       sleep,
       times,
       utimes,
       getitimer,
       setitimer,
       getuid,
       geteuid,
       setuid,
       getgid,
       getegid,
       setgid,
       getgroups,
       setgroups,
       initgroups,
       getlogin,
       getpwnam,
       getgrnam,
       getpwuid,
       getgrgid,
       inet_addr_of_string,
       string_of_inet_addr,
       inet_addr_any,
       inet_addr_loopback,
       inet_addr_any$0,
       inet6_addr_loopback,
       socket,
       domain_of_sockaddr,
       socketpair,
       accept,
       bind,
       connect,
       listen,
       shutdown,
       getsockname,
       getpeername,
       recv,
       recvfrom,
       send,
       send_substring,
       sendto,
       sendto_substring,
       getsockopt,
       setsockopt,
       getsockopt_int,
       setsockopt_int,
       getsockopt_optint,
       setsockopt_optint,
       getsockopt_float,
       setsockopt_float,
       getsockopt_error,
       open_connection,
       shutdown_connection,
       establish_server,
       gethostname,
       gethostbyname,
       gethostbyaddr,
       getprotobyname,
       getprotobynumber,
       getservbyname,
       getservbyport,
       getaddrinfo,
       getnameinfo,
       tcgetattr,
       tcsetattr,
       tcsendbreak,
       tcdrain,
       tcflush,
       tcflow,
       setsid];
    caml_register_global(147,UnixLabels,"UnixLabels");
    return}
  (function(){return this}()));


//# 1 "../.js/str/str.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_bytes_get=runtime.caml_bytes_get,
     caml_bytes_set=runtime.caml_bytes_set,
     caml_check_bound=runtime.caml_check_bound,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_make_vect=runtime.caml_make_vect,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_new_string=runtime.caml_new_string,
     caml_string_equal=runtime.caml_string_equal,
     caml_string_get=runtime.caml_string_get,
     caml_trampoline=runtime.caml_trampoline,
     caml_trampoline_return=runtime.caml_trampoline_return,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst=caml_new_string(""),
     cst$0=caml_new_string(""),
     cst$5=caml_new_string(""),
     cst$4=caml_new_string(""),
     cst$3=caml_new_string(""),
     cst_Str_matched_group=caml_new_string("Str.matched_group"),
     cst_Str_group_end=caml_new_string("Str.group_end"),
     cst_Str_group_beginning=caml_new_string("Str.group_beginning"),
     cst_group_not_closed_by=caml_new_string("\\( group not closed by \\)"),
     cst_class_not_closed_by=caml_new_string("[ class not closed by ]"),
     cst_spurious_in_regular_expression=
      caml_new_string("spurious \\) in regular expression"),
     cst_too_many_r_or_r_where_r_is_nullable=
      caml_new_string("too many r* or r+ where r is nullable"),
     cst$1=caml_new_string(""),
     cst$2=caml_new_string(""),
     List=global_data.List,
     String=global_data.String,
     Not_found=global_data.Not_found,
     Pervasives=global_data.Pervasives,
     Bytes=global_data.Bytes,
     Assert_failure=global_data.Assert_failure,
     Buffer=global_data.Buffer,
     Char=global_data.Char,
     Array=global_data.Array,
     Map=global_data.Map,
     _b_=[0,92],
     _c_=[0,caml_new_string("str.ml"),520,10],
     _a_=[0,caml_new_string("str.ml"),213,11];
    function string_before(s,n){return caml_call3(String[4],s,0,n)}
    function string_after(s,n)
     {return caml_call3(String[4],s,n,caml_ml_string_length(s) - n | 0)}
    function first_chars(s,n){return caml_call3(String[4],s,0,n)}
    function last_chars(s,n)
     {return caml_call3(String[4],s,caml_ml_string_length(s) - n | 0,n)}
    var full=caml_call2(Bytes[1],32,255);
    function make_empty(param){return caml_call2(Bytes[1],32,0)}
    function add(s,i)
     {var _ao_=caml_bytes_get(s,i >>> 3 | 0) | 1 << (i & 7);
      return caml_bytes_set(s,i >>> 3 | 0,caml_call1(Char[1],_ao_))}
    function singleton(c){var s=make_empty(0);add(s,c);return s}
    function complement(s)
     {var r=caml_create_bytes(32),i=0;
      for(;;)
       {var _am_=caml_bytes_get(s,i) ^ 255;
        caml_bytes_set(r,i,caml_call1(Char[1],_am_));
        var _an_=i + 1 | 0;
        if(31 !== i){var i=_an_;continue}
        return r}}
    function union(s1,s2)
     {var r=caml_create_bytes(32),i=0;
      for(;;)
       {var _aj_=caml_bytes_get(s2,i),_ak_=caml_bytes_get(s1,i) | _aj_;
        caml_bytes_set(r,i,caml_call1(Char[1],_ak_));
        var _al_=i + 1 | 0;
        if(31 !== i){var i=_al_;continue}
        return r}}
    function disjoint(s1,s2)
     {try
       {var i=0;
        for(;;)
         {var _ag_=caml_bytes_get(s2,i);
          if(0 !== (caml_bytes_get(s1,i) & _ag_))throw Pervasives[3];
          var _ah_=i + 1 | 0;
          if(31 !== i){var i=_ah_;continue}
          var _af_=1;
          return _af_}}
      catch(_ai_)
       {_ai_ = caml_wrap_exception(_ai_);
        if(_ai_ === Pervasives[3])return 0;
        throw _ai_}}
    function iter(fn,s)
     {var i=0;
      for(;;)
       {var c=caml_bytes_get(s,i);
        if(0 !== c)
         {var j=0;
          for(;;)
           {if(0 !== (c & 1 << j))
             caml_call1(fn,caml_call1(Char[1],(i << 3) + j | 0));
            var _ae_=j + 1 | 0;
            if(7 !== j){var j=_ae_;continue}
            break}}
        var _ad_=i + 1 | 0;
        if(31 !== i){var i=_ad_;continue}
        return 0}}
    function fold_case(s)
     {var r=make_empty(0);
      iter
       (function(c)
         {add(r,caml_call1(Char[3],c));return add(r,caml_call1(Char[4],c))},
        s);
      return r}
    var
     op_CHAR=0,
     op_CHARNORM=1,
     op_STRING=2,
     op_STRINGNORM=3,
     op_CHARCLASS=4,
     op_BOL=5,
     op_EOL=6,
     op_WORDBOUNDARY=7,
     op_BEGGROUP=8,
     op_ENDGROUP=9,
     op_REFGROUP=10,
     op_ACCEPT=11,
     op_SIMPLEOPT=12,
     op_SIMPLESTAR=13,
     op_SIMPLEPLUS=14,
     op_GOTO=15,
     op_PUSHBACK=16,
     op_SETMARK=17,
     op_CHECKPROGRESS=18;
    function instr(opc,arg){return opc | arg << 8}
    function displ(dest,from){return (dest - from | 0) - 1 | 0}
    function is_nullable(param)
     {var param$0=param;
      for(;;)
       if(typeof param$0 === "number")
        switch(param$0){case 0:return 1;case 1:return 1;default:return 1}
       else
        switch(param$0[0])
         {case 0:return 0;
          case 1:var s=param$0[1];return caml_string_equal(s,cst);
          case 2:return 0;
          case 3:var rl=param$0[1];return caml_call2(List[27],is_nullable,rl);
          case 4:
           var r2=param$0[2],r1=param$0[1],_ac_=is_nullable(r1);
           if(_ac_)return _ac_;
           var param$0=r2;
           continue;
          case 5:return 1;
          case 6:var param$1=param$0[1],param$0=param$1;continue;
          case 7:return 1;
          case 8:var param$2=param$0[2],param$0=param$2;continue;
          default:return 1}}
    function first$0(counter,param)
     {var param$0=param;
      for(;;)
       if(typeof param$0 === "number")
        switch(param$0)
         {case 0:return full;case 1:return full;default:return full}
       else
        switch(param$0[0])
         {case 0:var c=param$0[1];return singleton(c);
          case 1:
           var s=param$0[1];
           return caml_string_equal(s,cst$0)
                   ?full
                   :singleton(caml_string_get(s,0));
          case 2:
           var cmpl=param$0[2],cl=param$0[1];return cmpl?complement(cl):cl;
          case 3:
           var rl=param$0[1];
           if(counter < 50)
            {var counter$0=counter + 1 | 0;return first_seq$0(counter$0,rl)}
           return caml_trampoline_return(first_seq$0,[0,rl]);
          case 4:
           var r2=param$0[2],r1=param$0[1],_ab_=first(r2);
           return union(first(r1),_ab_);
          case 5:return full;
          case 6:var param$1=param$0[1],param$0=param$1;continue;
          case 7:return full;
          case 8:var param$2=param$0[2],param$0=param$2;continue;
          default:return full}}
    function first_seq$0(counter,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var ___=param$0[1];
          if(typeof ___ === "number")
           {var param$1=param$0[2],param$0=param$1;continue}
          else
           switch(___[0])
            {case 5:
              var rl=param$0[2],r=___[1],_$_=first_seq(rl);
              return union(first(r),_$_);
             case 7:
              var rl$0=param$0[2],r$0=___[1],_aa_=first_seq(rl$0);
              return union(first(r$0),_aa_);
             default:
              if(counter < 50)
               {var counter$0=counter + 1 | 0;return first$0(counter$0,___)}
              return caml_trampoline_return(first$0,[0,___])}}
        return full}}
    function first(param){return caml_trampoline(first$0(0,param))}
    function first_seq(param){return caml_trampoline(first_seq$0(0,param))}
    function charclass_of_regexp(fold_case$0,re)
     {if(typeof re === "number")
       var switch$0=0;
      else
       switch(re[0])
        {case 0:var c=re[1],match=[0,singleton(c),0],switch$0=1;break;
         case 2:
          var compl$0=re[2],cl=re[1],match=[0,cl,compl$0],switch$0=1;break;
         default:var switch$0=0}
      if(switch$0)
       {var
         compl=match[2],
         cl1=match[1],
         cl2=fold_case$0?fold_case(cl1):cl1,
         _Z_=compl?complement(cl2):cl2;
        return caml_call1(Bytes[6],_Z_)}
      throw [0,Assert_failure,_a_]}
    var t=caml_create_bytes(256),i=0;
    for(;;)
     {var _d_=caml_call1(Char[1],i);
      caml_bytes_set(t,i,caml_call1(Char[3],_d_));
      var _e_=i + 1 | 0;
      if(255 !== i){var i=_e_;continue}
      var
       fold_case_table=caml_call1(Bytes[6],t),
       compare=runtime.caml_string_compare,
       StringMap=caml_call1(Map[1],[0,compare]),
       compile=
        function(fold_case$0,re)
         {var
           prog=[0,caml_make_vect(32,0)],
           progpos=[0,0],
           cpool=[0,StringMap[1]],
           cpoolpos=[0,0],
           numgroups=[0,1],
           numregs=[0,0];
          function emit_instr(opc,arg)
           {if(prog[1].length - 1 <= progpos[1])
             {var newlen=[0,prog[1].length - 1];
              for(;;)
               {if(newlen[1] <= progpos[1])
                 {newlen[1] = newlen[1] * 2 | 0;continue}
                var nprog=caml_make_vect(newlen[1],0);
                caml_call5(Array[10],prog[1],0,nprog,0,prog[1].length - 1);
                prog[1] = nprog;
                break}}
            var _X_=instr(opc,arg),_Y_=progpos[1];
            caml_check_bound(prog[1],_Y_)[1 + _Y_] = _X_;
            progpos[1]++;
            return 0}
          function emit_hole(param)
           {var p=progpos[1];emit_instr(op_CHAR,0);return p}
          function patch_instr(pos,opc,dest)
           {var _W_=instr(opc,displ(dest,pos));
            caml_check_bound(prog[1],pos)[1 + pos] = _W_;
            return 0}
          function cpool_index(s)
           {try
             {var _U_=caml_call2(StringMap[27],s,cpool[1]);return _U_}
            catch(_V_)
             {_V_ = caml_wrap_exception(_V_);
              if(_V_ === Not_found)
               {var p=cpoolpos[1];
                cpool[1] = caml_call3(StringMap[4],s,p,cpool[1]);
                cpoolpos[1]++;
                return p}
              throw _V_}}
          function allocate_register_if_nullable(r)
           {if(is_nullable(r))
             {var n=numregs[1];
              if(64 <= n)
               caml_call1
                (Pervasives[2],cst_too_many_r_or_r_where_r_is_nullable);
              numregs[1]++;
              return n}
            return -1}
          function emit_seq_code(param)
           {var param$0=param;
            for(;;)
             {if(param$0)
               {var _N_=param$0[1];
                if(typeof _N_ !== "number")
                 switch(_N_[0])
                  {case 5:
                    var _O_=_N_[1];
                    if(typeof _O_ === "number")
                     var switch$0=0;
                    else
                     switch(_O_[0])
                      {case 0:
                       case 2:
                        var rl$0=param$0[2],_P_=first_seq(rl$0);
                        if(disjoint_modulo_case(first(_O_),_P_))
                         {emit_instr
                           (op_SIMPLESTAR,
                            cpool_index(charclass_of_regexp(fold_case$0,_O_)));
                          var param$0=rl$0;
                          continue}
                        var switch$0=1;
                        break;
                       default:var switch$0=0}
                    break;
                   case 6:
                    var _Q_=_N_[1];
                    if(typeof _Q_ === "number")
                     var switch$1=0;
                    else
                     switch(_Q_[0])
                      {case 0:
                       case 2:
                        var rl$1=param$0[2],_R_=first_seq(rl$1);
                        if(disjoint_modulo_case(first(_Q_),_R_))
                         {emit_instr
                           (op_SIMPLEPLUS,
                            cpool_index(charclass_of_regexp(fold_case$0,_Q_)));
                          var param$0=rl$1;
                          continue}
                        var switch$1=1;
                        break;
                       default:var switch$1=0}
                    break;
                   case 7:
                    var _S_=_N_[1];
                    if(typeof _S_ === "number")
                     var switch$2=0;
                    else
                     switch(_S_[0])
                      {case 0:
                       case 2:
                        var rl$2=param$0[2],_T_=first_seq(rl$2);
                        if(disjoint_modulo_case(first(_S_),_T_))
                         {emit_instr
                           (op_SIMPLEOPT,
                            cpool_index(charclass_of_regexp(fold_case$0,_S_)));
                          var param$0=rl$2;
                          continue}
                        var switch$2=1;
                        break;
                       default:var switch$2=0}
                    break
                   }
                var rl=param$0[2];
                emit_code(_N_);
                var param$0=rl;
                continue}
              return 0}}
          function emit_code(param)
           {if(typeof param === "number")
             switch(param)
              {case 0:return emit_instr(op_BOL,0);
               case 1:return emit_instr(op_EOL,0);
               default:return emit_instr(op_WORDBOUNDARY,0)}
            else
             switch(param[0])
              {case 0:
                var c=param[1];
                return fold_case$0
                        ?emit_instr(op_CHARNORM,caml_call1(Char[3],c))
                        :emit_instr(op_CHAR,c);
               case 1:
                var s=param[1],match=caml_ml_string_length(s);
                if(0 === match)return 0;
                if(1 === match)
                 {if(fold_case$0)
                   {var _K_=caml_string_get(s,0);
                    return emit_instr(op_CHARNORM,caml_call1(Char[3],_K_))}
                  return emit_instr(op_CHAR,caml_string_get(s,0))}
                try
                 {var i=caml_call2(String[14],s,0);
                  emit_code([1,string_before(s,i)]);
                  emit_instr(op_CHAR,0);
                  var _L_=emit_code([1,string_after(s,i + 1 | 0)]);
                  return _L_}
                catch(_M_)
                 {_M_ = caml_wrap_exception(_M_);
                  if(_M_ === Not_found)
                   return fold_case$0
                           ?emit_instr
                             (op_STRINGNORM,cpool_index(caml_call1(String[26],s)))
                           :emit_instr(op_STRING,cpool_index(s));
                  throw _M_}
               case 2:
                var
                 compl=param[2],
                 cl=param[1],
                 cl1=fold_case$0?fold_case(cl):cl,
                 cl2=compl?complement(cl1):cl1;
                return emit_instr
                        (op_CHARCLASS,cpool_index(caml_call1(Bytes[6],cl2)));
               case 3:var rl=param[1];return emit_seq_code(rl);
               case 4:
                var r2=param[2],r1=param[1],pos_pushback=emit_hole(0);
                emit_code(r1);
                var pos_goto_end=emit_hole(0),lbl1=progpos[1];
                emit_code(r2);
                var lbl2=progpos[1];
                patch_instr(pos_pushback,op_PUSHBACK,lbl1);
                return patch_instr(pos_goto_end,op_GOTO,lbl2);
               case 5:
                var
                 r=param[1],
                 regno=allocate_register_if_nullable(r),
                 lbl1$0=emit_hole(0);
                if(0 <= regno)emit_instr(op_SETMARK,regno);
                emit_code(r);
                if(0 <= regno)emit_instr(op_CHECKPROGRESS,regno);
                emit_instr(op_GOTO,displ(lbl1$0,progpos[1]));
                var lbl2$0=progpos[1];
                return patch_instr(lbl1$0,op_PUSHBACK,lbl2$0);
               case 6:
                var
                 r$0=param[1],
                 regno$0=allocate_register_if_nullable(r$0),
                 lbl1$1=progpos[1];
                emit_code(r$0);
                if(0 <= regno$0)emit_instr(op_CHECKPROGRESS,regno$0);
                var pos_pushback$0=emit_hole(0);
                if(0 <= regno$0)emit_instr(op_SETMARK,regno$0);
                emit_instr(op_GOTO,displ(lbl1$1,progpos[1]));
                var lbl2$1=progpos[1];
                return patch_instr(pos_pushback$0,op_PUSHBACK,lbl2$1);
               case 7:
                var r$1=param[1],pos_pushback$1=emit_hole(0);
                emit_code(r$1);
                var lbl=progpos[1];
                return patch_instr(pos_pushback$1,op_PUSHBACK,lbl);
               case 8:
                var r$2=param[2],n=param[1];
                emit_instr(op_BEGGROUP,n);
                emit_code(r$2);
                emit_instr(op_ENDGROUP,n);
                numgroups[1]
                =
                caml_call2(Pervasives[5],numgroups[1],n + 1 | 0);
                return 0;
               default:
                var n$0=param[1];
                emit_instr(op_REFGROUP,n$0);
                numgroups[1]
                =
                caml_call2(Pervasives[5],numgroups[1],n$0 + 1 | 0);
                return 0}}
          function disjoint_modulo_case(c1,c2)
           {if(fold_case$0)
             {var _J_=fold_case(c2);return disjoint(fold_case(c1),_J_)}
            return disjoint(c1,c2)}
          emit_code(re);
          emit_instr(op_ACCEPT,0);
          var start=first(re),start$0=fold_case$0?fold_case(start):start;
          if(runtime.caml_bytes_equal(start,full))
           var start_pos=-1;
          else
           {var r=caml_call2(Bytes[1],256,0);
            iter(function(c){return caml_bytes_set(r,c,1)},start$0);
            var start_pos=cpool_index(caml_call1(Bytes[6],r))}
          var constantpool=caml_make_vect(cpoolpos[1],cst$1),_F_=cpool[1];
          function _G_(str,idx)
           {caml_check_bound(constantpool,idx)[1 + idx] = str;return 0}
          caml_call2(StringMap[12],_G_,_F_);
          var
           _H_=numregs[1],
           _I_=numgroups[1],
           fold_case_table$0=fold_case$0?fold_case_table:cst$2;
          return [0,
                  caml_call3(Array[7],prog[1],0,progpos[1]),
                  constantpool,
                  fold_case_table$0,
                  _I_,
                  _H_,
                  start_pos]},
       flush=
        function(buf)
         {var s=caml_call1(Buffer[2],buf[1]);
          caml_call1(Buffer[8],buf[1]);
          var match=caml_ml_string_length(s);
          if(0 === match)return 0;
          if(1 === match)
           {var _E_=buf[2];buf[2] = [0,[0,caml_string_get(s,0)],_E_];return 0}
          buf[2] = [0,[1,s],buf[2]];
          return 0},
       dotclass=complement(singleton(10)),
       parse=
        function(s)
         {var len=caml_ml_string_length(s),group_counter=[0,1];
          function regexp0(i)
           {var match=regexp1(i),j=match[2],r=match[1],r1=r,i$0=j;
            for(;;)
             {if((i$0 + 2 | 0) <= len)
               if(92 === caml_string_get(s,i$0))
                if(124 === caml_string_get(s,i$0 + 1 | 0))
                 {var
                   match$0=regexp1(i$0 + 2 | 0),
                   i$1=match$0[2],
                   r2=match$0[1],
                   r1$0=[4,r1,r2],
                   r1=r1$0,
                   i$0=i$1;
                  continue}
              return [0,r1,i$0]}}
          function regexp1(i)
           {var sb=[0,caml_call1(Buffer[1],16),0],i$0=i;
            a:
            for(;;)
             {if(! (len <= i$0))
               {if((i$0 + 2 | 0) <= len)
                 if(92 === caml_string_get(s,i$0))
                  var
                   c$0=caml_string_get(s,i$0 + 1 | 0),
                   _B_=124 === c$0?1:0,
                   _C_=_B_ || (41 === c$0?1:0),
                   switch$0=_C_?0:1;
                 else
                  var switch$0=1;
                else
                 var switch$0=1;
                if(switch$0)
                 {var c$1=caml_string_get(s,i$0);
                  if(36 === c$1)
                   var match=[0,1,i$0 + 1 | 0];
                  else
                   {if(91 <= c$1)
                     if(95 <= c$1)
                      var switch$1=0;
                     else
                      {var switcher$0=c$1 - 91 | 0;
                       switch(switcher$0)
                        {case 0:
                          var i$4=i$0 + 1 | 0;
                          if(i$4 < len)
                           if(94 === caml_string_get(s,i$4))
                            var
                             match$3=regexpclass1(i$4 + 1 | 0),
                             j$3=match$3[2],
                             c$4=match$3[1],
                             match$1=[0,c$4,1,j$3],
                             switch$2=1;
                           else
                            var switch$2=0;
                          else
                           var switch$2=0;
                          if(! switch$2)
                           var
                            match$4=regexpclass1(i$4),
                            j$4=match$4[2],
                            c$5=match$4[1],
                            match$1=[0,c$5,0,j$4];
                          var
                           j$1=match$1[3],
                           compl=match$1[2],
                           c$2=match$1[1],
                           match=[0,[2,c$2,compl],j$1],
                           switch$1=1;
                          break;
                         case 1:
                          var i$5=i$0 + 1 | 0;
                          if(len <= i$5)
                           var _D_=[0,_b_,i$5];
                          else
                           {var c$3=caml_string_get(s,i$5);
                            if(58 <= c$3)
                             if(98 === c$3)
                              var _D_=[0,2,i$5 + 1 | 0],switch$3=2;
                             else
                              var switch$3=124 === c$3?1:0;
                            else
                             {var switcher$1=c$3 - 40 | 0;
                              if(1 < switcher$1 >>> 0)
                               if(9 <= switcher$1)
                                var _D_=[0,[9,c$3 - 48 | 0],i$5 + 1 | 0],switch$3=2;
                               else
                                var switch$3=0;
                              else
                               if(0 === switcher$1)
                                {var group_no=group_counter[1];
                                 group_counter[1]++;
                                 var
                                  match$2=regexp0(i$5 + 1 | 0),
                                  j$2=match$2[2],
                                  r$4=match$2[1];
                                 if((j$2 + 1 | 0) < len)
                                  if(92 === caml_string_get(s,j$2))
                                   if(41 === caml_string_get(s,j$2 + 1 | 0))
                                    var
                                     _D_=[0,[8,group_no,r$4],j$2 + 2 | 0],
                                     switch$3=2,
                                     switch$4=0;
                                   else
                                    var switch$4=1;
                                  else
                                   var switch$4=1;
                                 else
                                  var switch$4=1;
                                 if(switch$4)
                                  var
                                   _D_=caml_call1(Pervasives[2],cst_group_not_closed_by),
                                   switch$3=2}
                               else
                                var switch$3=1}
                            switch(switch$3)
                             {case 0:var _D_=[0,[0,c$3],i$5 + 1 | 0];break;
                              case 1:throw [0,Assert_failure,_c_]
                              }}
                          var match=_D_,switch$1=1;
                          break;
                         case 2:var switch$1=0;break;
                         default:var match=[0,0,i$0 + 1 | 0],switch$1=1}}
                    else
                     if(46 === c$1)
                      var match=[0,[2,dotclass,0],i$0 + 1 | 0],switch$1=1;
                     else
                      var switch$1=0;
                    if(! switch$1)var match=[0,[0,c$1],i$0 + 1 | 0]}
                  var j=match[2],r=match[1],r$0=r,j$0=j;
                  for(;;)
                   {if(! (len <= j$0))
                     {var
                       match$0=caml_string_get(s,j$0),
                       switcher=match$0 - 42 | 0;
                      if(! (1 < switcher >>> 0))
                       {if(0 === switcher)
                         {var i$2=j$0 + 1 | 0,r$2=[5,r$0],r$0=r$2,j$0=i$2;continue}
                        var i$3=j$0 + 1 | 0,r$3=[6,r$0],r$0=r$3,j$0=i$3;
                        continue}
                      if(21 === switcher)
                       {var i$1=j$0 + 1 | 0,r$1=[7,r$0],r$0=r$1,j$0=i$1;continue}}
                    if(typeof r$0 === "number")
                     var switch$5=0;
                    else
                     if(0 === r$0[0])
                      {var c=r$0[1];caml_call2(Buffer[10],sb[1],c);var switch$5=1}
                     else
                      var switch$5=0;
                    if(! switch$5){flush(sb);sb[2] = [0,r$0,sb[2]]}
                    var i$0=j$0;
                    continue a}}}
              flush(sb);
              return [0,[3,caml_call1(List[9],sb[2])],i$0]}}
          function regexpclass1(start)
           {var c=make_empty(0),i$0=start;
            for(;;)
             {if(len <= i$0)caml_call1(Pervasives[2],cst_class_not_closed_by);
              if(93 === caml_string_get(s,i$0))
               if(start < i$0){var j=i$0 + 1 | 0;return [0,c,j]}
              var c1=caml_string_get(s,i$0);
              if((i$0 + 2 | 0) < len)
               if(45 === caml_string_get(s,i$0 + 1 | 0))
                if(93 !== caml_string_get(s,i$0 + 2 | 0))
                 {var c2=caml_string_get(s,i$0 + 2 | 0);
                  if(! (c2 < c1))
                   {var i=c1;
                    for(;;)
                     {add(c,caml_call1(Char[1],i));
                      var _A_=i + 1 | 0;
                      if(c2 !== i){var i=_A_;continue}
                      break}}
                  var i$2=i$0 + 3 | 0,i$0=i$2;
                  continue}
              add(c,c1);
              var i$1=i$0 + 1 | 0,i$0=i$1;
              continue}}
          var match=regexp0(0),j=match[2],r=match[1];
          return j === len
                  ?r
                  :caml_call1
                    (Pervasives[2],cst_spurious_in_regular_expression)},
       regexp=function(e){return compile(0,parse(e))},
       regexp_case_fold=function(e){return compile(1,parse(e))},
       quote=
        function(s)
         {var
           len=caml_ml_string_length(s),
           buf=caml_create_bytes(2 * len | 0),
           pos=[0,0],
           _w_=len - 1 | 0,
           _v_=0;
          if(! (_w_ < 0))
           {var i=_v_;
            for(;;)
             {var c=caml_string_get(s,i),_x_=c - 63 | 0;
              if(31 < _x_ >>> 0)
               {var _y_=_x_ + 27 | 0;
                if(10 < _y_ >>> 0)
                 var switch$0=0;
                else
                 switch(_y_)
                  {case 0:
                   case 6:
                   case 7:
                   case 10:var switch$0=1;break;
                   default:var switch$0=0}}
              else
               var switch$0=26 < (_x_ - 1 | 0) >>> 0?1:0;
              if(switch$0)
               {caml_bytes_set(buf,pos[1],92);
                caml_bytes_set(buf,pos[1] + 1 | 0,c);
                pos[1] = pos[1] + 2 | 0}
              else
               {caml_bytes_set(buf,pos[1],c);pos[1] = pos[1] + 1 | 0}
              var _z_=i + 1 | 0;
              if(_w_ !== i){var i=_z_;continue}
              break}}
          return caml_call3(Bytes[8],buf,0,pos[1])},
       regexp_string=function(s){return compile(0,[1,s])},
       regexp_string_case_fold=function(s){return compile(1,[1,s])},
       last_search_result=[0,[0]],
       string_match=
        function(re,s,pos)
         {var res=runtime.re_string_match(re,s,pos);
          last_search_result[1] = res;
          return 0 < res.length - 1?1:0},
       string_partial_match=
        function(re,s,pos)
         {var res=runtime.re_partial_match(re,s,pos);
          last_search_result[1] = res;
          return 0 < res.length - 1?1:0},
       search_forward=
        function(re,s,pos)
         {var res=runtime.re_search_forward(re,s,pos);
          last_search_result[1] = res;
          if(0 === res.length - 1)throw Not_found;
          return caml_check_bound(res,0)[1]},
       search_backward=
        function(re,s,pos)
         {var res=runtime.re_search_backward(re,s,pos);
          last_search_result[1] = res;
          if(0 === res.length - 1)throw Not_found;
          return caml_check_bound(res,0)[1]},
       group_beginning=
        function(n)
         {var n2=n + n | 0;
          if(0 <= n)
           if(! (last_search_result[1].length - 1 <= n2))
            {var pos=caml_check_bound(last_search_result[1],n2)[1 + n2];
             if(-1 === pos)throw Not_found;
             return pos}
          return caml_call1(Pervasives[1],cst_Str_group_beginning)},
       group_end=
        function(n)
         {var n2=n + n | 0;
          if(0 <= n)
           if(! (last_search_result[1].length - 1 <= n2))
            {var
              _u_=n2 + 1 | 0,
              pos=caml_check_bound(last_search_result[1],_u_)[1 + _u_];
             if(-1 === pos)throw Not_found;
             return pos}
          return caml_call1(Pervasives[1],cst_Str_group_end)},
       matched_group=
        function(n,txt)
         {var n2=n + n | 0;
          if(0 <= n)
           if(! (last_search_result[1].length - 1 <= n2))
            {var
              b=caml_check_bound(last_search_result[1],n2)[1 + n2],
              _t_=n2 + 1 | 0,
              e=caml_check_bound(last_search_result[1],_t_)[1 + _t_];
             if(-1 === b)throw Not_found;
             return caml_call3(String[4],txt,b,e - b | 0)}
          return caml_call1(Pervasives[1],cst_Str_matched_group)},
       match_beginning=function(param){return group_beginning(0)},
       match_end=function(param){return group_end(0)},
       matched_string=function(txt){return matched_group(0,txt)},
       replace_matched=
        function(repl,matched)
         {return runtime.re_replacement_text
                  (repl,last_search_result[1],matched)},
       substitute_first=
        function(expr,repl_fun,text)
         {try
           {var
             pos=search_forward(expr,text,0),
             _o_=[0,string_after(text,match_end(0)),0],
             _p_=[0,caml_call1(repl_fun,text),_o_],
             _q_=[0,string_before(text,pos),_p_],
             _r_=caml_call2(String[7],cst$3,_q_);
            return _r_}
          catch(_s_)
           {_s_ = caml_wrap_exception(_s_);
            if(_s_ === Not_found)return text;
            throw _s_}},
       opt_search_forward=
        function(re,s,pos)
         {try
           {var _m_=[0,search_forward(re,s,pos)];return _m_}
          catch(_n_)
           {_n_ = caml_wrap_exception(_n_);
            if(_n_ === Not_found)return 0;
            throw _n_}},
       global_substitute=
        function(expr,repl_fun,text)
         {var accu=0,start=0,last_was_empty=0;
          for(;;)
           {var startpos=last_was_empty?start + 1 | 0:start;
            if(caml_ml_string_length(text) < startpos)
             var _k_=[0,string_after(text,start),accu];
            else
             {var match=opt_search_forward(expr,text,startpos);
              if(match)
               {var
                 pos=match[1],
                 start$0=match_end(0),
                 repl_text=caml_call1(repl_fun,text),
                 last_was_empty$0=start$0 === pos?1:0,
                 accu$0=
                  [0,
                   repl_text,
                   [0,caml_call3(String[4],text,start,pos - start | 0),accu]],
                 accu=accu$0,
                 start=start$0,
                 last_was_empty=last_was_empty$0;
                continue}
              var _k_=[0,string_after(text,start),accu]}
            var _l_=caml_call1(List[9],_k_);
            return caml_call2(String[7],cst$4,_l_)}},
       global_replace=
        function(expr,repl,text)
         {return global_substitute
                  (expr,function(_j_){return replace_matched(repl,_j_)},text)},
       replace_first=
        function(expr,repl,text)
         {return substitute_first
                  (expr,function(_i_){return replace_matched(repl,_i_)},text)},
       opt_search_forward_progress=
        function(expr,text,start)
         {var match=opt_search_forward(expr,text,start);
          if(match)
           {var pos=match[1];
            return start < match_end(0)
                    ?[0,pos]
                    :start < caml_ml_string_length(text)
                      ?opt_search_forward(expr,text,start + 1 | 0)
                      :0}
          return 0},
       bounded_split=
        function(expr,text,num)
         {var
           start=string_match(expr,text,0)?match_end(0):0,
           accu=0,
           start$0=start,
           n=num;
          for(;;)
           {if(caml_ml_string_length(text) <= start$0)
             var _h_=accu;
            else
             if(1 === n)
              var _h_=[0,string_after(text,start$0),accu];
             else
              {var match=opt_search_forward_progress(expr,text,start$0);
               if(match)
                {var
                  pos=match[1],
                  n$0=n - 1 | 0,
                  start$1=match_end(0),
                  accu$0=
                   [0,
                    caml_call3(String[4],text,start$0,pos - start$0 | 0),
                    accu],
                  accu=accu$0,
                  start$0=start$1,
                  n=n$0;
                 continue}
               var _h_=[0,string_after(text,start$0),accu]}
            return caml_call1(List[9],_h_)}},
       split=function(expr,text){return bounded_split(expr,text,0)},
       bounded_split_delim=
        function(expr,text,num)
         {if(caml_string_equal(text,cst$5))return 0;
          var accu=0,start=0,n=num;
          for(;;)
           {if(caml_ml_string_length(text) < start)
             var _g_=accu;
            else
             if(1 === n)
              var _g_=[0,string_after(text,start),accu];
             else
              {var match=opt_search_forward_progress(expr,text,start);
               if(match)
                {var
                  pos=match[1],
                  n$0=n - 1 | 0,
                  start$0=match_end(0),
                  accu$0=
                   [0,caml_call3(String[4],text,start,pos - start | 0),accu],
                  accu=accu$0,
                  start=start$0,
                  n=n$0;
                 continue}
               var _g_=[0,string_after(text,start),accu]}
            return caml_call1(List[9],_g_)}},
       split_delim=
        function(expr,text){return bounded_split_delim(expr,text,0)},
       bounded_full_split=
        function(expr,text,num)
         {var accu=0,start=0,n=num;
          for(;;)
           {if(caml_ml_string_length(text) <= start)
             var _f_=accu;
            else
             if(1 === n)
              var _f_=[0,[0,string_after(text,start)],accu];
             else
              {var match=opt_search_forward_progress(expr,text,start);
               if(match)
                {var pos=match[1],s=matched_string(text);
                 if(start < pos)
                  {var
                    n$0=n - 1 | 0,
                    start$0=match_end(0),
                    accu$0=
                     [0,
                      [1,s],
                      [0,
                       [0,caml_call3(String[4],text,start,pos - start | 0)],
                       accu]],
                    accu=accu$0,
                    start=start$0,
                    n=n$0;
                   continue}
                 var
                  n$1=n - 1 | 0,
                  start$1=match_end(0),
                  accu$1=[0,[1,s],accu],
                  accu=accu$1,
                  start=start$1,
                  n=n$1;
                 continue}
               var _f_=[0,[0,string_after(text,start)],accu]}
            return caml_call1(List[9],_f_)}},
       full_split=function(expr,text){return bounded_full_split(expr,text,0)},
       Str=
        [0,
         regexp,
         regexp_case_fold,
         quote,
         regexp_string,
         regexp_string_case_fold,
         string_match,
         search_forward,
         search_backward,
         string_partial_match,
         matched_string,
         match_beginning,
         match_end,
         matched_group,
         group_beginning,
         group_end,
         global_replace,
         replace_first,
         global_substitute,
         substitute_first,
         replace_matched,
         split,
         bounded_split,
         split_delim,
         bounded_split_delim,
         full_split,
         bounded_full_split,
         string_before,
         string_after,
         first_chars,
         last_chars];
      runtime.caml_register_global(27,Str,"Str");
      return}}
  (function(){return this}()));


//# 1 "../.js/menhirLib/menhirLib.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_bytes_set=runtime.caml_bytes_set,
     caml_bytes_unsafe_get=runtime.caml_bytes_unsafe_get,
     caml_check_bound=runtime.caml_check_bound,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_div=runtime.caml_div,
     caml_equal=runtime.caml_equal,
     caml_make_vect=runtime.caml_make_vect,
     caml_mod=runtime.caml_mod,
     caml_mul=runtime.caml_mul,
     caml_new_string=runtime.caml_new_string,
     caml_obj_tag=runtime.caml_obj_tag,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call7(f,a0,a1,a2,a3,a4,a5,a6)
     {return f.length == 7
              ?f(a0,a1,a2,a3,a4,a5,a6)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_feed_outgoing_transition_does_not_exist=
      caml_new_string("feed: outgoing transition does not exist"),
     cst_Current_LR_1_state=caml_new_string("Current LR(1) state: "),
     cst_some_initial_state=caml_new_string("<some initial state>"),
     arrow=caml_new_string(" -> "),
     dot=caml_new_string("."),
     space=caml_new_string(" "),
     newline=caml_new_string("\n"),
     cst_force_reduction_this_reduction_is_not_permitted_in_this_state=
      caml_new_string
       ("force_reduction: this reduction is not permitted in this state"),
     cst_resume_expects_HandlingError_Shifting_AboutToReduce=
      caml_new_string
       ("resume expects HandlingError | Shifting | AboutToReduce"),
     cst_offer_expects_InputNeeded=
      caml_new_string("offer expects InputNeeded"),
     cst=caml_new_string(""),
     Pervasives=global_data.Pervasives,
     Printf=global_data.Printf,
     Assert_failure=global_data.Assert_failure,
     List=global_data.List,
     Array=global_data.Array,
     Char=global_data.Char,
     Bytes=global_data.Bytes,
     Sys=global_data.Sys,
     Lexing=global_data.Lexing,
     CamlinternalLazy=global_data.CamlinternalLazy,
     _J_=
      [0,
       [11,
        caml_new_string("Handling error in state "),
        [4,0,0,0,[12,10,[10,0]]]],
       caml_new_string("Handling error in state %d\n%!")],
     _I_=
      [0,
       [11,caml_new_string("Resuming error handling\n"),[10,0]],
       caml_new_string("Resuming error handling\n%!")],
     _H_=
      [0,
       [11,caml_new_string("Initiating error handling\n"),[10,0]],
       caml_new_string("Initiating error handling\n%!")],
     _G_=
      [0,
       [11,
        caml_new_string("Lookahead token is now "),
        [2,
         0,
         [11,
          caml_new_string(" ("),
          [4,0,0,0,[12,45,[4,0,0,0,[11,caml_new_string(")\n"),[10,0]]]]]]]],
       caml_new_string("Lookahead token is now %s (%d-%d)\n%!")],
     _F_=[0,[2,0,[12,10,[10,0]]],caml_new_string("%s\n%!")],
     _E_=
      [0,
       [11,
        caml_new_string("Shifting ("),
        [2,0,[11,caml_new_string(") to state "),[4,0,0,0,[12,10,[10,0]]]]]],
       caml_new_string("Shifting (%s) to state %d\n%!")],
     _D_=
      [0,
       [11,
        caml_new_string("State "),
        [4,0,0,0,[11,caml_new_string(":\n"),[10,0]]]],
       caml_new_string("State %d:\n%!")],
     _C_=[0,caml_new_string("lib/pack/menhirLib.ml"),3408,4],
     _B_=[0,caml_new_string("lib/pack/menhirLib.ml"),3393,8],
     _A_=[0,caml_new_string("lib/pack/menhirLib.ml"),3347,4],
     _z_=[0,caml_new_string("lib/pack/menhirLib.ml"),3156,4],
     _y_=[0,caml_new_string("lib/pack/menhirLib.ml"),3069,4],
     _x_=[0,caml_new_string("lib/pack/menhirLib.ml"),3063,4],
     _w_=[0,caml_new_string("lib/pack/menhirLib.ml"),3044,4],
     _v_=[0,caml_new_string("lib/pack/menhirLib.ml"),2734,2],
     _u_=[0,caml_new_string("lib/pack/menhirLib.ml"),2730,2],
     _t_=[0,caml_new_string("lib/pack/menhirLib.ml"),2726,2],
     _s_=[0,caml_new_string("lib/pack/menhirLib.ml"),2701,2],
     _r_=[0,caml_new_string("lib/pack/menhirLib.ml"),2653,2],
     _q_=[0,caml_new_string("lib/pack/menhirLib.ml"),2655,2],
     _n_=[0,caml_new_string("lib/pack/menhirLib.ml"),2571,10],
     _p_=[0,caml_new_string("lib/pack/menhirLib.ml"),2490,2],
     _o_=[0,caml_new_string("lib/pack/menhirLib.ml"),2493,6],
     _m_=[0,caml_new_string("lib/pack/menhirLib.ml"),2394,6],
     _l_=[0,caml_new_string("lib/pack/menhirLib.ml"),2276,4],
     _k_=[0,caml_new_string("lib/pack/menhirLib.ml"),2325,4],
     _j_=[0,caml_new_string("lib/pack/menhirLib.ml"),2173,2],
     _i_=[0,caml_new_string("lib/pack/menhirLib.ml"),1992,6],
     _f_=[0,caml_new_string("lib/pack/menhirLib.ml"),1976,6],
     _g_=
      [0,
       [11,caml_new_string("before '"),[2,0,[12,39,0]]],
       caml_new_string("before '%s'")],
     _h_=
      [0,
       [11,
        caml_new_string("after '"),
        [2,0,[11,caml_new_string("' and before '"),[2,0,[12,39,0]]]]],
       caml_new_string("after '%s' and before '%s'")],
     _a_=[0,caml_new_string("lib/pack/menhirLib.ml"),1378,4],
     _b_=[0,caml_new_string("lib/pack/menhirLib.ml"),1397,4],
     _d_=[0,caml_new_string("lib/pack/menhirLib.ml"),1695,8],
     _e_=[0,caml_new_string("lib/pack/menhirLib.ml"),1883,6],
     _c_=[0,caml_new_string("lib/pack/menhirLib.ml"),1670,4];
    function take(n,input)
     {if(0 !== n)
       if(input)
        {var xs=input[2],x=input[1],xs$0=take(n - 1 | 0,xs);
         return xs === xs$0?input:[0,x,xs$0]}
      return 0}
    function drop(n,xs)
     {var n$0=n,xs$0=xs;
      for(;;)
       {if(0 === n$0)return xs$0;
        if(xs$0){var xs$1=xs$0[2],n$1=n$0 - 1 | 0,n$0=n$1,xs$0=xs$1;continue}
        return 0}}
    function uniq1(cmp,x,ys)
     {var cmp$0=cmp,ys$0=ys;
      for(;;)
       {if(ys$0)
         {var ys$1=ys$0[2],y=ys$0[1];
          if(0 === caml_call2(cmp$0,x,y))
           {var cmp$1=runtime.caml_compare,cmp$0=cmp$1,ys$0=ys$1;continue}
          return [0,y,uniq1(cmp$0,y,ys$1)]}
        return 0}}
    function uniq(cmp,xs)
     {if(xs){var xs$0=xs[2],x=xs[1];return [0,x,uniq1(cmp,x,xs$0)]}return 0}
    function weed(cmp,xs){return uniq(cmp,caml_call2(List[48],cmp,xs))}
    function length(xs)
     {var
       _bZ_=caml_obj_tag(xs),
       _b0_=
        250 === _bZ_?xs[1]:246 === _bZ_?caml_call1(CamlinternalLazy[2],xs):xs;
      if(_b0_){var xs$0=_b0_[2];return 1 + length(xs$0) | 0}
      return 0}
    function foldr(f,xs,accu)
     {var
       _bX_=caml_obj_tag(xs),
       _bY_=
        250 === _bX_?xs[1]:246 === _bX_?caml_call1(CamlinternalLazy[2],xs):xs;
      if(_bY_)
       {var xs$0=_bY_[2],x=_bY_[1];return caml_call2(f,x,foldr(f,xs$0,accu))}
      return accu}
    function traditional2revised
     (get_raw_token,get_startp,get_endp,parser,lexer)
     {var lexbuf=caml_call1(Lexing[3],cst);
      function lexer$0(lexbuf)
       {var token=caml_call1(lexer,0);
        lexbuf[11] = caml_call1(get_startp,token);
        lexbuf[12] = caml_call1(get_endp,token);
        return caml_call1(get_raw_token,token)}
      return caml_call2(parser,lexer$0,lexbuf)}
    function revised2traditional(make_token,parser,lexer,lexbuf)
     {function lexer$0(param)
       {var token=caml_call1(lexer,lexbuf);
        return caml_call3(make_token,token,lexbuf[11],lexbuf[12])}
      return caml_call1(parser,lexer$0)}
    function traditional2revised$0(parser)
     {function _bT_(param){var endp=param[3];return endp}
      function _bU_(param){var startp=param[2];return startp}
      function _bV_(param){var token=param[1];return token}
      return function(_bW_)
       {return traditional2revised(_bV_,_bU_,_bT_,parser,_bW_)}}
    function revised2traditional$0(parser)
     {function _bQ_(token,startp,endp){return [0,token,startp,endp]}
      return function(_bR_,_bS_)
       {return revised2traditional(_bQ_,parser,_bR_,_bS_)}}
    var
     Simplified=[0,traditional2revised$0,revised2traditional$0],
     Convert=[0,traditional2revised,revised2traditional,Simplified],
     IncrementalEngine=[0],
     EngineTypes=[0];
    function show(f,buffer)
     {var _bM_=buffer[1];
      if(typeof _bM_ === "number")
       throw [0,Assert_failure,_f_];
      else
       {if(0 === _bM_[0])
         {var invalid=_bM_[1],_bN_=caml_call1(f,invalid);
          return caml_call2(Printf[4],_g_,_bN_)}
        var
         invalid$0=_bM_[2],
         valid=_bM_[1],
         _bO_=caml_call1(f,invalid$0),
         _bP_=caml_call1(f,valid);
        return caml_call3(Printf[4],_h_,_bP_,_bO_)}}
    function last(buffer)
     {var _bL_=buffer[1];
      if(typeof _bL_ === "number")
       throw [0,Assert_failure,_i_];
      else
       var invalid=0 === _bL_[0]?_bL_[1]:_bL_[2];
      return invalid}
    function wrap(lexer)
     {var buffer=[0,0];
      return [0,
              buffer,
              function(lexbuf)
               {var
                 token=caml_call1(lexer,lexbuf),
                 x=[0,lexbuf[11],lexbuf[12]],
                 _bJ_=buffer[1];
                if(typeof _bJ_ === "number")
                 var _bK_=[0,x],switch$0=1;
                else
                 if(0 === _bJ_[0])
                  var x1=_bJ_[1],switch$0=0;
                 else
                  var x1=_bJ_[2],switch$0=0;
                if(! switch$0)var _bK_=[1,x1,x];
                buffer[1] = _bK_;
                return token}]}
    function make(x){return [0,x,caml_make_vect(16384,x),0]}
    function ensure(a,i)
     {if(0 <= i)
       {var table=a[2],length$1=table.length - 1,_bG_=length$1 <= i?1:0;
        if(_bG_)
         {var length$2=2 * length$1 | 0,length=length$2,_bH_=a[1];
          for(;;)
           {if(! (i < length))
             {var length$0=2 * length | 0,length=length$0;continue}
            var table$0=caml_make_vect(length,_bH_);
            caml_call5(Array[10],table,0,table$0,0,length$1);
            a[2] = table$0;
            var _bI_=0;
            break}}
        else
         var _bI_=_bG_;
        return _bI_}
      throw [0,Assert_failure,_j_]}
    function get(a,i){ensure(a,i);return a[2][1 + i]}
    function set(a,i,x)
     {ensure(a,i);
      a[2][1 + i] = x;
      var _bE_=a[3] <= i?1:0,_bF_=_bE_?(a[3] = i + 1 | 0,0):_bE_;
      return _bF_}
    function extent(a){return a[3]}
    function domain(a){return caml_call3(Array[7],a[2],0,a[3])}
    function pack(a)
     {var m=a.length - 1,_bq_=1;
      function _br_(k$1,v)
       {if(0 <= v)
         {var k=1,max=2;
          for(;;)
           {if(0 < max)
             if(! (v < max))
              {var max$0=caml_mul(max,max),k$0=2 * k | 0,k=k$0,max=max$0;
               continue}
            var _bD_=k;
            break}}
        else
         var _bD_=Sys[10];
        return caml_call2(Pervasives[5],k$1,_bD_)}
      var k=caml_call3(Array[17],_br_,_bq_,a);
      if(8 < k)
       {if(0 === (k % 8 | 0))
         {var
           w=k / 8 | 0,
           n=caml_mul(m,w),
           s=caml_create_bytes(n),
           _bt_=m - 1 | 0,
           _bs_=0;
          if(! (_bt_ < 0))
           {var i=_bs_;
            for(;;)
             {var v=[0,caml_check_bound(a,i)[1 + i]],_bu_=1;
              if(! (w < 1))
               {var x=_bu_;
                for(;;)
                 {caml_bytes_set
                   (s,
                    caml_mul(i + 1 | 0,w) - x | 0,
                    caml_call1(Char[1],v[1] & 255));
                  v[1] = v[1] >>> 8 | 0;
                  var _bw_=x + 1 | 0;
                  if(w !== x){var x=_bw_;continue}
                  break}}
              var _bv_=i + 1 | 0;
              if(_bt_ !== i){var i=_bv_;continue}
              break}}
          return [0,k,caml_call1(Bytes[42],s)]}
        throw [0,Assert_failure,_k_]}
      if(0 === caml_mod(8,k))
       {var
         w$0=caml_div(8,k),
         n$0=0 === caml_mod(m,w$0)?caml_div(m,w$0):caml_div(m,w$0) + 1 | 0,
         s$0=caml_create_bytes(n$0),
         i$0=[0,0],
         _by_=n$0 - 1 | 0,
         _bx_=0;
        if(! (_by_ < 0))
         {var j=_bx_;
          for(;;)
           {var c=[0,0],_bz_=1;
            if(! (w$0 < 1))
             {var x$0=_bz_;
              for(;;)
               {var ii=i$0[1];
                if(ii === m)
                 var _bB_=0;
                else
                 {var v$0=caml_check_bound(a,ii)[1 + ii];
                  i$0[1] = ii + 1 | 0;
                  var _bB_=v$0}
                c[1] = c[1] << k | _bB_;
                var _bC_=x$0 + 1 | 0;
                if(w$0 !== x$0){var x$0=_bC_;continue}
                break}}
            caml_bytes_set(s$0,j,caml_call1(Char[1],c[1]));
            var _bA_=j + 1 | 0;
            if(_by_ !== j){var j=_bA_;continue}
            break}}
        return [0,k,caml_call1(Bytes[42],s$0)]}
      throw [0,Assert_failure,_l_]}
    function get1(s,i)
     {var
       c=caml_bytes_unsafe_get(s,i >>> 3 | 0),
       c$0=c >>> (caml_call1(Pervasives[9],i) & 7) | 0,
       c$1=c$0 & 1;
      return c$1}
    function get$0(param,i)
     {var s=param[2],k=param[1],switcher=k - 1 | 0;
      if(! (15 < switcher >>> 0))
       switch(switcher)
        {case 0:return get1(s,i);
         case 1:
          var
           c=caml_bytes_unsafe_get(s,i >>> 2 | 0),
           c$0=c >>> (2 * (caml_call1(Pervasives[9],i) & 3) | 0) | 0,
           c$1=c$0 & 3;
          return c$1;
         case 3:
          var
           c$2=caml_bytes_unsafe_get(s,i >>> 1 | 0),
           c$3=c$2 >>> (4 * (caml_call1(Pervasives[9],i) & 1) | 0) | 0,
           c$4=c$3 & 15;
          return c$4;
         case 7:return caml_bytes_unsafe_get(s,i);
         case 15:
          var j$0=2 * i | 0;
          return (caml_bytes_unsafe_get(s,j$0) << 8)
                 +
                 caml_bytes_unsafe_get(s,j$0 + 1 | 0)
                 |
                 0
         }
      if(32 === k)
       {var j=4 * i | 0;
        return (((((caml_bytes_unsafe_get(s,j) << 8)
                   +
                   caml_bytes_unsafe_get(s,j + 1 | 0)
                   |
                   0)
                  <<
                  8)
                 +
                 caml_bytes_unsafe_get(s,j + 2 | 0)
                 |
                 0)
                <<
                8)
               +
               caml_bytes_unsafe_get(s,j + 3 | 0)
               |
               0}
      throw [0,Assert_failure,_m_]}
    function unflatten1(param,i,j)
     {var data=param[2],n=param[1];return get1(data,caml_mul(n,i) + j | 0)}
    function decode(displacement)
     {return 0 === (displacement & 1)
              ?displacement >>> 1 | 0
              :- (displacement >>> 1 | 0) | 0}
    function compress(equal,insignificant,dummy,m,n,t)
     {if(t.length - 1 === m)
       {var _bj_=m - 1 | 0,_bi_=0;
        if(! (_bj_ < 0))
         {var i=_bi_;
          for(;;)
           {if(caml_check_bound(t,i)[1 + i].length - 1 !== n)
             throw [0,Assert_failure,_o_];
            var _bm_=i + 1 | 0;
            if(_bj_ !== i){var i=_bm_;continue}
            break}}
        var
         sparse=
          function(i,line)
           {var j$2=n - 1 | 0,j=j$2,rank=0,row=0;
            for(;;)
             {if(0 <= j)
               {var x=caml_check_bound(line,j)[1 + j];
                if(caml_call1(insignificant,x))
                 {var j$0=j - 1 | 0,j=j$0;continue}
                var
                 row$0=[0,[0,j,x],row],
                 rank$0=1 + rank | 0,
                 j$1=j - 1 | 0,
                 j=j$1,
                 rank=rank$0,
                 row=row$0;
                continue}
              return [0,i,rank,row]}},
         rows=caml_call2(Array[16],sparse,t),
         _bk_=
          function(param,_bp_)
           {var rank2=_bp_[2],rank1=param[2];
            return runtime.caml_int_compare(rank2,rank1)};
        caml_call2(Array[27],_bk_,rows);
        var
         displacement=caml_make_vect(m,0),
         data=make(dummy),
         _bl_=
          function(param$1)
           {var row$1=param$1[3],i=param$1[1];
            if(row$1)
             {var match$0=row$1[1],j$0=match$0[1],k$1=- j$0 | 0,k=k$1;
              a:
              for(;;)
               {var d=data[3],param=row$1;
                for(;;)
                 {if(param)
                   {var row=param[2],match=param[1],x=match[2],j=match[1];
                    if(! (0 <= (k + j | 0)))throw [0,Assert_failure,_n_];
                    if(d <= (k + j | 0))
                     var _bn_=1;
                    else
                     {var y=get(data,k + j | 0);
                      if(caml_call1(insignificant,y))
                       var switch$0=0;
                      else
                       if(caml_call2(equal,x,y))
                        var switch$0=0;
                       else
                        var _bn_=0,switch$0=1;
                      if(! switch$0){var param=row;continue}}}
                  else
                   var _bn_=1;
                  if(! _bn_){var k$0=k + 1 | 0,k=k$0;continue a}
                  var k$2=k;
                  break}
                break}}
            else
             var k$2=0;
            var param$0=row$1;
            for(;;)
             {if(param$0)
               {var
                 row$0=param$0[2],
                 match$1=param$0[1],
                 x$0=match$1[2],
                 j$1=match$1[1];
                set(data,k$2 + j$1 | 0,x$0);
                var param$0=row$0;
                continue}
              var _bo_=0 <= k$2?k$2 << 1:((- k$2 | 0) << 1) + 1 | 0;
              caml_check_bound(displacement,i)[1 + i] = _bo_;
              return 0}};
        caml_call2(Array[13],_bl_,rows);
        return [0,displacement,domain(data)]}
      throw [0,Assert_failure,_p_]}
    function get$1(param,i,j)
     {var data=param[2],displacement=param[1];
      if(0 <= i)
       if(i < displacement.length - 1)
        {var k=decode(caml_check_bound(displacement,i)[1 + i]);
         if(0 <= (k + j | 0))
          if((k + j | 0) < data.length - 1)
           {var _bh_=k + j | 0;return caml_check_bound(data,_bh_)[1 + _bh_]}
         throw [0,Assert_failure,_q_]}
      throw [0,Assert_failure,_r_]}
    function getget(get_displacement,get_data,param,i,j)
     {var
       data=param[2],
       displacement=param[1],
       k=decode(caml_call2(get_displacement,displacement,i));
      return caml_call2(get_data,data,k + j | 0)}
    function make$0(a)
     {var n=a.length - 1,size=[0,0];
      function _ba_(i)
       {var s=size[1];
        if(i < n)size[1] = s + (caml_check_bound(a,i)[1 + i].length - 1) | 0;
        return s}
      var entry=caml_call2(Array[2],n + 1 | 0,_ba_),_bb_=size[1];
      if(caml_check_bound(entry,n)[1 + n] === _bb_)
       {var
         i=[0,0],
         j=[0,0],
         _bc_=
          function(param)
           {for(;;)
             {var
               _bd_=i[1],
               _be_=caml_check_bound(a,_bd_)[1 + _bd_].length - 1;
              if(j[1] === _be_){i[1] = i[1] + 1 | 0;j[1] = 0;continue}
              var
               _bf_=j[1],
               _bg_=i[1],
               x=
                caml_check_bound(caml_check_bound(a,_bg_)[1 + _bg_],_bf_)
                 [1 + _bf_];
              j[1] = j[1] + 1 | 0;
              return x}},
         data=caml_call2(Array[2],size[1],_bc_);
        return [0,data,entry]}
      throw [0,Assert_failure,_s_]}
    function length$0(param){var entry=param[2];return entry.length - 1}
    function row_length(param,i)
     {var entry=param[2],_a$_=i + 1 | 0,_a__=caml_check_bound(entry,i)[1 + i];
      return caml_check_bound(entry,_a$_)[1 + _a$_] - _a__ | 0}
    function row_length_via(get_entry,i)
     {var _a9_=caml_call1(get_entry,i);
      return caml_call1(get_entry,i + 1 | 0) - _a9_ | 0}
    function read(la,i,j)
     {var entry=la[2],data=la[1];
      if(0 <= j)
       if(j < row_length(la,i))
        {var _a8_=caml_check_bound(entry,i)[1 + i] + j | 0;
         return caml_check_bound(data,_a8_)[1 + _a8_]}
      throw [0,Assert_failure,_t_]}
    function read_via(get_data,get_entry,i,j)
     {if(0 <= j)
       if(j < row_length_via(get_entry,i))
        return caml_call1(get_data,caml_call1(get_entry,i) + j | 0);
      throw [0,Assert_failure,_u_]}
    function write(la,i,j,v)
     {var entry=la[2],data=la[1];
      if(0 <= j)
       if(j < row_length(la,i))
        {var _a7_=caml_check_bound(entry,i)[1 + i] + j | 0;
         caml_check_bound(data,_a7_)[1 + _a7_] = v;
         return 0}
      throw [0,Assert_failure,_v_]}
    function read_interval_via(get_data,i,j)
     {if(i === j)return 0;
      var _a6_=read_interval_via(get_data,i + 1 | 0,j);
      return [0,caml_call1(get_data,i),_a6_]}
    function read_row_via(get_data,get_entry,i)
     {var _a5_=caml_call1(get_entry,i + 1 | 0);
      return read_interval_via(get_data,caml_call1(get_entry,i),_a5_)}
    function read_row(param,i)
     {var entry=param[2],data=param[1];
      function _a2_(_a4_){return caml_check_bound(entry,_a4_)[1 + _a4_]}
      return read_row_via
              (function(_a3_){return caml_check_bound(data,_a3_)[1 + _a3_]},
               _a2_,
               i)}
    var TableFormat=[0],InspectionTableFormat=[0];
    function Symbols(T){return [0]}
    var
     StaticVersion=[0,0],
     _K_=
      [0,
       function(T)
        {function number(s){return s}
         var _aF_=T[1],_aG_=T[3],_aH_=T[2],error_value=0;
         function foreach_terminal(f,accu$0)
          {var match=T[5],n=match[1],i=0,accu=accu$0;
           for(;;)
            {if(i === n)return accu;
             var accu$1=caml_call2(f,i,accu),i$0=i + 1 | 0,i=i$0,accu=accu$1;
             continue}}
         function non_start_production(i)
          {if(T[9] <= i)if((i - T[9] | 0) < T[10].length - 1)return 0;
           throw [0,Assert_failure,_A_]}
         function production_index(i){non_start_production(i);return i}
         function find_production(i){non_start_production(i);return i}
         function default_reduction(state,defred,nodefred,env)
          {var code=get$0(T[4],state);
           return 0 === code
                   ?caml_call1(nodefred,env)
                   :caml_call2(defred,env,code - 1 | 0)}
         function is_start(prod){return prod < T[9]?1:0}
         function unmarshal2(table,i,j){return getget(get$0,get$0,table,i,j)}
         function action(state,terminal,value,shift,reduce,fail,env)
          {var c=unflatten1(T[5],state,terminal);
           if(1 === c)
            {var
              action=unmarshal2(T[6],state,terminal),
              opcode=action & 3,
              param=action >>> 2 | 0;
             if(2 <= opcode)
              {var please_discard=2 === opcode?1:0;
               return caml_call5
                       (shift,env,please_discard,terminal,value,param)}
             return caml_call2(reduce,env,param)}
           if(0 === c)return caml_call1(fail,env);
           throw [0,Assert_failure,_B_]}
         function goto_nt(state,nt)
          {var code=unmarshal2(T[8],state,nt);return code - 1 | 0}
         function goto_prod(state,prod)
          {return goto_nt(state,get$0(T[7],prod))}
         function maybe_goto_nt(state,nt)
          {var code=unmarshal2(T[8],state,nt);
           if(0 <= code)return 0 === code?0:[0,code - 1 | 0];
           throw [0,Assert_failure,_C_]}
         var _aI_=T[11];
         function semantic_action(prod)
          {var _a1_=prod - T[9] | 0;
           return caml_check_bound(T[10],_a1_)[1 + _a1_]}
         function may_reduce(state,prod)
          {var _aR_=0;
           function _aS_(param)
            {var _aT_=0;
             return foreach_terminal
                     (function(t,accu)
                       {if(accu)return accu;
                        var _aU_=0;
                        function _aV_(param){return 0}
                        function _aW_(param,prod$0){return prod === prod$0?1:0}
                        return action
                                (state,
                                 t,
                                 0,
                                 function(param,_a0_,_aZ_,_aY_,_aX_){return 0},
                                 _aW_,
                                 _aV_,
                                 _aU_)},
                      _aT_)}
           return default_reduction
                   (state,
                    function(param,prod$0){return prod === prod$0?1:0},
                    _aS_,
                    _aR_)}
         var log=T[12]?1:0;
         function state(state)
          {return T[12]?caml_call3(Printf[1],Pervasives[28],_D_,state):0}
         function shift(terminal,state)
          {var _aP_=T[12];
           if(_aP_)
            {var
              match=_aP_[1],
              terminals=match[1],
              _aQ_=caml_check_bound(terminals,terminal)[1 + terminal];
             return caml_call4(Printf[1],Pervasives[28],_E_,_aQ_,state)}
           return 0}
         function reduce_or_accept(prod)
          {var _aN_=T[12];
           if(_aN_)
            {var
              match=_aN_[1],
              productions=match[2],
              _aO_=caml_check_bound(productions,prod)[1 + prod];
             return caml_call3(Printf[1],Pervasives[28],_F_,_aO_)}
           return 0}
         function lookahead_token(token,startp,endp)
          {var _aJ_=T[12];
           if(_aJ_)
            {var
              match=_aJ_[1],
              terminals=match[1],
              _aK_=endp[4],
              _aL_=startp[4],
              _aM_=caml_check_bound(terminals,token)[1 + token];
             return caml_call5(Printf[1],Pervasives[28],_G_,_aM_,_aL_,_aK_)}
           return 0}
         function initiating_error_handling(param)
          {return T[12]?caml_call2(Printf[1],Pervasives[28],_H_):0}
         function resuming_error_handling(param)
          {return T[12]?caml_call2(Printf[1],Pervasives[28],_I_):0}
         function handling_error(state)
          {return T[12]?caml_call3(Printf[1],Pervasives[28],_J_,state):0}
         var
          Log=
           [0,
            state,
            shift,
            reduce_or_accept,
            lookahead_token,
            initiating_error_handling,
            resuming_error_handling,
            handling_error];
         return [0,
                 number,
                 _aF_,
                 _aG_,
                 _aH_,
                 error_value,
                 foreach_terminal,
                 production_index,
                 find_production,
                 default_reduction,
                 action,
                 goto_nt,
                 goto_prod,
                 maybe_goto_nt,
                 is_start,
                 _aI_,
                 semantic_action,
                 may_reduce,
                 log,
                 Log]}],
     _L_=
      [0,
       Symbols,
       function(TT,IT,ET,_al_)
        {function read_packed_linearized(param,i)
          {var entry=param[2],data=param[1];
           function _aC_(_aE_){return get$0(entry,_aE_)}
           return read_row_via(function(_aD_){return get$0(data,_aD_)},_aC_,i)}
         function decode_symbol(symbol)
          {if(0 < symbol)
            {var kind=symbol & 1,symbol$0=symbol >>> 1 | 0;
             return 0 === kind
                     ?caml_call1(IT[1],symbol$0 - 1 | 0)
                     :caml_call1(IT[2],symbol$0)}
           throw [0,Assert_failure,_w_]}
         function n2i(nt)
          {var answer=TT[9] + nt | 0;
           if(caml_equal(caml_call1(IT[2],answer),[0,[1,nt]]))return answer;
           throw [0,Assert_failure,_x_]}
         function t2i(answer)
          {if(caml_equal(caml_call1(IT[1],answer),[0,[0,answer]]))
            return answer;
           throw [0,Assert_failure,_y_]}
         function compare_terminals(t1,t2)
          {var _aB_=t2i(t2);return t2i(t1) - _aB_ | 0}
         function compare_nonterminals(nt1,nt2)
          {var _aA_=n2i(nt2);return n2i(nt1) - _aA_ | 0}
         function compare_symbols(symbol1,symbol2)
          {var _av_=symbol1[1];
           if(0 === _av_[0])
            {var _aw_=symbol2[1],_ax_=_av_[1];
             if(0 === _aw_[0])
              {var t2=_aw_[1];return compare_terminals(_ax_,t2)}
             return -1}
           var _ay_=symbol2[1],_az_=_av_[1];
           if(0 === _ay_[0])return 1;
           var nt2=_ay_[1];
           return compare_nonterminals(_az_,nt2)}
         function compare_productions(prod1,prod2){return prod1 - prod2 | 0}
         function compare_items(param,_au_)
          {var
            index2=_au_[2],
            prod2=_au_[1],
            index1=param[2],
            prod1=param[1],
            c=prod1 - prod2 | 0;
           return 0 === c?index1 - index2 | 0:c}
         function incoming_symbol(s)
          {var
            core=get$0(IT[4],s),
            symbol=decode_symbol(get$0(IT[6],core)),
            symbol$0=symbol[1];
           return symbol$0}
         function lhs(prod)
          {var _at_=get$0(TT[7],prod);return caml_call1(IT[2],_at_)}
         function rhs(prod)
          {var _as_=read_packed_linearized(IT[3],prod);
           return caml_call2(List[17],decode_symbol,_as_)}
         function export$0(t){return [0,t >>> 10 | 0,t % 1024 | 0]}
         function items(s)
          {var core=get$0(IT[4],s),_ar_=read_packed_linearized(IT[5],core);
           return caml_call2(List[17],export$0,_ar_)}
         function decode_bool(i)
          {if(0 !== i)if(1 !== i)throw [0,Assert_failure,_z_];
           return 1 === i?1:0}
         function nullable(nt)
          {var _aq_=n2i(nt);return decode_bool(get1(IT[7],_aq_))}
         function first(nt,t)
          {var _ao_=t2i(t),_ap_=n2i(nt);
           return decode_bool(unflatten1(IT[8],_ap_,_ao_))}
         function xfirst(symbol,t)
          {var _an_=symbol[1];
           if(0 === _an_[0])
            {var t$0=_an_[1];return 0 === compare_terminals(t,t$0)?1:0}
           var nt=_an_[1];
           return first(nt,t)}
         function foldij(i,j,f,accu)
          {var i$0=i,accu$0=accu;
           for(;;)
            {if(i$0 === j)return accu$0;
             var
              accu$1=caml_call2(f,i$0,accu$0),
              i$1=i$0 + 1 | 0,
              i$0=i$1,
              accu$0=accu$1;
             continue}}
         function foreach_terminal(f,accu)
          {var match=TT[5],n=match[1];
           return foldij
                   (0,
                    n,
                    function(i,accu)
                     {return caml_call2(f,caml_call1(IT[1],i),accu)},
                    accu)}
         function foreach_terminal_but_error(f,accu)
          {var match=TT[5],n=match[1];
           return foldij
                   (0,
                    n,
                    function(i,accu)
                     {return i === TT[2]
                              ?accu
                              :caml_call2(f,caml_call1(IT[1],i),accu)},
                    accu)}
         function feed_failure(param)
          {return caml_call1
                   (Pervasives[1],cst_feed_outgoing_transition_does_not_exist)}
         function reduce(env,prod){return feed_failure(0)}
         function initiate(env){return feed_failure(0)}
         function feed(symbol,startp,semv,endp,env)
          {if(0 === symbol[0])
            {var
              terminal=symbol[1],
              terminal$0=t2i(terminal),
              source$0=env[4],
              _am_=
               function(env,please_discard,terminal,semv,target)
                {var stack=[0,source$0,semv,startp,endp,env[3]];
                 return [0,env[1],env[2],stack,target]};
             return caml_call7
                     (ET[10],source$0,terminal$0,semv,_am_,reduce,initiate,env)}
           var
            nt=symbol[1],
            nt$0=n2i(nt),
            source=env[4],
            match=caml_call2(ET[13],source,nt$0);
           if(match)
            {var target=match[1],stack=[0,source,semv,startp,endp,env[3]];
             return [0,env[1],env[2],stack,target]}
           return feed_failure(0)}
         return [0,
                 compare_terminals,
                 compare_nonterminals,
                 compare_symbols,
                 compare_productions,
                 compare_items,
                 incoming_symbol,
                 items,
                 lhs,
                 rhs,
                 nullable,
                 first,
                 xfirst,
                 foreach_terminal,
                 foreach_terminal_but_error,
                 feed]}],
     _M_=
      [0,
       make$0,
       read,
       write,
       length$0,
       row_length,
       read_row,
       row_length_via,
       read_via,
       read_row_via],
     _N_=[0,compress,get$1,getget],
     _O_=[0,pack,get$0,get1,unflatten1],
     _P_=[0,make,get,set,extent,domain],
     _Q_=
      [0,
       function(I,User)
        {function print_symbols(i,symbols)
          {var i$0=i,symbols$0=symbols;
           for(;;)
            {if(0 === i$0)
              {caml_call1(User[1],dot);
               caml_call1(User[1],space);
               var i$0=-1;
               continue}
             if(symbols$0)
              {var symbols$1=symbols$0[2],symbol=symbols$0[1];
               caml_call1(User[2],symbol);
               caml_call1(User[1],space);
               var i$1=i$0 - 1 | 0,i$0=i$1,symbols$0=symbols$1;
               continue}
             return 0}}
         function print_element_as_symbol(element)
          {var s=element[1],_ak_=[0,caml_call1(I[29],s)];
           return caml_call1(User[2],_ak_)}
         var _ae_=User[3];
         if(_ae_)
          var print_element=_ae_[1],print_element$0=print_element;
         else
          var print_element$0=print_element_as_symbol;
         function _af_(env)
          {var match=caml_call1(I[13],env),match$0=caml_call1(I[21],env);
           if(match)
            if(match$0)
             {var env$0=match$0[1],element=match[1];
              _af_(env$0);
              caml_call1(User[1],space);
              return caml_call1(print_element$0,element)}
           return 0}
         function print_stack(env)
          {_af_(env);return caml_call1(User[1],newline)}
         function print_item(param)
          {var i=param[2],prod=param[1],_aj_=caml_call1(I[31],prod);
           caml_call1(User[2],_aj_);
           caml_call1(User[1],arrow);
           print_symbols(i,caml_call1(I[32],prod));
           return caml_call1(User[1],newline)}
         function print_symbols$0(symbols){return print_symbols(-1,symbols)}
         function print_production(prod){return print_item([0,prod,-1])}
         function print_current_state(env)
          {caml_call1(User[1],cst_Current_LR_1_state);
           var match=caml_call1(I[13],env);
           if(match)
            {var
              match$0=match[1],
              current=match$0[1],
              _ag_=caml_call1(I[9],current),
              _ah_=caml_call1(Pervasives[21],_ag_);
             caml_call1(User[1],_ah_);
             caml_call1(User[1],newline);
             var _ai_=caml_call1(I[30],current);
             return caml_call2(List[15],print_item,_ai_)}
           caml_call1(User[1],cst_some_initial_state);
           return caml_call1(User[1],newline)}
         function print_env(env)
          {print_stack(env);
           print_current_state(env);
           return caml_call1(User[1],newline)}
         return [0,
                 print_symbols$0,
                 print_element_as_symbol,
                 print_stack,
                 print_item,
                 print_production,
                 print_current_state,
                 print_env]}],
     _R_=[0,wrap,show,last],
     MenhirLib=
      [0,
       [0,take,drop,uniq,weed,length,foldr],
       Convert,
       IncrementalEngine,
       EngineTypes,
       [0,
        function(T)
         {var
           number=T[1],
           production_index=T[7],
           find_production=T[8],
           Error=T[15],
           log=T[18],
           Log=T[19];
          function check_for_default_reduction(env)
           {return caml_call4
                    (T[9],env[4],announce_reduce,check_for_error_token,env)}
          function run(env,please_discard)
           {if(log)caml_call1(Log[1],env[4]);
            return please_discard?[0,env]:check_for_default_reduction(env)}
          function check_for_error_token(env)
           {if(env[1]){if(log)caml_call1(Log[6],0);return [3,env]}
            var
             match=env[2],
             token=match[1],
             _ac_=caml_call1(T[3],token),
             _ad_=caml_call1(T[2],token);
            return caml_call7
                    (T[10],env[4],_ad_,_ac_,shift,announce_reduce,initiate,env)}
          function shift(env,please_discard,terminal,value,s)
           {if(log)caml_call2(Log[2],terminal,s);
            var
             match=env[2],
             endp=match[3],
             startp=match[2],
             stack=[0,env[4],value,startp,endp,env[3]],
             new_env=[0,env[1],env[2],stack,s];
            return [1,env,new_env,please_discard]}
          function announce_reduce(env,prod)
           {if(caml_call1(T[14],prod))
             {if(log)caml_call1(Log[3],prod);var v=env[3][2];return [4,v]}
            return [2,env,prod]}
          function initiate(env)
           {if(log)caml_call1(Log[5],0);
            var env$0=[0,1,env[2],env[3],env[4]];
            return [3,env$0]}
          function reduce(env,prod)
           {if(log)caml_call1(Log[3],prod);
            try
             {var stack=caml_call2(T[16],prod,env)}
            catch(_ab_)
             {_ab_ = caml_wrap_exception(_ab_);
              if(_ab_ === Error)return initiate(env);
              throw _ab_}
            var
             current=caml_call2(T[12],stack[1],prod),
             env$0=[0,env[1],env[2],stack,current];
            return run(env$0,0)}
          function error_shift(env,please_discard,terminal,value,s)
           {if(caml_equal(terminal,T[4]))
             if(caml_equal(value,T[5]))
              {if(log)caml_call1(Log[7],env[4]);
               return shift(env,please_discard,terminal,value,s)}
            throw [0,Assert_failure,_b_]}
          function error_reduce(env,prod)
           {if(log)caml_call1(Log[7],env[4]);return reduce(env,prod)}
          function error_fail(env)
           {var cell=env[3],next=cell[5];
            if(next === cell)return 0;
            var env$0=[0,env[1],env[2],next,cell[1]];
            return [3,env$0]}
          function start(s,initial)
           {var empty=[];
            runtime.caml_update_dummy(empty,[0,s,T[5],initial,initial,empty]);
            var env=[0,0,[0,0,initial,initial],empty,s];
            return run(env,1)}
          function offer(param)
           {if(typeof param !== "number" && 0 === param[0])
             {var env=param[1];
              return function(triple)
               {if(log)
                 {var
                   endp=triple[3],
                   startp=triple[2],
                   token=triple[1],
                   _aa_=caml_call1(T[2],token);
                  caml_call3(Log[4],_aa_,startp,endp)}
                var env$0=[0,0,triple,env[3],env[4]];
                return check_for_default_reduction(env$0)}}
            return caml_call1(Pervasives[1],cst_offer_expects_InputNeeded)}
          function resume(param)
           {if(typeof param !== "number")
             switch(param[0])
              {case 1:
                var please_discard=param[3],env=param[2];
                return run(env,please_discard);
               case 2:
                var prod=param[2],env$0=param[1];return reduce(env$0,prod);
               case 3:
                var env$1=param[1];
                if(env$1[1])
                 return caml_call7
                         (T[10],
                          env$1[4],
                          T[4],
                          T[5],
                          error_shift,
                          error_reduce,
                          error_fail,
                          env$1);
                throw [0,Assert_failure,_a_]
               }
            return caml_call1
                    (Pervasives[1],
                     cst_resume_expects_HandlingError_Shifting_AboutToReduce)}
          function lexer_lexbuf_to_supplier(lexer,lexbuf,param)
           {var
             token=caml_call1(lexer,lexbuf),
             startp=lexbuf[11],
             endp=lexbuf[12];
            return [0,token,startp,endp]}
          function loop(read,checkpoint)
           {var checkpoint$0=checkpoint;
            for(;;)
             if(typeof checkpoint$0 === "number")
              throw Error;
             else
              switch(checkpoint$0[0])
               {case 0:
                 var
                  triple=caml_call1(read,0),
                  checkpoint$1=caml_call1(offer(checkpoint$0),triple),
                  checkpoint$0=checkpoint$1;
                 continue;
                case 4:var v=checkpoint$0[1];return v;
                default:
                 var
                  checkpoint$2=resume(checkpoint$0),
                  checkpoint$0=checkpoint$2;
                 continue}}
          function entry(s,lexer,lexbuf)
           {var initial=lexbuf[12],___=start(s,initial);
            return loop
                    (function(_$_)
                      {return lexer_lexbuf_to_supplier(lexer,lexbuf,_$_)},
                     ___)}
          function loop_handle(succeed,fail,read,checkpoint)
           {var checkpoint$0=checkpoint;
            for(;;)
             {if(typeof checkpoint$0 !== "number")
               switch(checkpoint$0[0])
                {case 0:
                  var
                   triple=caml_call1(read,0),
                   checkpoint$1=caml_call1(offer(checkpoint$0),triple),
                   checkpoint$0=checkpoint$1;
                  continue;
                 case 4:var v=checkpoint$0[1];return caml_call1(succeed,v);
                 case 3:break;
                 default:
                  var
                   checkpoint$2=resume(checkpoint$0),
                   checkpoint$0=checkpoint$2;
                  continue}
              return caml_call1(fail,checkpoint$0)}}
          function loop_handle_undo(succeed,fail,read,checkpoint$2)
           {if(typeof checkpoint$2 === "number")
             var switch$0=0;
            else
             if(0 === checkpoint$2[0])
              var _Z_=1,switch$0=1;
             else
              var switch$0=0;
            if(! switch$0)var _Z_=0;
            if(_Z_)
             {var param$2=[0,checkpoint$2,checkpoint$2],param=param$2;
              for(;;)
               {var checkpoint=param[2],inputneeded=param[1];
                if(typeof checkpoint !== "number")
                 switch(checkpoint[0])
                  {case 0:
                    var
                     triple=caml_call1(read,0),
                     checkpoint$0=caml_call1(offer(checkpoint),triple),
                     param$0=[0,checkpoint,checkpoint$0],
                     param=param$0;
                    continue;
                   case 4:var v=checkpoint[1];return caml_call1(succeed,v);
                   case 3:break;
                   default:
                    var
                     checkpoint$1=resume(checkpoint),
                     param$1=[0,inputneeded,checkpoint$1],
                     param=param$1;
                    continue}
                return caml_call2(fail,inputneeded,checkpoint)}}
            throw [0,Assert_failure,_c_]}
          function shifts(checkpoint)
           {var checkpoint$0=checkpoint;
            for(;;)
             {if(typeof checkpoint$0 !== "number")
               switch(checkpoint$0[0])
                {case 1:var env=checkpoint$0[1];return [0,env];
                 case 2:
                  var
                   checkpoint$1=resume(checkpoint$0),
                   checkpoint$0=checkpoint$1;
                  continue;
                 case 3:return 0
                 }
              throw [0,Assert_failure,_d_]}}
          function acceptable(checkpoint,token,pos)
           {var
             triple=[0,token,pos,pos],
             checkpoint$0=caml_call1(offer(checkpoint),triple),
             match=shifts(checkpoint$0);
            return match?1:0}
          function _S_(cell,current)
           {return [246,
                    function(param)
                     {var next=cell[5];
                      if(next === cell)return 0;
                      var element=[0,current,cell[2],cell[3],cell[4]];
                      return [0,element,_S_(next,cell[1])]}]}
          function stack(env){return _S_(env[3],env[4])}
          function top(env)
           {var cell=env[3],next=cell[5];
            return next === cell?0:[0,[0,env[4],cell[2],cell[3],cell[4]]]}
          function equal(env1,env2)
           {var _W_=env1[3] === env2[3]?1:0;
            if(_W_)
             var
              _X_=caml_call1(number,env2[4]),
              _Y_=caml_call1(number,env1[4]) === _X_?1:0;
            else
             var _Y_=_W_;
            return _Y_}
          function current_state_number(env){return caml_call1(number,env[4])}
          function positions(param)
           {var match=param[2],endp=match[3],startp=match[2];
            return [0,startp,endp]}
          function state_has_default_reduction(state)
           {var _T_=0;
            function _U_(env){return 0}
            function _V_(env,prod){return 1}
            return caml_call4(T[9],state,_V_,_U_,_T_)}
          function env_has_default_reduction(env)
           {return state_has_default_reduction(env[4])}
          function pop(env)
           {var cell=env[3],next=cell[5];
            return next === cell?0:[0,[0,env[1],env[2],next,cell[1]]]}
          function force_reduction(prod,env)
           {if(caml_call2(T[17],env[4],prod))
             {if(caml_call1(T[14],prod))throw [0,Assert_failure,_e_];
              var
               stack=caml_call2(T[16],prod,env),
               current=caml_call2(T[12],stack[1],prod);
              return [0,env[1],env[2],stack,current]}
            return caml_call1
                    (Pervasives[1],
                     cst_force_reduction_this_reduction_is_not_permitted_in_this_state)}
          function input_needed(env){return [0,env]}
          function pop_many(i,env)
           {var i$0=i,env$0=env;
            for(;;)
             {if(0 === i$0)return [0,env$0];
              var match=pop(env$0);
              if(match)
               {var env$1=match[1],i$1=i$0 - 1 | 0,i$0=i$1,env$0=env$1;
                continue}
              return 0}}
          function get(i,env)
           {var match=pop_many(i,env);
            if(match){var env$0=match[1];return top(env$0)}
            return 0}
          return [0,
                  Error,
                  entry,
                  offer,
                  resume,
                  lexer_lexbuf_to_supplier,
                  loop,
                  loop_handle,
                  loop_handle_undo,
                  shifts,
                  acceptable,
                  number,
                  production_index,
                  find_production,
                  stack,
                  top,
                  pop_many,
                  get,
                  current_state_number,
                  equal,
                  positions,
                  env_has_default_reduction,
                  state_has_default_reduction,
                  pop,
                  force_reduction,
                  input_needed,
                  start]}],
       _R_,
       _Q_,
       _P_,
       _O_,
       _N_,
       _M_,
       TableFormat,
       InspectionTableFormat,
       _L_,
       _K_,
       StaticVersion];
    runtime.caml_register_global(58,MenhirLib,"MenhirLib");
    return}
  (function(){return this}()));


//# 1 "../.js/js_of_ocaml/js_of_ocaml.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_float_of_string=runtime.caml_float_of_string,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_int_of_string=runtime.caml_int_of_string,
     caml_js_from_array=runtime.caml_js_from_array,
     caml_js_from_string=runtime.caml_js_from_string,
     caml_js_get=runtime.caml_js_get,
     caml_js_html_escape=runtime.caml_js_html_escape,
     caml_js_set=runtime.caml_js_set,
     caml_js_to_byte_string=runtime.caml_js_to_byte_string,
     caml_js_to_string=runtime.caml_js_to_string,
     caml_js_wrap_callback=runtime.caml_js_wrap_callback,
     caml_js_wrap_meth_callback=runtime.caml_js_wrap_meth_callback,
     caml_jsbytes_of_string=runtime.caml_jsbytes_of_string,
     caml_list_of_js_array=runtime.caml_list_of_js_array,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_new_string=runtime.caml_new_string,
     caml_register_global=runtime.caml_register_global,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_array=runtime.caml_string_of_array,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_parseFloat=caml_new_string("parseFloat"),
     cst_parseInt=caml_new_string("parseInt"),
     cst_Js_of_ocaml_Js_Error=caml_new_string("Js_of_ocaml__Js.Error"),
     cst_jsError=caml_new_string("jsError"),
     cst_can_t_retrieve_file_name_not_implemented=
      caml_new_string("can't retrieve file name: not implemented"),
     cst_endings=caml_new_string("endings"),
     cst_type=caml_new_string("type"),
     cst_loadstart=caml_new_string("loadstart"),
     cst_progress=caml_new_string("progress"),
     cst_abort=caml_new_string("abort"),
     cst_error=caml_new_string("error"),
     cst_load=caml_new_string("load"),
     cst_loadend=caml_new_string("loadend"),
     cst_a$1=caml_new_string("a"),
     cst_area$1=caml_new_string("area"),
     cst_audio$1=caml_new_string("audio"),
     cst_base$1=caml_new_string("base"),
     cst_blockquote$1=caml_new_string("blockquote"),
     cst_body$1=caml_new_string("body"),
     cst_br$1=caml_new_string("br"),
     cst_button$1=caml_new_string("button"),
     cst_canvas$1=caml_new_string("canvas"),
     cst_caption$1=caml_new_string("caption"),
     cst_col$1=caml_new_string("col"),
     cst_colgroup$1=caml_new_string("colgroup"),
     cst_del$1=caml_new_string("del"),
     cst_div$1=caml_new_string("div"),
     cst_dl$1=caml_new_string("dl"),
     cst_embed$1=caml_new_string("embed"),
     cst_fieldset$1=caml_new_string("fieldset"),
     cst_form$1=caml_new_string("form"),
     cst_frame$1=caml_new_string("frame"),
     cst_frameset$1=caml_new_string("frameset"),
     cst_h1$1=caml_new_string("h1"),
     cst_h2$1=caml_new_string("h2"),
     cst_h3$1=caml_new_string("h3"),
     cst_h4$1=caml_new_string("h4"),
     cst_h5$1=caml_new_string("h5"),
     cst_h6$1=caml_new_string("h6"),
     cst_head$1=caml_new_string("head"),
     cst_hr$1=caml_new_string("hr"),
     cst_html$1=caml_new_string("html"),
     cst_iframe$1=caml_new_string("iframe"),
     cst_img$1=caml_new_string("img"),
     cst_input$2=caml_new_string("input"),
     cst_ins$1=caml_new_string("ins"),
     cst_label$1=caml_new_string("label"),
     cst_legend$1=caml_new_string("legend"),
     cst_li$1=caml_new_string("li"),
     cst_link$1=caml_new_string("link"),
     cst_map$1=caml_new_string("map"),
     cst_meta$1=caml_new_string("meta"),
     cst_object$1=caml_new_string("object"),
     cst_ol$1=caml_new_string("ol"),
     cst_optgroup$1=caml_new_string("optgroup"),
     cst_option$1=caml_new_string("option"),
     cst_p$1=caml_new_string("p"),
     cst_param$1=caml_new_string("param"),
     cst_pre$1=caml_new_string("pre"),
     cst_q$1=caml_new_string("q"),
     cst_script$1=caml_new_string("script"),
     cst_select$2=caml_new_string("select"),
     cst_style$1=caml_new_string("style"),
     cst_table$1=caml_new_string("table"),
     cst_tbody$1=caml_new_string("tbody"),
     cst_td$1=caml_new_string("td"),
     cst_textarea$1=caml_new_string("textarea"),
     cst_tfoot$1=caml_new_string("tfoot"),
     cst_th$1=caml_new_string("th"),
     cst_thead$1=caml_new_string("thead"),
     cst_title$1=caml_new_string("title"),
     cst_tr$1=caml_new_string("tr"),
     cst_ul$1=caml_new_string("ul"),
     cst_video$1=caml_new_string("video"),
     cst_KeyH=caml_new_string("KeyH"),
     cst_Digit6=caml_new_string("Digit6"),
     cst_BrowserRefresh=caml_new_string("BrowserRefresh"),
     cst_Backslash=caml_new_string("Backslash"),
     cst_AltLeft=caml_new_string("AltLeft"),
     cst_AltRight=caml_new_string("AltRight"),
     cst_ArrowDown=caml_new_string("ArrowDown"),
     cst_ArrowLeft=caml_new_string("ArrowLeft"),
     cst_ArrowRight=caml_new_string("ArrowRight"),
     cst_ArrowUp=caml_new_string("ArrowUp"),
     cst_Backquote=caml_new_string("Backquote"),
     cst_Backspace=caml_new_string("Backspace"),
     cst_BracketLeft=caml_new_string("BracketLeft"),
     cst_BracketRight=caml_new_string("BracketRight"),
     cst_BrowserBack=caml_new_string("BrowserBack"),
     cst_BrowserFavorites=caml_new_string("BrowserFavorites"),
     cst_BrowserForward=caml_new_string("BrowserForward"),
     cst_BrowserHome=caml_new_string("BrowserHome"),
     cst_Delete=caml_new_string("Delete"),
     cst_BrowserSearch=caml_new_string("BrowserSearch"),
     cst_BrowserStop=caml_new_string("BrowserStop"),
     cst_CapsLock=caml_new_string("CapsLock"),
     cst_Comma=caml_new_string("Comma"),
     cst_ContextMenu=caml_new_string("ContextMenu"),
     cst_ControlLeft=caml_new_string("ControlLeft"),
     cst_ControlRight=caml_new_string("ControlRight"),
     cst_Digit0=caml_new_string("Digit0"),
     cst_Digit1=caml_new_string("Digit1"),
     cst_Digit2=caml_new_string("Digit2"),
     cst_Digit3=caml_new_string("Digit3"),
     cst_Digit4=caml_new_string("Digit4"),
     cst_Digit5=caml_new_string("Digit5"),
     cst_F6=caml_new_string("F6"),
     cst_F1=caml_new_string("F1"),
     cst_Digit7=caml_new_string("Digit7"),
     cst_Digit8=caml_new_string("Digit8"),
     cst_Digit9=caml_new_string("Digit9"),
     cst_End=caml_new_string("End"),
     cst_Enter=caml_new_string("Enter"),
     cst_Equal=caml_new_string("Equal"),
     cst_Escape=caml_new_string("Escape"),
     cst_F10=caml_new_string("F10"),
     cst_F11=caml_new_string("F11"),
     cst_F12=caml_new_string("F12"),
     cst_F2=caml_new_string("F2"),
     cst_F3=caml_new_string("F3"),
     cst_F4=caml_new_string("F4"),
     cst_F5=caml_new_string("F5"),
     cst_KeyA=caml_new_string("KeyA"),
     cst_F7=caml_new_string("F7"),
     cst_F8=caml_new_string("F8"),
     cst_F9=caml_new_string("F9"),
     cst_Home=caml_new_string("Home"),
     cst_Insert=caml_new_string("Insert"),
     cst_IntlBackslash=caml_new_string("IntlBackslash"),
     cst_IntlYen=caml_new_string("IntlYen"),
     cst_KeyB=caml_new_string("KeyB"),
     cst_KeyC=caml_new_string("KeyC"),
     cst_KeyD=caml_new_string("KeyD"),
     cst_KeyE=caml_new_string("KeyE"),
     cst_KeyF=caml_new_string("KeyF"),
     cst_KeyG=caml_new_string("KeyG"),
     cst_Numpad4=caml_new_string("Numpad4"),
     cst_KeyX=caml_new_string("KeyX"),
     cst_KeyP=caml_new_string("KeyP"),
     cst_KeyI=caml_new_string("KeyI"),
     cst_KeyJ=caml_new_string("KeyJ"),
     cst_KeyK=caml_new_string("KeyK"),
     cst_KeyL=caml_new_string("KeyL"),
     cst_KeyM=caml_new_string("KeyM"),
     cst_KeyN=caml_new_string("KeyN"),
     cst_KeyO=caml_new_string("KeyO"),
     cst_KeyQ=caml_new_string("KeyQ"),
     cst_KeyR=caml_new_string("KeyR"),
     cst_KeyS=caml_new_string("KeyS"),
     cst_KeyT=caml_new_string("KeyT"),
     cst_KeyU=caml_new_string("KeyU"),
     cst_KeyV=caml_new_string("KeyV"),
     cst_KeyW=caml_new_string("KeyW"),
     cst_MetaRight=caml_new_string("MetaRight"),
     cst_KeyY=caml_new_string("KeyY"),
     cst_KeyZ=caml_new_string("KeyZ"),
     cst_MediaPlayPause=caml_new_string("MediaPlayPause"),
     cst_MediaStop=caml_new_string("MediaStop"),
     cst_MediaTrackNext=caml_new_string("MediaTrackNext"),
     cst_MediaTrackPrevious=caml_new_string("MediaTrackPrevious"),
     cst_MetaLeft=caml_new_string("MetaLeft"),
     cst_Minus=caml_new_string("Minus"),
     cst_NumLock=caml_new_string("NumLock"),
     cst_Numpad0=caml_new_string("Numpad0"),
     cst_Numpad1=caml_new_string("Numpad1"),
     cst_Numpad2=caml_new_string("Numpad2"),
     cst_Numpad3=caml_new_string("Numpad3"),
     cst_PageUp=caml_new_string("PageUp"),
     cst_NumpadDivide=caml_new_string("NumpadDivide"),
     cst_Numpad5=caml_new_string("Numpad5"),
     cst_Numpad6=caml_new_string("Numpad6"),
     cst_Numpad7=caml_new_string("Numpad7"),
     cst_Numpad8=caml_new_string("Numpad8"),
     cst_Numpad9=caml_new_string("Numpad9"),
     cst_NumpadAdd=caml_new_string("NumpadAdd"),
     cst_NumpadDecimal=caml_new_string("NumpadDecimal"),
     cst_NumpadEnter=caml_new_string("NumpadEnter"),
     cst_NumpadEqual=caml_new_string("NumpadEqual"),
     cst_NumpadMultiply=caml_new_string("NumpadMultiply"),
     cst_NumpadSubtract=caml_new_string("NumpadSubtract"),
     cst_OSLeft=caml_new_string("OSLeft"),
     cst_OSRight=caml_new_string("OSRight"),
     cst_PageDown=caml_new_string("PageDown"),
     cst_ShiftRight=caml_new_string("ShiftRight"),
     cst_Pause=caml_new_string("Pause"),
     cst_Period=caml_new_string("Period"),
     cst_PrintScreen=caml_new_string("PrintScreen"),
     cst_Quote=caml_new_string("Quote"),
     cst_ScrollLock=caml_new_string("ScrollLock"),
     cst_Semicolon=caml_new_string("Semicolon"),
     cst_ShiftLeft=caml_new_string("ShiftLeft"),
     cst_Slash=caml_new_string("Slash"),
     cst_Space=caml_new_string("Space"),
     cst_Tab=caml_new_string("Tab"),
     cst_VolumeDown=caml_new_string("VolumeDown"),
     cst_VolumeMute=caml_new_string("VolumeMute"),
     cst_VolumeUp=caml_new_string("VolumeUp"),
     cst_mouseout$0=caml_new_string("mouseout"),
     cst_mouseover$0=caml_new_string("mouseover"),
     cst_video$0=caml_new_string("video"),
     cst_audio$0=caml_new_string("audio"),
     cst_ul$0=caml_new_string("ul"),
     cst_tr$0=caml_new_string("tr"),
     cst_title$0=caml_new_string("title"),
     cst_thead$0=caml_new_string("thead"),
     cst_th$0=caml_new_string("th"),
     cst_tfoot$0=caml_new_string("tfoot"),
     cst_textarea$0=caml_new_string("textarea"),
     cst_td$0=caml_new_string("td"),
     cst_tbody$0=caml_new_string("tbody"),
     cst_table$0=caml_new_string("table"),
     cst_style$0=caml_new_string("style"),
     cst_select$1=caml_new_string("select"),
     cst_script$0=caml_new_string("script"),
     cst_q$0=caml_new_string("q"),
     cst_pre$0=caml_new_string("pre"),
     cst_param$0=caml_new_string("param"),
     cst_p$0=caml_new_string("p"),
     cst_option$0=caml_new_string("option"),
     cst_optgroup$0=caml_new_string("optgroup"),
     cst_ol$0=caml_new_string("ol"),
     cst_object$0=caml_new_string("object"),
     cst_meta$0=caml_new_string("meta"),
     cst_map$0=caml_new_string("map"),
     cst_link$0=caml_new_string("link"),
     cst_li$0=caml_new_string("li"),
     cst_legend$0=caml_new_string("legend"),
     cst_label$0=caml_new_string("label"),
     cst_ins$0=caml_new_string("ins"),
     cst_input$1=caml_new_string("input"),
     cst_img$0=caml_new_string("img"),
     cst_iframe$0=caml_new_string("iframe"),
     cst_html$0=caml_new_string("html"),
     cst_hr$0=caml_new_string("hr"),
     cst_head$0=caml_new_string("head"),
     cst_h6$0=caml_new_string("h6"),
     cst_h5$0=caml_new_string("h5"),
     cst_h4$0=caml_new_string("h4"),
     cst_h3$0=caml_new_string("h3"),
     cst_h2$0=caml_new_string("h2"),
     cst_h1$0=caml_new_string("h1"),
     cst_frame$0=caml_new_string("frame"),
     cst_frameset$0=caml_new_string("frameset"),
     cst_form$0=caml_new_string("form"),
     cst_embed$0=caml_new_string("embed"),
     cst_fieldset$0=caml_new_string("fieldset"),
     cst_dl$0=caml_new_string("dl"),
     cst_div$0=caml_new_string("div"),
     cst_del$0=caml_new_string("del"),
     cst_colgroup$0=caml_new_string("colgroup"),
     cst_col$0=caml_new_string("col"),
     cst_caption$0=caml_new_string("caption"),
     cst_canvas$0=caml_new_string("canvas"),
     cst_button$0=caml_new_string("button"),
     cst_br$0=caml_new_string("br"),
     cst_body$0=caml_new_string("body"),
     cst_blockquote$0=caml_new_string("blockquote"),
     cst_base$0=caml_new_string("base"),
     cst_area$0=caml_new_string("area"),
     cst_a$0=caml_new_string("a"),
     cst_canvas=caml_new_string("canvas"),
     cst_video=caml_new_string("video"),
     cst_audio=caml_new_string("audio"),
     cst_iframe=caml_new_string("iframe"),
     cst_frame=caml_new_string("frame"),
     cst_frameset=caml_new_string("frameset"),
     cst_address=caml_new_string("address"),
     cst_noscript=caml_new_string("noscript"),
     cst_dt=caml_new_string("dt"),
     cst_dd=caml_new_string("dd"),
     cst_abbr=caml_new_string("abbr"),
     cst_var=caml_new_string("var"),
     cst_kbd=caml_new_string("kbd"),
     cst_samp=caml_new_string("samp"),
     cst_code=caml_new_string("code"),
     cst_dfn=caml_new_string("dfn"),
     cst_cite=caml_new_string("cite"),
     cst_strong=caml_new_string("strong"),
     cst_em=caml_new_string("em"),
     cst_small=caml_new_string("small"),
     cst_big=caml_new_string("big"),
     cst_b=caml_new_string("b"),
     cst_i=caml_new_string("i"),
     cst_tt=caml_new_string("tt"),
     cst_span=caml_new_string("span"),
     cst_sup=caml_new_string("sup"),
     cst_sub=caml_new_string("sub"),
     cst_td=caml_new_string("td"),
     cst_th=caml_new_string("th"),
     cst_tr=caml_new_string("tr"),
     cst_tbody=caml_new_string("tbody"),
     cst_tfoot=caml_new_string("tfoot"),
     cst_thead=caml_new_string("thead"),
     cst_colgroup=caml_new_string("colgroup"),
     cst_col=caml_new_string("col"),
     cst_caption=caml_new_string("caption"),
     cst_table=caml_new_string("table"),
     cst_script=caml_new_string("script"),
     cst_area=caml_new_string("area"),
     cst_map=caml_new_string("map"),
     cst_param=caml_new_string("param"),
     cst_object=caml_new_string("object"),
     cst_img=caml_new_string("img"),
     cst_a=caml_new_string("a"),
     cst_del=caml_new_string("del"),
     cst_ins=caml_new_string("ins"),
     cst_hr=caml_new_string("hr"),
     cst_br=caml_new_string("br"),
     cst_pre=caml_new_string("pre"),
     cst_blockquote=caml_new_string("blockquote"),
     cst_q=caml_new_string("q"),
     cst_h6=caml_new_string("h6"),
     cst_h5=caml_new_string("h5"),
     cst_h4=caml_new_string("h4"),
     cst_h3=caml_new_string("h3"),
     cst_h2=caml_new_string("h2"),
     cst_h1=caml_new_string("h1"),
     cst_p=caml_new_string("p"),
     cst_embed=caml_new_string("embed"),
     cst_div=caml_new_string("div"),
     cst_li=caml_new_string("li"),
     cst_dl=caml_new_string("dl"),
     cst_ol=caml_new_string("ol"),
     cst_ul=caml_new_string("ul"),
     cst_legend=caml_new_string("legend"),
     cst_fieldset=caml_new_string("fieldset"),
     cst_label=caml_new_string("label"),
     cst_button=caml_new_string("button"),
     cst_textarea=caml_new_string("textarea"),
     cst_input$0=caml_new_string("input"),
     cst_select$0=caml_new_string("select"),
     cst_option=caml_new_string("option"),
     cst_optgroup=caml_new_string("optgroup"),
     cst_form=caml_new_string("form"),
     cst_body=caml_new_string("body"),
     cst_style=caml_new_string("style"),
     cst_base=caml_new_string("base"),
     cst_meta=caml_new_string("meta"),
     cst_title=caml_new_string("title"),
     cst_link=caml_new_string("link"),
     cst_head=caml_new_string("head"),
     cst_html=caml_new_string("html"),
     cst_click=caml_new_string("click"),
     cst_dblclick=caml_new_string("dblclick"),
     cst_mousedown=caml_new_string("mousedown"),
     cst_mouseup=caml_new_string("mouseup"),
     cst_mouseover=caml_new_string("mouseover"),
     cst_mousemove=caml_new_string("mousemove"),
     cst_mouseout=caml_new_string("mouseout"),
     cst_keypress=caml_new_string("keypress"),
     cst_keydown=caml_new_string("keydown"),
     cst_keyup=caml_new_string("keyup"),
     cst_mousewheel=caml_new_string("mousewheel"),
     cst_DOMMouseScroll=caml_new_string("DOMMouseScroll"),
     cst_touchstart=caml_new_string("touchstart"),
     cst_touchmove=caml_new_string("touchmove"),
     cst_touchend=caml_new_string("touchend"),
     cst_touchcancel=caml_new_string("touchcancel"),
     cst_dragstart=caml_new_string("dragstart"),
     cst_dragend=caml_new_string("dragend"),
     cst_dragenter=caml_new_string("dragenter"),
     cst_dragover=caml_new_string("dragover"),
     cst_dragleave=caml_new_string("dragleave"),
     cst_drag=caml_new_string("drag"),
     cst_drop=caml_new_string("drop"),
     cst_hashchange=caml_new_string("hashchange"),
     cst_change=caml_new_string("change"),
     cst_input=caml_new_string("input"),
     cst_timeupdate=caml_new_string("timeupdate"),
     cst_submit=caml_new_string("submit"),
     cst_scroll=caml_new_string("scroll"),
     cst_focus=caml_new_string("focus"),
     cst_blur=caml_new_string("blur"),
     cst_load$0=caml_new_string("load"),
     cst_unload=caml_new_string("unload"),
     cst_beforeunload=caml_new_string("beforeunload"),
     cst_resize=caml_new_string("resize"),
     cst_orientationchange=caml_new_string("orientationchange"),
     cst_popstate=caml_new_string("popstate"),
     cst_error$0=caml_new_string("error"),
     cst_abort$0=caml_new_string("abort"),
     cst_select=caml_new_string("select"),
     cst_online=caml_new_string("online"),
     cst_offline=caml_new_string("offline"),
     cst_checking=caml_new_string("checking"),
     cst_noupdate=caml_new_string("noupdate"),
     cst_downloading=caml_new_string("downloading"),
     cst_progress$0=caml_new_string("progress"),
     cst_updateready=caml_new_string("updateready"),
     cst_cached=caml_new_string("cached"),
     cst_obsolete=caml_new_string("obsolete"),
     cst_DOMContentLoaded=caml_new_string("DOMContentLoaded"),
     cst_animationstart=caml_new_string("animationstart"),
     cst_animationend=caml_new_string("animationend"),
     cst_animationiteration=caml_new_string("animationiteration"),
     cst_animationcancel=caml_new_string("animationcancel"),
     cst_canplay=caml_new_string("canplay"),
     cst_canplaythrough=caml_new_string("canplaythrough"),
     cst_durationchange=caml_new_string("durationchange"),
     cst_emptied=caml_new_string("emptied"),
     cst_ended=caml_new_string("ended"),
     cst_gotpointercapture=caml_new_string("gotpointercapture"),
     cst_loadeddata=caml_new_string("loadeddata"),
     cst_loadedmetadata=caml_new_string("loadedmetadata"),
     cst_loadstart$0=caml_new_string("loadstart"),
     cst_lostpointercapture=caml_new_string("lostpointercapture"),
     cst_pause=caml_new_string("pause"),
     cst_play=caml_new_string("play"),
     cst_playing=caml_new_string("playing"),
     cst_pointerenter=caml_new_string("pointerenter"),
     cst_pointercancel=caml_new_string("pointercancel"),
     cst_pointerdown=caml_new_string("pointerdown"),
     cst_pointerleave=caml_new_string("pointerleave"),
     cst_pointermove=caml_new_string("pointermove"),
     cst_pointerout=caml_new_string("pointerout"),
     cst_pointerover=caml_new_string("pointerover"),
     cst_pointerup=caml_new_string("pointerup"),
     cst_ratechange=caml_new_string("ratechange"),
     cst_seeked=caml_new_string("seeked"),
     cst_seeking=caml_new_string("seeking"),
     cst_stalled=caml_new_string("stalled"),
     cst_suspend=caml_new_string("suspend"),
     cst_volumechange=caml_new_string("volumechange"),
     cst_waiting=caml_new_string("waiting"),
     cst_Js_of_ocaml_Dom_html_Canvas_not_available=
      caml_new_string("Js_of_ocaml__Dom_html.Canvas_not_available"),
     cst_checkbox=caml_new_string("checkbox"),
     cst_file=caml_new_string("file"),
     cst_password=caml_new_string("password"),
     cst_radio=caml_new_string("radio"),
     cst_reset=caml_new_string("reset"),
     cst_submit$0=caml_new_string("submit"),
     cst_text=caml_new_string("text"),
     cst_readystatechange=caml_new_string("readystatechange"),
     cst_loadstart$1=caml_new_string("loadstart"),
     cst_progress$1=caml_new_string("progress"),
     cst_abort$1=caml_new_string("abort"),
     cst_error$1=caml_new_string("error"),
     cst_load$1=caml_new_string("load"),
     cst_timeout=caml_new_string("timeout"),
     cst_loadend$0=caml_new_string("loadend"),
     cst_Worker_onmessage_is_undefined$0=
      caml_new_string("Worker.onmessage is undefined"),
     cst_Worker_onmessage_is_undefined=
      caml_new_string("Worker.onmessage is undefined"),
     cst_Worker_import_scripts_is_undefined=
      caml_new_string("Worker.import_scripts is undefined"),
     cst_webglcontextlost=caml_new_string("webglcontextlost"),
     cst_webglcontextrestored=caml_new_string("webglcontextrestored"),
     cst_webglcontextcreationerror=
      caml_new_string("webglcontextcreationerror"),
     cst_g=caml_new_string("g"),
     cst=caml_new_string("[\\][()\\\\|+*.?{}^$]"),
     cst$37=caml_new_string(""),
     cst$13=caml_new_string(""),
     cst$21=caml_new_string(""),
     cst$14=caml_new_string("#"),
     cst$15=caml_new_string("?"),
     cst$20=caml_new_string(""),
     cst$16=caml_new_string("/"),
     cst$17=caml_new_string("/"),
     cst$19=caml_new_string(":"),
     cst$18=caml_new_string(""),
     cst_http$1=caml_new_string("http://"),
     cst$22=caml_new_string(""),
     cst$30=caml_new_string(""),
     cst$23=caml_new_string("#"),
     cst$24=caml_new_string("?"),
     cst$29=caml_new_string(""),
     cst$25=caml_new_string("/"),
     cst$26=caml_new_string("/"),
     cst$28=caml_new_string(":"),
     cst$27=caml_new_string(""),
     cst_https$1=caml_new_string("https://"),
     cst$31=caml_new_string(""),
     cst$36=caml_new_string(""),
     cst$32=caml_new_string("#"),
     cst$33=caml_new_string("?"),
     cst$35=caml_new_string(""),
     cst$34=caml_new_string("/"),
     cst_file$2=caml_new_string("file://"),
     cst$12=caml_new_string(""),
     cst$11=caml_new_string(""),
     cst$10=caml_new_string(""),
     cst$9=caml_new_string(""),
     cst$8=caml_new_string(""),
     cst$7=caml_new_string(""),
     cst$6=caml_new_string(""),
     cst$4=caml_new_string("="),
     cst$5=caml_new_string("&"),
     cst$2=caml_new_string(""),
     cst$3=caml_new_string(""),
     cst_file$0=caml_new_string("file"),
     cst_file$1=caml_new_string("file:"),
     cst_http=caml_new_string("http"),
     cst_http$0=caml_new_string("http:"),
     cst_https=caml_new_string("https"),
     cst_https$0=caml_new_string("https:"),
     cst$1=caml_new_string(" "),
     cst_2B=caml_new_string("%2B"),
     cst_Js_of_ocaml_Url_Local_exn=
      caml_new_string("Js_of_ocaml__Url.Local_exn"),
     cst$0=caml_new_string("+"),
     cst_Js_of_ocaml_Url_Not_an_http_protocol=
      caml_new_string("Js_of_ocaml__Url.Not_an_http_protocol"),
     cst_Hh_Tt_Tt_Pp_Ss_0_9a_zA_Z_0_9a_zA_Z_0_9A_Fa_f_0_9=
      caml_new_string
       ("^([Hh][Tt][Tt][Pp][Ss]?)://([0-9a-zA-Z.-]+|\\[[0-9a-zA-Z.-]+\\]|\\[[0-9A-Fa-f:.]+\\])?(:([0-9]+))?(/([^\\?#]*)(\\?([^#]*))?(#(.*))?)?$"),
     cst_Ff_Ii_Ll_Ee=
      caml_new_string
       ("^([Ff][Ii][Ll][Ee])://([^\\?#]*)(\\?([^#]*))?(#(.*))?$"),
     s=caml_new_string("3.5.2"),
     git_version=caml_new_string(""),
     cst$38=caml_new_string(""),
     cst$41=caml_new_string("+"),
     cst_Jstable_keys=caml_new_string("Jstable.keys"),
     dummy_string=caml_new_string(""),
     cst_is_not_a_valid_length$0=caml_new_string(" is not a valid length"),
     cst_d_d_deg_grad_rad_turns=
      caml_new_string("^(\\d*(?:\\.\\d*))(deg|grad|rad|turns)$"),
     cst_length_conversion_error$0=
      caml_new_string("length conversion error: "),
     cst_deg$0=caml_new_string("deg"),
     cst_grad$0=caml_new_string("grad"),
     cst_rad$0=caml_new_string("rad"),
     cst_turns$0=caml_new_string("turns"),
     cst_deg=caml_new_string("deg"),
     cst_grad=caml_new_string("grad"),
     cst_rad=caml_new_string("rad"),
     cst_turns=caml_new_string("turns"),
     cst_is_not_a_valid_length=caml_new_string(" is not a valid length"),
     cst_0$0=caml_new_string("0"),
     cst_d_d_s_S=caml_new_string("^(\\d*(?:\\.\\d*)?)\\s*(\\S*)$"),
     cst_length_conversion_error=caml_new_string("length conversion error: "),
     cst_pc$0=caml_new_string("pc"),
     cst_ch$0=caml_new_string("ch"),
     cst_cm$0=caml_new_string("cm"),
     cst_em$1=caml_new_string("em"),
     cst_ex$0=caml_new_string("ex"),
     cst_gd$0=caml_new_string("gd"),
     cst_in$0=caml_new_string("in"),
     cst_mm$0=caml_new_string("mm"),
     cst_pt$0=caml_new_string("pt"),
     cst_px$0=caml_new_string("px"),
     cst_rem$0=caml_new_string("rem"),
     cst_vh$0=caml_new_string("vh"),
     cst_vm$0=caml_new_string("vm"),
     cst_vw$0=caml_new_string("vw"),
     cst_0=caml_new_string("0"),
     cst_em$0=caml_new_string("em"),
     cst_ex=caml_new_string("ex"),
     cst_px=caml_new_string("px"),
     cst_gd=caml_new_string("gd"),
     cst_rem=caml_new_string("rem"),
     cst_vw=caml_new_string("vw"),
     cst_vh=caml_new_string("vh"),
     cst_vm=caml_new_string("vm"),
     cst_ch=caml_new_string("ch"),
     cst_mm=caml_new_string("mm"),
     cst_cm=caml_new_string("cm"),
     cst_in=caml_new_string("in"),
     cst_pt=caml_new_string("pt"),
     cst_pc=caml_new_string("pc"),
     cst$40=caml_new_string("): "),
     cst_color_conversion_error$0=caml_new_string("color conversion error ("),
     cst$39=caml_new_string("): "),
     cst_color_conversion_error=caml_new_string("color conversion error ("),
     cst_is_not_a_valid_color$0=caml_new_string(" is not a valid color"),
     cst_rgba_d_d_d_d_d=
      caml_new_string
       ("(rgba?)\\((?:(\\d*),(\\d*),(\\d*)(?:,(\\d*(?:\\.\\d*)?))?)\\)"),
     cst_rgba_d_d_d_d_d$0=
      caml_new_string
       ("(rgba?)\\((?:(\\d*)%,(\\d*)%,(\\d*)%(?:,(\\d*(?:\\.\\d*)?))?)\\)"),
     cst_hsla_d_d_d_d_d=
      caml_new_string
       ("(hsla?)\\((?:(\\d*),(\\d*)%,(\\d*)%(?:,(\\d*(?:\\.\\d*)?))?)\\)"),
     cst_rgb=caml_new_string("rgb"),
     cst_rgba=caml_new_string("rgba"),
     cst_rgb$0=caml_new_string("rgb"),
     cst_rgba$0=caml_new_string("rgba"),
     cst_hsl=caml_new_string("hsl"),
     cst_hsla=caml_new_string("hsla"),
     cst_rgb_s_d_s_d_s_d=
      caml_new_string("^rgb\\(\\s*\\d*,\\s*\\d*,\\s*\\d*\\)$"),
     cst_rgb_s_d_s_d_s_d$0=
      caml_new_string("^rgb\\(\\s*\\d*%,\\s*\\d*%,\\s*\\d*%\\)$"),
     cst_rgba_s_d_s_d_s_d_d_d=
      caml_new_string("^rgba\\(\\s*\\d*,\\s*\\d*,\\s*\\d*,\\d*\\.?\\d*\\)$"),
     cst_rgba_s_d_s_d_s_d_d_d$0=
      caml_new_string
       ("^rgba\\(\\s*\\d*%,\\s*\\d*%,\\s*\\d*%,\\d*\\.?\\d*\\)$"),
     cst_hsl_s_d_s_d_s_d=
      caml_new_string("^hsl\\(\\s*\\d*,\\s*\\d*%,\\s*\\d*%\\)$"),
     cst_hsla_s_d_s_d_s_d_d_d=
      caml_new_string("^hsla\\(\\s*\\d*,\\s*\\d*%,\\s*\\d*%,\\d*\\.?\\d*\\)$"),
     cst_is_not_a_valid_color=caml_new_string(" is not a valid color"),
     cst_is_out_of_valid_range=caml_new_string(" is out of valid range"),
     partial=[8,0,0,0,[12,41,0]],
     partial$0=[12,41,0],
     cst_lightgrey$0=caml_new_string("lightgrey"),
     cst_darkslategray$0=caml_new_string("darkslategray"),
     cst_cornsilk$0=caml_new_string("cornsilk"),
     cst_blue$0=caml_new_string("blue"),
     cst_aliceblue$0=caml_new_string("aliceblue"),
     cst_antiquewhite$0=caml_new_string("antiquewhite"),
     cst_aqua$0=caml_new_string("aqua"),
     cst_aquamarine$0=caml_new_string("aquamarine"),
     cst_azure$0=caml_new_string("azure"),
     cst_beige$0=caml_new_string("beige"),
     cst_bisque$0=caml_new_string("bisque"),
     cst_black$0=caml_new_string("black"),
     cst_blanchedalmond$0=caml_new_string("blanchedalmond"),
     cst_blueviolet$0=caml_new_string("blueviolet"),
     cst_brown$0=caml_new_string("brown"),
     cst_burlywood$0=caml_new_string("burlywood"),
     cst_cadetblue$0=caml_new_string("cadetblue"),
     cst_chartreuse$0=caml_new_string("chartreuse"),
     cst_chocolate$0=caml_new_string("chocolate"),
     cst_coral$0=caml_new_string("coral"),
     cst_cornflowerblue$0=caml_new_string("cornflowerblue"),
     cst_darkkhaki$0=caml_new_string("darkkhaki"),
     cst_crimson$0=caml_new_string("crimson"),
     cst_cyan$0=caml_new_string("cyan"),
     cst_darkblue$0=caml_new_string("darkblue"),
     cst_darkcyan$0=caml_new_string("darkcyan"),
     cst_darkgoldenrod$0=caml_new_string("darkgoldenrod"),
     cst_darkgray$0=caml_new_string("darkgray"),
     cst_darkgreen$0=caml_new_string("darkgreen"),
     cst_darkgrey$0=caml_new_string("darkgrey"),
     cst_darkmagenta$0=caml_new_string("darkmagenta"),
     cst_darkolivegreen$0=caml_new_string("darkolivegreen"),
     cst_darkorange$0=caml_new_string("darkorange"),
     cst_darkorchid$0=caml_new_string("darkorchid"),
     cst_darkred$0=caml_new_string("darkred"),
     cst_darksalmon$0=caml_new_string("darksalmon"),
     cst_darkseagreen$0=caml_new_string("darkseagreen"),
     cst_darkslateblue$0=caml_new_string("darkslateblue"),
     cst_greenyellow$0=caml_new_string("greenyellow"),
     cst_floralwhite$0=caml_new_string("floralwhite"),
     cst_darkslategrey$0=caml_new_string("darkslategrey"),
     cst_darkturquoise$0=caml_new_string("darkturquoise"),
     cst_darkviolet$0=caml_new_string("darkviolet"),
     cst_deeppink$0=caml_new_string("deeppink"),
     cst_deepskyblue$0=caml_new_string("deepskyblue"),
     cst_dimgray$0=caml_new_string("dimgray"),
     cst_dimgrey$0=caml_new_string("dimgrey"),
     cst_dodgerblue$0=caml_new_string("dodgerblue"),
     cst_firebrick$0=caml_new_string("firebrick"),
     cst_forestgreen$0=caml_new_string("forestgreen"),
     cst_fuchsia$0=caml_new_string("fuchsia"),
     cst_gainsboro$0=caml_new_string("gainsboro"),
     cst_ghostwhite$0=caml_new_string("ghostwhite"),
     cst_gold$0=caml_new_string("gold"),
     cst_goldenrod$0=caml_new_string("goldenrod"),
     cst_gray$0=caml_new_string("gray"),
     cst_green$0=caml_new_string("green"),
     cst_lavenderblush$0=caml_new_string("lavenderblush"),
     cst_grey$0=caml_new_string("grey"),
     cst_honeydew$0=caml_new_string("honeydew"),
     cst_hotpink$0=caml_new_string("hotpink"),
     cst_indianred$0=caml_new_string("indianred"),
     cst_indigo$0=caml_new_string("indigo"),
     cst_ivory$0=caml_new_string("ivory"),
     cst_khaki$0=caml_new_string("khaki"),
     cst_lavender$0=caml_new_string("lavender"),
     cst_lawngreen$0=caml_new_string("lawngreen"),
     cst_lemonchiffon$0=caml_new_string("lemonchiffon"),
     cst_lightblue$0=caml_new_string("lightblue"),
     cst_lightcoral$0=caml_new_string("lightcoral"),
     cst_lightcyan$0=caml_new_string("lightcyan"),
     cst_lightgoldenrodyellow$0=caml_new_string("lightgoldenrodyellow"),
     cst_lightgray$0=caml_new_string("lightgray"),
     cst_lightgreen$0=caml_new_string("lightgreen"),
     cst_paleturquoise$0=caml_new_string("paleturquoise"),
     cst_mediumslateblue$0=caml_new_string("mediumslateblue"),
     cst_limegreen$0=caml_new_string("limegreen"),
     cst_lightpink$0=caml_new_string("lightpink"),
     cst_lightsalmon$0=caml_new_string("lightsalmon"),
     cst_lightseagreen$0=caml_new_string("lightseagreen"),
     cst_lightskyblue$0=caml_new_string("lightskyblue"),
     cst_lightslategray$0=caml_new_string("lightslategray"),
     cst_lightslategrey$0=caml_new_string("lightslategrey"),
     cst_lightsteelblue$0=caml_new_string("lightsteelblue"),
     cst_lightyellow$0=caml_new_string("lightyellow"),
     cst_lime$0=caml_new_string("lime"),
     cst_linen$0=caml_new_string("linen"),
     cst_magenta$0=caml_new_string("magenta"),
     cst_maroon$0=caml_new_string("maroon"),
     cst_mediumaquamarine$0=caml_new_string("mediumaquamarine"),
     cst_mediumblue$0=caml_new_string("mediumblue"),
     cst_mediumorchid$0=caml_new_string("mediumorchid"),
     cst_mediumpurple$0=caml_new_string("mediumpurple"),
     cst_mediumseagreen$0=caml_new_string("mediumseagreen"),
     cst_navy$0=caml_new_string("navy"),
     cst_mediumspringgreen$0=caml_new_string("mediumspringgreen"),
     cst_mediumturquoise$0=caml_new_string("mediumturquoise"),
     cst_mediumvioletred$0=caml_new_string("mediumvioletred"),
     cst_midnightblue$0=caml_new_string("midnightblue"),
     cst_mintcream$0=caml_new_string("mintcream"),
     cst_mistyrose$0=caml_new_string("mistyrose"),
     cst_moccasin$0=caml_new_string("moccasin"),
     cst_navajowhite$0=caml_new_string("navajowhite"),
     cst_oldlace$0=caml_new_string("oldlace"),
     cst_olive$0=caml_new_string("olive"),
     cst_olivedrab$0=caml_new_string("olivedrab"),
     cst_orange$0=caml_new_string("orange"),
     cst_orangered$0=caml_new_string("orangered"),
     cst_orchid$0=caml_new_string("orchid"),
     cst_palegoldenrod$0=caml_new_string("palegoldenrod"),
     cst_palegreen$0=caml_new_string("palegreen"),
     cst_skyblue$0=caml_new_string("skyblue"),
     cst_rosybrown$0=caml_new_string("rosybrown"),
     cst_palevioletred$0=caml_new_string("palevioletred"),
     cst_papayawhip$0=caml_new_string("papayawhip"),
     cst_peachpuff$0=caml_new_string("peachpuff"),
     cst_peru$0=caml_new_string("peru"),
     cst_pink$0=caml_new_string("pink"),
     cst_plum$0=caml_new_string("plum"),
     cst_powderblue$0=caml_new_string("powderblue"),
     cst_purple$0=caml_new_string("purple"),
     cst_red$0=caml_new_string("red"),
     cst_royalblue$0=caml_new_string("royalblue"),
     cst_saddlebrown$0=caml_new_string("saddlebrown"),
     cst_salmon$0=caml_new_string("salmon"),
     cst_sandybrown$0=caml_new_string("sandybrown"),
     cst_seagreen$0=caml_new_string("seagreen"),
     cst_seashell$0=caml_new_string("seashell"),
     cst_sienna$0=caml_new_string("sienna"),
     cst_silver$0=caml_new_string("silver"),
     cst_thistle$0=caml_new_string("thistle"),
     cst_slateblue$0=caml_new_string("slateblue"),
     cst_slategray$0=caml_new_string("slategray"),
     cst_slategrey$0=caml_new_string("slategrey"),
     cst_snow$0=caml_new_string("snow"),
     cst_springgreen$0=caml_new_string("springgreen"),
     cst_steelblue$0=caml_new_string("steelblue"),
     cst_tan$0=caml_new_string("tan"),
     cst_teal$0=caml_new_string("teal"),
     cst_tomato$0=caml_new_string("tomato"),
     cst_turquoise$0=caml_new_string("turquoise"),
     cst_violet$0=caml_new_string("violet"),
     cst_wheat$0=caml_new_string("wheat"),
     cst_white$0=caml_new_string("white"),
     cst_whitesmoke$0=caml_new_string("whitesmoke"),
     cst_yellow$0=caml_new_string("yellow"),
     cst_yellowgreen$0=caml_new_string("yellowgreen"),
     cst_is_not_a_valid_color_name=
      caml_new_string(" is not a valid color name"),
     cst_aliceblue=caml_new_string("aliceblue"),
     cst_antiquewhite=caml_new_string("antiquewhite"),
     cst_aqua=caml_new_string("aqua"),
     cst_aquamarine=caml_new_string("aquamarine"),
     cst_azure=caml_new_string("azure"),
     cst_beige=caml_new_string("beige"),
     cst_bisque=caml_new_string("bisque"),
     cst_black=caml_new_string("black"),
     cst_blanchedalmond=caml_new_string("blanchedalmond"),
     cst_blue=caml_new_string("blue"),
     cst_blueviolet=caml_new_string("blueviolet"),
     cst_brown=caml_new_string("brown"),
     cst_burlywood=caml_new_string("burlywood"),
     cst_cadetblue=caml_new_string("cadetblue"),
     cst_chartreuse=caml_new_string("chartreuse"),
     cst_chocolate=caml_new_string("chocolate"),
     cst_coral=caml_new_string("coral"),
     cst_cornflowerblue=caml_new_string("cornflowerblue"),
     cst_cornsilk=caml_new_string("cornsilk"),
     cst_crimson=caml_new_string("crimson"),
     cst_cyan=caml_new_string("cyan"),
     cst_darkblue=caml_new_string("darkblue"),
     cst_darkcyan=caml_new_string("darkcyan"),
     cst_darkgoldenrod=caml_new_string("darkgoldenrod"),
     cst_darkgray=caml_new_string("darkgray"),
     cst_darkgreen=caml_new_string("darkgreen"),
     cst_darkgrey=caml_new_string("darkgrey"),
     cst_darkkhaki=caml_new_string("darkkhaki"),
     cst_darkmagenta=caml_new_string("darkmagenta"),
     cst_darkolivegreen=caml_new_string("darkolivegreen"),
     cst_darkorange=caml_new_string("darkorange"),
     cst_darkorchid=caml_new_string("darkorchid"),
     cst_darkred=caml_new_string("darkred"),
     cst_darksalmon=caml_new_string("darksalmon"),
     cst_darkseagreen=caml_new_string("darkseagreen"),
     cst_darkslateblue=caml_new_string("darkslateblue"),
     cst_darkslategray=caml_new_string("darkslategray"),
     cst_darkslategrey=caml_new_string("darkslategrey"),
     cst_darkturquoise=caml_new_string("darkturquoise"),
     cst_darkviolet=caml_new_string("darkviolet"),
     cst_deeppink=caml_new_string("deeppink"),
     cst_deepskyblue=caml_new_string("deepskyblue"),
     cst_dimgray=caml_new_string("dimgray"),
     cst_dimgrey=caml_new_string("dimgrey"),
     cst_dodgerblue=caml_new_string("dodgerblue"),
     cst_firebrick=caml_new_string("firebrick"),
     cst_floralwhite=caml_new_string("floralwhite"),
     cst_forestgreen=caml_new_string("forestgreen"),
     cst_fuchsia=caml_new_string("fuchsia"),
     cst_gainsboro=caml_new_string("gainsboro"),
     cst_ghostwhite=caml_new_string("ghostwhite"),
     cst_gold=caml_new_string("gold"),
     cst_goldenrod=caml_new_string("goldenrod"),
     cst_gray=caml_new_string("gray"),
     cst_grey=caml_new_string("grey"),
     cst_green=caml_new_string("green"),
     cst_greenyellow=caml_new_string("greenyellow"),
     cst_honeydew=caml_new_string("honeydew"),
     cst_hotpink=caml_new_string("hotpink"),
     cst_indianred=caml_new_string("indianred"),
     cst_indigo=caml_new_string("indigo"),
     cst_ivory=caml_new_string("ivory"),
     cst_khaki=caml_new_string("khaki"),
     cst_lavender=caml_new_string("lavender"),
     cst_lavenderblush=caml_new_string("lavenderblush"),
     cst_lawngreen=caml_new_string("lawngreen"),
     cst_lemonchiffon=caml_new_string("lemonchiffon"),
     cst_lightblue=caml_new_string("lightblue"),
     cst_lightcoral=caml_new_string("lightcoral"),
     cst_lightcyan=caml_new_string("lightcyan"),
     cst_lightgoldenrodyellow=caml_new_string("lightgoldenrodyellow"),
     cst_lightgray=caml_new_string("lightgray"),
     cst_lightgreen=caml_new_string("lightgreen"),
     cst_lightgrey=caml_new_string("lightgrey"),
     cst_lightpink=caml_new_string("lightpink"),
     cst_lightsalmon=caml_new_string("lightsalmon"),
     cst_lightseagreen=caml_new_string("lightseagreen"),
     cst_lightskyblue=caml_new_string("lightskyblue"),
     cst_lightslategray=caml_new_string("lightslategray"),
     cst_lightslategrey=caml_new_string("lightslategrey"),
     cst_lightsteelblue=caml_new_string("lightsteelblue"),
     cst_lightyellow=caml_new_string("lightyellow"),
     cst_lime=caml_new_string("lime"),
     cst_limegreen=caml_new_string("limegreen"),
     cst_linen=caml_new_string("linen"),
     cst_magenta=caml_new_string("magenta"),
     cst_maroon=caml_new_string("maroon"),
     cst_mediumaquamarine=caml_new_string("mediumaquamarine"),
     cst_mediumblue=caml_new_string("mediumblue"),
     cst_mediumorchid=caml_new_string("mediumorchid"),
     cst_mediumpurple=caml_new_string("mediumpurple"),
     cst_mediumseagreen=caml_new_string("mediumseagreen"),
     cst_mediumslateblue=caml_new_string("mediumslateblue"),
     cst_mediumspringgreen=caml_new_string("mediumspringgreen"),
     cst_mediumturquoise=caml_new_string("mediumturquoise"),
     cst_mediumvioletred=caml_new_string("mediumvioletred"),
     cst_midnightblue=caml_new_string("midnightblue"),
     cst_mintcream=caml_new_string("mintcream"),
     cst_mistyrose=caml_new_string("mistyrose"),
     cst_moccasin=caml_new_string("moccasin"),
     cst_navajowhite=caml_new_string("navajowhite"),
     cst_navy=caml_new_string("navy"),
     cst_oldlace=caml_new_string("oldlace"),
     cst_olive=caml_new_string("olive"),
     cst_olivedrab=caml_new_string("olivedrab"),
     cst_orange=caml_new_string("orange"),
     cst_orangered=caml_new_string("orangered"),
     cst_orchid=caml_new_string("orchid"),
     cst_palegoldenrod=caml_new_string("palegoldenrod"),
     cst_palegreen=caml_new_string("palegreen"),
     cst_paleturquoise=caml_new_string("paleturquoise"),
     cst_palevioletred=caml_new_string("palevioletred"),
     cst_papayawhip=caml_new_string("papayawhip"),
     cst_peachpuff=caml_new_string("peachpuff"),
     cst_peru=caml_new_string("peru"),
     cst_pink=caml_new_string("pink"),
     cst_plum=caml_new_string("plum"),
     cst_powderblue=caml_new_string("powderblue"),
     cst_purple=caml_new_string("purple"),
     cst_red=caml_new_string("red"),
     cst_rosybrown=caml_new_string("rosybrown"),
     cst_royalblue=caml_new_string("royalblue"),
     cst_saddlebrown=caml_new_string("saddlebrown"),
     cst_salmon=caml_new_string("salmon"),
     cst_sandybrown=caml_new_string("sandybrown"),
     cst_seagreen=caml_new_string("seagreen"),
     cst_seashell=caml_new_string("seashell"),
     cst_sienna=caml_new_string("sienna"),
     cst_silver=caml_new_string("silver"),
     cst_skyblue=caml_new_string("skyblue"),
     cst_slateblue=caml_new_string("slateblue"),
     cst_slategray=caml_new_string("slategray"),
     cst_slategrey=caml_new_string("slategrey"),
     cst_snow=caml_new_string("snow"),
     cst_springgreen=caml_new_string("springgreen"),
     cst_steelblue=caml_new_string("steelblue"),
     cst_tan=caml_new_string("tan"),
     cst_teal=caml_new_string("teal"),
     cst_thistle=caml_new_string("thistle"),
     cst_tomato=caml_new_string("tomato"),
     cst_turquoise=caml_new_string("turquoise"),
     cst_violet=caml_new_string("violet"),
     cst_wheat=caml_new_string("wheat"),
     cst_white=caml_new_string("white"),
     cst_whitesmoke=caml_new_string("whitesmoke"),
     cst_yellow=caml_new_string("yellow"),
     cst_yellowgreen=caml_new_string("yellowgreen"),
     cst_vkern$0=caml_new_string("vkern"),
     cst_view$0=caml_new_string("view"),
     cst_use$0=caml_new_string("use"),
     cst_tspan$0=caml_new_string("tspan"),
     cst_tref$0=caml_new_string("tref"),
     cst_title$3=caml_new_string("title"),
     cst_textpath$0=caml_new_string("textpath"),
     cst_text$1=caml_new_string("text"),
     cst_symbol$0=caml_new_string("symbol"),
     cst_switch$0=caml_new_string("switch"),
     cst_svg$0=caml_new_string("svg"),
     cst_style$3=caml_new_string("style"),
     cst_stop$0=caml_new_string("stop"),
     cst_set$0=caml_new_string("set"),
     cst_script$3=caml_new_string("script"),
     cst_rect$0=caml_new_string("rect"),
     cst_radialgradient$0=caml_new_string("radialgradient"),
     cst_polyline$0=caml_new_string("polyline"),
     cst_polygon$0=caml_new_string("polygon"),
     cst_pattern$0=caml_new_string("pattern"),
     cst_path$0=caml_new_string("path"),
     cst_mpath$0=caml_new_string("mpath"),
     cst_missing_glyph$0=caml_new_string("missing-glyph"),
     cst_metadata$0=caml_new_string("metadata"),
     cst_mask$0=caml_new_string("mask"),
     cst_lineargradient$0=caml_new_string("lineargradient"),
     cst_line$0=caml_new_string("line"),
     cst_image$0=caml_new_string("image"),
     cst_hkern$0=caml_new_string("hkern"),
     cst_glyphref$0=caml_new_string("glyphref"),
     cst_glyph$0=caml_new_string("glyph"),
     cst_g$1=caml_new_string("g"),
     cst_foreignobject=caml_new_string("foreignobject"),
     cst_font_face_uri$0=caml_new_string("font-face-uri"),
     cst_font_face_src$0=caml_new_string("font-face-src"),
     cst_font_face_name$0=caml_new_string("font-face-name"),
     cst_font_face_format$0=caml_new_string("font-face-format"),
     cst_font_face$0=caml_new_string("font-face"),
     cst_font$0=caml_new_string("font"),
     cst_filter$0=caml_new_string("filter"),
     cst_ellipse$0=caml_new_string("ellipse"),
     cst_desc$0=caml_new_string("desc"),
     cst_defs$0=caml_new_string("defs"),
     cst_cursor$0=caml_new_string("cursor"),
     cst_clippath$0=caml_new_string("clippath"),
     cst_circle$0=caml_new_string("circle"),
     cst_animatetransform$0=caml_new_string("animatetransform"),
     cst_animatemotion$0=caml_new_string("animatemotion"),
     cst_animatecolor$0=caml_new_string("animatecolor"),
     cst_animate$0=caml_new_string("animate"),
     cst_altglyphitem$0=caml_new_string("altglyphitem"),
     cst_altglyphdef$0=caml_new_string("altglyphdef"),
     cst_altglyph$0=caml_new_string("altglyph"),
     cst_a$3=caml_new_string("a"),
     cst_vkern=caml_new_string("vkern"),
     cst_view=caml_new_string("view"),
     cst_use=caml_new_string("use"),
     cst_tspan=caml_new_string("tspan"),
     cst_tref=caml_new_string("tref"),
     cst_title$2=caml_new_string("title"),
     cst_textpath=caml_new_string("textpath"),
     cst_text$0=caml_new_string("text"),
     cst_symbol=caml_new_string("symbol"),
     cst_switch=caml_new_string("switch"),
     cst_svg=caml_new_string("svg"),
     cst_style$2=caml_new_string("style"),
     cst_stop=caml_new_string("stop"),
     cst_set=caml_new_string("set"),
     cst_script$2=caml_new_string("script"),
     cst_rect=caml_new_string("rect"),
     cst_radialgradient=caml_new_string("radialgradient"),
     cst_polyline=caml_new_string("polyline"),
     cst_polygon=caml_new_string("polygon"),
     cst_pattern=caml_new_string("pattern"),
     cst_path=caml_new_string("path"),
     cst_mpath=caml_new_string("mpath"),
     cst_missing_glyph=caml_new_string("missing-glyph"),
     cst_metadata=caml_new_string("metadata"),
     cst_mask=caml_new_string("mask"),
     cst_lineargradient=caml_new_string("lineargradient"),
     cst_line=caml_new_string("line"),
     cst_image=caml_new_string("image"),
     cst_hkern=caml_new_string("hkern"),
     cst_glyphref=caml_new_string("glyphref"),
     cst_glyph=caml_new_string("glyph"),
     cst_g$0=caml_new_string("g"),
     cst_foreignObject=caml_new_string("foreignObject"),
     cst_font_face_uri=caml_new_string("font-face-uri"),
     cst_font_face_src=caml_new_string("font-face-src"),
     cst_font_face_name=caml_new_string("font-face-name"),
     cst_font_face_format=caml_new_string("font-face-format"),
     cst_font_face=caml_new_string("font-face"),
     cst_font=caml_new_string("font"),
     cst_filter=caml_new_string("filter"),
     cst_ellipse=caml_new_string("ellipse"),
     cst_desc=caml_new_string("desc"),
     cst_defs=caml_new_string("defs"),
     cst_cursor=caml_new_string("cursor"),
     cst_clippath=caml_new_string("clippath"),
     cst_circle=caml_new_string("circle"),
     cst_animatetransform=caml_new_string("animatetransform"),
     cst_animatemotion=caml_new_string("animatemotion"),
     cst_animatecolor=caml_new_string("animatecolor"),
     cst_animate=caml_new_string("animate"),
     cst_altglyphitem=caml_new_string("altglyphitem"),
     cst_altglyphdef=caml_new_string("altglyphdef"),
     cst_altglyph=caml_new_string("altglyph"),
     cst_a$2=caml_new_string("a"),
     cst_Js_of_ocaml_Dom_svg_SVGError=
      caml_new_string("Js_of_ocaml__Dom_svg.SVGError"),
     String=global_data.String,
     Char=global_data.Char,
     Pervasives=global_data.Pervasives,
     Callback=global_data.Callback,
     Printexc=global_data.Printexc,
     Assert_failure=global_data.Assert_failure,
     Not_found=global_data.Not_found,
     List=global_data.List,
     Array=global_data.Array,
     Uchar=global_data.Uchar,
     Printf=global_data.Printf,
     Failure=global_data.Failure,
     Invalid_argument=global_data.Invalid_argument,
     Js_of_ocaml=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
    caml_register_global(1627,Js_of_ocaml,"Js_of_ocaml__");
    var
     Poly=[0],
     _d_=[0,caml_new_string("lib/js_of_ocaml/dom.ml"),351,67],
     _e_=[0,caml_new_string("transparent")],
     _f_=[0,caml_new_string("native")],
     _j_=[0,caml_new_string("lib/js_of_ocaml/dom_html.ml"),2790,58],
     _i_=[0,caml_new_string("lib/js_of_ocaml/dom_html.ml"),2789,61],
     _h_=
      [0,
       [11,
        caml_new_string("getElementById_exn: "),
        [3,0,[11,caml_new_string(" not found"),0]]],
       caml_new_string("getElementById_exn: %S not found")],
     _l_=[0,caml_new_string("lib/js_of_ocaml/form.ml"),177,13],
     _k_=[0,1],
     _m_=[0,caml_new_string("lib/js_of_ocaml/xmlHttpRequest.ml"),129,75],
     _n_=[0,caml_new_string("lib/js_of_ocaml/regexp.ml"),34,64],
     _o_=[0,caml_new_string(""),0],
     _ci_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _cj_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _ck_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _cl_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _b6_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _b7_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _b8_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _b9_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _b__=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _b$_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _ca_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _cb_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _cc_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _cd_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _ce_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _cf_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _cg_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _ch_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _b5_=
      caml_list_of_js_array
       ([caml_new_string("aliceblue"),
         caml_new_string("antiquewhite"),
         caml_new_string("aqua"),
         caml_new_string("aquamarine"),
         caml_new_string("azure"),
         caml_new_string("beige"),
         caml_new_string("bisque"),
         caml_new_string("black"),
         caml_new_string("blanchedalmond"),
         caml_new_string("blue"),
         caml_new_string("blueviolet"),
         caml_new_string("brown"),
         caml_new_string("burlywood"),
         caml_new_string("cadetblue"),
         caml_new_string("chartreuse"),
         caml_new_string("chocolate"),
         caml_new_string("coral"),
         caml_new_string("cornflowerblue"),
         caml_new_string("cornsilk"),
         caml_new_string("crimson"),
         caml_new_string("cyan"),
         caml_new_string("darkblue"),
         caml_new_string("darkcyan"),
         caml_new_string("darkgoldenrod"),
         caml_new_string("darkgray"),
         caml_new_string("darkgreen"),
         caml_new_string("darkgrey"),
         caml_new_string("darkkhaki"),
         caml_new_string("darkmagenta"),
         caml_new_string("darkolivegreen"),
         caml_new_string("darkorange"),
         caml_new_string("darkorchid"),
         caml_new_string("darkred"),
         caml_new_string("darksalmon"),
         caml_new_string("darkseagreen"),
         caml_new_string("darkslateblue"),
         caml_new_string("darkslategray"),
         caml_new_string("darkslategrey"),
         caml_new_string("darkturquoise"),
         caml_new_string("darkviolet"),
         caml_new_string("deeppink"),
         caml_new_string("deepskyblue"),
         caml_new_string("dimgray"),
         caml_new_string("dimgrey"),
         caml_new_string("dodgerblue"),
         caml_new_string("firebrick"),
         caml_new_string("floralwhite"),
         caml_new_string("forestgreen"),
         caml_new_string("fuchsia"),
         caml_new_string("gainsboro"),
         caml_new_string("ghostwhite"),
         caml_new_string("gold"),
         caml_new_string("goldenrod"),
         caml_new_string("gray"),
         caml_new_string("green"),
         caml_new_string("greenyellow"),
         caml_new_string("grey"),
         caml_new_string("honeydew"),
         caml_new_string("hotpink"),
         caml_new_string("indianred"),
         caml_new_string("indigo"),
         caml_new_string("ivory"),
         caml_new_string("khaki"),
         caml_new_string("lavender"),
         caml_new_string("lavenderblush"),
         caml_new_string("lawngreen"),
         caml_new_string("lemonchiffon"),
         caml_new_string("lightblue"),
         caml_new_string("lightcoral"),
         caml_new_string("lightcyan"),
         caml_new_string("lightgoldenrodyellow"),
         caml_new_string("lightgray"),
         caml_new_string("lightgreen"),
         caml_new_string("lightgrey"),
         caml_new_string("lightpink"),
         caml_new_string("lightsalmon"),
         caml_new_string("lightseagreen"),
         caml_new_string("lightskyblue"),
         caml_new_string("lightslategray"),
         caml_new_string("lightslategrey"),
         caml_new_string("lightsteelblue"),
         caml_new_string("lightyellow"),
         caml_new_string("lime"),
         caml_new_string("limegreen"),
         caml_new_string("linen"),
         caml_new_string("magenta"),
         caml_new_string("maroon"),
         caml_new_string("mediumaquamarine"),
         caml_new_string("mediumblue"),
         caml_new_string("mediumorchid"),
         caml_new_string("mediumpurple"),
         caml_new_string("mediumseagreen"),
         caml_new_string("mediumslateblue"),
         caml_new_string("mediumspringgreen"),
         caml_new_string("mediumturquoise"),
         caml_new_string("mediumvioletred"),
         caml_new_string("midnightblue"),
         caml_new_string("mintcream"),
         caml_new_string("mistyrose"),
         caml_new_string("moccasin"),
         caml_new_string("navajowhite"),
         caml_new_string("navy"),
         caml_new_string("oldlace"),
         caml_new_string("olive"),
         caml_new_string("olivedrab"),
         caml_new_string("orange"),
         caml_new_string("orangered"),
         caml_new_string("orchid"),
         caml_new_string("palegoldenrod"),
         caml_new_string("palegreen"),
         caml_new_string("paleturquoise"),
         caml_new_string("palevioletred"),
         caml_new_string("papayawhip"),
         caml_new_string("peachpuff"),
         caml_new_string("peru"),
         caml_new_string("pink"),
         caml_new_string("plum"),
         caml_new_string("powderblue"),
         caml_new_string("purple"),
         caml_new_string("red"),
         caml_new_string("rosybrown"),
         caml_new_string("royalblue"),
         caml_new_string("saddlebrown"),
         caml_new_string("salmon"),
         caml_new_string("sandybrown"),
         caml_new_string("seagreen"),
         caml_new_string("seashell"),
         caml_new_string("sienna"),
         caml_new_string("silver"),
         caml_new_string("skyblue"),
         caml_new_string("slateblue"),
         caml_new_string("slategray"),
         caml_new_string("slategrey"),
         caml_new_string("snow"),
         caml_new_string("springgreen"),
         caml_new_string("steelblue"),
         caml_new_string("tan"),
         caml_new_string("teal"),
         caml_new_string("thistle"),
         caml_new_string("tomato"),
         caml_new_string("turquoise"),
         caml_new_string("violet"),
         caml_new_string("wheat"),
         caml_new_string("white"),
         caml_new_string("whitesmoke"),
         caml_new_string("yellow"),
         caml_new_string("yellowgreen")]),
     _b4_=
      [0,
       [12,35,[4,8,[0,2,2],0,[4,8,[0,2,2],0,[4,8,[0,2,2],0,0]]]],
       caml_new_string("#%02X%02X%02X")],
     _bY_=
      [0,
       [11,
        caml_new_string("rgb("),
        [4,0,0,0,[12,44,[4,0,0,0,[12,44,[4,0,0,0,[12,41,0]]]]]]],
       caml_new_string("rgb(%d,%d,%d)")],
     _bZ_=
      [0,
       [11,
        caml_new_string("rgb("),
        [4,
         0,
         0,
         0,
         [12,37,[12,44,[4,0,0,0,[12,37,[12,44,[4,0,0,0,[12,37,[12,41,0]]]]]]]]]],
       caml_new_string("rgb(%d%%,%d%%,%d%%)")],
     _b0_=
      [0,
       [11,
        caml_new_string("rgba("),
        [4,
         0,
         0,
         0,
         [12,44,[4,0,0,0,[12,44,[4,0,0,0,[12,44,[8,0,0,0,[12,41,0]]]]]]]]],
       caml_new_string("rgba(%d,%d,%d,%f)")],
     _b1_=
      [0,
       [11,
        caml_new_string("rgba("),
        [4,
         0,
         0,
         0,
         [12,
          37,
          [12,44,[4,0,0,0,[12,37,[12,44,[4,0,0,0,[12,37,[12,44,partial]]]]]]]]]],
       caml_new_string("rgba(%d%%,%d%%,%d%%,%f)")],
     _b2_=
      [0,
       [11,
        caml_new_string("hsl("),
        [4,
         0,
         0,
         0,
         [12,44,[4,0,0,0,[12,37,[12,44,[4,0,0,0,[12,37,[12,41,0]]]]]]]]],
       caml_new_string("hsl(%d,%d%%,%d%%)")],
     _b3_=
      [0,
       [11,
        caml_new_string("hsla("),
        [4,
         0,
         0,
         0,
         [12,
          44,
          [4,
           0,
           0,
           0,
           [12,37,[12,44,[4,0,0,0,[12,37,[12,44,[8,0,0,0,partial$0]]]]]]]]]],
       caml_new_string("hsla(%d,%d%%,%d%%,%f)")],
     _v_=[0,240,248,255],
     _w_=[0,250,235,215],
     _x_=[0,0,255,255],
     _y_=[0,127,255,212],
     _z_=[0,240,255,255],
     _A_=[0,245,245,220],
     _B_=[0,255,228,196],
     _C_=[0,0,0,0],
     _D_=[0,255,235,205],
     _E_=[0,0,0,255],
     _F_=[0,138,43,226],
     _G_=[0,165,42,42],
     _H_=[0,222,184,135],
     _I_=[0,95,158,160],
     _J_=[0,127,255,0],
     _K_=[0,210,105,30],
     _L_=[0,255,127,80],
     _M_=[0,100,149,237],
     _N_=[0,255,248,220],
     _O_=[0,220,20,60],
     _P_=[0,0,255,255],
     _Q_=[0,0,0,139],
     _R_=[0,0,139,139],
     _S_=[0,184,134,11],
     _T_=[0,169,169,169],
     _U_=[0,0,100,0],
     _V_=[0,169,169,169],
     _W_=[0,189,183,107],
     _X_=[0,139,0,139],
     _Y_=[0,85,107,47],
     _Z_=[0,255,140,0],
     ___=[0,153,50,204],
     _$_=[0,139,0,0],
     _aa_=[0,233,150,122],
     _ab_=[0,143,188,143],
     _ac_=[0,72,61,139],
     _ad_=[0,47,79,79],
     _ae_=[0,47,79,79],
     _af_=[0,0,206,209],
     _ag_=[0,148,0,211],
     _ah_=[0,255,20,147],
     _ai_=[0,0,191,255],
     _aj_=[0,105,105,105],
     _ak_=[0,105,105,105],
     _al_=[0,30,144,255],
     _am_=[0,178,34,34],
     _an_=[0,255,250,240],
     _ao_=[0,34,139,34],
     _ap_=[0,255,0,255],
     _aq_=[0,220,220,220],
     _ar_=[0,248,248,255],
     _as_=[0,255,215,0],
     _at_=[0,218,165,32],
     _au_=[0,128,128,128],
     _av_=[0,128,128,128],
     _aw_=[0,0,128,0],
     _ax_=[0,173,255,47],
     _ay_=[0,240,255,240],
     _az_=[0,255,105,180],
     _aA_=[0,205,92,92],
     _aB_=[0,75,0,130],
     _aC_=[0,255,255,240],
     _aD_=[0,240,230,140],
     _aE_=[0,230,230,250],
     _aF_=[0,255,240,245],
     _aG_=[0,124,252,0],
     _aH_=[0,255,250,205],
     _aI_=[0,173,216,230],
     _aJ_=[0,240,128,128],
     _aK_=[0,224,255,255],
     _aL_=[0,250,250,210],
     _aM_=[0,211,211,211],
     _aN_=[0,144,238,144],
     _aO_=[0,211,211,211],
     _aP_=[0,255,182,193],
     _aQ_=[0,255,160,122],
     _aR_=[0,32,178,170],
     _aS_=[0,135,206,250],
     _aT_=[0,119,136,153],
     _aU_=[0,119,136,153],
     _aV_=[0,176,196,222],
     _aW_=[0,255,255,224],
     _aX_=[0,0,255,0],
     _aY_=[0,50,205,50],
     _aZ_=[0,250,240,230],
     _a0_=[0,255,0,255],
     _a1_=[0,128,0,0],
     _a2_=[0,102,205,170],
     _a3_=[0,0,0,205],
     _a4_=[0,186,85,211],
     _a5_=[0,147,112,219],
     _a6_=[0,60,179,113],
     _a7_=[0,123,104,238],
     _a8_=[0,0,250,154],
     _a9_=[0,72,209,204],
     _a__=[0,199,21,133],
     _a$_=[0,25,25,112],
     _ba_=[0,245,255,250],
     _bb_=[0,255,228,225],
     _bc_=[0,255,228,181],
     _bd_=[0,255,222,173],
     _be_=[0,0,0,128],
     _bf_=[0,253,245,230],
     _bg_=[0,128,128,0],
     _bh_=[0,107,142,35],
     _bi_=[0,255,165,0],
     _bj_=[0,255,69,0],
     _bk_=[0,218,112,214],
     _bl_=[0,238,232,170],
     _bm_=[0,152,251,152],
     _bn_=[0,175,238,238],
     _bo_=[0,219,112,147],
     _bp_=[0,255,239,213],
     _bq_=[0,255,218,185],
     _br_=[0,205,133,63],
     _bs_=[0,255,192,203],
     _bt_=[0,221,160,221],
     _bu_=[0,176,224,230],
     _bv_=[0,128,0,128],
     _bw_=[0,255,0,0],
     _bx_=[0,188,143,143],
     _by_=[0,65,105,225],
     _bz_=[0,139,69,19],
     _bA_=[0,250,128,114],
     _bB_=[0,244,164,96],
     _bC_=[0,46,139,87],
     _bD_=[0,255,245,238],
     _bE_=[0,160,82,45],
     _bF_=[0,192,192,192],
     _bG_=[0,135,206,235],
     _bH_=[0,106,90,205],
     _bI_=[0,112,128,144],
     _bJ_=[0,112,128,144],
     _bK_=[0,255,250,250],
     _bL_=[0,0,255,127],
     _bM_=[0,70,130,180],
     _bN_=[0,210,180,140],
     _bO_=[0,0,128,128],
     _bP_=[0,216,191,216],
     _bQ_=[0,255,99,71],
     _bR_=[0,64,224,208],
     _bS_=[0,238,130,238],
     _bT_=[0,245,222,179],
     _bU_=[0,255,255,255],
     _bV_=[0,245,245,245],
     _bW_=[0,255,255,0],
     _bX_=[0,154,205,50];
    function symbol(x,y){return x < y?1:0}
    function symbol$0(x,y){return x <= y?1:0}
    function symbol$1(x,y){return x !== y?1:0}
    function symbol$2(x,y){return x === y?1:0}
    function symbol$3(x,y){return y < x?1:0}
    function symbol$4(x,y){return y <= x?1:0}
    var compare=runtime.caml_int_compare;
    function equal(x,y){return x === y?1:0}
    function max(x,y){return y <= x?x:y}
    function min(x,y){return x <= y?x:y}
    var
     Int_replace_polymorphic_compare=
      [0,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       compare,
       equal,
       max,
       min],
     make=String[1],
     init=String[2],
     copy=String[3],
     sub=String[4],
     fill=String[5],
     blit=String[6],
     concat=String[7],
     iter=String[8],
     iteri=String[9],
     map=String[10],
     mapi=String[11],
     trim=String[12],
     escaped=String[13],
     index=String[14],
     index_opt=String[15],
     rindex=String[16],
     rindex_opt=String[17],
     index_from=String[18],
     index_from_opt=String[19],
     rindex_from=String[20],
     rindex_from_opt=String[21],
     contains=String[22],
     contains_from=String[23],
     rcontains_from=String[24],
     uppercase=String[25],
     lowercase=String[26],
     capitalize=String[27],
     uncapitalize=String[28],
     uppercase_ascii=String[29],
     lowercase_ascii=String[30],
     capitalize_ascii=String[31],
     uncapitalize_ascii=String[32],
     compare$0=String[33],
     split_on_char=String[35],
     equal$0=runtime.caml_string_equal,
     String$0=
      [0,
       make,
       init,
       copy,
       sub,
       fill,
       blit,
       concat,
       iter,
       iteri,
       map,
       mapi,
       trim,
       escaped,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase,
       lowercase,
       capitalize,
       uncapitalize,
       uppercase_ascii,
       lowercase_ascii,
       capitalize_ascii,
       uncapitalize_ascii,
       compare$0,
       split_on_char,
       equal$0],
     chr=Char[1],
     escaped$0=Char[2],
     lowercase$0=Char[3],
     uppercase$0=Char[4],
     lowercase_ascii$0=Char[5],
     uppercase_ascii$0=Char[6],
     compare$1=Char[7];
    function equal$1(x,y){return x === y?1:0}
    var
     Char$0=
      [0,
       chr,
       escaped$0,
       lowercase$0,
       uppercase$0,
       lowercase_ascii$0,
       uppercase_ascii$0,
       compare$1,
       equal$1],
     symbol$5=Int_replace_polymorphic_compare[1],
     symbol$6=Int_replace_polymorphic_compare[2],
     symbol$7=Int_replace_polymorphic_compare[3],
     symbol$8=Int_replace_polymorphic_compare[4],
     symbol$9=Int_replace_polymorphic_compare[5],
     symbol$10=Int_replace_polymorphic_compare[6],
     compare$2=Int_replace_polymorphic_compare[7],
     equal$2=Int_replace_polymorphic_compare[8],
     max$0=Int_replace_polymorphic_compare[9],
     min$0=Int_replace_polymorphic_compare[10],
     Js_of_ocaml_Import=
      [0,
       Poly,
       Int_replace_polymorphic_compare,
       String$0,
       Char$0,
       symbol$5,
       symbol$6,
       symbol$7,
       symbol$8,
       symbol$9,
       symbol$10,
       compare$2,
       equal$2,
       max$0,
       min$0];
    caml_register_global(1630,Js_of_ocaml_Import,"Js_of_ocaml__Import");
    var
     global=joo_global_object,
     Unsafe=[0,global],
     no_handler=null,
     t37=undefined;
    function return$0(_gG_){return _gG_}
    function map$0(x,f){return x == no_handler?no_handler:caml_call1(f,x)}
    function bind(x,f){return x == no_handler?no_handler:caml_call1(f,x)}
    function test(x){return 1 - (x == no_handler?1:0)}
    function iter$0(x,f)
     {var _gF_=1 - (x == no_handler?1:0);return _gF_?caml_call1(f,x):_gF_}
    function case$0(x,f,g)
     {return x == no_handler?caml_call1(f,0):caml_call1(g,x)}
    function get(x,f){return x == no_handler?caml_call1(f,0):x}
    function option(x){if(x){var x$0=x[1];return x$0}return no_handler}
    function to_option(x)
     {function _gE_(x){return [0,x]}
      return case$0(x,function(param){return 0},_gE_)}
    var
     Opt=
      [0,
       no_handler,
       return$0,
       map$0,
       bind,
       test,
       iter$0,
       case$0,
       get,
       option,
       to_option];
    function return$1(_gD_){return _gD_}
    function map$1(x,f){return x === t37?t37:caml_call1(f,x)}
    function bind$0(x,f){return x === t37?t37:caml_call1(f,x)}
    function test$0(x){return x !== t37?1:0}
    function iter$1(x,f)
     {var _gC_=x !== t37?1:0;return _gC_?caml_call1(f,x):_gC_}
    function case$1(x,f,g){return x === t37?caml_call1(f,0):caml_call1(g,x)}
    function get$0(x,f){return x === t37?caml_call1(f,0):x}
    function option$0(x){if(x){var x$0=x[1];return x$0}return t37}
    function to_option$0(x)
     {function _gB_(x){return [0,x]}
      return case$1(x,function(param){return 0},_gB_)}
    var
     Optdef=
      [0,
       t37,
       return$1,
       map$1,
       bind$0,
       test$0,
       iter$1,
       case$1,
       get$0,
       option$0,
       to_option$0];
    function coerce(x,f,g)
     {function _gz_(param){return caml_call1(g,x)}
      var _gA_=caml_call1(f,x);
      return caml_call2(Opt[8],_gA_,_gz_)}
    function coerce_opt(x,f,g)
     {function _gx_(param){return caml_call1(g,x)}
      var _gy_=caml_call2(Opt[4],x,f);
      return caml_call2(Opt[8],_gy_,_gx_)}
    var
     true$0=true,
     false$0=false,
     string_constr=Unsafe[1].String,
     regExp_withFlags=Unsafe[1].RegExp,
     object_constructor=Unsafe[1].Object;
    function object_keys(o){return object_constructor.keys(o)}
    var
     array_length=Unsafe[1].Array,
     array_get=caml_js_get,
     array_set=caml_js_set;
    function array_map(f,a)
     {return a.map
              (caml_js_wrap_callback
                (function(x,idx,param){return caml_call1(f,x)}))}
    function array_mapi(f,a)
     {return a.map
              (caml_js_wrap_callback
                (function(x,idx,param){return caml_call2(f,idx,x)}))}
    function str_array(_gw_){return _gw_}
    function match_result(_gv_){return _gv_}
    var
     date_ms=Unsafe[1].Date,
     math=Unsafe[1].Math,
     Error=[248,cst_Js_of_ocaml_Js_Error,caml_fresh_oo_id(0)],
     error_constr=Unsafe[1].Error;
    caml_call2(Callback[2],cst_jsError,[0,Error,{}]);
    function raise_js_error(exn){throw exn}
    var JSON=Unsafe[1].JSON;
    function decodeURI(s){return Unsafe[1].decodeURI(s)}
    function decodeURIComponent(s){return Unsafe[1].decodeURIComponent(s)}
    function encodeURI(s){return Unsafe[1].encodeURI(s)}
    function encodeURIComponent(s){return Unsafe[1].encodeURIComponent(s)}
    function escape(s){return Unsafe[1].escape(s)}
    function unescape(s){return Unsafe[1].unescape(s)}
    function isNaN(i){return Unsafe[1].isNaN(i) | 0}
    function parseInt(s)
     {var s$0=Unsafe[1].parseInt(s);
      return isNaN(s$0)?caml_call1(Pervasives[2],cst_parseInt):s$0}
    function parseFloat(s)
     {var s$0=Unsafe[1].parseFloat(s);
      return isNaN(s$0)?caml_call1(Pervasives[2],cst_parseFloat):s$0}
    function _a_(param)
     {if(param[1] === Error)
       {var e=param[2];return [0,caml_js_to_string(e.toString())]}
      return 0}
    caml_call1(Printexc[8],_a_);
    function _b_(e)
     {return e instanceof array_length?0:[0,caml_js_to_string(e.toString())]}
    caml_call1(Printexc[8],_b_);
    function string_of_error(e){return caml_js_to_string(e.toString())}
    function export_js(field,x)
     {return runtime.caml_js_export_var(0)[field] = x}
    function export$0(field,x){return export_js(field.toString(),x)}
    function export_all(obj)
     {var keys=object_keys(obj);
      return keys.forEach
              (caml_js_wrap_callback
                (function(key,param,_gu_){return export_js(key,obj[key])}))}
    function _c_(_gt_){return _gt_}
    var
     Js_of_ocaml_Js=
      [0,
       no_handler,
       function(_gs_){return _gs_},
       t37,
       _c_,
       Opt,
       Optdef,
       true$0,
       false$0,
       string_constr,
       regExp_withFlags,
       regExp_withFlags,
       regExp_withFlags,
       object_keys,
       array_length,
       array_length,
       array_get,
       array_set,
       array_map,
       array_mapi,
       str_array,
       match_result,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       math,
       error_constr,
       string_of_error,
       raise_js_error,
       Error,
       JSON,
       decodeURI,
       decodeURIComponent,
       encodeURI,
       encodeURIComponent,
       escape,
       unescape,
       isNaN,
       parseInt,
       parseFloat,
       coerce,
       coerce_opt,
       export$0,
       export_all,
       Unsafe];
    caml_register_global(1634,Js_of_ocaml_Js,"Js_of_ocaml__Js");
    function list_of_nodeList(nodeList)
     {var length=nodeList.length,acc=0,i=0;
      for(;;)
       {if(caml_call2(symbol$5,i,length))
         {var _gr_=nodeList.item(i),match=caml_call1(Opt[10],_gr_);
          if(match)
           {var e=match[1],i$0=i + 1 | 0,acc$0=[0,e,acc],acc=acc$0,i=i$0;
            continue}
          var i$1=i + 1 | 0,i=i$1;
          continue}
        return caml_call1(List[9],acc)}}
    var
     disconnected=1,
     preceding=2,
     following=4,
     contains$0=8,
     contained_by=16,
     implementation_specific=32;
    function has(t,mask){return caml_call2(symbol$8,t & mask,mask)}
    function add(x,y){return x | y}
    var
     DocumentPosition=
      [0,
       disconnected,
       preceding,
       following,
       contains$0,
       contained_by,
       implementation_specific,
       has,
       add,
       add];
    function appendChild(p,n){p.appendChild(n);return 0}
    function removeChild(p,n){p.removeChild(n);return 0}
    function replaceChild(p,n,o){p.replaceChild(n,o);return 0}
    function insertBefore(p,n,o){p.insertBefore(n,o);return 0}
    function nodeType(e)
     {var match=e.nodeType;
      if(0 !== match)
       {var switcher=match - 1 | 0;
        switch(switcher)
         {case 0:return [0,e];case 1:return [1,e];case 2:case 3:return [2,e]}}
      return [3,e]}
    function cast(e,t){return e.nodeType === t?e:no_handler}
    function element(e){return cast(e,1)}
    function text(e)
     {if(3 !== e.nodeType)if(4 !== e.nodeType)return no_handler;return e}
    function attr(e){return cast(e,2)}
    function handler(f)
     {return function(e)
       {if(caml_call1(Opt[5],e))
         {var res=caml_call1(f,e);
          if(1 - (res | 0))e.preventDefault();
          return res}
        var e$0=event,res$0=caml_call1(f,e$0);
        if(1 - (res$0 | 0))e$0.returnValue = res$0;
        return res$0}}
    function full_handler(f)
     {return runtime.caml_js_wrap_meth_callback_unsafe
              (function(this$0,e)
                {if(caml_call1(Opt[5],e))
                  {var res=caml_call2(f,this$0,e);
                   if(1 - (res | 0))e.preventDefault();
                   return res}
                 var e$0=event,res$0=caml_call2(f,this$0,e$0);
                 if(1 - (res$0 | 0))e$0.returnValue = res$0;
                 return res$0})}
    function invoke_handler(f,this$0,event){return f.call(this$0,event)}
    function eventTarget(e)
     {function _go_(param)
       {function _gq_(param){throw Not_found}
        return caml_call2(Opt[8],e.srcElement,_gq_)}
      var target=caml_call2(Opt[8],e.target,_go_);
      if(target instanceof Unsafe[1].Node)
       {if(3 === target.nodeType)
         {var _gp_=function(param){throw [0,Assert_failure,_d_]};
          return caml_call2(Opt[8],target.parentNode,_gp_)}
        return target}
      return target}
    var make$0=caml_js_from_string,Event=[0,make$0];
    function addEventListenerWithOptions(e,typ,capture,once,passive,h)
     {if(e.addEventListener === t37)
       {var
         ev="on".concat(typ),
         callback=
          function(e)
           {var _gl_=[0,h,e,[0]];
            return function(_gm_,_gn_)
             {return runtime.caml_js_call(_gl_,_gm_,_gn_)}};
        e.attachEvent(ev,callback);
        return function(param){return e.detachEvent(ev,callback)}}
      var opts={};
      function iter(t,f){if(t){var b=t[1];return caml_call1(f,b)}return 0}
      iter(capture,function(b){return opts.capture = b});
      iter(once,function(b){return opts.once = b});
      iter(passive,function(b){return opts.passive = b});
      e.addEventListener(typ,h,opts);
      return function(param){return e.removeEventListener(typ,h,opts)}}
    function addEventListener(e,typ,h,capt)
     {return addEventListenerWithOptions(e,typ,[0,capt],0,0,h)}
    function removeEventListener(id){return caml_call1(id,0)}
    function preventDefault(ev)
     {return caml_call1(Optdef[5],ev.preventDefault)
              ?ev.preventDefault()
              :ev.returnValue = ! ! 0}
    function createCustomEvent(bubbles,cancelable,detail,typ)
     {function opt_iter(f,param)
       {if(param){var x=param[1];return caml_call1(f,x)}return 0}
      var opts={};
      opt_iter(function(x){return opts.bubbles = ! ! x},bubbles);
      opt_iter(function(x){return opts.cancelable = ! ! x},cancelable);
      opt_iter(function(x){return opts.detail = x},detail);
      var constr=Unsafe[1].CustomEvent;
      return new constr(typ,opts)}
    var
     Js_of_ocaml_Dom=
      [0,
       DocumentPosition,
       insertBefore,
       replaceChild,
       removeChild,
       appendChild,
       list_of_nodeList,
       nodeType,
       [0,element,text,attr],
       no_handler,
       handler,
       full_handler,
       invoke_handler,
       eventTarget,
       Event,
       addEventListenerWithOptions,
       addEventListener,
       removeEventListener,
       preventDefault,
       createCustomEvent];
    caml_register_global(1638,Js_of_ocaml_Dom,"Js_of_ocaml__Dom");
    var
     arrayBuffer=Unsafe[1].ArrayBuffer,
     int8Array_inBuffer=Unsafe[1].Int8Array,
     uint8Array_fromBuffer=Unsafe[1].Uint8Array,
     int16Array_inBuffer=Unsafe[1].Int16Array,
     uint16Array_inBuffer=Unsafe[1].Uint16Array,
     int32Array_inBuffer=Unsafe[1].Int32Array,
     uint32Array_inBuffer=Unsafe[1].Uint32Array,
     float32Array_inBuffer=Unsafe[1].Float32Array,
     float64Array_inBuffer=Unsafe[1].Float64Array,
     set=caml_js_set,
     get$1=caml_js_get,
     unsafe_get=caml_js_get,
     dataView=Unsafe[1].DataView;
    function of_arrayBuffer(ab)
     {var uint8=new uint8Array_fromBuffer(ab);
      return caml_string_of_array(uint8)}
    var
     Js_of_ocaml_Typed_array=
      [0,
       arrayBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       uint8Array_fromBuffer,
       uint8Array_fromBuffer,
       uint8Array_fromBuffer,
       uint8Array_fromBuffer,
       uint8Array_fromBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       set,
       get$1,
       unsafe_get,
       dataView,
       dataView,
       [0,
        runtime.bigstring_to_array_buffer,
        runtime.bigstring_to_typed_array,
        runtime.bigstring_of_array_buffer,
        runtime.bigstring_of_typed_array],
       [0,of_arrayBuffer,caml_string_of_array]];
    caml_register_global
     (1639,Js_of_ocaml_Typed_array,"Js_of_ocaml__Typed_array");
    var blob_constr=Unsafe[1].Blob;
    function filter_map(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var q=param$0[2],v=param$0[1],match=caml_call1(f,v);
          if(match){var v$0=match[1];return [0,v$0,filter_map(f,q)]}
          var param$0=q;
          continue}
        return 0}}
    function blob_raw(contentType,endings,a)
     {var _gh_=0;
      if(endings)
       var _gi_=116179762 <= endings[1]?_e_:_f_,_gj_=_gi_;
      else
       var _gj_=0;
      var
       _gk_=[0,[0,cst_type,contentType],[0,[0,cst_endings,_gj_],_gh_]],
       options=
        filter_map
         (function(param)
           {var v=param[2],name=param[1];
            if(v){var v$0=v[1];return [0,[0,name,v$0.toString()]]}
            return 0},
          _gk_),
       options$0=
        options?runtime.caml_js_object(caml_call1(Array[12],options)):t37;
      return new blob_constr(caml_js_from_array(a),options$0)}
    function blob_from_string(contentType,endings,s)
     {return blob_raw(contentType,endings,[0,s.toString()])}
    function blob_from_any(contentType,endings,l)
     {function _gf_(param)
       {var _gg_=param[1];
        if(155580615 === _gg_){var s=param[2];return s}
        if(486041214 <= _gg_)
         {if(1037850489 <= _gg_){var a=param[2];return a}
          var a$0=param[2];
          return a$0}
        if(288368849 <= _gg_){var s$0=param[2];return s$0.toString()}
        var b=param[2];
        return b}
      var l$0=caml_call2(List[17],_gf_,l);
      return blob_raw(contentType,endings,caml_call1(Array[12],l$0))}
    function filename(file)
     {var match=caml_call1(Optdef[10],file.name);
      if(match){var name=match[1];return name}
      var match$0=caml_call1(Optdef[10],file.fileName);
      if(match$0){var name$0=match$0[1];return name$0}
      return caml_call1
              (Pervasives[2],cst_can_t_retrieve_file_name_not_implemented)}
    var doc_constr=Unsafe[1].Document;
    function document(e){return e instanceof doc_constr?e:no_handler}
    function blob(e){return e instanceof blob_constr?e:no_handler}
    function string(e){return typeof e === "string"?e:no_handler}
    function arrayBuffer$0(e){return e instanceof arrayBuffer?e:no_handler}
    var
     loadstart=caml_call1(Event[1],cst_loadstart),
     progress=caml_call1(Event[1],cst_progress),
     abort=caml_call1(Event[1],cst_abort),
     error=caml_call1(Event[1],cst_error),
     load=caml_call1(Event[1],cst_load),
     loadend=caml_call1(Event[1],cst_loadend),
     ReaderEvent=[0,loadstart,progress,abort,error,load,loadend],
     fileReader=Unsafe[1].FileReader,
     Js_of_ocaml_File=
      [0,
       blob_from_string,
       blob_from_any,
       [0,document,blob,function(_ge_){return _ge_},string,arrayBuffer$0],
       ReaderEvent,
       filename,
       fileReader,
       addEventListener];
    caml_register_global(1641,Js_of_ocaml_File,"Js_of_ocaml__File");
    var
     onIE=runtime.caml_js_on_ie(0) | 0,
     click=caml_call1(Event[1],cst_click),
     dblclick=caml_call1(Event[1],cst_dblclick),
     mousedown=caml_call1(Event[1],cst_mousedown),
     mouseup=caml_call1(Event[1],cst_mouseup),
     mouseover=caml_call1(Event[1],cst_mouseover),
     mousemove=caml_call1(Event[1],cst_mousemove),
     mouseout=caml_call1(Event[1],cst_mouseout),
     keypress=caml_call1(Event[1],cst_keypress),
     keydown=caml_call1(Event[1],cst_keydown),
     keyup=caml_call1(Event[1],cst_keyup),
     mousewheel=caml_call1(Event[1],cst_mousewheel),
     DOMMouseScroll=caml_call1(Event[1],cst_DOMMouseScroll),
     touchstart=caml_call1(Event[1],cst_touchstart),
     touchmove=caml_call1(Event[1],cst_touchmove),
     touchend=caml_call1(Event[1],cst_touchend),
     touchcancel=caml_call1(Event[1],cst_touchcancel),
     dragstart=caml_call1(Event[1],cst_dragstart),
     dragend=caml_call1(Event[1],cst_dragend),
     dragenter=caml_call1(Event[1],cst_dragenter),
     dragover=caml_call1(Event[1],cst_dragover),
     dragleave=caml_call1(Event[1],cst_dragleave),
     drag=caml_call1(Event[1],cst_drag),
     drop=caml_call1(Event[1],cst_drop),
     hashchange=caml_call1(Event[1],cst_hashchange),
     change=caml_call1(Event[1],cst_change),
     input=caml_call1(Event[1],cst_input),
     timeupdate=caml_call1(Event[1],cst_timeupdate),
     submit=caml_call1(Event[1],cst_submit),
     scroll=caml_call1(Event[1],cst_scroll),
     focus=caml_call1(Event[1],cst_focus),
     blur=caml_call1(Event[1],cst_blur),
     load$0=caml_call1(Event[1],cst_load$0),
     unload=caml_call1(Event[1],cst_unload),
     beforeunload=caml_call1(Event[1],cst_beforeunload),
     resize=caml_call1(Event[1],cst_resize),
     orientationchange=caml_call1(Event[1],cst_orientationchange),
     popstate=caml_call1(Event[1],cst_popstate),
     error$0=caml_call1(Event[1],cst_error$0),
     abort$0=caml_call1(Event[1],cst_abort$0),
     select=caml_call1(Event[1],cst_select),
     online=caml_call1(Event[1],cst_online),
     offline=caml_call1(Event[1],cst_offline),
     checking=caml_call1(Event[1],cst_checking),
     noupdate=caml_call1(Event[1],cst_noupdate),
     downloading=caml_call1(Event[1],cst_downloading),
     progress$0=caml_call1(Event[1],cst_progress$0),
     updateready=caml_call1(Event[1],cst_updateready),
     cached=caml_call1(Event[1],cst_cached),
     obsolete=caml_call1(Event[1],cst_obsolete),
     domContentLoaded=caml_call1(Event[1],cst_DOMContentLoaded),
     animationstart=caml_call1(Event[1],cst_animationstart),
     animationend=caml_call1(Event[1],cst_animationend),
     animationiteration=caml_call1(Event[1],cst_animationiteration),
     animationcancel=caml_call1(Event[1],cst_animationcancel),
     canplay=caml_call1(Event[1],cst_canplay),
     canplaythrough=caml_call1(Event[1],cst_canplaythrough),
     durationchange=caml_call1(Event[1],cst_durationchange),
     emptied=caml_call1(Event[1],cst_emptied),
     ended=caml_call1(Event[1],cst_ended),
     gotpointercapture=caml_call1(Event[1],cst_gotpointercapture),
     loadeddata=caml_call1(Event[1],cst_loadeddata),
     loadedmetadata=caml_call1(Event[1],cst_loadedmetadata),
     loadstart$0=caml_call1(Event[1],cst_loadstart$0),
     lostpointercapture=caml_call1(Event[1],cst_lostpointercapture),
     pause=caml_call1(Event[1],cst_pause),
     play=caml_call1(Event[1],cst_play),
     playing=caml_call1(Event[1],cst_playing),
     pointerenter=caml_call1(Event[1],cst_pointerenter),
     pointercancel=caml_call1(Event[1],cst_pointercancel),
     pointerdown=caml_call1(Event[1],cst_pointerdown),
     pointerleave=caml_call1(Event[1],cst_pointerleave),
     pointermove=caml_call1(Event[1],cst_pointermove),
     pointerout=caml_call1(Event[1],cst_pointerout),
     pointerover=caml_call1(Event[1],cst_pointerover),
     pointerup=caml_call1(Event[1],cst_pointerup),
     ratechange=caml_call1(Event[1],cst_ratechange),
     seeked=caml_call1(Event[1],cst_seeked),
     seeking=caml_call1(Event[1],cst_seeking),
     stalled=caml_call1(Event[1],cst_stalled),
     suspend=caml_call1(Event[1],cst_suspend),
     volumechange=caml_call1(Event[1],cst_volumechange),
     waiting=caml_call1(Event[1],cst_waiting),
     make$1=Event[1],
     Event$0=
      [0,
       click,
       dblclick,
       mousedown,
       mouseup,
       mouseover,
       mousemove,
       mouseout,
       keypress,
       keydown,
       keyup,
       mousewheel,
       DOMMouseScroll,
       touchstart,
       touchmove,
       touchend,
       touchcancel,
       dragstart,
       dragend,
       dragenter,
       dragover,
       dragleave,
       drag,
       drop,
       hashchange,
       change,
       input,
       timeupdate,
       submit,
       scroll,
       focus,
       blur,
       load$0,
       unload,
       beforeunload,
       resize,
       orientationchange,
       popstate,
       error$0,
       abort$0,
       select,
       online,
       offline,
       checking,
       noupdate,
       downloading,
       progress$0,
       updateready,
       cached,
       obsolete,
       domContentLoaded,
       animationstart,
       animationend,
       animationiteration,
       animationcancel,
       canplay,
       canplaythrough,
       durationchange,
       emptied,
       ended,
       gotpointercapture,
       loadeddata,
       loadedmetadata,
       loadstart$0,
       lostpointercapture,
       pause,
       play,
       playing,
       pointerenter,
       pointercancel,
       pointerdown,
       pointerleave,
       pointermove,
       pointerout,
       pointerover,
       pointerup,
       ratechange,
       seeked,
       seeking,
       stalled,
       suspend,
       volumechange,
       waiting,
       make$1],
     d="2d";
    function location_origin(loc)
     {function _gc_(o){return o}
      function _gd_(param)
       {var protocol=loc.protocol,hostname=loc.hostname,port=loc.port;
        if(caml_call2(symbol$8,protocol.length,0))
         if(caml_call2(symbol$8,hostname.length,0))return "";
        var origin=protocol.concat("//",hostname);
        return caml_call2(symbol$9,port.length,0)
                ?origin.concat(":",loc.port)
                :origin}
      return caml_call3(Optdef[7],loc.origin,_gd_,_gc_)}
    var _g_=Unsafe[1],document$0=_g_.document;
    function getElementById(id)
     {function _f$_(pnode){return pnode}
      function _ga_(param){throw Not_found}
      var _gb_=document$0.getElementById(id.toString());
      return caml_call3(Opt[7],_gb_,_ga_,_f$_)}
    function getElementById_exn(id)
     {function _f7_(pnode){return pnode}
      function _f8_(param)
       {var _f__=caml_call2(Printf[4],_h_,id);
        return caml_call1(Pervasives[2],_f__)}
      var _f9_=document$0.getElementById(id.toString());
      return caml_call3(Opt[7],_f9_,_f8_,_f7_)}
    function getElementById_opt(id)
     {var _f6_=document$0.getElementById(id.toString());
      return caml_call1(Opt[10],_f6_)}
    function getElementById_coerce(id,coerce)
     {function _f2_(e)
       {var _f5_=caml_call1(coerce,e);return caml_call1(Opt[10],_f5_)}
      function _f3_(param){return 0}
      var _f4_=document$0.getElementById(id.toString());
      return caml_call3(Opt[7],_f4_,_f3_,_f2_)}
    function opt_iter(x,f){if(x){var v=x[1];return caml_call1(f,v)}return 0}
    function createElement(doc,name)
     {return doc.createElement(name.toString())}
    function unsafeCreateElement(doc,name){return createElement(doc,name)}
    var createElementSyntax=[0,785140586];
    function unsafeCreateElementEx(type,name,doc,elt)
     {for(;;)
       {if(0 === type)if(0 === name)return createElement(doc,elt);
        var _fW_=createElementSyntax[1];
        if(785140586 === _fW_)
         {try
           {var
             el=document$0.createElement('<input name="x">'),
             _fZ_=el.tagName.toLowerCase() === "input"?1:0,
             _f0_=_fZ_?el.name === "x"?1:0:_fZ_,
             _fX_=_f0_}
          catch(_f1_){var _fX_=0}
          var _fY_=_fX_?982028505:-1003883683;
          createElementSyntax[1] = _fY_;
          continue}
        if(982028505 <= _fW_)
         {var a=new array_length();
          a.push("<",elt.toString());
          opt_iter
           (type,
            function(t){a.push(' type="',caml_js_html_escape(t),'"');return 0});
          opt_iter
           (name,
            function(n){a.push(' name="',caml_js_html_escape(n),'"');return 0});
          a.push(">");
          return doc.createElement(a.join(""))}
        var res=createElement(doc,elt);
        opt_iter(type,function(t){return res.type = t});
        opt_iter(name,function(n){return res.name = n});
        return res}}
    function createHtml(doc){return unsafeCreateElement(doc,cst_html)}
    function createHead(doc){return unsafeCreateElement(doc,cst_head)}
    function createLink(doc){return unsafeCreateElement(doc,cst_link)}
    function createTitle(doc){return unsafeCreateElement(doc,cst_title)}
    function createMeta(doc){return unsafeCreateElement(doc,cst_meta)}
    function createBase(doc){return unsafeCreateElement(doc,cst_base)}
    function createStyle(doc){return unsafeCreateElement(doc,cst_style)}
    function createBody(doc){return unsafeCreateElement(doc,cst_body)}
    function createForm(doc){return unsafeCreateElement(doc,cst_form)}
    function createOptgroup(doc){return unsafeCreateElement(doc,cst_optgroup)}
    function createOption(doc){return unsafeCreateElement(doc,cst_option)}
    function createSelect(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_select$0)}
    function createInput(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_input$0)}
    function createTextarea(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_textarea)}
    function createButton(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_button)}
    function createLabel(doc){return unsafeCreateElement(doc,cst_label)}
    function createFieldset(doc){return unsafeCreateElement(doc,cst_fieldset)}
    function createLegend(doc){return unsafeCreateElement(doc,cst_legend)}
    function createUl(doc){return unsafeCreateElement(doc,cst_ul)}
    function createOl(doc){return unsafeCreateElement(doc,cst_ol)}
    function createDl(doc){return unsafeCreateElement(doc,cst_dl)}
    function createLi(doc){return unsafeCreateElement(doc,cst_li)}
    function createDiv(doc){return unsafeCreateElement(doc,cst_div)}
    function createEmbed(doc){return unsafeCreateElement(doc,cst_embed)}
    function createP(doc){return unsafeCreateElement(doc,cst_p)}
    function createH1(doc){return unsafeCreateElement(doc,cst_h1)}
    function createH2(doc){return unsafeCreateElement(doc,cst_h2)}
    function createH3(doc){return unsafeCreateElement(doc,cst_h3)}
    function createH4(doc){return unsafeCreateElement(doc,cst_h4)}
    function createH5(doc){return unsafeCreateElement(doc,cst_h5)}
    function createH6(doc){return unsafeCreateElement(doc,cst_h6)}
    function createQ(doc){return unsafeCreateElement(doc,cst_q)}
    function createBlockquote(doc)
     {return unsafeCreateElement(doc,cst_blockquote)}
    function createPre(doc){return unsafeCreateElement(doc,cst_pre)}
    function createBr(doc){return unsafeCreateElement(doc,cst_br)}
    function createHr(doc){return unsafeCreateElement(doc,cst_hr)}
    function createIns(doc){return unsafeCreateElement(doc,cst_ins)}
    function createDel(doc){return unsafeCreateElement(doc,cst_del)}
    function createA(doc){return unsafeCreateElement(doc,cst_a)}
    function createImg(doc){return unsafeCreateElement(doc,cst_img)}
    function createObject(doc){return unsafeCreateElement(doc,cst_object)}
    function createParam(doc){return unsafeCreateElement(doc,cst_param)}
    function createMap(doc){return unsafeCreateElement(doc,cst_map)}
    function createArea(doc){return unsafeCreateElement(doc,cst_area)}
    function createScript(doc){return unsafeCreateElement(doc,cst_script)}
    function createTable(doc){return unsafeCreateElement(doc,cst_table)}
    function createCaption(doc){return unsafeCreateElement(doc,cst_caption)}
    function createCol(doc){return unsafeCreateElement(doc,cst_col)}
    function createColgroup(doc){return unsafeCreateElement(doc,cst_colgroup)}
    function createThead(doc){return unsafeCreateElement(doc,cst_thead)}
    function createTfoot(doc){return unsafeCreateElement(doc,cst_tfoot)}
    function createTbody(doc){return unsafeCreateElement(doc,cst_tbody)}
    function createTr(doc){return unsafeCreateElement(doc,cst_tr)}
    function createTh(doc){return unsafeCreateElement(doc,cst_th)}
    function createTd(doc){return unsafeCreateElement(doc,cst_td)}
    function createSub(doc){return createElement(doc,cst_sub)}
    function createSup(doc){return createElement(doc,cst_sup)}
    function createSpan(doc){return createElement(doc,cst_span)}
    function createTt(doc){return createElement(doc,cst_tt)}
    function createI(doc){return createElement(doc,cst_i)}
    function createB(doc){return createElement(doc,cst_b)}
    function createBig(doc){return createElement(doc,cst_big)}
    function createSmall(doc){return createElement(doc,cst_small)}
    function createEm(doc){return createElement(doc,cst_em)}
    function createStrong(doc){return createElement(doc,cst_strong)}
    function createCite(doc){return createElement(doc,cst_cite)}
    function createDfn(doc){return createElement(doc,cst_dfn)}
    function createCode(doc){return createElement(doc,cst_code)}
    function createSamp(doc){return createElement(doc,cst_samp)}
    function createKbd(doc){return createElement(doc,cst_kbd)}
    function createVar(doc){return createElement(doc,cst_var)}
    function createAbbr(doc){return createElement(doc,cst_abbr)}
    function createDd(doc){return createElement(doc,cst_dd)}
    function createDt(doc){return createElement(doc,cst_dt)}
    function createNoscript(doc){return createElement(doc,cst_noscript)}
    function createAddress(doc){return createElement(doc,cst_address)}
    function createFrameset(doc){return unsafeCreateElement(doc,cst_frameset)}
    function createFrame(doc){return unsafeCreateElement(doc,cst_frame)}
    function createIframe(doc){return unsafeCreateElement(doc,cst_iframe)}
    function createAudio(doc){return unsafeCreateElement(doc,cst_audio)}
    function createVideo(doc){return unsafeCreateElement(doc,cst_video)}
    var
     Canvas_not_available=
      [248,cst_Js_of_ocaml_Dom_html_Canvas_not_available,caml_fresh_oo_id(0)];
    function createCanvas(doc)
     {var c=unsafeCreateElement(doc,cst_canvas);
      if(1 - caml_call1(Opt[5],c.getContext))throw Canvas_not_available;
      return c}
    var
     html_element=Unsafe[1].HTMLElement,
     element$0=
      html_element === t37
       ?function(e){return e.innerHTML === t37?no_handler:e}
       :function(e){return e instanceof html_element?e:no_handler};
    function unsafeCoerce(tag,e)
     {var _fV_=tag.toString();
      return e.tagName.toLowerCase() === _fV_?e:no_handler}
    function a(e){return unsafeCoerce(cst_a$0,e)}
    function area(e){return unsafeCoerce(cst_area$0,e)}
    function base(e){return unsafeCoerce(cst_base$0,e)}
    function blockquote(e){return unsafeCoerce(cst_blockquote$0,e)}
    function body(e){return unsafeCoerce(cst_body$0,e)}
    function br(e){return unsafeCoerce(cst_br$0,e)}
    function button(e){return unsafeCoerce(cst_button$0,e)}
    function canvas(e){return unsafeCoerce(cst_canvas$0,e)}
    function caption(e){return unsafeCoerce(cst_caption$0,e)}
    function col(e){return unsafeCoerce(cst_col$0,e)}
    function colgroup(e){return unsafeCoerce(cst_colgroup$0,e)}
    function del(e){return unsafeCoerce(cst_del$0,e)}
    function div(e){return unsafeCoerce(cst_div$0,e)}
    function dl(e){return unsafeCoerce(cst_dl$0,e)}
    function fieldset(e){return unsafeCoerce(cst_fieldset$0,e)}
    function embed(e){return unsafeCoerce(cst_embed$0,e)}
    function form(e){return unsafeCoerce(cst_form$0,e)}
    function frameset(e){return unsafeCoerce(cst_frameset$0,e)}
    function frame(e){return unsafeCoerce(cst_frame$0,e)}
    function h1(e){return unsafeCoerce(cst_h1$0,e)}
    function h2(e){return unsafeCoerce(cst_h2$0,e)}
    function h3(e){return unsafeCoerce(cst_h3$0,e)}
    function h4(e){return unsafeCoerce(cst_h4$0,e)}
    function h5(e){return unsafeCoerce(cst_h5$0,e)}
    function h6(e){return unsafeCoerce(cst_h6$0,e)}
    function head(e){return unsafeCoerce(cst_head$0,e)}
    function hr(e){return unsafeCoerce(cst_hr$0,e)}
    function html(e){return unsafeCoerce(cst_html$0,e)}
    function iframe(e){return unsafeCoerce(cst_iframe$0,e)}
    function img(e){return unsafeCoerce(cst_img$0,e)}
    function input$0(e){return unsafeCoerce(cst_input$1,e)}
    function ins(e){return unsafeCoerce(cst_ins$0,e)}
    function label(e){return unsafeCoerce(cst_label$0,e)}
    function legend(e){return unsafeCoerce(cst_legend$0,e)}
    function li(e){return unsafeCoerce(cst_li$0,e)}
    function link(e){return unsafeCoerce(cst_link$0,e)}
    function map$2(e){return unsafeCoerce(cst_map$0,e)}
    function meta(e){return unsafeCoerce(cst_meta$0,e)}
    function object(e){return unsafeCoerce(cst_object$0,e)}
    function ol(e){return unsafeCoerce(cst_ol$0,e)}
    function optgroup(e){return unsafeCoerce(cst_optgroup$0,e)}
    function option$1(e){return unsafeCoerce(cst_option$0,e)}
    function p(e){return unsafeCoerce(cst_p$0,e)}
    function param(e){return unsafeCoerce(cst_param$0,e)}
    function pre(e){return unsafeCoerce(cst_pre$0,e)}
    function q(e){return unsafeCoerce(cst_q$0,e)}
    function script(e){return unsafeCoerce(cst_script$0,e)}
    function select$0(e){return unsafeCoerce(cst_select$1,e)}
    function style(e){return unsafeCoerce(cst_style$0,e)}
    function table(e){return unsafeCoerce(cst_table$0,e)}
    function tbody(e){return unsafeCoerce(cst_tbody$0,e)}
    function td(e){return unsafeCoerce(cst_td$0,e)}
    function textarea(e){return unsafeCoerce(cst_textarea$0,e)}
    function tfoot(e){return unsafeCoerce(cst_tfoot$0,e)}
    function th(e){return unsafeCoerce(cst_th$0,e)}
    function thead(e){return unsafeCoerce(cst_thead$0,e)}
    function title(e){return unsafeCoerce(cst_title$0,e)}
    function tr(e){return unsafeCoerce(cst_tr$0,e)}
    function ul(e){return unsafeCoerce(cst_ul$0,e)}
    function audio(e){return unsafeCoerce(cst_audio$0,e)}
    function video(e){return unsafeCoerce(cst_video$0,e)}
    function unsafeCoerceEvent(constr,ev)
     {if(constr !== t37)if(ev instanceof constr)return ev;return no_handler}
    function mouseEvent(ev){return unsafeCoerceEvent(Unsafe[1].MouseEvent,ev)}
    function keyboardEvent(ev)
     {return unsafeCoerceEvent(Unsafe[1].KeyboardEvent,ev)}
    function wheelEvent(ev){return unsafeCoerceEvent(Unsafe[1].WheelEvent,ev)}
    function mouseScrollEvent(ev)
     {return unsafeCoerceEvent(Unsafe[1].MouseScrollEvent,ev)}
    function popStateEvent(ev)
     {return unsafeCoerceEvent(Unsafe[1].PopStateEvent,ev)}
    function eventRelatedTarget(e)
     {function _fS_(param)
       {var match=caml_js_to_string(e.type);
        if(caml_string_notequal(match,cst_mouseout$0))
         {if(caml_string_notequal(match,cst_mouseover$0))return no_handler;
          var _fT_=function(param){throw [0,Assert_failure,_i_]};
          return caml_call2(Optdef[8],e.fromElement,_fT_)}
        function _fU_(param){throw [0,Assert_failure,_j_]}
        return caml_call2(Optdef[8],e.toElement,_fU_)}
      return caml_call2(Optdef[8],e.relatedTarget,_fS_)}
    function eventAbsolutePosition(e)
     {var body=document$0.body,html=document$0.documentElement;
      return [0,
              (e.clientX + body.scrollLeft | 0) + html.scrollLeft | 0,
              (e.clientY + body.scrollTop | 0) + html.scrollTop | 0]}
    function eventAbsolutePosition$0(e)
     {function _fO_(x)
       {function _fQ_(y){return [0,x,y]}
        function _fR_(param){return eventAbsolutePosition(e)}
        return caml_call3(Optdef[7],e.pageY,_fR_,_fQ_)}
      function _fP_(param){return eventAbsolutePosition(e)}
      return caml_call3(Optdef[7],e.pageX,_fP_,_fO_)}
    function elementClientPosition(e)
     {var
       r=e.getBoundingClientRect(),
       body=document$0.body,
       html=document$0.documentElement;
      return [0,
              ((r.left | 0) - body.clientLeft | 0) - html.clientLeft | 0,
              ((r.top | 0) - body.clientTop | 0) - html.clientTop | 0]}
    function getDocumentScroll(param)
     {var body=document$0.body,html=document$0.documentElement;
      return [0,
              body.scrollLeft + html.scrollLeft | 0,
              body.scrollTop + html.scrollTop | 0]}
    function buttonPressed(ev)
     {function _fM_(x){return x}
      function _fN_(param)
       {var match=ev.button,switcher=match - 1 | 0;
        if(! (3 < switcher >>> 0))
         switch(switcher)
          {case 0:return 1;case 1:return 3;case 2:break;default:return 2}
        return 0}
      return caml_call3(Optdef[7],ev.which,_fN_,_fM_)}
    function addMousewheelEventListenerWithOptions(e,capture,once,passive,h)
     {var d=createDiv(document$0);
      d.setAttribute("onmousewheel","return;");
      if(typeof d.onmousewheel === "function")
       {var
         _fI_=
          handler
           (function(e)
             {function _fK_(param){return 0}
              var
               dx=
                (- caml_call2(Optdef[8],e.wheelDeltaX,_fK_) | 0) / 40 | 0;
              function _fL_(param){return e.wheelDelta}
              var
               dy=
                (- caml_call2(Optdef[8],e.wheelDeltaY,_fL_) | 0) / 40 | 0;
              return caml_call3(h,e,dx,dy)});
        return addEventListenerWithOptions
                (e,Event$0[11],capture,once,passive,_fI_)}
      var
       _fJ_=
        handler
         (function(e)
           {var d=e.detail;
            return e.axis === e.HORIZONTAL
                    ?caml_call3(h,e,d,0)
                    :caml_call3(h,e,0,d)});
      return addEventListenerWithOptions
              (e,Event$0[12],capture,once,passive,_fJ_)}
    function addMousewheelEventListener(e,h,capt)
     {return addMousewheelEventListenerWithOptions(e,[0,capt],0,0,h)}
    function f(v)
     {var
       match=caml_js_to_string(v),
       switch$0=caml_string_compare(match,cst_KeyH);
      if(0 <= switch$0)
       {if(! (0 < switch$0))return 8;
        var switch$1=caml_string_compare(match,cst_Numpad4);
        if(0 <= switch$1)
         {if(! (0 < switch$1))return 72;
          var switch$2=caml_string_compare(match,cst_PageUp);
          if(0 <= switch$2)
           {if(! (0 < switch$2))return 98;
            var switch$3=caml_string_compare(match,cst_ShiftRight);
            if(0 <= switch$3)
             {if(! (0 < switch$3))return 91;
              if(! caml_string_notequal(match,cst_Slash))return 55;
              if(! caml_string_notequal(match,cst_Space))return 41;
              if(! caml_string_notequal(match,cst_Tab))return 39;
              if(! caml_string_notequal(match,cst_VolumeDown))return 103;
              if(! caml_string_notequal(match,cst_VolumeMute))return 102;
              if(! caml_string_notequal(match,cst_VolumeUp))return 104}
            else
             {if(! caml_string_notequal(match,cst_Pause))return 123;
              if(! caml_string_notequal(match,cst_Period))return 54;
              if(! caml_string_notequal(match,cst_PrintScreen))return 120;
              if(! caml_string_notequal(match,cst_Quote))return 50;
              if(! caml_string_notequal(match,cst_ScrollLock))return 119;
              if(! caml_string_notequal(match,cst_Semicolon))return 49;
              if(! caml_string_notequal(match,cst_ShiftLeft))return 90}}
          else
           {var switch$4=caml_string_compare(match,cst_NumpadDivide);
            if(0 <= switch$4)
             {if(! (0 < switch$4))return 84;
              if(! caml_string_notequal(match,cst_NumpadEnter))return 83;
              if(! caml_string_notequal(match,cst_NumpadEqual))return 82;
              if(! caml_string_notequal(match,cst_NumpadMultiply))return 78;
              if(! caml_string_notequal(match,cst_NumpadSubtract))return 79;
              if(! caml_string_notequal(match,cst_OSLeft))return 117;
              if(! caml_string_notequal(match,cst_OSRight))return 118;
              if(! caml_string_notequal(match,cst_PageDown))return 99}
            else
             {if(! caml_string_notequal(match,cst_Numpad5))return 73;
              if(! caml_string_notequal(match,cst_Numpad6))return 74;
              if(! caml_string_notequal(match,cst_Numpad7))return 75;
              if(! caml_string_notequal(match,cst_Numpad8))return 76;
              if(! caml_string_notequal(match,cst_Numpad9))return 77;
              if(! caml_string_notequal(match,cst_NumpadAdd))return 80;
              if(! caml_string_notequal(match,cst_NumpadDecimal))return 81}}}
        else
         {var switch$5=caml_string_compare(match,cst_KeyX);
          if(0 <= switch$5)
           {if(! (0 < switch$5))return 24;
            var switch$6=caml_string_compare(match,cst_MetaRight);
            if(0 <= switch$6)
             {if(! (0 < switch$6))return 89;
              if(! caml_string_notequal(match,cst_Minus))return 37;
              if(! caml_string_notequal(match,cst_NumLock))return 85;
              if(! caml_string_notequal(match,cst_Numpad0))return 68;
              if(! caml_string_notequal(match,cst_Numpad1))return 69;
              if(! caml_string_notequal(match,cst_Numpad2))return 70;
              if(! caml_string_notequal(match,cst_Numpad3))return 71}
            else
             {if(! caml_string_notequal(match,cst_KeyY))return 25;
              if(! caml_string_notequal(match,cst_KeyZ))return 26;
              if(! caml_string_notequal(match,cst_MediaPlayPause))return 107;
              if(! caml_string_notequal(match,cst_MediaStop))return 108;
              if(! caml_string_notequal(match,cst_MediaTrackNext))return 106;
              if(! caml_string_notequal(match,cst_MediaTrackPrevious))
               return 105;
              if(! caml_string_notequal(match,cst_MetaLeft))return 88}}
          else
           {var switch$7=caml_string_compare(match,cst_KeyP);
            if(0 <= switch$7)
             {if(! (0 < switch$7))return 16;
              if(! caml_string_notequal(match,cst_KeyQ))return 17;
              if(! caml_string_notequal(match,cst_KeyR))return 18;
              if(! caml_string_notequal(match,cst_KeyS))return 19;
              if(! caml_string_notequal(match,cst_KeyT))return 20;
              if(! caml_string_notequal(match,cst_KeyU))return 21;
              if(! caml_string_notequal(match,cst_KeyV))return 22;
              if(! caml_string_notequal(match,cst_KeyW))return 23}
            else
             {if(! caml_string_notequal(match,cst_KeyI))return 9;
              if(! caml_string_notequal(match,cst_KeyJ))return 10;
              if(! caml_string_notequal(match,cst_KeyK))return 11;
              if(! caml_string_notequal(match,cst_KeyL))return 12;
              if(! caml_string_notequal(match,cst_KeyM))return 13;
              if(! caml_string_notequal(match,cst_KeyN))return 14;
              if(! caml_string_notequal(match,cst_KeyO))return 15}}}}
      else
       {var switch$8=caml_string_compare(match,cst_Digit6);
        if(0 <= switch$8)
         {if(! (0 < switch$8))return 33;
          var switch$9=caml_string_compare(match,cst_F6);
          if(0 <= switch$9)
           {if(! (0 < switch$9))return 61;
            var switch$10=caml_string_compare(match,cst_KeyA);
            if(0 <= switch$10)
             {if(! (0 < switch$10))return 1;
              if(! caml_string_notequal(match,cst_KeyB))return 2;
              if(! caml_string_notequal(match,cst_KeyC))return 3;
              if(! caml_string_notequal(match,cst_KeyD))return 4;
              if(! caml_string_notequal(match,cst_KeyE))return 5;
              if(! caml_string_notequal(match,cst_KeyF))return 6;
              if(! caml_string_notequal(match,cst_KeyG))return 7}
            else
             {if(! caml_string_notequal(match,cst_F7))return 62;
              if(! caml_string_notequal(match,cst_F8))return 63;
              if(! caml_string_notequal(match,cst_F9))return 64;
              if(! caml_string_notequal(match,cst_Home))return 100;
              if(! caml_string_notequal(match,cst_Insert))return 44;
              if(! caml_string_notequal(match,cst_IntlBackslash))return 121;
              if(! caml_string_notequal(match,cst_IntlYen))return 122}}
          else
           {var switch$11=caml_string_compare(match,cst_F1);
            if(0 <= switch$11)
             {if(! (0 < switch$11))return 56;
              if(! caml_string_notequal(match,cst_F10))return 65;
              if(! caml_string_notequal(match,cst_F11))return 66;
              if(! caml_string_notequal(match,cst_F12))return 67;
              if(! caml_string_notequal(match,cst_F2))return 57;
              if(! caml_string_notequal(match,cst_F3))return 58;
              if(! caml_string_notequal(match,cst_F4))return 59;
              if(! caml_string_notequal(match,cst_F5))return 60}
            else
             {if(! caml_string_notequal(match,cst_Digit7))return 34;
              if(! caml_string_notequal(match,cst_Digit8))return 35;
              if(! caml_string_notequal(match,cst_Digit9))return 36;
              if(! caml_string_notequal(match,cst_End))return 101;
              if(! caml_string_notequal(match,cst_Enter))return 40;
              if(! caml_string_notequal(match,cst_Equal))return 38;
              if(! caml_string_notequal(match,cst_Escape))return 42}}}
        else
         {var switch$12=caml_string_compare(match,cst_BrowserRefresh);
          if(0 <= switch$12)
           {if(! (0 < switch$12))return 113;
            var switch$13=caml_string_compare(match,cst_Delete);
            if(0 <= switch$13)
             {if(! (0 < switch$13))return 45;
              if(! caml_string_notequal(match,cst_Digit0))return 27;
              if(! caml_string_notequal(match,cst_Digit1))return 28;
              if(! caml_string_notequal(match,cst_Digit2))return 29;
              if(! caml_string_notequal(match,cst_Digit3))return 30;
              if(! caml_string_notequal(match,cst_Digit4))return 31;
              if(! caml_string_notequal(match,cst_Digit5))return 32}
            else
             {if(! caml_string_notequal(match,cst_BrowserSearch))return 110;
              if(! caml_string_notequal(match,cst_BrowserStop))return 114;
              if(! caml_string_notequal(match,cst_CapsLock))return 46;
              if(! caml_string_notequal(match,cst_Comma))return 53;
              if(! caml_string_notequal(match,cst_ContextMenu))return 109;
              if(! caml_string_notequal(match,cst_ControlLeft))return 86;
              if(! caml_string_notequal(match,cst_ControlRight))return 87}}
          else
           {var switch$14=caml_string_compare(match,cst_Backslash);
            if(0 <= switch$14)
             {if(! (0 < switch$14))return 52;
              if(! caml_string_notequal(match,cst_Backspace))return 43;
              if(! caml_string_notequal(match,cst_BracketLeft))return 47;
              if(! caml_string_notequal(match,cst_BracketRight))return 48;
              if(! caml_string_notequal(match,cst_BrowserBack))return 116;
              if(! caml_string_notequal(match,cst_BrowserFavorites))
               return 112;
              if(! caml_string_notequal(match,cst_BrowserForward))return 115;
              if(! caml_string_notequal(match,cst_BrowserHome))return 111}
            else
             {if(! caml_string_notequal(match,cst_AltLeft))return 92;
              if(! caml_string_notequal(match,cst_AltRight))return 93;
              if(! caml_string_notequal(match,cst_ArrowDown))return 97;
              if(! caml_string_notequal(match,cst_ArrowLeft))return 94;
              if(! caml_string_notequal(match,cst_ArrowRight))return 95;
              if(! caml_string_notequal(match,cst_ArrowUp))return 96;
              if(! caml_string_notequal(match,cst_Backquote))return 51}}}}
      return 0}
    function try_key_code_left(param)
     {if(19 <= param)
       {if(91 === param)return 88}
      else
       if(16 <= param)
        {var switcher=param - 16 | 0;
         switch(switcher){case 0:return 90;case 1:return 86;default:return 92}}
      return 0}
    function try_key_code_right(param)
     {if(19 <= param)
       {if(91 === param)return 89}
      else
       if(16 <= param)
        {var switcher=param - 16 | 0;
         switch(switcher){case 0:return 91;case 1:return 87;default:return 93}}
      return 0}
    function try_key_code_numpad(param)
     {if(47 <= param)
       {var switcher=param - 96 | 0;
        if(! (15 < switcher >>> 0))
         switch(switcher)
          {case 0:return 68;
           case 1:return 69;
           case 2:return 70;
           case 3:return 71;
           case 4:return 72;
           case 5:return 73;
           case 6:return 74;
           case 7:return 75;
           case 8:return 76;
           case 9:return 77;
           case 10:return 78;
           case 11:return 80;
           case 12:break;
           case 13:return 79;
           case 14:return 81;
           default:return 84}}
      else
       if(12 <= param)
        {var switcher$0=param - 12 | 0;
         switch(switcher$0)
          {case 0:return 73;
           case 1:return 83;
           case 21:return 77;
           case 22:return 71;
           case 23:return 69;
           case 24:return 75;
           case 25:return 72;
           case 26:return 76;
           case 27:return 74;
           case 28:return 70;
           case 33:return 68;
           case 34:return 81
           }}
      return 0}
    function try_key_code_normal(param)
     {var switcher=param - 8 | 0;
      if(! (214 < switcher >>> 0))
       {var _fH_=switcher;
        if(67 <= _fH_)
         switch(_fH_)
          {case 67:return 11;
           case 68:return 12;
           case 69:return 13;
           case 70:return 14;
           case 71:return 15;
           case 72:return 16;
           case 73:return 17;
           case 74:return 18;
           case 75:return 19;
           case 76:return 20;
           case 77:return 21;
           case 78:return 22;
           case 79:return 23;
           case 80:return 24;
           case 81:return 25;
           case 82:return 26;
           case 85:return 109;
           case 104:return 56;
           case 105:return 57;
           case 106:return 58;
           case 107:return 59;
           case 108:return 60;
           case 109:return 61;
           case 110:return 62;
           case 111:return 63;
           case 112:return 64;
           case 113:return 65;
           case 114:return 66;
           case 115:return 67;
           case 137:return 119;
           case 178:return 49;
           case 179:return 38;
           case 180:return 53;
           case 181:return 37;
           case 182:return 54;
           case 183:return 55;
           case 184:return 51;
           case 211:return 47;
           case 212:return 52;
           case 213:return 48;
           case 214:return 50
           }
        else
         switch(_fH_)
          {case 0:return 43;
           case 1:return 39;
           case 5:return 40;
           case 11:return 123;
           case 12:return 46;
           case 19:return 42;
           case 24:return 41;
           case 25:return 98;
           case 26:return 99;
           case 27:return 101;
           case 28:return 100;
           case 29:return 94;
           case 30:return 96;
           case 31:return 95;
           case 32:return 97;
           case 34:return 120;
           case 37:return 44;
           case 38:return 45;
           case 40:return 27;
           case 41:return 28;
           case 42:return 29;
           case 43:return 30;
           case 44:return 31;
           case 45:return 32;
           case 46:return 33;
           case 47:return 34;
           case 48:return 35;
           case 49:return 36;
           case 57:return 1;
           case 58:return 2;
           case 59:return 3;
           case 60:return 4;
           case 61:return 5;
           case 62:return 6;
           case 63:return 7;
           case 64:return 8;
           case 65:return 9;
           case 66:return 10
           }}
      return 0}
    function make_unidentified(param){return 0}
    function run_next(value,f,v){return 0 === v?caml_call1(f,value):v}
    function symbol$11(x,f){return caml_call1(f,x)}
    function of_event(evt)
     {var _fA_=evt.keyCode;
      function _fB_(_fG_){return run_next(_fA_,try_key_code_normal,_fG_)}
      var match=evt.location,switcher=match - 1 | 0;
      if(2 < switcher >>> 0)
       var _fC_=make_unidentified;
      else
       switch(switcher)
        {case 0:
          var
           _fx_=evt.keyCode,
           _fC_=function(_fE_){return run_next(_fx_,try_key_code_left,_fE_)};
          break;
         case 1:
          var
           _fy_=evt.keyCode,
           _fC_=function(_fD_){return run_next(_fy_,try_key_code_right,_fD_)};
          break;
         default:
          var
           _fz_=evt.keyCode,
           _fC_=function(_fF_){return run_next(_fz_,try_key_code_numpad,_fF_)}}
      var value=evt.code;
      return symbol$11
              (symbol$11
                (symbol$11
                  (0,
                   function(v)
                    {return 0 === v
                             ?caml_call3(Optdef[7],value,make_unidentified,f)
                             :v}),
                 _fC_),
               _fB_)}
    function char_of_int(value)
     {if(caml_call2(symbol$5,0,value))
       try
        {var _fv_=[0,caml_call1(Uchar[8],value)];return _fv_}
       catch(_fw_){return 0}
      return 0}
    function empty_string(param){return ""}
    function none(param){return 0}
    function of_event$0(evt)
     {var key=caml_call2(Optdef[8],evt.key,empty_string),match=key.length;
      return 0 === match
              ?caml_call3(Optdef[7],evt.charCode,none,char_of_int)
              :1 === match?char_of_int(key.charCodeAt(0) | 0):0}
    function element$1(_fu_){return _fu_}
    function tagged(e)
     {var tag=caml_js_to_byte_string(e.tagName.toLowerCase());
      if(caml_call2(symbol$8,caml_ml_string_length(tag),0))return [61,e];
      var match=runtime.caml_bytes_unsafe_get(tag,0),switcher=match - 97 | 0;
      if(! (21 < switcher >>> 0))
       switch(switcher)
        {case 0:
          return caml_string_notequal(tag,cst_a$1)
                  ?caml_string_notequal(tag,cst_area$1)
                    ?caml_string_notequal(tag,cst_audio$1)?[61,e]:[2,e]
                    :[1,e]
                  :[0,e];
         case 1:
          return caml_string_notequal(tag,cst_base$1)
                  ?caml_string_notequal(tag,cst_blockquote$1)
                    ?caml_string_notequal(tag,cst_body$1)
                      ?caml_string_notequal(tag,cst_br$1)
                        ?caml_string_notequal(tag,cst_button$1)?[61,e]:[7,e]
                        :[6,e]
                      :[5,e]
                    :[4,e]
                  :[3,e];
         case 2:
          return caml_string_notequal(tag,cst_canvas$1)
                  ?caml_string_notequal(tag,cst_caption$1)
                    ?caml_string_notequal(tag,cst_col$1)
                      ?caml_string_notequal(tag,cst_colgroup$1)?[61,e]:[11,e]
                      :[10,e]
                    :[9,e]
                  :[8,e];
         case 3:
          return caml_string_notequal(tag,cst_del$1)
                  ?caml_string_notequal(tag,cst_div$1)
                    ?caml_string_notequal(tag,cst_dl$1)?[61,e]:[14,e]
                    :[13,e]
                  :[12,e];
         case 4:return caml_string_notequal(tag,cst_embed$1)?[61,e]:[15,e];
         case 5:
          return caml_string_notequal(tag,cst_fieldset$1)
                  ?caml_string_notequal(tag,cst_form$1)
                    ?caml_string_notequal(tag,cst_frame$1)
                      ?caml_string_notequal(tag,cst_frameset$1)?[61,e]:[18,e]
                      :[19,e]
                    :[17,e]
                  :[16,e];
         case 7:
          return caml_string_notequal(tag,cst_h1$1)
                  ?caml_string_notequal(tag,cst_h2$1)
                    ?caml_string_notequal(tag,cst_h3$1)
                      ?caml_string_notequal(tag,cst_h4$1)
                        ?caml_string_notequal(tag,cst_h5$1)
                          ?caml_string_notequal(tag,cst_h6$1)
                            ?caml_string_notequal(tag,cst_head$1)
                              ?caml_string_notequal(tag,cst_hr$1)
                                ?caml_string_notequal(tag,cst_html$1)?[61,e]:[28,e]
                                :[27,e]
                              :[26,e]
                            :[25,e]
                          :[24,e]
                        :[23,e]
                      :[22,e]
                    :[21,e]
                  :[20,e];
         case 8:
          return caml_string_notequal(tag,cst_iframe$1)
                  ?caml_string_notequal(tag,cst_img$1)
                    ?caml_string_notequal(tag,cst_input$2)
                      ?caml_string_notequal(tag,cst_ins$1)?[61,e]:[32,e]
                      :[31,e]
                    :[30,e]
                  :[29,e];
         case 11:
          return caml_string_notequal(tag,cst_label$1)
                  ?caml_string_notequal(tag,cst_legend$1)
                    ?caml_string_notequal(tag,cst_li$1)
                      ?caml_string_notequal(tag,cst_link$1)?[61,e]:[36,e]
                      :[35,e]
                    :[34,e]
                  :[33,e];
         case 12:
          return caml_string_notequal(tag,cst_map$1)
                  ?caml_string_notequal(tag,cst_meta$1)?[61,e]:[38,e]
                  :[37,e];
         case 14:
          return caml_string_notequal(tag,cst_object$1)
                  ?caml_string_notequal(tag,cst_ol$1)
                    ?caml_string_notequal(tag,cst_optgroup$1)
                      ?caml_string_notequal(tag,cst_option$1)?[61,e]:[42,e]
                      :[41,e]
                    :[40,e]
                  :[39,e];
         case 15:
          return caml_string_notequal(tag,cst_p$1)
                  ?caml_string_notequal(tag,cst_param$1)
                    ?caml_string_notequal(tag,cst_pre$1)?[61,e]:[45,e]
                    :[44,e]
                  :[43,e];
         case 16:return caml_string_notequal(tag,cst_q$1)?[61,e]:[46,e];
         case 18:
          return caml_string_notequal(tag,cst_script$1)
                  ?caml_string_notequal(tag,cst_select$2)
                    ?caml_string_notequal(tag,cst_style$1)?[61,e]:[49,e]
                    :[48,e]
                  :[47,e];
         case 19:
          return caml_string_notequal(tag,cst_table$1)
                  ?caml_string_notequal(tag,cst_tbody$1)
                    ?caml_string_notequal(tag,cst_td$1)
                      ?caml_string_notequal(tag,cst_textarea$1)
                        ?caml_string_notequal(tag,cst_tfoot$1)
                          ?caml_string_notequal(tag,cst_th$1)
                            ?caml_string_notequal(tag,cst_thead$1)
                              ?caml_string_notequal(tag,cst_title$1)
                                ?caml_string_notequal(tag,cst_tr$1)?[61,e]:[58,e]
                                :[57,e]
                              :[56,e]
                            :[55,e]
                          :[54,e]
                        :[53,e]
                      :[52,e]
                    :[51,e]
                  :[50,e];
         case 20:return caml_string_notequal(tag,cst_ul$1)?[61,e]:[59,e];
         case 21:return caml_string_notequal(tag,cst_video$1)?[61,e]:[60,e]
         }
      return [61,e]}
    function opt_tagged(e)
     {function _fs_(e){return [0,tagged(e)]}
      function _ft_(param){return 0}
      return caml_call3(Opt[7],e,_ft_,_fs_)}
    function taggedEvent(ev)
     {function _fd_(ev){return [0,ev]}
      function _fe_(param)
       {function _fg_(ev){return [1,ev]}
        function _fh_(param)
         {function _fj_(ev){return [2,ev]}
          function _fk_(param)
           {function _fm_(ev){return [3,ev]}
            function _fn_(param)
             {function _fp_(ev){return [4,ev]}
              function _fq_(param){return [5,ev]}
              var _fr_=popStateEvent(ev);
              return caml_call3(Opt[7],_fr_,_fq_,_fp_)}
            var _fo_=mouseScrollEvent(ev);
            return caml_call3(Opt[7],_fo_,_fn_,_fm_)}
          var _fl_=wheelEvent(ev);
          return caml_call3(Opt[7],_fl_,_fk_,_fj_)}
        var _fi_=keyboardEvent(ev);
        return caml_call3(Opt[7],_fi_,_fh_,_fg_)}
      var _ff_=mouseEvent(ev);
      return caml_call3(Opt[7],_ff_,_fe_,_fd_)}
    function opt_taggedEvent(ev)
     {function _fb_(ev){return [0,taggedEvent(ev)]}
      function _fc_(param){return 0}
      return caml_call3(Opt[7],ev,_fc_,_fb_)}
    function stopPropagation(ev)
     {function _e$_(param){return ev.stopPropagation()}
      function _fa_(param){return ev.cancelBubble = true$0}
      return caml_call3(Optdef[7],ev.stopPropagation,_fa_,_e$_)}
    var
     requestAnimationFrame=
      runtime.caml_js_pure_expr
       (function(param)
         {var
           l=
            [0,
             _g_.requestAnimationFrame,
             [0,
              _g_.mozRequestAnimationFrame,
              [0,
               _g_.webkitRequestAnimationFrame,
               [0,
                _g_.oRequestAnimationFrame,
                [0,_g_.msRequestAnimationFrame,0]]]]];
          try
           {var
             _e8_=function(c){return caml_call1(Optdef[5],c)},
             req=caml_call2(List[33],_e8_,l),
             _e9_=function(callback){return req(callback)};
            return _e9_}
          catch(_e__)
           {_e__ = caml_wrap_exception(_e__);
            if(_e__ === Not_found)
             {var
               now=function(param){return new date_ms().getTime()},
               last=[0,now(0)];
              return function(callback)
               {var
                 t=now(0),
                 dt=last[1] + 16.6666666666666679 - t,
                 dt$0=dt < 0.?0.:dt;
                last[1] = t;
                _g_.setTimeout(callback,dt$0);
                return 0}}
            throw _e__}});
    function hasPushState(param)
     {return caml_call1(Optdef[5],_g_.history.pushState)}
    function hasPlaceholder(param)
     {var i=createInput(0,0,document$0);
      return caml_call1(Optdef[5],i.placeholder)}
    function hasRequired(param)
     {var i=createInput(0,0,document$0);
      return caml_call1(Optdef[5],i.required)}
    var overflow_limit=2147483000.;
    function setTimeout(callback,d)
     {var id=[0,0];
      function loop(step,param)
       {if(2147483000. < step)
         var step$0=overflow_limit,remain=step - 2147483000.;
        else
         var step$0=step,remain=0.;
        var cb=remain == 0.?callback:function(_e7_){return loop(remain,_e7_)};
        id[1] = [0,_g_.setTimeout(caml_js_wrap_callback(cb),step$0)];
        return 0}
      loop(d,0);
      return id}
    function clearTimeout(id)
     {var _e6_=id[1];
      if(_e6_){var x=_e6_[1];id[1] = 0;return _g_.clearTimeout(x)}
      return 0}
    function js_array_of_collection(c){return [].slice.call(c)}
    var
     Js_of_ocaml_Dom_html=
      [0,
       d,
       document$0,
       getElementById_opt,
       getElementById_exn,
       getElementById_coerce,
       getElementById,
       location_origin,
       _g_,
       no_handler,
       handler,
       full_handler,
       invoke_handler,
       eventTarget,
       eventRelatedTarget,
       Event$0,
       addEventListenerWithOptions,
       addEventListener,
       removeEventListener,
       addMousewheelEventListenerWithOptions,
       addMousewheelEventListener,
       createCustomEvent,
       buttonPressed,
       eventAbsolutePosition$0,
       elementClientPosition,
       getDocumentScroll,
       [0,of_event,try_key_code_normal],
       [0,of_event$0],
       createHtml,
       createHead,
       createLink,
       createTitle,
       createMeta,
       createBase,
       createStyle,
       createBody,
       createForm,
       createOptgroup,
       createOption,
       createSelect,
       createInput,
       createTextarea,
       createButton,
       createLabel,
       createFieldset,
       createLegend,
       createUl,
       createOl,
       createDl,
       createLi,
       createDiv,
       createEmbed,
       createP,
       createH1,
       createH2,
       createH3,
       createH4,
       createH5,
       createH6,
       createQ,
       createBlockquote,
       createPre,
       createBr,
       createHr,
       createIns,
       createDel,
       createA,
       createImg,
       createObject,
       createParam,
       createMap,
       createArea,
       createScript,
       createTable,
       createCaption,
       createCol,
       createColgroup,
       createThead,
       createTfoot,
       createTbody,
       createTr,
       createTh,
       createTd,
       createSub,
       createSup,
       createSpan,
       createTt,
       createI,
       createB,
       createBig,
       createSmall,
       createEm,
       createStrong,
       createCite,
       createDfn,
       createCode,
       createSamp,
       createKbd,
       createVar,
       createAbbr,
       createDd,
       createDt,
       createNoscript,
       createAddress,
       createFrameset,
       createFrame,
       createIframe,
       createAudio,
       createVideo,
       Canvas_not_available,
       createCanvas,
       element$1,
       tagged,
       opt_tagged,
       taggedEvent,
       opt_taggedEvent,
       stopPropagation,
       [0,
        element$0,
        a,
        area,
        audio,
        base,
        blockquote,
        body,
        br,
        button,
        canvas,
        caption,
        col,
        colgroup,
        del,
        div,
        embed,
        dl,
        fieldset,
        form,
        frameset,
        frame,
        h1,
        h2,
        h3,
        h4,
        h5,
        h6,
        head,
        hr,
        html,
        iframe,
        img,
        input$0,
        ins,
        label,
        legend,
        li,
        link,
        map$2,
        meta,
        object,
        ol,
        optgroup,
        option$1,
        p,
        param,
        pre,
        q,
        script,
        select$0,
        style,
        table,
        tbody,
        td,
        textarea,
        tfoot,
        th,
        thead,
        title,
        tr,
        ul,
        video,
        mouseEvent,
        keyboardEvent,
        wheelEvent,
        mouseScrollEvent,
        popStateEvent],
       setTimeout,
       clearTimeout,
       js_array_of_collection,
       requestAnimationFrame,
       runtime.caml_js_html_entities,
       onIE,
       hasPushState,
       hasPlaceholder,
       hasRequired];
    caml_register_global(1644,Js_of_ocaml_Dom_html,"Js_of_ocaml__Dom_html");
    var formData=Unsafe[1].FormData,formData_form=Unsafe[1].FormData;
    function filter_map$0(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var q=param$0[2],v=param$0[1],match=caml_call1(f,v);
          if(match){var v$0=match[1];return [0,v$0,filter_map$0(f,q)]}
          var param$0=q;
          continue}
        return 0}}
    function have_content(elt)
     {var
       _e4_=caml_call2(symbol$9,elt.name.length,0),
       _e5_=_e4_?1 - (elt.disabled | 0):_e4_;
      return _e5_}
    function form_elements(get,form)
     {var length=form.elements.length;
      function _eS_(i)
       {var _e3_=form.elements.item(i);return caml_call1(Opt[10],_e3_)}
      var
       _eT_=caml_call2(Array[2],length,_eS_),
       elements=caml_call1(Array[11],_eT_);
      function _eU_(param)
       {if(param)
         {var v=param[1],match$3=tagged(v);
          switch(match$3[0])
           {case 31:
             var v$0=match$3[1];
             if(get)var sth=get[1],get$0=sth;else var get$0=0;
             if(have_content(v$0))
              {var
                name$1=caml_js_to_string(v$0.name),
                value=v$0.value,
                match=caml_js_to_byte_string(v$0.type.toLowerCase());
               if(caml_string_notequal(match,cst_checkbox))
                {if(! caml_string_notequal(match,cst_file))
                  {if(get$0)return [0,[0,name$1,[0,-976970511,value]],0];
                   var match$0=caml_call1(Optdef[10],v$0.files);
                   if(match$0)
                    {var list=match$0[1];
                     if(caml_call2(symbol$8,list.length,0))
                      return [0,[0,name$1,[0,-976970511,""]],0];
                     var match$1=caml_call1(Optdef[10],v$0.multiple);
                     if(match$1)
                      if(0 !== match$1[1])
                       {var
                         _eZ_=function(i){return list.item(i)},
                         _e0_=caml_call2(Array[2],list.length,_eZ_),
                         _e1_=caml_call1(Array[11],_e0_);
                        return filter_map$0
                                (function(f)
                                  {var match=caml_call1(Opt[10],f);
                                   if(match)
                                    {var file=match[1];return [0,[0,name$1,[0,781515420,file]]]}
                                   return 0},
                                 _e1_)}
                     var _eY_=list.item(0),match$2=caml_call1(Opt[10],_eY_);
                     if(match$2)
                      {var file=match$2[1];
                       return [0,[0,name$1,[0,781515420,file]],0]}
                     return 0}
                   return 0}
                 if(caml_string_notequal(match,cst_password))
                  if(caml_string_notequal(match,cst_radio))
                   {if(caml_string_notequal(match,cst_reset))
                     if(caml_string_notequal(match,cst_submit$0))
                      {if(caml_string_notequal(match,cst_text))
                        return [0,[0,name$1,[0,-976970511,value]],0];
                       var switch$0=1,switch$1=0}
                     else
                      var switch$1=1;
                    else
                     var switch$1=1;
                    if(switch$1)return 0}
                  else
                   var switch$0=0;
                 else
                  var switch$0=1;
                 if(switch$0)return [0,[0,name$1,[0,-976970511,value]],0]}
               return v$0.checked | 0?[0,[0,name$1,[0,-976970511,value]],0]:0}
             return 0;
            case 48:
             var v$1=match$3[1];
             if(have_content(v$1))
              {var name$0=caml_js_to_string(v$1.name);
               if(v$1.multiple | 0)
                {var
                  _eW_=
                   function(i)
                    {var _e2_=v$1.options.item(i);
                     return caml_call1(Opt[10],_e2_)},
                  options=caml_call2(Array[2],v$1.options.length,_eW_),
                  _eX_=caml_call1(Array[11],options);
                 return filter_map$0
                         (function(param)
                           {if(param)
                             {var e=param[1];
                              return e.selected | 0
                                      ?[0,[0,name$0,[0,-976970511,e.value]]]
                                      :0}
                            return 0},
                          _eX_)}
               return [0,[0,name$0,[0,-976970511,v$1.value]],0]}
             return 0;
            case 53:
             var v$2=match$3[1];
             if(have_content(v$2))
              {var name=caml_js_to_string(v$2.name);
               return [0,[0,name,[0,-976970511,v$2.value]],0]}
             return 0;
            default:return 0}}
        return 0}
      var
       _eV_=caml_call2(List[17],_eU_,elements),
       contents=caml_call1(List[14],_eV_);
      return contents}
    function append(form_contents,form_elt)
     {if(891486873 <= form_contents[1])
       {var list=form_contents[2];list[1] = [0,form_elt,list[1]];return 0}
      var f=form_contents[2],_eQ_=form_elt[2],_eR_=form_elt[1];
      if(781515420 <= _eQ_[1])
       {var file=_eQ_[2];return f.append(_eR_.toString(),file)}
      var s=_eQ_[2];
      return f.append(_eR_.toString(),s)}
    function empty_form_contents(param)
     {var match=caml_call1(Optdef[10],formData);
      if(match){var constr=match[1];return [0,808620462,new constr()]}
      return [0,891486873,[0,0]]}
    function post_form_contents(form)
     {var contents=empty_form_contents(0),_eN_=form_elements(0,form);
      function _eO_(_eP_){return append(contents,_eP_)}
      caml_call2(List[15],_eO_,_eN_);
      return contents}
    function get_form_contents(form)
     {var _eJ_=form_elements(_k_,form);
      function _eK_(param)
       {var _eL_=param[2],_eM_=param[1];
        if(typeof _eL_ !== "number")
         if(-976970511 === _eL_[1])
          {var s=_eL_[2];return [0,_eM_,caml_js_to_string(s)]}
        throw [0,Assert_failure,_l_]}
      return caml_call2(List[17],_eK_,_eJ_)}
    var
     Js_of_ocaml_Form=
      [0,
       formData,
       formData_form,
       append,
       post_form_contents,
       get_form_contents,
       empty_form_contents,
       form_elements];
    caml_register_global(1645,Js_of_ocaml_Form,"Js_of_ocaml__Form");
    var
     readystatechange=caml_call1(Event[1],cst_readystatechange),
     loadstart$1=caml_call1(Event[1],cst_loadstart$1),
     progress$1=caml_call1(Event[1],cst_progress$1),
     abort$1=caml_call1(Event[1],cst_abort$1),
     error$1=caml_call1(Event[1],cst_error$1),
     load$1=caml_call1(Event[1],cst_load$1),
     timeout=caml_call1(Event[1],cst_timeout),
     loadend$0=caml_call1(Event[1],cst_loadend$0),
     Event$1=
      [0,
       readystatechange,
       loadstart$1,
       progress$1,
       abort$1,
       error$1,
       load$1,
       timeout,
       loadend$0];
    function create(param)
     {var
       xmlHttpRequest=Unsafe[1].XMLHttpRequest,
       activeXObject=Unsafe[1].activeXObject;
      try
       {var _eE_=new xmlHttpRequest();return _eE_}
      catch(_eF_)
       {try
         {var _eD_=new activeXObject("Msxml2.XMLHTTP");return _eD_}
        catch(_eG_)
         {try
           {var _eC_=new activeXObject("Msxml3.XMLHTTP");return _eC_}
          catch(_eH_)
           {try
             {var _eB_=new activeXObject("Microsoft.XMLHTTP");return _eB_}
            catch(_eI_){throw [0,Assert_failure,_m_]}}}}}
    var Js_of_ocaml_XmlHttpRequest=[0,create,Event$1];
    caml_register_global
     (1646,Js_of_ocaml_XmlHttpRequest,"Js_of_ocaml__XmlHttpRequest");
    var worker=Unsafe[1].Worker;
    function create$0(script){return new worker(script.toString())}
    function import_scripts(scripts)
     {if(Unsafe[1].importScripts === t37)
       caml_call1(Pervasives[1],cst_Worker_import_scripts_is_undefined);
      var
       _ez_=caml_call1(Array[12],scripts),
       _eA_=caml_call2(Array[15],caml_js_from_string,_ez_);
      return runtime.caml_js_fun_call(Unsafe[1].importScripts,_eA_)}
    function set_onmessage(handler)
     {if(Unsafe[1].onmessage === t37)
       caml_call1(Pervasives[1],cst_Worker_onmessage_is_undefined);
      function js_handler(ev){return caml_call1(handler,ev.data)}
      return Unsafe[1].onmessage = caml_js_wrap_callback(js_handler)}
    function post_message(msg)
     {if(Unsafe[1].postMessage === t37)
       caml_call1(Pervasives[1],cst_Worker_onmessage_is_undefined$0);
      return Unsafe[1].postMessage(msg)}
    var
     Js_of_ocaml_Worker=
      [0,create$0,import_scripts,set_onmessage,post_message];
    caml_register_global(1647,Js_of_ocaml_Worker,"Js_of_ocaml__Worker");
    var webSocket=Unsafe[1].WebSocket;
    function is_supported(param){return caml_call1(Optdef[5],webSocket)}
    var Js_of_ocaml_WebSockets=[0,webSocket,webSocket,webSocket,is_supported];
    caml_register_global
     (1648,Js_of_ocaml_WebSockets,"Js_of_ocaml__WebSockets");
    var
     defaultContextAttributes=
      {"alpha":true$0,
       "depth":true$0,
       "stencil":false$0,
       "antialias":true$0,
       "premultipliedAlpha":false$0,
       "preserveDrawingBuffer":false$0,
       "preferLowPowerToHighPerformance":false$0,
       "failIfMajorPerformanceCaveat":false$0},
     webglcontextlost=caml_call1(Event$0[83],cst_webglcontextlost),
     webglcontextrestored=caml_call1(Event$0[83],cst_webglcontextrestored),
     webglcontextcreationerror=
      caml_call1(Event$0[83],cst_webglcontextcreationerror),
     Event$2=
      [0,webglcontextlost,webglcontextrestored,webglcontextcreationerror];
    function getContext(c)
     {var ctx=c.getContext("webgl");
      return caml_call1(Opt[5],ctx)?ctx:c.getContext("experimental-webgl")}
    function getContextWithAttributes(c,attribs)
     {var ctx=c.getContext("webgl",attribs);
      return caml_call1(Opt[5],ctx)
              ?ctx
              :c.getContext("experimental-webgl",attribs)}
    var
     Js_of_ocaml_WebGL=
      [0,defaultContextAttributes,Event$2,getContext,getContextWithAttributes];
    caml_register_global(1649,Js_of_ocaml_WebGL,"Js_of_ocaml__WebGL");
    function regexp(s)
     {return new regExp_withFlags(caml_jsbytes_of_string(s),"g")}
    function regexp_case_fold(s)
     {return new regExp_withFlags(caml_jsbytes_of_string(s),"gi")}
    function regexp_with_flag(s,f)
     {var _ey_=caml_call2(Pervasives[16],cst_g,f).toString();
      return new regExp_withFlags(caml_jsbytes_of_string(s),_ey_)}
    function blunt_str_array_get(a,i)
     {function _ex_(param){throw [0,Assert_failure,_n_]}
      return caml_js_to_byte_string(caml_call2(Optdef[8],a[i],_ex_))}
    function string_match(r,s,i)
     {r.lastIndex = i;
      var
       _ev_=r.exec(caml_jsbytes_of_string(s)),
       _ew_=caml_call2(Opt[3],_ev_,match_result);
      return caml_call1(Opt[10],_ew_)}
    function search_forward(r,s,i)
     {r.lastIndex = i;
      function _es_(res){return [0,res.index,res]}
      var
       _et_=r.exec(caml_jsbytes_of_string(s)),
       _eu_=caml_call2(Opt[3],_et_,_es_);
      return caml_call1(Opt[10],_eu_)}
    function matched_string(r){return blunt_str_array_get(r,0)}
    function matched_group(r,i)
     {var _er_=caml_call2(Optdef[3],r[i],caml_js_to_byte_string);
      return caml_call1(Optdef[10],_er_)}
    var quote_repl_re=new regExp_withFlags("[$]","g");
    function quote_repl(s)
     {return caml_jsbytes_of_string(s).replace(quote_repl_re,"$$$$")}
    function global_replace(r,s,s_by)
     {r.lastIndex = 0;
      var _eq_=quote_repl(s_by);
      return caml_js_to_byte_string(caml_jsbytes_of_string(s).replace(r,_eq_))}
    function replace_first(r,s,s_by)
     {var
       match=r.ignoreCase | 0,
       match$0=r.multiline | 0,
       flags=0 === match?0 === match$0?"":"m":0 === match$0?"i":"mi",
       r$0=new regExp_withFlags(r.source,flags),
       _ep_=quote_repl(s_by);
      return caml_js_to_byte_string
              (caml_jsbytes_of_string(s).replace(r$0,_ep_))}
    function list_of_js_array(a)
     {var idx$1=a.length - 1 | 0,accu=0,idx=idx$1;
      for(;;)
       {if(caml_call2(symbol$5,idx,0))return accu;
        var
         idx$0=idx - 1 | 0,
         accu$0=[0,blunt_str_array_get(a,idx),accu],
         accu=accu$0,
         idx=idx$0;
        continue}}
    function split(r,s)
     {r.lastIndex = 0;
      return list_of_js_array(caml_jsbytes_of_string(s).split(r))}
    function bounded_split(r,s,i)
     {r.lastIndex = 0;
      return list_of_js_array(caml_jsbytes_of_string(s).split(r,i))}
    var quote_re=regexp(cst);
    function quote(s)
     {return caml_js_to_byte_string
              (caml_jsbytes_of_string(s).replace(quote_re,"\\$&"))}
    function regexp_string(s){return regexp(quote(s))}
    function regexp_string_case_fold(s){return regexp_case_fold(quote(s))}
    var
     Js_of_ocaml_Regexp=
      [0,
       regexp,
       regexp_case_fold,
       regexp_with_flag,
       quote,
       regexp_string,
       regexp_string_case_fold,
       string_match,
       search_forward,
       search_forward,
       matched_string,
       matched_group,
       global_replace,
       replace_first,
       split,
       bounded_split];
    caml_register_global(1650,Js_of_ocaml_Regexp,"Js_of_ocaml__Regexp");
    var Local_exn=[248,cst_Js_of_ocaml_Url_Local_exn,caml_fresh_oo_id(0)];
    function interrupt(param){throw Local_exn}
    var
     plus_re=regexp_string(cst$0),
     plus_re_js_string=new regExp_withFlags("\\+","g");
    function urldecode_js_string_string(s)
     {plus_re_js_string.lastIndex = 0;
      return caml_js_to_byte_string
              (unescape(s.replace(plus_re_js_string," ")))}
    function urldecode(s)
     {return caml_js_to_byte_string
              (unescape
                (caml_jsbytes_of_string(global_replace(plus_re,s,cst$1))))}
    function urlencode(opt,s)
     {if(opt)var sth=opt[1],with_plus=sth;else var with_plus=1;
      if(with_plus)
       {var s$0=caml_js_to_byte_string(escape(caml_jsbytes_of_string(s)));
        return global_replace(plus_re,s$0,cst_2B)}
      return caml_js_to_byte_string(escape(caml_jsbytes_of_string(s)))}
    var
     Not_an_http_protocol=
      [248,cst_Js_of_ocaml_Url_Not_an_http_protocol,caml_fresh_oo_id(0)],
     default_http_port=80,
     default_https_port=443;
    function path_of_path_string(s)
     {var l=caml_ml_string_length(s);
      function aux(i)
       {try
         {var _en_=caml_call3(String$0[18],s,i,47),j=_en_}
        catch(_eo_)
         {_eo_ = caml_wrap_exception(_eo_);
          if(_eo_ !== Not_found)throw _eo_;
          var j=l}
        var word=caml_call3(String$0[4],s,i,j - i | 0);
        return caml_call2(symbol$10,j,l)?[0,word,0]:[0,word,aux(j + 1 | 0)]}
      var a=aux(0);
      if(a)
       if(! caml_string_notequal(a[1],cst$2))
        {var _em_=a[2];
         if(! _em_)return 0;
         if(! caml_string_notequal(_em_[1],cst$3))if(! _em_[2])return _o_}
      return a}
    function encode_arguments(l)
     {function _eh_(param)
       {var
         v=param[2],
         n=param[1],
         _ej_=urlencode(0,v),
         _ek_=caml_call2(Pervasives[16],cst$4,_ej_),
         _el_=urlencode(0,n);
        return caml_call2(Pervasives[16],_el_,_ek_)}
      var _ei_=caml_call2(List[17],_eh_,l);
      return caml_call2(String$0[7],cst$5,_ei_)}
    function decode_arguments_js_string(s)
     {var arr=s.split(caml_call2(String$0[1],1,38).toString()),len=arr.length;
      function aux(acc,idx)
       {var idx$0=idx;
        for(;;)
         {if(caml_call2(symbol$5,idx$0,0))return acc;
          try
           {var
             _d$_=idx$0 - 1 | 0,
             _ea_=
              function(s)
               {function _ef_(param)
                 {var
                   y=param[2],
                   x=param[1],
                   _eg_=urldecode_js_string_string(y);
                  return [0,urldecode_js_string_string(x),_eg_]}
                var index=s.indexOf(caml_call2(String$0[1],1,61).toString());
                if(caml_call2(symbol$5,index,0))
                 var _ee_=t37;
                else
                 var
                  _ed_=s.slice(index + 1 | 0),
                  _ee_=[0,s.slice(0,index),_ed_];
                return caml_call3(Optdef[7],_ee_,interrupt,_ef_)},
             _eb_=
              aux
               ([0,caml_call3(Optdef[7],arr[idx$0],interrupt,_ea_),acc],_d$_);
            return _eb_}
          catch(_ec_)
           {_ec_ = caml_wrap_exception(_ec_);
            if(_ec_ === Local_exn)
             {var idx$1=idx$0 - 1 | 0,idx$0=idx$1;continue}
            throw _ec_}}}
      return aux(0,len - 1 | 0)}
    function decode_arguments(s)
     {return decode_arguments_js_string(caml_jsbytes_of_string(s))}
    var
     url_re=
      new
       regExp_withFlags
       (caml_jsbytes_of_string
         (cst_Hh_Tt_Tt_Pp_Ss_0_9a_zA_Z_0_9a_zA_Z_0_9A_Fa_f_0_9)),
     file_re=new regExp_withFlags(caml_jsbytes_of_string(cst_Ff_Ii_Ll_Ee));
    function url_of_js_string(s)
     {function _dS_(res)
       {var
         prot_string=caml_call2(Optdef[8],res[1],interrupt),
         match=caml_js_to_byte_string(prot_string.toLowerCase());
        if(caml_string_notequal(match,cst_file$0))
         if(caml_string_notequal(match,cst_file$1))
          {if(caml_string_notequal(match,cst_http))
            if(caml_string_notequal(match,cst_http$0))
             {if(caml_string_notequal(match,cst_https))
               if(caml_string_notequal(match,cst_https$0))
                var switch$0=1,switch$1=0;
               else
                var switch$1=1;
              else
               var switch$1=1;
              if(switch$1)var ssl=1,switch$0=2}
            else
             var switch$0=0;
           else
            var switch$0=0;
           switch(switch$0)
            {case 0:var ssl=0,switch$2=1;break;
             case 1:var switch$2=0;break;
             default:var switch$2=1}
           if(switch$2)
            {var
              _d2_=function(param){return caml_jsbytes_of_string(cst$7)},
              path_str=
               urldecode_js_string_string(caml_call2(Optdef[8],res[6],_d2_)),
              _d3_=function(param){return caml_jsbytes_of_string(cst$8)},
              _d4_=
               urldecode_js_string_string(caml_call2(Optdef[8],res[10],_d3_)),
              _d5_=function(param){return caml_jsbytes_of_string(cst$9)},
              _d6_=
               decode_arguments_js_string(caml_call2(Optdef[8],res[8],_d5_)),
              _d7_=path_of_path_string(path_str),
              _d8_=function(param){return caml_jsbytes_of_string(cst$10)},
              s=caml_js_to_byte_string(caml_call2(Optdef[8],res[4],_d8_)),
              _d9_=
               caml_string_notequal(s,cst$6)?caml_int_of_string(s):ssl?443:80,
              url=
               [0,
                urldecode_js_string_string
                 (caml_call2(Optdef[8],res[2],interrupt)),
                _d9_,
                _d7_,
                path_str,
                _d6_,
                _d4_],
              _d__=ssl?[1,url]:[0,url];
             return [0,_d__]}}
        throw Not_an_http_protocol}
      function _dT_(param)
       {function _dV_(res)
         {var
           path_str=
            urldecode_js_string_string(caml_call2(Optdef[8],res[2],interrupt));
          function _dY_(param){return caml_jsbytes_of_string(cst$11)}
          var _dZ_=caml_js_to_byte_string(caml_call2(Optdef[8],res[6],_dY_));
          function _d0_(param){return caml_jsbytes_of_string(cst$12)}
          var
           _d1_=
            decode_arguments_js_string(caml_call2(Optdef[8],res[4],_d0_));
          return [0,[2,[0,path_of_path_string(path_str),path_str,_d1_,_dZ_]]]}
        function _dW_(param){return 0}
        var _dX_=file_re.exec(s);
        return caml_call3(Opt[7],_dX_,_dW_,_dV_)}
      var _dU_=url_re.exec(s);
      return caml_call3(Opt[7],_dU_,_dT_,_dS_)}
    function url_of_string(s)
     {return url_of_js_string(caml_jsbytes_of_string(s))}
    function string_of_url(param)
     {switch(param[0])
       {case 0:
         var
          match=param[1],
          frag=match[6],
          args=match[5],
          path=match[3],
          port=match[2],
          host=match[1];
         if(caml_string_notequal(frag,cst$13))
          var
           _df_=urlencode(0,frag),
           _dg_=caml_call2(Pervasives[16],cst$14,_df_);
         else
          var _dg_=cst$21;
         if(args)
          var
           _dh_=encode_arguments(args),
           _di_=caml_call2(Pervasives[16],cst$15,_dh_);
         else
          var _di_=cst$20;
         var
          _dj_=caml_call2(Pervasives[16],_di_,_dg_),
          _dk_=function(x){return urlencode(0,x)},
          _dl_=caml_call2(List[17],_dk_,path),
          _dm_=caml_call2(String$0[7],cst$16,_dl_),
          _dn_=caml_call2(Pervasives[16],_dm_,_dj_),
          _do_=caml_call2(Pervasives[16],cst$17,_dn_);
         if(80 === port)
          var _dp_=cst$18;
         else
          var
           _dt_=caml_call1(Pervasives[21],port),
           _dp_=caml_call2(Pervasives[16],cst$19,_dt_);
         var
          _dq_=caml_call2(Pervasives[16],_dp_,_do_),
          _dr_=urlencode(0,host),
          _ds_=caml_call2(Pervasives[16],_dr_,_dq_);
         return caml_call2(Pervasives[16],cst_http$1,_ds_);
        case 1:
         var
          match$0=param[1],
          frag$0=match$0[6],
          args$0=match$0[5],
          path$0=match$0[3],
          port$0=match$0[2],
          host$0=match$0[1];
         if(caml_string_notequal(frag$0,cst$22))
          var
           _du_=urlencode(0,frag$0),
           _dv_=caml_call2(Pervasives[16],cst$23,_du_);
         else
          var _dv_=cst$30;
         if(args$0)
          var
           _dw_=encode_arguments(args$0),
           _dx_=caml_call2(Pervasives[16],cst$24,_dw_);
         else
          var _dx_=cst$29;
         var
          _dy_=caml_call2(Pervasives[16],_dx_,_dv_),
          _dz_=function(x){return urlencode(0,x)},
          _dA_=caml_call2(List[17],_dz_,path$0),
          _dB_=caml_call2(String$0[7],cst$25,_dA_),
          _dC_=caml_call2(Pervasives[16],_dB_,_dy_),
          _dD_=caml_call2(Pervasives[16],cst$26,_dC_);
         if(443 === port$0)
          var _dE_=cst$27;
         else
          var
           _dI_=caml_call1(Pervasives[21],port$0),
           _dE_=caml_call2(Pervasives[16],cst$28,_dI_);
         var
          _dF_=caml_call2(Pervasives[16],_dE_,_dD_),
          _dG_=urlencode(0,host$0),
          _dH_=caml_call2(Pervasives[16],_dG_,_dF_);
         return caml_call2(Pervasives[16],cst_https$1,_dH_);
        default:
         var
          match$1=param[1],
          frag$1=match$1[4],
          args$1=match$1[3],
          path$1=match$1[1];
         if(caml_string_notequal(frag$1,cst$31))
          var
           _dJ_=urlencode(0,frag$1),
           _dK_=caml_call2(Pervasives[16],cst$32,_dJ_);
         else
          var _dK_=cst$36;
         if(args$1)
          var
           _dL_=encode_arguments(args$1),
           _dM_=caml_call2(Pervasives[16],cst$33,_dL_);
         else
          var _dM_=cst$35;
         var
          _dN_=caml_call2(Pervasives[16],_dM_,_dK_),
          _dO_=function(x){return urlencode(0,x)},
          _dP_=caml_call2(List[17],_dO_,path$1),
          _dQ_=caml_call2(String$0[7],cst$34,_dP_),
          _dR_=caml_call2(Pervasives[16],_dQ_,_dN_);
         return caml_call2(Pervasives[16],cst_file$2,_dR_)}}
    var _p_=caml_call1(Optdef[2],_g_.location);
    if(caml_call1(Optdef[5],_p_))
     var _q_=_g_.location;
    else
     var
      t29="",
      t40=function(param,_de_){return 0},
      t39=function(param,_dd_){return 0},
      t38=function(param){return 0},
      _q_=
       {"href":t29,
        "protocol":t29,
        "host":t29,
        "hostname":t29,
        "port":t29,
        "pathname":t29,
        "search":t29,
        "hash":t29,
        "origin":t37,
        "reload":caml_js_wrap_meth_callback(t38),
        "replace":caml_js_wrap_meth_callback(t39),
        "assign":caml_js_wrap_meth_callback(t40)};
    var
     host=urldecode_js_string_string(_q_.hostname),
     protocol=urldecode_js_string_string(_q_.protocol),
     _r_=0,
     port=
      function(param)
        {try
          {var _db_=[0,caml_int_of_string(caml_js_to_byte_string(_q_.port))];
           return _db_}
         catch(_dc_)
          {_dc_ = caml_wrap_exception(_dc_);
           if(_dc_[1] === Failure)return 0;
           throw _dc_}}
       (_r_),
     path_string=urldecode_js_string_string(_q_.pathname),
     path=path_of_path_string(path_string),
     _s_=_q_.search.charAt(0) === "?"?_q_.search.slice(1):_q_.search,
     arguments$0=decode_arguments_js_string(_s_);
    function get_fragment(param)
     {function _c9_(res){return caml_js_to_string(res[1])}
      function _c__(param){return cst$37}
      var _c$_=new regExp_withFlags("#(.*)"),_da_=_q_.href.match(_c$_);
      return caml_call3(Opt[7],_da_,_c__,_c9_)}
    function set_fragment(s)
     {return _q_.hash = caml_jsbytes_of_string(urlencode(0,s))}
    function get$2(param){return url_of_js_string(_q_.href)}
    function set$0(u)
     {return _q_.href = caml_jsbytes_of_string(string_of_url(u))}
    var
     as_string=urldecode_js_string_string(_q_.href),
     Js_of_ocaml_Url=
      [0,
       urldecode,
       urlencode,
       default_http_port,
       default_https_port,
       path_of_path_string,
       encode_arguments,
       decode_arguments,
       url_of_string,
       string_of_url,
       [0,
        host,
        port,
        protocol,
        path_string,
        path,
        arguments$0,
        get_fragment,
        set_fragment,
        get$2,
        set$0,
        as_string]];
    caml_register_global(1653,Js_of_ocaml_Url,"Js_of_ocaml__Url");
    var Js_of_ocaml_Lib_version=[0,s,git_version];
    caml_register_global
     (1654,Js_of_ocaml_Lib_version,"Js_of_ocaml__Lib_version");
    function update_file(name,content)
     {var oc=caml_call1(Pervasives[48],name);
      caml_call2(Pervasives[54],oc,content);
      return caml_call1(Pervasives[64],oc)}
    function set_channel_flusher(out_channel,f)
     {var
       f$0=
        caml_js_wrap_callback
         (function(s){return caml_call1(f,caml_js_to_byte_string(s))});
      return runtime.caml_ml_set_channel_output(out_channel,f$0)}
    function set_channel_filler(in_channel,f)
     {var f$0=caml_js_wrap_callback(f);
      return runtime.caml_ml_set_channel_refill(in_channel,f$0)}
    function mount(path,f)
     {return runtime.caml_mount_autoload
              (path,
               caml_js_wrap_callback
                (function(prefix,path){return caml_call2(f,prefix,path)}))}
    var unmount=runtime.caml_unmount;
    if(caml_call2(String$0[35],git_version,cst$38))
     var js_of_ocaml_version=s;
    else
     var
      _cm_=caml_call2(Pervasives[16],cst$41,git_version),
      js_of_ocaml_version=caml_call2(Pervasives[16],s,_cm_);
    var
     _t_=runtime.caml_create_file,
     _u_=runtime.caml_read_file_content,
     Js_of_ocaml_Sys_js=
      [0,
       set_channel_flusher,
       set_channel_filler,
       function(_c8_){return runtime.caml_list_mount_point(_c8_)},
       unmount,
       mount,
       _u_,
       _t_,
       update_file,
       js_of_ocaml_version];
    caml_register_global(1655,Js_of_ocaml_Sys_js,"Js_of_ocaml__Sys_js");
    function empty_resize_observer_options(param){return {}}
    var resizeObserver=Unsafe[1].ResizeObserver;
    function is_supported$0(param)
     {return caml_call1(Optdef[5],resizeObserver)}
    function observe(node,f,box,param)
     {var obs=new resizeObserver(caml_js_wrap_callback(f));
      if(box)
       {var box$0=box[1],opts={};opts.box = box$0;obs.observe(node,opts)}
      else
       obs.observe(node);
      return obs}
    var
     Js_of_ocaml_ResizeObserver=
      [0,empty_resize_observer_options,resizeObserver,is_supported$0,observe];
    caml_register_global
     (1656,Js_of_ocaml_ResizeObserver,"Js_of_ocaml__ResizeObserver");
    function empty_mutation_observer_init(param){return {}}
    var mutationObserver=Unsafe[1].MutationObserver;
    function is_supported$1(param)
     {return caml_call1(Optdef[5],mutationObserver)}
    function observe$0
     (node,
      f,
      child_list,
      attributes,
      character_data,
      subtree,
      attribute_old_value,
      character_data_old_value,
      attribute_filter,
      param)
     {function opt_iter(x,f)
       {if(x){var x$0=x[1];return caml_call1(f,x$0)}return 0}
      var obs=new mutationObserver(caml_js_wrap_callback(f)),cfg={};
      opt_iter(child_list,function(v){return cfg.childList = v});
      opt_iter(attributes,function(v){return cfg.attributes = v});
      opt_iter(character_data,function(v){return cfg.characterData = v});
      opt_iter(subtree,function(v){return cfg.subtree = v});
      opt_iter
       (attribute_old_value,function(v){return cfg.attributeOldValue = v});
      opt_iter
       (character_data_old_value,
        function(v){return cfg.characterDataOldValue = v});
      opt_iter
       (attribute_filter,
        function(l)
         {return cfg.attributeFilter
                 =
                 caml_js_from_array(caml_call1(Array[12],l))});
      obs.observe(node,cfg);
      return obs}
    var
     Js_of_ocaml_MutationObserver=
      [0,
       empty_mutation_observer_init,
       mutationObserver,
       is_supported$1,
       observe$0];
    caml_register_global
     (1657,Js_of_ocaml_MutationObserver,"Js_of_ocaml__MutationObserver");
    var obj=Unsafe[1].Object;
    function create$1(param){return new obj()}
    function add$0(t,k,v){return t[k.concat("_")] = v}
    function remove(t,k){return delete t[k.concat("_")]}
    function find(t,k){return t[k.concat("_")]}
    function keys(t)
     {var
       key_array=Unsafe[1].Object.keys(t),
       res=[0,0],
       _c4_=key_array.length - 1 | 0,
       _c3_=0;
      if(! (_c4_ < 0))
       {var i=_c3_;
        for(;;)
         {var
           _c5_=
            function(param){return caml_call1(Pervasives[2],cst_Jstable_keys)},
           key=caml_call2(Optdef[8],key_array[i],_c5_),
           _c6_=res[1];
          res[1] = [0,key.substring(0,key.length - 1 | 0),_c6_];
          var _c7_=i + 1 | 0;
          if(_c4_ !== i){var i=_c7_;continue}
          break}}
      return caml_call1(List[9],res[1])}
    var Js_of_ocaml_Jstable=[0,create$1,add$0,remove,find,keys];
    caml_register_global(1658,Js_of_ocaml_Jstable,"Js_of_ocaml__Jstable");
    var json=runtime.caml_json(0);
    function reviver(this$0,key,value)
     {return typeof value == typeof "foo"?caml_js_to_byte_string(value):value}
    var input_reviver=caml_js_wrap_meth_callback(reviver);
    function unsafe_input(s){return json.parse(s,input_reviver)}
    var mlString_constr=dummy_string.constructor;
    function output_reviver(key,value)
     {return value instanceof mlString_constr
              ?caml_jsbytes_of_string(value)
              :value}
    function output(obj){return json.stringify(obj,output_reviver)}
    var Js_of_ocaml_Json=[0,output,unsafe_input];
    caml_register_global(1659,Js_of_ocaml_Json,"Js_of_ocaml__Json");
    function string_of_name(param)
     {var _c2_=param;
      if(74 <= _c2_)
       {if(111 <= _c2_)
         switch(_c2_)
          {case 111:return cst_palevioletred;
           case 112:return cst_papayawhip;
           case 113:return cst_peachpuff;
           case 114:return cst_peru;
           case 115:return cst_pink;
           case 116:return cst_plum;
           case 117:return cst_powderblue;
           case 118:return cst_purple;
           case 119:return cst_red;
           case 120:return cst_rosybrown;
           case 121:return cst_royalblue;
           case 122:return cst_saddlebrown;
           case 123:return cst_salmon;
           case 124:return cst_sandybrown;
           case 125:return cst_seagreen;
           case 126:return cst_seashell;
           case 127:return cst_sienna;
           case 128:return cst_silver;
           case 129:return cst_skyblue;
           case 130:return cst_slateblue;
           case 131:return cst_slategray;
           case 132:return cst_slategrey;
           case 133:return cst_snow;
           case 134:return cst_springgreen;
           case 135:return cst_steelblue;
           case 136:return cst_tan;
           case 137:return cst_teal;
           case 138:return cst_thistle;
           case 139:return cst_tomato;
           case 140:return cst_turquoise;
           case 141:return cst_violet;
           case 142:return cst_wheat;
           case 143:return cst_white;
           case 144:return cst_whitesmoke;
           case 145:return cst_yellow;
           default:return cst_yellowgreen}
        switch(_c2_)
         {case 74:return cst_lightpink;
          case 75:return cst_lightsalmon;
          case 76:return cst_lightseagreen;
          case 77:return cst_lightskyblue;
          case 78:return cst_lightslategray;
          case 79:return cst_lightslategrey;
          case 80:return cst_lightsteelblue;
          case 81:return cst_lightyellow;
          case 82:return cst_lime;
          case 83:return cst_limegreen;
          case 84:return cst_linen;
          case 85:return cst_magenta;
          case 86:return cst_maroon;
          case 87:return cst_mediumaquamarine;
          case 88:return cst_mediumblue;
          case 89:return cst_mediumorchid;
          case 90:return cst_mediumpurple;
          case 91:return cst_mediumseagreen;
          case 92:return cst_mediumslateblue;
          case 93:return cst_mediumspringgreen;
          case 94:return cst_mediumturquoise;
          case 95:return cst_mediumvioletred;
          case 96:return cst_midnightblue;
          case 97:return cst_mintcream;
          case 98:return cst_mistyrose;
          case 99:return cst_moccasin;
          case 100:return cst_navajowhite;
          case 101:return cst_navy;
          case 102:return cst_oldlace;
          case 103:return cst_olive;
          case 104:return cst_olivedrab;
          case 105:return cst_orange;
          case 106:return cst_orangered;
          case 107:return cst_orchid;
          case 108:return cst_palegoldenrod;
          case 109:return cst_palegreen;
          default:return cst_paleturquoise}}
      if(37 <= _c2_)
       switch(_c2_)
        {case 37:return cst_darkslategrey;
         case 38:return cst_darkturquoise;
         case 39:return cst_darkviolet;
         case 40:return cst_deeppink;
         case 41:return cst_deepskyblue;
         case 42:return cst_dimgray;
         case 43:return cst_dimgrey;
         case 44:return cst_dodgerblue;
         case 45:return cst_firebrick;
         case 46:return cst_floralwhite;
         case 47:return cst_forestgreen;
         case 48:return cst_fuchsia;
         case 49:return cst_gainsboro;
         case 50:return cst_ghostwhite;
         case 51:return cst_gold;
         case 52:return cst_goldenrod;
         case 53:return cst_gray;
         case 54:return cst_grey;
         case 55:return cst_green;
         case 56:return cst_greenyellow;
         case 57:return cst_honeydew;
         case 58:return cst_hotpink;
         case 59:return cst_indianred;
         case 60:return cst_indigo;
         case 61:return cst_ivory;
         case 62:return cst_khaki;
         case 63:return cst_lavender;
         case 64:return cst_lavenderblush;
         case 65:return cst_lawngreen;
         case 66:return cst_lemonchiffon;
         case 67:return cst_lightblue;
         case 68:return cst_lightcoral;
         case 69:return cst_lightcyan;
         case 70:return cst_lightgoldenrodyellow;
         case 71:return cst_lightgray;
         case 72:return cst_lightgreen;
         default:return cst_lightgrey}
      switch(_c2_)
       {case 0:return cst_aliceblue;
        case 1:return cst_antiquewhite;
        case 2:return cst_aqua;
        case 3:return cst_aquamarine;
        case 4:return cst_azure;
        case 5:return cst_beige;
        case 6:return cst_bisque;
        case 7:return cst_black;
        case 8:return cst_blanchedalmond;
        case 9:return cst_blue;
        case 10:return cst_blueviolet;
        case 11:return cst_brown;
        case 12:return cst_burlywood;
        case 13:return cst_cadetblue;
        case 14:return cst_chartreuse;
        case 15:return cst_chocolate;
        case 16:return cst_coral;
        case 17:return cst_cornflowerblue;
        case 18:return cst_cornsilk;
        case 19:return cst_crimson;
        case 20:return cst_cyan;
        case 21:return cst_darkblue;
        case 22:return cst_darkcyan;
        case 23:return cst_darkgoldenrod;
        case 24:return cst_darkgray;
        case 25:return cst_darkgreen;
        case 26:return cst_darkgrey;
        case 27:return cst_darkkhaki;
        case 28:return cst_darkmagenta;
        case 29:return cst_darkolivegreen;
        case 30:return cst_darkorange;
        case 31:return cst_darkorchid;
        case 32:return cst_darkred;
        case 33:return cst_darksalmon;
        case 34:return cst_darkseagreen;
        case 35:return cst_darkslateblue;
        default:return cst_darkslategray}}
    function name_of_string(s)
     {var switch$0=caml_string_compare(s,cst_lightgrey$0);
      if(0 <= switch$0)
       {if(! (0 < switch$0))return 73;
        var switch$1=caml_string_compare(s,cst_paleturquoise$0);
        if(0 <= switch$1)
         {if(! (0 < switch$1))return 110;
          var switch$2=caml_string_compare(s,cst_skyblue$0);
          if(0 <= switch$2)
           {if(! (0 < switch$2))return 129;
            var switch$3=caml_string_compare(s,cst_thistle$0);
            if(0 <= switch$3)
             {if(! (0 < switch$3))return 138;
              if(! caml_string_notequal(s,cst_tomato$0))return 139;
              if(! caml_string_notequal(s,cst_turquoise$0))return 140;
              if(! caml_string_notequal(s,cst_violet$0))return 141;
              if(! caml_string_notequal(s,cst_wheat$0))return 142;
              if(! caml_string_notequal(s,cst_white$0))return 143;
              if(! caml_string_notequal(s,cst_whitesmoke$0))return 144;
              if(! caml_string_notequal(s,cst_yellow$0))return 145;
              if(! caml_string_notequal(s,cst_yellowgreen$0))return 146}
            else
             {if(! caml_string_notequal(s,cst_slateblue$0))return 130;
              if(! caml_string_notequal(s,cst_slategray$0))return 131;
              if(! caml_string_notequal(s,cst_slategrey$0))return 132;
              if(! caml_string_notequal(s,cst_snow$0))return 133;
              if(! caml_string_notequal(s,cst_springgreen$0))return 134;
              if(! caml_string_notequal(s,cst_steelblue$0))return 135;
              if(! caml_string_notequal(s,cst_tan$0))return 136;
              if(! caml_string_notequal(s,cst_teal$0))return 137}}
          else
           {var switch$4=caml_string_compare(s,cst_rosybrown$0);
            if(0 <= switch$4)
             {if(! (0 < switch$4))return 120;
              if(! caml_string_notequal(s,cst_royalblue$0))return 121;
              if(! caml_string_notequal(s,cst_saddlebrown$0))return 122;
              if(! caml_string_notequal(s,cst_salmon$0))return 123;
              if(! caml_string_notequal(s,cst_sandybrown$0))return 124;
              if(! caml_string_notequal(s,cst_seagreen$0))return 125;
              if(! caml_string_notequal(s,cst_seashell$0))return 126;
              if(! caml_string_notequal(s,cst_sienna$0))return 127;
              if(! caml_string_notequal(s,cst_silver$0))return 128}
            else
             {if(! caml_string_notequal(s,cst_palevioletred$0))return 111;
              if(! caml_string_notequal(s,cst_papayawhip$0))return 112;
              if(! caml_string_notequal(s,cst_peachpuff$0))return 113;
              if(! caml_string_notequal(s,cst_peru$0))return 114;
              if(! caml_string_notequal(s,cst_pink$0))return 115;
              if(! caml_string_notequal(s,cst_plum$0))return 116;
              if(! caml_string_notequal(s,cst_powderblue$0))return 117;
              if(! caml_string_notequal(s,cst_purple$0))return 118;
              if(! caml_string_notequal(s,cst_red$0))return 119}}}
        else
         {var switch$5=caml_string_compare(s,cst_mediumslateblue$0);
          if(0 <= switch$5)
           {if(! (0 < switch$5))return 92;
            var switch$6=caml_string_compare(s,cst_navy$0);
            if(0 <= switch$6)
             {if(! (0 < switch$6))return 101;
              if(! caml_string_notequal(s,cst_oldlace$0))return 102;
              if(! caml_string_notequal(s,cst_olive$0))return 103;
              if(! caml_string_notequal(s,cst_olivedrab$0))return 104;
              if(! caml_string_notequal(s,cst_orange$0))return 105;
              if(! caml_string_notequal(s,cst_orangered$0))return 106;
              if(! caml_string_notequal(s,cst_orchid$0))return 107;
              if(! caml_string_notequal(s,cst_palegoldenrod$0))return 108;
              if(! caml_string_notequal(s,cst_palegreen$0))return 109}
            else
             {if(! caml_string_notequal(s,cst_mediumspringgreen$0))return 93;
              if(! caml_string_notequal(s,cst_mediumturquoise$0))return 94;
              if(! caml_string_notequal(s,cst_mediumvioletred$0))return 95;
              if(! caml_string_notequal(s,cst_midnightblue$0))return 96;
              if(! caml_string_notequal(s,cst_mintcream$0))return 97;
              if(! caml_string_notequal(s,cst_mistyrose$0))return 98;
              if(! caml_string_notequal(s,cst_moccasin$0))return 99;
              if(! caml_string_notequal(s,cst_navajowhite$0))return 100}}
          else
           {var switch$7=caml_string_compare(s,cst_limegreen$0);
            if(0 <= switch$7)
             {if(! (0 < switch$7))return 83;
              if(! caml_string_notequal(s,cst_linen$0))return 84;
              if(! caml_string_notequal(s,cst_magenta$0))return 85;
              if(! caml_string_notequal(s,cst_maroon$0))return 86;
              if(! caml_string_notequal(s,cst_mediumaquamarine$0))return 87;
              if(! caml_string_notequal(s,cst_mediumblue$0))return 88;
              if(! caml_string_notequal(s,cst_mediumorchid$0))return 89;
              if(! caml_string_notequal(s,cst_mediumpurple$0))return 90;
              if(! caml_string_notequal(s,cst_mediumseagreen$0))return 91}
            else
             {if(! caml_string_notequal(s,cst_lightpink$0))return 74;
              if(! caml_string_notequal(s,cst_lightsalmon$0))return 75;
              if(! caml_string_notequal(s,cst_lightseagreen$0))return 76;
              if(! caml_string_notequal(s,cst_lightskyblue$0))return 77;
              if(! caml_string_notequal(s,cst_lightslategray$0))return 78;
              if(! caml_string_notequal(s,cst_lightslategrey$0))return 79;
              if(! caml_string_notequal(s,cst_lightsteelblue$0))return 80;
              if(! caml_string_notequal(s,cst_lightyellow$0))return 81;
              if(! caml_string_notequal(s,cst_lime$0))return 82}}}}
      else
       {var switch$8=caml_string_compare(s,cst_darkslategray$0);
        if(0 <= switch$8)
         {if(! (0 < switch$8))return 36;
          var switch$9=caml_string_compare(s,cst_greenyellow$0);
          if(0 <= switch$9)
           {if(! (0 < switch$9))return 56;
            var switch$10=caml_string_compare(s,cst_lavenderblush$0);
            if(0 <= switch$10)
             {if(! (0 < switch$10))return 64;
              if(! caml_string_notequal(s,cst_lawngreen$0))return 65;
              if(! caml_string_notequal(s,cst_lemonchiffon$0))return 66;
              if(! caml_string_notequal(s,cst_lightblue$0))return 67;
              if(! caml_string_notequal(s,cst_lightcoral$0))return 68;
              if(! caml_string_notequal(s,cst_lightcyan$0))return 69;
              if(! caml_string_notequal(s,cst_lightgoldenrodyellow$0))
               return 70;
              if(! caml_string_notequal(s,cst_lightgray$0))return 71;
              if(! caml_string_notequal(s,cst_lightgreen$0))return 72}
            else
             {if(! caml_string_notequal(s,cst_grey$0))return 54;
              if(! caml_string_notequal(s,cst_honeydew$0))return 57;
              if(! caml_string_notequal(s,cst_hotpink$0))return 58;
              if(! caml_string_notequal(s,cst_indianred$0))return 59;
              if(! caml_string_notequal(s,cst_indigo$0))return 60;
              if(! caml_string_notequal(s,cst_ivory$0))return 61;
              if(! caml_string_notequal(s,cst_khaki$0))return 62;
              if(! caml_string_notequal(s,cst_lavender$0))return 63}}
          else
           {var switch$11=caml_string_compare(s,cst_floralwhite$0);
            if(0 <= switch$11)
             {if(! (0 < switch$11))return 46;
              if(! caml_string_notequal(s,cst_forestgreen$0))return 47;
              if(! caml_string_notequal(s,cst_fuchsia$0))return 48;
              if(! caml_string_notequal(s,cst_gainsboro$0))return 49;
              if(! caml_string_notequal(s,cst_ghostwhite$0))return 50;
              if(! caml_string_notequal(s,cst_gold$0))return 51;
              if(! caml_string_notequal(s,cst_goldenrod$0))return 52;
              if(! caml_string_notequal(s,cst_gray$0))return 53;
              if(! caml_string_notequal(s,cst_green$0))return 55}
            else
             {if(! caml_string_notequal(s,cst_darkslategrey$0))return 37;
              if(! caml_string_notequal(s,cst_darkturquoise$0))return 38;
              if(! caml_string_notequal(s,cst_darkviolet$0))return 39;
              if(! caml_string_notequal(s,cst_deeppink$0))return 40;
              if(! caml_string_notequal(s,cst_deepskyblue$0))return 41;
              if(! caml_string_notequal(s,cst_dimgray$0))return 42;
              if(! caml_string_notequal(s,cst_dimgrey$0))return 43;
              if(! caml_string_notequal(s,cst_dodgerblue$0))return 44;
              if(! caml_string_notequal(s,cst_firebrick$0))return 45}}}
        else
         {var switch$12=caml_string_compare(s,cst_cornsilk$0);
          if(0 <= switch$12)
           {if(! (0 < switch$12))return 18;
            var switch$13=caml_string_compare(s,cst_darkkhaki$0);
            if(0 <= switch$13)
             {if(! (0 < switch$13))return 27;
              if(! caml_string_notequal(s,cst_darkmagenta$0))return 28;
              if(! caml_string_notequal(s,cst_darkolivegreen$0))return 29;
              if(! caml_string_notequal(s,cst_darkorange$0))return 30;
              if(! caml_string_notequal(s,cst_darkorchid$0))return 31;
              if(! caml_string_notequal(s,cst_darkred$0))return 32;
              if(! caml_string_notequal(s,cst_darksalmon$0))return 33;
              if(! caml_string_notequal(s,cst_darkseagreen$0))return 34;
              if(! caml_string_notequal(s,cst_darkslateblue$0))return 35}
            else
             {if(! caml_string_notequal(s,cst_crimson$0))return 19;
              if(! caml_string_notequal(s,cst_cyan$0))return 20;
              if(! caml_string_notequal(s,cst_darkblue$0))return 21;
              if(! caml_string_notequal(s,cst_darkcyan$0))return 22;
              if(! caml_string_notequal(s,cst_darkgoldenrod$0))return 23;
              if(! caml_string_notequal(s,cst_darkgray$0))return 24;
              if(! caml_string_notequal(s,cst_darkgreen$0))return 25;
              if(! caml_string_notequal(s,cst_darkgrey$0))return 26}}
          else
           {var switch$14=caml_string_compare(s,cst_blue$0);
            if(0 <= switch$14)
             {if(! (0 < switch$14))return 9;
              if(! caml_string_notequal(s,cst_blueviolet$0))return 10;
              if(! caml_string_notequal(s,cst_brown$0))return 11;
              if(! caml_string_notequal(s,cst_burlywood$0))return 12;
              if(! caml_string_notequal(s,cst_cadetblue$0))return 13;
              if(! caml_string_notequal(s,cst_chartreuse$0))return 14;
              if(! caml_string_notequal(s,cst_chocolate$0))return 15;
              if(! caml_string_notequal(s,cst_coral$0))return 16;
              if(! caml_string_notequal(s,cst_cornflowerblue$0))return 17}
            else
             {if(! caml_string_notequal(s,cst_aliceblue$0))return 0;
              if(! caml_string_notequal(s,cst_antiquewhite$0))return 1;
              if(! caml_string_notequal(s,cst_aqua$0))return 2;
              if(! caml_string_notequal(s,cst_aquamarine$0))return 3;
              if(! caml_string_notequal(s,cst_azure$0))return 4;
              if(! caml_string_notequal(s,cst_beige$0))return 5;
              if(! caml_string_notequal(s,cst_bisque$0))return 6;
              if(! caml_string_notequal(s,cst_black$0))return 7;
              if(! caml_string_notequal(s,cst_blanchedalmond$0))return 8}}}}
      throw [0,
             Invalid_argument,
             caml_call2(Pervasives[16],s,cst_is_not_a_valid_color_name)]}
    function rgb_of_name(param)
     {var _c1_=param;
      if(74 <= _c1_)
       {if(111 <= _c1_)
         switch(_c1_)
          {case 111:return _bo_;
           case 112:return _bp_;
           case 113:return _bq_;
           case 114:return _br_;
           case 115:return _bs_;
           case 116:return _bt_;
           case 117:return _bu_;
           case 118:return _bv_;
           case 119:return _bw_;
           case 120:return _bx_;
           case 121:return _by_;
           case 122:return _bz_;
           case 123:return _bA_;
           case 124:return _bB_;
           case 125:return _bC_;
           case 126:return _bD_;
           case 127:return _bE_;
           case 128:return _bF_;
           case 129:return _bG_;
           case 130:return _bH_;
           case 131:return _bI_;
           case 132:return _bJ_;
           case 133:return _bK_;
           case 134:return _bL_;
           case 135:return _bM_;
           case 136:return _bN_;
           case 137:return _bO_;
           case 138:return _bP_;
           case 139:return _bQ_;
           case 140:return _bR_;
           case 141:return _bS_;
           case 142:return _bT_;
           case 143:return _bU_;
           case 144:return _bV_;
           case 145:return _bW_;
           default:return _bX_}
        switch(_c1_)
         {case 74:return _aP_;
          case 75:return _aQ_;
          case 76:return _aR_;
          case 77:return _aS_;
          case 78:return _aT_;
          case 79:return _aU_;
          case 80:return _aV_;
          case 81:return _aW_;
          case 82:return _aX_;
          case 83:return _aY_;
          case 84:return _aZ_;
          case 85:return _a0_;
          case 86:return _a1_;
          case 87:return _a2_;
          case 88:return _a3_;
          case 89:return _a4_;
          case 90:return _a5_;
          case 91:return _a6_;
          case 92:return _a7_;
          case 93:return _a8_;
          case 94:return _a9_;
          case 95:return _a__;
          case 96:return _a$_;
          case 97:return _ba_;
          case 98:return _bb_;
          case 99:return _bc_;
          case 100:return _bd_;
          case 101:return _be_;
          case 102:return _bf_;
          case 103:return _bg_;
          case 104:return _bh_;
          case 105:return _bi_;
          case 106:return _bj_;
          case 107:return _bk_;
          case 108:return _bl_;
          case 109:return _bm_;
          default:return _bn_}}
      if(37 <= _c1_)
       switch(_c1_)
        {case 37:return _ae_;
         case 38:return _af_;
         case 39:return _ag_;
         case 40:return _ah_;
         case 41:return _ai_;
         case 42:return _aj_;
         case 43:return _ak_;
         case 44:return _al_;
         case 45:return _am_;
         case 46:return _an_;
         case 47:return _ao_;
         case 48:return _ap_;
         case 49:return _aq_;
         case 50:return _ar_;
         case 51:return _as_;
         case 52:return _at_;
         case 53:return _au_;
         case 54:return _av_;
         case 55:return _aw_;
         case 56:return _ax_;
         case 57:return _ay_;
         case 58:return _az_;
         case 59:return _aA_;
         case 60:return _aB_;
         case 61:return _aC_;
         case 62:return _aD_;
         case 63:return _aE_;
         case 64:return _aF_;
         case 65:return _aG_;
         case 66:return _aH_;
         case 67:return _aI_;
         case 68:return _aJ_;
         case 69:return _aK_;
         case 70:return _aL_;
         case 71:return _aM_;
         case 72:return _aN_;
         default:return _aO_}
      switch(_c1_)
       {case 0:return _v_;
        case 1:return _w_;
        case 2:return _x_;
        case 3:return _y_;
        case 4:return _z_;
        case 5:return _A_;
        case 6:return _B_;
        case 7:return _C_;
        case 8:return _D_;
        case 9:return _E_;
        case 10:return _F_;
        case 11:return _G_;
        case 12:return _H_;
        case 13:return _I_;
        case 14:return _J_;
        case 15:return _K_;
        case 16:return _L_;
        case 17:return _M_;
        case 18:return _N_;
        case 19:return _O_;
        case 20:return _P_;
        case 21:return _Q_;
        case 22:return _R_;
        case 23:return _S_;
        case 24:return _T_;
        case 25:return _U_;
        case 26:return _V_;
        case 27:return _W_;
        case 28:return _X_;
        case 29:return _Y_;
        case 30:return _Z_;
        case 31:return ___;
        case 32:return _$_;
        case 33:return _aa_;
        case 34:return _ab_;
        case 35:return _ac_;
        default:return _ad_}}
    function rgb(a,r,g,b)
     {if(a){var a$0=a[1];return [3,[0,r,g,b,a$0]]}return [1,[0,r,g,b]]}
    function hsl(a,h,s,l)
     {if(a){var a$0=a[1];return [6,[0,h,s,l,a$0]]}return [5,[0,h,s,l]]}
    function string_of_t(param)
     {switch(param[0])
       {case 0:var n=param[1];return string_of_name(n);
        case 1:
         var match=param[1],b=match[3],g=match[2],r=match[1];
         return caml_call4(Printf[4],_bY_,r,g,b);
        case 2:
         var match$0=param[1],b$0=match$0[3],g$0=match$0[2],r$0=match$0[1];
         return caml_call4(Printf[4],_bZ_,r$0,g$0,b$0);
        case 3:
         var
          match$1=param[1],
          a=match$1[4],
          b$1=match$1[3],
          g$1=match$1[2],
          r$1=match$1[1];
         return caml_call5(Printf[4],_b0_,r$1,g$1,b$1,a);
        case 4:
         var
          match$2=param[1],
          a$0=match$2[4],
          b$2=match$2[3],
          g$2=match$2[2],
          r$2=match$2[1];
         return caml_call5(Printf[4],_b1_,r$2,g$2,b$2,a$0);
        case 5:
         var match$3=param[1],l=match$3[3],s=match$3[2],h=match$3[1];
         return caml_call4(Printf[4],_b2_,h,s,l);
        default:
         var
          match$4=param[1],
          a$1=match$4[4],
          l$0=match$4[3],
          s$0=match$4[2],
          h$0=match$4[1];
         return caml_call5(Printf[4],_b3_,h$0,s$0,l$0,a$1)}}
    function hex_of_rgb(param)
     {var blue=param[3],green=param[2],red=param[1];
      function in_range(i)
       {var
         _cY_=caml_call2(symbol$5,i,0),
         _cZ_=_cY_ || caml_call2(symbol$9,i,255);
        if(_cZ_)
         {var _c0_=caml_call1(Pervasives[21],i);
          throw [0,
                 Invalid_argument,
                 caml_call2(Pervasives[16],_c0_,cst_is_out_of_valid_range)]}
        return _cZ_}
      in_range(red);
      in_range(green);
      in_range(blue);
      return caml_call4(Printf[4],_b4_,red,green,blue)}
    function js_t_of_js_string(s)
     {var
       rgb_re=
        new regExp_withFlags(caml_jsbytes_of_string(cst_rgb_s_d_s_d_s_d)),
       rgb_pct_re=
        new regExp_withFlags(caml_jsbytes_of_string(cst_rgb_s_d_s_d_s_d$0)),
       rgba_re=
        new regExp_withFlags(caml_jsbytes_of_string(cst_rgba_s_d_s_d_s_d_d_d)),
       rgba_pct_re=
        new
         regExp_withFlags
         (caml_jsbytes_of_string(cst_rgba_s_d_s_d_s_d_d_d$0)),
       hsl_re=
        new regExp_withFlags(caml_jsbytes_of_string(cst_hsl_s_d_s_d_s_d)),
       hsla_re=
        new regExp_withFlags(caml_jsbytes_of_string(cst_hsla_s_d_s_d_s_d_d_d));
      if(! (rgb_re.test(s) | 0))
       if(! (rgba_re.test(s) | 0))
        if(! (rgb_pct_re.test(s) | 0))
         if(! (rgba_pct_re.test(s) | 0))
          if(! (hsl_re.test(s) | 0))
           if(! (hsla_re.test(s) | 0))
            {if(caml_call2(List[31],caml_js_to_string(s),_b5_))return s;
             throw [0,
                    Invalid_argument,
                    caml_call2
                     (Pervasives[16],
                      caml_js_to_string(s),
                      cst_is_not_a_valid_color)]}
      return s}
    function js(c)
     {if(0 === c[0]){var n=c[1];return string_of_name(n).toString()}
      return string_of_t(c).toString()}
    function ml(c)
     {var s=caml_js_to_string(c);
      try
       {var _cO_=[0,name_of_string(s)];return _cO_}
      catch(_cP_)
       {_cP_ = caml_wrap_exception(_cP_);
        if(_cP_[1] === Invalid_argument)
         {var
           fail=
            function(param)
             {throw [0,
                     Invalid_argument,
                     caml_call2(Pervasives[16],s,cst_is_not_a_valid_color$0)]},
           re_rgb=regexp(cst_rgba_d_d_d_d_d),
           re_rgb_pct=regexp(cst_rgba_d_d_d_d_d$0),
           re_hsl=regexp(cst_hsla_d_d_d_d_d),
           i_of_s_o=
            function(param)
             {if(param)
               {var i=param[1];
                try
                 {var _cW_=caml_int_of_string(i);return _cW_}
                catch(_cX_)
                 {_cX_ = caml_wrap_exception(_cX_);
                  if(_cX_[1] === Invalid_argument)
                   var s=_cX_[2];
                  else
                   {if(_cX_[1] !== Failure)throw _cX_;var s=_cX_[2]}
                  var
                   _cU_=caml_call2(Pervasives[16],cst$39,s),
                   _cV_=caml_call2(Pervasives[16],i,_cU_);
                  throw [0,
                         Invalid_argument,
                         caml_call2(Pervasives[16],cst_color_conversion_error,_cV_)]}}
              return fail(0)},
           f_of_s=
            function(f)
             {try
               {var _cS_=caml_float_of_string(f);return _cS_}
              catch(_cT_)
               {_cT_ = caml_wrap_exception(_cT_);
                if(_cT_[1] === Invalid_argument)
                 var s=_cT_[2];
                else
                 {if(_cT_[1] !== Failure)throw _cT_;var s=_cT_[2]}
                var
                 _cQ_=caml_call2(Pervasives[16],cst$40,s),
                 _cR_=caml_call2(Pervasives[16],f,_cQ_);
                throw [0,
                       Invalid_argument,
                       caml_call2(Pervasives[16],cst_color_conversion_error$0,_cR_)]}},
           match=string_match(re_rgb,s,0);
          if(match)
           {var
             r=match[1],
             red=matched_group(r,2),
             green=matched_group(r,3),
             blue=matched_group(r,4),
             alpha=matched_group(r,5),
             match$0=matched_group(r,1);
            if(match$0)
             {var _cw_=match$0[1];
              if(! caml_string_notequal(_cw_,cst_rgb))
               {if(alpha)return fail(0);
                var _cA_=i_of_s_o(blue),_cB_=i_of_s_o(green);
                return [1,[0,i_of_s_o(red),_cB_,_cA_]]}
              if(! caml_string_notequal(_cw_,cst_rgba))
               {if(alpha)
                 {var
                   a=alpha[1],
                   _cx_=f_of_s(a),
                   _cy_=i_of_s_o(blue),
                   _cz_=i_of_s_o(green);
                  return [3,[0,i_of_s_o(red),_cz_,_cy_,_cx_]]}
                return fail(0)}}
            return fail(0)}
          var match$1=string_match(re_rgb_pct,s,0);
          if(match$1)
           {var
             r$0=match$1[1],
             red$0=matched_group(r$0,2),
             green$0=matched_group(r$0,3),
             blue$0=matched_group(r$0,4),
             alpha$0=matched_group(r$0,5),
             match$2=matched_group(r$0,1);
            if(match$2)
             {var _cC_=match$2[1];
              if(! caml_string_notequal(_cC_,cst_rgb$0))
               {if(alpha$0)return fail(0);
                var _cG_=i_of_s_o(blue$0),_cH_=i_of_s_o(green$0);
                return [2,[0,i_of_s_o(red$0),_cH_,_cG_]]}
              if(! caml_string_notequal(_cC_,cst_rgba$0))
               {if(alpha$0)
                 {var
                   a$0=alpha$0[1],
                   _cD_=f_of_s(a$0),
                   _cE_=i_of_s_o(blue$0),
                   _cF_=i_of_s_o(green$0);
                  return [4,[0,i_of_s_o(red$0),_cF_,_cE_,_cD_]]}
                return fail(0)}}
            return fail(0)}
          var match$3=string_match(re_hsl,s,0);
          if(match$3)
           {var
             r$1=match$3[1],
             red$1=matched_group(r$1,2),
             green$1=matched_group(r$1,3),
             blue$1=matched_group(r$1,4),
             alpha$1=matched_group(r$1,5),
             match$4=matched_group(r$1,1);
            if(match$4)
             {var _cI_=match$4[1];
              if(! caml_string_notequal(_cI_,cst_hsl))
               {if(alpha$1)return fail(0);
                var _cM_=i_of_s_o(blue$1),_cN_=i_of_s_o(green$1);
                return [5,[0,i_of_s_o(red$1),_cN_,_cM_]]}
              if(! caml_string_notequal(_cI_,cst_hsla))
               {if(alpha$1)
                 {var
                   a$1=alpha$1[1],
                   _cJ_=f_of_s(a$1),
                   _cK_=i_of_s_o(blue$1),
                   _cL_=i_of_s_o(green$1);
                  return [6,[0,i_of_s_o(red$1),_cL_,_cK_,_cJ_]]}
                return fail(0)}}
            return fail(0)}
          return fail(0)}
        throw _cP_}}
    function string_of_t$0(param)
     {if(typeof param === "number")
       return cst_0;
      else
       switch(param[0])
        {case 0:var f=param[1];return caml_call3(Printf[4],_b6_,f,cst_em$0);
         case 1:var f$0=param[1];return caml_call3(Printf[4],_b7_,f$0,cst_ex);
         case 2:var f$1=param[1];return caml_call3(Printf[4],_b8_,f$1,cst_px);
         case 3:var f$2=param[1];return caml_call3(Printf[4],_b9_,f$2,cst_gd);
         case 4:
          var f$3=param[1];return caml_call3(Printf[4],_b__,f$3,cst_rem);
         case 5:var f$4=param[1];return caml_call3(Printf[4],_b$_,f$4,cst_vw);
         case 6:var f$5=param[1];return caml_call3(Printf[4],_ca_,f$5,cst_vh);
         case 7:var f$6=param[1];return caml_call3(Printf[4],_cb_,f$6,cst_vm);
         case 8:var f$7=param[1];return caml_call3(Printf[4],_cc_,f$7,cst_ch);
         case 9:var f$8=param[1];return caml_call3(Printf[4],_cd_,f$8,cst_mm);
         case 10:
          var f$9=param[1];return caml_call3(Printf[4],_ce_,f$9,cst_cm);
         case 11:
          var f$10=param[1];return caml_call3(Printf[4],_cf_,f$10,cst_in);
         case 12:
          var f$11=param[1];return caml_call3(Printf[4],_cg_,f$11,cst_pt);
         default:
          var f$12=param[1];return caml_call3(Printf[4],_ch_,f$12,cst_pc)}}
    function js$0(t){return string_of_t$0(t).toString()}
    function ml$0(t)
     {var s=caml_js_to_string(t);
      if(caml_call2(String$0[35],s,cst_0$0))return 0;
      function fail(param)
       {throw [0,
               Invalid_argument,
               caml_call2(Pervasives[16],s,cst_is_not_a_valid_length)]}
      var re=regexp(cst_d_d_s_S),match=string_match(re,s,0);
      if(match)
       {var r=match[1],match$0=matched_group(r,1);
        if(match$0)
         {var f=match$0[1];
          try
           {var _cu_=caml_float_of_string(f)}
          catch(exn)
           {exn = caml_wrap_exception(exn);
            if(exn[1] === Invalid_argument)
             {var s$0=exn[2];
              throw [0,
                     Invalid_argument,
                     caml_call2(Pervasives[16],cst_length_conversion_error,s$0)]}
            throw exn}
          var f$0=_cu_}
        else
         var f$0=fail(0);
        var match$1=matched_group(r,2);
        if(match$1)
         {var _cv_=match$1[1],switch$0=caml_string_compare(_cv_,cst_pc$0);
          if(0 <= switch$0)
           {if(! (0 < switch$0))return [13,f$0];
            if(! caml_string_notequal(_cv_,cst_pt$0))return [12,f$0];
            if(! caml_string_notequal(_cv_,cst_px$0))return [2,f$0];
            if(! caml_string_notequal(_cv_,cst_rem$0))return [4,f$0];
            if(! caml_string_notequal(_cv_,cst_vh$0))return [6,f$0];
            if(! caml_string_notequal(_cv_,cst_vm$0))return [7,f$0];
            if(! caml_string_notequal(_cv_,cst_vw$0))return [5,f$0]}
          else
           {if(! caml_string_notequal(_cv_,cst_ch$0))return [8,f$0];
            if(! caml_string_notequal(_cv_,cst_cm$0))return [10,f$0];
            if(! caml_string_notequal(_cv_,cst_em$1))return [0,f$0];
            if(! caml_string_notequal(_cv_,cst_ex$0))return [1,f$0];
            if(! caml_string_notequal(_cv_,cst_gd$0))return [3,f$0];
            if(! caml_string_notequal(_cv_,cst_in$0))return [11,f$0];
            if(! caml_string_notequal(_cv_,cst_mm$0))return [9,f$0]}
          return fail(0)}
        return fail(0)}
      return fail(0)}
    var Length=[0,string_of_t$0,js$0,ml$0];
    function string_of_t$1(param)
     {switch(param[0])
       {case 0:var f=param[1];return caml_call3(Printf[4],_ci_,f,cst_deg);
        case 1:
         var f$0=param[1];return caml_call3(Printf[4],_cj_,f$0,cst_grad);
        case 2:var f$1=param[1];return caml_call3(Printf[4],_ck_,f$1,cst_rad);
        default:
         var f$2=param[1];return caml_call3(Printf[4],_cl_,f$2,cst_turns)}}
    function js$1(t){return string_of_t$1(t).toString()}
    function ml$1(j)
     {var s=caml_js_to_string(j),re=regexp(cst_d_d_deg_grad_rad_turns);
      function fail(param)
       {throw [0,
               Invalid_argument,
               caml_call2(Pervasives[16],s,cst_is_not_a_valid_length$0)]}
      var match=string_match(re,s,0);
      if(match)
       {var r=match[1],match$0=matched_group(r,1);
        if(match$0)
         {var f=match$0[1];
          try
           {var _cs_=caml_float_of_string(f)}
          catch(exn)
           {exn = caml_wrap_exception(exn);
            if(exn[1] === Invalid_argument)
             {var s$0=exn[2];
              throw [0,
                     Invalid_argument,
                     caml_call2(Pervasives[16],cst_length_conversion_error$0,s$0)]}
            throw exn}
          var f$0=_cs_}
        else
         var f$0=fail(0);
        var match$1=matched_group(r,2);
        if(match$1)
         {var _ct_=match$1[1];
          if(! caml_string_notequal(_ct_,cst_deg$0))return [0,f$0];
          if(! caml_string_notequal(_ct_,cst_grad$0))return [1,f$0];
          if(! caml_string_notequal(_ct_,cst_rad$0))return [2,f$0];
          if(! caml_string_notequal(_ct_,cst_turns$0))return [3,f$0]}
        return fail(0)}
      return fail(0)}
    var
     Angle=[0,string_of_t$1,js$1,ml$1],
     Js_of_ocaml_CSS=
      [0,
       [0,
        string_of_name,
        rgb_of_name,
        hex_of_rgb,
        rgb,
        hsl,
        string_of_t,
        js,
        ml,
        js_t_of_js_string],
       Length,
       Angle];
    caml_register_global(1661,Js_of_ocaml_CSS,"Js_of_ocaml__CSS");
    function listen(opt,target,typ,cb)
     {if(opt)var sth=opt[1],capture=sth;else var capture=0;
      var _cr_=! ! capture;
      return addEventListener
              (target,
               typ,
               full_handler(function(n,e){return ! ! caml_call2(cb,n,e)}),
               _cr_)}
    var Js_of_ocaml_Dom_events=[0,Event$0,listen,removeEventListener];
    caml_register_global
     (1662,Js_of_ocaml_Dom_events,"Js_of_ocaml__Dom_events");
    var
     xmlns="http://www.w3.org/2000/svg",
     SVGError=[248,cst_Js_of_ocaml_Dom_svg_SVGError,caml_fresh_oo_id(0)];
    function createElement$0(doc,name)
     {return doc.createElementNS(xmlns,name.toString())}
    function unsafeCreateElement$0(doc,name){return createElement$0(doc,name)}
    function createA$0(doc){return unsafeCreateElement$0(doc,cst_a$2)}
    function createAltGlyph(doc)
     {return unsafeCreateElement$0(doc,cst_altglyph)}
    function createAltGlyphDef(doc)
     {return unsafeCreateElement$0(doc,cst_altglyphdef)}
    function createAltGlyphItem(doc)
     {return unsafeCreateElement$0(doc,cst_altglyphitem)}
    function createAnimate(doc){return unsafeCreateElement$0(doc,cst_animate)}
    function createAnimateColor(doc)
     {return unsafeCreateElement$0(doc,cst_animatecolor)}
    function createAnimateMotion(doc)
     {return unsafeCreateElement$0(doc,cst_animatemotion)}
    function createAnimateTransform(doc)
     {return unsafeCreateElement$0(doc,cst_animatetransform)}
    function createCircle(doc){return unsafeCreateElement$0(doc,cst_circle)}
    function createClipPath(doc)
     {return unsafeCreateElement$0(doc,cst_clippath)}
    function createCursor(doc){return unsafeCreateElement$0(doc,cst_cursor)}
    function createDefs(doc){return unsafeCreateElement$0(doc,cst_defs)}
    function createDesc(doc){return unsafeCreateElement$0(doc,cst_desc)}
    function createEllipse(doc){return unsafeCreateElement$0(doc,cst_ellipse)}
    function createFilter(doc){return unsafeCreateElement$0(doc,cst_filter)}
    function createFont(doc){return unsafeCreateElement$0(doc,cst_font)}
    function createFontFace(doc)
     {return unsafeCreateElement$0(doc,cst_font_face)}
    function createFontFaceFormat(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_format)}
    function createFontFaceName(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_name)}
    function createFontFaceSrc(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_src)}
    function createFontFaceUri(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_uri)}
    function createForeignObject(doc)
     {return unsafeCreateElement$0(doc,cst_foreignObject)}
    function createG(doc){return unsafeCreateElement$0(doc,cst_g$0)}
    function createGlyph(doc){return unsafeCreateElement$0(doc,cst_glyph)}
    function createGlyphRef(doc)
     {return unsafeCreateElement$0(doc,cst_glyphref)}
    function createhkern(doc){return unsafeCreateElement$0(doc,cst_hkern)}
    function createImage(doc){return unsafeCreateElement$0(doc,cst_image)}
    function createLineElement(doc)
     {return unsafeCreateElement$0(doc,cst_line)}
    function createLinearElement(doc)
     {return unsafeCreateElement$0(doc,cst_lineargradient)}
    function createMask(doc){return unsafeCreateElement$0(doc,cst_mask)}
    function createMetaData(doc)
     {return unsafeCreateElement$0(doc,cst_metadata)}
    function createMissingGlyph(doc)
     {return unsafeCreateElement$0(doc,cst_missing_glyph)}
    function createMPath(doc){return unsafeCreateElement$0(doc,cst_mpath)}
    function createPath(doc){return unsafeCreateElement$0(doc,cst_path)}
    function createPattern(doc){return unsafeCreateElement$0(doc,cst_pattern)}
    function createPolygon(doc){return unsafeCreateElement$0(doc,cst_polygon)}
    function createPolyline(doc)
     {return unsafeCreateElement$0(doc,cst_polyline)}
    function createRadialgradient(doc)
     {return unsafeCreateElement$0(doc,cst_radialgradient)}
    function createRect(doc){return unsafeCreateElement$0(doc,cst_rect)}
    function createScript$0(doc)
     {return unsafeCreateElement$0(doc,cst_script$2)}
    function createSet(doc){return unsafeCreateElement$0(doc,cst_set)}
    function createStop(doc){return unsafeCreateElement$0(doc,cst_stop)}
    function createStyle$0(doc){return unsafeCreateElement$0(doc,cst_style$2)}
    function createSvg(doc){return unsafeCreateElement$0(doc,cst_svg)}
    function createSwitch(doc){return unsafeCreateElement$0(doc,cst_switch)}
    function createSymbol(doc){return unsafeCreateElement$0(doc,cst_symbol)}
    function createTextElement(doc)
     {return unsafeCreateElement$0(doc,cst_text$0)}
    function createTextpath(doc)
     {return unsafeCreateElement$0(doc,cst_textpath)}
    function createTitle$0(doc){return unsafeCreateElement$0(doc,cst_title$2)}
    function createTref(doc){return unsafeCreateElement$0(doc,cst_tref)}
    function createTspan(doc){return unsafeCreateElement$0(doc,cst_tspan)}
    function createUse(doc){return unsafeCreateElement$0(doc,cst_use)}
    function createView(doc){return unsafeCreateElement$0(doc,cst_view)}
    function createvkern(doc){return unsafeCreateElement$0(doc,cst_vkern)}
    var svg_element=Unsafe[1].SVGElement,document$1=Unsafe[1].document;
    function getElementById$0(id)
     {function _co_(e){if(e instanceof svg_element)return e;throw Not_found}
      function _cp_(param){throw Not_found}
      var _cq_=Unsafe[1].document.getElementById(id.toString());
      return caml_call3(Opt[7],_cq_,_cp_,_co_)}
    function element$2(e){return e instanceof svg_element?e:no_handler}
    function unsafeCoerce$0(e,tag)
     {var _cn_=tag.toString();
      return e.tagName.toLowerCase() === _cn_?e:no_handler}
    function a$0(e){return unsafeCoerce$0(e,cst_a$3)}
    function altGlyph(e){return unsafeCoerce$0(e,cst_altglyph$0)}
    function altGlyphDef(e){return unsafeCoerce$0(e,cst_altglyphdef$0)}
    function altGlyphItem(e){return unsafeCoerce$0(e,cst_altglyphitem$0)}
    function animate(e){return unsafeCoerce$0(e,cst_animate$0)}
    function animateColor(e){return unsafeCoerce$0(e,cst_animatecolor$0)}
    function animateMotion(e){return unsafeCoerce$0(e,cst_animatemotion$0)}
    function animateTransform(e)
     {return unsafeCoerce$0(e,cst_animatetransform$0)}
    function circle(e){return unsafeCoerce$0(e,cst_circle$0)}
    function clipPath(e){return unsafeCoerce$0(e,cst_clippath$0)}
    function cursor(e){return unsafeCoerce$0(e,cst_cursor$0)}
    function defs(e){return unsafeCoerce$0(e,cst_defs$0)}
    function desc(e){return unsafeCoerce$0(e,cst_desc$0)}
    function ellipse(e){return unsafeCoerce$0(e,cst_ellipse$0)}
    function filter(e){return unsafeCoerce$0(e,cst_filter$0)}
    function font(e){return unsafeCoerce$0(e,cst_font$0)}
    function fontFace(e){return unsafeCoerce$0(e,cst_font_face$0)}
    function fontFaceFormat(e)
     {return unsafeCoerce$0(e,cst_font_face_format$0)}
    function fontFaceName(e){return unsafeCoerce$0(e,cst_font_face_name$0)}
    function fontFaceSrc(e){return unsafeCoerce$0(e,cst_font_face_src$0)}
    function fontFaceUri(e){return unsafeCoerce$0(e,cst_font_face_uri$0)}
    function foreignObject(e){return unsafeCoerce$0(e,cst_foreignobject)}
    function g(e){return unsafeCoerce$0(e,cst_g$1)}
    function glyph(e){return unsafeCoerce$0(e,cst_glyph$0)}
    function glyphRef(e){return unsafeCoerce$0(e,cst_glyphref$0)}
    function hkern(e){return unsafeCoerce$0(e,cst_hkern$0)}
    function image(e){return unsafeCoerce$0(e,cst_image$0)}
    function lineElement(e){return unsafeCoerce$0(e,cst_line$0)}
    function linearElement(e){return unsafeCoerce$0(e,cst_lineargradient$0)}
    function mask(e){return unsafeCoerce$0(e,cst_mask$0)}
    function metaData(e){return unsafeCoerce$0(e,cst_metadata$0)}
    function missingGlyph(e){return unsafeCoerce$0(e,cst_missing_glyph$0)}
    function mPath(e){return unsafeCoerce$0(e,cst_mpath$0)}
    function path$0(e){return unsafeCoerce$0(e,cst_path$0)}
    function pattern(e){return unsafeCoerce$0(e,cst_pattern$0)}
    function polygon(e){return unsafeCoerce$0(e,cst_polygon$0)}
    function polyline(e){return unsafeCoerce$0(e,cst_polyline$0)}
    function radialgradient(e){return unsafeCoerce$0(e,cst_radialgradient$0)}
    function rect(e){return unsafeCoerce$0(e,cst_rect$0)}
    function script$0(e){return unsafeCoerce$0(e,cst_script$3)}
    function set$1(e){return unsafeCoerce$0(e,cst_set$0)}
    function stop(e){return unsafeCoerce$0(e,cst_stop$0)}
    function style$0(e){return unsafeCoerce$0(e,cst_style$3)}
    function svg(e){return unsafeCoerce$0(e,cst_svg$0)}
    function switch$0(e){return unsafeCoerce$0(e,cst_switch$0)}
    function symbol$12(e){return unsafeCoerce$0(e,cst_symbol$0)}
    function textElement(e){return unsafeCoerce$0(e,cst_text$1)}
    function textpath(e){return unsafeCoerce$0(e,cst_textpath$0)}
    function title$0(e){return unsafeCoerce$0(e,cst_title$3)}
    function tref(e){return unsafeCoerce$0(e,cst_tref$0)}
    function tspan(e){return unsafeCoerce$0(e,cst_tspan$0)}
    function use(e){return unsafeCoerce$0(e,cst_use$0)}
    function view(e){return unsafeCoerce$0(e,cst_view$0)}
    function vkern(e){return unsafeCoerce$0(e,cst_vkern$0)}
    var
     Js_of_ocaml_Dom_svg=
      [0,
       xmlns,
       SVGError,
       createElement$0,
       createA$0,
       createAltGlyph,
       createAltGlyphDef,
       createAltGlyphItem,
       createAnimate,
       createAnimateColor,
       createAnimateMotion,
       createAnimateTransform,
       createCircle,
       createClipPath,
       createCursor,
       createDefs,
       createDesc,
       createEllipse,
       createFilter,
       createFont,
       createFontFace,
       createFontFaceFormat,
       createFontFaceName,
       createFontFaceSrc,
       createFontFaceUri,
       createForeignObject,
       createG,
       createGlyph,
       createGlyphRef,
       createhkern,
       createImage,
       createLineElement,
       createLinearElement,
       createMask,
       createMetaData,
       createMissingGlyph,
       createMPath,
       createPath,
       createPattern,
       createPolygon,
       createPolyline,
       createRadialgradient,
       createRect,
       createScript$0,
       createSet,
       createStop,
       createStyle$0,
       createSvg,
       createSwitch,
       createSymbol,
       createTextElement,
       createTextpath,
       createTitle$0,
       createTref,
       createTspan,
       createUse,
       createView,
       createvkern,
       svg_element,
       document$1,
       getElementById$0,
       [0,
        element$2,
        a$0,
        altGlyph,
        altGlyphDef,
        altGlyphItem,
        animate,
        animateColor,
        animateMotion,
        animateTransform,
        circle,
        clipPath,
        cursor,
        defs,
        desc,
        ellipse,
        filter,
        font,
        fontFace,
        fontFaceFormat,
        fontFaceName,
        fontFaceSrc,
        fontFaceUri,
        foreignObject,
        g,
        glyph,
        glyphRef,
        hkern,
        image,
        lineElement,
        linearElement,
        mask,
        metaData,
        missingGlyph,
        mPath,
        path$0,
        pattern,
        polygon,
        polyline,
        radialgradient,
        rect,
        script$0,
        set$1,
        stop,
        style$0,
        svg,
        switch$0,
        symbol$12,
        textElement,
        textpath,
        title$0,
        tref,
        tspan,
        use,
        view,
        vkern]];
    caml_register_global(1663,Js_of_ocaml_Dom_svg,"Js_of_ocaml__Dom_svg");
    function withCredentials(b)
     {var init={};init.withCredentials = ! ! b;return init}
    var
     eventSource=Unsafe[1].EventSource,
     eventSource_options=Unsafe[1].EventSource,
     Js_of_ocaml_EventSource=
      [0,withCredentials,eventSource,eventSource_options,addEventListener];
    caml_register_global
     (1664,Js_of_ocaml_EventSource,"Js_of_ocaml__EventSource");
    var
     console=runtime.caml_js_get_console(0),
     Js_of_ocaml_Firebug=[0,console];
    caml_register_global(1665,Js_of_ocaml_Firebug,"Js_of_ocaml__Firebug");
    function empty_position_options(param){return {}}
    var
     x=Unsafe[1].navigator,
     geolocation=caml_call1(Optdef[5],x)?x.geolocation:x;
    function is_supported$2(param){return caml_call1(Optdef[5],geolocation)}
    var
     Js_of_ocaml_Geolocation=
      [0,empty_position_options,geolocation,is_supported$2];
    caml_register_global
     (1666,Js_of_ocaml_Geolocation,"Js_of_ocaml__Geolocation");
    function object_options(param){return {"localeMatcher":"best fit"}}
    function options(param)
     {return {"localeMatcher":"best fit",
              "usage":"sort",
              "sensitivity":"variant",
              "ignorePunctuation":false$0,
              "numeric":false$0,
              "caseFirst":"false"}}
    var Collator=[0,object_options,options];
    function options$0(param)
     {return {"localeMatcher":"best fit",
              "timeZone":t37,
              "hour12":t37,
              "hourCycle":t37,
              "formatMatcher":"best fit",
              "weekday":t37,
              "era":t37,
              "year":t37,
              "month":t37,
              "day":t37,
              "hour":t37,
              "minute":t37,
              "second":t37,
              "timeZoneName":t37}}
    var DateTimeFormat=[0,object_options,options$0];
    function options$1(param)
     {return {"localeMatcher":"best fit",
              "style":"decimal",
              "currency":t37,
              "currencyDisplay":t37,
              "useGrouping":true$0,
              "minimumIntegerDigits":t37,
              "minimumFractionDigits":t37,
              "maximumFractionDigits":t37,
              "minimumSignificantDigits":t37,
              "maximumSignificantDigits":t37}}
    var NumberFormat=[0,object_options,options$1];
    function options$2(param)
     {return {"localeMatcher":"best fit","type":"cardinal"}}
    var
     PluralRules=[0,object_options,options$2],
     intl=Unsafe[1].Intl,
     collator_constr=Unsafe[1].Intl.Collator,
     dateTimeFormat_constr=Unsafe[1].Intl.DateTimeFormat,
     numberFormat_constr=Unsafe[1].Intl.NumberFormat,
     pluralRules_constr=Unsafe[1].Intl.PluralRules;
    function is_supported$3(param){return caml_call1(Optdef[5],intl)}
    var
     Js_of_ocaml_Intl=
      [0,
       Collator,
       DateTimeFormat,
       NumberFormat,
       PluralRules,
       intl,
       collator_constr,
       dateTimeFormat_constr,
       numberFormat_constr,
       pluralRules_constr,
       is_supported$3];
    caml_register_global(1667,Js_of_ocaml_Intl,"Js_of_ocaml__Intl");
    var Js_of_ocaml$0=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
    caml_register_global(1668,Js_of_ocaml$0,"Js_of_ocaml");
    return}
  (function(){return this}()));


//# 1 ".server.eobjs/byte/range.cmo.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_new_string=runtime.caml_new_string;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    var
     global_data=runtime.caml_get_global_data(),
     partial=[11,caml_new_string("))"),0],
     norange=[0,caml_new_string("__internal"),[0,0,0],[0,0,0]],
     Lexing=global_data.Lexing,
     Printf=global_data.Printf,
     Pervasives=global_data.Pervasives,
     _c_=
      [0,
       [11,
        caml_new_string('("'),
        [2,
         0,
         [11,
          caml_new_string('", ('),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(", "),
            [4,
             0,
             0,
             0,
             [11,
              caml_new_string("), ("),
              [4,0,0,0,[11,caml_new_string(", "),[4,0,0,0,partial]]]]]]]]]],
       caml_new_string('("%s", (%d, %d), (%d, %d))')],
     _b_=
      [0,
       [2,
        0,
        [11,
         caml_new_string(":["),
         [4,
          0,
          0,
          0,
          [12,46,[4,0,0,0,[12,45,[4,0,0,0,[12,46,[4,0,0,0,[12,93,0]]]]]]]]]],
       caml_new_string("%s:[%d.%d-%d.%d]")],
     _a_=
      [0,
       [11,
        caml_new_string("merge_range called on different files: "),
        [2,0,[11,caml_new_string(" and "),[2,0,0]]]],
       caml_new_string("merge_range called on different files: %s and %s")];
    function line_of_pos(param){var l=param[1];return l}
    function col_of_pos(param){var c=param[2];return c}
    function mk_pos(line,col){return [0,line,col]}
    function file_of_range(param){var f=param[1];return f}
    function start_of_range(param){var s=param[2];return s}
    function end_of_range(param){var e=param[3];return e}
    function mk_range(f,s,e){return [0,f,s,e]}
    function valid_pos(param)
     {var c=param[2],l=param[1],_k_=0 <= l?1:0,_l_=_k_?0 <= c?1:0:_k_;
      return _l_}
    function merge_range(r1,r2)
     {var e2=r2[3],s2=r2[2],f=r2[1],e1=r1[3],s1=r1[2],f$0=r1[1];
      if(runtime.caml_string_notequal(f$0,f))
       {var _i_=caml_call3(Printf[4],_a_,f$0,f);
        return caml_call1(Pervasives[2],_i_)}
      if(valid_pos(s1))
       {if(valid_pos(s2))
         {var _j_=caml_call2(Pervasives[5],e1,e2);
          return [0,f$0,caml_call2(Pervasives[4],s1,s2),_j_]}
        return r1}
      return r2}
    function string_of_range(param)
     {var
       _h_=param[3],
       ec=_h_[2],
       el=_h_[1],
       match=param[2],
       sc=match[2],
       sl=match[1],
       f=param[1];
      return caml_call6(Printf[4],_b_,f,sl,sc,el,ec)}
    function ml_string_of_range(param)
     {var
       _g_=param[3],
       ec=_g_[2],
       el=_g_[1],
       match=param[2],
       sc=match[2],
       sl=match[1],
       f=param[1];
      return caml_call6(Printf[4],_c_,f,sl,sc,el,ec)}
    function pos_of_lexpos(p){return [0,p[2],p[4] - p[3] | 0]}
    function mk_lex_range(p1,p2)
     {var _e_=pos_of_lexpos(p2),_f_=pos_of_lexpos(p1);
      return [0,p1[1],_f_,_e_]}
    function lex_range(lexbuf)
     {var _d_=caml_call1(Lexing[10],lexbuf);
      return mk_lex_range(caml_call1(Lexing[9],lexbuf),_d_)}
    var
     Range=
      [0,
       line_of_pos,
       col_of_pos,
       mk_pos,
       file_of_range,
       start_of_range,
       end_of_range,
       mk_range,
       merge_range,
       string_of_range,
       ml_string_of_range,
       norange,
       pos_of_lexpos,
       mk_lex_range,
       lex_range];
    runtime.caml_register_global(7,Range,"Range");
    return}
  (function(){return this}()));


//# 1 ".server.eobjs/byte/ast.cmo.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     global_data=runtime.caml_get_global_data(),
     Range=global_data.Range;
    function no_loc(x){return [0,x,Range[11]]}
    var Ast=[0,no_loc];
    runtime.caml_register_global(1,Ast,"Ast");
    return}
  (function(){return this}()));


//# 1 ".server.eobjs/byte/parser.cmo.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_new_string=runtime.caml_new_string;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_Parser_MenhirBasics_Error=
      caml_new_string("Parser.MenhirBasics.Error"),
     default_reduction=
      [0,
       8,
       caml_new_string
        ("\0\0\x0f\x11X\0Y\x0e\0Z\0\0\0\0\0\r\f\x12\0\0\0\0\0\x10\0\0=\0\x14\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0F\0\0*\0\x15\0\x16\0\x01\0-\0\0\0\0\0\0[\0\0JA\x04\0\0\0\0\0\0\0S\0\0\0\0\0Q\0R\0\0\0\0\0\0\x0b\n5\0\0\0\0\0\0\0\0M\0\0TV\0\0\0NP\0\0\0\0O\0\0\0\0\0\0LC]\0;\0\x05\x07\0\0\0\x0002/\0\0\0\0\0.3\0\0\x001?\x004\0\0H\0\x06\0\0\0\0\0\b\x02\0D\x009\0\x03\0W")],
     error=
      [0,
       47,
       caml_new_string
        ('\x0f\xc0\x02"\x82\x14\0\0\b \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\xf8\0DPB\x80\0\0\0\0\0\0\0\0\0\0\0\n\x80\0\0\0\0\0\0\0\0\0\0\0\0\0@\0\0~\x02\x11\x14\x10\xa0\0\0\x01\x80\0\x01\xf8\x04DPB\x83\xf0\0\x88\xa0\x85\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0?\0\b\x8a\bP~\0\x11\x14\x10\xa0\0\0\x01\0\0\0\0\b\0\0\0\0\0\x01\x04\0\0\0\0\0\0\0\0\0?y\xf4qZ\x1f\x82\x04E\x04(\0\0\0\0\0\0\0\b\0\0\0\0\0\0\0\0\0\0\x07g>\x8e#C\xf0\0\x88\xa0\x85\0\x1f\xbc\xfa8\xad\x0f\xc0\x02"\x82\x14\0t\xb3\xe8\xe2$?\0\b\x8a\bP\x01\xfb\xcf\xa3\x8a\xd0\xfc\0"(!@\x07\xef>\x8e+C\xf0\0\x88\xa0\x85\0\x1f\xbc\xfa8\xad\x0f\xc0\x02"\x82\x14\0~\xf3\xe8\xe2\xb4?\0\b\x8a\bP\x01\xfb\xcf\xa3\x8a\xd0\0\0\0\0\0\x01\xf8\0DPB\x80\x0f\xde}\x1cV\x87\xe0\x01\x11A\n\0?y\xf4qZ\x1f\x80\x04E\x04(\0\xfd\xe7\xd1\xc5h~\0\x11\x14\x10\xa0\x03\xf7\x9fG\x15\xa1\xf8\0DPB\x80\x0f\xde}\x1cV\x87\xe0\x01\x11A\n\0?y\xf4qZ\x1f\x80\x04E\x04(\0\xfd\xe7\xd1\xc5h~\0\x11\x14\x10\xa0\x03\xf7\x9fG\x15\xa1\xf8\0DPB\x80\x0f\xde}\x1cV\x87\xe0\x01\x11A\n\0?y\xf4qZ\x1f\x80\x04E\x04(\0\0\0\0\0\0\x01\xfb\xcf\xa3\x8a\xd0\x03\xb1\x9fG\x11 \0\0\0\0\0\0\0\b\0\0\0\0\0\0\0\0\0\0:Y\xf4q\x12\0\0\0\0\0\0\0\xfd\xe7\xd1\xc5h\0\0\0\0\0\0\x03\xa1\x9fG\x15 \0\0\0\0\0\x06\xa0\0\0\x02\x10\0\0\0\0@\0\0\0\0 \0\0\x15\x02\0\0\0\0\0\0\0B\0\0\0\x02\0\0\0\0\0\0\0\0\0\0\0 \0\0\x01\x02\xa0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\0\0\0\0\0\0@\0\x06\xfc\n"8a@\0\0\x04\0\0\x03\xf0\0\x88\xa0\x85\0\x1d\x8c\xfa8\x89\0\0\0\b\0\0\0\0\0\0\0\0\0\0\0\x02\0\0\0\0\0\0\x04\0\xfc\0"(!@\x07\xc3>\x8e#C\xf1\0\x88\xa0\x85\0\0\0\0\0\0\0>\x19\xf4q\x12\0\0\0\0\0\0\0\0\0\x80\0\0~\0\x11\x14\x10\xa0\x03\xb1\x9fG\x11 \0\0\x01\0\0\x1b\xf0h\x88\xe1\x9d\0\0\0\x04\x80\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\xd0\xcf\xa3\x8c\x90\0\0\x02\0\0\x04\0\x80\0\0\0\0\x01\0\0\0\0\x07\xe2\x01\x11A\n\0\x04\0\0\0\0\xdf\x83\x04G\f(\0\x10\0\0\0\0\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x80\x1f\x80\x04E\x04(\0\xf8g\xd1\xc4H\0\0\0\0\0\0\0\0\0\0\0\0\x07C>\x8e"C\xf0@\x88\xa0\x85\0\0\x80\0\0\0\0>\x19\xf4q\x12\0\0\0\0\0\0?\0\b\x8a\bP\x01\xd2\xcf\xa3\x88\x90\x03\xa1\x9fG\x19 \x07\xc3>\x8e"@\x01\0\0\0\x02\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03~\x05\x11\x1c0\xa0\0\0\0\0\0\0\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x80\0\0\0\0\0\x01\0;\0\b\b\b\0\0\0 \x80\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05@\0\0\0\0\0\0\0\x10\0\0\0\0\x80\0\0\0\0\0\0`\0\0v\x01\x10\x10\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\0\0\0 \0\0\0\0\0\x04\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\x04\0\0\x01\x03\xb0\0\x80\x80\x80\0\0\0\0\0\0\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0B\0\0\0\0\x01\0\0\0\xa8\x10\0\0\0\0\0 \0\0\0\0\0\0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x80\0\0\0\0\0\0\xd4\0\0\0B\0\0\0\0\0\0\r\xf8\x10Dp\xc2\x80\0\0\0\0\0\0\0\0\0\0 \0\0\0\0\0\0')],
     action=
      [0,
       [0,
        16,
        caml_new_string
         ("\b\x8c\0\x1f\0\0\0\0\0\0\b\x8c\0\0\0\0\0\x1c\0\0\0!\b\x8c\0\x03\b\x8c\b\x8c\0\0\0\0\0\0\b\x8c\b\x8c\0*\0d\0,\0\0\0\x15\b\x8c\0\0\0r\0\0\x05\xc4\b\x8c\x006\b\x8c\x05\xc4\b\x8c\0\x80\b\x8c\0\xca\b\x8c\x01\x14\b\x8c\x01^\b\x8c\x01\xa8\0\0\b\x8c\x01\xf2\b\x8c\x02<\b\x8c\x02\x86\b\x8c\x02\xd0\b\x8c\x03\x1a\b\x8c\x03d\b\x8c\x03\xae\b\x8c\x03\xf8\b\x8c\x04B\b\x8c\x04\x8c\b\x8c\0\0\x04\xd6\x06\x0e\0\0\0\x94\0\0\x06\x0e\0\0\x05 \0\0\x05\xc4\0\0\x05d\0\x80\0\x94\x05d\0\x06\0\xaa\0\0\0\x1a\0\x1c\0\0\0\0\0\0\0\xb2\x006\x06j\0\xa6\b\x8c\x06\xb2\x006\0\0\0\xaa\0\xa4\b\x8c\x06\x0e\b\x8c\0\0\x05\xc4\0\0\0\xc2\b\x8c\x06\xee\x006\x05|\x006\0\0\0\0\0\0\x07*\0\xce\0&\0\xec\b\xe0\0\xee\x06j\0\xf0\0\0\0\xf4\x006\0\0\0\0\0\xc4\b\x8c\x06\xb2\0\0\0\0\b6\b\x8c\0\xf8\x07t\0\0\b\x8c\x06\xb2\x07\xb0\x07\xfa\0d\0&\0\0\0\0\0\0\x06j\0\0\0\xf6\0\0\0\0\0\xde\0\xd4\bv\0L\0\0\0\0\0\0\0\x1c\0\xfe\x01\x1c\0t\b\xec\0\0\0\0\x01\n\x01*\0\x94\0\0\0\0\x01,\0\0\0|\bv\0\0\x018\0\0\0J\x01 \x05d\x01>\x006\0\0\0\0\x01\f\0\0\x05d\0\0\x06j\0\0\x01\x0e\0\0")],
       [0,
        16,
        caml_new_string
         ('\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\n\0\x9d\0\x9d\0\x9d\0\x9d\0.\x01e\0\x9d\0\x9d\0\x9d\0f\0\x82\0&\0\x9d\0\x12\x01\x8a\0\x1a\0\x9d\0\x9d\0\x9d\x01i\x006\x01!\0\x9d\x01N\0\x9d\x01\x05\0\x9d\0\x9d\x01V\0\x9d\0a\0a\0a\0a\0a\0a\0^\0a\0a\0a\0a\0V\x01i\0a\0a\0a\0f\0\x82\x01r\0a\x01Z\x01\xaa\x02r\0a\0a\0a\x01)\x01N\x01e\0a\0Z\0a\x02\xce\0a\0a\0r\0a\0z\0\x91\0\x91\0\x91\0\x91\0\x91\x01\x19\0\x91\0\x91\0\x92\0\x91\x01i\x02\x8e\0\x91\0\x91\0\x91\0f\0\x82\x01\x1e\0\x91\x02>\x02\xa6\x01B\0\x91\0\x91\0\x91\x01F\x01i\x01R\0\x91\x01n\0\x91\x02\xba\0\x9a\0\x91\x01z\0\x91\0z\0Y\0Y\0Y\0Y\0Y\x01\x8e\0Y\0Y\0Y\0Y\x01\x92\x01\xae\0Y\0Y\0Y\0f\0\x82\x01\xd6\0Y\x01\xde\x01\xe6\x01\xee\0Y\0Y\0Y\x01\xf6\x02\x06\x02"\0Y\x02Z\0Y\x02f\0Y\0Y\x02j\0Y\0z\0]\0]\0]\0]\0]\x02\x86\0]\0]\0]\0]\x02\x8a\x02\x9e\0]\0]\0]\0f\0\x82\x02\xa2\0]\x02\xb2\x02\xc6\x02\xd2\0]\0]\0]\x02\xda\x02\xeb\x03\x03\0]\0\0\0]\0\0\0]\0]\0\0\0]\0z\0\x8d\0\x8d\0\x8d\0\x8d\0\x8d\0\0\0\x8d\0\x8d\0\x92\0\x8d\0\0\0\0\0\x8d\0\x8d\0\x8d\0f\0\x82\0\0\0\x8d\0\0\0\0\0\0\0\x8d\0\x8d\0\x8d\0\0\0\0\0\0\0\x8d\0\0\0\x8d\0\0\0\x9a\0\x8d\0\0\0\x8d\0z\0\x95\0\x95\0\x95\0\x95\0\x95\0\0\0\x95\0\x95\0\x92\0\x95\0\0\0\0\0\x95\0\x95\0\x95\0f\0\x82\0\0\0\x95\0\0\0\0\0\0\0\x95\0\x95\0\x95\0\0\0\0\0\0\0\x95\0\0\0\x95\0\0\0\x9a\0\x95\0\0\0\x95\0z\0\x8a\0\xa2\0\x81\0\xaa\0\x81\0\0\0\x81\0\x81\0\x92\0\x81\0\0\0\0\0\xbe\0\xc6\0\xce\0f\0\x82\0\0\0\x81\0\0\0\0\0\0\0\x81\0\xd6\0\xde\0\0\0\0\0\0\0\xe6\0\0\0\x81\0\0\0\x9a\0\x81\0\0\0\xee\0z\0\x8a\0\xa2\0i\0\xaa\0i\0\0\0i\0i\0\x92\0i\0\0\0\0\0i\0\xc6\0\xce\0f\0\x82\0\0\0i\0\0\0\0\0\0\0i\0\xd6\0\xde\0\0\0\0\0\0\0i\0\0\0i\0\0\0\x9a\0i\0\0\0i\0z\0\x8a\0\xa2\0q\0\xaa\0q\0\0\0q\0q\0\x92\0q\0\0\0\0\0q\0q\0q\0f\0\x82\0\0\0q\0\0\0\0\0\0\0q\0q\0q\0\0\0\0\0\0\0q\0\0\0q\0\0\0\x9a\0q\0\0\0q\0z\0\x8a\0\xa2\0m\0\xaa\0m\0\0\0m\0m\0\x92\0m\0\0\0\0\0m\0m\0m\0f\0\x82\0\0\0m\0\0\0\0\0\0\0m\0m\0m\0\0\0\0\0\0\0m\0\0\0m\0\0\0\x9a\0m\0\0\0m\0z\0\x8a\0\xa2\0y\0\xaa\0y\0\0\0y\0y\0\x92\0y\0\0\0\0\0y\0y\0y\0f\0\x82\0\0\0y\0\0\0\0\0\0\0y\0y\0y\0\0\0\0\0\0\0y\0\0\0y\0\0\0\x9a\0y\0\0\0y\0z\0\x8a\0\xa2\0u\0\xaa\0u\0\0\0u\0u\0\x92\0u\0\0\0\0\0u\0u\0u\0f\0\x82\0\0\0u\0\0\0\0\0\0\0u\0u\0u\0\0\0\0\0\0\0u\0\0\0u\0\0\0\x9a\0u\0\0\0u\0z\0\x8a\0\xa2\0e\0\xaa\0e\0\0\0e\0e\0\x92\0e\0\0\0\0\0e\0\xc6\0\xce\0f\0\x82\0\0\0e\0\0\0\0\0\0\0e\0\xd6\0\xde\0\0\0\0\0\0\0e\0\0\0e\0\0\0\x9a\0e\0\0\0e\0z\0\x8a\0\xa2\0}\0\xaa\0}\0\0\0}\0}\0\x92\0}\0\0\0\0\0\xbe\0\xc6\0\xce\0f\0\x82\0\0\0}\0\0\0\0\0\0\0}\0\xd6\0\xde\0\0\0\0\0\0\0\xe6\0\0\0}\0\0\0\x9a\0}\0\0\0}\0z\0\x8a\0\xa2\0\x89\0\xaa\0\x89\0\0\0\x89\0\x89\0\x92\0\xb6\0\0\0\0\0\xbe\0\xc6\0\xce\0f\0\x82\0\0\0\x89\0\0\0\0\0\0\0\xfe\0\xd6\0\xde\0\0\0\0\0\0\0\xe6\0\0\0\x89\0\0\0\x9a\0\x89\0\0\0\xee\0z\0\x8a\0\xa2\0\x85\0\xaa\0\x85\0\0\0\x85\0\x85\0\x92\0\xb6\0\0\0\0\0\xbe\0\xc6\0\xce\0f\0\x82\0\0\0\x85\0\0\0\0\0\0\0\x85\0\xd6\0\xde\0\0\0\0\0\0\0\xe6\0\0\0\x85\0\0\0\x9a\0\x85\0\0\0\xee\0z\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\x99\0\x99\0\x99\0f\0\x82\0\0\0\x99\0\0\0\0\0\0\0\x99\0\x99\0\x99\0\0\0\0\0\0\0\x99\0\0\0\x99\0\0\0\x99\0\x99\0\0\0\x99\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\0\0\xa1\0\xa1\0\xa1\0\xa1\0\0\0\0\0\xa1\0\xa1\0\xa1\0f\0\x82\0\0\0\xa1\0\0\0\0\0\0\0\xa1\0\xa1\0\xa1\0\0\x01>\0&\0\xa1\0\x12\0\xa1\0\x1a\0\xa1\0\xa1\0\0\0\xa1\0!\0!\0\xfd\0!\0!\0!\0!\0!\0!\0\0\0\0\0\0\0\0\0\0\0!\0!\0\0\0!\0\0\0\0\0\0\0!\0\0\x02b\0\0\0!\0\0\0\0\0\xdd\0!\0!\0!\0\0\0\0\0\0\0\0\0!\0!\0\0\0\0\0!\x01\xbe\0!\0\0\0!\0z\0\x8a\0\xa2\x01\xa6\0\xaa\x01\x11\0\0\0\xb2\x01\x11\0\x92\0\xb6\0\0\0\0\0\xbe\0\xc6\0\xce\0f\0\x82\0\0\0\xf6\0\0\0\0\0\0\0\xfe\0\xd6\0\xde\0\0\0\0\0\0\0\xe6\0\0\x017\0\0\0\x9a\x01\x06\0\0\0\xee\0z\0\x8a\0\xa2\x01m\0\xaa\x01\x16\0\0\x01&\0\0\0\x92\0\xb6\0\0\0\0\0\xbe\0\xc6\0\xce\0f\0\x82\0\0\0\xf6\0\0\0\0\0\0\0\xfe\0\xd6\0\xde\0\0\0\0\0\0\0\xe6\0\0\0\0\0\0\0\x9a\x01m\0\0\0\xee\x01v\x01\x8a\0\0\0\x06\0\x0e\0\x12\0\x16\0\x1a\0\x1e\0\0\0\0\0\0\0\0\0\0\x01Q\x01\x9a\0\0\0\xe5\0\0\0\0\0\0\0"\0\0\0\0\0\0\0:\0\0\0\0\0\0\0>\x01\xaa\x01\xce\0\0\0\0\0\0\0\0\x01\xd2\0F\0\0\0\0\0\0\0\0\0J\0\0\0N\0z\0\x8a\0\xa2\x02\x0e\0\xaa\x01\x82\0\0\x022\0\0\0\x92\0\xb6\0\0\0\0\0\xbe\0\xc6\0\xce\0f\0\x82\0\0\0\xf6\0\0\0\0\0\0\0\xfe\0\xd6\0\xde\0\0\0\0\0\0\0\xe6\0z\0\x8a\0\xa2\0\x9a\0\xaa\x01\xb6\0\xee\0\0\0\0\0\x92\0\xb6\0\0\0\0\0\xbe\0\xc6\0\xce\0f\0\x82\0\0\0\xf6\0\0\0\0\0\0\0\xfe\0\xd6\0\xde\0\0\0\0\0\0\0\xe6\0-\0-\0-\0\x9a\0-\0\0\0\xee\0\0\0\0\0-\0-\0\0\0\0\0-\0-\0-\0-\0-\0\0\0-\0\0\0\0\0\0\0-\0-\0-\0\0\0\0\0\0\0-\0\xd5\0\0\0\0\0-\0\0\0\0\0-\0M\0M\0M\x02&\0M\0\0\0\0\0\0\0\0\0M\0M\0\0\0\0\0M\0M\0M\0M\0M\0\0\0M\0\0\0\0\0\0\0M\0M\0M\0\0\0\0\0\0\0M\0I\0I\0I\0M\0I\0\0\0M\0\0\0\0\0I\0I\0\0\0\0\0I\0I\0I\0I\0I\0\0\0I\0\0\0\0\0\0\0I\0I\0I\0\0\0\0\0\0\0I\0\xd9\0\0\0\0\0I\0\0\0\0\0I\0z\0\x8a\0\xa2\0\xad\0\xaa\0\0\0\0\0\0\0\0\0\x92\0\xb6\0\0\0\0\0\xbe\0\xc6\0\xce\0f\0\x82\0\0\0\xf6\0\0\0\0\0\0\0\xfe\0\xd6\0\xde\0\0\0\0\0\0\0\xe6\0z\0\x8a\0\xa2\0\x9a\0\xaa\0\0\0\xee\0\0\0\0\0\x92\0\xb6\0\0\0\0\0\xbe\0\xc6\0\xce\x02\x1a\x02*\0\0\0\xf6\0\0\0\0\0\0\0\xfe\0\xd6\0\xde\x02n\x02v\0\x12\0\xe6\0\x1a\x02z\0\0\0\x9a\0\0\0\0\0\xee\0\x06\0\x0e\0\x12\0\x16\0\x1a\0\x1e\0\0\x02~\0\0\x01\x9e\0\0\0\xed\0\0\x002\0\xed\x02\x92\0\0\0\0\0"\0\0\0\0\0\0\0:\x02\x96\0\0\0\0\0>\0\0\0B\0\0\0\0\0\0\0\0\0\0\0F\0\0\0\0\0\0\0\0\0J\0\0\0N\0\x06\0\x0e\0\x12\0\x16\0\x1a\0\x1e\x02n\x02v\0\x12\0\xa9\0\x1a\x02z\0\0\0\0\0\0\0\0\0\0\0\0\0"\0\0\0\xf5\0\0\0:\0\0\x02~\0\0\0>\0\0\0B\0\0\0\0\0\0\x02\x92\0\0\0F\0\0\0\0\0\0\0\0\0J\x02\x96\0N')]],
     lhs=
      [0,
       8,
       caml_new_string
        ("\x02\x01\0\x1d\x1c\x1b\x1b\x1b\x1a\x1a\x1a\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x18\x18\x17\x16\x16\x16\x16\x16\x16\x16\x15\x14\x14\x13\x13\x12\x12\x11\x11\x10\x10\x0f\x0f\x0e\x0e\r\f\f\x0b\x0b\n\n\t\t\b\b\b\b\b\b\b\b\x07\x07\x06\x05\x05\x05\x05\x04\x03")],
     goto$0=
      [0,
       [0,
        16,
        caml_new_string
         ("\0j\0\0\0\0\0\0\0\0\0\f\0\0\0\0\0\x04\0\0\0\0\0R\0\0\x006\0\x84\0\0\0\0\0\0\0\x88\0\x8a\0\0\0\0\0\0\0\0\0\0\x008\0\0\0\0\0\0\0\0\0\x9a\0\0\0\x9c\0\0\0\xa0\0\0\0\xa8\0\0\0\xaa\0\0\0\xb4\0\0\0\xb6\0\0\0\0\0\xb8\0\0\0\xbc\0\0\0\xbe\0\0\0\xc0\0\0\0\xc6\0\0\0\xca\0\0\0\xcc\0\0\0\xce\0\0\0\xd4\0\0\0\xd6\0\0\0~\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0H\0\0\0\0\0\n\0\0\0\0\0\0\0\0\0\xd8\0\0\0\0\0\0\0\0\0\x1f\0\t\0\0\0\xda\0\0\0\x0e\0\0\0\0\0\0\0\xea\0\0\0\xec\0\0\0\0\0\0\0\0\0\xf0\0\0\0\x10\0\x16\0\xd8\0\0\0\0\0\0\0\0\0\0\0^\0\0\0n\0\0\0\x05\0\0\0\0\0\0\0\x14\0\0\0\0\0\0\0\xfa\0\0\0\0\0\0\0\0\0h\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\x01\x06\0\0\0\0\0\0\0\b\0\0\0\0\0\0\0\0\0\0\0\0\x01\b\0\0\0\0\0\0\0\0\x01\n\0\0\0\0\0\0\0V\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x98\0\0\0\0\0\0\0\0\0\0\0r\0\0\0\xde\0\0\0\0\0\0\0\0\0\x82\0\0\0,\0\0\0\0\0\0")],
       [0,
        8,
        caml_new_string
         ('{\x15{\x15\x94}\x80\x0b{\x15S\x15\x94\x98\x96Y\x81\x85\x81\x85Z\x86\x95\x86\x81\x85{\x15\xbf\x86\xc0K\x15\x15[bos\x7f\x1b\x1b\xb3\x81\x85G\x1c\x15\x86\xa7\xb9w\x8f\x1e\x1e\xab\xba\x92\x15\x15\xac\x15\x93S\xbc\x1b\xaeIY\x15\x88\xb3\x15Z\x15\x15CL\x1eMy\x8e\xa7\x15\x15\xbd\x15\xb6\xb0\x1e\x15\x15E\xbcD\x19\x15\x15\x15\xae\x15\x15\x15 "\x15$\x15\x15\x15&(\x15\x15S\x15*,/X135\x15\x157\x159;=q\x15?A\x15`\x8fr\xa7\xa1\xb8\x91\0fi\0m\0\0\0\0\x83\0\0\x8c\xb1')]],
     Range=global_data.Range,
     MenhirLib=global_data.MenhirLib,
     Error=[248,cst_Parser_MenhirBasics_Error,runtime.caml_fresh_oo_id(0)],
     _aB_=[1,1],
     _az_=[1,0],
     _U_=[1,1],
     _S_=[1,0],
     _n_=[2,0];
    function loc(startpos,endpos,elt)
     {return [0,elt,caml_call2(Range[13],startpos,endpos)]}
    function token2terminal(tok)
     {if(typeof tok === "number")
       switch(tok)
        {case 0:return 1;
         case 1:return 2;
         case 2:return 3;
         case 3:return 4;
         case 4:return 5;
         case 5:return 6;
         case 6:return 7;
         case 7:return 8;
         case 8:return 10;
         case 9:return 11;
         case 10:return 12;
         case 11:return 13;
         case 12:return 14;
         case 13:return 15;
         case 14:return 16;
         case 15:return 17;
         case 16:return 18;
         case 17:return 19;
         case 18:return 20;
         case 19:return 21;
         case 20:return 22;
         case 21:return 23;
         case 22:return 24;
         case 23:return 25;
         case 24:return 26;
         case 25:return 27;
         case 26:return 28;
         case 27:return 29;
         case 28:return 31;
         case 29:return 33;
         case 30:return 34;
         case 31:return 35;
         case 32:return 36;
         case 33:return 37;
         case 34:return 38;
         case 35:return 39;
         case 36:return 40;
         case 37:return 41;
         case 38:return 42;
         case 39:return 43;
         case 40:return 44;
         case 41:return 45;
         default:return 46}
      else
       switch(tok[0]){case 0:return 9;case 1:return 30;default:return 32}}
    var error_terminal=0;
    function token2value(tok)
     {if(typeof tok === "number")
       switch(tok)
        {case 0:return 0;
         case 1:return 0;
         case 2:return 0;
         case 3:return 0;
         case 4:return 0;
         case 5:return 0;
         case 6:return 0;
         case 7:return 0;
         case 8:return 0;
         case 9:return 0;
         case 10:return 0;
         case 11:return 0;
         case 12:return 0;
         case 13:return 0;
         case 14:return 0;
         case 15:return 0;
         case 16:return 0;
         case 17:return 0;
         case 18:return 0;
         case 19:return 0;
         case 20:return 0;
         case 21:return 0;
         case 22:return 0;
         case 23:return 0;
         case 24:return 0;
         case 25:return 0;
         case 26:return 0;
         case 27:return 0;
         case 28:return 0;
         case 29:return 0;
         case 30:return 0;
         case 31:return 0;
         case 32:return 0;
         case 33:return 0;
         case 34:return 0;
         case 35:return 0;
         case 36:return 0;
         case 37:return 0;
         case 38:return 0;
         case 39:return 0;
         case 40:return 0;
         case 41:return 0;
         default:return 0}
      else
       switch(tok[0])
        {case 0:var v=tok[1];return v;
         case 1:var v$0=tok[1];return v$0;
         default:var v$1=tok[1];return v$1}}
    var start=3;
    function _a_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_xs=menhir_stack[4],
       startpos_xs=menhir_stack[3],
       xs=menhir_stack[2],
       menhir_s=menhir_stack[1];
      return [0,menhir_s,xs,startpos_xs,endpos_xs,menhir_stack$0]}
    function _b_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _bd_=menhir_stack[5][5],
       match=_bd_[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       id=_bd_[2],
       endpos_init=menhir_stack[4],
       init=menhir_stack[2],
       v=[0,id,init];
      return [0,menhir_s,v,startpos_1,endpos_init,menhir_stack$0]}
    function _c_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_t=match[3],
       t=match[2],
       menhir_s=match[1],
       endpos_3=menhir_stack[4],
       r=[0,t],
       v=[0,r];
      return [0,menhir_s,v,startpos_t,endpos_3,menhir_stack$0]}
    function _d_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_1=menhir_stack[4],
       startpos_1=menhir_stack[3],
       menhir_s=menhir_stack[1],
       v=[0,0];
      return [0,menhir_s,v,startpos_1,endpos_1,menhir_stack$0]}
    function _e_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_1=menhir_stack[4],
       startpos_1=menhir_stack[3],
       menhir_s=menhir_stack[1];
      return [0,menhir_s,0,startpos_1,endpos_1,menhir_stack$0]}
    function _f_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_1=menhir_stack[4],
       startpos_1=menhir_stack[3],
       menhir_s=menhir_stack[1];
      return [0,menhir_s,1,startpos_1,endpos_1,menhir_stack$0]}
    function _g_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5],
       menhir_stack$0=match[5],
       startpos_s=match[3],
       s=match[2],
       menhir_s=match[1],
       endpos_2=menhir_stack[4];
      return [0,menhir_s,s,startpos_s,endpos_2,menhir_stack$0]}
    function _h_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_s=menhir_stack[4],
       startpos_s=menhir_stack[3],
       s=menhir_stack[2],
       menhir_s=menhir_stack[1],
       v=[0,s];
      return [0,menhir_s,v,startpos_s,endpos_s,menhir_stack$0]}
    function _i_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_s=menhir_env[4],
       startpos=menhir_stack[4];
      return [0,menhir_s,0,startpos,startpos,menhir_stack]}
    function _j_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _ba_=menhir_stack[5][5],
       _bb_=_ba_[5][5],
       _bc_=_bb_[5][5],
       match=_bc_[5][5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       ds=_bc_[2],
       e=_bb_[2],
       s=_ba_[2],
       endpos_b=menhir_stack[4],
       b=menhir_stack[2],
       v=loc(startpos_1,endpos_b,[5,ds,e,s,b]);
      return [0,menhir_s,v,startpos_1,endpos_b,menhir_stack$0]}
    function _k_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _a$_=menhir_stack[5][5],
       match=_a$_[5][5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       e=_a$_[2],
       endpos_b=menhir_stack[4],
       b=menhir_stack[2],
       v=loc(startpos_1,endpos_b,[6,e,b]);
      return [0,menhir_s,v,startpos_1,endpos_b,menhir_stack$0]}
    function _l_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _a__=menhir_stack[5],
       match=_a__[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       e=_a__[2],
       endpos_3=menhir_stack[4],
       v=loc(startpos_1,endpos_3,[2,[0,e]]);
      return [0,menhir_s,v,startpos_1,endpos_3,menhir_stack$0]}
    function _m_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       endpos_2=menhir_stack[4],
       v=loc(startpos_1,endpos_2,_n_);
      return [0,menhir_s,v,startpos_1,endpos_2,menhir_stack$0]}
    function _o_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_ifs=menhir_stack[4],
       startpos_ifs=menhir_stack[3],
       ifs=menhir_stack[2],
       menhir_s=menhir_stack[1];
      return [0,menhir_s,ifs,startpos_ifs,endpos_ifs,menhir_stack$0]}
    function _p_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _a9_=menhir_stack[5][5],
       match=_a9_[5][5],
       menhir_stack$0=match[5],
       startpos_e=match[3],
       e=match[2],
       menhir_s=match[1],
       xs=_a9_[2],
       endpos_5=menhir_stack[4],
       v=loc(startpos_e,endpos_5,[3,e,xs]);
      return [0,menhir_s,v,startpos_e,endpos_5,menhir_stack$0]}
    function _q_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _a8_=menhir_stack[5],
       match=_a8_[5][5],
       menhir_stack$0=match[5],
       startpos_p=match[3],
       p=match[2],
       menhir_s=match[1],
       e=_a8_[2],
       endpos_4=menhir_stack[4],
       v=loc(startpos_p,endpos_4,[0,p,e]);
      return [0,menhir_s,v,startpos_p,endpos_4,menhir_stack$0]}
    function _r_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5],
       menhir_stack$0=match[5],
       startpos_d=match[3],
       d=match[2],
       menhir_s=match[1],
       endpos_2=menhir_stack[4],
       v=loc(startpos_d,endpos_2,[1,d]);
      return [0,menhir_s,v,startpos_d,endpos_2,menhir_stack$0]}
    function _s_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_x=match[3],
       x=match[2],
       menhir_s=match[1],
       endpos_xs=menhir_stack[4],
       xs=menhir_stack[2],
       v=[0,x,xs];
      return [0,menhir_s,v,startpos_x,endpos_xs,menhir_stack$0]}
    function _t_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_x=menhir_stack[4],
       startpos_x=menhir_stack[3],
       x=menhir_stack[2],
       menhir_s=menhir_stack[1],
       v=[0,x,0];
      return [0,menhir_s,v,startpos_x,endpos_x,menhir_stack$0]}
    function _u_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _a7_=menhir_stack[5][5],
       match=_a7_[5],
       menhir_stack$0=match[5],
       startpos_x=match[3],
       x=match[2],
       menhir_s=match[1],
       y=_a7_[2],
       endpos_xs=menhir_stack[4],
       xs=menhir_stack[2],
       x$0=[0,x,y],
       v=[0,x$0,xs];
      return [0,menhir_s,v,startpos_x,endpos_xs,menhir_stack$0]}
    function _v_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5],
       menhir_stack$0=match[5],
       startpos_x=match[3],
       x=match[2],
       menhir_s=match[1],
       endpos_y=menhir_stack[4],
       y=menhir_stack[2],
       x$0=[0,x,y],
       v=[0,x$0,0];
      return [0,menhir_s,v,startpos_x,endpos_y,menhir_stack$0]}
    function _w_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_x=match[3],
       x=match[2],
       menhir_s=match[1],
       endpos_xs=menhir_stack[4],
       xs=menhir_stack[2],
       v=[0,x,xs];
      return [0,menhir_s,v,startpos_x,endpos_xs,menhir_stack$0]}
    function _x_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_x=menhir_stack[4],
       startpos_x=menhir_stack[3],
       x=menhir_stack[2],
       menhir_s=menhir_stack[1],
       v=[0,x,0];
      return [0,menhir_s,v,startpos_x,endpos_x,menhir_stack$0]}
    function _y_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_x=match[3],
       x=match[2],
       menhir_s=match[1],
       endpos_xs=menhir_stack[4],
       xs=menhir_stack[2],
       v=[0,x,xs];
      return [0,menhir_s,v,startpos_x,endpos_xs,menhir_stack$0]}
    function _z_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_x=menhir_stack[4],
       startpos_x=menhir_stack[3],
       x=menhir_stack[2],
       menhir_s=menhir_stack[1],
       v=[0,x,0];
      return [0,menhir_s,v,startpos_x,endpos_x,menhir_stack$0]}
    function _A_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5],
       menhir_stack$0=match[5],
       startpos_p=match[3],
       p=match[2],
       menhir_s=match[1],
       endpos_2=menhir_stack[4];
      return [0,menhir_s,p,startpos_p,endpos_2,menhir_stack$0]}
    function _B_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_x=menhir_stack[4],
       startpos_x=menhir_stack[3],
       x=menhir_stack[2],
       menhir_s=menhir_stack[1];
      return [0,menhir_s,x,startpos_x,endpos_x,menhir_stack$0]}
    function _C_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_s=menhir_env[4],
       startpos=menhir_stack[4];
      return [0,menhir_s,0,startpos,startpos,menhir_stack]}
    function _D_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_x=menhir_stack[4],
       startpos_x=menhir_stack[3],
       x=menhir_stack[2],
       menhir_s=menhir_stack[1];
      return [0,menhir_s,x,startpos_x,endpos_x,menhir_stack$0]}
    function _E_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_s=menhir_env[4],
       startpos=menhir_stack[4];
      return [0,menhir_s,0,startpos,startpos,menhir_stack]}
    function _F_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_x=menhir_stack[4],
       startpos_x=menhir_stack[3],
       x=menhir_stack[2],
       menhir_s=menhir_stack[1];
      return [0,menhir_s,x,startpos_x,endpos_x,menhir_stack$0]}
    function _G_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_s=menhir_env[4],
       startpos=menhir_stack[4];
      return [0,menhir_s,0,startpos,startpos,menhir_stack]}
    function _H_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_x=menhir_stack[4],
       startpos_x=menhir_stack[3],
       x=menhir_stack[2],
       menhir_s=menhir_stack[1];
      return [0,menhir_s,x,startpos_x,endpos_x,menhir_stack$0]}
    function _I_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_s=menhir_env[4],
       startpos=menhir_stack[4];
      return [0,menhir_s,0,startpos,startpos,menhir_stack]}
    function _J_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5],
       menhir_stack$0=match[5],
       startpos_x=match[3],
       x=match[2],
       menhir_s=match[1],
       endpos_xs=menhir_stack[4],
       xs=menhir_stack[2],
       v=[0,x,xs];
      return [0,menhir_s,v,startpos_x,endpos_xs,menhir_stack$0]}
    function _K_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_s=menhir_env[4],
       startpos=menhir_stack[4];
      return [0,menhir_s,0,startpos,startpos,menhir_stack]}
    function _L_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5],
       menhir_stack$0=match[5],
       startpos_x=match[3],
       x=match[2],
       menhir_s=match[1],
       endpos_xs=menhir_stack[4],
       xs=menhir_stack[2],
       v=[0,x,xs];
      return [0,menhir_s,v,startpos_x,endpos_xs,menhir_stack$0]}
    function _M_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_s=menhir_env[4],
       startpos=menhir_stack[4];
      return [0,menhir_s,0,startpos,startpos,menhir_stack]}
    function _N_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _a6_=menhir_stack[5],
       match=_a6_[5][5],
       menhir_stack$0=match[5],
       startpos_e=match[3],
       e=match[2],
       menhir_s=match[1],
       i=_a6_[2],
       endpos_4=menhir_stack[4],
       v=loc(startpos_e,endpos_4,[7,e,i]);
      return [0,menhir_s,v,startpos_e,endpos_4,menhir_stack$0]}
    function _O_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_id=menhir_stack[4],
       startpos_id=menhir_stack[3],
       id=menhir_stack[2],
       menhir_s=menhir_stack[1],
       v=loc(startpos_id,endpos_id,[6,id]);
      return [0,menhir_s,v,startpos_id,endpos_id,menhir_stack$0]}
    function _P_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _a4_=menhir_stack[5],
       _a5_=_a4_[5][5],
       match=_a5_[5][5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       e=_a5_[2],
       b1=_a4_[2],
       endpos_b2=menhir_stack[4],
       b2=menhir_stack[2],
       v=loc(startpos_1,endpos_b2,[4,e,b1,b2]);
      return [0,menhir_s,v,startpos_1,endpos_b2,menhir_stack$0]}
    function _Q_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _a2_=menhir_stack[5],
       _a3_=_a2_[5][5][5][5],
       match=_a3_[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       t=_a3_[2],
       xs=_a2_[2],
       endpos_7=menhir_stack[4],
       v=loc(startpos_1,endpos_7,[4,t,xs]);
      return [0,menhir_s,v,startpos_1,endpos_7,menhir_stack$0]}
    function _R_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_1=menhir_stack[4],
       startpos_1=menhir_stack[3],
       menhir_s=menhir_stack[1],
       v=loc(startpos_1,endpos_1,_S_);
      return [0,menhir_s,v,startpos_1,endpos_1,menhir_stack$0]}
    function _T_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_1=menhir_stack[4],
       startpos_1=menhir_stack[3],
       menhir_s=menhir_stack[1],
       v=loc(startpos_1,endpos_1,_U_);
      return [0,menhir_s,v,startpos_1,endpos_1,menhir_stack$0]}
    function _V_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5][5],
       menhir_stack$0=match[5],
       startpos_t=match[3],
       t=match[2],
       menhir_s=match[1],
       endpos_2=menhir_stack[4],
       t$0=[0,t],
       v=loc(startpos_t,endpos_2,[0,t$0]);
      return [0,menhir_s,v,startpos_t,endpos_2,menhir_stack$0]}
    function _W_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       endpos_2=menhir_stack[4],
       v=loc(startpos_1,endpos_2,[0,0]);
      return [0,menhir_s,v,startpos_1,endpos_2,menhir_stack$0]}
    function _X_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_s=menhir_stack[4],
       startpos_s=menhir_stack[3],
       s=menhir_stack[2],
       menhir_s=menhir_stack[1],
       v=loc(startpos_s,endpos_s,[3,s]);
      return [0,menhir_s,v,startpos_s,endpos_s,menhir_stack$0]}
    function _Y_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_i=menhir_stack[4],
       startpos_i=menhir_stack[3],
       i=menhir_stack[2],
       menhir_s=menhir_stack[1],
       v=loc(startpos_i,endpos_i,[2,i]);
      return [0,menhir_s,v,startpos_i,endpos_i,menhir_stack$0]}
    function _Z_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5],
       menhir_stack$0=match[5],
       startpos_e=match[3],
       e=match[2],
       menhir_s=match[1],
       endpos_2=menhir_stack[4];
      return [0,menhir_s,e,startpos_e,endpos_2,menhir_stack$0]}
    function ___(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_e=menhir_stack[4],
       startpos_e=menhir_stack[3],
       e=menhir_stack[2],
       menhir_s=menhir_stack[1],
       v=[0,e];
      return [0,menhir_s,v,startpos_e,endpos_e,menhir_stack$0]}
    function _$_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_s=menhir_env[4],
       startpos=menhir_stack[4];
      return [0,menhir_s,0,startpos,startpos,menhir_stack]}
    function _aa_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _a1_=menhir_stack[5],
       match=_a1_[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       e=_a1_[2],
       endpos_3=menhir_stack[4];
      return [0,menhir_s,e,startpos_1,endpos_3,menhir_stack$0]}
    function _ab_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       endpos_e=menhir_stack[4],
       e=menhir_stack[2],
       v=loc(startpos_1,endpos_e,[10,2,e]);
      return [0,menhir_s,v,startpos_1,endpos_e,menhir_stack$0]}
    function _ac_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       endpos_e=menhir_stack[4],
       e=menhir_stack[2],
       v=loc(startpos_1,endpos_e,[10,1,e]);
      return [0,menhir_s,v,startpos_1,endpos_e,menhir_stack$0]}
    function _ad_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       endpos_e=menhir_stack[4],
       e=menhir_stack[2],
       v=loc(startpos_1,endpos_e,[10,0,e]);
      return [0,menhir_s,v,startpos_1,endpos_e,menhir_stack$0]}
    function _ae_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_e1=match[3],
       e1=match[2],
       menhir_s=match[1],
       endpos_e2=menhir_stack[4],
       e2=menhir_stack[2],
       v=loc(startpos_e1,endpos_e2,[9,15,e1,e2]);
      return [0,menhir_s,v,startpos_e1,endpos_e2,menhir_stack$0]}
    function _af_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_e1=match[3],
       e1=match[2],
       menhir_s=match[1],
       endpos_e2=menhir_stack[4],
       e2=menhir_stack[2],
       v=loc(startpos_e1,endpos_e2,[9,14,e1,e2]);
      return [0,menhir_s,v,startpos_e1,endpos_e2,menhir_stack$0]}
    function _ag_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_e1=match[3],
       e1=match[2],
       menhir_s=match[1],
       endpos_e2=menhir_stack[4],
       e2=menhir_stack[2],
       v=loc(startpos_e1,endpos_e2,[9,13,e1,e2]);
      return [0,menhir_s,v,startpos_e1,endpos_e2,menhir_stack$0]}
    function _ah_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_e1=match[3],
       e1=match[2],
       menhir_s=match[1],
       endpos_e2=menhir_stack[4],
       e2=menhir_stack[2],
       v=loc(startpos_e1,endpos_e2,[9,12,e1,e2]);
      return [0,menhir_s,v,startpos_e1,endpos_e2,menhir_stack$0]}
    function _ai_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_e1=match[3],
       e1=match[2],
       menhir_s=match[1],
       endpos_e2=menhir_stack[4],
       e2=menhir_stack[2],
       v=loc(startpos_e1,endpos_e2,[9,11,e1,e2]);
      return [0,menhir_s,v,startpos_e1,endpos_e2,menhir_stack$0]}
    function _aj_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_e1=match[3],
       e1=match[2],
       menhir_s=match[1],
       endpos_e2=menhir_stack[4],
       e2=menhir_stack[2],
       v=loc(startpos_e1,endpos_e2,[9,10,e1,e2]);
      return [0,menhir_s,v,startpos_e1,endpos_e2,menhir_stack$0]}
    function _ak_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_e1=match[3],
       e1=match[2],
       menhir_s=match[1],
       endpos_e2=menhir_stack[4],
       e2=menhir_stack[2],
       v=loc(startpos_e1,endpos_e2,[9,9,e1,e2]);
      return [0,menhir_s,v,startpos_e1,endpos_e2,menhir_stack$0]}
    function _al_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_e1=match[3],
       e1=match[2],
       menhir_s=match[1],
       endpos_e2=menhir_stack[4],
       e2=menhir_stack[2],
       v=loc(startpos_e1,endpos_e2,[9,8,e1,e2]);
      return [0,menhir_s,v,startpos_e1,endpos_e2,menhir_stack$0]}
    function _am_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_e1=match[3],
       e1=match[2],
       menhir_s=match[1],
       endpos_e2=menhir_stack[4],
       e2=menhir_stack[2],
       v=loc(startpos_e1,endpos_e2,[9,7,e1,e2]);
      return [0,menhir_s,v,startpos_e1,endpos_e2,menhir_stack$0]}
    function _an_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_e1=match[3],
       e1=match[2],
       menhir_s=match[1],
       endpos_e2=menhir_stack[4],
       e2=menhir_stack[2],
       v=loc(startpos_e1,endpos_e2,[9,6,e1,e2]);
      return [0,menhir_s,v,startpos_e1,endpos_e2,menhir_stack$0]}
    function _ao_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_e1=match[3],
       e1=match[2],
       menhir_s=match[1],
       endpos_e2=menhir_stack[4],
       e2=menhir_stack[2],
       v=loc(startpos_e1,endpos_e2,[9,5,e1,e2]);
      return [0,menhir_s,v,startpos_e1,endpos_e2,menhir_stack$0]}
    function _ap_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_e1=match[3],
       e1=match[2],
       menhir_s=match[1],
       endpos_e2=menhir_stack[4],
       e2=menhir_stack[2],
       v=loc(startpos_e1,endpos_e2,[9,4,e1,e2]);
      return [0,menhir_s,v,startpos_e1,endpos_e2,menhir_stack$0]}
    function _aq_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_e1=match[3],
       e1=match[2],
       menhir_s=match[1],
       endpos_e2=menhir_stack[4],
       e2=menhir_stack[2],
       v=loc(startpos_e1,endpos_e2,[9,3,e1,e2]);
      return [0,menhir_s,v,startpos_e1,endpos_e2,menhir_stack$0]}
    function _ar_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_e1=match[3],
       e1=match[2],
       menhir_s=match[1],
       endpos_e2=menhir_stack[4],
       e2=menhir_stack[2],
       v=loc(startpos_e1,endpos_e2,[9,2,e1,e2]);
      return [0,menhir_s,v,startpos_e1,endpos_e2,menhir_stack$0]}
    function _as_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_e1=match[3],
       e1=match[2],
       menhir_s=match[1],
       endpos_e2=menhir_stack[4],
       e2=menhir_stack[2],
       v=loc(startpos_e1,endpos_e2,[9,1,e1,e2]);
      return [0,menhir_s,v,startpos_e1,endpos_e2,menhir_stack$0]}
    function _at_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_e1=match[3],
       e1=match[2],
       menhir_s=match[1],
       endpos_e2=menhir_stack[4],
       e2=menhir_stack[2],
       v=loc(startpos_e1,endpos_e2,[9,0,e1,e2]);
      return [0,menhir_s,v,startpos_e1,endpos_e2,menhir_stack$0]}
    function _au_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _aZ_=menhir_stack[5],
       _a0_=_aZ_[5][5],
       match=_a0_[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       t=_a0_[2],
       e=_aZ_[2],
       endpos_5=menhir_stack[4],
       v=loc(startpos_1,endpos_5,[5,t,e]);
      return [0,menhir_s,v,startpos_1,endpos_5,menhir_stack$0]}
    function _av_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _aX_=menhir_stack[5],
       _aY_=_aX_[5][5][5][5],
       match=_aY_[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       t=_aY_[2],
       xs=_aX_[2],
       endpos_7=menhir_stack[4],
       v=loc(startpos_1,endpos_7,[4,t,xs]);
      return [0,menhir_s,v,startpos_1,endpos_7,menhir_stack$0]}
    function _aw_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _aW_=menhir_stack[5],
       match=_aW_[5][5],
       menhir_stack$0=match[5],
       startpos_e=match[3],
       e=match[2],
       menhir_s=match[1],
       xs=_aW_[2],
       endpos_4=menhir_stack[4],
       v=loc(startpos_e,endpos_4,[8,e,xs]);
      return [0,menhir_s,v,startpos_e,endpos_4,menhir_stack$0]}
    function _ax_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _aV_=menhir_stack[5],
       match=_aV_[5][5],
       menhir_stack$0=match[5],
       startpos_e=match[3],
       e=match[2],
       menhir_s=match[1],
       i=_aV_[2],
       endpos_4=menhir_stack[4],
       v=loc(startpos_e,endpos_4,[7,e,i]);
      return [0,menhir_s,v,startpos_e,endpos_4,menhir_stack$0]}
    function _ay_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_1=menhir_stack[4],
       startpos_1=menhir_stack[3],
       menhir_s=menhir_stack[1],
       v=loc(startpos_1,endpos_1,_az_);
      return [0,menhir_s,v,startpos_1,endpos_1,menhir_stack$0]}
    function _aA_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_1=menhir_stack[4],
       startpos_1=menhir_stack[3],
       menhir_s=menhir_stack[1],
       v=loc(startpos_1,endpos_1,_aB_);
      return [0,menhir_s,v,startpos_1,endpos_1,menhir_stack$0]}
    function _aC_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5][5],
       menhir_stack$0=match[5],
       startpos_t=match[3],
       t=match[2],
       menhir_s=match[1],
       endpos_2=menhir_stack[4],
       t$0=[0,t],
       v=loc(startpos_t,endpos_2,[0,t$0]);
      return [0,menhir_s,v,startpos_t,endpos_2,menhir_stack$0]}
    function _aD_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       endpos_2=menhir_stack[4],
       v=loc(startpos_1,endpos_2,[0,0]);
      return [0,menhir_s,v,startpos_1,endpos_2,menhir_stack$0]}
    function _aE_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_s=menhir_stack[4],
       startpos_s=menhir_stack[3],
       s=menhir_stack[2],
       menhir_s=menhir_stack[1],
       v=loc(startpos_s,endpos_s,[3,s]);
      return [0,menhir_s,v,startpos_s,endpos_s,menhir_stack$0]}
    function _aF_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_i=menhir_stack[4],
       startpos_i=menhir_stack[3],
       i=menhir_stack[2],
       menhir_s=menhir_stack[1],
       v=loc(startpos_i,endpos_i,[2,i]);
      return [0,menhir_s,v,startpos_i,endpos_i,menhir_stack$0]}
    function _aG_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_id=menhir_stack[4],
       startpos_id=menhir_stack[3],
       id=menhir_stack[2],
       menhir_s=menhir_stack[1],
       v=loc(startpos_id,endpos_id,[6,id]);
      return [0,menhir_s,v,startpos_id,endpos_id,menhir_stack$0]}
    function _aH_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       endpos_ifs=menhir_stack[4],
       ifs=menhir_stack[2],
       v=[0,ifs,0];
      return [0,menhir_s,v,startpos_1,endpos_ifs,menhir_stack$0]}
    function _aI_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       endpos_b=menhir_stack[4],
       b=menhir_stack[2];
      return [0,menhir_s,b,startpos_1,endpos_b,menhir_stack$0]}
    function _aJ_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_s=menhir_env[4],
       startpos=menhir_stack[4];
      return [0,menhir_s,0,startpos,startpos,menhir_stack]}
    function _aK_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _aT_=menhir_stack[5][5],
       _aU_=_aT_[5][5],
       match=_aU_[5],
       menhir_stack$0=match[5],
       startpos_t=match[3],
       t=match[2],
       menhir_s=match[1],
       fname=_aU_[2],
       args=_aT_[2],
       endpos_body=menhir_stack[4],
       body=menhir_stack[2],
       frtyp=[0,t],
       v=[1,loc(startpos_t,endpos_body,[0,frtyp,fname,args,body])];
      return [0,menhir_s,v,startpos_t,endpos_body,menhir_stack$0]}
    function _aL_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _aR_=menhir_stack[5][5],
       _aS_=_aR_[5][5],
       match=_aS_[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       fname=_aS_[2],
       args=_aR_[2],
       endpos_body=menhir_stack[4],
       body=menhir_stack[2],
       v=[1,loc(startpos_1,endpos_body,[0,0,fname,args,body])];
      return [0,menhir_s,v,startpos_1,endpos_body,menhir_stack$0]}
    function _aM_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _aP_=menhir_stack[5],
       _aQ_=_aP_[5][5],
       match=_aQ_[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       name=_aQ_[2],
       init=_aP_[2],
       endpos_5=menhir_stack[4],
       v=[0,loc(startpos_1,endpos_5,[0,name,init])];
      return [0,menhir_s,v,startpos_1,endpos_5,menhir_stack$0]}
    function _aN_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _aO_=menhir_stack[5],
       match=_aO_[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       stmts=_aO_[2],
       endpos_3=menhir_stack[4];
      return [0,menhir_s,stmts,startpos_1,endpos_3,menhir_stack$0]}
    var
     semantic_action=
      [0,
       function(menhir_env)
        {var
          menhir_stack=menhir_env[3],
          menhir_stack$0=menhir_stack[5],
          endpos_xs=menhir_stack[4],
          startpos_xs=menhir_stack[3],
          xs=menhir_stack[2],
          menhir_s=menhir_stack[1];
         return [0,menhir_s,xs,startpos_xs,endpos_xs,menhir_stack$0]},
       _aN_,
       _aM_,
       _aL_,
       _aK_,
       _aJ_,
       _aI_,
       _aH_,
       _aG_,
       _aF_,
       _aE_,
       _aD_,
       _aC_,
       _aA_,
       _ay_,
       _ax_,
       _aw_,
       _av_,
       _au_,
       _at_,
       _as_,
       _ar_,
       _aq_,
       _ap_,
       _ao_,
       _an_,
       _am_,
       _al_,
       _ak_,
       _aj_,
       _ai_,
       _ah_,
       _ag_,
       _af_,
       _ae_,
       _ad_,
       _ac_,
       _ab_,
       _aa_,
       _$_,
       ___,
       _Z_,
       _Y_,
       _X_,
       _W_,
       _V_,
       _T_,
       _R_,
       _Q_,
       _P_,
       _O_,
       _N_,
       _M_,
       _L_,
       _K_,
       _J_,
       _I_,
       _H_,
       _G_,
       _F_,
       _E_,
       _D_,
       _C_,
       _B_,
       _A_,
       _z_,
       _y_,
       _x_,
       _w_,
       _v_,
       _u_,
       _t_,
       _s_,
       _r_,
       _q_,
       _p_,
       _o_,
       _m_,
       _l_,
       _k_,
       _j_,
       _i_,
       _h_,
       _g_,
       _f_,
       _e_,
       _d_,
       _c_,
       _b_,
       _a_],
     ET=
      caml_call1
       (MenhirLib[15][1],
        [0,
         token2terminal,
         error_terminal,
         token2value,
         default_reduction,
         error,
         action,
         lhs,
         goto$0,
         start,
         semantic_action,
         Error,
         0]),
     TI=caml_call1(MenhirLib[5][1],ET),
     entry=TI[2],
     offer=TI[3],
     resume=TI[4],
     lexer_lexbuf_to_supplier=TI[5],
     loop=TI[6],
     loop_handle=TI[7],
     loop_handle_undo=TI[8],
     shifts=TI[9],
     acceptable=TI[10],
     number=TI[11],
     production_index=TI[12],
     find_production=TI[13],
     stack=TI[14],
     top=TI[15],
     pop_many=TI[16],
     get=TI[17],
     current_state_number=TI[18],
     equal=TI[19],
     positions=TI[20],
     env_has_default_reduction=TI[21],
     state_has_default_reduction=TI[22],
     pop=TI[23],
     force_reduction=TI[24],
     input_needed=TI[25],
     start$0=TI[26];
    function stmt_top(lexer,lexbuf){return caml_call3(entry,189,lexer,lexbuf)}
    function prog(lexer,lexbuf){return caml_call3(entry,78,lexer,lexbuf)}
    function exp_top(lexer,lexbuf){return caml_call3(entry,0,lexer,lexbuf)}
    function stmt_top$0(initial_position)
     {return caml_call2(start$0,189,initial_position)}
    function prog$0(initial_position)
     {return caml_call2(start$0,78,initial_position)}
    function exp_top$0(initial_position)
     {return caml_call2(start$0,0,initial_position)}
    var
     Incremental=[0,stmt_top$0,prog$0,exp_top$0],
     Parser=
      [0,
       Error,
       stmt_top,
       prog,
       exp_top,
       [0,
        offer,
        resume,
        lexer_lexbuf_to_supplier,
        loop,
        loop_handle,
        loop_handle_undo,
        shifts,
        acceptable,
        number,
        production_index,
        find_production,
        stack,
        top,
        pop_many,
        get,
        current_state_number,
        equal,
        positions,
        env_has_default_reduction,
        state_has_default_reduction,
        pop,
        force_reduction,
        input_needed],
       Incremental];
    runtime.caml_register_global(13,Parser,"Parser");
    return}
  (function(){return this}()));


//# 1 ".server.eobjs/byte/lexer.cmo.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_bytes_set=runtime.caml_bytes_set,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_int_of_string=runtime.caml_int_of_string,
     caml_list_of_js_array=runtime.caml_list_of_js_array,
     caml_new_string=runtime.caml_new_string,
     caml_trampoline=runtime.caml_trampoline,
     caml_trampoline_return=runtime.caml_trampoline_return;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_Lexer_Lexer_error=caml_new_string("Lexer.Lexer_error"),
     reserved_words=
      caml_list_of_js_array
       ([[0,caml_new_string("null"),19],
         [0,caml_new_string("true"),4],
         [0,caml_new_string("false"),34],
         [0,caml_new_string("void"),2],
         [0,caml_new_string("bool"),7],
         [0,caml_new_string("int"),5],
         [0,caml_new_string("string"),3],
         [0,caml_new_string("new"),20],
         [0,caml_new_string("else"),38],
         [0,caml_new_string("if"),28],
         [0,caml_new_string("while"),0],
         [0,caml_new_string("for"),33],
         [0,caml_new_string("return"),14],
         [0,caml_new_string("var"),1],
         [0,caml_new_string("global"),32],
         [0,caml_new_string(";"),11],
         [0,caml_new_string(","),40],
         [0,caml_new_string("{"),26],
         [0,caml_new_string("}"),16],
         [0,caml_new_string("("),24],
         [0,caml_new_string(")"),13],
         [0,caml_new_string("["),25],
         [0,caml_new_string("]"),15],
         [0,caml_new_string("="),36],
         [0,caml_new_string("+"),17],
         [0,caml_new_string("-"),39],
         [0,caml_new_string("*"),8],
         [0,caml_new_string("=="),35],
         [0,caml_new_string("!="),21],
         [0,caml_new_string("<"),23],
         [0,caml_new_string("<="),22],
         [0,caml_new_string(">"),31],
         [0,caml_new_string(">="),30],
         [0,caml_new_string("&"),42],
         [0,caml_new_string("|"),18],
         [0,caml_new_string("[&]"),29],
         [0,caml_new_string("[|]"),27],
         [0,caml_new_string("<<"),10],
         [0,caml_new_string(">>"),9],
         [0,caml_new_string(">>>"),12],
         [0,caml_new_string("!"),41],
         [0,caml_new_string("~"),6]]),
     ocaml_lex_tables=
      [0,
       caml_new_string
        ("\0\0\xf6\xff\xf7\xff\x02\0\x05\0\b\0\x06\0\x07\0\x01\0\xf8\xff\x05\0\x15\0\x1f\0W\0\xfc\xff\xfd\xff\x10\0\xff\xff\xfe\xff\xa2\0\xb9\0\x01\0\x02\0\x1b\0\0\x01\xfb\xff\x02\0\xfc\xff\xfd\xff\xde\0\x07\0V\0\xfb\xff\xfc\xff\xfd\xff0\0-\0\xff\xff\xfe\xff\xd2\0\xfb\xff\xfc\xff\xfd\xff\xfe\xff\xff\xff\x18\x01\xf9\xff\xf3\0\xfb\xff\xfc\xff\xfd\xff\xfe\xff\xff\xff'\x01\xfa\xff"),
       caml_new_string
        ("\xff\xff\xff\xff\xff\xff\b\0\b\0\b\0\b\0\b\0\x07\0\xff\xff\x06\0\x05\0\x05\0\x04\0\xff\xff\xff\xff\t\0\xff\xff\xff\xff\xff\xff\x05\0\xff\xff\xff\xff\b\0\xff\xff\xff\xff\x03\0\xff\xff\xff\xff\x01\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\x02\0\x02\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x06\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"),
       caml_new_string
        ('\x01\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\xff\xff\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x19\0\0\0\xff\xff\0\0\0\0\xff\xff\xff\xff"\0\0\0\0\0\0\0\xff\xff\xff\xff\0\0\0\0(\0\0\0\0\0\0\0\0\0\0\0.\0\0\0\xff\xff\0\0\0\0\0\0\0\0\0\0\xff\xff\0\0'),
       caml_new_string
        ("\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\n\0\t\0\t\0\x1b\0\b\0\n\0\0\0\x1e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\n\0\x06\0\x0f\0\x0e\0\0\0\n\0\x02\0\x1e\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x16\0\x10\0\f\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x12\0\x02\0\x04\0\x07\0\x03\0\x02\0\x17\0\x02\0\x02\0\x02\0\x02\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x02\0&\0\x05\0%\0\x02\0\x02\0\x02\0!\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\x02\0\x02\0\x02\0\x02\0\0\0$\0\0\0\0\0\0\0\x15\0#\0\0\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\0\0\0\0\0\0\0\0\r\0\0\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\0\0,\0\0\0\0\0\0\0\0\0\0\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x11\0\0\0\0\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x1e\0\x1b\0\0\0\0\0\x1a\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\0\0\0\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x1e\0\0\0\x1c\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\0\0\0+\0\0\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\x001\0\0\0\0\0\0\0\0\x000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\0\0\0\0\0\0\0\0 \x006\x006\x006\x006\x006\x006\x006\x006\x006\x006\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x004\0\0\0\0\0\0\0\0\0\0\x003\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0)\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
       caml_new_string
        ("\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\b\0\x1a\0\0\0\n\0\xff\xff\x1e\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0\xff\xff\n\0\0\0\x1e\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\x03\0\x03\0\x04\0\x04\0\x06\0\x07\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\x17\0#\0\0\0$\0\0\0\x15\0\x16\0\x1f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\x1f\0\xff\xff\xff\xff\xff\xff\x05\0\x1f\0\xff\xff\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\f\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\xff\xff\xff\xff\xff\xff\xff\xff\r\0\xff\xff\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0'\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\xff\xff'\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\0\0\xff\xff\xff\xff\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x18\0\x18\0\xff\xff\xff\xff\x18\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\xff\xff\xff\xff\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x18\0\xff\xff\x18\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\xff\xff'\0\xff\xff\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0-\0\xff\xff\xff\xff\xff\xff\xff\xff-\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0\xff\xff\xff\xff\xff\xff\xff\xff\x1f\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff-\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff-\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff-\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff'\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x18\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff-\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"),
       caml_new_string(""),
       caml_new_string(""),
       caml_new_string(""),
       caml_new_string(""),
       caml_new_string(""),
       caml_new_string("")],
     Lexing=global_data.Lexing,
     Printf=global_data.Printf,
     Char=global_data.Char,
     Bytes=global_data.Bytes,
     Range=global_data.Range,
     Hashtbl=global_data.Hashtbl,
     List=global_data.List,
     Lexer_error=[248,cst_Lexer_Lexer_error,runtime.caml_fresh_oo_id(0)],
     _c_=
      [0,
       [11,caml_new_string("# can only be the 1st char in a line."),0],
       caml_new_string("# can only be the 1st char in a line.")],
     _d_=
      [0,
       [11,caml_new_string("Illegal directives"),0],
       caml_new_string("Illegal directives")],
     _e_=
      [0,
       [11,caml_new_string("Illegal directives"),0],
       caml_new_string("Illegal directives")],
     _f_=
      [0,
       [11,caml_new_string("Illegal directives"),0],
       caml_new_string("Illegal directives")],
     _g_=
      [0,
       [11,caml_new_string("Illegal directives"),0],
       caml_new_string("Illegal directives")],
     _h_=
      [0,
       [11,caml_new_string("comments are not closed"),0],
       caml_new_string("comments are not closed")],
     _i_=
      [0,
       [11,caml_new_string("String is not terminated"),0],
       caml_new_string("String is not terminated")],
     _j_=
      [0,
       [2,
        0,
        [11,caml_new_string(" is an illegal escaped character constant"),0]],
       caml_new_string("%s is an illegal escaped character constant")],
     _k_=
      [0,
       [2,
        0,
        [11,caml_new_string(" is an illegal escaped character constant"),0]],
       caml_new_string("%s is an illegal escaped character constant")],
     _a_=
      [0,
       [11,caml_new_string("Unexpected character: '"),[0,[12,39,0]]],
       caml_new_string("Unexpected character: '%c'")];
    function reset_lexbuf(filename,lnum,lexbuf)
     {lexbuf[12] = [0,filename,lnum,0,0];return 0}
    function newline(lexbuf)
     {var
       init=caml_call1(Lexing[10],lexbuf),
       _P_=init[4],
       _Q_=caml_call1(Lexing[8],lexbuf),
       _R_=caml_call1(Lexing[10],lexbuf)[2] + 1 | 0;
      lexbuf[12] = [0,init[1],_R_,_Q_,_P_];
      return 0}
    function unexpected_char(lexbuf,c)
     {var _O_=caml_call2(Printf[4],_a_,c);
      throw [0,Lexer_error,caml_call1(Range[14],lexbuf),_O_]}
    var symbol_table=caml_call2(Hashtbl[1],0,1024);
    function _b_(param)
     {var t=param[2],str=param[1];
      return caml_call3(Hashtbl[5],symbol_table,str,t)}
    caml_call2(List[15],_b_,reserved_words);
    function create_token(lexbuf)
     {var str=caml_call1(Lexing[5],lexbuf);
      try
       {var _M_=caml_call2(Hashtbl[6],symbol_table,str);return _M_}
      catch(_N_){return [2,str]}}
    var
     string_buffer=[0,caml_create_bytes(2048)],
     string_end=[0,0],
     start_lex=[0,caml_call1(Range[5],Range[11])];
    function start_pos_of_lexbuf(lexbuf)
     {var _L_=caml_call1(Lexing[9],lexbuf);return caml_call1(Range[12],_L_)}
    function lex_long_range(lexbuf)
     {var end_p=caml_call1(Lexing[10],lexbuf),_K_=caml_call1(Range[12],end_p);
      return caml_call3(Range[7],end_p[1],start_lex[1],_K_)}
    function reset_str(param){string_end[1] = 0;return 0}
    function add_str(ch)
     {var x=string_end[1],buffer=string_buffer[1];
      if(x === runtime.caml_ml_bytes_length(buffer))
       {var new_buffer=caml_create_bytes(x * 2 | 0);
        caml_call5(Bytes[11],buffer,0,new_buffer,0,x);
        caml_bytes_set(new_buffer,x,ch);
        string_buffer[1] = new_buffer;
        string_end[1] = x + 1 | 0;
        return 0}
      caml_bytes_set(buffer,x,ch);
      string_end[1] = x + 1 | 0;
      return 0}
    function get_str(param)
     {return caml_call3(Bytes[8],string_buffer[1],0,string_end[1])}
    var lnum=[0,1];
    function token$0(counter,lexbuf)
     {var _J_=0;
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return ocaml_lex_token_rec$0(counter$0,lexbuf,_J_)}
      return caml_trampoline_return(ocaml_lex_token_rec$0,[0,lexbuf,_J_])}
    function ocaml_lex_token_rec$0(counter,lexbuf,ocaml_lex_state)
     {var ocaml_lex_state$0=ocaml_lex_state;
      for(;;)
       {var
         ocaml_lex_state$1=
          caml_call3(Lexing[17],ocaml_lex_tables,ocaml_lex_state$0,lexbuf);
        if(9 < ocaml_lex_state$1 >>> 0)
         {caml_call1(lexbuf[1],lexbuf);
          var ocaml_lex_state$0=ocaml_lex_state$1;
          continue}
        switch(ocaml_lex_state$1)
         {case 0:return 37;
          case 1:
           start_lex[1] = start_pos_of_lexbuf(lexbuf);
           var _F_=0;
           if(counter < 50)
            {var counter$1=counter + 1 | 0;
             return comments$0(counter$1,_F_,lexbuf)}
           return caml_trampoline_return(comments$0,[0,_F_,lexbuf]);
          case 2:
           reset_str(0);
           start_lex[1] = start_pos_of_lexbuf(lexbuf);
           var _G_=0;
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return string$0(counter$0,_G_,lexbuf)}
           return caml_trampoline_return(string$0,[0,_G_,lexbuf]);
          case 3:
           var p=caml_call1(Lexing[9],lexbuf);
           if(0 === (p[4] - p[3] | 0))
            {var _H_=0;
             if(counter < 50)
              {var counter$2=counter + 1 | 0;
               return directive$0(counter$2,_H_,lexbuf)}
             return caml_trampoline_return(directive$0,[0,_H_,lexbuf])}
           var _I_=caml_call1(Printf[4],_c_);
           throw [0,Lexer_error,lex_long_range(lexbuf),_I_];
          case 4:return create_token(lexbuf);
          case 5:
           return [1,
                   runtime.caml_int64_of_string(caml_call1(Lexing[5],lexbuf))];
          case 6:
           if(counter < 50)
            {var counter$3=counter + 1 | 0;return token$0(counter$3,lexbuf)}
           return caml_trampoline_return(token$0,[0,lexbuf]);
          case 7:
           newline(lexbuf);
           if(counter < 50)
            {var counter$4=counter + 1 | 0;return token$0(counter$4,lexbuf)}
           return caml_trampoline_return(token$0,[0,lexbuf]);
          case 8:return create_token(lexbuf);
          default:
           var c=caml_call2(Lexing[15],lexbuf,lexbuf[5]);
           return unexpected_char(lexbuf,c)}}}
    function directive$0(counter,state,lexbuf)
     {var _E_=24;
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return ocaml_lex_directive_rec$0(counter$0,state,lexbuf,_E_)}
      return caml_trampoline_return
              (ocaml_lex_directive_rec$0,[0,state,lexbuf,_E_])}
    function ocaml_lex_directive_rec$0(counter,state,lexbuf,ocaml_lex_state)
     {var ocaml_lex_state$0=ocaml_lex_state;
      for(;;)
       {var
         ocaml_lex_state$1=
          caml_call3(Lexing[17],ocaml_lex_tables,ocaml_lex_state$0,lexbuf);
        if(4 < ocaml_lex_state$1 >>> 0)
         {caml_call1(lexbuf[1],lexbuf);
          var ocaml_lex_state$0=ocaml_lex_state$1;
          continue}
        switch(ocaml_lex_state$1)
         {case 0:
           if(counter < 50)
            {var counter$1=counter + 1 | 0;
             return directive$0(counter$1,state,lexbuf)}
           return caml_trampoline_return(directive$0,[0,state,lexbuf]);
          case 1:
           if(0 === state)
            {lnum[1] = caml_int_of_string(caml_call1(Lexing[5],lexbuf));
             var _w_=1;
             if(counter < 50)
              {var counter$2=counter + 1 | 0;
               return directive$0(counter$2,_w_,lexbuf)}
             return caml_trampoline_return(directive$0,[0,_w_,lexbuf])}
           if(2 === state)
            {var _x_=3;
             if(counter < 50)
              {var counter$3=counter + 1 | 0;
               return directive$0(counter$3,_x_,lexbuf)}
             return caml_trampoline_return(directive$0,[0,_x_,lexbuf])}
           var _y_=caml_call1(Printf[4],_d_);
           throw [0,Lexer_error,lex_long_range(lexbuf),_y_];
          case 2:
           if(1 === state)
            {reset_str(0);
             start_lex[1] = start_pos_of_lexbuf(lexbuf);
             var _z_=1;
             if(counter < 50)
              {var counter$0=counter + 1 | 0;
               return string$0(counter$0,_z_,lexbuf)}
             return caml_trampoline_return(string$0,[0,_z_,lexbuf])}
           var _A_=caml_call1(Printf[4],_e_);
           throw [0,Lexer_error,lex_long_range(lexbuf),_A_];
          case 3:
           if(2 !== state)
            if(3 !== state)
             {var _C_=caml_call1(Printf[4],_f_);
              throw [0,Lexer_error,lex_long_range(lexbuf),_C_]}
           var _B_=lnum[1];
           reset_lexbuf(get_str(0),_B_,lexbuf);
           if(counter < 50)
            {var counter$4=counter + 1 | 0;return token$0(counter$4,lexbuf)}
           return caml_trampoline_return(token$0,[0,lexbuf]);
          default:
           var _D_=caml_call1(Printf[4],_g_);
           throw [0,Lexer_error,lex_long_range(lexbuf),_D_]}}}
    function comments$0(counter,level,lexbuf)
     {var _v_=31;
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return ocaml_lex_comments_rec$0(counter$0,level,lexbuf,_v_)}
      return caml_trampoline_return
              (ocaml_lex_comments_rec$0,[0,level,lexbuf,_v_])}
    function ocaml_lex_comments_rec$0(counter,level,lexbuf,ocaml_lex_state)
     {var ocaml_lex_state$0=ocaml_lex_state;
      for(;;)
       {var
         ocaml_lex_state$1=
          caml_call3(Lexing[17],ocaml_lex_tables,ocaml_lex_state$0,lexbuf);
        if(4 < ocaml_lex_state$1 >>> 0)
         {caml_call1(lexbuf[1],lexbuf);
          var ocaml_lex_state$0=ocaml_lex_state$1;
          continue}
        switch(ocaml_lex_state$1)
         {case 0:
           if(0 === level)
            {if(counter < 50)
              {var counter$4=counter + 1 | 0;return token$0(counter$4,lexbuf)}
             return caml_trampoline_return(token$0,[0,lexbuf])}
           var _s_=level - 1 | 0;
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return comments$0(counter$0,_s_,lexbuf)}
           return caml_trampoline_return(comments$0,[0,_s_,lexbuf]);
          case 1:
           var _t_=level + 1 | 0;
           if(counter < 50)
            {var counter$1=counter + 1 | 0;
             return comments$0(counter$1,_t_,lexbuf)}
           return caml_trampoline_return(comments$0,[0,_t_,lexbuf]);
          case 2:
           if(counter < 50)
            {var counter$2=counter + 1 | 0;
             return comments$0(counter$2,level,lexbuf)}
           return caml_trampoline_return(comments$0,[0,level,lexbuf]);
          case 3:
           newline(lexbuf);
           if(counter < 50)
            {var counter$3=counter + 1 | 0;
             return comments$0(counter$3,level,lexbuf)}
           return caml_trampoline_return(comments$0,[0,level,lexbuf]);
          default:
           var _u_=caml_call1(Printf[4],_h_);
           throw [0,Lexer_error,lex_long_range(lexbuf),_u_]}}}
    function string$0(counter,in_directive,lexbuf)
     {var _r_=39;
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return ocaml_lex_string_rec$0(counter$0,in_directive,lexbuf,_r_)}
      return caml_trampoline_return
              (ocaml_lex_string_rec$0,[0,in_directive,lexbuf,_r_])}
    function ocaml_lex_string_rec$0
     (counter,in_directive,lexbuf,ocaml_lex_state)
     {var ocaml_lex_state$0=ocaml_lex_state;
      for(;;)
       {var
         ocaml_lex_state$1=
          caml_call3(Lexing[17],ocaml_lex_tables,ocaml_lex_state$0,lexbuf);
        if(4 < ocaml_lex_state$1 >>> 0)
         {caml_call1(lexbuf[1],lexbuf);
          var ocaml_lex_state$0=ocaml_lex_state$1;
          continue}
        switch(ocaml_lex_state$1)
         {case 0:
           if(0 === in_directive)return [0,get_str(0)];
           var _p_=2;
           if(counter < 50)
            {var counter$3=counter + 1 | 0;
             return directive$0(counter$3,_p_,lexbuf)}
           return caml_trampoline_return(directive$0,[0,_p_,lexbuf]);
          case 1:
           add_str(escaped(lexbuf));
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return string$0(counter$0,in_directive,lexbuf)}
           return caml_trampoline_return(string$0,[0,in_directive,lexbuf]);
          case 2:
           add_str(10);
           newline(lexbuf);
           if(counter < 50)
            {var counter$1=counter + 1 | 0;
             return string$0(counter$1,in_directive,lexbuf)}
           return caml_trampoline_return(string$0,[0,in_directive,lexbuf]);
          case 3:
           var _q_=caml_call1(Printf[4],_i_);
           throw [0,Lexer_error,lex_long_range(lexbuf),_q_];
          default:
           add_str(caml_call2(Lexing[6],lexbuf,0));
           if(counter < 50)
            {var counter$2=counter + 1 | 0;
             return string$0(counter$2,in_directive,lexbuf)}
           return caml_trampoline_return(string$0,[0,in_directive,lexbuf])}}}
    function token(lexbuf){return caml_trampoline(token$0(0,lexbuf))}
    function ocaml_lex_token_rec(lexbuf,ocaml_lex_state)
     {return caml_trampoline(ocaml_lex_token_rec$0(0,lexbuf,ocaml_lex_state))}
    function directive(state,lexbuf)
     {return caml_trampoline(directive$0(0,state,lexbuf))}
    function ocaml_lex_directive_rec(state,lexbuf,ocaml_lex_state)
     {return caml_trampoline
              (ocaml_lex_directive_rec$0(0,state,lexbuf,ocaml_lex_state))}
    function comments(level,lexbuf)
     {return caml_trampoline(comments$0(0,level,lexbuf))}
    function ocaml_lex_comments_rec(level,lexbuf,ocaml_lex_state)
     {return caml_trampoline
              (ocaml_lex_comments_rec$0(0,level,lexbuf,ocaml_lex_state))}
    function string(in_directive,lexbuf)
     {return caml_trampoline(string$0(0,in_directive,lexbuf))}
    function ocaml_lex_string_rec(in_directive,lexbuf,ocaml_lex_state)
     {return caml_trampoline
              (ocaml_lex_string_rec$0(0,in_directive,lexbuf,ocaml_lex_state))}
    function ocaml_lex_escaped_rec(lexbuf,ocaml_lex_state)
     {var ocaml_lex_state$0=ocaml_lex_state;
      for(;;)
       {var
         ocaml_lex_state$1=
          caml_call3(Lexing[17],ocaml_lex_tables,ocaml_lex_state$0,lexbuf);
        if(6 < ocaml_lex_state$1 >>> 0)
         {caml_call1(lexbuf[1],lexbuf);
          var ocaml_lex_state$0=ocaml_lex_state$1;
          continue}
        switch(ocaml_lex_state$1)
         {case 0:return 10;
          case 1:return 9;
          case 2:return 92;
          case 3:return 34;
          case 4:return 39;
          case 5:
           var x=caml_int_of_string(caml_call1(Lexing[5],lexbuf));
           if(255 < x)
            {var
              _l_=caml_call1(Lexing[5],lexbuf),
              _m_=caml_call2(Printf[4],_j_,_l_);
             throw [0,Lexer_error,lex_long_range(lexbuf),_m_]}
           return caml_call1(Char[1],x);
          default:
           var
            _n_=caml_call1(Lexing[5],lexbuf),
            _o_=caml_call2(Printf[4],_k_,_n_);
           throw [0,Lexer_error,lex_long_range(lexbuf),_o_]}}}
    function escaped(lexbuf){return ocaml_lex_escaped_rec(lexbuf,45)}
    var
     Lexer=
      [0,
       Lexer_error,
       reset_lexbuf,
       newline,
       unexpected_char,
       reserved_words,
       symbol_table,
       create_token,
       string_buffer,
       string_end,
       start_lex,
       start_pos_of_lexbuf,
       lex_long_range,
       reset_str,
       add_str,
       get_str,
       lnum,
       ocaml_lex_tables,
       token,
       ocaml_lex_token_rec,
       directive,
       ocaml_lex_directive_rec,
       comments,
       ocaml_lex_comments_rec,
       string,
       ocaml_lex_string_rec,
       escaped,
       ocaml_lex_escaped_rec];
    runtime.caml_register_global(20,Lexer,"Lexer");
    return}
  (function(){return this}()));


//# 1 ".server.eobjs/byte/server.cmo.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_equal=runtime.caml_equal,
     caml_new_string=runtime.caml_new_string;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    var
     global_data=runtime.caml_get_global_data(),
     Range=global_data.Range,
     Lexer=global_data.Lexer,
     Parser=global_data.Parser,
     Array=global_data.Array,
     List=global_data.List,
     Printf=global_data.Printf,
     Lexing=global_data.Lexing,
     Js_of_ocaml_Js=global_data.Js_of_ocaml__Js,
     _a_=
      [0,
       [11,caml_new_string("Parse error at: "),[2,0,[12,10,0]]],
       caml_new_string("Parse error at: %s\n")],
     I=0;
    function succeed(param){return 0}
    function recover_from_error(supplier)
     {for(;;)
       {var _r_=caml_call1(supplier,0),_s_=_r_[1];
        if(typeof _s_ === "number")
         {if(11 === _s_)return 0;
          if(26 === _s_)
           {var depth=1;
            for(;;)
             {if(0 === depth)return 0;
              var _p_=caml_call1(supplier,0),_q_=_p_[1];
              if(typeof _q_ === "number")
               {if(16 === _q_)
                 {var depth$0=depth - 1 | 0,depth=depth$0;continue}
                if(26 === _q_)
                 {var depth$1=depth + 1 | 0,depth=depth$1;continue}}
              var stop=_p_[3],start=_p_[2];
              if(caml_equal(start,stop))return 0;
              continue}}}
        var stop$0=_r_[3],start$0=_r_[2];
        if(caml_equal(start$0,stop$0))return 0;
        continue}}
    function fail(lexbuf,backed_up,param)
     {var
       match=caml_call1(Range[14],lexbuf),
       b=match[3],
       a=match[2],
       supplier=caml_call2(Parser[5][3],Lexer[18],lexbuf);
      recover_from_error(supplier);
      function _m_(_n_,_o_){return fail(lexbuf,_n_,_o_)}
      return [0,
              [0,a,b],
              caml_call4(Parser[5][6],succeed,_m_,supplier,backed_up)]}
    function find_errors(contents)
     {var
       lexbuf=caml_call1(Lexing[3],contents),
       result=caml_call1(Parser[6][2],lexbuf[12]),
       supplier=caml_call2(Parser[5][3],Lexer[18],lexbuf);
      function _j_(_k_,_l_){return fail(lexbuf,_k_,_l_)}
      return caml_call4(Parser[5][6],succeed,_j_,supplier,result)}
    function filter_map(l)
     {var l$0=l;
      for(;;)
       {if(l$0)
         {var _i_=l$0[1];
          if(_i_){var tl=l$0[2],x=_i_[1];return [0,x,filter_map(tl)]}
          var l$1=l$0[2],l$0=l$1;
          continue}
        return 0}}
    function print_error(loc)
     {var _h_=caml_call1(Range[9],loc);return caml_call2(Printf[2],_a_,_h_)}
    function js_of_range(loc)
     {function js_of_pos(pos)
       {var char$0=pos[2],line=pos[1];return {"line":line,"char":char$0}}
      var finish=loc[2],start=loc[1],_g_=js_of_pos(finish);
      return {"start":js_of_pos(start),"finish":_g_}}
    function main(files)
     {var
       _b_=caml_call1(Array[11],runtime.caml_js_to_array(files)),
       _c_=caml_call2(List[17],runtime.caml_js_to_string,_b_),
       _d_=caml_call2(List[17],find_errors,_c_),
       _e_=caml_call1(List[14],_d_),
       _f_=caml_call2(List[17],js_of_range,_e_);
      return runtime.caml_js_from_array(caml_call1(Array[12],_f_))}
    function t5(param,files){return main(files)}
    caml_call1
     (Js_of_ocaml_Js[49],{"compile":runtime.caml_js_wrap_meth_callback(t5)});
    var
     Server=
      [0,
       I,
       succeed,
       recover_from_error,
       fail,
       find_errors,
       filter_map,
       print_error,
       js_of_range,
       main];
    runtime.caml_register_global(23,Server,"Server");
    return}
  (function(){return this}()));


//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJzZXJ2ZXIuYmMuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiY2FtbF9pbnQ2NF9pc196ZXJvIiwieCIsImNhbWxfc3RyX3JlcGVhdCIsIm4iLCJzIiwiciIsImwiLCJjYW1sX2ludDY0X29mX2ludDMyIiwiY2FtbF9vYmpfZHVwIiwiYSIsIkFycmF5IiwiaSIsImNhbWxfaW50NjRfc3ViIiwieSIsInoxIiwiejIiLCJ6MyIsImNhbWxfaW50NjRfdWNvbXBhcmUiLCJjYW1sX2ludDY0X2xzbDEiLCJjYW1sX2ludDY0X2xzcjEiLCJjYW1sX2ludDY0X3VkaXZtb2QiLCJvZmZzZXQiLCJtb2R1bHVzIiwiZGl2aXNvciIsInF1b3RpZW50IiwiY2FtbF9pbnQ2NF90b19pbnQzMiIsImNhbWxfaW50NjRfaXNfbmVnYXRpdmUiLCJjYW1sX2ludDY0X25lZyIsInkxIiwieTIiLCJ5MyIsInJhd19hcnJheV9zdWIiLCJiIiwiaiIsImNhbWxfc3ViYXJyYXlfdG9fc3RyaW5nIiwibGVuIiwiZiIsIlN0cmluZyIsIm51bGwiLCJNYXRoIiwiY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyIsImNhbWxfanNieXRlc19vZl9zdHJpbmciLCJjYW1sX3JhaXNlX3dpdGhfYXJnIiwidGFnIiwiYXJnIiwiY2FtbF9pc19hc2NpaSIsImNhbWxfdXRmMTZfb2ZfdXRmOCIsInQiLCJjIiwiYzEiLCJjMiIsInYiLCJjYW1sX3RvX2pzX3N0cmluZyIsIk1sQnl0ZXMiLCJjb250ZW50cyIsImxlbmd0aCIsInRoaXMiLCJjb250ZW50IiwiY2FtbF9uZXdfc3RyaW5nIiwiY2FtbF9yYWlzZV93aXRoX3N0cmluZyIsIm1zZyIsImNhbWxfZ2xvYmFsX2RhdGEiLCJjYW1sX2ludmFsaWRfYXJndW1lbnQiLCJjYW1sX3BhcnNlX2Zvcm1hdCIsImZtdCIsImNhbWxfZmluaXNoX2Zvcm1hdHRpbmciLCJyYXdidWZmZXIiLCJidWZmZXIiLCJjYW1sX2ludDY0X2Zvcm1hdCIsIndiYXNlIiwiY3Z0YmwiLCJwIiwiY2FtbF9leHBtMV9mbG9hdCIsInoiLCJqb29fZ2xvYmFsX29iamVjdCIsImNhbWxfY3VycmVudF9kaXIiLCJjYW1sX21ha2VfcGF0aCIsIm5hbWUiLCJjb21wIiwibmNvbXAiLCJjYW1sX3JhaXNlX3N5c19lcnJvciIsImNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlIiwiY2FtbF9zdHJpbmdfb2ZfYXJyYXkiLCJjYW1sX3N0cmluZ19ib3VuZF9lcnJvciIsImNhbWxfYnl0ZXNfdW5zYWZlX2dldCIsImNhbWxfYnl0ZXNfZ2V0IiwiY2FtbF9jcmVhdGVfYnl0ZXMiLCJjYW1sX21sX2J5dGVzX2xlbmd0aCIsImNhbWxfY29udmVydF9zdHJpbmdfdG9fYXJyYXkiLCJjYW1sX2JsaXRfYnl0ZXMiLCJzMSIsImkxIiwiczIiLCJpMiIsIk1sRmlsZSIsIk1sRmFrZUZpbGUiLCJvbGQiLCJidWYiLCJwb3MiLCJjbGVuIiwibmV3X3N0ciIsIm9sZF9kYXRhIiwiTWxGYWtlRGV2aWNlIiwicm9vdCIsInJlcyIsIm5hbWVfc2xhc2giLCJSZWdFeHAiLCJzZWVuIiwibSIsIm9rIiwiZmlsZSIsIm1sc3RyaW5nIiwiY2FtbF9hcnJheV9vZl9zdHJpbmciLCJjYW1sX2J5dGVzX3Vuc2FmZV9zZXQiLCJjYW1sX2J5dGVzX3NldCIsIkJ1ZmZlciIsIk1sTm9kZUZpbGUiLCJmZCIsInJlcXVpcmUiLCJidWZfb2Zmc2V0IiwiTWxOb2RlRGV2aWNlIiwiY29uc3RzIiwia2V5IiwibyIsImNhbWxfcm9vdCIsImZzX25vZGVfc3VwcG9ydGVkIiwianNvb19tb3VudF9wb2ludCIsInJlc29sdmVfZnNfZGV2aWNlIiwicGF0aCIsImNhbWxfc3lzX2lzX2RpcmVjdG9yeSIsImNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQiLCJjYW1sX3V0Zjhfb2ZfdXRmMTYiLCJkIiwiY2FtbF9qc190b19zdHJpbmciLCJjYW1sX3JhaXNlX2NvbnN0YW50IiwiY2FtbF9yYWlzZV9ub3RfZm91bmQiLCJjYW1sX3N5c19nZXRlbnYiLCJnIiwidW5kZWZpbmVkIiwic2hpZnRfcmlnaHRfbmF0IiwibmF0MSIsIm9mczEiLCJsZW4xIiwibmF0MiIsIm9mczIiLCJuYml0cyIsIndyYXAiLCJNbE9iamVjdFRhYmxlIiwiTmFpdmVMb29rdXAiLCJvYmpzIiwiY2FtbF9mYWlsd2l0aCIsImNhbWxfc3lzX3JlbmFtZSIsIm9fcm9vdCIsIm5fcm9vdCIsImNhbWxfbG9nMTBfZmxvYXQiLCJjYW1sX3J1bnRpbWVfd2FybmluZ3MiLCJjYW1sX21sX2VuYWJsZV9ydW50aW1lX3dhcm5pbmdzIiwiYm9vbCIsImNhbWxfY2xhc3NpZnlfZmxvYXQiLCJpc0Zpbml0ZSIsImlzTmFOIiwiY2FtbF9tbF9yZWZpbGxfaW5wdXQiLCJjaGFuIiwic3RyIiwic3RyX2xlbiIsImNhbWxfbWxfY2hhbm5lbHMiLCJjYW1sX21sX21heV9yZWZpbGxfaW5wdXQiLCJjaGFuaWQiLCJjYW1sX2FycmF5X2JvdW5kX2Vycm9yIiwiY2FtbF9tbF9pbnB1dF9zY2FuX2xpbmUiLCJjYW1sX2djX21pbm9yIiwiY2FtbF9pbnQ2NF9vZl9ieXRlcyIsImNhbWxfYmFfdWludDhfZ2V0NjQiLCJiYSIsImkwIiwib2ZzIiwiYjEiLCJiMiIsImIzIiwiYjQiLCJiNSIsImI2IiwiYjciLCJiOCIsImNhbWxfaW50NjRfdG9fYnl0ZXMiLCJjYW1sX2ludDY0X21hcnNoYWwiLCJ3cml0ZXIiLCJzaXplcyIsImNhbWxfYmFfbnVtX2RpbXMiLCJjYW1sX211bCIsImNhbWxfaGFzaF9taXhfaW50IiwiaCIsImNhbWxfaGFzaF9taXhfc3RyaW5nX2FyciIsInciLCJjYW1sX3JldHVybl9leG5fY29uc3RhbnQiLCJjYW1sX25hbWVkX3ZhbHVlcyIsImNhbWxfbmFtZWRfdmFsdWUiLCJubSIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJlIiwiY2FtbF9jcmVhdGVfZmlsZSIsImNhbWxfZnNfaW5pdCIsInRtcCIsImNhbWxfbGlzdF9vZl9qc19hcnJheSIsImNhbWxfc2V0X3BhcnNlcl90cmFjZSIsInVuaXhfZ2V0dGltZW9mZGF5IiwiRGF0ZSIsIm51bV9kaWdpdHNfbmF0IiwibmF0IiwiY2FtbF9oYXNoX25hdCIsInJhd19hcnJheV9hcHBlbmRfb25lIiwiY2FtbF9jYWxsX2dlbiIsImFyZ3MiLCJhcmdzTGVuIiwiY2FtbF9qc193cmFwX2NhbGxiYWNrIiwiYXJndW1lbnRzIiwiY2FtbF9qc193cmFwX2NhbGxiYWNrX2FyZ3VtZW50cyIsImNhbWxfc3lzX2NoZGlyIiwiZGlyIiwiY2FtbF9nY19jb3VudGVycyIsImNhbWxfaGFzaF9taXhfc3RyaW5nX3N0ciIsImxvZzJfb2siLCJqc29vX2Zsb29yX2xvZzIiLCJJbmZpbml0eSIsImNhbWxfaW50MzJfYml0c19vZl9mbG9hdCIsImZsb2F0MzJhIiwiaW50MzJhIiwiY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkiLCJsbyIsIm1pIiwiaGkiLCJjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQiLCJzaWduIiwiZXhwIiwiayIsInIzIiwicjIiLCJyMSIsImNhbWxfYmFfc2VyaWFsaXplIiwic3oiLCJjb21wbGV4IiwiY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudCIsImtpbmQiLCJjYW1sX2JhX2NyZWF0ZV9idWZmZXIiLCJzaXplIiwidmlldyIsImRhdGEiLCJjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMiLCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMiLCJOYU4iLCJjYW1sX2JhX2dldF9zaXplIiwiZGltcyIsIm5fZGltcyIsImNhbWxfaW50NjRfY3JlYXRlX2xvX2hpIiwiY2FtbF9pbnQ2NF9oaTMyIiwiY2FtbF9pbnQ2NF9sbzMyIiwiTWxfQmlnYXJyYXkiLCJsYXlvdXQiLCJpbSIsInJlIiwidG90YWwiLCJrMSIsImsyIiwiTWxfQmlnYXJyYXlfY18xXzEiLCJjYW1sX2JhX2NyZWF0ZV91bnNhZmUiLCJzaXplX3Blcl9lbGVtZW50IiwiY2FtbF9iYV9kZXNlcmlhbGl6ZSIsInJlYWRlciIsIm51bV9kaW1zIiwic2l4dHkiLCJpbnQ2NCIsImNhbWxfYmFfY29tcGFyZSIsImNhbWxfaGFzaF9taXhfaW50NjQiLCJjYW1sX2hhc2hfbWl4X2Zsb2F0IiwidjAiLCJjYW1sX2JhX2hhc2giLCJudW1fZWx0cyIsImNhbWxfaW50MzJfdW5tYXJzaGFsIiwiY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsIiwiY2FtbF9pbnQ2NF91bm1hcnNoYWwiLCJjYW1sX2ludDY0X2NvbXBhcmUiLCJ4MyIsImNhbWxfaW50NjRfaGFzaCIsImNhbWxfY3VzdG9tX29wcyIsImNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbSIsImNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbSIsIm51bSIsImN1c3RvbSIsInN3YXAiLCJjYW1sX2NvbXBhcmVfdmFsX3RhZyIsIk51bWJlciIsImNhbWxfaW50X2NvbXBhcmUiLCJjYW1sX3N0cmluZ19jb21wYXJlIiwiY2FtbF9jb21wYXJlX3ZhbCIsInN0YWNrIiwidGFnX2EiLCJ0YWdfYiIsImNhbWxfZ3JlYXRlcnRoYW4iLCJkaXZfaGVscGVyIiwiZGl2X2RpZ2l0X25hdCIsIm5hdHEiLCJvZnNxIiwibmF0ciIsIm9mc3IiLCJyZW0iLCJudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXQiLCJzaGlmdF9sZWZ0X25hdCIsIk1sTmF0IiwiY3JlYXRlX25hdCIsImFyciIsInNldF90b196ZXJvX25hdCIsImluY3JfbmF0IiwiY2FycnlfaW4iLCJjYXJyeSIsImFkZF9uYXQiLCJsZW4yIiwibmF0X29mX2FycmF5IiwibXVsdF9kaWdpdF9uYXQiLCJuYXQzIiwib2ZzMyIsIngxIiwieDIiLCJkZWNyX25hdCIsImJvcnJvdyIsInN1Yl9uYXQiLCJjb21wYXJlX25hdCIsImRpdl9uYXQiLCJxdW8iLCJjYW1sX2JhX2JsaXQiLCJzcmMiLCJkc3QiLCJpc19kaWdpdF9pbnQiLCJjYW1sX3JhaXNlX3plcm9fZGl2aWRlIiwiY2FtbF9pbnQ2NF9kaXYiLCJxIiwiY2FtbF9qc19odG1sX2VudGl0aWVzIiwiZW50aXR5IiwidGVtcCIsImRvY3VtZW50IiwiY2FtbF9zdHJpbmdfdW5zYWZlX3NldCIsImNhbWxfaW50NjRfb2Zmc2V0IiwiY2FtbF9pbnQ2NF9vZl9mbG9hdCIsImNhbWxfbWxfY2hhbm5lbF9zaXplXzY0IiwiY2FtbF9iYV9zZXRfMiIsImNhbWxfYXJndiIsIm1haW4iLCJhcmd2IiwiYXJnczIiLCJjYW1sX2V4ZWN1dGFibGVfbmFtZSIsImNhbWxfYnl0ZXNfY29tcGFyZSIsImNhbWxfanNfZXZhbF9zdHJpbmciLCJldmFsIiwiY2FtbF9DYW1saW50ZXJuYWxNb2RfaW5pdF9tb2QiLCJsb2MiLCJzaGFwZSIsInVuZGVmX21vZHVsZSIsIl94IiwibG9vcCIsInN0cnVjdCIsImlkeCIsInNlcmlhbGl6ZV9uYXQiLCJjYW1sX21lbXByb2Zfc2V0IiwiX2NvbnRyb2wiLCJjYW1sX3N5c19leGl0IiwiY29kZSIsImNhbWxfanNfZnJvbV9hcnJheSIsImNhbWxfYmFfcmVzaGFwZSIsInZpbmQiLCJuZXdfZGltIiwiY2FtbF9vb19sYXN0X2lkIiwiY2FtbF9zZXRfb29faWQiLCJjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYSIsInN0cjEiLCJwb3MxIiwiYmEyIiwicG9zMiIsInNsaWNlIiwiY2FtbF9nZXRfZ2xvYmFsX2RhdGEiLCJjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkIiwiY2FtbF9iYV91aW50OF9nZXQxNiIsImNhbWxfY29tcGFyZSIsImNhbWxfZnJlc2hfb29faWQiLCJjYW1sX2ludDY0X3RvX2Zsb2F0IiwiY2FtbF9iYV9nZXRfMSIsImNhbWxfYmlnc3RyaW5nX21lbWNtcCIsImNhbWxfcmF3X2JhY2t0cmFjZV9sZW5ndGgiLCJjYW1sX2JhX3VpbnQ4X2dldDMyIiwiY2FtbF9vYmpfYmxvY2siLCJiaWdzdHJpbmdfdG9fYXJyYXlfYnVmZmVyIiwiYnMiLCJseG9yX2RpZ2l0X25hdCIsImNhbWxfZmluYWxfcmVsZWFzZSIsInJhd19hcnJheV9jb25zIiwiY2FtbF9qc190b19hcnJheSIsImNhbWxfYnl0ZXNfc2V0NjQiLCJpNjQiLCJjYW1sX2J5dGVzX3NldDE2IiwiaTE2IiwiY2FtbF9zdHJpbmdfc2V0MTYiLCJjYW1sX2ludDY0X2Jzd2FwIiwiY2FtbF9maWxsX2J5dGVzIiwiY2FtbF9maWxsX3N0cmluZyIsImNhbWxfZ2NfbWFqb3IiLCJjYW1sX2xleF9hcnJheSIsImNhbWxfbGV4X2VuZ2luZSIsInRibCIsInN0YXJ0X3N0YXRlIiwibGV4YnVmIiwibGV4X2J1ZmZlciIsImxleF9idWZmZXJfbGVuIiwibGV4X3N0YXJ0X3BvcyIsImxleF9jdXJyX3BvcyIsImxleF9sYXN0X3BvcyIsImxleF9sYXN0X2FjdGlvbiIsImxleF9lb2ZfcmVhY2hlZCIsImxleF9iYXNlIiwibGV4X2JhY2t0cmsiLCJsZXhfZGVmYXVsdCIsImxleF90cmFucyIsImxleF9jaGVjayIsInN0YXRlIiwiYmFzZSIsImJhY2t0cmsiLCJjYW1sX3N5c19maWxlX2V4aXN0cyIsImNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3QiLCJjYW1sX2FycmF5X3N1YiIsImEyIiwiY2FtbF9ieXRlc19lcXVhbCIsImNhbWxfc3lzX2NvbnN0X29zdHlwZV9jeWd3aW4iLCJjYW1sX2Nvc2hfZmxvYXQiLCJjYW1sX2VwaGVfa2V5X29mZnNldCIsImNhbWxfd2Vha19jaGVjayIsImNhbWxfZXBoZV9jaGVja19rZXkiLCJjYW1sX2hhc2hfbWl4X2ZpbmFsIiwiY2FtbF9sZXhfcnVuX21lbSIsIm1lbSIsImN1cnJfcG9zIiwiY2FtbF9sZXhfcnVuX3RhZyIsImNhbWxfbmV3X2xleF9lbmdpbmUiLCJsZXhfbWVtIiwibGV4X2Jhc2VfY29kZSIsImxleF9iYWNrdHJrX2NvZGUiLCJsZXhfZGVmYXVsdF9jb2RlIiwibGV4X3RyYW5zX2NvZGUiLCJsZXhfY2hlY2tfY29kZSIsImxleF9jb2RlIiwicGNfb2ZmIiwicHN0YXRlIiwiYmFzZV9jb2RlIiwiY2FtbF9iYV91aW50OF9zZXQ2NCIsImNhbWxfc3lzX2V4ZWN1dGFibGVfbmFtZSIsImNhbWxfbGVzc2VxdWFsIiwiY2FtbF9tbF9mbHVzaCIsIm91dHB1dCIsImNhbWxfbWxfc2Vla19vdXRfNjQiLCJjb21wYXJlX25hdF9yZWFsIiwiY2FtbF9nY19zZXQiLCJjYW1sX2pzX2dldCIsImNhbWxfZ2NfY29tcGFjdGlvbiIsImNhbWxfd2Vha19nZXQiLCJjYW1sX2VwaGVfZ2V0X2tleSIsIndpbl9jbGVhbnVwIiwiY2FtbF9zeXNfY2xvc2UiLCJjYW1sX21sX2Nsb3NlX2NoYW5uZWwiLCJjYW1sX2V4bl93aXRoX2pzX2JhY2t0cmFjZSIsImV4biIsImZvcmNlIiwiY2FtbF9zeXNfaXNhdHR5IiwiX2NoYW4iLCJpc19kaWdpdF96ZXJvIiwidW5peF9pbmV0X2FkZHJfb2Zfc3RyaW5nIiwiY2FtbF9qc19zZXQiLCJjYW1sX2FycmF5X2dldCIsImFycmF5IiwiaW5kZXgiLCJjYW1sX3NwYWNldGltZV9vbmx5X3dvcmtzX2Zvcl9uYXRpdmVfY29kZSIsImNhbWxfbWxfc2Vla19pbl82NCIsImNhbWxfbm90ZXF1YWwiLCJjYW1sX2ludDY0X3NoaWZ0X2xlZnQiLCJjYW1sX3N5c19jb25zdF9pbnRfc2l6ZSIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrIiwiY2FtbF9pc19qcyIsImNhbWxfYmFfZGltIiwiY2FtbF9iYV9kaW1fMSIsInVuaXhfbG9jYWx0aW1lIiwiZF9udW0iLCJqYW51YXJ5Zmlyc3QiLCJkb3kiLCJqYW4iLCJqdWwiLCJzdGRUaW1lem9uZU9mZnNldCIsImNhbWxfanNfbWV0aF9jYWxsIiwiY2FtbF93ZWFrX2NyZWF0ZSIsImNhbWxfZXBoZV9jcmVhdGUiLCJjYW1sX2pzX3RvX2J5dGVfc3RyaW5nIiwidW5peF9ta3RpbWUiLCJ0bSIsInRtMiIsImNhbWxfdHJhbXBvbGluZSIsImNhbWxfYnl0ZXNfZ2V0NjQiLCJjYW1sX3dlYWtfc2V0IiwiY2FtbF9zeXNfcmVtb3ZlIiwiY2FtbF9zdHJpbmdfZ2V0MzIiLCJjYW1sX2h5cG90X2Zsb2F0IiwiY2FtbF9qc19jYWxsIiwiY2FtbF9zeXNfY29uc3RfbWF4X3dvc2l6ZSIsImNhbWxfZXBoZV91bnNldF9rZXkiLCJjYW1sX2J5dGVzX2xlc3N0aGFuIiwiY2FtbF9nY19xdWlja19zdGF0IiwiY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSIsImNhbWxfbWxfaW5wdXRfaW50IiwiY2FtbF9hcnJheV9ibGl0IiwiYTEiLCJudGhfZGlnaXRfbmF0IiwiY2FtbF9mbG9hdF9vZl9zdHJpbmciLCJtMyIsIm1hbnRpc3NhIiwicGFyc2VJbnQiLCJleHBvbmVudCIsImNhbWxfc3lzX2dldGN3ZCIsImNhbWxfc3lzX2NvbnN0X2JpZ19lbmRpYW4iLCJjYW1sX2xpc3RfdG9fanNfYXJyYXkiLCJjYW1sX2xlZ2FjeV9jdXN0b21fY29kZSIsImNhbWxfbWxfc3RyaW5nX2xlbmd0aCIsImNhbWxfb3V0cHV0X3ZhbCIsIldyaXRlciIsInZhbHVlIiwiZmxhZ3MiLCJub19zaGFyaW5nIiwiY2xvc3VyZXMiLCJpbnRlcm5fb2JqX3RhYmxlIiwibWVtbyIsImV4aXN0aW5nX29mZnNldCIsImV4dGVybl9yZWMiLCJvcHMiLCJzel8zMl82NCIsImhlYWRlcl9wb3MiLCJvbGRfcG9zIiwidHlwZV9vZl92IiwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nIiwiY2FtbF9yYWlzZV9ub3RfYV9kaXIiLCJjYW1sX3N5c19zeXN0ZW1fY29tbWFuZCIsImNtZCIsImNhbWxfanNfZXJyb3Jfb2ZfZXhjZXB0aW9uIiwiZGVzZXJpYWxpemVfbmF0IiwiaW5pdGlhbGl6ZV9uYXQiLCJqc19wcmludF9zdGRvdXQiLCJjYW1sX2NvcHlzaWduX2Zsb2F0IiwiY2FtbF9iYV9zZXRfZ2VuZXJpYyIsImNhbWxfZXBoZV9zZXRfa2V5IiwiY2FtbF9zdHJpbmdfbGVzc2VxdWFsIiwiY2FtbF9zdHJpbmdfZ3JlYXRlcmVxdWFsIiwiY2FtbF9pbnQ2NF9hZGQiLCJjYW1sX25leHRhZnRlcl9mbG9hdCIsImJpdHMiLCJvbmUiLCJjYW1sX21sX3Bvc19pbiIsImNhbWxfaW50NjRfYW5kIiwiY2FtbF9zeXNfY29uc3Rfd29yZF9zaXplIiwiY2FtbF9zdGRfb3V0cHV0Iiwic2xlbiIsImpzX3ByaW50X3N0ZGVyciIsImNhbWxfc3lzX29wZW5faW50ZXJuYWwiLCJpbmZvIiwiY2FtbF9zeXNfb3BlbiIsIl9wZXJtcyIsIk1sQnl0ZXNSZWFkZXIiLCJjYW1sX2Zsb2F0X29mX2J5dGVzIiwiY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlciIsIl9tYWdpYyIsIl9ibG9ja19sZW4iLCJudW1fb2JqZWN0cyIsIl9zaXplXzMyIiwiX3NpemVfNjQiLCJvYmpfY291bnRlciIsImludGVybl9yZWMiLCJoZWFkZXIiLCJleHBlY3RlZF9zaXplIiwiY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzIiwiY2FtbF9qc19mcm9tX3N0cmluZyIsImNhbWxfYmFfc3ViIiwiY2hhbmdlZF9kaW0iLCJtdWwiLCJuZXdfZGltcyIsIm5ld19kYXRhIiwiY2FtbF9nY19mdWxsX21ham9yIiwiY2FtbF9ieXRlc19zZXQzMiIsImkzMiIsImNhbWxfaW50NjRfaXNfbWludXNfb25lIiwiY2FtbF9iYV91aW50OF9zZXQzMiIsImNhbWxfc3lzX2NvbnN0X29zdHlwZV91bml4IiwiY2FtbF9zaWduYml0X2Zsb2F0IiwiY2FtbF9tbF9zZWVrX291dCIsImNhbWxfcmVzdG9yZV9yYXdfYmFja3RyYWNlIiwiYnQiLCJjYW1sX2pzX3R5cGVvZiIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3Vuc2FmZSIsImNhbWxfYmFfZGltXzMiLCJjYW1sX2VwaGVfZGF0YV9vZmZzZXQiLCJjYW1sX2VwaGVfY2hlY2tfZGF0YSIsImNhbWxfYnl0ZXNfZ2V0MTYiLCJjYW1sX29ial9tYWtlX2ZvcndhcmQiLCJjYW1sX2pzX2Zyb21fYm9vbCIsImNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZSIsImNhbWxfY3JlYXRlX3N0cmluZyIsImNhbWxfbWQ1X3N0cmluZyIsImFkZCIsInh4IiwiZmYiLCJnZyIsImhoIiwiaWkiLCJtZDUiLCJjYW1sX21kNV9jaGFuIiwiY2hhbl9sZW4iLCJjYW1sX3dlYWtfZ2V0X2NvcHkiLCJjYW1sX21sX291dHB1dF9ieXRlcyIsInN0cmluZyIsImpzc3RyaW5nIiwiaWQiLCJjYW1sX21sX291dHB1dCIsImNhbWxfZXBoZV9nZXRfZGF0YSIsImNhbWxfdHJhbXBvbGluZV9yZXR1cm4iLCJjYW1sX2FycmF5X2FwcGVuZCIsImwxIiwibDIiLCJjYW1sX3N0cmluZ19vZl9ieXRlcyIsImNhbWxfbWxfc2V0X2NoYW5uZWxfcmVmaWxsIiwiY2FtbF9qc19leHByIiwiY2FtbF9pbnQ2NF9tdWwiLCJjYW1sX21sX3J1bnRpbWVfd2FybmluZ3NfZW5hYmxlZCIsIl91bml0IiwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnl0ZXMiLCJjYW1sX2hhc2hfdW5pdl9wYXJhbSIsImNvdW50IiwibGltaXQiLCJvYmoiLCJoYXNoX2FjY3UiLCJoYXNoX2F1eCIsImNhbWxfc3RyaW5nX2VxdWFsIiwicmF3X2FycmF5X2NvcHkiLCJjYW1sX291dHB1dF92YWx1ZV90b19idWZmZXIiLCJjYW1sX3B1cmVfanNfZXhwciIsImNhbWxfYmxpdF9zdHJpbmciLCJibGl0X25hdCIsImNhbWxfaW50NjRfdWx0IiwiY2FtbF9pbnQ2NF94b3IiLCJjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2J5dGVzIiwiYmExIiwiYnl0ZXMyIiwiY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZSIsImNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSIsImNhbWxfcGFyc2VfZGlnaXQiLCJjYW1sX2ludDY0X29mX3N0cmluZyIsImJhc2U2NCIsInRocmVzaG9sZCIsImNhbWxfbWFrZV92ZWN0IiwiaW5pdCIsImNhbWxfYmxpdF9zdHJpbmdfdG9fYmlnc3RyaW5nIiwiY2FtbF9tbF9zZWVrX2luIiwiY2FtbF9zeXNfcmVhZF9kaXJlY3RvcnkiLCJjYW1sX21sX291dHB1dF9jaGFyIiwiY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3dpbjMyIiwiY2FtbF9vYmpfaXNfYmxvY2siLCJjYW1sX21sX2lucHV0X2NoYXIiLCJjYW1sX2pzX3ZhciIsImNhbWxfdHJ1bmNfZmxvYXQiLCJjYW1sX2VwaGVfYmxpdF9kYXRhIiwiY2FtbF9pc19wcmludGFibGUiLCJjYW1sX2J5dGVzX2xlc3NlcXVhbCIsImNhbWxfZXF1YWwiLCJjYW1sX2ZpbmFsX3JlZ2lzdGVyX2NhbGxlZF93aXRob3V0X3ZhbHVlIiwiY2FtbF9zeXNfcmFuZG9tX3NlZWQiLCJub3ciLCJjYW1sX2JhX2dldF8yIiwid2luX2hhbmRsZV9mZCIsImNhbWxfYmFfdWludDhfc2V0MTYiLCJjYW1sX2pzX2RlbGV0ZSIsImNhbWxfaW50X29mX3N0cmluZyIsImNhbWxfbGlzdF9tb3VudF9wb2ludCIsInByZXYiLCJjYW1sX21hcnNoYWxfY29uc3RhbnRzIiwiY2FtbF9qc19lcXVhbHMiLCJiaWdzdHJpbmdfdG9fdHlwZWRfYXJyYXkiLCJjYW1sX2JhX3NsaWNlIiwibnVtX2luZHMiLCJzdWJfZGltcyIsImNhbWxfbWFyc2hhbF9kYXRhX3NpemUiLCJnZXQzMiIsImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmciLCJjYW1sX2lucHV0X3ZhbHVlIiwiY2FtbF9iYV9raW5kIiwiY2FtbF9qc19mdW5fY2FsbCIsImNhbWxfanNfcHVyZV9leHByIiwiY29tcGFyZV9kaWdpdHNfbmF0IiwiY2FtbF9tbF9pbnB1dCIsImNhbWxfaGFzaF9taXhfYmlnc3RyaW5nIiwiY2FtbF9yZWNvcmRfYmFja3RyYWNlIiwidW5peF9nbXRpbWUiLCJjYW1sX3N5c19jb25zdF9iYWNrZW5kX3R5cGUiLCJjYW1sX3N5c19nZXRfY29uZmlnIiwidW5peF90aW1lIiwiY2FtbF9tbF9vdXRfY2hhbm5lbHNfbGlzdCIsImJpZ3N0cmluZ19vZl9hcnJheV9idWZmZXIiLCJhYiIsInRhIiwiY2FtbF9tb2QiLCJjYW1sX2JhX2luaXQiLCJCaWdTdHJpbmdSZWFkZXIiLCJjYW1sX2JhX2dldF9nZW5lcmljIiwiY2FtbF9nZXRfZXhjZXB0aW9uX2JhY2t0cmFjZSIsImNhbWxfZm9ybWF0X2Zsb2F0IiwidG9GaXhlZCIsImRwIiwicHJlYyIsImNhbWxfbW91bnRfYXV0b2xvYWQiLCJjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhIiwiY2FtbF9ibGl0X2JpZ3N0cmluZ190b19iaWdzdHJpbmciLCJjYW1sX2RpdiIsImNhbWxfc3RyaW5nX2xlc3N0aGFuIiwiY2FtbF9zdHJpbmdfZ3JlYXRlcnRoYW4iLCJjYW1sX2VwaGVfZ2V0X2RhdGFfY29weSIsImNhbWxfc3lzX2dldF9hcmd2IiwiY2FtbF9qc190b19ib29sIiwiY2FtbF9lcGhlX2dldF9rZXlfY29weSIsImNhbWxfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3QiLCJjYW1sX2xlc3N0aGFuIiwiY2FtbF9yZWdpc3Rlcl9nbG9iYWwiLCJuYW1lX29wdCIsIm11bHRfbmF0IiwibGVuMyIsInNxdWFyZV9uYXQiLCJjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlIiwiY2FtbF9qc19mcm9tX2Zsb2F0IiwiY2FtbF9nY19zdGF0IiwiY2FtbF9zeXNfbW9kaWZ5X2FyZ3YiLCJjYW1sX21ldGhvZF9jYWNoZSIsImNhbWxfZ2V0X3B1YmxpY19tZXRob2QiLCJjYWNoZWlkIiwibWV0aHMiLCJsaSIsImNhbWxfanNfZ2V0X2NvbnNvbGUiLCJjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pbiIsImNoYW5uZWwiLCJiaWdzdHJpbmdfb2ZfdHlwZWRfYXJyYXkiLCJjYW1sX3JvdW5kX2Zsb2F0IiwiY2FtbF9vanNfbmV3X2FyciIsIkYiLCJjb21wbGVtZW50X25hdCIsImNhbWxfanNfcmVnZXhwcyIsImNhbWxfanNfaHRtbF9lc2NhcGUiLCJjYW1sX2JhX2RpbV8yIiwiY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfYXJndW1lbnRzIiwiY2FtbF9zaW5oX2Zsb2F0IiwiY2FtbF9sZGV4cF9mbG9hdCIsImNhbWxfanNfd3JhcF9jYWxsYmFja19zdHJpY3QiLCJhcml0eSIsImNhbWxfZ2V0X2N1cnJlbnRfY2FsbHN0YWNrIiwiY2FtbF9iYV9zZXRfMSIsImxhbmRfZGlnaXRfbmF0IiwiY2FtbF9pbnQ2NF9tb2QiLCJjYW1sX29ial9zZXRfdGFnIiwiY2FtbF9jcmVhdGVfZmlsZV9leHRlcm4iLCJjYW1sX2ludDMyX2Jzd2FwIiwid2luX3N0YXJ0dXAiLCJjYW1sX2JhX3NldF8zIiwiY2FtbF9qc19pbnN0YW5jZW9mIiwiY2FtbF9ibGl0X2JpZ3N0cmluZ190b19zdHJpbmciLCJudGhfZGlnaXRfbmF0X25hdGl2ZSIsInNldF9kaWdpdF9uYXRfbmF0aXZlIiwiZGlnaXQiLCJjYW1sX3N0cmluZ19zZXQ2NCIsImNhbWxfYmFfbWFwX2ZpbGUiLCJ2ZmQiLCJzaGFyZWQiLCJjYW1sX2JhX21hcF9maWxlX2J5dGVjb2RlIiwiYXJnbiIsImNhbWxfYmFfY3JlYXRlX2Zyb20iLCJkYXRhMSIsImRhdGEyIiwianN0eXAiLCJjYW1sX3RhbmhfZmxvYXQiLCJKU09OIiwicnhfb25lIiwicnhfdHdvIiwicnhfdGhyZWUiLCJyeF9mb3VyIiwicnhfZXNjYXBhYmxlIiwicnhfZGFuZ2Vyb3VzIiwidGhpc192YWx1ZSIsIkJvb2xlYW4iLCJnYXAiLCJpbmRlbnQiLCJtZXRhIiwicmVwIiwicXVvdGUiLCJob2xkZXIiLCJtaW5kIiwicGFydGlhbCIsIk9iamVjdCIsInJlcGxhY2VyIiwic3BhY2UiLCJFcnJvciIsInRleHQiLCJyZXZpdmVyIiwid2FsayIsIlN5bnRheEVycm9yIiwiY2FtbF9qc29uIiwiY2FtbF91bm1vdW50IiwiY2FtbF9tbF9wb3NfaW5fNjQiLCJjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZSIsIl9jaGFubmVsIiwiY2FtbF9zdHJpbmdfc2V0IiwiY2FtbF9tbF9wb3Nfb3V0IiwiY2FtbF9zcGFjZXRpbWVfZW5hYmxlZCIsImNhbWxfYnl0ZXNfbm90ZXF1YWwiLCJjYW1sX3J1bnRpbWVfcGFyYW1ldGVycyIsImNhbWxfanNfb2JqZWN0IiwiY2FtbF9iYV9jcmVhdGUiLCJkaW1zX21sIiwiY2FtbF93ZWFrX2JsaXQiLCJjYW1sX2Jzd2FwMTYiLCJjYW1sX2ZpbmFsX3JlZ2lzdGVyIiwiY2FtbF9tbF9zZXRfYmluYXJ5X21vZGUiLCJtb2RlIiwiY2FtbF9zdHJpbmdfZ2V0MTYiLCJjYW1sX2VwaGVfdW5zZXRfZGF0YSIsImNhbWxfb3V0cHV0X3ZhbHVlIiwiY2FtbF9iYV9nZXRfMyIsImNhbWxfZXBoZV9ibGl0X2tleSIsImNhbWxfY2hlY2tfYm91bmQiLCJjYW1sX2J5dGVzX29mX3N0cmluZyIsImNhbWxfaGFzaF9taXhfc3RyaW5nIiwiY2FtbF9oYXNoIiwic2VlZCIsInF1ZXVlIiwicmQiLCJ3ciIsImNhbWxfb2JqX3RhZyIsIkZ1bmN0aW9uIiwiY2FtbF9qc19leHBvcnRfdmFyIiwibW9kdWxlIiwiY2FtbF9ieXRlc19nZXQzMiIsImNhbWxfZnJleHBfZmxvYXQiLCJuZWciLCJjYW1sX3N0cmluZ19nZXQ2NCIsImNhbWxfbWxfcG9zX291dF82NCIsImNhbWxfc2V0X3N0YXRpY19lbnYiLCJjYW1sX2JhX2NoYW5nZV9sYXlvdXQiLCJjYW1sX2pzX25ldyIsImNhbWxfZm9ybWF0X2ludCIsImNhbWxfb2JqX3RydW5jYXRlIiwiaXNfZGlnaXRfb2RkIiwiY2FtbF9ydW50aW1lX3ZhcmlhbnQiLCJjYW1sX2FycmF5X2NvbmNhdCIsImNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dCIsImNhbWxfZXBoZV9zZXRfZGF0YSIsImNhbWxfbWFrZV9mbG9hdF92ZWN0IiwiY2FtbF9ncmVhdGVyZXF1YWwiLCJjYW1sX2dldF9leGNlcHRpb25fcmF3X2JhY2t0cmFjZSIsImNhbWxfbG9nMXBfZmxvYXQiLCJjYW1sX3N0cmluZ19nZXQiLCJjYW1sX2ludDY0X29yIiwiY2FtbF9sYXp5X21ha2VfZm9yd2FyZCIsImxvcl9kaWdpdF9uYXQiLCJjYW1sX2pzX29uX2llIiwidWEiLCJjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0IiwiY2FtbF9iYV9sYXlvdXQiLCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZSIsImNhbWxfYXJyYXlfc2V0IiwibmV3dmFsIiwiY2FtbF9ieXRlc19ncmVhdGVyZXF1YWwiLCJzZXRfZGlnaXRfbmF0IiwiY2FtbF91cGRhdGVfZHVtbXkiLCJjYW1sX0NhbWxpbnRlcm5hbE1vZF91cGRhdGVfbW9kIiwicmVhbCIsImNhbWxfbWxfb3V0cHV0X2ludCIsImNhbWxfb2JqX3dpdGhfdGFnIiwiY2FtbF9pbml0aWFsX3RpbWUiLCJjYW1sX3N5c190aW1lIiwiY2FtbF9tbF9jaGFubmVsX3NpemUiLCJjYW1sX3Jhd19iYWNrdHJhY2Vfc2xvdCIsImNhbWxfaW50NjRfaXNfbWluX2ludCIsImNhbWxfaGV4c3RyaW5nX29mX2Zsb2F0Iiwic3R5bGUiLCJleHBfc2lnbiIsInNpZ25fc3RyIiwiY3N0IiwieF9zdHIiLCJjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19zdHJpY3QiLCJjYW1sX2JhY2t0cmFjZV9zdGF0dXMiLCJjYW1sX2luc3RhbGxfc2lnbmFsX2hhbmRsZXIiLCJjYW1sX3N5c19hcmd2IiwiY2FtbF9iYV9maWxsIiwiY2FtbF9tb2RmX2Zsb2F0IiwiY2FtbF9nY19nZXQiLCJjYW1sX2Zsb2F0X2NvbXBhcmUiLCJjYW1sX3N0cmluZ19zZXQzMiIsImNhbWxfcGFyc2VfZW5naW5lIiwidGFibGVzIiwiZW52IiwiRVJSQ09ERSIsInRlc3RzaGlmdCIsInNoaWZ0Iiwic2hpZnRfcmVjb3ZlciIsInJlZHVjZSIsIlJFQURfVE9LRU4iLCJSQUlTRV9QQVJTRV9FUlJPUiIsIkdST1dfU1RBQ0tTXzEiLCJHUk9XX1NUQUNLU18yIiwiQ09NUFVURV9TRU1BTlRJQ19BQ1RJT04iLCJDQUxMX0VSUk9SX0ZVTkNUSU9OIiwiZW52X3Nfc3RhY2siLCJlbnZfdl9zdGFjayIsImVudl9zeW1iX3N0YXJ0X3N0YWNrIiwiZW52X3N5bWJfZW5kX3N0YWNrIiwiZW52X3N0YWNrc2l6ZSIsImVudl9zdGFja2Jhc2UiLCJlbnZfY3Vycl9jaGFyIiwiZW52X2x2YWwiLCJlbnZfc3ltYl9zdGFydCIsImVudl9zeW1iX2VuZCIsImVudl9hc3AiLCJlbnZfcnVsZV9sZW4iLCJlbnZfcnVsZV9udW1iZXIiLCJlbnZfc3AiLCJlbnZfc3RhdGUiLCJlbnZfZXJyZmxhZyIsInRibF90cmFuc2xfY29uc3QiLCJ0YmxfdHJhbnNsX2Jsb2NrIiwidGJsX2xocyIsInRibF9sZW4iLCJ0YmxfZGVmcmVkIiwidGJsX2Rnb3RvIiwidGJsX3NpbmRleCIsInRibF9yaW5kZXgiLCJ0YmxfZ2luZGV4IiwidGJsX3RhYmxlc2l6ZSIsInRibF90YWJsZSIsInRibF9jaGVjayIsIm4xIiwibjIiLCJzdGF0ZTEiLCJzcCIsImVycmZsYWciLCJhc3AiLCJjYW1sX2FycmF5X2ZpbGwiLCJjYW1sX3N0cmluZ19ub3RlcXVhbCIsImNhbWxfYnl0ZXNfZ3JlYXRlcnRoYW4iLCJjYW1sX21sX3NldF9jaGFubmVsX291dHB1dCIsImNhbWxfcmVhZF9maWxlX2NvbnRlbnQiLCJjYW1sX2pzX3RvX2Zsb2F0IiwiZXJyX25vX3ByZWQiLCJlcnJfbm9fc3VjYyIsIm9jYW1sX3ZlcnNpb24iLCJ6ZXJvJDAiLCJvbmUkMCIsIm1pbnVzX29uZSQwIiwibWluX2ludCQxIiwibWF4X2ludCQxIiwiZHVtbXlfcG9zIiwiemVyb19wb3MiLCJzdWJfZm9ybWF0IiwiZm9ybWF0dGluZ19saXQiLCJsb2NmbXQiLCJjdXJyZW50X2Rpcl9uYW1lIiwicGFyZW50X2Rpcl9uYW1lIiwiZGlyX3NlcCIsInF1b3RlcXVvdGUiLCJjdXJyZW50X2Rpcl9uYW1lJDAiLCJwYXJlbnRfZGlyX25hbWUkMCIsImRpcl9zZXAkMCIsImN1cnJlbnRfZGlyX25hbWUkMSIsInBhcmVudF9kaXJfbmFtZSQxIiwiZGlyX3NlcCQxIiwiemVybyQyIiwib25lJDIiLCJpIiwiZXJhc2VfcmVsIiwicmVzdCIsInJlc3QkMCIsInJlc3QkMSIsInJlc3QkMiIsInJlc3QkMyIsInJlc3QkNCIsInJlc3QkNSIsInJlc3QkNiIsInJlc3QkNyIsInR5IiwicmVzdCQ4IiwidHkxIiwicmVzdCQ5IiwicmVzdCQxMCIsInJlc3QkMTEiLCJyZXN0JDEyIiwicmVzdCQxMyIsImNvbmNhdF9mbXR0eSIsImZtdHR5MSIsImZtdHR5MiIsInR5MiIsImNvbmNhdF9mbXQiLCJmbXQxIiwiZm10MiIsInBhZCIsInBhZCQwIiwicHJlYyIsInBhZCQxIiwiaWNvbnYiLCJwcmVjJDAiLCJwYWQkMiIsImljb252JDAiLCJwcmVjJDEiLCJwYWQkMyIsImljb252JDEiLCJwcmVjJDIiLCJwYWQkNCIsImljb252JDIiLCJwcmVjJDMiLCJwYWQkNSIsImZjb252IiwicGFkJDYiLCJzdHIiLCJjaHIiLCJmbXR0eSIsInBhZCQ3IiwiZm10dHkkMCIsInBhZCQ4IiwicmVzdCQxNCIsInJlc3QkMTUiLCJyZXN0JDE2IiwiZm10aW5nX2xpdCIsInJlc3QkMTciLCJmbXRpbmdfZ2VuIiwicmVzdCQxOCIsInJlc3QkMTkiLCJjaGFyX3NldCIsIndpZHRoX29wdCIsInJlc3QkMjAiLCJjb3VudGVyIiwicmVzdCQyMSIsInJlc3QkMjIiLCJpZ24iLCJyZXN0JDIzIiwiZiIsImFyaXR5IiwiZmFpbHdpdGgiLCJzIiwiaW52YWxpZF9hcmciLCJtaW4iLCJ4IiwieSIsIm1heCIsImFicyIsImxub3QiLCJpbmZpbml0eSIsIm5lZ19pbmZpbml0eSIsIm5hbiIsIm1heF9mbG9hdCIsIm1pbl9mbG9hdCIsImVwc2lsb25fZmxvYXQiLCJtYXhfaW50IiwibWluX2ludCIsInN5bWJvbCIsInMxIiwiczIiLCJsMSIsImwyIiwiY2hhcl9vZl9pbnQiLCJuIiwic3RyaW5nX29mX2Jvb2wiLCJiIiwiYm9vbF9vZl9zdHJpbmciLCJib29sX29mX3N0cmluZ19vcHQiLCJzdHJpbmdfb2ZfaW50IiwiaW50X29mX3N0cmluZ19vcHQiLCJ2YWxpZF9mbG9hdF9sZXhlbSIsImwiLCJpJDAiLCJzdHJpbmdfb2ZfZmxvYXQiLCJmbG9hdF9vZl9zdHJpbmdfb3B0IiwidGwiLCJoZCIsInN0ZGluIiwic3Rkb3V0Iiwic3RkZXJyIiwib3Blbl9vdXRfZ2VuIiwibW9kZSIsInBlcm0iLCJuYW1lIiwiYyIsIm9wZW5fb3V0Iiwib3Blbl9vdXRfYmluIiwiZmx1c2hfYWxsIiwiaXRlciIsImEiLCJvdXRwdXRfYnl0ZXMiLCJvYyIsIm91dHB1dF9zdHJpbmciLCJvdXRwdXQiLCJvZnMiLCJsZW4iLCJvdXRwdXRfc3Vic3RyaW5nIiwib3V0cHV0X3ZhbHVlIiwiY2hhbiIsInYiLCJjbG9zZV9vdXQiLCJjbG9zZV9vdXRfbm9lcnIiLCJvcGVuX2luX2dlbiIsIm9wZW5faW4iLCJvcGVuX2luX2JpbiIsImlucHV0IiwiaWMiLCJ1bnNhZmVfcmVhbGx5X2lucHV0Iiwib2ZzJDAiLCJsZW4kMCIsInIiLCJsZW4kMSIsIm9mcyQxIiwicmVhbGx5X2lucHV0IiwicmVhbGx5X2lucHV0X3N0cmluZyIsImlucHV0X2xpbmUiLCJidWlsZF9yZXN1bHQiLCJidWYiLCJhY2N1IiwicmVzIiwiYmVnIiwiYWNjdSQwIiwiY2xvc2VfaW5fbm9lcnIiLCJwcmludF9jaGFyIiwicHJpbnRfc3RyaW5nIiwicHJpbnRfYnl0ZXMiLCJwcmludF9pbnQiLCJwcmludF9mbG9hdCIsInByaW50X2VuZGxpbmUiLCJwcmludF9uZXdsaW5lIiwicHJlcnJfY2hhciIsInByZXJyX3N0cmluZyIsInByZXJyX2J5dGVzIiwicHJlcnJfaW50IiwicHJlcnJfZmxvYXQiLCJwcmVycl9lbmRsaW5lIiwicHJlcnJfbmV3bGluZSIsInJlYWRfbGluZSIsInJlYWRfaW50IiwicmVhZF9pbnRfb3B0IiwicmVhZF9mbG9hdCIsInJlYWRfZmxvYXRfb3B0Iiwic3RyaW5nX29mX2Zvcm1hdCIsInN5bWJvbCQwIiwic3RyMiIsInN0cjEiLCJleGl0X2Z1bmN0aW9uIiwiYXRfZXhpdCIsImciLCJkb19hdF9leGl0IiwiZXhpdCIsInJldGNvZGUiLCJwYXJhbSQwIiwibCQwIiwibiQwIiwibCQxIiwibiQxIiwibDEkMCIsImwyJDAiLCJsMSQxIiwibDIkMSIsImluaXRfYXV4IiwiYWNjIiwiYWNjJDAiLCJwYXJhbSIsImFjY3UkMSIsImEyIiwiYTEiLCJwIiwicGFpciIsInJ5IiwicngiLCJjbXAiLCJtYXRjaCIsInQyIiwiaDIiLCJ0MSIsImgxIiwiY2hvcCIsImsiLCJrJDAiLCJrJDEiLCJzb3J0IiwieDIiLCJ4MSIsIngzIiwieDIkMCIsIngxJDAiLCJuMSIsIm4yIiwicmV2X3NvcnQiLCJjJDAiLCJjJDEiLCJjJDIiLCJjJDMiLCJjJDQiLCJjJDUiLCJjJDYiLCJhY2N1JDIiLCJlc2NhcGVkIiwicyQwIiwibG93ZXJjYXNlIiwidXBwZXJjYXNlIiwibG93ZXJjYXNlX2FzY2lpIiwidXBwZXJjYXNlX2FzY2lpIiwiY29tcGFyZSIsImMxIiwiYzIiLCJlcXVhbCIsIm1pbiQwIiwibWF4JDAiLCJsb19ib3VuZCIsImhpX2JvdW5kIiwiYm9tIiwicmVwIiwic3VjYyIsInUiLCJwcmVkIiwiaXNfdmFsaWQiLCJvZl9pbnQiLCJpc19jaGFyIiwib2ZfY2hhciIsInRvX2NoYXIiLCJ1bnNhZmVfdG9fY2hhciIsImVxdWFsJDAiLCJjb21wYXJlJDAiLCJoYXNoIiwic3ltYm9sJDEiLCJsZWZ0IiwicmlnaHQiLCJzcmNvZmYiLCJkc3RvZmYiLCJjcHlsZW4iLCJvZnMxIiwib2ZzMiIsInNlcCIsInNlcGxlbiIsImRzdCIsImlzX3NwYWNlIiwiaiIsImFwcGx5MSIsImluZGV4X3JlYyIsImxpbSIsImkkMSIsImluZGV4X3JlY19vcHQiLCJyaW5kZXhfcmVjIiwicmluZGV4X3JlY19vcHQiLCJpc19zcGFjZSQwIiwiaW5kZXhfcmVjJDAiLCJpbmRleF9yZWNfb3B0JDAiLCJyaW5kZXhfcmVjJDAiLCJyaW5kZXhfcmVjX29wdCQwIiwib3NfdHlwZSIsImJhY2tlbmRfdHlwZSIsInVuaXgiLCJ3aW4zMiIsImN5Z3dpbiIsIm1heF9hcnJheV9sZW5ndGgiLCJtYXhfc3RyaW5nX2xlbmd0aCIsImJpZ19lbmRpYW4iLCJzaXplIiwiaW50X3NpemUiLCJnZXRlbnZfb3B0IiwiaW50ZXJhY3RpdmUiLCJzZXRfc2lnbmFsIiwic2lnX251bSIsInNpZ19iZWgiLCJzaWdhYnJ0Iiwic2lnYWxybSIsInNpZ2ZwZSIsInNpZ2h1cCIsInNpZ2lsbCIsInNpZ2ludCIsInNpZ2tpbGwiLCJzaWdwaXBlIiwic2lncXVpdCIsInNpZ3NlZ3YiLCJzaWd0ZXJtIiwic2lndXNyMSIsInNpZ3VzcjIiLCJzaWdjaGxkIiwic2lnY29udCIsInNpZ3N0b3AiLCJzaWd0c3RwIiwic2lndHRpbiIsInNpZ3R0b3UiLCJzaWd2dGFscm0iLCJzaWdwcm9mIiwic2lnYnVzIiwic2lncG9sbCIsInNpZ3N5cyIsInNpZ3RyYXAiLCJzaWd1cmciLCJzaWd4Y3B1Iiwic2lneGZzeiIsImNhdGNoX2JyZWFrIiwib24iLCJtZXJnZSQwIiwib3JkZXIiLCJsaXN0IiwiaW5pdGxpc3QiLCJlMiIsIm1lcmdlMiIsInN3YXAiLCJhcnIiLCJ0bXAiLCJhcnJheSIsInFzb3J0IiwibG8iLCJoaSIsImxvJDAiLCJoaSQwIiwibWlkIiwicGl2b3QiLCJsbyQxIiwiaGkkMSIsInZhbF9pIiwidG9fYnVmZmVyIiwiYnVmZiIsImZsYWdzIiwiaGVhZGVyX3NpemUiLCJkYXRhX3NpemUiLCJ0b3RhbF9zaXplIiwiZnJvbV9ieXRlcyIsImZyb21fc3RyaW5nIiwiaXNfYmxvY2siLCJkb3VibGVfZmllbGQiLCJzZXRfZG91YmxlX2ZpZWxkIiwibWFyc2hhbCIsIm9iaiIsInVubWFyc2hhbCIsInBvcyIsImZpcnN0X25vbl9jb25zdGFudF9jb25zdHJ1Y3Rvcl90YWciLCJsYXN0X25vbl9jb25zdGFudF9jb25zdHJ1Y3Rvcl90YWciLCJsYXp5X3RhZyIsImNsb3N1cmVfdGFnIiwib2JqZWN0X3RhZyIsImluZml4X3RhZyIsImZvcndhcmRfdGFnIiwibm9fc2Nhbl90YWciLCJhYnN0cmFjdF90YWciLCJzdHJpbmdfdGFnIiwiZG91YmxlX3RhZyIsImRvdWJsZV9hcnJheV90YWciLCJjdXN0b21fdGFnIiwiaW50X3RhZyIsIm91dF9vZl9oZWFwX3RhZyIsInVuYWxpZ25lZF90YWciLCJleHRlbnNpb25fY29uc3RydWN0b3IiLCJzbG90IiwiZXh0ZW5zaW9uX25hbWUiLCJleHRlbnNpb25faWQiLCJsZW5ndGgkMCIsInN4Iiwic3kiLCJpbml0IiwibGEiLCJsYiIsInJlcyQwIiwidGwkMCIsImhkJDAiLCJtYXhzb24iLCJpMzEiLCJ0cmlja2xlZG93biIsImUiLCJ0cmlja2xlIiwiYnViYmxlZG93biIsImJ1YmJsZSIsImkkMiIsImUkMCIsImZhdGhlciIsIm1lcmdlIiwic3JjMW9mcyIsInNyYzFsZW4iLCJzcmMyIiwic3JjMm9mcyIsInNyYzJsZW4iLCJkc3RvZnMiLCJzcmMxciIsInNyYzJyIiwiczIkMSIsInMxJDEiLCJpMSIsImkyIiwiZCIsImkyJDAiLCJkJDAiLCJzMiQwIiwiaTEkMCIsImQkMSIsInMxJDAiLCJpc29ydHRvIiwic3Jjb2ZzIiwic29ydHRvIiwidCIsInplcm8iLCJvbmUiLCJtaW51c19vbmUiLCJzdWNjJDAiLCJwcmVkJDAiLCJhYnMkMCIsIm1pbl9pbnQkMCIsIm1heF9pbnQkMCIsImxvZ25vdCIsInRvX3N0cmluZyQwIiwib2Zfc3RyaW5nX29wdCIsImNvbXBhcmUkMyIsImVxdWFsJDMiLCJzdWNjJDEiLCJwcmVkJDEiLCJhYnMkMSIsImxvZ25vdCQwIiwidG9fc3RyaW5nJDEiLCJvZl9zdHJpbmdfb3B0JDAiLCJjb21wYXJlJDQiLCJlcXVhbCQ0IiwiemVybyQxIiwib25lJDEiLCJtaW51c19vbmUkMSIsInN1Y2MkMiIsInByZWQkMiIsImFicyQyIiwibWluX2ludCQyIiwibWF4X2ludCQyIiwibG9nbm90JDEiLCJ0b19zdHJpbmckMiIsIm9mX3N0cmluZ19vcHQkMSIsImNvbXBhcmUkNSIsImVxdWFsJDUiLCJlbmdpbmUiLCJ0YmwiLCJzdGF0ZSIsInJlc3VsdCIsIm5ld19lbmdpbmUiLCJmcm9tX2Z1bmN0aW9uIiwiYXV4X2J1ZmZlciIsImxleGJ1ZiIsInJlYWQiLCJuZXdsZW4iLCJuZXdidWYiLCJmcm9tX2NoYW5uZWwiLCJmcm9tX3N0cmluZyQwIiwibGV4ZW1lIiwic3ViX2xleGVtZSIsInN1Yl9sZXhlbWVfb3B0Iiwic3ViX2xleGVtZV9jaGFyIiwic3ViX2xleGVtZV9jaGFyX29wdCIsImxleGVtZV9jaGFyIiwibGV4ZW1lX3N0YXJ0IiwibGV4ZW1lX2VuZCIsImxleGVtZV9zdGFydF9wIiwibGV4ZW1lX2VuZF9wIiwibmV3X2xpbmUiLCJsY3AiLCJmbHVzaF9pbnB1dCIsImVudiIsImdyb3dfc3RhY2tzIiwib2xkc2l6ZSIsIm5ld3NpemUiLCJuZXdfcyIsIm5ld192IiwibmV3X3N0YXJ0IiwibmV3X2VuZCIsImNsZWFyX3BhcnNlciIsImN1cnJlbnRfbG9va2FoZWFkX2Z1biIsInl5cGFyc2UiLCJ0YWJsZXMiLCJzdGFydCIsImxleGVyIiwiaW5pdF9hc3AiLCJpbml0X3NwIiwiaW5pdF9zdGFja2Jhc2UiLCJpbml0X3N0YXRlIiwiaW5pdF9jdXJyX2NoYXIiLCJpbml0X2x2YWwiLCJpbml0X2VycmZsYWciLCJjbWQiLCJhcmciLCJhcmckMCIsImNtZCQwIiwiYXJnJDEiLCJleG4iLCJjdXJyX2NoYXIiLCJ0b2siLCJwZWVrX3ZhbCIsInN5bWJvbF9zdGFydF9wb3MiLCJzdCIsImVuIiwic3ltYm9sX2VuZF9wb3MiLCJyaHNfc3RhcnRfcG9zIiwicmhzX2VuZF9wb3MiLCJzeW1ib2xfc3RhcnQiLCJzeW1ib2xfZW5kIiwicmhzX3N0YXJ0IiwicmhzX2VuZCIsImlzX2N1cnJlbnRfbG9va2FoZWFkIiwicGFyc2VfZXJyb3IiLCJoZWlnaHQiLCJoIiwiY3JlYXRlIiwiaGwiLCJoJDAiLCJociIsImJhbCIsImxyIiwibHYiLCJsbCIsImxyciIsImxydiIsImxybCIsInJyIiwicnYiLCJybCIsInJsciIsInJsdiIsInJsbCIsImFkZCIsInNpbmdsZXRvbiIsImFkZF9taW5fZWxlbWVudCIsImFkZF9tYXhfZWxlbWVudCIsImpvaW4iLCJyaCIsImxoIiwibWluX2VsdCIsIm1pbl9lbHRfb3B0IiwibWF4X2VsdCIsIm1heF9lbHRfb3B0IiwicmVtb3ZlX21pbl9lbHQiLCJyJDAiLCJjb25jYXQiLCJzcGxpdCIsInByZXMiLCJwcmVzJDAiLCJlbXB0eSIsImlzX2VtcHR5IiwibWVtIiwicGFyYW0kMSIsInJlbW92ZSIsInVuaW9uIiwicjIiLCJ2MiIsInIxIiwidjEiLCJyMiQwIiwicjEkMCIsImludGVyIiwiZGlmZiIsImNvbnNfZW51bSIsInMkMSIsImUkMSIsImUyJDIiLCJlMSQyIiwiZTEiLCJlMiQwIiwiZTEkMCIsImUyJDEiLCJlMSQxIiwic3Vic2V0IiwiZm9sZCIsImZvcl9hbGwiLCJleGlzdHMiLCJmaWx0ZXIiLCJwdiIsInBhcnRpdGlvbiIsImxmIiwibHQiLCJyZiIsInJ0IiwiY2FyZGluYWwiLCJlbGVtZW50c19hdXgiLCJlbGVtZW50cyIsImZpbmQiLCJmaW5kX2ZpcnN0IiwidiQwIiwiZmluZF9maXJzdF9vcHQiLCJmaW5kX2xhc3QiLCJmaW5kX2xhc3Rfb3B0IiwiZmluZF9vcHQiLCJtYXAiLCJvZl9saXN0Iiwic3ViIiwibCQzIiwieDAiLCJsJDQiLCJ4MCQwIiwibCQ1IiwieDAkMSIsIm5sIiwibCQyIiwieDQiLCJsZCIsImxyZCIsInJkIiwicmxkIiwiZGF0YSIsIm0iLCJtaW5fYmluZGluZyIsIm1pbl9iaW5kaW5nX29wdCIsIm1heF9iaW5kaW5nIiwibWF4X2JpbmRpbmdfb3B0IiwicmVtb3ZlX21pbl9iaW5kaW5nIiwidXBkYXRlIiwiZGF0YSQwIiwibWFwaSIsIm0kMCIsImFkZF9taW5fYmluZGluZyIsImFkZF9tYXhfYmluZGluZyIsImNvbmNhdF9vcl9qb2luIiwiZDEiLCJkMiIsImQyJDAiLCJkMSQwIiwiZDIkMSIsImQxJDEiLCJwdmQiLCJtJDEiLCJtMSIsIm0yIiwiYmluZGluZ3NfYXV4IiwiYmluZGluZ3MiLCJjbGVhciIsImNvcHkkMiIsInB1c2giLCJwb3AiLCJ0b3AiLCJsZW5ndGgkMSIsIml0ZXIkMyIsImNyZWF0ZSQwIiwiY2xlYXIkMCIsInEiLCJjZWxsIiwicGVlayIsImNvbnRlbnQiLCJ0YWtlIiwiY29weSQzIiwicV9yZXMiLCJwcmV2IiwibmV4dCIsImlzX2VtcHR5JDAiLCJsZW5ndGgkMiIsIml0ZXIkNCIsImZvbGQkMCIsInRyYW5zZmVyIiwicTEiLCJxMiIsInJhaXNlX3VuZGVmaW5lZCIsImZvcmNlX2xhenlfYmxvY2siLCJibGsiLCJjbG9zdXJlIiwiZm9yY2VfdmFsX2xhenlfYmxvY2siLCJmb3JjZSIsImx6diIsImZvcmNlX3ZhbCIsImZyb21fZnVuIiwiZnJvbV92YWwiLCJpc192YWwiLCJjb3VudCIsImZpbGxfYnVmZiIsImdldF9kYXRhIiwiZDExIiwiYSQwIiwiYSQxIiwicGVla19kYXRhIiwicGVlayQwIiwianVua19kYXRhIiwianVuayIsIm5nZXRfZGF0YSIsImFsIiwibnBlZWsiLCJlbXB0eSQwIiwiaXRlciQ1Iiwic3RybSIsImZyb20iLCJvZl9saXN0JDAiLCJvZl9zdHJpbmckMCIsIm9mX2J5dGVzIiwib2ZfY2hhbm5lbCIsImlhcHAiLCJpY29ucyIsImlzaW5nIiwibGFwcCIsImxjb25zIiwibHNpbmciLCJzZW1wdHkiLCJzbGF6eSIsImR1bXAiLCJkdW1wX2RhdGEiLCJjcmVhdGUkMSIsImNvbnRlbnRzIiwidG9fYnl0ZXMiLCJzdWIkMiIsImJsaXQkMiIsInNyYyIsIm50aCQwIiwibGVuZ3RoJDMiLCJjbGVhciQxIiwicmVzZXQiLCJyZXNpemUiLCJtb3JlIiwibmV3X2xlbiIsIm5ld19idWZmZXIiLCJhZGRfY2hhciIsImFkZF91dGZfOF91Y2hhciIsInBvcyQwIiwicG9zJDEiLCJhZGRfdXRmXzE2YmVfdWNoYXIiLCJ1JDAiLCJhZGRfdXRmXzE2bGVfdWNoYXIiLCJhZGRfc3Vic3RyaW5nIiwib2Zmc2V0IiwibmV3X3Bvc2l0aW9uIiwiYWRkX3N1YmJ5dGVzIiwiYWRkX3N0cmluZyIsImFkZF9ieXRlcyIsImFkZF9idWZmZXIiLCJicyIsImFkZF9jaGFubmVsIiwib3V0cHV0X2J1ZmZlciIsImFkZF9zdWJzdGl0dXRlIiwibGltJDEiLCJwcmV2aW91cyIsImkkNyIsImN1cnJlbnQiLCJpJDgiLCJvcGVuaW5nIiwiaSQ2IiwibGltJDAiLCJpJDMiLCJzdG9wIiwiaSQ0IiwiaSQ1IiwiayQyIiwibmV4dF9pIiwiaWRlbnQiLCJpJDkiLCJpJDEwIiwiaSQxMSIsInRydW5jYXRlIiwiY3JlYXRlX2NoYXJfc2V0IiwiYWRkX2luX2NoYXJfc2V0Iiwic3RyX2luZCIsIm1hc2siLCJmcmVlemVfY2hhcl9zZXQiLCJyZXZfY2hhcl9zZXQiLCJjaGFyX3NldCQwIiwiaXNfaW5fY2hhcl9zZXQiLCJwYWRfb2ZfcGFkX29wdCIsInBhZF9vcHQiLCJ3aWR0aCIsInBhcmFtX2Zvcm1hdF9vZl9pZ25vcmVkX2Zvcm1hdCIsImZtdCIsInBhZF9vcHQkMCIsInBhZF9vcHQkMSIsInBhZF9vcHQkMiIsInBhZF9vcHQkMyIsInBhZF9vcHQkNCIsInByZWNfb3B0IiwicGFkX29wdCQ1IiwibmRlYyIsInBhZF9vcHQkNiIsInBhZF9vcHQkNyIsInBhZF9vcHQkOCIsImRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uIiwiYnVmZmVyX2NyZWF0ZSIsImluaXRfc2l6ZSIsImJ1ZmZlcl9jaGVja19zaXplIiwib3ZlcmhlYWQiLCJtaW5fbGVuIiwibmV3X3N0ciIsImJ1ZmZlcl9hZGRfY2hhciIsImJ1ZmZlcl9hZGRfc3RyaW5nIiwic3RyX2xlbiIsImJ1ZmZlcl9jb250ZW50cyIsImNoYXJfb2ZfaWNvbnYiLCJjaGFyX29mX2Zjb252IiwiYnByaW50X3BhZHR5IiwicGFkdHkiLCJicHJpbnRfaWdub3JlZF9mbGFnIiwiaWduX2ZsYWciLCJicHJpbnRfcGFkX29wdCIsImJwcmludF9wYWRkaW5nIiwicGFkdHkkMCIsImJwcmludF9wcmVjaXNpb24iLCJicHJpbnRfaWNvbnZfZmxhZyIsImJwcmludF9hbHRpbnRfZm10IiwiYnByaW50X2Zjb252X2ZsYWciLCJzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQiLCJzdHIkMCIsInN0cmluZ19vZl9mb3JtYXR0aW5nX2dlbiIsImZvcm1hdHRpbmdfZ2VuIiwiYnByaW50X2NoYXJfbGl0ZXJhbCIsImJwcmludF9zdHJpbmdfbGl0ZXJhbCIsImJwcmludF9mbXR0eSIsInN1Yl9mbXR0eSIsInN1Yl9mbXR0eSQwIiwiaW50X29mX2N1c3RvbV9hcml0eSIsInN0cmluZ19vZl9mbXQiLCJmbXQkMSIsImNociQwIiwiaXNfYWxvbmUkMCIsImlzX2Fsb25lIiwiaiQwIiwiaiQxIiwiZm10JDAiLCJzeW1tIiwiZm10dHlfcmVsX2RldCIsImRlIiwiZWQiLCJhZiIsImZhIiwiZGUkMCIsImVkJDAiLCJhZiQwIiwiZmEkMCIsImRlJDEiLCJlZCQxIiwiYWYkMSIsImZhJDEiLCJkZSQyIiwiZWQkMiIsImFmJDIiLCJmYSQyIiwiZGUkMyIsImVkJDMiLCJhZiQzIiwiZmEkMyIsImRlJDQiLCJlZCQ0IiwiYWYkNCIsImZhJDQiLCJkZSQ1IiwiZWQkNSIsImFmJDUiLCJmYSQ1IiwiZGUkNiIsImVkJDYiLCJhZiQ2IiwiZmEkNiIsImRlJDciLCJlZCQ3IiwiYWYkNyIsImZhJDciLCJkZSQ4IiwiZWQkOCIsImFmJDgiLCJmYSQ4IiwidHJhbnMiLCJqZCIsImRqIiwiZ2EiLCJhZyIsImRlJDkiLCJlZCQ5IiwiYWYkOSIsImZhJDkiLCJkZSQxMCIsImVkJDEwIiwiYWYkMTAiLCJmYSQxMCIsImRlJDExIiwiZWQkMTEiLCJhZiQxMSIsImZhJDExIiwiZGUkMTIiLCJlZCQxMiIsImFmJDEyIiwiZmEkMTIiLCJkZSQxMyIsImVkJDEzIiwiYWYkMTMiLCJmYSQxMyIsInJlc3QyIiwicmVzdDIkMCIsInJlc3QyJDEiLCJyZXN0MiQyIiwicmVzdDIkMyIsInJlc3QyJDQiLCJyZXN0MiQ1IiwicmVzdDIkNiIsInJlc3QyJDciLCJyZXN0MiQ4IiwidHkyMiIsInR5MjEiLCJmNCIsImYyIiwicmVzdDIkOSIsInJlc3QyJDEwIiwicmVzdDIkMTEiLCJyZXN0MiQxMiIsInJlc3QyJDEzIiwiZm10dHlfb2ZfcGFkZGluZ19mbXR0eSIsImZtdHR5X29mX2N1c3RvbSIsImFyaXR5JDAiLCJmbXR0eV9vZl9mbXQiLCJ0eV9yZXN0IiwicHJlY190eSIsImZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSIsInR5X3Jlc3QkMCIsInByZWNfdHkkMCIsInR5X3Jlc3QkMSIsInByZWNfdHkkMSIsInR5X3Jlc3QkMiIsInByZWNfdHkkMiIsInR5X3Jlc3QkMyIsInByZWNfdHkkMyIsImZtdHR5JDEiLCJmbXR0eSQyIiwiZm10dHkkMyIsInR5JDAiLCJmbXR0eSQ0IiwiZm10dHkkNSIsInR5cGVfcGFkZGluZyIsInciLCJ0eXBlX3BhZHByZWMiLCJ0eXBlX2Zvcm1hdCIsInR5cGVfZm9ybWF0X2dlbiIsInR5cGVfaWdub3JlZF9wYXJhbV9vbmUiLCJmbXR0eV9yZXN0IiwiZm10X3Jlc3QiLCJmbXR0eV9yZXN0JDAiLCJmbXRfcmVzdCQwIiwiZm10X3Jlc3QkMSIsImZtdHR5X3Jlc3QkMSIsImZtdCQyIiwiZm10X3Jlc3QkMiIsImZtdHR5X3Jlc3QkMiIsImZtdCQzIiwiZm10X3Jlc3QkMyIsImZtdHR5X3Jlc3QkMyIsImZtdCQ0IiwiZm10X3Jlc3QkNCIsImZtdHR5X3Jlc3QkNCIsImZtdCQ1IiwiZm10X3Jlc3QkNSIsImZtdHR5X3Jlc3QkNSIsImZtdHR5JDYiLCJmbXQkNiIsImZtdF9yZXN0JDYiLCJmbXR0eV9yZXN0JDYiLCJmbXR0eSQ3IiwiZm10JDciLCJmbXRfcmVzdCQ3IiwiZm10dHlfcmVzdCQ3IiwiZm10dHkkOCIsImZtdCQ4IiwiZm10X3Jlc3QkOCIsImZtdHR5X3Jlc3QkOCIsImZtdHR5JDkiLCJmbXQkOSIsImZtdF9yZXN0JDkiLCJmbXR0eSQxMCIsImZtdCQxMCIsImZtdF9yZXN0JDEwIiwiZm10dHkkMTEiLCJmbXQkMTEiLCJmbXRfcmVzdCQxMSIsImZtdHR5JDEyIiwiZm10JDEyIiwiZm10dHlfcmVzdCQ5IiwiZm10X3Jlc3QkMTIiLCJmbXR0eSQxMyIsImZtdCQxMyIsImZtdHR5X3Jlc3QkMTAiLCJzdWJfZm10dHkxIiwiZm10X3Jlc3QkMTMiLCJzdWJfZm10dHkkMSIsImZtdHR5JDE0IiwiZm10JDE0IiwiZm10dHlfcmVzdCQxMSIsImZtdF9yZXN0JDE0IiwiZm10dHkkMTUiLCJmbXQkMTUiLCJmbXR0eV9yZXN0JDEyIiwiZm10X3Jlc3QkMTUiLCJmbXR0eSQxNiIsImZtdCQxNiIsImZtdF9yZXN0JDE2IiwiZm10dHkkMTciLCJmbXQkMTciLCJmbXRfcmVzdCQxNyIsImZtdHR5MyIsImZtdDMiLCJzdHIkMSIsImZtdDEkMCIsImZtdHR5MiQwIiwiZm10MiQwIiwiZm10dHkzJDAiLCJmbXQzJDAiLCJmbXR0eV9yZXN0JDEzIiwiZm10X3Jlc3QkMTgiLCJmbXR0eSQxOCIsImZtdCQxOCIsImZtdHR5X3Jlc3QkMTQiLCJmbXRfcmVzdCQxOSIsImZtdHR5JDE5IiwiZm10JDE5IiwiZm10dHlfcmVzdCQxNSIsImZtdF9yZXN0JDIwIiwiZm10dHkkMjAiLCJmbXQkMjAiLCJmbXR0eV9yZXN0JDE2IiwiZm10dHkkMjEiLCJmbXQkMjEiLCJzdWJfZm10dHkkMiIsInN1Yl9mbXR0eSQzIiwidHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24iLCJmbXR0eSQyMiIsImZtdCQyMiIsInN1Yl9mbXR0eSQ0Iiwic3ViX2ZtdHR5X3Jlc3QiLCJzdWJfZm10dHlfcmVzdCQwIiwic3ViX2ZtdHR5X3Jlc3QkMSIsInN1Yl9mbXR0eV9yZXN0JDIiLCJzdWJfZm10dHlfcmVzdCQzIiwic3ViX2ZtdHR5X3Jlc3QkNCIsInN1Yl9mbXR0eV9yZXN0JDUiLCJzdWJfZm10dHlfcmVzdCQ2Iiwic3ViX2ZtdHR5X3Jlc3QkNyIsInN1Yl9mbXR0eV9yZXN0JDgiLCJzdWJfZm10dHlfcmVzdCQ5Iiwic3ViX2ZtdHR5X3Jlc3QkMTAiLCJzdWJfZm10dHlfcmVzdCQxMSIsInN1Yl9mbXR0eV9yZXN0JDEyIiwic3ViX2ZtdHR5X3Jlc3QkMTMiLCJzdWJfZm10dHlfcmVzdCQxNCIsInN1YjJfZm10dHkiLCJzdWJfZm10dHlfcmVzdCQxNSIsInN1YjJfZm10dHkkMCIsInN1Yl9mbXR0eV9yZXN0JDE2Iiwic3ViMl9mbXR0eSQxIiwic3ViMV9mbXR0eSIsInN1Yl9mbXR0eV9yZXN0JDE3Iiwic3ViMl9mbXR0eSQyIiwic3ViMV9mbXR0eSQwIiwic3ViX2ZtdHR5X3Jlc3QkMTgiLCJzdWJfZm10dHlfcmVzdCQxOSIsInN1Yl9mbXR0eV9yZXN0JDIwIiwic3ViX2ZtdHR5X3Jlc3QkMjEiLCJzdWJfZm10dHlfcmVzdCQyMiIsInN1Yl9mbXR0eV9yZXN0JDIzIiwic3ViX2ZtdHR5X3Jlc3QkMjQiLCJzdWJfZm10dHlfcmVzdCQyNSIsInN1Yl9mbXR0eV9yZXN0JDI2IiwicmVjYXN0IiwiZml4X3BhZGRpbmciLCJmaXhfaW50X3ByZWNpc2lvbiIsInJlcyQxIiwic3RyaW5nX3RvX2NhbWxfc3RyaW5nIiwiY29udmVydF9pbnQiLCJjb252ZXJ0X2ludDMyIiwiY29udmVydF9uYXRpdmVpbnQiLCJjb252ZXJ0X2ludDY0IiwiY29udmVydF9mbG9hdCIsInNpZ24iLCJzeW1iIiwic3RyaW5nX29mX2ZtdHR5IiwibWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24iLCJvIiwibWFrZV9wcmludGYiLCJwJDAiLCJwJDEiLCJtYWtlX3BhZGRpbmciLCJuZXdfYWNjIiwibWFrZV9wcmludGYkMCIsImFjYyQxIiwiYWNjJDIiLCJhY2MkMyIsImFjYyQ0IiwiayQzIiwia29jIiwia2FjYyIsImskNCIsIm1ha2VfaWdub3JlZF9wYXJhbSQwIiwibWFrZV9jdXN0b20kMCIsIm1ha2VfaW52YWxpZF9hcmciLCJtYWtlX2Zyb21fZm10dHkkMCIsIm1ha2VfZnJvbV9mbXR0eSIsIm1ha2VfY3VzdG9tIiwibWFrZV9pZ25vcmVkX3BhcmFtIiwiZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24iLCJtYWtlX2lwcmludGYiLCJtYWtlX2lwcmludGYkMCIsInJlc3QkMjQiLCJyZXN0JDI1IiwiZm5fb2ZfY3VzdG9tX2FyaXR5JDAiLCJmbl9vZl9jdXN0b21fYXJpdHkiLCJvdXRwdXRfYWNjIiwicCQyIiwicCQzIiwibXNnIiwicCQ0IiwiYnVmcHV0X2FjYyIsInN0cnB1dF9hY2MiLCJmYWlsd2l0aF9tZXNzYWdlIiwib3Blbl9ib3hfb2Zfc3RyaW5nIiwiaW52YWxpZF9ib3giLCJwYXJzZV9zcGFjZXMiLCJwYXJzZV9sd29yZCIsInBhcnNlX2ludCIsIndzdGFydCIsIndlbmQiLCJib3hfbmFtZSIsIm5zdGFydCIsIm5lbmQiLCJpbmRlbnQiLCJleHBfZW5kIiwiYm94X3R5cGUiLCJtYWtlX3BhZGRpbmdfZm10X2ViYiIsIm1ha2VfcGFkcHJlY19mbXRfZWJiIiwiZm10X2ViYl9vZl9zdHJpbmciLCJsZWdhY3lfYmVoYXZpb3IiLCJmbGFnIiwibGVnYWN5X2JlaGF2aW9yJDAiLCJpbnZhbGlkX2Zvcm1hdF9tZXNzYWdlIiwidW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IiwiZW5kX2luZCIsImludmFsaWRfZm9ybWF0X3dpdGhvdXQiLCJleHBlY3RlZF9jaGFyYWN0ZXIiLCJleHBlY3RlZCIsImFkZF9saXRlcmFsIiwibGl0X3N0YXJ0IiwicGFyc2UiLCJzdHJfaW5kJDIiLCJwYXJzZV9mbGFncyIsInN0cl9pbmQkMCIsInBhcnNlX3RhZyIsInBhcnNlX2dvb2RfYnJlYWsiLCJwYXJzZV9tYWdpY19zaXplIiwic3RyX2luZCQxIiwicGFyc2VfY29udmVyc2lvbiIsInBjdF9pbmQiLCJwbHVzIiwic3BhY2UiLCJwYWRwcmVjIiwicGx1c191c2VkIiwiaGFzaF91c2VkIiwic3BhY2VfdXNlZCIsImlnbl91c2VkIiwicGFkX3VzZWQiLCJwcmVjX3VzZWQiLCJnZXRfcGx1cyIsImdldF9oYXNoIiwiZ2V0X3NwYWNlIiwiZ2V0X2lnbiIsImdldF9wYWQiLCJnZXRfcHJlYyIsImdldF9wYWRwcmVjIiwiZ2V0X2ludF9wYWQiLCJpbmNvbXBhdGlibGVfZmxhZyIsImNoZWNrX25vXzAiLCJvcHRfb2ZfcGFkIiwid2lkdGgkMCIsIndpZHRoJDEiLCJnZXRfcGFkX29wdCIsImdldF9wYWRwcmVjX29wdCIsImZtdF9yZXN1bHQiLCJzdWJfZW5kIiwic2VhcmNoX3N1YmZvcm1hdF9lbmQiLCJzdWJfZm10IiwiaWdub3JlZCQyIiwiY291bnRlciQwIiwiaWdub3JlZCQ2IiwiaWdub3JlZCQ3IiwiYWRkX3JhbmdlIiwiZmFpbF9zaW5nbGVfcGVyY2VudCIsInBhcnNlX2NoYXJfc2V0X2NvbnRlbnQiLCJwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyJDAiLCJwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIiwicmV2ZXJzZSIsIm5leHRfaW5kIiwiY2hhcl9zZXQkMSIsImlnbm9yZWQkOSIsImNoYXJfZm9ybWF0IiwiZm10X3Jlc3QkMjEiLCJmbXRfcmVzdCQyMiIsInBhZCQ5IiwiZm10X3Jlc3QkMjMiLCJpZ25vcmVkJDEwIiwiZm10X3Jlc3QkMjQiLCJwYWQkMTAiLCJmbXRfcmVzdCQyNSIsInN1Yl9lbmQkMCIsInN1Yl9mbXQkMCIsImZtdF9yZXN0JDI2IiwiaWdub3JlZCQxMSIsImlnbm9yZWQkMyIsInN5bWIkMCIsImlnbm9yZWQkNSIsImNvbXB1dGVfaW50X2NvbnYiLCJpZ25vcmVkJDgiLCJwcmVjJDQiLCJzcGFjZSQxIiwicGx1cyQyIiwicGx1cyQzIiwic3BhY2UkMiIsImlnbm9yZWQkNCIsImlnbm9yZWQiLCJpZ25vcmVkJDAiLCJpZ25vcmVkJDEiLCJwbHVzJDAiLCJoYXNoJDAiLCJzcGFjZSQwIiwicGx1cyQxIiwiaWduJDAiLCJwYXJzZV9hZnRlcl9wcmVjaXNpb24iLCJtaW51cyIsInBhcnNlX2NvbnYiLCJwYXJzZV9hZnRlcl9wYWRkaW5nIiwicGFyc2VfbGl0ZXJhbCIsInBhcnNlX3Bvc2l0aXZlIiwibmV3X2luZCIsIm1pbnVzJDAiLCJzZXRfZmxhZyIsInN0cl9pbmQkMyIsInN0cl9pbmQkNCIsInN0cl9pbmQkNSIsImlzX29wZW5fdGFnIiwiaW5kIiwic3ViX3N0ciIsInN1Yl9mb3JtYXQkMCIsImZvcm1hdHRpbmckMCIsImZvcm1hdHRpbmciLCJzdHJfaW5kXzEiLCJwYXJzZV9pbnRlZ2VyIiwic3RyX2luZF8yIiwic3RyX2luZF8zIiwiZm9ybWF0dGluZ19saXQkMCIsInN0cl9pbmRfNCIsInN0cl9pbmRfNSIsInN1Yl9lbmQkMSIsInN1Yl9lbmQkMiIsInN0cl9pbmQkNiIsInN0cl9pbmQkNyIsIm9wdGlvbiIsInN1YmZtdCIsImZvcm1hdF9vZl9zdHJpbmdfZm10dHkiLCJmb3JtYXRfb2Zfc3RyaW5nX2Zvcm1hdCIsImtmcHJpbnRmIiwia2JwcmludGYiLCJpa2ZwcmludGYiLCJmcHJpbnRmIiwiYnByaW50ZiIsImlmcHJpbnRmIiwicHJpbnRmIiwiZXByaW50ZiIsImtzcHJpbnRmIiwic3ByaW50ZiIsImFzc29jMyIsInkyIiwieTEiLCJzcGxpdCQwIiwibWFrZV9zeW1saXN0IiwicHJlZml4Iiwic3VmZml4IiwiaGVscF9hY3Rpb24iLCJhZGRfaGVscCIsInNwZWNsaXN0IiwiYWRkMiIsInVzYWdlX2IiLCJlcnJtc2ciLCJkb2MiLCJzcGVjIiwia2V5IiwidXNhZ2Vfc3RyaW5nIiwidXNhZ2UiLCJib29sX29mX3N0cmluZ19vcHQkMCIsImludF9vZl9zdHJpbmdfb3B0JDAiLCJmbG9hdF9vZl9zdHJpbmdfb3B0JDAiLCJwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pY19hdXgiLCJhbGxvd19leHBhbmQiLCJhcmd2IiwiYW5vbmZ1biIsImluaXRwb3MiLCJjb252ZXJ0X2Vycm9yIiwiZXJyb3IiLCJwcm9nbmFtZSIsIm9wdCIsImFjdGlvbiIsImZvbGxvdyQwIiwia2V5d29yZCIsIm5vX2FyZyQwIiwiZm9sbG93Iiwibm9fYXJnIiwiZ2V0X2FyZyQwIiwiZ2V0X2FyZyIsImNvbnN1bWVfYXJnJDAiLCJjb25zdW1lX2FyZyIsInRyZWF0X2FjdGlvbiQwIiwidHJlYXRfYWN0aW9uIiwiZiQwIiwiZiQxIiwiciQxIiwiZiQyIiwiciQyIiwiYXJnJDIiLCJ4JDAiLCJmJDMiLCJhcmckMyIsIngkMSIsInIkMyIsImFyZyQ0IiwieCQyIiwic3BlY3MiLCJmJDQiLCJhcmckNSIsImYkNSIsImYkNiIsImFyZyQ2IiwibmV3YXJnIiwiYmVmb3JlIiwiYWZ0ZXIiLCJwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pYyIsInBhcnNlX2FyZ3ZfZHluYW1pYyIsInN0aCIsImN1cnJlbnQkMCIsInBhcnNlX2FyZ3YiLCJtc2ckMCIsIm1zZyQxIiwicGFyc2VfZHluYW1pYyIsInBhcnNlX2V4cGFuZCIsInNlY29uZF93b3JkIiwibG9vcCIsIm1heF9hcmdfbGVuIiwiY3VyIiwia3dkIiwicmVwbGFjZV9sZWFkaW5nX3RhYiIsInNlZW4iLCJhbGlnbiIsImxpbWl0IiwiY29tcGxldGVkIiwia3NkIiwiY3V0Y29sJDAiLCJzcGFjZXMkMCIsImN1dGNvbCIsImt3ZF9sZW4iLCJzcGFjZXMiLCJyZWFkX2F1eCIsInRyaW0iLCJmaWxlIiwid29yZHMiLCJzdGFzaCIsIndvcmQiLCJyZWFkX2FyZyIsInJlYWRfYXJnMCIsIndyaXRlX2F1eCIsImFyZ3MiLCJ3cml0ZV9hcmciLCJ3cml0ZV9hcmcwIiwicHJpbnRlcnMiLCJmaWVsZCIsIm90aGVyX2ZpZWxkcyIsImZpZWxkcyIsInRvX3N0cmluZyQzIiwiY29udiIsImNoYXIkMCIsImxpbmUiLCJjaGFyJDEiLCJsaW5lJDAiLCJmaWxlJDAiLCJjaGFyJDIiLCJsaW5lJDEiLCJmaWxlJDEiLCJjb25zdHJ1Y3RvciIsInByaW50IiwiZmN0IiwiY2F0Y2gkMCIsImNvbnZlcnRfcmF3X2JhY2t0cmFjZSIsImJ0IiwiZm9ybWF0X2JhY2t0cmFjZV9zbG90IiwiaW5mbyIsImlzX3JhaXNlIiwicHJpbnRfcmF3X2JhY2t0cmFjZSIsIm91dGNoYW4iLCJyYXdfYmFja3RyYWNlIiwiYmFja3RyYWNlIiwicHJpbnRfYmFja3RyYWNlIiwicmF3X2JhY2t0cmFjZV90b19zdHJpbmciLCJiYWNrdHJhY2Vfc2xvdF9pc19yYWlzZSIsImJhY2t0cmFjZV9zbG90X2lzX2lubGluZSIsImJhY2t0cmFjZV9zbG90X2xvY2F0aW9uIiwiYmFja3RyYWNlX3Nsb3RzIiwiZ2V0X2JhY2t0cmFjZSIsInJlZ2lzdGVyX3ByaW50ZXIiLCJmbiIsImV4bl9zbG90IiwiZXhuX3Nsb3RfaWQiLCJleG5fc2xvdF9uYW1lIiwidW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIiLCJzZXRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIiLCJwcmludF9zdGF0IiwiYWxsb2NhdGVkX2J5dGVzIiwibWEiLCJwcm8iLCJtaSIsImNyZWF0ZV9hbGFybSIsImRlbGV0ZV9hbGFybSIsInN0cmluZyIsImJ5dGVzIiwic3Vic3RyaW5nIiwic3ViYnl0ZXMiLCJmaWxlbmFtZSIsIm91dHB1dCQwIiwiZGlnZXN0IiwiaW5wdXQkMCIsImNoYXJfaGV4IiwidG9faGV4IiwiZnJvbV9oZXgiLCJkaWdpdCIsIm5ld19zdGF0ZSIsImFzc2lnbiIsInN0MSIsInN0MiIsImZ1bGxfaW5pdCIsInNlZWQiLCJzZWVkJDAiLCJtYWtlJDEiLCJtYWtlX3NlbGZfaW5pdCIsImNvcHkkNCIsImJpdHMiLCJjdXJ2YWwiLCJuZXd2YWwiLCJuZXd2YWwzMCIsImludCQwIiwiYm91bmQiLCJpbnQzMiIsImIxIiwiYjIiLCJpbnQ2NCIsImIzIiwibmF0aXZlaW50IiwiZmxvYXQkMCIsImJvb2wiLCJkZWZhdWx0JDAiLCJiaXRzJDAiLCJpbnQkMSIsImludDMyJDAiLCJuYXRpdmVpbnQkMCIsImludDY0JDAiLCJmbG9hdCQxIiwic2NhbGUiLCJib29sJDAiLCJmdWxsX2luaXQkMCIsImluaXQkMyIsInNlbGZfaW5pdCIsImdldF9zdGF0ZSIsInNldF9zdGF0ZSIsImhhc2hfcGFyYW0iLCJzZWVkZWRfaGFzaCIsIm9uZ29pbmdfdHJhdmVyc2FsIiwiZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCIsInBhcmFtcyIsInJhbmRvbWl6ZWRfZGVmYXVsdCIsInJhbmRvbWl6ZWQiLCJyYW5kb21pemUiLCJpc19yYW5kb21pemVkIiwicHJuZyIsImNyZWF0ZSQyIiwiaW5pdGlhbF9zaXplIiwicmFuZG9tIiwiY2xlYXIkMiIsInJlc2V0JDAiLCJjb3B5X2J1Y2tldGxpc3QiLCJrZXkkMCIsIm5leHQkMCIsImNvcHkkNSIsImxlbmd0aCQ0IiwicmVzaXplJDAiLCJpbmRleGZ1biIsIm9kYXRhIiwib3NpemUiLCJuc2l6ZSIsIm5kYXRhIiwibmRhdGFfdGFpbCIsImlucGxhY2UiLCJjZWxsJDAiLCJuaWR4IiwibWF0Y2gkMCIsImtleV9pbmRleCIsImFkZCQwIiwiYnVja2V0IiwiZmluZCQwIiwiazEiLCJuZXh0MSIsImsyIiwibmV4dDIiLCJrMyIsImQzIiwibmV4dDMiLCJmaW5kX29wdCQwIiwiZmluZF9hbGwkMCIsImZpbmRfaW5fYnVja2V0IiwicmVwbGFjZSIsIm1lbSQxIiwiaXRlciQ2IiwiZG9fYnVja2V0Iiwib2xkX3RyYXYiLCJmaWx0ZXJfbWFwX2lucGxhY2VfYnVja2V0IiwiZmlsdGVyX21hcF9pbnBsYWNlIiwiZm9sZCQxIiwiYiQwIiwiYnVja2V0X2xlbmd0aCIsInN0YXRzIiwibWJsIiwiaGlzdG8iLCJmaW5kX2FsbCIsImNvcHkiLCJsZW5ndGgiLCJzeiIsImxlbmd0aCQ1IiwiZmlsbCQxIiwiYXIiLCJlbXB0eWJ1Y2tldCIsImdldF9pbmRleCIsInN6JDAiLCJzeiQxIiwiY291bnRfYnVja2V0IiwiYWRkX2F1eCIsInNldHRlciIsImluZGV4IiwiYnVja2V0JDAiLCJoYXNoZXMiLCJuZXdzeiIsIm5ld2J1Y2tldCIsIm5ld2hhc2hlcyIsImhidWNrZXQiLCJwcmV2X2xlbiIsImxpdmUiLCJqJDIiLCJuZXd0Iiwib2IiLCJvaCIsInNldHRlciQwIiwibmIiLCJuaSIsImZpbmRfb3IiLCJpZm5vdGZvdW5kIiwiZmluZF9zaGFkb3ciLCJpZmZvdW5kIiwibGVucyIsInRvdGxlbiIsImFkZF9xdWV1ZSIsInRha2VfcXVldWUiLCJwcF9lbnF1ZXVlIiwidG9rZW4iLCJwcF9pbmZpbml0eSIsInBwX291dHB1dF9zdHJpbmciLCJwcF9vdXRwdXRfbmV3bGluZSIsImJyZWFrX25ld19saW5lIiwicmVhbF9pbmRlbnQiLCJicmVha19saW5lIiwiYnJlYWtfc2FtZV9saW5lIiwicHBfZm9yY2VfYnJlYWtfbGluZSIsImJsX3R5IiwicHBfc2tpcF90b2tlbiIsImZvcm1hdF9wcF90b2tlbiIsInRhYnMiLCJhZGRfdGFiIiwibHMiLCJscyQwIiwidGFncyIsInRhZ19uYW1lIiwibWFya2VyIiwib2ZmIiwib2ZmJDAiLCJpbnNlcnRpb25fcG9pbnQiLCJ0YWJzJDAiLCJ0YWIiLCJvZmYkMSIsImluc2VydGlvbl9wb2ludCQwIiwib2Zmc2V0JDAiLCJibF90eXBlIiwidGJveCIsInRhZ19uYW1lJDAiLCJtYXJrZXIkMCIsImFkdmFuY2VfbG9vcCIsInNpemUkMCIsImFkdmFuY2VfbGVmdCIsImVucXVldWVfYWR2YW5jZSIsImVucXVldWVfc3RyaW5nX2FzIiwicV9lbGVtIiwic2Nhbl9zdGFja19ib3R0b20iLCJjbGVhcl9zY2FuX3N0YWNrIiwic2V0X3NpemUiLCJxdWV1ZV9lbGVtIiwibGVmdF90b3QiLCJzY2FuX3B1c2giLCJwcF9vcGVuX2JveF9nZW4iLCJicl90eSIsImVsZW0iLCJwcF9jbG9zZV9ib3giLCJwcF9vcGVuX3RhZyIsInBwX2Nsb3NlX3RhZyIsInBwX3NldF9wcmludF90YWdzIiwicHBfc2V0X21hcmtfdGFncyIsInBwX2dldF9wcmludF90YWdzIiwicHBfZ2V0X21hcmtfdGFncyIsInBwX3NldF90YWdzIiwicHBfZ2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIiwicHBfc2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIiwicGN0IiwicG90IiwibWN0IiwibW90IiwicHBfcmluaXQiLCJwcF9mbHVzaF9xdWV1ZSIsInBwX3ByaW50X2FzX3NpemUiLCJwcF9wcmludF9hcyIsImlzaXplIiwicHBfcHJpbnRfc3RyaW5nIiwicHBfcHJpbnRfaW50IiwicHBfcHJpbnRfZmxvYXQiLCJwcF9wcmludF9ib29sIiwicHBfcHJpbnRfY2hhciIsInBwX29wZW5faGJveCIsInBwX29wZW5fdmJveCIsInBwX29wZW5faHZib3giLCJwcF9vcGVuX2hvdmJveCIsInBwX29wZW5fYm94IiwicHBfcHJpbnRfbmV3bGluZSIsInBwX3ByaW50X2ZsdXNoIiwicHBfZm9yY2VfbmV3bGluZSIsInBwX3ByaW50X2lmX25ld2xpbmUiLCJwcF9wcmludF9icmVhayIsInBwX3ByaW50X3NwYWNlIiwicHBfcHJpbnRfY3V0IiwicHBfb3Blbl90Ym94IiwicHBfY2xvc2VfdGJveCIsInBwX3ByaW50X3RicmVhayIsInBwX3ByaW50X3RhYiIsInBwX3NldF90YWIiLCJwcF9zZXRfbWF4X2JveGVzIiwicHBfZ2V0X21heF9ib3hlcyIsInBwX292ZXJfbWF4X2JveGVzIiwicHBfc2V0X2VsbGlwc2lzX3RleHQiLCJwcF9nZXRfZWxsaXBzaXNfdGV4dCIsInBwX2xpbWl0IiwicHBfc2V0X21heF9pbmRlbnQiLCJwcF9nZXRfbWF4X2luZGVudCIsInBwX3NldF9tYXJnaW4iLCJuZXdfbWF4X2luZGVudCIsInBwX2dldF9tYXJnaW4iLCJwcF9zZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMiLCJwcF9nZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMiLCJwcF9zZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMiLCJwcF9nZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMiLCJkaXNwbGF5X25ld2xpbmUiLCJibGFua19saW5lIiwiZGlzcGxheV9pbmRlbnQiLCJwcF9zZXRfZm9ybWF0dGVyX291dF9jaGFubmVsIiwiZGVmYXVsdF9wcF9tYXJrX29wZW5fdGFnIiwiZGVmYXVsdF9wcF9tYXJrX2Nsb3NlX3RhZyIsImRlZmF1bHRfcHBfcHJpbnRfb3Blbl90YWciLCJkZWZhdWx0X3BwX3ByaW50X2Nsb3NlX3RhZyIsInBwX21ha2VfZm9ybWF0dGVyIiwicHBfcXVldWUiLCJzeXNfdG9rIiwic3lzX3NjYW5fc3RhY2siLCJmb3JtYXR0ZXJfb2Zfb3V0X2Z1bmN0aW9ucyIsIm91dF9mdW5zIiwibWFrZV9mb3JtYXR0ZXIiLCJmbHVzaCIsInBwZiIsImZvcm1hdHRlcl9vZl9vdXRfY2hhbm5lbCIsImZvcm1hdHRlcl9vZl9idWZmZXIiLCJwcF9idWZmZXJfc2l6ZSIsInBwX21ha2VfYnVmZmVyIiwic3RkYnVmIiwic3RkX2Zvcm1hdHRlciIsImVycl9mb3JtYXR0ZXIiLCJzdHJfZm9ybWF0dGVyIiwiZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciIsImZsdXNoX3N0cl9mb3JtYXR0ZXIiLCJtYWtlX3N5bWJvbGljX291dHB1dF9idWZmZXIiLCJjbGVhcl9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIiwic29iIiwiZ2V0X3N5bWJvbGljX291dHB1dF9idWZmZXIiLCJmbHVzaF9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIiwiaXRlbXMiLCJhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0iLCJpdGVtIiwiZm9ybWF0dGVyX29mX3N5bWJvbGljX291dHB1dF9idWZmZXIiLCJvcGVuX2hib3giLCJvcGVuX3Zib3giLCJvcGVuX2h2Ym94Iiwib3Blbl9ob3Zib3giLCJvcGVuX2JveCIsImNsb3NlX2JveCIsIm9wZW5fdGFnIiwiY2xvc2VfdGFnIiwicHJpbnRfYXMiLCJwcmludF9zdHJpbmckMCIsInByaW50X2ludCQwIiwicHJpbnRfZmxvYXQkMCIsInByaW50X2NoYXIkMCIsInByaW50X2Jvb2wiLCJwcmludF9icmVhayIsInByaW50X2N1dCIsInByaW50X3NwYWNlIiwiZm9yY2VfbmV3bGluZSIsInByaW50X2ZsdXNoIiwicHJpbnRfbmV3bGluZSQwIiwicHJpbnRfaWZfbmV3bGluZSIsIm9wZW5fdGJveCIsImNsb3NlX3Rib3giLCJwcmludF90YnJlYWsiLCJzZXRfdGFiIiwicHJpbnRfdGFiIiwic2V0X21hcmdpbiIsImdldF9tYXJnaW4iLCJzZXRfbWF4X2luZGVudCIsImdldF9tYXhfaW5kZW50Iiwic2V0X21heF9ib3hlcyIsImdldF9tYXhfYm94ZXMiLCJvdmVyX21heF9ib3hlcyIsInNldF9lbGxpcHNpc190ZXh0IiwiZ2V0X2VsbGlwc2lzX3RleHQiLCJzZXRfZm9ybWF0dGVyX291dF9jaGFubmVsIiwic2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIiwiZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIiwic2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIiwiZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIiwic2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIiwiZ2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIiwic2V0X3ByaW50X3RhZ3MiLCJnZXRfcHJpbnRfdGFncyIsInNldF9tYXJrX3RhZ3MiLCJnZXRfbWFya190YWdzIiwic2V0X3RhZ3MiLCJwcF9wcmludF9saXN0IiwicHBfdiIsIm9wdCQwIiwicHBfc2VwIiwib3B0JDEiLCJwcF9wcmludF90ZXh0IiwiY29tcHV0ZV90YWciLCJ0YWdfYWNjIiwib3V0cHV0X2Zvcm1hdHRpbmdfbGl0Iiwib3V0cHV0X2FjYyQwIiwiYnR5IiwicCQ1IiwicCQ2Iiwic3RycHV0X2FjYyQwIiwic2l6ZSQxIiwia2ZwcmludGYkMCIsImlrZnByaW50ZiQwIiwiZnByaW50ZiQwIiwiaWZwcmludGYkMCIsInByaW50ZiQwIiwiZXByaW50ZiQwIiwia3NwcmludGYkMCIsInNwcmludGYkMCIsImthc3ByaW50ZiIsImFzcHJpbnRmIiwicHBfc2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyIsInBwX2dldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMiLCJzZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIiwiZ2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyIsImJwcmludGYkMCIsIm51bGxfY2hhciIsIm5leHRfY2hhciIsImliIiwicGVla19jaGFyIiwiY2hlY2tlZF9wZWVrX2NoYXIiLCJlbmRfb2ZfaW5wdXQiLCJiZWdpbm5pbmdfb2ZfaW5wdXQiLCJuYW1lX29mX2lucHV0IiwiZm5hbWUiLCJjaGFyX2NvdW50IiwicmVzZXRfdG9rZW4iLCJpbnZhbGlkYXRlX2N1cnJlbnRfY2hhciIsInRva2VuX3N0cmluZyIsInRva2VuX2J1ZmZlciIsInNraXBfY2hhciIsImlnbm9yZV9jaGFyIiwic3RvcmVfY2hhciIsImRlZmF1bHRfdG9rZW5fYnVmZmVyX3NpemUiLCJjcmVhdGUkMyIsImluYW1lIiwiZnJvbV9zdHJpbmckMSIsImZyb21fZnVuY3Rpb24kMCIsInNjYW5fY2xvc2VfYXRfZW5kIiwic2Nhbl9yYWlzZV9hdF9lbmQiLCJmcm9tX2ljIiwic2Nhbl9jbG9zZV9pYyIsImVvZiIsInN0ZGliIiwib3Blbl9pbl9maWxlIiwiZnJvbV9maWxlIiwiZnJvbV9maWxlX2JpbiIsImZyb21fY2hhbm5lbCQwIiwiY2xvc2VfaW4iLCJpYyQwIiwibWVtbyIsIm1lbW9fZnJvbV9pYyIsIm1lbW9fZnJvbV9jaGFubmVsIiwiYmFkX2lucHV0IiwiYmFkX2lucHV0X2VzY2FwZSIsImJhZF90b2tlbl9sZW5ndGgiLCJtZXNzYWdlIiwiYmFkX2Zsb2F0IiwiYmFkX2hleF9mbG9hdCIsImNoYXJhY3Rlcl9taXNtYXRjaCIsImNpIiwiY2hlY2tfdGhpc19jaGFyIiwiY2hlY2tfY2hhciIsInRva2VuX2NoYXIiLCJ0b2tlbl9ib29sIiwiaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIiLCJ0b2tlbl9pbnRfbGl0ZXJhbCIsInRva2VuX2Zsb2F0Iiwic2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIiLCJ3aWR0aCQyIiwic2Nhbl91bnNpZ25lZF9kZWNpbWFsX2ludCIsInNjYW5fZGlnaXRfcGx1cyIsImJhc2lzIiwiZGlnaXRwIiwid2lkdGgkMyIsImlzX2JpbmFyeV9kaWdpdCIsInNjYW5fYmluYXJ5X2ludCIsImlzX29jdGFsX2RpZ2l0Iiwic2Nhbl9vY3RhbF9pbnQiLCJpc19oZXhhX2RpZ2l0Iiwic2Nhbl9oZXhhZGVjaW1hbF9pbnQiLCJzY2FuX3NpZ24iLCJzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWxfaW50Iiwic2Nhbl9pbnRfY29udmVyc2lvbiIsInNjYW5fZnJhY3Rpb25hbF9wYXJ0Iiwic2Nhbl9leHBvbmVudF9wYXJ0Iiwic2Nhbl9mbG9hdCIsInByZWNpc2lvbiIsInByZWNpc2lvbiQwIiwiY2hlY2tfY2FzZV9pbnNlbnNpdGl2ZV9zdHJpbmciLCJzY2FuX2hleF9mbG9hdCIsIndpZHRoJDQiLCJ3aWR0aCQ1Iiwid2lkdGgkNiIsIndpZHRoJDEwIiwid2lkdGgkNyIsIndpZHRoJDgiLCJ3aWR0aCQ5Iiwic2Nhbl9jYW1sX2Zsb2F0X3Jlc3QiLCJ3aWR0aF9wcmVjaXNpb24iLCJmcmFjX3dpZHRoIiwic2Nhbl9jYW1sX2Zsb2F0Iiwic2Nhbl9zdHJpbmciLCJzdHAiLCJzY2FuX2NoYXIiLCJoZXhhZGVjaW1hbF92YWx1ZV9vZl9jaGFyIiwiY2hlY2tfbmV4dF9jaGFyIiwiY2hlY2tfbmV4dF9jaGFyX2Zvcl9jaGFyIiwiY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmciLCJzY2FuX2JhY2tzbGFzaF9jaGFyIiwiYzAiLCJnZXRfZGlnaXQiLCJnZXRfZGlnaXQkMCIsImMxJDAiLCJjMiQwIiwic2Nhbl9jYW1sX2NoYXIiLCJmaW5kX3N0b3AiLCJzY2FuX2NhbWxfc3RyaW5nIiwiZmluZF9zdG9wJDAiLCJza2lwX3NwYWNlcyIsInNjYW5fY2hhcnNfaW5fY2hhcl9zZXQiLCJzY2FuX2luZGljIiwic2Nhbl9jaGFycyIsInNjYW5mX2JhZF9pbnB1dCIsImdldF9jb3VudGVyIiwid2lkdGhfb2ZfcGFkX29wdCIsInN0b3BwZXJfb2ZfZm9ybWF0dGluZ19saXQiLCJmbXRpbmciLCJ0YWtlX2Zvcm1hdF9yZWFkZXJzJDAiLCJ0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzJDAiLCJyZWFkZXIiLCJuZXdfayIsInJlYWRlcnNfcmVzdCIsInRha2VfZm9ybWF0X3JlYWRlcnMiLCJmbXQkMjMiLCJmbXQkMjQiLCJmbXQkMjUiLCJ0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIiwicGFkX3ByZWNfc2NhbmYiLCJyZWFkZXJzIiwic2NhbiIsIm1ha2Vfc2NhbmYiLCJzY2FuJDAiLCJzdHJfcmVzdCIsInNjYW4kMSIsInNjYW4kMiIsInNjYW4kMyIsInNjYW4kNCIsImNvbnYkMCIsInNjYW4kNSIsImNvbnYkMSIsInNjYW4kNiIsImNvbnYkMiIsInNjYW4kNyIsInByZWMkNSIsInNjYW4kOCIsImZtdGluZ19saXQkMCIsInN0cCQwIiwicyQyIiwic3RyX3Jlc3QkMCIsImFyZ19yZXN0Iiwia3NjYW5mIiwiZWYiLCJhcHBseSIsImFyZ3MkMCIsImV4YyIsImJzY2FuZiIsImtzc2NhbmYiLCJzc2NhbmYiLCJzY2FuZiIsImJzY2FuZl9mb3JtYXQiLCJmb3JtYXQiLCJzc2NhbmZfZm9ybWF0IiwiZm9ybWF0X2Zyb21fc3RyaW5nIiwidW5lc2NhcGVkIiwia2ZzY2FuZiIsImZzY2FuZiIsInJlZ2lzdGVyIiwicmVnaXN0ZXJfZXhjZXB0aW9uIiwibyQwIiwicGFyYW1zJDAiLCJpbml0aWFsX29iamVjdF9zaXplIiwiZHVtbXlfaXRlbSIsInRhZyIsImNvbXBhcmUkNiIsImNvbXBhcmUkNyIsImNvbXBhcmUkOCIsImR1bW15X3RhYmxlIiwidGFibGVfY291bnQiLCJkdW1teV9tZXQiLCJmaXRfc2l6ZSIsIm5ld190YWJsZSIsInB1Yl9sYWJlbHMiLCJtZXRob2RzIiwicmVzaXplJDEiLCJuZXdfc2l6ZSIsIm9sZF9zaXplIiwibmV3X2J1Y2siLCJtZXRob2RfY291bnQiLCJpbnN0X3Zhcl9jb3VudCIsIm5ld19tZXRob2QiLCJ0YWJsZSIsImdldF9tZXRob2RfbGFiZWwiLCJsYWJlbCIsImdldF9tZXRob2RfbGFiZWxzIiwibmFtZXMiLCJzZXRfbWV0aG9kIiwiZWxlbWVudCIsImdldF9tZXRob2QiLCJ0b19saXN0JDAiLCJuYXJyb3ciLCJ2YXJzIiwidmlydF9tZXRocyIsImNvbmNyX21ldGhzIiwidmFycyQwIiwidmlydF9tZXRocyQwIiwiY29uY3JfbWV0aHMkMCIsInZpcnRfbWV0aF9sYWJzIiwiY29uY3JfbWV0aF9sYWJzIiwibGFiIiwidHZhcnMiLCJieV9uYW1lIiwiYnlfbGFiZWwiLCJtZXQiLCJobSIsIndpZGVuIiwic2F2ZWRfdmFycyIsInNhdmVkX2hpZGRlbl9tZXRocyIsIm5ld19zbG90IiwibmV3X3ZhcmlhYmxlIiwidG9fYXJyYXkiLCJuZXdfbWV0aG9kc192YXJpYWJsZXMiLCJtZXRocyIsInZhbHMiLCJtZXRocyQwIiwibm1ldGhzIiwibnZhbHMiLCJnZXRfdmFyaWFibGUiLCJnZXRfdmFyaWFibGVzIiwiYWRkX2luaXRpYWxpemVyIiwiY3JlYXRlX3RhYmxlIiwicHVibGljX21ldGhvZHMiLCJpbml0X2NsYXNzIiwiaW5oZXJpdHMiLCJjbGEiLCJzdXBlciQwIiwibm0iLCJtYWtlX2NsYXNzIiwicHViX21ldGhzIiwiY2xhc3NfaW5pdCIsImVudl9pbml0IiwibWFrZV9jbGFzc19zdG9yZSIsImluaXRfdGFibGUiLCJkdW1teV9jbGFzcyIsImxvYyIsInVuZGVmIiwiY3JlYXRlX29iamVjdCIsImNyZWF0ZV9vYmplY3Rfb3B0Iiwib2JqXzAiLCJpdGVyX2YiLCJydW5faW5pdGlhbGl6ZXJzIiwiaW5pdHMiLCJydW5faW5pdGlhbGl6ZXJzX29wdCIsImNyZWF0ZV9vYmplY3RfYW5kX3J1bl9pbml0aWFsaXplcnMiLCJnZXRfZGF0YSQwIiwiYnVpbGRfcGF0aCIsImtleXMiLCJsb29rdXBfdGFibGVzIiwicm9vdCIsInRhYmxlcyQyIiwidGFibGVzJDAiLCJ0YWJsZXMkMSIsIm5ld19jYWNoZSIsInNldF9tZXRob2RzIiwiY2xvIiwiY2xvJDAiLCJuJDIiLCJuJDMiLCJuJDQiLCJuJDUiLCJuJDYiLCJ4JDMiLCJuJDciLCJ4JDQiLCJuJDgiLCJmJDciLCJuJDkiLCJ4JDUiLCJmJDgiLCJlJDIiLCJuJDEwIiwieCQ2IiwiZiQ5IiwibiQxMSIsIngkNyIsIm4kMTIiLCJ4JDgiLCJuJDEzIiwibiQxNCIsImUkMyIsIm4kMTUiLCJtJDIiLCJ4JDkiLCJtJDMiLCJuJDE2IiwibSQ0IiwiZSQ0IiwibiQxNyIsIm0kNSIsIm4kMTgiLCJzdGF0cyQwIiwiaW5pdGlhbF9idWZmZXIiLCJidWZmZXIiLCJidWZwb3MiLCJyZXNldF9idWZmZXIiLCJzdG9yZSIsIm5ld2J1ZmZlciIsImdldF9zdHJpbmciLCJtYWtlX2xleGVyIiwia2V5d29yZHMiLCJrd2RfdGFibGUiLCJpZGVudF9vcl9rZXl3b3JkIiwiaWQiLCJrZXl3b3JkX29yX2Vycm9yIiwiZW5kX2V4cG9uZW50X3BhcnQiLCJleHBvbmVudF9wYXJ0IiwibnVtYmVyIiwiaWRlbnQyIiwibmVnX251bWJlciIsIm5leHRfdG9rZW4kMCIsImVzY2FwZSIsIm1heWJlX2NvbW1lbnQiLCJjb21tZW50IiwibmV4dF90b2tlbiIsImhrZXkiLCJjbGVhbiIsImluc2VydF9idWNrZXQiLCJjb250YWluZXIiLCJyZW1vdmVfYnVja2V0IiwiaGsiLCJyZXBsYWNlX2J1Y2tldCIsIm5ld19kIiwiYnVja2V0X2xlbmd0aF9hbGl2ZSIsInN0YXRzX2FsaXZlIiwiY3JlYXRlJDQiLCJnZXRfa2V5IiwiZ2V0X2tleV9jb3B5Iiwic2V0X2tleSIsInVuc2V0X2tleSIsImNoZWNrX2tleSIsImJsaXRfa2V5IiwiZ2V0X2RhdGEkMSIsImdldF9kYXRhX2NvcHkiLCJzZXRfZGF0YSIsInVuc2V0X2RhdGEiLCJjaGVja19kYXRhIiwiYmxpdF9kYXRhIiwic2V0X2tleV9kYXRhIiwiY3JlYXRlJDUiLCJnZXRfa2V5MSIsImdldF9rZXkxX2NvcHkiLCJzZXRfa2V5MSIsInVuc2V0X2tleTEiLCJjaGVja19rZXkxIiwiZ2V0X2tleTIiLCJnZXRfa2V5Ml9jb3B5Iiwic2V0X2tleTIiLCJ1bnNldF9rZXkyIiwiY2hlY2tfa2V5MiIsImJsaXRfa2V5MSIsImJsaXRfa2V5MiIsImJsaXRfa2V5MTIiLCJnZXRfZGF0YSQyIiwiZ2V0X2RhdGFfY29weSQwIiwic2V0X2RhdGEkMCIsInVuc2V0X2RhdGEkMCIsImNoZWNrX2RhdGEkMCIsImJsaXRfZGF0YSQwIiwiazIkMCIsImsxJDAiLCJjcmVhdGUkNiIsImxlbmd0aCQ2IiwiZ2V0X2tleSQwIiwiZ2V0X2tleV9jb3B5JDAiLCJzZXRfa2V5JDAiLCJ1bnNldF9rZXkkMCIsImNoZWNrX2tleSQwIiwiYmxpdF9rZXkkMCIsIm8xIiwibzIiLCJnZXRfZGF0YSQzIiwiZ2V0X2RhdGFfY29weSQxIiwic2V0X2RhdGEkMSIsInVuc2V0X2RhdGEkMSIsImNoZWNrX2RhdGEkMSIsImJsaXRfZGF0YSQxIiwia2kiLCJrMCIsImdlbmVyaWNfYmFzZW5hbWUiLCJpc19kaXJfc2VwIiwiZ2VuZXJpY19kaXJuYW1lIiwiaXNfcmVsYXRpdmUiLCJpc19pbXBsaWNpdCIsImNoZWNrX3N1ZmZpeCIsInN1ZmYiLCJxdW90ZSIsImJhc2VuYW1lIiwiZGlybmFtZSIsImlzX2Rpcl9zZXAkMCIsImlzX3JlbGF0aXZlJDAiLCJpc19pbXBsaWNpdCQwIiwiY2hlY2tfc3VmZml4JDAiLCJ0ZW1wX2Rpcl9uYW1lIiwicXVvdGUkMCIsImFkZF9icyIsImxvb3AkMCIsImxvb3BfYnMiLCJkcml2ZV9hbmRfcGF0aCIsImRpcm5hbWUkMCIsInBhdGgiLCJkcml2ZSIsImRpciIsImJhc2VuYW1lJDAiLCJiYXNlbmFtZSQxIiwiZGlybmFtZSQxIiwiY3VycmVudF9kaXJfbmFtZSQyIiwicGFyZW50X2Rpcl9uYW1lJDIiLCJkaXJfc2VwJDIiLCJpc19kaXJfc2VwJDEiLCJpc19yZWxhdGl2ZSQxIiwiaXNfaW1wbGljaXQkMSIsImNoZWNrX3N1ZmZpeCQxIiwidGVtcF9kaXJfbmFtZSQwIiwicXVvdGUkMSIsImJhc2VuYW1lJDIiLCJkaXJuYW1lJDIiLCJjb25jYXQkMiIsImNob3Bfc3VmZml4IiwiZXh0ZW5zaW9uX2xlbiIsImV4dGVuc2lvbiIsImNob3BfZXh0ZW5zaW9uIiwicmVtb3ZlX2V4dGVuc2lvbiIsInBybmckMCIsInRlbXBfZmlsZV9uYW1lIiwidGVtcF9kaXIiLCJybmQiLCJjdXJyZW50X3RlbXBfZGlyX25hbWUiLCJzZXRfdGVtcF9kaXJfbmFtZSIsImdldF90ZW1wX2Rpcl9uYW1lIiwidGVtcF9maWxlIiwidHJ5X25hbWUiLCJjb3VudGVyJDEiLCJvcGVuX3RlbXBfZmlsZSIsInN0aCQwIiwicGVybXMiLCJzdGgkMSIsImFkZCQxIiwic3ViJDMiLCJuZWciLCJjb25qIiwibXVsIiwiZGl2IiwiaW52Iiwibm9ybTIiLCJub3JtIiwicSQwIiwicG9sYXIiLCJzcXJ0IiwidyQwIiwiZXhwIiwibG9nIiwicG93IiwiZW5hYmxlZCIsImlmX3NwYWNldGltZV9lbmFibGVkIiwiY3JlYXRlJDciLCJjaGFubmVsIiwic2F2ZV9ldmVudCIsInRpbWUiLCJldmVudF9uYW1lIiwic2F2ZV9hbmRfY2xvc2UiLCJ0YWtlJDAiLCJjbG9zZWQiLCJzYXZlX2V2ZW50X2Zvcl9hdXRvbWF0aWNfc25hcHNob3RzIiwibm9yYW5nZSIsImxpbmVfb2ZfcG9zIiwibCIsImNvbF9vZl9wb3MiLCJjIiwibWtfcG9zIiwibGluZSIsImNvbCIsImZpbGVfb2ZfcmFuZ2UiLCJmIiwic3RhcnRfb2ZfcmFuZ2UiLCJzIiwiZW5kX29mX3JhbmdlIiwiZSIsIm1rX3JhbmdlIiwidmFsaWRfcG9zIiwibWVyZ2VfcmFuZ2UiLCJyMSIsInIyIiwiZTIiLCJzMiIsImUxIiwiczEiLCJmJDAiLCJzdHJpbmdfb2ZfcmFuZ2UiLCJlYyIsImVsIiwic2MiLCJzbCIsIm1sX3N0cmluZ19vZl9yYW5nZSIsInBvc19vZl9sZXhwb3MiLCJwIiwibWtfbGV4X3JhbmdlIiwicDEiLCJwMiIsImxleF9yYW5nZSIsImxleGJ1ZiIsIm5vX2xvYyIsIngiLCJkZWZhdWx0X3JlZHVjdGlvbiIsImVycm9yIiwiYWN0aW9uIiwibGhzIiwiZ290byQwIiwiRXJyb3IiLCJsb2MiLCJzdGFydHBvcyIsImVuZHBvcyIsImVsdCIsInRva2VuMnRlcm1pbmFsIiwidG9rIiwiZXJyb3JfdGVybWluYWwiLCJ0b2tlbjJ2YWx1ZSIsInYiLCJ2JDAiLCJ2JDEiLCJzdGFydCIsIm1lbmhpcl9lbnYiLCJtZW5oaXJfc3RhY2siLCJtZW5oaXJfc3RhY2skMCIsImVuZHBvc194cyIsInN0YXJ0cG9zX3hzIiwieHMiLCJtZW5oaXJfcyIsInN0YXJ0cG9zXzEiLCJpZCIsImVuZHBvc19pbml0IiwiaW5pdCIsInN0YXJ0cG9zX3QiLCJ0IiwiZW5kcG9zXzMiLCJyIiwiZW5kcG9zXzEiLCJzdGFydHBvc19zIiwicyIsImVuZHBvc18yIiwiZW5kcG9zX3MiLCJkcyIsImUiLCJlbmRwb3NfYiIsImIiLCJlbmRwb3NfaWZzIiwic3RhcnRwb3NfaWZzIiwiaWZzIiwic3RhcnRwb3NfZSIsImVuZHBvc181Iiwic3RhcnRwb3NfcCIsInAiLCJlbmRwb3NfNCIsInN0YXJ0cG9zX2QiLCJkIiwic3RhcnRwb3NfeCIsIngiLCJlbmRwb3NfeCIsInkiLCJ4JDAiLCJlbmRwb3NfeSIsImkiLCJlbmRwb3NfaWQiLCJzdGFydHBvc19pZCIsImIxIiwiZW5kcG9zX2IyIiwiYjIiLCJlbmRwb3NfNyIsInQkMCIsImVuZHBvc19pIiwic3RhcnRwb3NfaSIsImVuZHBvc19lIiwic3RhcnRwb3NfZTEiLCJlMSIsImVuZHBvc19lMiIsImUyIiwiZm5hbWUiLCJhcmdzIiwiZW5kcG9zX2JvZHkiLCJib2R5IiwiZnJ0eXAiLCJuYW1lIiwic3RtdHMiLCJzZW1hbnRpY19hY3Rpb24iLCJzdG10X3RvcCIsImxleGVyIiwibGV4YnVmIiwicHJvZyIsImV4cF90b3AiLCJzdG10X3RvcCQwIiwiaW5pdGlhbF9wb3NpdGlvbiIsInByb2ckMCIsImV4cF90b3AkMCIsInJlc2VydmVkX3dvcmRzIiwib2NhbWxfbGV4X3RhYmxlcyIsInJlc2V0X2xleGJ1ZiIsImZpbGVuYW1lIiwibG51bSIsImxleGJ1ZiIsIm5ld2xpbmUiLCJ1bmV4cGVjdGVkX2NoYXIiLCJjIiwic3ltYm9sX3RhYmxlIiwidCIsInN0ciIsImNyZWF0ZV90b2tlbiIsInN0cmluZ19idWZmZXIiLCJzdHJpbmdfZW5kIiwic3RhcnRfbGV4Iiwic3RhcnRfcG9zX29mX2xleGJ1ZiIsImxleF9sb25nX3JhbmdlIiwiZW5kX3AiLCJyZXNldF9zdHIiLCJhZGRfc3RyIiwiY2giLCJ4IiwiYnVmZmVyIiwibmV3X2J1ZmZlciIsImdldF9zdHIiLCJ0b2tlbiQwIiwib2NhbWxfbGV4X3Rva2VuX3JlYyQwIiwib2NhbWxfbGV4X3N0YXRlIiwib2NhbWxfbGV4X3N0YXRlJDAiLCJvY2FtbF9sZXhfc3RhdGUkMSIsImNvbW1lbnRzJDAiLCJzdHJpbmckMCIsInAiLCJkaXJlY3RpdmUkMCIsInN0YXRlIiwib2NhbWxfbGV4X2RpcmVjdGl2ZV9yZWMkMCIsImxldmVsIiwib2NhbWxfbGV4X2NvbW1lbnRzX3JlYyQwIiwiaW5fZGlyZWN0aXZlIiwib2NhbWxfbGV4X3N0cmluZ19yZWMkMCIsImVzY2FwZWQiLCJ0b2tlbiIsIm9jYW1sX2xleF90b2tlbl9yZWMiLCJkaXJlY3RpdmUiLCJvY2FtbF9sZXhfZGlyZWN0aXZlX3JlYyIsImNvbW1lbnRzIiwib2NhbWxfbGV4X2NvbW1lbnRzX3JlYyIsInN0cmluZyIsIm9jYW1sX2xleF9zdHJpbmdfcmVjIiwib2NhbWxfbGV4X2VzY2FwZWRfcmVjIiwic3VjY2VlZCIsInJlY292ZXJfZnJvbV9lcnJvciIsInN1cHBsaWVyIiwiZGVwdGgiLCJkZXB0aCQwIiwiZGVwdGgkMSIsInN0b3AiLCJzdGFydCIsInN0b3AkMCIsInN0YXJ0JDAiLCJmYWlsIiwibGV4YnVmIiwiYmFja2VkX3VwIiwiYiIsImEiLCJmaW5kX2Vycm9ycyIsImNvbnRlbnRzIiwicmVzdWx0IiwiZmlsdGVyX21hcCIsImwiLCJsJDAiLCJ0bCIsIngiLCJsJDEiLCJwcmludF9lcnJvciIsImxvYyIsImpzX29mX3JhbmdlIiwianNfb2ZfcG9zIiwicG9zIiwiY2hhciQwIiwibGluZSIsImZpbmlzaCIsIm1haW4iLCJmaWxlcyJdLCJtYXBwaW5ncyI6Ijs7OztJQW9GQSxTQUFTQSxtQkFBbUJDLEdBQzFCLFFBQVFBLE9BQUtBLE9BQUtBLFVBQ3BCO0lDckNBLFNBQVNDLGdCQUFnQkMsRUFBR0M7TUFDMUIsR0FBR0QsT0FBUTtNQUNYLEdBQUlDLFNBQVUsT0FBUSxTQUFTRDtNQUMvQixJQUFNLEtBQVE7TUFDZCxHQUFJQSxPQUFRLE9BQU9FO01BQ25CO09BQVEsQ0FDTixHQUFJRixNQUFPRSxLQUFLRDtRQUNoQkQ7UUFDQSxHQUFJQSxPQUFRLE9BQU9FO1FBQ25CRCxLQUFLQTtRQUNMRTtRQUNBLEdBQUlBLE9BQVEsYUFNaEI7SUQ4S0EsU0FB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Ozs7Ozs7Ozs7Ozs7O1U7Ozs7Ozs7SVE3QjFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQ2tCS3c3QjtLQUNBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tDNEdBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQ3BGQUM7S0FDQUM7S0FDQUM7S0FJQUM7S0FDQUM7Ozs7S0N6QkFDO0tBb0hBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0N5N0VNQztLQVFRQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tDMWpGZEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tDcURFQztLQUNBQztLQUNBQzs7O0tBM0RZQztLQThFWkM7S0FDQUM7S0FDQUM7OztLQStEQUM7S0FDQUM7S0FDQUM7OztLQzdJRkM7S0FDQUM7S0FDQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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ci8ub3BhbS80LjA2LjAvbGliL2pzX29mX29jYW1sLWNvbXBpbGVyL2ludDY0LmpzIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9qc19vZl9vY2FtbC1jb21waWxlci9tbFN0cmluZy5qcyIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvanNfb2Zfb2NhbWwtY29tcGlsZXIvc3RkbGliLmpzIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9qc19vZl9vY2FtbC1jb21waWxlci9pZWVlXzc1NC5qcyIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvanNfb2Zfb2NhbWwtY29tcGlsZXIvZnMuanMiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL2pzX29mX29jYW1sLWNvbXBpbGVyL2ZzX2Zha2UuanMiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL2pzX29mX29jYW1sLWNvbXBpbGVyL2ZzX25vZGUuanMiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL2pzX29mX29jYW1sLWNvbXBpbGVyL25hdC5qcyIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvanNfb2Zfb2NhbWwtY29tcGlsZXIvbWFyc2hhbC5qcyIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvanNfb2Zfb2NhbWwtY29tcGlsZXIvaW8uanMiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL2pzX29mX29jYW1sLWNvbXBpbGVyL2djLmpzIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9qc19vZl9vY2FtbC1jb21waWxlci9iaWdhcnJheS5qcyIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvanNfb2Zfb2NhbWwtY29tcGlsZXIvcGFyc2luZy5qcyIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvanNfb2Zfb2NhbWwtY29tcGlsZXIvdW5peC5qcyIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvanNfb2Zfb2NhbWwtY29tcGlsZXIvanNsaWJfanNfb2Zfb2NhbWwuanMiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL2pzX29mX29jYW1sLWNvbXBpbGVyL2pzbGliLmpzIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9qc19vZl9vY2FtbC1jb21waWxlci9pbnRlcm5hbE1vZC5qcyIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvanNfb2Zfb2NhbWwtY29tcGlsZXIvYmlnc3RyaW5nLmpzIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9qc19vZl9vY2FtbC1jb21waWxlci9sZXhpbmcuanMiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL2pzX29mX29jYW1sLWNvbXBpbGVyL3dlYWsuanMiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL2pzX29mX29jYW1sLWNvbXBpbGVyL21kNS5qcyIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvanNfb2Zfb2NhbWwtY29tcGlsZXIvYmlnc3RyaW5nLWNzdHJ1Y3QuanMiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL2pzX29mX29jYW1sLWNvbXBpbGVyL3BvbHlmaWxsL2pzb24yLmpzIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9vY2FtbC91Y2hhci5tbCIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvb2NhbWwvc3lzLm1sIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9vY2FtbC9pbnQ2NC5tbCIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvb2NhbWwvbGV4aW5nLm1sIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9vY2FtbC9jYW1saW50ZXJuYWxGb3JtYXQubWwiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL29jYW1sL3ByaW50ZXhjLm1sIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9vY2FtbC9maWxlbmFtZS5tbCIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvb2NhbWwvY29tcGxleC5tbCIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvb2NhbWwvY2FtbGludGVybmFsRm9ybWF0QmFzaWNzLm1sIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9vY2FtbC9wZXJ2YXNpdmVzLm1sIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9vY2FtbC9saXN0Lm1sIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9vY2FtbC9jaGFyLm1sIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9vY2FtbC9ieXRlcy5tbCIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvb2NhbWwvc3RyaW5nLm1sIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9vY2FtbC9uYXRpdmVpbnQubWwiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL29jYW1sL3NvcnQubWwiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL29jYW1sL21hcnNoYWwubWwiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL29jYW1sL29iai5tbCIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvb2NhbWwvYXJyYXkubWwiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL29jYW1sL2ludDMyLm1sIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9vY2FtbC9wYXJzaW5nLm1sIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9vY2FtbC9zZXQubWwiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL29jYW1sL21hcC5tbCIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvb2NhbWwvc3RhY2subWwiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL29jYW1sL3F1ZXVlLm1sIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9vY2FtbC9jYW1saW50ZXJuYWxMYXp5Lm1sIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9vY2FtbC9sYXp5Lm1sIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9vY2FtbC9zdHJlYW0ubWwiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL29jYW1sL2J1ZmZlci5tbCIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvb2NhbWwvcHJpbnRmLm1sIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9vY2FtbC9hcmcubWwiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL29jYW1sL2djLm1sIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9vY2FtbC9kaWdlc3QubWwiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL29jYW1sL3JhbmRvbS5tbCIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvb2NhbWwvaGFzaHRibC5tbCIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvb2NhbWwvd2Vhay5tbCIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvb2NhbWwvZm9ybWF0Lm1sIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9vY2FtbC9zY2FuZi5tbCIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvb2NhbWwvY2FsbGJhY2subWwiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL29jYW1sL2NhbWxpbnRlcm5hbE9PLm1sIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9vY2FtbC9nZW5sZXgubWwiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL29jYW1sL2VwaGVtZXJvbi5tbCIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvb2NhbWwvc3BhY2V0aW1lLm1sIiwiL2hvbWUvdGlnYXIvQ09TXzMyMC9fYnVpbGQvZGVmYXVsdC9odzAzL3V0aWwvcmFuZ2UubWwiLCIvaG9tZS90aWdhci9DT1NfMzIwL19idWlsZC9kZWZhdWx0L2h3MDMvYXN0Lm1sIiwiL2hvbWUvdGlnYXIvQ09TXzMyMC9fYnVpbGQvZGVmYXVsdC9odzAzL3BhcnNlci5tbCIsIi9ob21lL3RpZ2FyL0NPU18zMjAvX2J1aWxkL2RlZmF1bHQvaHcwMy9wYXJzZXIubWx5IiwiL2hvbWUvdGlnYXIvQ09TXzMyMC9fYnVpbGQvZGVmYXVsdC9odzAzL2xleGVyLm1sbCIsIi9ob21lL3RpZ2FyL0NPU18zMjAvX2J1aWxkL2RlZmF1bHQvaHcwMy9sZXhlci5tbCIsIi9ob21lL3RpZ2FyL0NPU18zMjAvX2J1aWxkL2RlZmF1bHQvaHcwMy9zZXJ2ZXIubWwiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2Zmc2V0XG52YXIgY2FtbF9pbnQ2NF9vZmZzZXQgPSBNYXRoLnBvdygyLCAtMjQpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3Vjb21wYXJlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3Vjb21wYXJlKHgseSkge1xuICBpZiAoeFszXSA+IHlbM10pIHJldHVybiAxO1xuICBpZiAoeFszXSA8IHlbM10pIHJldHVybiAtMTtcbiAgaWYgKHhbMl0gPiB5WzJdKSByZXR1cm4gMTtcbiAgaWYgKHhbMl0gPCB5WzJdKSByZXR1cm4gLTE7XG4gIGlmICh4WzFdID4geVsxXSkgcmV0dXJuIDE7XG4gIGlmICh4WzFdIDwgeVsxXSkgcmV0dXJuIC0xO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF91bHQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdWNvbXBhcmVcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdWx0KHgseSkgeyByZXR1cm4gY2FtbF9pbnQ2NF91Y29tcGFyZSh4LHkpIDwgMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2NvbXBhcmUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfY29tcGFyZSh4LHkpIHtcbiAgdmFyIHgzID0geFszXSA8PCAxNjtcbiAgdmFyIHkzID0geVszXSA8PCAxNjtcbiAgaWYgKHgzID4geTMpIHJldHVybiAxO1xuICBpZiAoeDMgPCB5MykgcmV0dXJuIC0xO1xuICBpZiAoeFsyXSA+IHlbMl0pIHJldHVybiAxO1xuICBpZiAoeFsyXSA8IHlbMl0pIHJldHVybiAtMTtcbiAgaWYgKHhbMV0gPiB5WzFdKSByZXR1cm4gMTtcbiAgaWYgKHhbMV0gPCB5WzFdKSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X25lZyBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9uZWcgKHgpIHtcbiAgdmFyIHkxID0gLSB4WzFdO1xuICB2YXIgeTIgPSAtIHhbMl0gKyAoeTEgPj4gMjQpO1xuICB2YXIgeTMgPSAtIHhbM10gKyAoeTIgPj4gMjQpO1xuICByZXR1cm4gWzI1NSwgeTEgJiAweGZmZmZmZiwgeTIgJiAweGZmZmZmZiwgeTMgJiAweGZmZmZdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2FkZCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9hZGQgKHgsIHkpIHtcbiAgdmFyIHoxID0geFsxXSArIHlbMV07XG4gIHZhciB6MiA9IHhbMl0gKyB5WzJdICsgKHoxID4+IDI0KTtcbiAgdmFyIHozID0geFszXSArIHlbM10gKyAoejIgPj4gMjQpO1xuICByZXR1cm4gWzI1NSwgejEgJiAweGZmZmZmZiwgejIgJiAweGZmZmZmZiwgejMgJiAweGZmZmZdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3N1YiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9zdWIgKHgsIHkpIHtcbiAgdmFyIHoxID0geFsxXSAtIHlbMV07XG4gIHZhciB6MiA9IHhbMl0gLSB5WzJdICsgKHoxID4+IDI0KTtcbiAgdmFyIHozID0geFszXSAtIHlbM10gKyAoejIgPj4gMjQpO1xuICByZXR1cm4gWzI1NSwgejEgJiAweGZmZmZmZiwgejIgJiAweGZmZmZmZiwgejMgJiAweGZmZmZdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X211bCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbXVsKHgseSkge1xuICB2YXIgejEgPSB4WzFdICogeVsxXTtcbiAgdmFyIHoyID0gKCh6MSAqIGNhbWxfaW50NjRfb2Zmc2V0KSB8IDApICsgeFsyXSAqIHlbMV0gKyB4WzFdICogeVsyXTtcbiAgdmFyIHozID0gKCh6MiAqIGNhbWxfaW50NjRfb2Zmc2V0KSB8IDApICsgeFszXSAqIHlbMV0gKyB4WzJdICogeVsyXSArIHhbMV0gKiB5WzNdO1xuICByZXR1cm4gWzI1NSwgejEgJiAweGZmZmZmZiwgejIgJiAweGZmZmZmZiwgejMgJiAweGZmZmZdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2lzX3plcm8gY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfaXNfemVybyh4KSB7XG4gIHJldHVybiAoeFszXXx4WzJdfHhbMV0pID09IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaXNfbmVnYXRpdmUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfaXNfbmVnYXRpdmUoeCkge1xuICByZXR1cm4gKHhbM10gPDwgMTYpIDwgMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9pc19taW5faW50IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2lzX21pbl9pbnQoeCkge1xuICByZXR1cm4geFszXSA9PSAweDgwMDAgJiYgKHhbMV18eFsyXSkgPT0gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9pc19taW51c19vbmUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfaXNfbWludXNfb25lKHgpIHtcbiAgcmV0dXJuIHhbM10gPT0gMHhmZmZmICYmICh4WzFdJnhbMl0pID09IDB4ZmZmZmZmO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2FuZCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9hbmQgKHgsIHkpIHtcbiAgcmV0dXJuIFsyNTUsIHhbMV0meVsxXSwgeFsyXSZ5WzJdLCB4WzNdJnlbM11dO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29yIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29yICh4LCB5KSB7XG4gIHJldHVybiBbMjU1LCB4WzFdfHlbMV0sIHhbMl18eVsyXSwgeFszXXx5WzNdXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF94b3IgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfeG9yICh4LCB5KSB7XG4gIHJldHVybiBbMjU1LCB4WzFdXnlbMV0sIHhbMl1eeVsyXSwgeFszXV55WzNdXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9zaGlmdF9sZWZ0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3NoaWZ0X2xlZnQgKHgsIHMpIHtcbiAgcyA9IHMgJiA2MztcbiAgaWYgKHMgPT0gMCkgcmV0dXJuIHg7XG4gIGlmIChzIDwgMjQpXG4gICAgcmV0dXJuIFsyNTUsXG4gICAgICAgICAgICAoeFsxXSA8PCBzKSAmIDB4ZmZmZmZmLFxuICAgICAgICAgICAgKCh4WzJdIDw8IHMpIHwgKHhbMV0gPj4gKDI0IC0gcykpKSAmIDB4ZmZmZmZmLFxuICAgICAgICAgICAgKCh4WzNdIDw8IHMpIHwgKHhbMl0gPj4gKDI0IC0gcykpKSAmIDB4ZmZmZl07XG4gIGlmIChzIDwgNDgpXG4gICAgcmV0dXJuIFsyNTUsIDAsXG4gICAgICAgICAgICAoeFsxXSA8PCAocyAtIDI0KSkgJiAweGZmZmZmZixcbiAgICAgICAgICAgICgoeFsyXSA8PCAocyAtIDI0KSkgfCAoeFsxXSA+PiAoNDggLSBzKSkpICYgMHhmZmZmXTtcbiAgcmV0dXJuIFsyNTUsIDAsIDAsICh4WzFdIDw8IChzIC0gNDgpKSAmIDB4ZmZmZl07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQgKHgsIHMpIHtcbiAgcyA9IHMgJiA2MztcbiAgaWYgKHMgPT0gMCkgcmV0dXJuIHg7XG4gIGlmIChzIDwgMjQpXG4gICAgcmV0dXJuIFsyNTUsXG4gICAgICAgICAgICAoKHhbMV0gPj4gcykgfCAoeFsyXSA8PCAoMjQgLSBzKSkpICYgMHhmZmZmZmYsXG4gICAgICAgICAgICAoKHhbMl0gPj4gcykgfCAoeFszXSA8PCAoMjQgLSBzKSkpICYgMHhmZmZmZmYsXG4gICAgICAgICAgICAoeFszXSA+PiBzKV07XG4gIGlmIChzIDwgNDgpXG4gICAgcmV0dXJuIFsyNTUsXG4gICAgICAgICAgICAoKHhbMl0gPj4gKHMgLSAyNCkpIHwgKHhbM10gPDwgKDQ4IC0gcykpKSAmIDB4ZmZmZmZmLFxuICAgICAgICAgICAgKHhbM10gPj4gKHMgLSAyNCkpLFxuICAgICAgICAgICAgMF07XG4gIHJldHVybiBbMjU1LCAoeFszXSA+PiAocyAtIDQ4KSksIDAsIDBdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0ICh4LCBzKSB7XG4gIHMgPSBzICYgNjM7XG4gIGlmIChzID09IDApIHJldHVybiB4O1xuICB2YXIgaCA9ICh4WzNdIDw8IDE2KSA+PiAxNjtcbiAgaWYgKHMgPCAyNClcbiAgICByZXR1cm4gWzI1NSxcbiAgICAgICAgICAgICgoeFsxXSA+PiBzKSB8ICh4WzJdIDw8ICgyNCAtIHMpKSkgJiAweGZmZmZmZixcbiAgICAgICAgICAgICgoeFsyXSA+PiBzKSB8IChoIDw8ICgyNCAtIHMpKSkgJiAweGZmZmZmZixcbiAgICAgICAgICAgICgoeFszXSA8PCAxNikgPj4gcykgPj4+IDE2XTtcbiAgdmFyIHNpZ24gPSAoeFszXSA8PCAxNikgPj4gMzE7XG4gIGlmIChzIDwgNDgpXG4gICAgcmV0dXJuIFsyNTUsXG4gICAgICAgICAgICAoKHhbMl0gPj4gKHMgLSAyNCkpIHwgKHhbM10gPDwgKDQ4IC0gcykpKSAmIDB4ZmZmZmZmLFxuICAgICAgICAgICAgKCh4WzNdIDw8IDE2KSA+PiAocyAtIDI0KSA+PiAxNikgJiAweGZmZmZmZixcbiAgICAgICAgICAgIHNpZ24gJiAweGZmZmZdO1xuICByZXR1cm4gWzI1NSxcbiAgICAgICAgICAoKHhbM10gPDwgMTYpID4+IChzIC0gMzIpKSAmIDB4ZmZmZmZmLFxuICAgICAgICAgIHNpZ24gJiAweGZmZmZmZiwgc2lnbiAmIDB4ZmZmZl07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbHNsMSBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9sc2wxICh4KSB7XG4gIHhbM10gPSAoeFszXSA8PCAxKSB8ICh4WzJdID4+IDIzKTtcbiAgeFsyXSA9ICgoeFsyXSA8PCAxKSB8ICh4WzFdID4+IDIzKSkgJiAweGZmZmZmZjtcbiAgeFsxXSA9ICh4WzFdIDw8IDEpICYgMHhmZmZmZmY7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbHNyMSBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9sc3IxICh4KSB7XG4gIHhbMV0gPSAoKHhbMV0gPj4+IDEpIHwgKHhbMl0gPDwgMjMpKSAmIDB4ZmZmZmZmO1xuICB4WzJdID0gKCh4WzJdID4+PiAxKSB8ICh4WzNdIDw8IDIzKSkgJiAweGZmZmZmZjtcbiAgeFszXSA9IHhbM10gPj4+IDE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdWRpdm1vZCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF91Y29tcGFyZSwgY2FtbF9pbnQ2NF9sc2wxLCBjYW1sX2ludDY0X2xzcjFcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfc3ViXG4vL1JlcXVpcmVzOiBjYW1sX29ial9kdXBcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdWRpdm1vZCAoeCwgeSkge1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgdmFyIG1vZHVsdXMgPSBjYW1sX29ial9kdXAoeCk7XG4gIHZhciBkaXZpc29yID0gY2FtbF9vYmpfZHVwKHkpO1xuICB2YXIgcXVvdGllbnQgPSBbMjU1LCAwLCAwLCAwXTtcbiAgd2hpbGUgKGNhbWxfaW50NjRfdWNvbXBhcmUgKG1vZHVsdXMsIGRpdmlzb3IpID4gMCkge1xuICAgIG9mZnNldCsrO1xuICAgIGNhbWxfaW50NjRfbHNsMSAoZGl2aXNvcik7XG4gIH1cbiAgd2hpbGUgKG9mZnNldCA+PSAwKSB7XG4gICAgb2Zmc2V0IC0tO1xuICAgIGNhbWxfaW50NjRfbHNsMSAocXVvdGllbnQpO1xuICAgIGlmIChjYW1sX2ludDY0X3Vjb21wYXJlIChtb2R1bHVzLCBkaXZpc29yKSA+PSAwKSB7XG4gICAgICBxdW90aWVudFsxXSArKztcbiAgICAgIG1vZHVsdXMgPSBjYW1sX2ludDY0X3N1YiAobW9kdWx1cywgZGl2aXNvcik7XG4gICAgfVxuICAgIGNhbWxfaW50NjRfbHNyMSAoZGl2aXNvcik7XG4gIH1cbiAgcmV0dXJuIFswLHF1b3RpZW50LCBtb2R1bHVzXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9kaXYgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfaXNfemVybywgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9uZWcsIGNhbWxfaW50NjRfdWRpdm1vZFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9kaXYgKHgsIHkpXG57XG4gIGlmIChjYW1sX2ludDY0X2lzX3plcm8gKHkpKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpO1xuICB2YXIgc2lnbiA9IHhbM10gXiB5WzNdO1xuICBpZiAoeFszXSAmIDB4ODAwMCkgeCA9IGNhbWxfaW50NjRfbmVnKHgpO1xuICBpZiAoeVszXSAmIDB4ODAwMCkgeSA9IGNhbWxfaW50NjRfbmVnKHkpO1xuICB2YXIgcSA9IGNhbWxfaW50NjRfdWRpdm1vZCh4LCB5KVsxXTtcbiAgaWYgKHNpZ24gJiAweDgwMDApIHEgPSBjYW1sX2ludDY0X25lZyhxKTtcbiAgcmV0dXJuIHE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbW9kIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2lzX3plcm8sIGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfbmVnLCBjYW1sX2ludDY0X3VkaXZtb2RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbW9kICh4LCB5KVxue1xuICBpZiAoY2FtbF9pbnQ2NF9pc196ZXJvICh5KSkgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSAoKTtcbiAgdmFyIHNpZ24gPSB4WzNdO1xuICBpZiAoeFszXSAmIDB4ODAwMCkgeCA9IGNhbWxfaW50NjRfbmVnKHgpO1xuICBpZiAoeVszXSAmIDB4ODAwMCkgeSA9IGNhbWxfaW50NjRfbmVnKHkpO1xuICB2YXIgciA9IGNhbWxfaW50NjRfdWRpdm1vZCh4LCB5KVsyXTtcbiAgaWYgKHNpZ24gJiAweDgwMDApIHIgPSBjYW1sX2ludDY0X25lZyhyKTtcbiAgcmV0dXJuIHI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2ZfaW50MzIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb2ZfaW50MzIgKHgpIHtcbiAgcmV0dXJuIFsyNTUsIHggJiAweGZmZmZmZiwgKHggPj4gMjQpICYgMHhmZmZmZmYsICh4ID4+IDMxKSAmIDB4ZmZmZl1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF90b19pbnQzMiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF90b19pbnQzMiAoeCkge1xuICByZXR1cm4geFsxXSB8ICh4WzJdIDw8IDI0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF90b19mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF90b19mbG9hdCAoeCkge1xuICByZXR1cm4gKCh4WzNdIDw8IDE2KSAqIE1hdGgucG93KDIsIDMyKSArIHhbMl0gKiBNYXRoLnBvdygyLCAyNCkpICsgeFsxXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb2ZfZmxvYXQgKHgpIHtcbiAgaWYgKHggPCAwKSB4ID0gTWF0aC5jZWlsKHgpO1xuICByZXR1cm4gWzI1NSxcbiAgICAgICAgICB4ICYgMHhmZmZmZmYsXG4gICAgICAgICAgTWF0aC5mbG9vcih4ICogY2FtbF9pbnQ2NF9vZmZzZXQpICYgMHhmZmZmZmYsXG4gICAgICAgICAgTWF0aC5mbG9vcih4ICogY2FtbF9pbnQ2NF9vZmZzZXQgKiBjYW1sX2ludDY0X29mZnNldCkgJiAweGZmZmZdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2Zvcm1hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9mb3JtYXQsIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmdcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfaXNfbmVnYXRpdmUsIGNhbWxfaW50NjRfbmVnXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2ludDMyLCBjYW1sX2ludDY0X3VkaXZtb2QsIGNhbWxfaW50NjRfdG9faW50MzJcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfaXNfemVybywgY2FtbF9zdHJfcmVwZWF0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2Zvcm1hdCAoZm10LCB4KSB7XG4gIHZhciBmID0gY2FtbF9wYXJzZV9mb3JtYXQoZm10KTtcbiAgaWYgKGYuc2lnbmVkY29udiAmJiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlKHgpKSB7XG4gICAgZi5zaWduID0gLTE7IHggPSBjYW1sX2ludDY0X25lZyh4KTtcbiAgfVxuICB2YXIgYnVmZmVyID0gXCJcIjtcbiAgdmFyIHdiYXNlID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihmLmJhc2UpO1xuICB2YXIgY3Z0YmwgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbiAgZG8ge1xuICAgIHZhciBwID0gY2FtbF9pbnQ2NF91ZGl2bW9kKHgsIHdiYXNlKTtcbiAgICB4ID0gcFsxXTtcbiAgICBidWZmZXIgPSBjdnRibC5jaGFyQXQoY2FtbF9pbnQ2NF90b19pbnQzMihwWzJdKSkgKyBidWZmZXI7XG4gIH0gd2hpbGUgKCEgY2FtbF9pbnQ2NF9pc196ZXJvKHgpKTtcbiAgaWYgKGYucHJlYyA+PSAwKSB7XG4gICAgZi5maWxsZXIgPSAnICc7XG4gICAgdmFyIG4gPSBmLnByZWMgLSBidWZmZXIubGVuZ3RoO1xuICAgIGlmIChuID4gMCkgYnVmZmVyID0gY2FtbF9zdHJfcmVwZWF0IChuLCAnMCcpICsgYnVmZmVyO1xuICB9XG4gIHJldHVybiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nKGYsIGJ1ZmZlcik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UsIGNhbWxfZmFpbHdpdGgsIGNhbWxfcGFyc2VfZGlnaXQsIE1sQnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfaW50MzIsIGNhbWxfaW50NjRfdWRpdm1vZCwgY2FtbF9pbnQ2NF91bHRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYWRkLCBjYW1sX2ludDY0X211bCwgY2FtbF9pbnQ2NF9uZWdcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCxjYW1sX3N0cmluZ191bnNhZmVfZ2V0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29mX3N0cmluZyhzKSB7XG4gIHZhciByID0gY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlIChzKTtcbiAgdmFyIGkgPSByWzBdLCBzaWduID0gclsxXSwgYmFzZSA9IHJbMl07XG4gIHZhciBiYXNlNjQgPSBjYW1sX2ludDY0X29mX2ludDMyKGJhc2UpO1xuICB2YXIgdGhyZXNob2xkID1cbiAgICAgIGNhbWxfaW50NjRfdWRpdm1vZChbMjU1LCAweGZmZmZmZiwgMHhmZmZmZmZmLCAweGZmZmZdLCBiYXNlNjQpWzFdO1xuICB2YXIgYyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSk7XG4gIHZhciBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgaWYgKGQgPCAwIHx8IGQgPj0gYmFzZSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIHZhciByZXMgPSBjYW1sX2ludDY0X29mX2ludDMyKGQpO1xuICBmb3IgKDs7KSB7XG4gICAgaSsrO1xuICAgIGMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpO1xuICAgIGlmIChjID09IDk1KSBjb250aW51ZTtcbiAgICBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBicmVhaztcbiAgICAvKiBEZXRlY3Qgb3ZlcmZsb3cgaW4gbXVsdGlwbGljYXRpb24gYmFzZSAqIHJlcyAqL1xuICAgIGlmIChjYW1sX2ludDY0X3VsdCh0aHJlc2hvbGQsIHJlcykpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICAgIGQgPSBjYW1sX2ludDY0X29mX2ludDMyKGQpO1xuICAgIHJlcyA9IGNhbWxfaW50NjRfYWRkKGNhbWxfaW50NjRfbXVsKGJhc2U2NCwgcmVzKSwgZCk7XG4gICAgLyogRGV0ZWN0IG92ZXJmbG93IGluIGFkZGl0aW9uIChiYXNlICogcmVzKSArIGQgKi9cbiAgICBpZiAoY2FtbF9pbnQ2NF91bHQocmVzLCBkKSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIH1cbiAgaWYgKGkgIT0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgaWYgKHJbMl0gPT0gMTAgJiYgY2FtbF9pbnQ2NF91bHQoWzI1NSwgMCwgMCwgMHg4MDAwXSwgcmVzKSlcbiAgICBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgaWYgKHNpZ24gPCAwKSByZXMgPSBjYW1sX2ludDY0X25lZyhyZXMpO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaVxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkobG8sIG1pLCBoaSl7XG4gIHJldHVybiBbMjU1LCBsbywgbWksIGhpXVxufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGlcbmZ1bmN0aW9uIGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpKGxvLCBoaSl7XG4gIHJldHVybiBbMjU1LFxuICAgICAgICAgIGxvICYgMHhmZmZmZmYsXG4gICAgICAgICAgKChsbyA+Pj4gMjQpICYgMHhmZikgfCAoKGhpICYgMHhmZmZmKSA8PCA4KSxcbiAgICAgICAgICAoaGkgPj4+IDE2KSAmIDB4ZmZmZl07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2xvMzIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbG8zMih2KXtcbiAgcmV0dXJuIHZbMV0gfCAoKHZbMl0gJiAweGZmKSA8PCAyNCk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2hpMzIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfaGkzMih2KXtcbiAgcmV0dXJuICgodlsyXSA+Pj4gOCkgJiAweGZmZmYpIHwgKHZbM10gPDwgMTYpO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb2ZfYnl0ZXMoYSkge1xuICByZXR1cm4gWzI1NSwgYVs3XSB8IChhWzZdIDw8IDgpIHwgKGFbNV0gPDwgMTYpLFxuICAgICAgICAgIGFbNF0gfCAoYVszXSA8PCA4KSB8IChhWzJdIDw8IDE2KSwgYVsxXSB8IChhWzBdIDw8IDgpXTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdG9fYnl0ZXMoeCkge1xuICByZXR1cm4gW3hbM10gPj4gOCwgeFszXSAmIDB4ZmYsIHhbMl0gPj4gMTYsICh4WzJdID4+IDgpICYgMHhmZiwgeFsyXSAmIDB4ZmYsXG4gICAgICAgICAgeFsxXSA+PiAxNiwgKHhbMV0gPj4gOCkgJiAweGZmLCB4WzFdICYgMHhmZl07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaGFzaFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9oYXNoKHgpe1xuICB2YXIgbG8gPSAoKHhbMV0gICAgICApICAgICAgICAgKSB8ICgoeFsyXSAmIDB4ZmYpIDw8IDI0KTtcbiAgdmFyIGhpID0gKCh4WzJdID4+PiA4KSAmIDB4ZmZmZikgfCAoKHhbM10gICAgICAgKSA8PCAxNik7XG4gIHJldHVybiBsbyBeIGhpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwLTIwMTQgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8gQW4gT0NhbWwgc3RyaW5nIGlzIGFuIG9iamVjdCB3aXRoIHRocmVlIGZpZWxkczpcbi8vIC0gdGFnICd0J1xuLy8gLSBsZW5ndGggJ2wnXG4vLyAtIGNvbnRlbnRzICdjJ1xuLy9cbi8vIFRoZSBjb250ZW50cyBvZiB0aGUgc3RyaW5nIGNhbiBiZSBlaXRoZXIgYSBKYXZhU2NyaXB0IGFycmF5IG9yXG4vLyBhIEphdmFTY3JpcHQgc3RyaW5nLiBUaGUgbGVuZ3RoIG9mIHRoaXMgc3RyaW5nIGNhbiBiZSBsZXNzIHRoYW4gdGhlXG4vLyBsZW5ndGggb2YgdGhlIE9DYW1sIHN0cmluZy4gSW4gdGhpcyBjYXNlLCByZW1haW5pbmcgYnl0ZXMgYXJlXG4vLyBhc3N1bWVkIHRvIGJlIHplcm9lcy4gQXJyYXlzIGFyZSBtdXRhYmxlIGJ1dCBjb25zdW1lcyBtb3JlIG1lbW9yeVxuLy8gdGhhbiBzdHJpbmdzLiBBIGNvbW1vbiBwYXR0ZXJuIGlzIHRvIHN0YXJ0IGZyb20gYW4gZW1wdHkgc3RyaW5nIGFuZFxuLy8gcHJvZ3Jlc3NpdmVseSBmaWxsIGl0IGZyb20gdGhlIHN0YXJ0LiBQYXJ0aWFsIHN0cmluZ3MgbWFrZXMgaXRcbi8vIHBvc3NpYmxlIHRvIGltcGxlbWVudCB0aGlzIGVmZmljaWVudGx5LlxuLy9cbi8vIFdoZW4gY29udmVydGluZyB0byBhbmQgZnJvbSBVVEYtMTYsIHdlIGtlZXAgdHJhY2sgb2Ygd2hldGhlciB0aGVcbi8vIHN0cmluZyBpcyBjb21wb3NlZCBvbmx5IG9mIEFTQ0lJIGNoYXJhY3RlcnMgKGluIHdoaWNoIGNhc2UsIG5vXG4vLyBjb252ZXJzaW9uIG5lZWRzIHRvIGJlIHBlcmZvcm1lZCkgb3Igbm90LlxuLy9cbi8vIFRoZSBzdHJpbmcgdGFnIGNhbiB0aHVzIHRha2UgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XG4vLyAgIGZ1bGwgc3RyaW5nICAgICBCWVRFIHwgVU5LTk9XTjogICAgICAwXG4vLyAgICAgICAgICAgICAgICAgICBCWVRFIHwgQVNDSUk6ICAgICAgICA5XG4vLyAgICAgICAgICAgICAgICAgICBCWVRFIHwgTk9UX0FTQ0lJOiAgICA4XG4vLyAgIHN0cmluZyBwcmVmaXggICBQQVJUSUFMOiAgICAgICAgICAgICAyXG4vLyAgIGFycmF5ICAgICAgICAgICBBUlJBWTogICAgICAgICAgICAgICA0XG4vL1xuLy8gT25lIGNhbiB1c2UgYml0IG1hc2tpbmcgdG8gZGlzY3JpbWluYXRlIHRoZXNlIGRpZmZlcmVudCBjYXNlczpcbi8vICAga25vd25fZW5jb2RpbmcoeCkgPSB4Jjhcbi8vICAgaXNfYXNjaWkoeCkgPSAgICAgICB4JjFcbi8vICAga2luZCh4KSA9ICAgICAgICAgICB4JjZcblxuLy9Qcm92aWRlczogY2FtbF9zdHJfcmVwZWF0XG5mdW5jdGlvbiBjYW1sX3N0cl9yZXBlYXQobiwgcykge1xuICBpZihuID09IDApIHJldHVybiBcIlwiO1xuICBpZiAocy5yZXBlYXQpIHtyZXR1cm4gcy5yZXBlYXQobik7fSAvLyBFQ01Bc2NyaXB0IDYgYW5kIEZpcmVmb3ggMjQrXG4gIHZhciByID0gXCJcIiwgbCA9IDA7XG4gIGlmIChuID09IDApIHJldHVybiByO1xuICBmb3IoOzspIHtcbiAgICBpZiAobiAmIDEpIHIgKz0gcztcbiAgICBuID4+PSAxO1xuICAgIGlmIChuID09IDApIHJldHVybiByO1xuICAgIHMgKz0gcztcbiAgICBsKys7XG4gICAgaWYgKGwgPT0gOSkge1xuICAgICAgcy5zbGljZSgwLDEpOyAvLyBmbGF0dGVuIHRoZSBzdHJpbmdcbiAgICAgIC8vIHRoZW4sIHRoZSBmbGF0dGVuaW5nIG9mIHRoZSB3aG9sZSBzdHJpbmcgd2lsbCBiZSBmYXN0ZXIsXG4gICAgICAvLyBhcyBpdCB3aWxsIGJlIGNvbXBvc2VkIG9mIGxhcmdlciBwaWVjZXNcbiAgICB9XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdWJhcnJheV90b19zdHJpbmdcbi8vUmVxdWlyZXM6IHJhd19hcnJheV9zdWJcbi8vV2Vha2RlZlxuLy8gUHJlIEVDTUFTY3JpcHQgNSwgW2FwcGx5XSB3b3VsZCBub3Qgc3VwcG9ydCBhcnJheS1saWtlIG9iamVjdC5cbi8vIEluIHN1Y2ggc2V0dXAsIFR5cGVkX2FycmF5IHdvdWxkIGJlIGltcGxlbWVudGVkIGFzIHBvbHlmaWxsLCBhbmQgW2YuYXBwbHldIHdvdWxkXG4vLyBmYWlsIGhlcmUuIE1hcmsgdGhlIHByaW1pdGl2ZSBhcyBXZWFrZGVmLCBzbyB0aGF0IHBlb3BsZSBjYW4gb3ZlcnJpZGUgaXQgZWFzaWx5LlxuZnVuY3Rpb24gY2FtbF9zdWJhcnJheV90b19zdHJpbmcgKGEsIGksIGxlbikge1xuICB2YXIgZiA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG4gIGlmIChpID09IDAgJiYgbGVuIDw9IDQwOTYgJiYgbGVuID09IGEubGVuZ3RoKSByZXR1cm4gZi5hcHBseSAobnVsbCwgYSk7XG4gIHZhciBzID0gXCJcIjtcbiAgZm9yICg7IDAgPCBsZW47IGkgKz0gMTAyNCxsZW4tPTEwMjQpXG4gICAgcyArPSBmLmFwcGx5IChudWxsLCByYXdfYXJyYXlfc3ViKGEsaSwgTWF0aC5taW4obGVuLCAxMDI0KSkpO1xuICByZXR1cm4gcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF91dGY4X29mX3V0ZjE2XG5mdW5jdGlvbiBjYW1sX3V0Zjhfb2ZfdXRmMTYocykge1xuICBmb3IgKHZhciBiID0gXCJcIiwgdCA9IGIsIGMsIGQsIGkgPSAwLCBsID0gcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyAoaiA8IGwpICYmIChjID0gcy5jaGFyQ29kZUF0KGopKSA8IDB4ODA7IGorKyk7XG4gICAgICBpZiAoaiAtIGkgPiA1MTIpIHsgdC5zdWJzdHIoMCwgMSk7IGIgKz0gdDsgdCA9IFwiXCI7IGIgKz0gcy5zbGljZShpLCBqKSB9XG4gICAgICBlbHNlIHQgKz0gcy5zbGljZShpLCBqKTtcbiAgICAgIGlmIChqID09IGwpIGJyZWFrO1xuICAgICAgaSA9IGo7XG4gICAgfVxuICAgIGlmIChjIDwgMHg4MDApIHtcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGMwIHwgKGMgPj4gNikpO1xuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ODAgfCAoYyAmIDB4M2YpKTtcbiAgICB9IGVsc2UgaWYgKGMgPCAweGQ4MDAgfHwgYyA+PSAweGRmZmYpIHtcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGUwIHwgKGMgPj4gMTIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoKGMgPj4gNikgJiAweDNmKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKGMgJiAweDNmKSk7XG4gICAgfSBlbHNlIGlmIChjID49IDB4ZGJmZiB8fCBpICsgMSA9PSBsIHx8XG4gICAgICAgICAgICAgICAoZCA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGQgPiAweGRmZmYpIHtcbiAgICAgIC8vIFVubWF0Y2hlZCBzdXJyb2dhdGUgcGFpciwgcmVwbGFjZWQgYnkgXFx1ZmZmZCAocmVwbGFjZW1lbnQgY2hhcmFjdGVyKVxuICAgICAgdCArPSBcIlxceGVmXFx4YmZcXHhiZFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBpKys7XG4gICAgICBjID0gKGMgPDwgMTApICsgZCAtIDB4MzVmZGMwMDtcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGYwIHwgKGMgPj4gMTgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoKGMgPj4gMTIpICYgMHgzZiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoYyA+PiA2KSAmIDB4M2YpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoYyAmIDB4M2YpKTtcbiAgICB9XG4gICAgaWYgKHQubGVuZ3RoID4gMTAyNCkge3Quc3Vic3RyKDAsIDEpOyBiICs9IHQ7IHQgPSBcIlwiO31cbiAgfVxuICByZXR1cm4gYit0O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3V0ZjE2X29mX3V0ZjhcbmZ1bmN0aW9uIGNhbWxfdXRmMTZfb2ZfdXRmOChzKSB7XG4gIGZvciAodmFyIGIgPSBcIlwiLCB0ID0gXCJcIiwgYywgYzEsIGMyLCB2LCBpID0gMCwgbCA9IHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgYzEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGMxIDwgMHg4MCkge1xuICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyAoaiA8IGwpICYmIChjMSA9IHMuY2hhckNvZGVBdChqKSkgPCAweDgwOyBqKyspO1xuICAgICAgaWYgKGogLSBpID4gNTEyKSB7IHQuc3Vic3RyKDAsIDEpOyBiICs9IHQ7IHQgPSBcIlwiOyBiICs9IHMuc2xpY2UoaSwgaikgfVxuICAgICAgZWxzZSB0ICs9IHMuc2xpY2UoaSwgaik7XG4gICAgICBpZiAoaiA9PSBsKSBicmVhaztcbiAgICAgIGkgPSBqO1xuICAgIH1cbiAgICB2ID0gMTtcbiAgICBpZiAoKCsraSA8IGwpICYmICgoKGMyID0gcy5jaGFyQ29kZUF0KGkpKSAmIC02NCkgPT0gMTI4KSkge1xuICAgICAgYyA9IGMyICsgKGMxIDw8IDYpO1xuICAgICAgaWYgKGMxIDwgMHhlMCkge1xuICAgICAgICB2ID0gYyAtIDB4MzA4MDtcbiAgICAgICAgaWYgKHYgPCAweDgwKSB2ID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHYgPSAyO1xuICAgICAgICBpZiAoKCsraSA8IGwpICYmICgoKGMyID0gcy5jaGFyQ29kZUF0KGkpKSAmIC02NCkgPT0gMTI4KSkge1xuICAgICAgICAgIGMgPSBjMiArIChjIDw8IDYpO1xuICAgICAgICAgIGlmIChjMSA8IDB4ZjApIHtcbiAgICAgICAgICAgIHYgPSBjIC0gMHhlMjA4MDtcbiAgICAgICAgICAgIGlmICgodiA8IDB4ODAwKSB8fCAoKHYgPj0gMHhkN2ZmKSAmJiAodiA8IDB4ZTAwMCkpKSB2ID0gMjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdiA9IDM7XG4gICAgICAgICAgICBpZiAoKCsraSA8IGwpICYmICgoKGMyID0gcy5jaGFyQ29kZUF0KGkpKSAmIC02NCkgPT0gMTI4KSAmJlxuICAgICAgICAgICAgICAgIChjMSA8IDB4ZjUpKSB7XG4gICAgICAgICAgICAgIHYgPSBjMiAtIDB4M2M4MjA4MCArIChjIDw8IDYpO1xuICAgICAgICAgICAgICBpZiAodiA8IDB4MTAwMDAgfHwgdiA+IDB4MTBmZmZmKSB2ID0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHYgPCA0KSB7IC8vIEludmFsaWQgc2VxdWVuY2VcbiAgICAgIGkgLT0gdjtcbiAgICAgIHQgKz0gXCJcXHVmZmZkXCI7XG4gICAgfSBlbHNlIGlmICh2ID4gMHhmZmZmKVxuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDdjMCArICh2ID4+IDEwKSwgMHhkYzAwICsgKHYgJiAweDNGRikpXG4gICAgZWxzZVxuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHYpO1xuICAgIGlmICh0Lmxlbmd0aCA+IDEwMjQpIHt0LnN1YnN0cigwLCAxKTsgYiArPSB0OyB0ID0gXCJcIjt9XG4gIH1cbiAgcmV0dXJuIGIrdDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19hc2NpaVxuZnVuY3Rpb24gY2FtbF9pc19hc2NpaSAocykge1xuICAvLyBUaGUgcmVndWxhciBleHByZXNzaW9uIGdldHMgYmV0dGVyIGF0IGFyb3VuZCB0aGlzIHBvaW50IGZvciBhbGwgYnJvd3NlcnNcbiAgaWYgKHMubGVuZ3RoIDwgMjQpIHtcbiAgICAvLyBTcGlkZXJtb25rZXkgZ2V0cyBtdWNoIHNsb3dlciB3aGVuIHMubGVuZ3RoID49IDI0IChvbiA2NCBiaXQgYXJjaHMpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSBpZiAocy5jaGFyQ29kZUF0KGkpID4gMTI3KSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZVxuICAgIHJldHVybiAhL1teXFx4MDAtXFx4N2ZdLy50ZXN0KHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3RvX2pzX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcywgY2FtbF9pc19hc2NpaSwgY2FtbF91dGYxNl9vZl91dGY4XG5mdW5jdGlvbiBjYW1sX3RvX2pzX3N0cmluZyhzKSB7XG4gIHN3aXRjaCAocy50KSB7XG4gIGNhc2UgOTogLypCWVRFUyB8IEFTQ0lJKi9cbiAgICByZXR1cm4gcy5jO1xuICBkZWZhdWx0OlxuICAgIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMocyk7XG4gIGNhc2UgMDogLypCWVRFUyB8IFVOS09XTiovXG4gICAgaWYgKGNhbWxfaXNfYXNjaWkocy5jKSkge1xuICAgICAgcy50ID0gOTsgLypCWVRFUyB8IEFTQ0lJKi9cbiAgICAgIHJldHVybiBzLmM7XG4gICAgfVxuICAgIHMudCA9IDg7IC8qQllURVMgfCBOT1RfQVNDSUkqL1xuICBjYXNlIDg6IC8qQllURVMgfCBOT1RfQVNDSUkqL1xuICAgIHJldHVybiBjYW1sX3V0ZjE2X29mX3V0Zjgocy5jKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpIHtcbiAgc3dpdGNoIChzLnQgJiA2KSB7XG4gIGRlZmF1bHQ6IC8qIFBBUlRJQUwgKi9cbiAgICBpZiAoaSA+PSBzLmMubGVuZ3RoKSByZXR1cm4gMDtcbiAgY2FzZSAwOiAvKiBCWVRFUyAqL1xuICAgIHJldHVybiBzLmMuY2hhckNvZGVBdChpKTtcbiAgY2FzZSA0OiAvKiBBUlJBWSAqL1xuICAgIHJldHVybiBzLmNbaV1cbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpKSB7XG4gIHN3aXRjaCAocy50ICYgNikge1xuICBkZWZhdWx0OiAvKiBQQVJUSUFMICovXG4gICAgaWYgKGkgPj0gcy5jLmxlbmd0aCkgcmV0dXJuIDA7XG4gIGNhc2UgMDogLyogQllURVMgKi9cbiAgICByZXR1cm4gcy5jLmNoYXJDb2RlQXQoaSk7XG4gIGNhc2UgNDogLyogQVJSQVkgKi9cbiAgICByZXR1cm4gcy5jW2ldXG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc191bnNhZmVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGksIGMpIHtcbiAgLy8gVGhlIE9DYW1sIGNvbXBpbGVyIHVzZXMgQ2hhci51bnNhZmVfY2hyIG9uIGludGVnZXJzIGxhcmdlciB0aGFuIDI1NSFcbiAgYyAmPSAweGZmO1xuICBpZiAocy50ICE9IDQgLyogQVJSQVkgKi8pIHtcbiAgICBpZiAoaSA9PSBzLmMubGVuZ3RoKSB7XG4gICAgICBzLmMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSAoYyk7XG4gICAgICBpZiAoaSArIDEgPT0gcy5sKSBzLnQgPSAwOyAvKkJZVEVTIHwgVU5LT1dOKi9cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2FycmF5IChzKTtcbiAgfVxuICBzLmNbaV0gPSBjO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfdW5zYWZlX3NldFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfc2V0XG5mdW5jdGlvbiBjYW1sX3N0cmluZ191bnNhZmVfc2V0IChzLCBpLCBjKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQocyxpLGMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ib3VuZF9lcnJvciAoKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19nZXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0XG5mdW5jdGlvbiBjYW1sX3N0cmluZ19nZXQgKHMsIGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dldDE2XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ2V0MTYocyxpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDEpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpLFxuICAgICAgYjIgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMSk7XG4gIHJldHVybiAoYjIgPDwgOCB8IGIxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19nZXQxNlxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ2V0MTYocyxpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDEpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpLFxuICAgICAgYjIgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMSk7XG4gIHJldHVybiAoYjIgPDwgOCB8IGIxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19nZXQzMihzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gMykgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSksXG4gICAgICBiMiA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAxKSxcbiAgICAgIGIzID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDIpLFxuICAgICAgYjQgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMyk7XG4gIHJldHVybiAoYjQgPDwgMjQgfCBiMyA8PCAxNiB8IGIyIDw8IDggfCBiMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dldDMyKHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSAzKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSxcbiAgICAgIGIyID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDEpLFxuICAgICAgYjMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMiksXG4gICAgICBiNCA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAzKTtcbiAgcmV0dXJuIChiNCA8PCAyNCB8IGIzIDw8IDE2IHwgYjIgPDwgOCB8IGIxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19nZXQ2NChzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gNykgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGEgPSBuZXcgQXJyYXkoOCk7XG4gIGZvcih2YXIgaiA9IDA7IGogPCA4OyBqKyspe1xuICAgIGFbNyAtIGpdID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIGopO1xuICB9XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzKGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dldDY0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19nZXQ2NChzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gNykgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGEgPSBuZXcgQXJyYXkoOCk7XG4gIGZvcih2YXIgaiA9IDA7IGogPCA4OyBqKyspe1xuICAgIGFbNyAtIGpdID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIGopO1xuICB9XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzKGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dldFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19nZXQgKHMsIGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfc2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0IChzLCBpLCBjKSB7XG4gIGlmIChpID4+PiAwID49IHMubCkgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGksIGMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3NldDE2XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19ib3VuZF9lcnJvciwgY2FtbF9zdHJpbmdfdW5zYWZlX3NldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19zZXQxNihzLGksaTE2KXtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gMSkgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIyID0gMHhGRiAmIGkxNiA+PiA4LFxuICAgICAgYjEgPSAweEZGICYgaTE2O1xuICBjYW1sX3N0cmluZ191bnNhZmVfc2V0IChzLCBpICsgMCwgYjEpO1xuICBjYW1sX3N0cmluZ191bnNhZmVfc2V0IChzLCBpICsgMSwgYjIpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQxNlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19zZXQxNlxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0MTYocyxpLGkxNil7XG4gIHJldHVybiBjYW1sX2J5dGVzX3NldDE2KHMsaSxpMTYpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3NldDMyXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19ib3VuZF9lcnJvciwgY2FtbF9zdHJpbmdfdW5zYWZlX3NldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19zZXQzMihzLGksaTMyKXtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gMykgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGI0ID0gMHhGRiAmIGkzMiA+PiAyNCxcbiAgICAgIGIzID0gMHhGRiAmIGkzMiA+PiAxNixcbiAgICAgIGIyID0gMHhGRiAmIGkzMiA+PiA4LFxuICAgICAgYjEgPSAweEZGICYgaTMyO1xuICBjYW1sX3N0cmluZ191bnNhZmVfc2V0IChzLCBpICsgMCwgYjEpO1xuICBjYW1sX3N0cmluZ191bnNhZmVfc2V0IChzLCBpICsgMSwgYjIpO1xuICBjYW1sX3N0cmluZ191bnNhZmVfc2V0IChzLCBpICsgMiwgYjMpO1xuICBjYW1sX3N0cmluZ191bnNhZmVfc2V0IChzLCBpICsgMywgYjQpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQzMlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19zZXQzMlxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0MzIocyxpLGkzMil7XG4gIHJldHVybiBjYW1sX2J5dGVzX3NldDMyKHMsaSxpMzIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3NldDY0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19ib3VuZF9lcnJvciwgY2FtbF9zdHJpbmdfdW5zYWZlX3NldFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19zZXQ2NChzLGksaTY0KXtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gNykgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGEgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGk2NCk7XG4gIGZvcih2YXIgaiA9IDA7IGogPCA4OyBqKyspIHtcbiAgICBjYW1sX3N0cmluZ191bnNhZmVfc2V0IChzLCBpICsgNyAtIGosIGFbal0pO1xuICB9XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3NldDY0XG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQ2NChzLGksaTY0KXtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfc2V0NjQocyxpLGk2NCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfc2V0XG5mdW5jdGlvbiBjYW1sX2J5dGVzX3NldCAocywgaSwgYykge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGksIGMpO1xufVxuXG4vL1Byb3ZpZGVzOiBNbEJ5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3RvX2pzX3N0cmluZ1xuZnVuY3Rpb24gTWxCeXRlcyAodGFnLCBjb250ZW50cywgbGVuZ3RoKSB7XG4gIHRoaXMudD10YWc7IHRoaXMuYz1jb250ZW50czsgdGhpcy5sPWxlbmd0aDtcbn1cbk1sQnl0ZXMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKXtyZXR1cm4gY2FtbF90b19qc19zdHJpbmcodGhpcyl9O1xuTWxCeXRlcy5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoKXtcbiAgdmFyIGNvbnRlbnQgPSB0aGlzLnQgPT0gNCA/IHRoaXMuYy5zbGljZSgpIDogdGhpcy5jO1xuICByZXR1cm4gbmV3IE1sQnl0ZXModGhpcy50LGNvbnRlbnQsdGhpcy5sKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdHJfcmVwZWF0LCBjYW1sX3N1YmFycmF5X3RvX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyAocykge1xuICAvKiBBc3N1bWVzIG5vdCBCWVRFUyAqL1xuICBpZiAocy50ID09IDIgLyogUEFSVElBTCAqLylcbiAgICBzLmMgKz0gY2FtbF9zdHJfcmVwZWF0KHMubCAtIHMuYy5sZW5ndGgsICdcXDAnKVxuICBlbHNlXG4gICAgcy5jID0gY2FtbF9zdWJhcnJheV90b19zdHJpbmcgKHMuYywgMCwgcy5jLmxlbmd0aCk7XG4gIHMudCA9IDA7IC8qQllURVMgfCBVTktPV04qL1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2FycmF5IChzKSB7XG4gIC8qIEFzc3VtZXMgbm90IEFSUkFZICovXG4gIGlmKGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkpIHtcbiAgICB2YXIgYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KHMubCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGEgPSBuZXcgQXJyYXkocy5sKTtcbiAgfVxuICB2YXIgYiA9IHMuYywgbCA9IGIubGVuZ3RoLCBpID0gMDtcbiAgZm9yICg7IGkgPCBsOyBpKyspIGFbaV0gPSBiLmNoYXJDb2RlQXQoaSk7XG4gIGZvciAobCA9IHMubDsgaSA8IGw7IGkrKykgYVtpXSA9IDA7XG4gIHMuYyA9IGE7XG4gIHMudCA9IDQ7IC8qIEFSUkFZICovXG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X29mX3N0cmluZyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2FycmF5X29mX3N0cmluZyAocykge1xuICBpZiAocy50ICE9IDQgLyogQVJSQVkgKi8pIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYXJyYXkocyk7XG4gIHJldHVybiBzLmM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9qc2J5dGVzX29mX3N0cmluZyAocykge1xuICBpZiAoKHMudCAmIDYpICE9IDAgLyogQllURVMgKi8pIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMocyk7XG4gIHJldHVybiBzLmM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2lzX2FzY2lpLCBjYW1sX3V0Zjhfb2ZfdXRmMTYsIE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfanNfdG9fc3RyaW5nIChzKSB7XG4gIHZhciB0YWcgPSA5IC8qIEJZVEVTIHwgQVNDSUkgKi87XG4gIGlmICghY2FtbF9pc19hc2NpaShzKSlcbiAgICB0YWcgPSA4IC8qIEJZVEVTIHwgTk9UX0FTQ0lJICovLCBzID0gY2FtbF91dGY4X29mX3V0ZjE2KHMpO1xuICByZXR1cm4gbmV3IE1sQnl0ZXModGFnLCBzLCBzLmxlbmd0aCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogTWxCeXRlcyxjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX3N0cmluZyhsZW4pIHtcbiAgaWYgKGxlbiA8IDApIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0cmluZy5jcmVhdGVcIik7XG4gIHJldHVybiBuZXcgTWxCeXRlcyhsZW4/Mjo5LFwiXCIsbGVuKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX2J5dGVzIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEJ5dGVzLGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9jcmVhdGVfYnl0ZXMobGVuKSB7XG4gIGlmIChsZW4gPCAwKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCeXRlcy5jcmVhdGVcIik7XG4gIHJldHVybiBuZXcgTWxCeXRlcyhsZW4/Mjo5LFwiXCIsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9uZXdfc3RyaW5nIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbmV3X3N0cmluZyAocykgeyByZXR1cm4gbmV3IE1sQnl0ZXMoMCxzLHMubGVuZ3RoKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9hcnJheVxuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfYXJyYXkgKGEpIHsgcmV0dXJuIG5ldyBNbEJ5dGVzKDQsYSxhLmxlbmd0aCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfY29tcGFyZSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19jb21wYXJlKHMxLCBzMikge1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPCBzMi5jKT8tMTooczEuYyA+IHMyLmMpPzE6MDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2NvbXBhcmUgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19jb21wYXJlKHMxLCBzMikge1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPCBzMi5jKT8tMTooczEuYyA+IHMyLmMpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZXF1YWwoczEsIHMyKSB7XG4gIGlmKHMxID09PSBzMikgcmV0dXJuIDE7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiAoczEuYyA9PSBzMi5jKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19lcXVhbChzMSwgczIpIHtcbiAgaWYoczEgPT09IHMyKSByZXR1cm4gMTtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jID09IHMyLmMpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbm90ZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfZXF1YWxcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX25vdGVxdWFsKHMxLCBzMikgeyByZXR1cm4gMS1jYW1sX3N0cmluZ19lcXVhbChzMSwgczIpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfbm90ZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfZXF1YWxcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfbm90ZXF1YWwoczEsIHMyKSB7IHJldHVybiAxLWNhbWxfc3RyaW5nX2VxdWFsKHMxLCBzMik7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbGVzc2VxdWFsIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3NlcXVhbChzMSwgczIpIHtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jIDw9IHMyLmMpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19sZXNzZXF1YWwgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19sZXNzZXF1YWwoczEsIHMyKSB7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiAoczEuYyA8PSBzMi5jKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2xlc3N0aGFuIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3N0aGFuKHMxLCBzMikge1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPCBzMi5jKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfbGVzc3RoYW4gbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19sZXNzdGhhbihzMSwgczIpIHtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jIDwgczIuYyk/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19ncmVhdGVyZXF1YWxcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2xlc3NlcXVhbFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ3JlYXRlcmVxdWFsKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfbGVzc2VxdWFsKHMyLHMxKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ3JlYXRlcmVxdWFsXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2xlc3NlcXVhbFxuZnVuY3Rpb24gY2FtbF9ieXRlc19ncmVhdGVyZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3NlcXVhbChzMixzMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dyZWF0ZXJ0aGFuXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19sZXNzdGhhblxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ3JlYXRlcnRoYW4oczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19sZXNzdGhhbihzMiwgczEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dyZWF0ZXJ0aGFuXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2xlc3N0aGFuXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dyZWF0ZXJ0aGFuKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19sZXNzdGhhbihzMiwgczEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbGxfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3RyX3JlcGVhdCwgY2FtbF9jb252ZXJ0X3N0cmluZ190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9maWxsX2J5dGVzKHMsIGksIGwsIGMpIHtcbiAgaWYgKGwgPiAwKSB7XG4gICAgaWYgKGkgPT0gMCAmJiAobCA+PSBzLmwgfHwgKHMudCA9PSAyIC8qIFBBUlRJQUwgKi8gJiYgbCA+PSBzLmMubGVuZ3RoKSkpIHtcbiAgICAgIGlmIChjID09IDApIHtcbiAgICAgICAgcy5jID0gXCJcIjtcbiAgICAgICAgcy50ID0gMjsgLyogUEFSVElBTCAqL1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcy5jID0gY2FtbF9zdHJfcmVwZWF0IChsLCBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgICAgICAgcy50ID0gKGwgPT0gcy5sKT8wIC8qIEJZVEVTIHwgVU5LT1dOICovIDoyOyAvKiBQQVJUSUFMICovXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzLnQgIT0gNCAvKiBBUlJBWSAqLykgY2FtbF9jb252ZXJ0X3N0cmluZ190b19hcnJheShzKTtcbiAgICAgIGZvciAobCArPSBpOyBpIDwgbDsgaSsrKSBzLmNbaV0gPSBjO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maWxsX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9maWxsX2J5dGVzXG52YXIgY2FtbF9maWxsX3N0cmluZyA9IGNhbWxfZmlsbF9ieXRlc1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2JsaXRfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3ViYXJyYXlfdG9fc3RyaW5nLCBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2JsaXRfYnl0ZXMoczEsIGkxLCBzMiwgaTIsIGxlbikge1xuICBpZiAobGVuID09IDApIHJldHVybiAwO1xuICBpZiAoKGkyID09IDApICYmXG4gICAgICAobGVuID49IHMyLmwgfHwgKHMyLnQgPT0gMiAvKiBQQVJUSUFMICovICYmIGxlbiA+PSBzMi5jLmxlbmd0aCkpKSB7XG4gICAgczIuYyA9IChzMS50ID09IDQgLyogQVJSQVkgKi8pP1xuICAgICAgY2FtbF9zdWJhcnJheV90b19zdHJpbmcoczEuYywgaTEsIGxlbik6XG4gICAgICAoaTEgPT0gMCAmJiBzMS5jLmxlbmd0aCA9PSBsZW4pP3MxLmM6czEuYy5zdWJzdHIoaTEsIGxlbik7XG4gICAgczIudCA9IChzMi5jLmxlbmd0aCA9PSBzMi5sKT8wIC8qIEJZVEVTIHwgVU5LT1dOICovIDoyOyAvKiBQQVJUSUFMICovXG4gIH0gZWxzZSBpZiAoczIudCA9PSAyIC8qIFBBUlRJQUwgKi8gJiYgaTIgPT0gczIuYy5sZW5ndGgpIHtcbiAgICBzMi5jICs9IChzMS50ID09IDQgLyogQVJSQVkgKi8pP1xuICAgICAgY2FtbF9zdWJhcnJheV90b19zdHJpbmcoczEuYywgaTEsIGxlbik6XG4gICAgICAoaTEgPT0gMCAmJiBzMS5jLmxlbmd0aCA9PSBsZW4pP3MxLmM6czEuYy5zdWJzdHIoaTEsIGxlbik7XG4gICAgczIudCA9IChzMi5jLmxlbmd0aCA9PSBzMi5sKT8wIC8qIEJZVEVTIHwgVU5LT1dOICovIDoyOyAvKiBQQVJUSUFMICovXG4gIH0gZWxzZSB7XG4gICAgaWYgKHMyLnQgIT0gNCAvKiBBUlJBWSAqLykgY2FtbF9jb252ZXJ0X3N0cmluZ190b19hcnJheShzMik7XG4gICAgdmFyIGMxID0gczEuYywgYzIgPSBzMi5jO1xuICAgIGlmIChzMS50ID09IDQgLyogQVJSQVkgKi8pIHtcbiAgICAgIGlmIChpMiA8PSBpMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBjMiBbaTIgKyBpXSA9IGMxIFtpMSArIGldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSBjMiBbaTIgKyBpXSA9IGMxIFtpMSArIGldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbCA9IE1hdGgubWluIChsZW4sIGMxLmxlbmd0aCAtIGkxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSBjMiBbaTIgKyBpXSA9IGMxLmNoYXJDb2RlQXQoaTEgKyBpKTtcbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIGMyIFtpMiArIGldID0gMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmxpdF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmxpdF9ieXRlc1xuZnVuY3Rpb24gY2FtbF9ibGl0X3N0cmluZyhzMSwgaTEsIHMyLCBpMiwgbGVuKSB7XG4gIC8vIFRPRE86IHMxIC0+IHN0cmluZyB0byBieXRlc1xuICByZXR1cm4gY2FtbF9ibGl0X2J5dGVzKHMxLCBpMSwgczIsIGkyLCBsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGggY29uc3RcbmZ1bmN0aW9uIGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSB7IHJldHVybiBzLmwgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aCBjb25zdFxuZnVuY3Rpb24gY2FtbF9tbF9ieXRlc19sZW5ndGgocykgeyByZXR1cm4gcy5sIH1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfYnl0ZXMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2J5dGVzKHMpIHsgcmV0dXJuIHN9XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2Zfc3RyaW5nIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX3N0cmluZyhzKSB7IHJldHVybiBzfVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gQ29yZVxuXG4vL1Byb3ZpZGVzOiByYXdfYXJyYXlfc3ViXG5mdW5jdGlvbiByYXdfYXJyYXlfc3ViIChhLGksbCkge1xuICB2YXIgYiA9IG5ldyBBcnJheShsKTtcbiAgZm9yKHZhciBqID0gMDsgaiA8IGw7IGorKykgYltqXSA9IGFbaStqXTtcbiAgcmV0dXJuIGJcbn1cblxuLy9Qcm92aWRlczogcmF3X2FycmF5X2NvcHlcbmZ1bmN0aW9uIHJhd19hcnJheV9jb3B5IChhKSB7XG4gIHZhciBsID0gYS5sZW5ndGg7XG4gIHZhciBiID0gbmV3IEFycmF5KGwpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrICkgYltpXSA9IGFbaV07XG4gIHJldHVybiBiXG59XG5cbi8vUHJvdmlkZXM6IHJhd19hcnJheV9jb25zXG5mdW5jdGlvbiByYXdfYXJyYXlfY29ucyAoYSx4KSB7XG4gIHZhciBsID0gYS5sZW5ndGg7XG4gIHZhciBiID0gbmV3IEFycmF5KGwrMSk7XG4gIGJbMF09eDtcbiAgZm9yKHZhciBpID0gMTsgaSA8PSBsOyBpKysgKSBiW2ldID0gYVtpLTFdO1xuICByZXR1cm4gYlxufVxuXG4vL1Byb3ZpZGVzOiByYXdfYXJyYXlfYXBwZW5kX29uZVxuZnVuY3Rpb24gcmF3X2FycmF5X2FwcGVuZF9vbmUoYSx4KSB7XG4gIHZhciBsID0gYS5sZW5ndGg7XG4gIHZhciBiID0gbmV3IEFycmF5KGwrMSk7XG4gIHZhciBpID0gMDtcbiAgZm9yKDsgaSA8IGw7IGkrKyApIGJbaV0gPSBhW2ldO1xuICBiW2ldPXg7XG4gIHJldHVybiBiXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY2FsbF9nZW4gKGNvbnN0LCBzaGFsbG93KVxuLy9SZXF1aXJlczogcmF3X2FycmF5X3N1YlxuLy9SZXF1aXJlczogcmF3X2FycmF5X2FwcGVuZF9vbmVcbmZ1bmN0aW9uIGNhbWxfY2FsbF9nZW4oZiwgYXJncykge1xuICBpZihmLmZ1bilcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLmZ1biwgYXJncyk7XG4gIHZhciBuID0gZi5sZW5ndGg7XG4gIHZhciBhcmdzTGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBkID0gbiAtIGFyZ3NMZW47XG4gIGlmIChkID09IDApXG4gICAgcmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gIGVsc2UgaWYgKGQgPCAwKVxuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYuYXBwbHkobnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhd19hcnJheV9zdWIoYXJncywwLG4pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICByYXdfYXJyYXlfc3ViKGFyZ3MsbixhcmdzTGVuIC0gbikpO1xuICBlbHNlXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh4KXsgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgcmF3X2FycmF5X2FwcGVuZF9vbmUoYXJncyx4KSk7IH07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmFtZWRfdmFsdWVzXG52YXIgY2FtbF9uYW1lZF92YWx1ZXMgPSB7fTtcblxuLy9Qcm92aWRlczogY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZSAoY29uc3QsY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZShubSx2KSB7XG4gIGNhbWxfbmFtZWRfdmFsdWVzW2NhbWxfanNieXRlc19vZl9zdHJpbmcobm0pXSA9IHY7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25hbWVkX3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlc1xuZnVuY3Rpb24gY2FtbF9uYW1lZF92YWx1ZShubSkge1xuICByZXR1cm4gY2FtbF9uYW1lZF92YWx1ZXNbbm1dXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2xvYmFsX2RhdGFcbnZhciBjYW1sX2dsb2JhbF9kYXRhID0gWzBdO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlZ2lzdGVyX2dsb2JhbCAoY29uc3QsIHNoYWxsb3csIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yZWdpc3Rlcl9nbG9iYWwgKG4sIHYsIG5hbWVfb3B0KSB7XG4gIGlmKG5hbWVfb3B0ICYmIGpvb19nbG9iYWxfb2JqZWN0LnRvcGxldmVsUmVsb2MpXG4gICAgbiA9IGpvb19nbG9iYWxfb2JqZWN0LnRvcGxldmVsUmVsb2MobmFtZV9vcHQpO1xuICBjYW1sX2dsb2JhbF9kYXRhW24gKyAxXSA9IHY7XG4gIGlmKG5hbWVfb3B0KSBjYW1sX2dsb2JhbF9kYXRhW25hbWVfb3B0XSA9IHY7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2dsb2JhbF9kYXRhIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfZ2V0X2dsb2JhbF9kYXRhICgpIHsgcmV0dXJuIGNhbWxfZ2xvYmFsX2RhdGE7IH1cblxuLy9SYWlzZSBleGNlcHRpb25cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX2NvbnN0YW50IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfcmFpc2VfY29uc3RhbnQgKHRhZykgeyB0aHJvdyB0YWc7IH1cblxuLy9Qcm92aWRlczogY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfcmV0dXJuX2V4bl9jb25zdGFudCAodGFnKSB7IHJldHVybiB0YWc7IH1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV93aXRoX2FyZyAoY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9yYWlzZV93aXRoX2FyZyAodGFnLCBhcmcpIHsgdGhyb3cgWzAsIHRhZywgYXJnXTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfYXJnLGNhbWxfbmV3X3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9yYWlzZV93aXRoX3N0cmluZyAodGFnLCBtc2cpIHtcbiAgY2FtbF9yYWlzZV93aXRoX2FyZyAodGFnLCBjYW1sX25ld19zdHJpbmcgKG1zZykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3N5c19lcnJvciAobXNnKSB7XG4gIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcoY2FtbF9nbG9iYWxfZGF0YS5TeXNfZXJyb3IsIG1zZyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmFpbHdpdGggKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX3N0cmluZywgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9mYWlsd2l0aCAobXNnKSB7XG4gIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcoY2FtbF9nbG9iYWxfZGF0YS5GYWlsdXJlLCBtc2cpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3dyYXBfZXhjZXB0aW9uIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsY2FtbF9qc190b19zdHJpbmcsY2FtbF9uYW1lZF92YWx1ZVxuLy9SZXF1aXJlczogY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50XG5mdW5jdGlvbiBjYW1sX3dyYXBfZXhjZXB0aW9uKGUpIHtcbiAgaWYoZSBpbnN0YW5jZW9mIEFycmF5KSByZXR1cm4gZTtcbiAgLy9TdGFja19vdmVyZmxvdzogY2hyb21lLCBzYWZhcmlcbiAgaWYoam9vX2dsb2JhbF9vYmplY3QuUmFuZ2VFcnJvclxuICAgICAmJiBlIGluc3RhbmNlb2Ygam9vX2dsb2JhbF9vYmplY3QuUmFuZ2VFcnJvclxuICAgICAmJiBlLm1lc3NhZ2VcbiAgICAgJiYgZS5tZXNzYWdlLm1hdGNoKC9tYXhpbXVtIGNhbGwgc3RhY2svaSkpXG4gICAgcmV0dXJuIGNhbWxfcmV0dXJuX2V4bl9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLlN0YWNrX292ZXJmbG93KTtcbiAgLy9TdGFja19vdmVyZmxvdzogZmlyZWZveFxuICBpZihqb29fZ2xvYmFsX29iamVjdC5JbnRlcm5hbEVycm9yXG4gICAgICYmIGUgaW5zdGFuY2VvZiBqb29fZ2xvYmFsX29iamVjdC5JbnRlcm5hbEVycm9yXG4gICAgICYmIGUubWVzc2FnZVxuICAgICAmJiBlLm1lc3NhZ2UubWF0Y2goL3RvbyBtdWNoIHJlY3Vyc2lvbi9pKSlcbiAgICByZXR1cm4gY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50KGNhbWxfZ2xvYmFsX2RhdGEuU3RhY2tfb3ZlcmZsb3cpO1xuICAvL1dyYXAgRXJyb3IgaW4gSnMuRXJyb3IgZXhjZXB0aW9uXG4gIGlmKGUgaW5zdGFuY2VvZiBqb29fZ2xvYmFsX29iamVjdC5FcnJvciAmJiBjYW1sX25hbWVkX3ZhbHVlKFwianNFcnJvclwiKSlcbiAgICByZXR1cm4gWzAsY2FtbF9uYW1lZF92YWx1ZShcImpzRXJyb3JcIiksZV07XG4gIC8vZmFsbGJhY2s6IHdyYXBwZWQgaW4gRmFpbHVyZVxuICByZXR1cm4gWzAsY2FtbF9nbG9iYWxfZGF0YS5GYWlsdXJlLGNhbWxfanNfdG9fc3RyaW5nIChTdHJpbmcoZSkpXTtcbn1cblxuLy8gRXhwZXJpbWVudGFsXG4vL1Byb3ZpZGVzOiBjYW1sX2V4bl93aXRoX2pzX2JhY2t0cmFjZVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9leG5fd2l0aF9qc19iYWNrdHJhY2UoZXhuLCBmb3JjZSkge1xuICAvL25ldmVyIHJlcmFpc2UgZm9yIGNvbnN0YW50IGV4blxuICBpZighZXhuLmpzX2Vycm9yIHx8IGZvcmNlIHx8IGV4blswXSA9PSAyNDgpIGV4bi5qc19lcnJvciA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5FcnJvcihcIkpzIGV4Y2VwdGlvbiBjb250YWluaW5nIGJhY2t0cmFjZVwiKTtcbiAgcmV0dXJuIGV4bjtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXJyb3Jfb2ZfZXhjZXB0aW9uXG5mdW5jdGlvbiBjYW1sX2pzX2Vycm9yX29mX2V4Y2VwdGlvbihleG4pIHtcbiAgaWYoZXhuLmpzX2Vycm9yKSB7IHJldHVybiBleG4uanNfZXJyb3I7IH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX2ludmFsaWRfYXJndW1lbnQgKG1zZykge1xuICBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nKGNhbWxfZ2xvYmFsX2RhdGEuSW52YWxpZF9hcmd1bWVudCwgbXNnKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9jb25zdGFudCwgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSAoKSB7XG4gIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5FbmRfb2ZfZmlsZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCkge1xuICBjYW1sX3JhaXNlX2NvbnN0YW50KGNhbWxfZ2xvYmFsX2RhdGEuRGl2aXNpb25fYnlfemVybyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfbm90X2ZvdW5kXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2NvbnN0YW50LCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JhaXNlX25vdF9mb3VuZCAoKSB7XG4gIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5Ob3RfZm91bmQpOyB9XG5cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yICgpIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91cGRhdGVfZHVtbXlcbmZ1bmN0aW9uIGNhbWxfdXBkYXRlX2R1bW15ICh4LCB5KSB7XG4gIGlmKCB0eXBlb2YgeT09PVwiZnVuY3Rpb25cIiApIHsgeC5mdW4gPSB5OyByZXR1cm4gMDsgfVxuICBpZiggeS5mdW4gKSB7IHguZnVuID0geS5mdW47IHJldHVybiAwOyB9XG4gIHZhciBpID0geS5sZW5ndGg7IHdoaWxlIChpLS0pIHhbaV0gPSB5W2ldOyByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfaXNfYmxvY2sgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9vYmpfaXNfYmxvY2sgKHgpIHsgcmV0dXJuICsoeCBpbnN0YW5jZW9mIEFycmF5KTsgfVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3RhZ1xuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9vYmpfdGFnICh4KSB7XG4gIGlmICgoeCBpbnN0YW5jZW9mIEFycmF5KSAmJiB4WzBdID09ICh4WzBdID4+PiAwKSlcbiAgICByZXR1cm4geFswXVxuICBlbHNlIGlmICh4IGluc3RhbmNlb2YgTWxCeXRlcylcbiAgICByZXR1cm4gMjUyXG4gIGVsc2UgaWYgKCh4IGluc3RhbmNlb2YgRnVuY3Rpb24pIHx8IHR5cGVvZiB4ID09IFwiZnVuY3Rpb25cIilcbiAgICByZXR1cm4gMjQ3XG4gIGVsc2UgaWYgKHggJiYgeC5jYW1sX2N1c3RvbSlcbiAgICByZXR1cm4gMjU1XG4gIGVsc2VcbiAgICByZXR1cm4gMTAwMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9zZXRfdGFnIChtdXRhYmxlLCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfb2JqX3NldF90YWcgKHgsIHRhZykgeyB4WzBdID0gdGFnOyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9vYmpfYmxvY2sgY29uc3QgKGNvbnN0LGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9vYmpfYmxvY2sgKHRhZywgc2l6ZSkge1xuICB2YXIgbyA9IG5ldyBBcnJheShzaXplKzEpO1xuICBvWzBdPXRhZztcbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gc2l6ZTsgaSsrKSBvW2ldID0gMDtcbiAgcmV0dXJuIG87XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3dpdGhfdGFnXG5mdW5jdGlvbiBjYW1sX29ial93aXRoX3RhZyh0YWcseCkge1xuICB2YXIgbCA9IHgubGVuZ3RoO1xuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgYVswXSA9IHRhZztcbiAgZm9yKHZhciBpID0gMTsgaSA8IGw7IGkrKyApIGFbaV0gPSB4W2ldO1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfZHVwIG11dGFibGUgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9vYmpfZHVwICh4KSB7XG4gIHZhciBsID0geC5sZW5ndGg7XG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrICkgYVtpXSA9IHhbaV07XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial90cnVuY2F0ZSAobXV0YWJsZSwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfb2JqX3RydW5jYXRlICh4LCBzKSB7XG4gIGlmIChzPD0wIHx8IHMgKyAxID4geC5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIk9iai50cnVuY2F0ZVwiKTtcbiAgaWYgKHgubGVuZ3RoICE9IHMgKyAxKSB4Lmxlbmd0aCA9IHMgKyAxO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfbWFrZV9mb3J3YXJkXG5mdW5jdGlvbiBjYW1sX29ial9tYWtlX2ZvcndhcmQgKGIsdikge1xuICBiWzBdPTI1MDtcbiAgYlsxXT12O1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xhenlfbWFrZV9mb3J3YXJkIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfbGF6eV9tYWtlX2ZvcndhcmQgKHYpIHsgcmV0dXJuIFsyNTAsIHZdOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbXVsIGNvbnN0XG5pZiAoIU1hdGguaW11bClcbiAgTWF0aC5pbXVsID1cbiAgZnVuY3Rpb24gKHgseSkge1xuICAgIHkgfD0gMDtcbiAgICByZXR1cm4gKCgoKHggPj4gMTYpICogeSkgPDwgMTYpICsgKHggJiAweGZmZmYpICogeSl8MDtcbiAgfTtcbnZhciBjYW1sX211bCA9IE1hdGguaW11bDtcblxuLy9zbGlnaHRseSBzbG93ZXJcbi8vIGZ1bmN0aW9uIG11bDMyKHgseSkge1xuLy8gICB2YXIgeGxvID0geCAmIDB4ZmZmZjtcbi8vICAgdmFyIHhoaSA9IHggLSB4bG87XG4vLyAgIHJldHVybiAoKCh4aGkgKiB5KSB8MCkgKyB4bG8gKiB5KXwwO1xuLy8gfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2RpdlxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuZnVuY3Rpb24gY2FtbF9kaXYoeCx5KSB7XG4gIGlmICh5ID09IDApIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHJldHVybiAoeC95KXwwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21vZFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuZnVuY3Rpb24gY2FtbF9tb2QoeCx5KSB7XG4gIGlmICh5ID09IDApIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHJldHVybiB4JXk7XG59XG5cbi8vLy8vLy8vLy8vLy8gUGVydmFzaXZlXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X3NldCAobXV0YWJsZSwgY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9hcnJheV9zZXQgKGFycmF5LCBpbmRleCwgbmV3dmFsKSB7XG4gIGlmICgoaW5kZXggPCAwKSB8fCAoaW5kZXggPj0gYXJyYXkubGVuZ3RoIC0gMSkpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgYXJyYXlbaW5kZXgrMV09bmV3dmFsOyByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9nZXQgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9hcnJheV9nZXQgKGFycmF5LCBpbmRleCkge1xuICBpZiAoKGluZGV4IDwgMCkgfHwgKGluZGV4ID49IGFycmF5Lmxlbmd0aCAtIDEpKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBhcnJheVtpbmRleCsxXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9maWxsXG5mdW5jdGlvbiBjYW1sX2FycmF5X2ZpbGwoYXJyYXksIG9mcywgbGVuLCB2KXtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICBhcnJheVtvZnMraSsxXSA9IHY7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY2hlY2tfYm91bmQgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfY2hlY2tfYm91bmQgKGFycmF5LCBpbmRleCkge1xuICBpZiAoaW5kZXggPj4+IDAgPj0gYXJyYXkubGVuZ3RoIC0gMSkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gYXJyYXk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFrZV92ZWN0IGNvbnN0IChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX21ha2VfdmVjdCAobGVuLCBpbml0KSB7XG4gIGlmIChsZW4gPCAwKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBsZW4gPSBsZW4gKyAxIHwgMDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobGVuKTtcbiAgYlswXT0wO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSBiW2ldID0gaW5pdDtcbiAgcmV0dXJuIGI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFrZV9mbG9hdF92ZWN0IGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfbWFrZV9mbG9hdF92ZWN0KGxlbil7XG4gIGlmIChsZW4gPCAwKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBsZW4gPSBsZW4gKyAxIHwgMDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobGVuKTtcbiAgYlswXT0yNTQ7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIGJbaV0gPSAwO1xuICByZXR1cm4gYlxufVxuLy9Qcm92aWRlczogY2FtbF9mbG9hdGFycmF5X2NyZWF0ZSBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlKGxlbil7XG4gIGlmIChsZW4gPCAwKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBsZW4gPSBsZW4gKyAxIHwgMDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobGVuKTtcbiAgYlswXT0yNTQ7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIGJbaV0gPSAwO1xuICByZXR1cm4gYlxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsX3RhZ1xuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbF90YWcoYSl7XG4gIGlmICh0eXBlb2YgYSA9PT0gXCJudW1iZXJcIikgcmV0dXJuIDEwMDA7IC8vIGludF90YWcgKHdlIHVzZSBpdCBmb3IgYWxsIG51bWJlcnMpXG4gIGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBNbEJ5dGVzKSByZXR1cm4gMjUyOyAvLyBzdHJpbmdfdGFnXG4gIGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBBcnJheSAmJiBhWzBdID09PSAoYVswXT4+PjApICYmIGFbMF0gPD0gMjU1KSB7XG4gICAgLy8gTG9vayBsaWtlIGFuIG9jYW1sIGJsb2NrXG4gICAgdmFyIHRhZyA9IGFbMF0gfCAwO1xuICAgIC8vIGlnbm9yZSBkb3VibGVfYXJyYXlfdGFnIGJlY2F1c2Ugd2UgY2Fubm90IGFjY3VyYXRlbHkgc2V0XG4gICAgLy8gdGhpcyB0YWcgd2hlbiB3ZSBjcmVhdGUgYW4gYXJyYXkgb2YgZmxvYXQuXG4gICAgcmV0dXJuICh0YWcgPT0gMjU0KT8wOnRhZ1xuICB9XG4gIGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBTdHJpbmcpIHJldHVybiAxMjUyOyAvLyBqYXZhc2NyaXB0IHN0cmluZywgbGlrZSBzdHJpbmdfdGFnICgyNTIpXG4gIGVsc2UgaWYgKHR5cGVvZiBhID09IFwic3RyaW5nXCIpIHJldHVybiAxMjUyOyAvLyBqYXZhc2NyaXB0IHN0cmluZywgbGlrZSBzdHJpbmdfdGFnICgyNTIpXG4gIGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBOdW1iZXIpIHJldHVybiAxMDAwOyAvLyBpbnRfdGFnICh3ZSB1c2UgaXQgZm9yIGFsbCBudW1iZXJzKVxuICBlbHNlIGlmIChhICYmIGEuY2FtbF9jdXN0b20pIHJldHVybiAxMjU1OyAvLyBsaWtlIGN1c3RvbV90YWcgKDI1NSlcbiAgZWxzZSBpZiAoYSAmJiBhLmNvbXBhcmUpIHJldHVybiAxMjU2OyAvLyBsaWtlIGN1c3RvbV90YWcgKDI1NSlcbiAgZWxzZSBpZiAodHlwZW9mIGEgPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gMTI0NzsgLy8gbGlrZSBjbG9zdXJlX3RhZyAoMjQ3KVxuICBlbHNlIGlmICh0eXBlb2YgYSA9PSBcInN5bWJvbFwiKSByZXR1cm4gMTI1MTtcbiAgcmV0dXJuIDEwMDE7IC8vb3V0X29mX2hlYXBfdGFnXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbVxuLy9SZXF1aXJlczogY2FtbF9jdXN0b21fb3BzXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20oYSl7XG4gIHJldHVybiBjYW1sX2N1c3RvbV9vcHNbYS5jYW1sX2N1c3RvbV0gJiYgY2FtbF9jdXN0b21fb3BzW2EuY2FtbF9jdXN0b21dLmNvbXBhcmU7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b20obnVtLCBjdXN0b20sIHN3YXAsIHRvdGFsKSB7XG4gIHZhciBjb21wID0gY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tKGN1c3RvbSk7XG4gIGlmKGNvbXApIHtcbiAgICB2YXIgeCA9IChzd2FwID4gMCk/Y29tcChjdXN0b20sbnVtLHRvdGFsKTpjb21wKG51bSxjdXN0b20sdG90YWwpO1xuICAgIGlmKHRvdGFsICYmIHggIT0geCkgcmV0dXJuIHN3YXA7IC8vIHRvdGFsICYmIG5hblxuICAgIGlmKCt4ICE9ICt4KSByZXR1cm4gK3g7IC8vIG5hblxuICAgIGlmKCh4IHwgMCkgIT0gMCkgcmV0dXJuICh4IHwgMCk7IC8vICFuYW5cbiAgfVxuICByZXR1cm4gc3dhcFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsIChjb25zdCwgY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9jb21wYXJlLCBjYW1sX2ludF9jb21wYXJlLCBjYW1sX3N0cmluZ19jb21wYXJlXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbSwgY2FtbF9jb21wYXJlX3ZhbF90YWdcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbVxuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbCAoYSwgYiwgdG90YWwpIHtcbiAgdmFyIHN0YWNrID0gW107XG4gIGZvcig7Oykge1xuICAgIGlmICghKHRvdGFsICYmIGEgPT09IGIpKSB7XG4gICAgICB2YXIgdGFnX2EgPSBjYW1sX2NvbXBhcmVfdmFsX3RhZyhhKTtcbiAgICAgIC8vIGZvcndhcmRfdGFnID9cbiAgICAgIGlmKHRhZ19hID09IDI1MCkgeyBhID0gYVsxXTsgY29udGludWUgfVxuXG4gICAgICB2YXIgdGFnX2IgPSBjYW1sX2NvbXBhcmVfdmFsX3RhZyhiKTtcbiAgICAgIC8vIGZvcndhcmRfdGFnID9cbiAgICAgIGlmKHRhZ19iID09IDI1MCkgeyBiID0gYlsxXTsgY29udGludWUgfVxuXG4gICAgICAvLyB0YWdzIGFyZSBkaWZmZXJlbnRcbiAgICAgIGlmKHRhZ19hICE9PSB0YWdfYikge1xuICAgICAgICBpZih0YWdfYSA9PSAxMDAwKSB7XG4gICAgICAgICAgaWYodGFnX2IgPT0gMTI1NSkgeyAvL2ltbWVkaWF0ZSBjYW4gY29tcGFyZSBhZ2FpbnN0IGN1c3RvbVxuICAgICAgICAgICAgcmV0dXJuIGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbShhLCBiLCAtMSwgdG90YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgfVxuICAgICAgICBpZih0YWdfYiA9PSAxMDAwKSB7XG4gICAgICAgICAgaWYodGFnX2EgPT0gMTI1NSkgeyAvL2ltbWVkaWF0ZSBjYW4gY29tcGFyZSBhZ2FpbnN0IGN1c3RvbVxuICAgICAgICAgICAgcmV0dXJuIGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbShiLCBhLCAxLCB0b3RhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAxXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0YWdfYSA8IHRhZ19iKT8tMToxO1xuICAgICAgfVxuICAgICAgc3dpdGNoKHRhZ19hKXtcbiAgICAgICAgLy8gMjQ2OiBMYXp5X3RhZyBoYW5kbGVkIGJlbGxvd1xuICAgICAgY2FzZSAyNDc6IC8vIENsb3N1cmVfdGFnXG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW5cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogZnVuY3Rpb25hbCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMjQ4OiAvLyBPYmplY3RcbiAgICAgICAgdmFyIHggPSBjYW1sX2ludF9jb21wYXJlKGFbMl0sIGJbMl0pO1xuICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI0OTogLy8gSW5maXhcbiAgICAgICAgLy8gQ2Fubm90IGhhcHBlblxuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjb21wYXJlOiBmdW5jdGlvbmFsIHZhbHVlXCIpO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAyNTA6IC8vIEZvcndhcmQgdGFnXG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW4sIGhhbmRsZWQgYWJvdmVcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGdvdCBGb3J3YXJkX3RhZywgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTE6IC8vQWJzdHJhY3RcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGFic3RyYWN0IHZhbHVlXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUyOiAvLyBPQ2FtbCBzdHJpbmdcbiAgICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgICB2YXIgeCA9IGNhbWxfc3RyaW5nX2NvbXBhcmUoYSwgYik7XG4gICAgICAgICAgaWYgKHggIT0gMCkgcmV0dXJuICh4IHwgMCk7XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTM6IC8vIERvdWJsZV90YWdcbiAgICAgICAgLy8gQ2Fubm90IGhhcHBlblxuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJlcXVhbDogZ290IERvdWJsZV90YWcsIHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjU0OiAvLyBEb3VibGVfYXJyYXlfdGFnXG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW4sIGhhbmRsZWQgYWJvdmVcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGdvdCBEb3VibGVfYXJyYXlfdGFnLCBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMjU1OiAvLyBJbnQ2NFxuICAgICAgICAvLyBJbnQ2NCBpcyB0aGUgb25seSBjdXN0b20gYmxvY2sgaW1wbGVtZW50ZWQgdGhpcyB3YXksXG4gICAgICAgIC8vIFRPRE86IFdlIHNob3VsZCByZXdyaXRlIHRoZSBpbXBsZW1lbnRhdGlvbiBhbmQgZm9sbG93XG4gICAgICAgIC8vIHdoYXQgd2UgZG8gZm9yIG90aGVyIGN1c3RvbSBibG9ja3M6IHphcml0aCwgYmlnaW50LCBiaWdhcnJheSwgLi4uXG4gICAgICAgIHZhciB4ID0gY2FtbF9pbnQ2NF9jb21wYXJlKGEsIGIpO1xuICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNDc6IC8vIEZ1bmN0aW9uXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGZ1bmN0aW9uYWwgdmFsdWVcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjU1OiAvLyBDdXN0b21cbiAgICAgICAgdmFyIGNvbXAgPSBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20oYSk7XG4gICAgICAgIGlmKGNvbXAgIT0gY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tKGIpKXtcbiAgICAgICAgICByZXR1cm4gKGEuY2FtbF9jdXN0b208Yi5jYW1sX2N1c3RvbSk/LTE6MTtcbiAgICAgICAgfVxuICAgICAgICBpZighY29tcClcbiAgICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjb21wYXJlOiBhYnN0cmFjdCB2YWx1ZVwiKTtcbiAgICAgICAgdmFyIHggPSBjb21wKGEsYix0b3RhbCk7XG4gICAgICAgIGlmKHggIT0geCl7IC8vIFByb3RlY3QgYWdhaW5zdCBpbnZhbGlkIFVOT1JERVJFRFxuICAgICAgICAgIHJldHVybiB0b3RhbD8tMTp4O1xuICAgICAgICB9XG4gICAgICAgIGlmKHggIT09ICh4fDApKXsgLy8gUHJvdGVjdCBhZ2FpbnN0IGludmFsaWQgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgcmV0dXJuIC0xXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHggIT0gMCkgcmV0dXJuICh4IHwgMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjU2OiAvLyBjb21wYXJlIGZ1bmN0aW9uXG4gICAgICAgIHZhciB4ID0gYS5jb21wYXJlKGIsdG90YWwpO1xuICAgICAgICBpZih4ICE9IHgpIHsgLy8gUHJvdGVjdCBhZ2FpbnN0IGludmFsaWQgVU5PUkRFUkVEXG4gICAgICAgICAgcmV0dXJuIHRvdGFsPy0xOng7XG4gICAgICAgIH1cbiAgICAgICAgaWYoeCAhPT0gKHh8MCkpeyAvLyBQcm90ZWN0IGFnYWluc3QgaW52YWxpZCByZXR1cm4gdmFsdWVcbiAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEwMDA6IC8vIE51bWJlclxuICAgICAgICBhID0gK2E7XG4gICAgICAgIGIgPSArYjtcbiAgICAgICAgaWYgKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhICE9IGIpIHtcbiAgICAgICAgICBpZiAoIXRvdGFsKSByZXR1cm4gTmFOO1xuICAgICAgICAgIGlmIChhID09IGEpIHJldHVybiAxO1xuICAgICAgICAgIGlmIChiID09IGIpIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTAwMTogLy8gVGhlIHJlc3RcbiAgICAgICAgLy8gSGVyZSB3ZSBjYW4gYmUgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcbiAgICAgICAgLy8gMS4gSmF2YVNjcmlwdCBwcmltaXRpdmUgdHlwZXNcbiAgICAgICAgLy8gMi4gSmF2YVNjcmlwdCBvYmplY3QgdGhhdCBjYW4gYmUgY29lcmNlZCB0byBwcmltaXRpdmUgdHlwZXNcbiAgICAgICAgLy8gMy4gSmF2YVNjcmlwdCBvYmplY3QgdGhhbiBjYW5ub3QgYmUgY29lcmNlZCB0byBwcmltaXRpdmUgdHlwZXNcbiAgICAgICAgLy9cbiAgICAgICAgLy8gKDMpIHdpbGwgcmFpc2UgYSBbVHlwZUVycm9yXVxuICAgICAgICAvLyAoMikgd2lsbCBjb2VyY2UgdG8gcHJpbWl0aXZlIHR5cGVzIHVzaW5nIFt2YWx1ZU9mXSBvciBbdG9TdHJpbmddXG4gICAgICAgIC8vICgyKSBhbmQgKDMpLCBhZnRlciBldmVudHVhbCBjb2VyY2lvblxuICAgICAgICAvLyAtIGlmIGEgYW5kIGIgYXJlIHN0cmluZ3MsIGFwcGx5IGxleGljb2dyYXBoaWMgY29tcGFyaXNvblxuICAgICAgICAvLyAtIGlmIGEgb3IgYiBhcmUgbm90IHN0cmluZ3MsIGNvbnZlcnQgYSBhbmQgYiB0byBudW1iZXJcbiAgICAgICAgLy8gICBhbmQgYXBwbHkgc3RhbmRhcmQgY29tcGFyaXNvblxuICAgICAgICAvL1xuICAgICAgICAvLyBFeGNlcHRpb246IGAhPWAgd2lsbCBub3QgY29lcmNlL2NvbnZlcnQgaWYgYm90aCBhIGFuZCBiIGFyZSBvYmplY3RzXG4gICAgICAgIGlmIChhIDwgYikgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoYSA+IGIpIHJldHVybiAxO1xuICAgICAgICBpZiAoYSAhPSBiKSB7XG4gICAgICAgICAgaWYgKCF0b3RhbCkgcmV0dXJuIE5hTjtcbiAgICAgICAgICBpZiAoYSA9PSBhKSByZXR1cm4gMTtcbiAgICAgICAgICBpZiAoYiA9PSBiKSByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTE6IC8vIEphdmFTY3JpcHQgU3ltYm9sLCBubyBvcmRlcmluZy5cbiAgICAgICAgaWYoYSAhPT0gYikge1xuICAgICAgICAgIGlmICghdG90YWwpIHJldHVybiBOYU47XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTI6IC8vIGphdmFzY3JpcHQgc3RyaW5nc1xuICAgICAgICB2YXIgYSA9IGEudG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIGIgPSBiLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmKGEgIT09IGIpIHtcbiAgICAgICAgICBpZihhIDwgYikgcmV0dXJuIC0xO1xuICAgICAgICAgIGlmKGEgPiBiKSByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjQ2OiAvLyBMYXp5X3RhZ1xuICAgICAgY2FzZSAyNTQ6IC8vIERvdWJsZV9hcnJheVxuICAgICAgZGVmYXVsdDogLy8gQmxvY2sgd2l0aCBvdGhlciB0YWdcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gKGEubGVuZ3RoIDwgYi5sZW5ndGgpPy0xOjE7XG4gICAgICAgIGlmIChhLmxlbmd0aCA+IDEpIHN0YWNrLnB1c2goYSwgYiwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhY2subGVuZ3RoID09IDApIHJldHVybiAwO1xuICAgIHZhciBpID0gc3RhY2sucG9wKCk7XG4gICAgYiA9IHN0YWNrLnBvcCgpO1xuICAgIGEgPSBzdGFjay5wb3AoKTtcbiAgICBpZiAoaSArIDEgPCBhLmxlbmd0aCkgc3RhY2sucHVzaChhLCBiLCBpICsgMSk7XG4gICAgYSA9IGFbaV07XG4gICAgYiA9IGJbaV07XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9jb21wYXJlIChhLCBiKSB7IHJldHVybiBjYW1sX2NvbXBhcmVfdmFsIChhLCBiLCB0cnVlKTsgfVxuLy9Qcm92aWRlczogY2FtbF9pbnRfY29tcGFyZSBtdXRhYmxlIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2ludF9jb21wYXJlIChhLCBiKSB7XG4gIGlmIChhIDwgYikgcmV0dXJuICgtMSk7IGlmIChhID09IGIpIHJldHVybiAwOyByZXR1cm4gMTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9lcXVhbCAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPT0gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbm90ZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9ub3RlcXVhbCAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgIT0gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JlYXRlcmVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfZ3JlYXRlcmVxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA+PSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9ncmVhdGVydGhhbiBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2dyZWF0ZXJ0aGFuICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA+IDApOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2xlc3NlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2xlc3NlcXVhbCAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPD0gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbGVzc3RoYW4gbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9sZXNzdGhhbiAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPCAwKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2Vcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlIChzKSB7XG4gIHZhciBpID0gMCwgbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpLCBiYXNlID0gMTAsIHNpZ24gPSAxO1xuICBpZiAobGVuID4gMCkge1xuICAgIHN3aXRjaCAoY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLGkpKSB7XG4gICAgY2FzZSA0NTogaSsrOyBzaWduID0gLTE7IGJyZWFrO1xuICAgIGNhc2UgNDM6IGkrKzsgc2lnbiA9IDE7IGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoaSArIDEgPCBsZW4gJiYgY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKSA9PSA0OClcbiAgICBzd2l0Y2ggKGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSArIDEpKSB7XG4gICAgY2FzZSAxMjA6IGNhc2UgODg6IGJhc2UgPSAxNjsgaSArPSAyOyBicmVhaztcbiAgICBjYXNlIDExMTogY2FzZSA3OTogYmFzZSA9ICA4OyBpICs9IDI7IGJyZWFrO1xuICAgIGNhc2UgIDk4OiBjYXNlIDY2OiBiYXNlID0gIDI7IGkgKz0gMjsgYnJlYWs7XG4gICAgY2FzZSAxMTc6IGNhc2UgODU6IHNpZ24gPSAgMDsgaSArPSAyOyBicmVhaztcbiAgICB9XG4gIHJldHVybiBbaSwgc2lnbiwgYmFzZV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcGFyc2VfZGlnaXRcbmZ1bmN0aW9uIGNhbWxfcGFyc2VfZGlnaXQoYykge1xuICBpZiAoYyA+PSA0OCAmJiBjIDw9IDU3KSAgcmV0dXJuIGMgLSA0ODtcbiAgaWYgKGMgPj0gNjUgJiYgYyA8PSA5MCkgIHJldHVybiBjIC0gNTU7XG4gIGlmIChjID49IDk3ICYmIGMgPD0gMTIyKSByZXR1cm4gYyAtIDg3O1xuICByZXR1cm4gLTE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50X29mX3N0cmluZyAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSwgY2FtbF9wYXJzZV9kaWdpdCwgY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9pbnRfb2Zfc3RyaW5nIChzKSB7XG4gIHZhciByID0gY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlIChzKTtcbiAgdmFyIGkgPSByWzBdLCBzaWduID0gclsxXSwgYmFzZSA9IHJbMl07XG4gIHZhciBsZW4gPSBjYW1sX21sX3N0cmluZ19sZW5ndGgocyk7XG4gIHZhciB0aHJlc2hvbGQgPSAtMSA+Pj4gMDtcbiAgdmFyIGMgPSAoaSA8IGxlbik/Y2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTowO1xuICB2YXIgZCA9IGNhbWxfcGFyc2VfZGlnaXQoYyk7XG4gIGlmIChkIDwgMCB8fCBkID49IGJhc2UpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICB2YXIgcmVzID0gZDtcbiAgZm9yIChpKys7aTxsZW47aSsrKSB7XG4gICAgYyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSk7XG4gICAgaWYgKGMgPT0gOTUpIGNvbnRpbnVlO1xuICAgIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICAgIGlmIChkIDwgMCB8fCBkID49IGJhc2UpIGJyZWFrO1xuICAgIHJlcyA9IGJhc2UgKiByZXMgKyBkO1xuICAgIGlmIChyZXMgPiB0aHJlc2hvbGQpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICB9XG4gIGlmIChpICE9IGxlbikgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIC8vIEZvciBiYXNlIGRpZmZlcmVudCBmcm9tIDEwLCB3ZSBleHBlY3QgYW4gdW5zaWduZWQgcmVwcmVzZW50YXRpb24sXG4gIC8vIGhlbmNlIGFueSB2YWx1ZSBvZiAncmVzJyAobGVzcyB0aGFuICd0aHJlc2hvbGQnKSBpcyBhY2NlcHRhYmxlLlxuICAvLyBCdXQgd2UgaGF2ZSB0byBjb252ZXJ0IHRoZSByZXN1bHQgYmFjayB0byBhIHNpZ25lZCBpbnRlZ2VyLlxuICByZXMgPSBzaWduICogcmVzO1xuICBpZiAoKGJhc2UgPT0gMTApICYmICgocmVzIHwgMCkgIT0gcmVzKSlcbiAgICAvKiBTaWduZWQgcmVwcmVzZW50YXRpb24gZXhwZWN0ZWQsIGFsbG93IC0yXihuYml0cy0xKSB0byAyXihuYml0cy0xKSAtIDEgKi9cbiAgICBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgcmV0dXJuIHJlcyB8IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRfb2Zfc3RyaW5nIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZmxvYXRfb2Zfc3RyaW5nKHMpIHtcbiAgdmFyIHJlcztcbiAgcyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcgKHMpO1xuICByZXMgPSArcztcbiAgaWYgKChzLmxlbmd0aCA+IDApICYmIChyZXMgPT09IHJlcykpIHJldHVybiByZXM7XG4gIHMgPSBzLnJlcGxhY2UoL18vZyxcIlwiKTtcbiAgcmVzID0gK3M7XG4gIGlmICgoKHMubGVuZ3RoID4gMCkgJiYgKHJlcyA9PT0gcmVzKSkgfHwgL15bKy1dP25hbiQvaS50ZXN0KHMpKSByZXR1cm4gcmVzO1xuICB2YXIgbSA9IC9eICooWystXT8pMHgoWzAtOWEtZl0rKVxcLj8oWzAtOWEtZl0qKXAoWystXT9bMC05XSspL2kuZXhlYyhzKTtcbiAgLy8gICAgICAgICAgMSAgICAgICAgMiAgICAgICAgICAgICAzICAgICAgICAgICA0XG4gIGlmKG0pe1xuICAgIHZhciBtMyA9IG1bM10ucmVwbGFjZSgvMCskLywnJyk7XG4gICAgdmFyIG1hbnRpc3NhID0gcGFyc2VJbnQobVsxXSArIG1bMl0gKyBtMywgMTYpO1xuICAgIHZhciBleHBvbmVudCA9IChtWzRdfDApIC0gNCptMy5sZW5ndGg7XG4gICAgcmVzID0gbWFudGlzc2EgKiBNYXRoLnBvdygyLCBleHBvbmVudCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBpZigvXlxcKz9pbmYoaW5pdHkpPyQvaS50ZXN0KHMpKSByZXR1cm4gSW5maW5pdHk7XG4gIGlmKC9eLWluZihpbml0eSk/JC9pLnRlc3QocykpIHJldHVybiAtSW5maW5pdHk7XG4gIGNhbWxfZmFpbHdpdGgoXCJmbG9hdF9vZl9zdHJpbmdcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfcHJpbnRhYmxlIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfaXNfcHJpbnRhYmxlKGMpIHsgcmV0dXJuICsoYyA+IDMxICYmIGMgPCAxMjcpOyB9XG5cbi8vLy8vLy8vLy8vLy8gRm9ybWF0XG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX2Zvcm1hdFxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZywgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3BhcnNlX2Zvcm1hdCAoZm10KSB7XG4gIGZtdCA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoZm10KTtcbiAgdmFyIGxlbiA9IGZtdC5sZW5ndGg7XG4gIGlmIChsZW4gPiAzMSkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZm9ybWF0X2ludDogZm9ybWF0IHRvbyBsb25nXCIpO1xuICB2YXIgZiA9XG4gICAgICB7IGp1c3RpZnk6JysnLCBzaWduc3R5bGU6Jy0nLCBmaWxsZXI6JyAnLCBhbHRlcm5hdGU6ZmFsc2UsXG4gICAgICAgIGJhc2U6MCwgc2lnbmVkY29udjpmYWxzZSwgd2lkdGg6MCwgdXBwZXJjYXNlOmZhbHNlLFxuICAgICAgICBzaWduOjEsIHByZWM6LTEsIGNvbnY6J2YnIH07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgYyA9IGZtdC5jaGFyQXQoaSk7XG4gICAgc3dpdGNoIChjKSB7XG4gICAgY2FzZSAnLSc6XG4gICAgICBmLmp1c3RpZnkgPSAnLSc7IGJyZWFrO1xuICAgIGNhc2UgJysnOiBjYXNlICcgJzpcbiAgICAgIGYuc2lnbnN0eWxlID0gYzsgYnJlYWs7XG4gICAgY2FzZSAnMCc6XG4gICAgICBmLmZpbGxlciA9ICcwJzsgYnJlYWs7XG4gICAgY2FzZSAnIyc6XG4gICAgICBmLmFsdGVybmF0ZSA9IHRydWU7IGJyZWFrO1xuICAgIGNhc2UgJzEnOiBjYXNlICcyJzogY2FzZSAnMyc6IGNhc2UgJzQnOiBjYXNlICc1JzpcbiAgICBjYXNlICc2JzogY2FzZSAnNyc6IGNhc2UgJzgnOiBjYXNlICc5JzpcbiAgICAgIGYud2lkdGggPSAwO1xuICAgICAgd2hpbGUgKGM9Zm10LmNoYXJDb2RlQXQoaSkgLSA0OCwgYyA+PSAwICYmIGMgPD0gOSkge1xuICAgICAgICBmLndpZHRoID0gZi53aWR0aCAqIDEwICsgYzsgaSsrXG4gICAgICB9XG4gICAgICBpLS07XG4gICAgICBicmVhaztcbiAgICBjYXNlICcuJzpcbiAgICAgIGYucHJlYyA9IDA7XG4gICAgICBpKys7XG4gICAgICB3aGlsZSAoYz1mbXQuY2hhckNvZGVBdChpKSAtIDQ4LCBjID49IDAgJiYgYyA8PSA5KSB7XG4gICAgICAgIGYucHJlYyA9IGYucHJlYyAqIDEwICsgYzsgaSsrXG4gICAgICB9XG4gICAgICBpLS07XG4gICAgY2FzZSAnZCc6IGNhc2UgJ2knOlxuICAgICAgZi5zaWduZWRjb252ID0gdHJ1ZTsgLyogZmFsbHRocm91Z2ggKi9cbiAgICBjYXNlICd1JzpcbiAgICAgIGYuYmFzZSA9IDEwOyBicmVhaztcbiAgICBjYXNlICd4JzpcbiAgICAgIGYuYmFzZSA9IDE2OyBicmVhaztcbiAgICBjYXNlICdYJzpcbiAgICAgIGYuYmFzZSA9IDE2OyBmLnVwcGVyY2FzZSA9IHRydWU7IGJyZWFrO1xuICAgIGNhc2UgJ28nOlxuICAgICAgZi5iYXNlID0gODsgYnJlYWs7XG4gICAgY2FzZSAnZSc6IGNhc2UgJ2YnOiBjYXNlICdnJzpcbiAgICAgIGYuc2lnbmVkY29udiA9IHRydWU7IGYuY29udiA9IGM7IGJyZWFrO1xuICAgIGNhc2UgJ0UnOiBjYXNlICdGJzogY2FzZSAnRyc6XG4gICAgICBmLnNpZ25lZGNvbnYgPSB0cnVlOyBmLnVwcGVyY2FzZSA9IHRydWU7XG4gICAgICBmLmNvbnYgPSBjLnRvTG93ZXJDYXNlICgpOyBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGY7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmluaXNoX2Zvcm1hdHRpbmdcbi8vUmVxdWlyZXM6IGNhbWxfbmV3X3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCByYXdidWZmZXIpIHtcbiAgaWYgKGYudXBwZXJjYXNlKSByYXdidWZmZXIgPSByYXdidWZmZXIudG9VcHBlckNhc2UoKTtcbiAgdmFyIGxlbiA9IHJhd2J1ZmZlci5sZW5ndGg7XG4gIC8qIEFkanVzdCBsZW4gdG8gcmVmbGVjdCBhZGRpdGlvbmFsIGNoYXJzIChzaWduLCBldGMpICovXG4gIGlmIChmLnNpZ25lZGNvbnYgJiYgKGYuc2lnbiA8IDAgfHwgZi5zaWduc3R5bGUgIT0gJy0nKSkgbGVuKys7XG4gIGlmIChmLmFsdGVybmF0ZSkge1xuICAgIGlmIChmLmJhc2UgPT0gOCkgbGVuICs9IDE7XG4gICAgaWYgKGYuYmFzZSA9PSAxNikgbGVuICs9IDI7XG4gIH1cbiAgLyogRG8gdGhlIGZvcm1hdHRpbmcgKi9cbiAgdmFyIGJ1ZmZlciA9IFwiXCI7XG4gIGlmIChmLmp1c3RpZnkgPT0gJysnICYmIGYuZmlsbGVyID09ICcgJylcbiAgICBmb3IgKHZhciBpID0gbGVuOyBpIDwgZi53aWR0aDsgaSsrKSBidWZmZXIgKz0gJyAnO1xuICBpZiAoZi5zaWduZWRjb252KSB7XG4gICAgaWYgKGYuc2lnbiA8IDApIGJ1ZmZlciArPSAnLSc7XG4gICAgZWxzZSBpZiAoZi5zaWduc3R5bGUgIT0gJy0nKSBidWZmZXIgKz0gZi5zaWduc3R5bGU7XG4gIH1cbiAgaWYgKGYuYWx0ZXJuYXRlICYmIGYuYmFzZSA9PSA4KSBidWZmZXIgKz0gJzAnO1xuICBpZiAoZi5hbHRlcm5hdGUgJiYgZi5iYXNlID09IDE2KSBidWZmZXIgKz0gXCIweFwiO1xuICBpZiAoZi5qdXN0aWZ5ID09ICcrJyAmJiBmLmZpbGxlciA9PSAnMCcpXG4gICAgZm9yICh2YXIgaSA9IGxlbjsgaSA8IGYud2lkdGg7IGkrKykgYnVmZmVyICs9ICcwJztcbiAgYnVmZmVyICs9IHJhd2J1ZmZlcjtcbiAgaWYgKGYuanVzdGlmeSA9PSAnLScpXG4gICAgZm9yICh2YXIgaSA9IGxlbjsgaSA8IGYud2lkdGg7IGkrKykgYnVmZmVyICs9ICcgJztcbiAgcmV0dXJuIGNhbWxfbmV3X3N0cmluZyAoYnVmZmVyKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mb3JtYXRfaW50IGNvbnN0IChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX2Zvcm1hdCwgY2FtbF9maW5pc2hfZm9ybWF0dGluZywgY2FtbF9zdHJfcmVwZWF0XG4vL1JlcXVpcmVzOiBjYW1sX25ld19zdHJpbmcsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZm9ybWF0X2ludChmbXQsIGkpIHtcbiAgaWYgKGNhbWxfanNieXRlc19vZl9zdHJpbmcoZm10KSA9PSBcIiVkXCIpIHJldHVybiBjYW1sX25ld19zdHJpbmcoXCJcIitpKTtcbiAgdmFyIGYgPSBjYW1sX3BhcnNlX2Zvcm1hdChmbXQpO1xuICBpZiAoaSA8IDApIHsgaWYgKGYuc2lnbmVkY29udikgeyBmLnNpZ24gPSAtMTsgaSA9IC1pOyB9IGVsc2UgaSA+Pj49IDA7IH1cbiAgdmFyIHMgPSBpLnRvU3RyaW5nKGYuYmFzZSk7XG4gIGlmIChmLnByZWMgPj0gMCkge1xuICAgIGYuZmlsbGVyID0gJyAnO1xuICAgIHZhciBuID0gZi5wcmVjIC0gcy5sZW5ndGg7XG4gICAgaWYgKG4gPiAwKSBzID0gY2FtbF9zdHJfcmVwZWF0IChuLCAnMCcpICsgcztcbiAgfVxuICByZXR1cm4gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCBzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mb3JtYXRfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2VfZm9ybWF0LCBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nXG5mdW5jdGlvbiBjYW1sX2Zvcm1hdF9mbG9hdCAoZm10LCB4KSB7XG4gIGZ1bmN0aW9uIHRvRml4ZWQoeCxkcCkge1xuICAgIGlmIChNYXRoLmFicyh4KSA8IDEuMCkge1xuICAgICAgcmV0dXJuIHgudG9GaXhlZChkcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlID0gcGFyc2VJbnQoeC50b1N0cmluZygpLnNwbGl0KCcrJylbMV0pO1xuICAgICAgaWYgKGUgPiAyMCkge1xuICAgICAgICBlIC09IDIwO1xuICAgICAgICB4IC89IE1hdGgucG93KDEwLGUpO1xuICAgICAgICB4ICs9IChuZXcgQXJyYXkoZSsxKSkuam9pbignMCcpO1xuICAgICAgICBpZihkcCA+IDApIHtcbiAgICAgICAgICB4ID0geCArICcuJyArIChuZXcgQXJyYXkoZHArMSkpLmpvaW4oJzAnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICAgIH1cbiAgICAgIGVsc2UgcmV0dXJuIHgudG9GaXhlZChkcClcbiAgICB9XG4gIH1cbiAgdmFyIHMsIGYgPSBjYW1sX3BhcnNlX2Zvcm1hdChmbXQpO1xuICB2YXIgcHJlYyA9IChmLnByZWMgPCAwKT82OmYucHJlYztcbiAgaWYgKHggPCAwIHx8ICh4ID09IDAgJiYgMS94ID09IC1JbmZpbml0eSkpIHsgZi5zaWduID0gLTE7IHggPSAteDsgfVxuICBpZiAoaXNOYU4oeCkpIHsgcyA9IFwibmFuXCI7IGYuZmlsbGVyID0gJyAnOyB9XG4gIGVsc2UgaWYgKCFpc0Zpbml0ZSh4KSkgeyBzID0gXCJpbmZcIjsgZi5maWxsZXIgPSAnICc7IH1cbiAgZWxzZVxuICAgIHN3aXRjaCAoZi5jb252KSB7XG4gICAgY2FzZSAnZSc6XG4gICAgICB2YXIgcyA9IHgudG9FeHBvbmVudGlhbChwcmVjKTtcbiAgICAgIC8vIGV4cG9uZW50IHNob3VsZCBiZSBhdCBsZWFzdCB0d28gZGlnaXRzXG4gICAgICB2YXIgaSA9IHMubGVuZ3RoO1xuICAgICAgaWYgKHMuY2hhckF0KGkgLSAzKSA9PSAnZScpXG4gICAgICAgIHMgPSBzLnNsaWNlICgwLCBpIC0gMSkgKyAnMCcgKyBzLnNsaWNlIChpIC0gMSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdmJzpcbiAgICAgIHMgPSB0b0ZpeGVkKHgsIHByZWMpOyBicmVhaztcbiAgICBjYXNlICdnJzpcbiAgICAgIHByZWMgPSBwcmVjP3ByZWM6MTtcbiAgICAgIHMgPSB4LnRvRXhwb25lbnRpYWwocHJlYyAtIDEpO1xuICAgICAgdmFyIGogPSBzLmluZGV4T2YoJ2UnKTtcbiAgICAgIHZhciBleHAgPSArcy5zbGljZShqICsgMSk7XG4gICAgICBpZiAoZXhwIDwgLTQgfHwgeCA+PSAxZTIxIHx8IHgudG9GaXhlZCgwKS5sZW5ndGggPiBwcmVjKSB7XG4gICAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB6ZXJvZXNcbiAgICAgICAgdmFyIGkgPSBqIC0gMTsgd2hpbGUgKHMuY2hhckF0KGkpID09ICcwJykgaS0tO1xuICAgICAgICBpZiAocy5jaGFyQXQoaSkgPT0gJy4nKSBpLS07XG4gICAgICAgIHMgPSBzLnNsaWNlKDAsIGkgKyAxKSArIHMuc2xpY2Uoaik7XG4gICAgICAgIGkgPSBzLmxlbmd0aDtcbiAgICAgICAgaWYgKHMuY2hhckF0KGkgLSAzKSA9PSAnZScpXG4gICAgICAgICAgcyA9IHMuc2xpY2UgKDAsIGkgLSAxKSArICcwJyArIHMuc2xpY2UgKGkgLSAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcCA9IHByZWM7XG4gICAgICAgIGlmIChleHAgPCAwKSB7IHAgLT0gZXhwICsgMTsgcyA9IHgudG9GaXhlZChwKTsgfVxuICAgICAgICBlbHNlIHdoaWxlIChzID0geC50b0ZpeGVkKHApLCBzLmxlbmd0aCA+IHByZWMgKyAxKSBwLS07XG4gICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHplcm9lc1xuICAgICAgICAgIHZhciBpID0gcy5sZW5ndGggLSAxOyB3aGlsZSAocy5jaGFyQXQoaSkgPT0gJzAnKSBpLS07XG4gICAgICAgICAgaWYgKHMuY2hhckF0KGkpID09ICcuJykgaS0tO1xuICAgICAgICAgIHMgPSBzLnNsaWNlKDAsIGkgKyAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICByZXR1cm4gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCBzKTtcbn1cblxuLy8vLy8vLy8vLy8vLyBIYXNodGJsXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfdW5pdl9wYXJhbSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBNbEJ5dGVzLCBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzLCBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQsIGNhbWxfY3VzdG9tX29wc1xuZnVuY3Rpb24gY2FtbF9oYXNoX3VuaXZfcGFyYW0gKGNvdW50LCBsaW1pdCwgb2JqKSB7XG4gIHZhciBoYXNoX2FjY3UgPSAwO1xuICBmdW5jdGlvbiBoYXNoX2F1eCAob2JqKSB7XG4gICAgbGltaXQgLS07XG4gICAgaWYgKGNvdW50IDwgMCB8fCBsaW1pdCA8IDApIHJldHVybjtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgQXJyYXkgJiYgb2JqWzBdID09PSAob2JqWzBdfDApKSB7XG4gICAgICBzd2l0Y2ggKG9ialswXSkge1xuICAgICAgY2FzZSAyNDg6XG4gICAgICAgIC8vIE9iamVjdFxuICAgICAgICBjb3VudCAtLTtcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDY1NTk5ICsgb2JqWzJdKSB8IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTA6XG4gICAgICAgIC8vIEZvcndhcmRcbiAgICAgICAgbGltaXQrKzsgaGFzaF9hdXgob2JqKTsgYnJlYWs7XG4gICAgICBjYXNlIDI1NTpcbiAgICAgICAgLy8gSW50NjRcbiAgICAgICAgY291bnQgLS07XG4gICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiA2NTU5OSArIG9ialsxXSArIChvYmpbMl0gPDwgMjQpKSB8IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY291bnQgLS07XG4gICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIG9ialswXSkgfCAwO1xuICAgICAgICBmb3IgKHZhciBpID0gb2JqLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIGhhc2hfYXV4IChvYmpbaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTWxCeXRlcykge1xuICAgICAgY291bnQgLS07XG4gICAgICBzd2l0Y2ggKG9iai50ICYgNikge1xuICAgICAgZGVmYXVsdDogLyogUEFSVElBTCAqL1xuICAgICAgICBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKG9iaik7XG4gICAgICBjYXNlIDA6IC8qIEJZVEVTICovXG4gICAgICAgIGZvciAodmFyIGIgPSBvYmouYywgbCA9IG9iai5sLCBpID0gMDsgaSA8IGw7IGkrKylcbiAgICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBiLmNoYXJDb2RlQXQoaSkpIHwgMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6IC8qIEFSUkFZICovXG4gICAgICAgIGZvciAodmFyIGEgPSBvYmouYywgbCA9IG9iai5sLCBpID0gMDsgaSA8IGw7IGkrKylcbiAgICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBhW2ldKSB8IDA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvYmogPT09IChvYmp8MCkpIHtcbiAgICAgIC8vIEludGVnZXJcbiAgICAgIGNvdW50IC0tO1xuICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDY1NTk5ICsgb2JqKSB8IDA7XG4gICAgfSBlbHNlIGlmIChvYmogPT09ICtvYmopIHtcbiAgICAgIC8vIEZsb2F0XG4gICAgICBjb3VudC0tO1xuICAgICAgdmFyIHAgPSBjYW1sX2ludDY0X3RvX2J5dGVzIChjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQgKG9iaikpO1xuICAgICAgZm9yICh2YXIgaSA9IDc7IGkgPj0gMDsgaS0tKSBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBwW2ldKSB8IDA7XG4gICAgfSBlbHNlIGlmKG9iaiAmJiBvYmouY2FtbF9jdXN0b20pIHtcbiAgICAgIGlmKGNhbWxfY3VzdG9tX29wc1tvYmouY2FtbF9jdXN0b21dICYmIGNhbWxfY3VzdG9tX29wc1tvYmouY2FtbF9jdXN0b21dLmhhc2gpIHtcbiAgICAgICAgdmFyIGggPSBjYW1sX2N1c3RvbV9vcHNbb2JqLmNhbWxfY3VzdG9tXS5oYXNoKG9iaikgfCAwO1xuICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogNjU1OTkgKyBoKSB8IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGhhc2hfYXV4IChvYmopO1xuICByZXR1cm4gaGFzaF9hY2N1ICYgMHgzRkZGRkZGRjtcbn1cblxuLy9mdW5jdGlvbiBST1RMMzIoeCxuKSB7IHJldHVybiAoKHggPDwgbikgfCAoeCA+Pj4gKDMyLW4pKSk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfaW50XG4vL1JlcXVpcmVzOiBjYW1sX211bFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9pbnQoaCxkKSB7XG4gIGQgPSBjYW1sX211bChkLCAweGNjOWUyZDUxfDApO1xuICBkID0gKChkIDw8IDE1KSB8IChkID4+PiAoMzItMTUpKSk7IC8vIFJPVEwzMihkLCAxNSk7XG4gIGQgPSBjYW1sX211bChkLCAweDFiODczNTkzKTtcbiAgaCBePSBkO1xuICBoID0gKChoIDw8IDEzKSB8IChoID4+PiAoMzItMTMpKSk7ICAgLy9ST1RMMzIoaCwgMTMpO1xuICByZXR1cm4gKCgoaCArIChoIDw8IDIpKXwwKSArICgweGU2NTQ2YjY0fDApKXwwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2ZpbmFsXG4vL1JlcXVpcmVzOiBjYW1sX211bFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9maW5hbChoKSB7XG4gIGggXj0gaCA+Pj4gMTY7XG4gIGggPSBjYW1sX211bCAoaCwgMHg4NWViY2E2YnwwKTtcbiAgaCBePSBoID4+PiAxMztcbiAgaCA9IGNhbWxfbXVsIChoLCAweGMyYjJhZTM1fDApO1xuICBoIF49IGggPj4+IDE2O1xuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9mbG9hdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2hhc2hfbWl4X2ludDY0XG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2Zsb2F0IChoLCB2MCkge1xuICByZXR1cm4gY2FtbF9oYXNoX21peF9pbnQ2NChoLCBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQgKHYwKSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2ludDY0XG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9sbzMyLCBjYW1sX2ludDY0X2hpMzJcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfaW50NjQgKGgsIHYpIHtcbiAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGNhbWxfaW50NjRfbG8zMih2KSk7XG4gIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBjYW1sX2ludDY0X2hpMzIodikpO1xuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9zdHJpbmdfc3RyXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9zdHJpbmdfc3RyKGgsIHMpIHtcbiAgdmFyIGxlbiA9IHMubGVuZ3RoLCBpLCB3O1xuICBmb3IgKGkgPSAwOyBpICsgNCA8PSBsZW47IGkgKz0gNCkge1xuICAgIHcgPSBzLmNoYXJDb2RlQXQoaSlcbiAgICAgIHwgKHMuY2hhckNvZGVBdChpKzEpIDw8IDgpXG4gICAgICB8IChzLmNoYXJDb2RlQXQoaSsyKSA8PCAxNilcbiAgICAgIHwgKHMuY2hhckNvZGVBdChpKzMpIDw8IDI0KTtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gIH1cbiAgdyA9IDA7XG4gIHN3aXRjaCAobGVuICYgMykge1xuICBjYXNlIDM6IHcgID0gcy5jaGFyQ29kZUF0KGkrMikgPDwgMTY7XG4gIGNhc2UgMjogdyB8PSBzLmNoYXJDb2RlQXQoaSsxKSA8PCA4O1xuICBjYXNlIDE6XG4gICAgdyB8PSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICBkZWZhdWx0OlxuICB9XG4gIGggXj0gbGVuO1xuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9zdHJpbmdfYXJyXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9zdHJpbmdfYXJyKGgsIHMpIHtcbiAgdmFyIGxlbiA9IHMubGVuZ3RoLCBpLCB3O1xuICBmb3IgKGkgPSAwOyBpICsgNCA8PSBsZW47IGkgKz0gNCkge1xuICAgIHcgPSBzW2ldXG4gICAgICB8IChzW2krMV0gPDwgOClcbiAgICAgIHwgKHNbaSsyXSA8PCAxNilcbiAgICAgIHwgKHNbaSszXSA8PCAyNCk7XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICB9XG4gIHcgPSAwO1xuICBzd2l0Y2ggKGxlbiAmIDMpIHtcbiAgY2FzZSAzOiB3ICA9IHNbaSsyXSA8PCAxNjtcbiAgY2FzZSAyOiB3IHw9IHNbaSsxXSA8PCA4O1xuICBjYXNlIDE6IHcgfD0gc1tpXTtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gIGRlZmF1bHQ6XG4gIH1cbiAgaCBePSBsZW47XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9zdHJpbmdfc3RyXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X3N0cmluZ19hcnJcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfc3RyaW5nKGgsIHYpIHtcbiAgc3dpdGNoICh2LnQgJiA2KSB7XG4gIGRlZmF1bHQ6XG4gICAgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyAodik7XG4gIGNhc2UgMDogLyogQllURVMgKi9cbiAgICBoID0gY2FtbF9oYXNoX21peF9zdHJpbmdfc3RyKGgsIHYuYyk7XG4gICAgYnJlYWs7XG4gIGNhc2UgMjogLyogQVJSQVkgKi9cbiAgICBoID0gY2FtbF9oYXNoX21peF9zdHJpbmdfYXJyKGgsIHYuYyk7XG4gIH1cbiAgcmV0dXJuIGhcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2ggbXV0YWJsZVxuLy9SZXF1aXJlczogTWxCeXRlc1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2hhc2hfbWl4X2ludCwgY2FtbF9oYXNoX21peF9maW5hbFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnQ2NCwgY2FtbF9oYXNoX21peF9mbG9hdCwgY2FtbF9oYXNoX21peF9zdHJpbmcsIGNhbWxfY3VzdG9tX29wc1xuZnVuY3Rpb24gY2FtbF9oYXNoIChjb3VudCwgbGltaXQsIHNlZWQsIG9iaikge1xuICB2YXIgcXVldWUsIHJkLCB3ciwgc3osIG51bSwgaCwgdiwgaSwgbGVuO1xuICBzeiA9IGxpbWl0O1xuICBpZiAoc3ogPCAwIHx8IHN6ID4gMjU2KSBzeiA9IDI1NjtcbiAgbnVtID0gY291bnQ7XG4gIGggPSBzZWVkO1xuICBxdWV1ZSA9IFtvYmpdOyByZCA9IDA7IHdyID0gMTtcbiAgd2hpbGUgKHJkIDwgd3IgJiYgbnVtID4gMCkge1xuICAgIHYgPSBxdWV1ZVtyZCsrXTtcbiAgICBpZiAodiAmJiB2LmNhbWxfY3VzdG9tKXtcbiAgICAgIGlmKGNhbWxfY3VzdG9tX29wc1t2LmNhbWxfY3VzdG9tXSAmJiBjYW1sX2N1c3RvbV9vcHNbdi5jYW1sX2N1c3RvbV0uaGFzaCkge1xuICAgICAgICB2YXIgaGggPSBjYW1sX2N1c3RvbV9vcHNbdi5jYW1sX2N1c3RvbV0uaGFzaCh2KTtcbiAgICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50IChoLCBoaCk7XG4gICAgICAgIG51bSAtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodiBpbnN0YW5jZW9mIEFycmF5ICYmIHZbMF0gPT09ICh2WzBdfDApKSB7XG4gICAgICBzd2l0Y2ggKHZbMF0pIHtcbiAgICAgIGNhc2UgMjQ4OlxuICAgICAgICAvLyBPYmplY3RcbiAgICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHZbMl0pO1xuICAgICAgICBudW0tLTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MDpcbiAgICAgICAgLy8gRm9yd2FyZFxuICAgICAgICBxdWV1ZVstLXJkXSA9IHZbMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTU6XG4gICAgICAgIC8vIEludDY0XG4gICAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludDY0IChoLCB2KTtcbiAgICAgICAgbnVtIC0tO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciB0YWcgPSAoKHYubGVuZ3RoIC0gMSkgPDwgMTApIHwgdlswXTtcbiAgICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHRhZyk7XG4gICAgICAgIGZvciAoaSA9IDEsIGxlbiA9IHYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAod3IgPj0gc3opIGJyZWFrO1xuICAgICAgICAgIHF1ZXVlW3dyKytdID0gdltpXTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBNbEJ5dGVzKSB7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9zdHJpbmcoaCx2KVxuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmICh2ID09PSAodnwwKSkge1xuICAgICAgLy8gSW50ZWdlclxuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHYrdisxKTtcbiAgICAgIG51bS0tO1xuICAgIH0gZWxzZSBpZiAodiA9PT0gK3YpIHtcbiAgICAgIC8vIEZsb2F0XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9mbG9hdChoLHYpO1xuICAgICAgbnVtLS07XG4gICAgfVxuICB9XG4gIGggPSBjYW1sX2hhc2hfbWl4X2ZpbmFsKGgpO1xuICByZXR1cm4gaCAmIDB4M0ZGRkZGRkY7XG59XG5cbi8vLy8vLy8vLy8vLy8gU3lzXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c190aW1lIG11dGFibGVcbnZhciBjYW1sX2luaXRpYWxfdGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgKiAwLjAwMTtcbmZ1bmN0aW9uIGNhbWxfc3lzX3RpbWUgKCkge1xuICB2YXIgbm93ID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgcmV0dXJuIG5vdyAqIDAuMDAxIC0gY2FtbF9pbml0aWFsX3RpbWU7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2dldF9jb25maWcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfbmV3X3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9zeXNfZ2V0X2NvbmZpZyAoKSB7XG4gIHJldHVybiBbMCwgY2FtbF9uZXdfc3RyaW5nKFwiVW5peFwiKSwgMzIsIDBdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9iYWNrZW5kX3R5cGUgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfbmV3X3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfYmFja2VuZF90eXBlICgpIHtcbiAgcmV0dXJuIFswLCBjYW1sX25ld19zdHJpbmcoXCJqc19vZl9vY2FtbFwiKV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JhbmRvbV9zZWVkIG11dGFibGVcbi8vVGhlIGZ1bmN0aW9uIG5lZWRzIHRvIHJldHVybiBhbiBhcnJheSBzaW5jZSBPQ2FtbCA0LjAuLi5cbmZ1bmN0aW9uIGNhbWxfc3lzX3JhbmRvbV9zZWVkICgpIHtcbiAgdmFyIG5vdyA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gIHZhciB4ID0gbm93XjB4ZmZmZmZmZmYqTWF0aC5yYW5kb20oKTtcbiAgcmV0dXJuIFswLHhdO1xufVxuXG5cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfYmlnX2VuZGlhbiBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfYmlnX2VuZGlhbiAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF93b3JkX3NpemUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X3dvcmRfc2l6ZSAoKSB7IHJldHVybiAzMjsgfVxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfaW50X3NpemUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X2ludF9zaXplICgpIHsgcmV0dXJuIDMyOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X21heF93b3NpemUgY29uc3Rcbi8vIG1heF9pbnQgLyA0IHNvIHRoYXQgdGhlIGZvbGxvd2luZyBkb2VzIG5vdCBvdmVyZmxvd1xuLy9sZXQgbWF4X3N0cmluZ19sZW5ndGggPSB3b3JkX3NpemUgLyA4ICogbWF4X2FycmF5X2xlbmd0aCAtIDE7O1xuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfbWF4X3dvc2l6ZSAoKSB7IHJldHVybiAoMHg3RkZGRkZGRi80KSB8IDA7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9vc3R5cGVfY3lnd2luIGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9vc3R5cGVfY3lnd2luICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X29zdHlwZV91bml4IGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9vc3R5cGVfdW5peCAoKSB7IHJldHVybiAxOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9vc3R5cGVfd2luMzIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X29zdHlwZV93aW4zMiAoKSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3N5c3RlbV9jb21tYW5kXG5mdW5jdGlvbiBjYW1sX3N5c19zeXN0ZW1fY29tbWFuZChjbWQpe1xuICB2YXIgY21kID0gY21kLnRvU3RyaW5nKCk7XG4gIGpvb19nbG9iYWxfb2JqZWN0LmNvbnNvbGUubG9nKGNtZCk7XG4gIGlmICh0eXBlb2YgcmVxdWlyZSAhPSBcInVuZGVmaW5lZFwiXG4gICAgICAmJiByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJylcbiAgICAgICYmIHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjU3luYykge1xuICAgIHRyeSB7cmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWNTeW5jKGNtZCk7IHJldHVybiAwfVxuICAgIGNhdGNoIChlKSB7cmV0dXJuIDF9XG4gIH1cbiAgZWxzZSByZXR1cm4gMTI3O1xufVxuXG4vLy8vLy8vLy8vLy8vIEFycmF5XG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X3N1YiBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2FycmF5X3N1YiAoYSwgaSwgbGVuKSB7XG4gIHZhciBhMiA9IG5ldyBBcnJheShsZW4rMSk7XG4gIGEyWzBdPTA7XG4gIGZvcih2YXIgaTIgPSAxLCBpMT0gaSsxOyBpMiA8PSBsZW47IGkyKyssaTErKyApe1xuICAgIGEyW2kyXT1hW2kxXTtcbiAgfVxuICByZXR1cm4gYTI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfYXBwZW5kIG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfYXBwZW5kKGExLCBhMikge1xuICB2YXIgbDEgPSBhMS5sZW5ndGgsIGwyID0gYTIubGVuZ3RoO1xuICB2YXIgbCA9IGwxK2wyLTFcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIGFbMF0gPSAwO1xuICB2YXIgaSA9IDEsaiA9IDE7XG4gIGZvcig7aTxsMTtpKyspIGFbaV09YTFbaV07XG4gIGZvcig7aTxsO2krKyxqKyspIGFbaV09YTJbal07XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2NvbmNhdCBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2FycmF5X2NvbmNhdChsKSB7XG4gIHZhciBhID0gWzBdO1xuICB3aGlsZSAobCAhPT0gMCkge1xuICAgIHZhciBiID0gbFsxXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGIubGVuZ3RoOyBpKyspIGEucHVzaChiW2ldKTtcbiAgICBsID0gbFsyXTtcbiAgfVxuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9ibGl0XG5mdW5jdGlvbiBjYW1sX2FycmF5X2JsaXQoYTEsIGkxLCBhMiwgaTIsIGxlbikge1xuICBpZiAoaTIgPD0gaTEpIHtcbiAgICBmb3IgKHZhciBqID0gMTsgaiA8PSBsZW47IGorKykgYTJbaTIgKyBqXSA9IGExW2kxICsgal07XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaiA9IGxlbjsgaiA+PSAxOyBqLS0pIGEyW2kyICsgal0gPSBhMVtpMSArIGpdO1xuICB9O1xuICByZXR1cm4gMDtcbn1cblxuLy8vLy8vLy8vLy8vLyBDYW1saW50ZXJuYWxPT1xuLy9Qcm92aWRlczogY2FtbF9nZXRfcHVibGljX21ldGhvZCBjb25zdFxudmFyIGNhbWxfbWV0aG9kX2NhY2hlID0gW107XG5mdW5jdGlvbiBjYW1sX2dldF9wdWJsaWNfbWV0aG9kIChvYmosIHRhZywgY2FjaGVpZCkge1xuICB2YXIgbWV0aHMgPSBvYmpbMV07XG4gIHZhciBvZnMgPSBjYW1sX21ldGhvZF9jYWNoZVtjYWNoZWlkXTtcbiAgaWYgKG9mcyA9PT0gbnVsbCkge1xuICAgIC8vIE1ha2Ugc3VyZSB0aGUgYXJyYXkgaXMgbm90IHNwYXJzZVxuICAgIGZvciAodmFyIGkgPSBjYW1sX21ldGhvZF9jYWNoZS5sZW5ndGg7IGkgPCBjYWNoZWlkOyBpKyspXG4gICAgICBjYW1sX21ldGhvZF9jYWNoZVtpXSA9IDA7XG4gIH0gZWxzZSBpZiAobWV0aHNbb2ZzXSA9PT0gdGFnKSB7XG4gICAgcmV0dXJuIG1ldGhzW29mcyAtIDFdO1xuICB9XG4gIHZhciBsaSA9IDMsIGhpID0gbWV0aHNbMV0gKiAyICsgMSwgbWk7XG4gIHdoaWxlIChsaSA8IGhpKSB7XG4gICAgbWkgPSAoKGxpK2hpKSA+PiAxKSB8IDE7XG4gICAgaWYgKHRhZyA8IG1ldGhzW21pKzFdKSBoaSA9IG1pLTI7XG4gICAgZWxzZSBsaSA9IG1pO1xuICB9XG4gIGNhbWxfbWV0aG9kX2NhY2hlW2NhY2hlaWRdID0gbGkgKyAxO1xuICAvKiByZXR1cm4gMCBpZiB0YWcgaXMgbm90IHRoZXJlICovXG4gIHJldHVybiAodGFnID09IG1ldGhzW2xpKzFdID8gbWV0aHNbbGldIDogMCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmluYWxfcmVnaXN0ZXIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZmluYWxfcmVnaXN0ZXIgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9maW5hbF9yZWdpc3Rlcl9jYWxsZWRfd2l0aG91dF92YWx1ZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9maW5hbF9yZWdpc3Rlcl9jYWxsZWRfd2l0aG91dF92YWx1ZSAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbmFsX3JlbGVhc2UgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZmluYWxfcmVsZWFzZSAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2JhY2t0cmFjZV9zdGF0dXMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfYmFja3RyYWNlX3N0YXR1cyAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9leGNlcHRpb25fYmFja3RyYWNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2dldF9leGNlcHRpb25fYmFja3RyYWNlICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2V4Y2VwdGlvbl9yYXdfYmFja3RyYWNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2dldF9leGNlcHRpb25fcmF3X2JhY2t0cmFjZSAoKSB7IHJldHVybiBbMF07IH1cbi8vUHJvdmlkZXM6IGNhbWxfcmVjb3JkX2JhY2t0cmFjZVxuZnVuY3Rpb24gY2FtbF9yZWNvcmRfYmFja3RyYWNlICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZSAoKSB7IHJldHVybiBbMF07IH1cbi8vUHJvdmlkZXM6IGNhbWxfcmF3X2JhY2t0cmFjZV9sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfcmF3X2JhY2t0cmFjZV9sZW5ndGgoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90XG5mdW5jdGlvbiBjYW1sX3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90KCkgeyByZXR1cm4gMCB9XG4vL1Byb3ZpZGVzOiBjYW1sX3Jhd19iYWNrdHJhY2Vfc2xvdFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3Jhd19iYWNrdHJhY2Vfc2xvdCAoKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlX3Nsb3Q6IGluZGV4IG91dCBvZiBib3VuZHNcIik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3Jlc3RvcmVfcmF3X2JhY2t0cmFjZVxuZnVuY3Rpb24gY2FtbF9yZXN0b3JlX3Jhd19iYWNrdHJhY2UoZXhuLCBidCkgeyByZXR1cm4gMCB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9jdXJyZW50X2NhbGxzdGFjayBjb25zdFxuZnVuY3Rpb24gY2FtbF9nZXRfY3VycmVudF9jYWxsc3RhY2sgKCkgeyByZXR1cm4gWzBdOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2V0X3N0YXRpY19lbnZcbmZ1bmN0aW9uIGNhbWxfc2V0X3N0YXRpY19lbnYoayx2KXtcbiAgaWYoIWpvb19nbG9iYWxfb2JqZWN0Lmpzb29fc3RhdGljX2VudilcbiAgICBqb29fZ2xvYmFsX29iamVjdC5qc29vX3N0YXRpY19lbnYgPSB7fVxuICBqb29fZ2xvYmFsX29iamVjdC5qc29vX3N0YXRpY19lbnZba10gPSB2O1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2dldGVudiAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX25vdF9mb3VuZFxuLy9SZXF1aXJlczogY2FtbF9qc190b19zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3lzX2dldGVudiAobmFtZSkge1xuICB2YXIgZyA9IGpvb19nbG9iYWxfb2JqZWN0O1xuICB2YXIgbiA9IG5hbWUudG9TdHJpbmcoKTtcbiAgLy9ub2RlanMgZW52XG4gIGlmKGcucHJvY2Vzc1xuICAgICAmJiBnLnByb2Nlc3MuZW52XG4gICAgICYmIGcucHJvY2Vzcy5lbnZbbl0gIT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBjYW1sX2pzX3RvX3N0cmluZyhnLnByb2Nlc3MuZW52W25dKTtcbiAgaWYoam9vX2dsb2JhbF9vYmplY3QuanNvb19zdGF0aWNfZW52XG4gICAgICYmIGpvb19nbG9iYWxfb2JqZWN0Lmpzb29fc3RhdGljX2VudltuXSlcbiAgICByZXR1cm4gY2FtbF9qc190b19zdHJpbmcoam9vX2dsb2JhbF9vYmplY3QuanNvb19zdGF0aWNfZW52W25dKVxuICBjYW1sX3JhaXNlX25vdF9mb3VuZCAoKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2V4aXRcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9zeXNfZXhpdCAoY29kZSkge1xuICB2YXIgZyA9IGpvb19nbG9iYWxfb2JqZWN0O1xuICBpZihnLnF1aXQpIGcucXVpdChjb2RlKTtcbiAgLy9ub2RlanNcbiAgaWYoZy5wcm9jZXNzICYmIGcucHJvY2Vzcy5leGl0KVxuICAgIGcucHJvY2Vzcy5leGl0KGNvZGUpO1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJGdW5jdGlvbiAnZXhpdCcgbm90IGltcGxlbWVudGVkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FyZ3Zcbi8vUmVxdWlyZXM6IGNhbWxfanNfdG9fc3RyaW5nXG4vL1JlcXVpcmVzOiByYXdfYXJyYXlfc3ViXG52YXIgY2FtbF9hcmd2ID0gKChmdW5jdGlvbiAoKSB7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIHZhciBtYWluID0gXCJhLm91dFwiO1xuICB2YXIgYXJncyA9IFtdXG5cbiAgaWYoZy5wcm9jZXNzXG4gICAgICYmIGcucHJvY2Vzcy5hcmd2XG4gICAgICYmIGcucHJvY2Vzcy5hcmd2Lmxlbmd0aCA+IDEpIHtcbiAgICB2YXIgYXJndiA9IGcucHJvY2Vzcy5hcmd2XG4gICAgLy9ub2RlanNcbiAgICBtYWluID0gYXJndlsxXTtcbiAgICBhcmdzID0gcmF3X2FycmF5X3N1Yihhcmd2LDIsYXJndi5sZW5ndGggLSAyKTtcbiAgfVxuXG4gIHZhciBwID0gY2FtbF9qc190b19zdHJpbmcobWFpbik7XG4gIHZhciBhcmdzMiA9IFswLCBwXTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspXG4gICAgYXJnczIucHVzaChjYW1sX2pzX3RvX3N0cmluZyhhcmdzW2ldKSk7XG4gIHJldHVybiBhcmdzMjtcbn0pKCkpXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXhlY3V0YWJsZV9uYW1lXG4vL1JlcXVpcmVzOiBjYW1sX2FyZ3ZcbnZhciBjYW1sX2V4ZWN1dGFibGVfbmFtZSA9IGNhbWxfYXJndlsxXVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRfYXJndlxuLy9SZXF1aXJlczogY2FtbF9hcmd2XG5mdW5jdGlvbiBjYW1sX3N5c19nZXRfYXJndiAoYSkge1xuICByZXR1cm4gWzAsIGNhbWxfYXJndlsxXSwgY2FtbF9hcmd2XTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfYXJndlxuLy9SZXF1aXJlczogY2FtbF9hcmd2XG5mdW5jdGlvbiBjYW1sX3N5c19hcmd2IChhKSB7XG4gIHJldHVybiBjYW1sX2FyZ3Y7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX21vZGlmeV9hcmd2XG4vL1JlcXVpcmVzOiBjYW1sX2FyZ3ZcbmZ1bmN0aW9uIGNhbWxfc3lzX21vZGlmeV9hcmd2KGFyZyl7XG4gIGNhbWxfYXJndiA9IGFyZztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2V4ZWN1dGFibGVfbmFtZSBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9leGVjdXRhYmxlX25hbWVcbmZ1bmN0aW9uIGNhbWxfc3lzX2V4ZWN1dGFibGVfbmFtZShhKXtcbiAgcmV0dXJuIGNhbWxfZXhlY3V0YWJsZV9uYW1lXG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfaW5ldF9hZGRyX29mX3N0cmluZ1xuZnVuY3Rpb24gdW5peF9pbmV0X2FkZHJfb2Zfc3RyaW5nICgpIHtyZXR1cm4gMDt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfb29fbGFzdF9pZFxudmFyIGNhbWxfb29fbGFzdF9pZCA9IDA7XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2V0X29vX2lkXG4vL1JlcXVpcmVzOiBjYW1sX29vX2xhc3RfaWRcbmZ1bmN0aW9uIGNhbWxfc2V0X29vX2lkIChiKSB7XG4gIGJbMl09Y2FtbF9vb19sYXN0X2lkKys7XG4gIHJldHVybiBiO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZyZXNoX29vX2lkXG4vL1JlcXVpcmVzOiBjYW1sX29vX2xhc3RfaWRcbmZ1bmN0aW9uIGNhbWxfZnJlc2hfb29faWQoKSB7XG4gIHJldHVybiBjYW1sX29vX2xhc3RfaWQrKztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnN0YWxsX3NpZ25hbF9oYW5kbGVyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2luc3RhbGxfc2lnbmFsX2hhbmRsZXIoKXtyZXR1cm4gMH1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90KCl7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Jzd2FwMTZcbmZ1bmN0aW9uIGNhbWxfYnN3YXAxNih4KSB7XG4gIHJldHVybiAoKCgoeCAmIDB4MDBGRikgPDwgOCkgfFxuICAgICAgICAgICAoKHggJiAweEZGMDApID4+IDgpKSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX2Jzd2FwXG5mdW5jdGlvbiBjYW1sX2ludDMyX2Jzd2FwKHgpIHtcbiAgcmV0dXJuICgoKHggJiAweDAwMDAwMEZGKSA8PCAyNCkgfFxuICAgICAgICAgICgoeCAmIDB4MDAwMEZGMDApIDw8IDgpIHxcbiAgICAgICAgICAoKHggJiAweDAwRkYwMDAwKSA+Pj4gOCkgfFxuICAgICAgICAgICgoeCAmIDB4RkYwMDAwMDApID4+PiAyNCkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9ic3dhcFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlcywgY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9pbnQ2NF9ic3dhcCh4KSB7XG4gIHZhciB5ID0gY2FtbF9pbnQ2NF90b19ieXRlcyh4KTtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMoW3lbN10sIHlbNl0sIHlbNV0sIHlbNF0sIHlbM10sIHlbMl0sIHlbMV0sIHlbMF1dKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9saXN0X29mX2pzX2FycmF5IGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfbGlzdF9vZl9qc19hcnJheShhKXtcbiAgdmFyIGwgPSAwO1xuICBmb3IodmFyIGk9YS5sZW5ndGggLSAxOyBpPj0wOyBpLS0pe1xuICAgIHZhciBlID0gYVtpXTtcbiAgICBsID0gWzAsZSxsXTtcbiAgfVxuICByZXR1cm4gbFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xpc3RfdG9fanNfYXJyYXkgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9saXN0X3RvX2pzX2FycmF5KGwpe1xuICB2YXIgYSA9IFtdO1xuICBmb3IoOyBsICE9PSAwOyBsID0gbFsyXSkge1xuICAgIGEucHVzaChsWzFdKTtcbiAgfVxuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX3dhcm5pbmdzXG52YXIgY2FtbF9ydW50aW1lX3dhcm5pbmdzID0gMDtcblxuLy9Qcm92aWRlczogY2FtbF9tbF9lbmFibGVfcnVudGltZV93YXJuaW5nc1xuLy9SZXF1aXJlczogY2FtbF9ydW50aW1lX3dhcm5pbmdzXG5mdW5jdGlvbiBjYW1sX21sX2VuYWJsZV9ydW50aW1lX3dhcm5pbmdzIChib29sKSB7XG4gIGNhbWxfcnVudGltZV93YXJuaW5ncyA9IGJvb2w7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3J1bnRpbWVfd2FybmluZ3NfZW5hYmxlZFxuLy9SZXF1aXJlczogY2FtbF9ydW50aW1lX3dhcm5pbmdzXG5mdW5jdGlvbiBjYW1sX21sX3J1bnRpbWVfd2FybmluZ3NfZW5hYmxlZCAoX3VuaXQpIHtcbiAgcmV0dXJuIGNhbWxfcnVudGltZV93YXJuaW5ncztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX3ZhcmlhbnRcbi8vUmVxdWlyZXM6IGNhbWxfbmV3X3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ydW50aW1lX3ZhcmlhbnQoX3VuaXQpIHtcbiAgcmV0dXJuIGNhbWxfbmV3X3N0cmluZyhcIlwiKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV9wYXJhbWV0ZXJzXG4vL1JlcXVpcmVzOiBjYW1sX25ld19zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV9wYXJhbWV0ZXJzKF91bml0KSB7XG4gIHJldHVybiBjYW1sX25ld19zdHJpbmcoXCJcIik7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfaXNhdHR5XG5mdW5jdGlvbiBjYW1sX3N5c19pc2F0dHkoX2NoYW4pIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3BhY2V0aW1lX2VuYWJsZWQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9zcGFjZXRpbWVfZW5hYmxlZChfdW5pdCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yZWdpc3Rlcl9jaGFubmVsX2Zvcl9zcGFjZXRpbWUgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9yZWdpc3Rlcl9jaGFubmVsX2Zvcl9zcGFjZXRpbWUoX2NoYW5uZWwpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX3NwYWNldGltZV9vbmx5X3dvcmtzX2Zvcl9uYXRpdmVfY29kZSgpIHtcbiAgY2FtbF9mYWlsd2l0aChcIlNwYWNldGltZSBwcm9maWxpbmcgb25seSB3b3JrcyBmb3IgbmF0aXZlIGNvZGVcIik7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9pc19qc1xuZnVuY3Rpb24gY2FtbF9pc19qcygpIHtcbiAgcmV0dXJuIDE7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczoganNvb19mbG9vcl9sb2cyXG52YXIgbG9nMl9vayA9IE1hdGgubG9nMiAmJiBNYXRoLmxvZzIoMS4xMjM1NTgyMDkyODg5NDc0RSszMDcpID09IDEwMjBcbmZ1bmN0aW9uIGpzb29fZmxvb3JfbG9nMih4KSB7XG4gIGlmKGxvZzJfb2spIHJldHVybiBNYXRoLmZsb29yKE1hdGgubG9nMih4KSlcbiAgdmFyIGkgPSAwO1xuICBpZiAoeCA9PSAwKSByZXR1cm4gLUluZmluaXR5O1xuICBpZih4Pj0xKSB7d2hpbGUgKHg+PTIpIHt4Lz0yOyBpKyt9IH1cbiAgZWxzZSB7d2hpbGUgKHggPCAxKSB7eCo9MjsgaS0tfSB9O1xuICByZXR1cm4gaTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2Zsb29yX2xvZzIsIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpXG5mdW5jdGlvbiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQgKHgpIHtcbiAgaWYgKCFpc0Zpbml0ZSh4KSkge1xuICAgIGlmIChpc05hTih4KSlcbiAgICAgIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSgxLCAwLCAweDdmZjApO1xuICAgIGlmICh4ID4gMClcbiAgICAgIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSgwLCAwLCAweDdmZjApXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKDAsIDAsIDB4ZmZmMClcbiAgfVxuICB2YXIgc2lnbiA9ICh4PT0wICYmIDEveCA9PSAtSW5maW5pdHkpPzB4ODAwMDooeD49MCk/MDoweDgwMDA7XG4gIGlmIChzaWduKSB4ID0gLXg7XG4gIC8vIEludDY0LmJpdHNfb2ZfZmxvYXQgMS4xMjM1NTgyMDkyODg5NDc0RSszMDcgPSAweDdmYjAwMDAwMDAwMDAwMDBMXG4gIC8vIHVzaW5nIE1hdGguTE9HMkUqTWF0aC5sb2coeCkgaW4gcGxhY2Ugb2YgTWF0aC5sb2cyIHJlc3VsdCBpbiBwcmVjaXNpb24gbG9zdFxuICB2YXIgZXhwID0ganNvb19mbG9vcl9sb2cyKHgpICsgMTAyMztcbiAgaWYgKGV4cCA8PSAwKSB7XG4gICAgZXhwID0gMDtcbiAgICB4IC89IE1hdGgucG93KDIsLTEwMjYpO1xuICB9IGVsc2Uge1xuICAgIHggLz0gTWF0aC5wb3coMixleHAtMTAyNyk7XG4gICAgaWYgKHggPCAxNikge1xuICAgICAgeCAqPSAyOyBleHAgLT0xOyB9XG4gICAgaWYgKGV4cCA9PSAwKSB7XG4gICAgICB4IC89IDI7IH1cbiAgfVxuICB2YXIgayA9IE1hdGgucG93KDIsMjQpO1xuICB2YXIgcjMgPSB4fDA7XG4gIHggPSAoeCAtIHIzKSAqIGs7XG4gIHZhciByMiA9IHh8MDtcbiAgeCA9ICh4IC0gcjIpICogaztcbiAgdmFyIHIxID0geHwwO1xuICByMyA9IChyMyAmMHhmKSB8IHNpZ24gfCBleHAgPDwgNDtcbiAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKHIxLCByMiwgcjMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29fZmxvb3JfbG9nMlxuZnVuY3Rpb24gY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0ICh4KSB7XG4gIHZhciBmbG9hdDMyYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5GbG9hdDMyQXJyYXkoMSk7XG4gIGZsb2F0MzJhWzBdID0geDtcbiAgdmFyIGludDMyYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5JbnQzMkFycmF5KGZsb2F0MzJhLmJ1ZmZlcik7XG4gIHJldHVybiBpbnQzMmFbMF0gfCAwO1xufVxuXG4vL0ZQIGxpdGVyYWxzIGNhbiBiZSB3cml0dGVuIHVzaW5nIHRoZSBoZXhhZGVjaW1hbFxuLy9ub3RhdGlvbiAweDxtYW50aXNzYSBpbiBoZXg+cDxleHBvbmVudD4gZnJvbSBJU08gQzk5LlxuLy9odHRwczovL2dpdGh1Yi5jb20vZGFua29nYWkvanMtaGV4ZmxvYXQvYmxvYi9tYXN0ZXIvaGV4ZmxvYXQuanNcbi8vUHJvdmlkZXM6IGNhbWxfaGV4c3RyaW5nX29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2pzX3RvX3N0cmluZywgY2FtbF9zdHJfcmVwZWF0XG5mdW5jdGlvbiBjYW1sX2hleHN0cmluZ19vZl9mbG9hdCAoeCwgcHJlYywgc3R5bGUpIHtcbiAgaWYgKCFpc0Zpbml0ZSh4KSkge1xuICAgIGlmIChpc05hTih4KSkgcmV0dXJuIGNhbWxfanNfdG9fc3RyaW5nKFwibmFuXCIpO1xuICAgIHJldHVybiBjYW1sX2pzX3RvX3N0cmluZyAoKHggPiAwKT9cImluZmluaXR5XCI6XCItaW5maW5pdHlcIik7XG4gIH1cbiAgdmFyIHNpZ24gPSAoeD09MCAmJiAxL3ggPT0gLUluZmluaXR5KT8xOih4Pj0wKT8wOjE7XG4gIGlmKHNpZ24pIHggPSAteDtcbiAgdmFyIGV4cCA9IDA7XG4gIGlmICh4ID09IDApIHsgfVxuICBlbHNlIGlmICh4IDwgMSkge1xuICAgIHdoaWxlICh4IDwgMSAmJiBleHAgPiAtMTAyMikgIHsgeCAqPSAyOyBleHAtLSB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHggPj0gMikgeyB4IC89IDI7IGV4cCsrIH1cbiAgfVxuICB2YXIgZXhwX3NpZ24gPSBleHAgPCAwID8gJycgOiAnKyc7XG4gIHZhciBzaWduX3N0ciA9ICcnO1xuICBpZiAoc2lnbikgc2lnbl9zdHIgPSAnLSdcbiAgZWxzZSB7XG4gICAgc3dpdGNoKHN0eWxlKXtcbiAgICBjYXNlIDQzIC8qICcrJyAqLzogc2lnbl9zdHIgPSAnKyc7IGJyZWFrO1xuICAgIGNhc2UgMzIgLyogJyAnICovOiBzaWduX3N0ciA9ICcgJzsgYnJlYWs7XG4gICAgZGVmYXVsdDogYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChwcmVjID49IDAgJiYgcHJlYyA8IDEzKSB7XG4gICAgLyogSWYgYSBwcmVjaXNpb24gaXMgZ2l2ZW4sIGFuZCBpcyBzbWFsbCwgcm91bmQgbWFudGlzc2EgYWNjb3JkaW5nbHkgKi9cbiAgICB2YXIgY3N0ID0gTWF0aC5wb3coMixwcmVjICogNCk7XG4gICAgeCA9IE1hdGgucm91bmQoeCAqIGNzdCkgLyBjc3Q7XG4gIH1cbiAgdmFyIHhfc3RyID0geC50b1N0cmluZygxNik7XG4gIGlmKHByZWMgPj0gMCl7XG4gICAgdmFyIGlkeCA9IHhfc3RyLmluZGV4T2YoJy4nKTtcbiAgICBpZihpZHg8MCkge1xuICAgICAgeF9zdHIgKz0gJy4nICsgY2FtbF9zdHJfcmVwZWF0KHByZWMsICcwJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHNpemUgPSBpZHgrMStwcmVjO1xuICAgICAgaWYoeF9zdHIubGVuZ3RoIDwgc2l6ZSlcbiAgICAgICAgeF9zdHIgKz0gY2FtbF9zdHJfcmVwZWF0KHNpemUgLSB4X3N0ci5sZW5ndGgsICcwJyk7XG4gICAgICBlbHNlXG4gICAgICAgIHhfc3RyID0geF9zdHIuc3Vic3RyKDAsc2l6ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjYW1sX2pzX3RvX3N0cmluZyAoc2lnbl9zdHIgKyAnMHgnICsgeF9zdHIgKyAncCcgKyBleHBfc2lnbiArIGV4cC50b1N0cmluZygxMCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyAoeCkge1xuICB2YXIgbG8gPSB4WzFdO1xuICB2YXIgbWkgPSB4WzJdO1xuICB2YXIgaGkgPSB4WzNdO1xuICB2YXIgZXhwID0gKGhpICYgMHg3ZmZmKSA+PiA0O1xuICBpZiAoZXhwID09IDIwNDcpIHtcbiAgICBpZiAoKGxvfG1pfChoaSYweGYpKSA9PSAwKVxuICAgICAgcmV0dXJuIChoaSAmIDB4ODAwMCk/KC1JbmZpbml0eSk6SW5maW5pdHk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIE5hTjtcbiAgfVxuICB2YXIgayA9IE1hdGgucG93KDIsLTI0KTtcbiAgdmFyIHJlcyA9IChsbyprK21pKSprKyhoaSYweGYpO1xuICBpZiAoZXhwID4gMCkge1xuICAgIHJlcyArPSAxNjtcbiAgICByZXMgKj0gTWF0aC5wb3coMixleHAtMTAyNyk7XG4gIH0gZWxzZVxuICAgIHJlcyAqPSBNYXRoLnBvdygyLC0xMDI2KTtcbiAgaWYgKGhpICYgMHg4MDAwKSByZXMgPSAtIHJlcztcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9uZXh0YWZ0ZXJfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cywgY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2ludDY0X2FkZCwgY2FtbF9pbnQ2NF9zdWIsY2FtbF9pbnQ2NF9vZl9pbnQzMlxuZnVuY3Rpb24gY2FtbF9uZXh0YWZ0ZXJfZmxvYXQgKHgseSkge1xuICBpZihpc05hTih4KSB8fCBpc05hTih5KSkgcmV0dXJuIE5hTjtcbiAgaWYoeD09eSkgcmV0dXJuIHk7XG4gIGlmKHg9PTApe1xuICAgIGlmKHkgPCAwKVxuICAgICAgcmV0dXJuIC1NYXRoLnBvdygyLCAtMTA3NClcbiAgICBlbHNlXG4gICAgICByZXR1cm4gTWF0aC5wb3coMiwgLTEwNzQpXG4gIH1cbiAgdmFyIGJpdHMgPSBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoeCk7XG4gIHZhciBvbmUgPSBjYW1sX2ludDY0X29mX2ludDMyKDEpO1xuICBpZiAoKHg8eSkgPT0gKHg+MCkpXG4gICAgYml0cyA9IGNhbWxfaW50NjRfYWRkKGJpdHMsIG9uZSlcbiAgZWxzZVxuICAgIGJpdHMgPSBjYW1sX2ludDY0X3N1YihiaXRzLCBvbmUpXG4gIHJldHVybiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMoYml0cyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdHJ1bmNfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfdHJ1bmNfZmxvYXQoeCl7XG4gIHJldHVybiBNYXRoLnRydW5jKHgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyAoeCkge1xuICB2YXIgaW50MzJhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LkludDMyQXJyYXkoMSk7XG4gIGludDMyYVswXSA9IHg7XG4gIHZhciBmbG9hdDMyYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5GbG9hdDMyQXJyYXkoaW50MzJhLmJ1ZmZlcik7XG4gIHJldHVybiBmbG9hdDMyYVswXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jbGFzc2lmeV9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9jbGFzc2lmeV9mbG9hdCAoeCkge1xuICBpZiAoaXNGaW5pdGUgKHgpKSB7XG4gICAgaWYgKE1hdGguYWJzKHgpID49IDIuMjI1MDczODU4NTA3MjAxNGUtMzA4KSByZXR1cm4gMDtcbiAgICBpZiAoeCAhPSAwKSByZXR1cm4gMTtcbiAgICByZXR1cm4gMjtcbiAgfVxuICByZXR1cm4gaXNOYU4oeCk/NDozO1xufVxuLy9Qcm92aWRlczogY2FtbF9tb2RmX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX21vZGZfZmxvYXQgKHgpIHtcbiAgaWYgKGlzRmluaXRlICh4KSkge1xuICAgIHZhciBuZWcgPSAoMS94KSA8IDA7XG4gICAgeCA9IE1hdGguYWJzKHgpO1xuICAgIHZhciBpID0gTWF0aC5mbG9vciAoeCk7XG4gICAgdmFyIGYgPSB4IC0gaTtcbiAgICBpZiAobmVnKSB7IGkgPSAtaTsgZiA9IC1mOyB9XG4gICAgcmV0dXJuIFswLCBmLCBpXTtcbiAgfVxuICBpZiAoaXNOYU4gKHgpKSByZXR1cm4gWzAsIE5hTiwgTmFOXTtcbiAgcmV0dXJuIFswLCAxL3gsIHhdO1xufVxuLy9Qcm92aWRlczogY2FtbF9sZGV4cF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9sZGV4cF9mbG9hdCAoeCxleHApIHtcbiAgZXhwIHw9IDA7XG4gIGlmIChleHAgPiAxMDIzKSB7XG4gICAgZXhwIC09IDEwMjM7XG4gICAgeCAqPSBNYXRoLnBvdygyLCAxMDIzKTtcbiAgICBpZiAoZXhwID4gMTAyMykgeyAgLy8gaW4gY2FzZSB4IGlzIHN1Ym5vcm1hbFxuICAgICAgZXhwIC09IDEwMjM7XG4gICAgICB4ICo9IE1hdGgucG93KDIsIDEwMjMpO1xuICAgIH1cbiAgfVxuICBpZiAoZXhwIDwgLTEwMjMpIHtcbiAgICBleHAgKz0gMTAyMztcbiAgICB4ICo9IE1hdGgucG93KDIsIC0xMDIzKTtcbiAgfVxuICB4ICo9IE1hdGgucG93KDIsIGV4cCk7XG4gIHJldHVybiB4O1xufVxuLy9Qcm92aWRlczogY2FtbF9mcmV4cF9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczoganNvb19mbG9vcl9sb2cyXG5mdW5jdGlvbiBjYW1sX2ZyZXhwX2Zsb2F0ICh4KSB7XG4gIGlmICgoeCA9PSAwKSB8fCAhaXNGaW5pdGUoeCkpIHJldHVybiBbMCwgeCwgMF07XG4gIHZhciBuZWcgPSB4IDwgMDtcbiAgaWYgKG5lZykgeCA9IC0geDtcbiAgdmFyIGV4cCA9IE1hdGgubWF4KC0xMDIzLCBqc29vX2Zsb29yX2xvZzIoeCkgKyAxKTtcbiAgeCAqPSBNYXRoLnBvdygyLC1leHApO1xuICB3aGlsZSAoeCA8IDAuNSkge1xuICAgIHggKj0gMjtcbiAgICBleHAtLTtcbiAgfVxuICB3aGlsZSAoeCA+PSAxKSB7XG4gICAgeCAqPSAwLjU7XG4gICAgZXhwKys7XG4gIH1cbiAgaWYgKG5lZykgeCA9IC0geDtcbiAgcmV0dXJuIFswLCB4LCBleHBdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0X2NvbXBhcmUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZmxvYXRfY29tcGFyZSAoeCwgeSkge1xuICBpZiAoeCA9PT0geSkgcmV0dXJuIDA7XG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xO1xuICBpZiAoeCA+IHkpIHJldHVybiAxO1xuICBpZiAoeCA9PT0geCkgcmV0dXJuIDE7XG4gIGlmICh5ID09PSB5KSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvcHlzaWduX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2NvcHlzaWduX2Zsb2F0ICh4LCB5KSB7XG4gIGlmICh5ID09IDApIHkgPSAxIC8geTtcbiAgeCA9IE1hdGguYWJzKHgpO1xuICByZXR1cm4gKHkgPCAwKT8oLXgpOng7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2lnbmJpdF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9zaWduYml0X2Zsb2F0KHgpIHtcbiAgaWYgKHggPT0gMCkgeCA9IDEgLyB4O1xuICByZXR1cm4gKHggPCAwKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXhwbTFfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZXhwbTFfZmxvYXQgKHgpIHtcbiAgdmFyIHkgPSBNYXRoLmV4cCh4KSwgeiA9IHkgLSAxO1xuICByZXR1cm4gKE1hdGguYWJzKHgpPjE/ejooej09MD94Ongqei9NYXRoLmxvZyh5KSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xvZzFwX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2xvZzFwX2Zsb2F0ICh4KSB7XG4gIHZhciB5ID0gMSArIHgsIHogPSB5IC0gMTtcbiAgcmV0dXJuICh6PT0wP3g6eCpNYXRoLmxvZyh5KS96KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oeXBvdF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9oeXBvdF9mbG9hdCAoeCwgeSkge1xuICB2YXIgeCA9IE1hdGguYWJzKHgpLCB5ID0gTWF0aC5hYnMoeSk7XG4gIHZhciBhID0gTWF0aC5tYXgoeCwgeSksIGIgPSBNYXRoLm1pbih4LHkpIC8gKGE/YToxKTtcbiAgcmV0dXJuIChhICogTWF0aC5zcXJ0KDEgKyBiKmIpKTtcbn1cblxuLy8gRklYOiB0aGVzZSBmaXZlIGZ1bmN0aW9ucyBvbmx5IGdpdmUgYXBwcm94aW1hdGUgcmVzdWx0cy5cbi8vUHJvdmlkZXM6IGNhbWxfbG9nMTBfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbG9nMTBfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGguTE9HMTBFICogTWF0aC5sb2coeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfY29zaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9jb3NoX2Zsb2F0ICh4KSB7IHJldHVybiAoTWF0aC5leHAoeCkgKyBNYXRoLmV4cCgteCkpIC8gMjsgfVxuLy9Qcm92aWRlczogY2FtbF9zaW5oX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX3NpbmhfZmxvYXQgKHgpIHsgcmV0dXJuIChNYXRoLmV4cCh4KSAtIE1hdGguZXhwKC14KSkgLyAyOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3RhbmhfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfdGFuaF9mbG9hdCAoeCkge1xuICB2YXIgeSA9IE1hdGguZXhwKHgpLCB6ID0gTWF0aC5leHAoLXgpO1xuICByZXR1cm4gKHkgLSB6KSAvICh5ICsgeik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcm91bmRfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfcm91bmRfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCk7IH1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gRHVtbXkgZmlsZXN5c3RlbVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2N1cnJlbnRfZGlyXG5pZihqb29fZ2xvYmFsX29iamVjdC5wcm9jZXNzICYmIGpvb19nbG9iYWxfb2JqZWN0LnByb2Nlc3MuY3dkKVxuICB2YXIgY2FtbF9jdXJyZW50X2RpciA9IGpvb19nbG9iYWxfb2JqZWN0LnByb2Nlc3MuY3dkKCkucmVwbGFjZSgvXFxcXC9nLCcvJyk7XG5lbHNlXG4gIHZhciBjYW1sX2N1cnJlbnRfZGlyID0gIFwiL3N0YXRpY1wiO1xuaWYoY2FtbF9jdXJyZW50X2Rpci5zbGljZSgtMSkgIT09IFwiL1wiKSBjYW1sX2N1cnJlbnRfZGlyICs9IFwiL1wiXG5cbi8vUHJvdmlkZXM6IGNhbWxfcm9vdFxuLy9SZXF1aXJlczogY2FtbF9jdXJyZW50X2RpclxudmFyIGNhbWxfcm9vdCA9IGNhbWxfY3VycmVudF9kaXIubWF0Y2goL1teXFwvXSpcXC8vKVswXTtcblxuXG4vL1Byb3ZpZGVzOiBNbEZpbGVcbmZ1bmN0aW9uIE1sRmlsZSgpeyAgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21ha2VfcGF0aFxuLy9SZXF1aXJlczogY2FtbF9jdXJyZW50X2RpcixNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX21ha2VfcGF0aCAobmFtZSkge1xuICBuYW1lPShuYW1lIGluc3RhbmNlb2YgTWxCeXRlcyk/bmFtZS50b1N0cmluZygpOm5hbWU7XG4gIGlmKG5hbWUuY2hhckNvZGVBdCgwKSAhPSA0NylcbiAgICBuYW1lID0gY2FtbF9jdXJyZW50X2RpciArIG5hbWU7XG4gIHZhciBjb21wID0gbmFtZS5zcGxpdChcIi9cIik7XG4gIHZhciBuY29tcCA9IFtdXG4gIGZvcih2YXIgaSA9IDA7IGk8Y29tcC5sZW5ndGg7IGkrKyl7XG4gICAgc3dpdGNoKGNvbXBbaV0pe1xuICAgIGNhc2UgXCIuLlwiOiBpZihuY29tcC5sZW5ndGg+MSkgbmNvbXAucG9wKCk7IGJyZWFrO1xuICAgIGNhc2UgXCIuXCI6IGJyZWFrO1xuICAgIGNhc2UgXCJcIjogaWYobmNvbXAubGVuZ3RoID09IDApIG5jb21wLnB1c2goXCJcIik7IGJyZWFrO1xuICAgIGRlZmF1bHQ6IG5jb21wLnB1c2goY29tcFtpXSk7YnJlYWtcbiAgICB9XG4gIH1cbiAgbmNvbXAub3JpZyA9IG5hbWU7XG4gIHJldHVybiBuY29tcDtcbn1cblxuLy9Qcm92aWRlczpqc29vX21vdW50X3BvaW50XG4vL1JlcXVpcmVzOiBNbEZha2VEZXZpY2UsIE1sTm9kZURldmljZSwgY2FtbF9yb290LCBmc19ub2RlX3N1cHBvcnRlZFxudmFyIGpzb29fbW91bnRfcG9pbnQgPSBbXVxuaWYgKGZzX25vZGVfc3VwcG9ydGVkKCkpIHtcbiAganNvb19tb3VudF9wb2ludC5wdXNoKHtwYXRoOmNhbWxfcm9vdCxkZXZpY2U6bmV3IE1sTm9kZURldmljZShjYW1sX3Jvb3QpfSk7XG59IGVsc2Uge1xuICBqc29vX21vdW50X3BvaW50LnB1c2goe3BhdGg6Y2FtbF9yb290LGRldmljZTpuZXcgTWxGYWtlRGV2aWNlKGNhbWxfcm9vdCl9KTtcbn1cbmpzb29fbW91bnRfcG9pbnQucHVzaCh7cGF0aDpjYW1sX3Jvb3QrXCJzdGF0aWMvXCIsIGRldmljZTpuZXcgTWxGYWtlRGV2aWNlKGNhbWxfcm9vdCtcInN0YXRpYy9cIil9KTtcblxuLy9Qcm92aWRlczpjYW1sX2xpc3RfbW91bnRfcG9pbnRcbi8vUmVxdWlyZXM6IGpzb29fbW91bnRfcG9pbnQsIGNhbWxfbmV3X3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9saXN0X21vdW50X3BvaW50KCl7XG4gIHZhciBwcmV2ID0gMFxuICBmb3IodmFyIGkgPSAwOyBpIDwganNvb19tb3VudF9wb2ludC5sZW5ndGg7IGkrKyl7XG4gICAgdmFyIG9sZCA9IHByZXY7XG4gICAgcHJldiA9IFswLCBjYW1sX25ld19zdHJpbmcoanNvb19tb3VudF9wb2ludFtpXS5wYXRoKSwgb2xkXVxuICB9XG4gIHJldHVybiBwcmV2O1xufVxuXG4vL1Byb3ZpZGVzOiByZXNvbHZlX2ZzX2RldmljZVxuLy9SZXF1aXJlczogY2FtbF9tYWtlX3BhdGgsIGpzb29fbW91bnRfcG9pbnRcbmZ1bmN0aW9uIHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpe1xuICB2YXIgcGF0aCA9IGNhbWxfbWFrZV9wYXRoKG5hbWUpO1xuICB2YXIgbmFtZSA9IHBhdGguam9pbihcIi9cIik7XG4gIHZhciBuYW1lX3NsYXNoID0gbmFtZSArIFwiL1wiO1xuICB2YXIgcmVzO1xuICBmb3IodmFyIGkgPSAwOyBpIDwganNvb19tb3VudF9wb2ludC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtID0ganNvb19tb3VudF9wb2ludFtpXTtcbiAgICBpZihuYW1lX3NsYXNoLnNlYXJjaChtLnBhdGgpID09IDBcbiAgICAgICAmJiAoIXJlcyB8fCByZXMucGF0aC5sZW5ndGggPCBtLnBhdGgubGVuZ3RoKSlcbiAgICAgIHJlcyA9IHtwYXRoOm0ucGF0aCxkZXZpY2U6bS5kZXZpY2UscmVzdDpuYW1lLnN1YnN0cmluZyhtLnBhdGgubGVuZ3RoLG5hbWUubGVuZ3RoKX07XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tb3VudF9hdXRvbG9hZFxuLy9SZXF1aXJlczogTWxGYWtlRGV2aWNlLCBjYW1sX21ha2VfcGF0aCwganNvb19tb3VudF9wb2ludFxuZnVuY3Rpb24gY2FtbF9tb3VudF9hdXRvbG9hZChuYW1lLGYpe1xuICB2YXIgcGF0aCA9IGNhbWxfbWFrZV9wYXRoKG5hbWUpO1xuICB2YXIgbmFtZSA9IHBhdGguam9pbihcIi9cIikgKyBcIi9cIjtcbiAganNvb19tb3VudF9wb2ludC5wdXNoKHtwYXRoOm5hbWUsZGV2aWNlOm5ldyBNbEZha2VEZXZpY2UobmFtZSxmKX0pXG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VubW91bnRcbi8vUmVxdWlyZXM6IGpzb29fbW91bnRfcG9pbnQsIGNhbWxfbWFrZV9wYXRoXG5mdW5jdGlvbiBjYW1sX3VubW91bnQobmFtZSl7XG4gIHZhciBwYXRoID0gY2FtbF9tYWtlX3BhdGgobmFtZSk7XG4gIHZhciBuYW1lID0gcGF0aC5qb2luKFwiL1wiKSArIFwiL1wiO1xuICB2YXIgaWR4ID0gLTE7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBqc29vX21vdW50X3BvaW50Lmxlbmd0aDsgaSsrKVxuICAgIGlmKGpzb29fbW91bnRfcG9pbnRbaV0ucGF0aCA9PSBuYW1lKSBpZHggPSBpO1xuICBpZihpZHggPiAtMSkganNvb19tb3VudF9wb2ludC5zcGxpY2UoaWR4LDEpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRjd2Rcbi8vUmVxdWlyZXM6IGNhbWxfY3VycmVudF9kaXIsIGNhbWxfbmV3X3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9zeXNfZ2V0Y3dkKCkge1xuICByZXR1cm4gY2FtbF9uZXdfc3RyaW5nKGNhbWxfY3VycmVudF9kaXIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jaGRpclxuLy9SZXF1aXJlczogY2FtbF9jdXJyZW50X2RpciwgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUsIHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19jaGRpcihkaXIpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShkaXIpO1xuICBpZihyb290LmRldmljZS5leGlzdHMocm9vdC5yZXN0KSkge1xuICAgIGlmKHJvb3QucmVzdCkgY2FtbF9jdXJyZW50X2RpciA9IHJvb3QucGF0aCArIHJvb3QucmVzdCArIFwiL1wiO1xuICAgIGVsc2UgY2FtbF9jdXJyZW50X2RpciA9IHJvb3QucGF0aDtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBlbHNlIHtcbiAgICBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShkaXIpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlXG4vL1JlcXVpcmVzOiBNbEJ5dGVzLCBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUobmFtZSl7XG4gIG5hbWUgPSAobmFtZSBpbnN0YW5jZW9mIE1sQnl0ZXMpP25hbWUudG9TdHJpbmcoKTpuYW1lO1xuICBjYW1sX3JhaXNlX3N5c19lcnJvciAobmFtZSArIFwiOiBObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX25vdF9hX2RpclxuLy9SZXF1aXJlczogTWxCeXRlcywgY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfbm90X2FfZGlyKG5hbWUpe1xuICBuYW1lID0gKG5hbWUgaW5zdGFuY2VvZiBNbEJ5dGVzKT9uYW1lLnRvU3RyaW5nKCk6bmFtZTtcbiAgY2FtbF9yYWlzZV9zeXNfZXJyb3IgKG5hbWUgKyBcIjogTm90IGEgZGlyZWN0b3J5XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19maWxlX2V4aXN0c1xuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX2ZpbGVfZXhpc3RzIChuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHJldHVybiByb290LmRldmljZS5leGlzdHMocm9vdC5yZXN0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcmVhZF9kaXJlY3Rvcnlcbi8vUmVxdWlyZXM6IGNhbWxfbmV3X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9ub3RfYV9kaXIsIHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19yZWFkX2RpcmVjdG9yeShuYW1lKXtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgdmFyIGEgPSByb290LmRldmljZS5yZWFkZGlyKHJvb3QucmVzdCk7XG4gIHZhciBsID0gbmV3IEFycmF5KGEubGVuZ3RoICsgMSk7XG4gIGxbMF0gPSAwO1xuICBmb3IodmFyIGk9MDtpPGEubGVuZ3RoO2krKylcbiAgICBsW2krMV0gPSBjYW1sX25ld19zdHJpbmcoYVtpXSk7XG4gIHJldHVybiBsO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yZW1vdmVcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlLCByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfcmVtb3ZlKG5hbWUpe1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICB2YXIgb2sgPSByb290LmRldmljZS51bmxpbmsocm9vdC5yZXN0KTtcbiAgaWYob2sgPT0gMCkgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUobmFtZSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19pc19kaXJlY3Rvcnlcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19pc19kaXJlY3RvcnkobmFtZSl7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBhID0gcm9vdC5kZXZpY2UuaXNfZGlyKHJvb3QucmVzdCk7XG4gIHJldHVybiBhPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcmVuYW1lXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfcmVuYW1lKG8sbil7XG4gIHZhciBvX3Jvb3QgPSByZXNvbHZlX2ZzX2RldmljZShvKTtcbiAgdmFyIG5fcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG4pO1xuICBpZihvX3Jvb3QuZGV2aWNlICE9IG5fcm9vdC5kZXZpY2UpXG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3lzX3JlbmFtZTogY2Fubm90IG1vdmUgZmlsZSBiZXR3ZWVuIHR3byBmaWxlc3lzdGVtXCIpO1xuICBpZighb19yb290LmRldmljZS5yZW5hbWUpXG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3lzX3JlbmFtZTogbm8gaW1wbGVtZW50ZWRcIik7XG4gIG9fcm9vdC5kZXZpY2UucmVuYW1lKG9fcm9vdC5yZXN0LCBuX3Jvb3QucmVzdCk7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9iYV9tYXBfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9iYV9tYXBfZmlsZSh2ZmQsIGtpbmQsIGxheW91dCwgc2hhcmVkLCBkaW1zLCBwb3MpIHtcbiAgLy8gdmFyIGRhdGEgPSBjYW1sX2dsb2JhbF9kYXRhLmZkc1t2ZmRdO1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9iYV9tYXBfZmlsZSBub3QgaW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfbWFwX2ZpbGVfYnl0ZWNvZGVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfbWFwX2ZpbGVcbmZ1bmN0aW9uIGNhbWxfYmFfbWFwX2ZpbGVfYnl0ZWNvZGUoYXJndixhcmduKXtcbiAgcmV0dXJuIGNhbWxfYmFfbWFwX2ZpbGUoYXJndlswXSxhcmd2WzFdLGFyZ3ZbMl0sYXJndlszXSxhcmd2WzRdLGFyZ3ZbNV0pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NyZWF0ZV9maWxlX2V4dGVyblxuZnVuY3Rpb24gY2FtbF9jcmVhdGVfZmlsZV9leHRlcm4obmFtZSxjb250ZW50KXtcbiAgaWYoam9vX2dsb2JhbF9vYmplY3QuY2FtbF9jcmVhdGVfZmlsZSlcbiAgICBqb29fZ2xvYmFsX29iamVjdC5jYW1sX2NyZWF0ZV9maWxlKG5hbWUsY29udGVudCk7XG4gIGVsc2Uge1xuICAgIGlmKCFqb29fZ2xvYmFsX29iamVjdC5jYW1sX2ZzX3RtcCkgam9vX2dsb2JhbF9vYmplY3QuY2FtbF9mc190bXAgPSBbXTtcbiAgICBqb29fZ2xvYmFsX29iamVjdC5jYW1sX2ZzX3RtcC5wdXNoKHtuYW1lOm5hbWUsY29udGVudDpjb250ZW50fSk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZnNfaW5pdFxuLy9SZXF1aXJlczogY2FtbF9jcmVhdGVfZmlsZVxuZnVuY3Rpb24gY2FtbF9mc19pbml0ICgpe1xuICB2YXIgdG1wPWpvb19nbG9iYWxfb2JqZWN0LmNhbWxfZnNfdG1wXG4gIGlmKHRtcCl7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRtcC5sZW5ndGg7IGkrKyl7XG4gICAgICBjYW1sX2NyZWF0ZV9maWxlKHRtcFtpXS5uYW1lLHRtcFtpXS5jb250ZW50KTtcbiAgICB9XG4gIH1cbiAgam9vX2dsb2JhbF9vYmplY3QuY2FtbF9jcmVhdGVfZmlsZSA9IGNhbWxfY3JlYXRlX2ZpbGU7XG4gIGpvb19nbG9iYWxfb2JqZWN0LmNhbWxfZnNfdG1wID0gW107XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NyZWF0ZV9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9jcmVhdGVfZmlsZShuYW1lLGNvbnRlbnQpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYoISByb290LmRldmljZS5yZWdpc3RlcikgY2FtbF9mYWlsd2l0aChcImNhbm5vdCByZWdpc3RlciBmaWxlXCIpO1xuICByb290LmRldmljZS5yZWdpc3Rlcihyb290LnJlc3QsY29udGVudCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlYWRfZmlsZV9jb250ZW50XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUsIGNhbWxfY3JlYXRlX2J5dGVzXG5mdW5jdGlvbiBjYW1sX3JlYWRfZmlsZV9jb250ZW50IChuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmKHJvb3QuZGV2aWNlLmV4aXN0cyhyb290LnJlc3QpKSB7XG4gICAgdmFyIGZpbGUgPSByb290LmRldmljZS5vcGVuKHJvb3QucmVzdCx7cmRvbmx5OjF9KTtcbiAgICB2YXIgbGVuICA9IGZpbGUubGVuZ3RoKCk7XG4gICAgdmFyIGJ1ZiAgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICAgIGZpbGUucmVhZCgwLGJ1ZiwwLGxlbik7XG4gICAgcmV0dXJuIGJ1ZlxuICB9XG4gIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlKG5hbWUpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogTWxGYWtlRGV2aWNlXG4vL1JlcXVpcmVzOiBNbEZha2VGaWxlLCBjYW1sX2NyZWF0ZV9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlLCBjYW1sX25ld19zdHJpbmcsIGNhbWxfc3RyaW5nX29mX2FycmF5XG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBNbEZha2VEZXZpY2UgKHJvb3QsIGYpIHtcbiAgdGhpcy5jb250ZW50PXt9O1xuICB0aGlzLnJvb3QgPSByb290O1xuICB0aGlzLmxvb2t1cEZ1biA9IGY7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLm5tID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gKHRoaXMucm9vdCArIG5hbWUpO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5sb29rdXAgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmKCF0aGlzLmNvbnRlbnRbbmFtZV0gJiYgdGhpcy5sb29rdXBGdW4pIHtcbiAgICB2YXIgcmVzID0gdGhpcy5sb29rdXBGdW4oY2FtbF9uZXdfc3RyaW5nKHRoaXMucm9vdCksIGNhbWxfbmV3X3N0cmluZyhuYW1lKSk7XG4gICAgaWYocmVzICE9PSAwKSB0aGlzLmNvbnRlbnRbbmFtZV09bmV3IE1sRmFrZUZpbGUocmVzWzFdKTtcbiAgfVxufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5leGlzdHMgPSBmdW5jdGlvbihuYW1lKSB7XG4gIC8vIFRoZSByb290IG9mIHRoZSBkZXZpY2UgZXhpc3RzXG4gIGlmKG5hbWUgPT0gXCJcIikgcmV0dXJuIDE7XG4gIC8vIENoZWNrIGlmIGEgZGlyZWN0b3J5IGV4aXN0c1xuICB2YXIgbmFtZV9zbGFzaCA9IChuYW1lICsgXCIvXCIpO1xuICB2YXIgciA9IG5ldyBSZWdFeHAoXCJeXCIgKyBuYW1lX3NsYXNoKTtcbiAgZm9yKHZhciBuIGluIHRoaXMuY29udGVudCkge1xuICAgIGlmIChuLm1hdGNoKHIpKSByZXR1cm4gMVxuICB9XG4gIC8vIENoZWNrIGlmIGEgZmlsZSBleGlzdHNcbiAgdGhpcy5sb29rdXAobmFtZSk7XG4gIHJldHVybiB0aGlzLmNvbnRlbnRbbmFtZV0/MTowO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5yZWFkZGlyID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgbmFtZV9zbGFzaCA9IChuYW1lID09IFwiXCIpP1wiXCI6KG5hbWUgKyBcIi9cIik7XG4gIHZhciByID0gbmV3IFJlZ0V4cChcIl5cIiArIG5hbWVfc2xhc2ggKyBcIihbXi9dKilcIik7XG4gIHZhciBzZWVuID0ge31cbiAgdmFyIGEgPSBbXTtcbiAgZm9yKHZhciBuIGluIHRoaXMuY29udGVudCkge1xuICAgIHZhciBtID0gbi5tYXRjaChyKTtcbiAgICBpZihtICYmICFzZWVuW21bMV1dKSB7c2VlblttWzFdXSA9IHRydWU7IGEucHVzaChtWzFdKX1cbiAgfVxuICByZXR1cm4gYTtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUuaXNfZGlyID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgbmFtZV9zbGFzaCA9IChuYW1lID09IFwiXCIpP1wiXCI6KG5hbWUgKyBcIi9cIik7XG4gIHZhciByID0gbmV3IFJlZ0V4cChcIl5cIiArIG5hbWVfc2xhc2ggKyBcIihbXi9dKilcIik7XG4gIHZhciBhID0gW107XG4gIGZvcih2YXIgbiBpbiB0aGlzLmNvbnRlbnQpIHtcbiAgICB2YXIgbSA9IG4ubWF0Y2gocik7XG4gICAgaWYobSkgcmV0dXJuIDFcbiAgfVxuICByZXR1cm4gMFxufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS51bmxpbmsgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBvayA9IHRoaXMuY29udGVudFtuYW1lXT90cnVlOmZhbHNlO1xuICBkZWxldGUgdGhpcy5jb250ZW50W25hbWVdO1xuICByZXR1cm4gb2s7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbihuYW1lLCBmKSB7XG4gIGlmKGYucmRvbmx5ICYmIGYud3Jvbmx5KVxuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZsYWdzIE9wZW5fcmRvbmx5IGFuZCBPcGVuX3dyb25seSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIGlmKGYudGV4dCAmJiBmLmJpbmFyeSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3RleHQgYW5kIE9wZW5fYmluYXJ5IGFyZSBub3QgY29tcGF0aWJsZVwiKTtcbiAgdGhpcy5sb29rdXAobmFtZSk7XG4gIGlmICh0aGlzLmNvbnRlbnRbbmFtZV0pIHtcbiAgICBpZiAodGhpcy5pc19kaXIobmFtZSkpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGlzIGEgZGlyZWN0b3J5XCIpO1xuICAgIGlmIChmLmNyZWF0ZSAmJiBmLmV4Y2wpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZpbGUgYWxyZWFkeSBleGlzdHNcIik7XG4gICAgdmFyIGZpbGUgPSB0aGlzLmNvbnRlbnRbbmFtZV07XG4gICAgaWYoZi50cnVuY2F0ZSkgZmlsZS50cnVuY2F0ZSgpO1xuICAgIHJldHVybiBmaWxlO1xuICB9IGVsc2UgaWYgKGYuY3JlYXRlKSB7XG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9jcmVhdGVfYnl0ZXMoMCkpO1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnRbbmFtZV07XG4gIH0gZWxzZSB7XG4gICAgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUgKHRoaXMubm0obmFtZSkpO1xuICB9XG59XG5cbk1sRmFrZURldmljZS5wcm90b3R5cGUucmVnaXN0ZXI9IGZ1bmN0aW9uIChuYW1lLGNvbnRlbnQpe1xuICBpZih0aGlzLmNvbnRlbnRbbmFtZV0pIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZpbGUgYWxyZWFkeSBleGlzdHNcIik7XG4gIGlmKGNvbnRlbnQgaW5zdGFuY2VvZiBNbEJ5dGVzKVxuICAgIHRoaXMuY29udGVudFtuYW1lXSA9IG5ldyBNbEZha2VGaWxlKGNvbnRlbnQpO1xuICBlbHNlIGlmKGNvbnRlbnQgaW5zdGFuY2VvZiBBcnJheSlcbiAgICB0aGlzLmNvbnRlbnRbbmFtZV0gPSBuZXcgTWxGYWtlRmlsZShjYW1sX3N0cmluZ19vZl9hcnJheShjb250ZW50KSk7XG4gIGVsc2UgaWYoY29udGVudC50b1N0cmluZykge1xuICAgIHZhciBtbHN0cmluZyA9IGNhbWxfbmV3X3N0cmluZyhjb250ZW50LnRvU3RyaW5nKCkpO1xuICAgIHRoaXMuY29udGVudFtuYW1lXSA9IG5ldyBNbEZha2VGaWxlKG1sc3RyaW5nKTtcbiAgfVxufVxuXG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxGYWtlRGV2aWNlXG5cbi8vUHJvdmlkZXM6IE1sRmFrZUZpbGVcbi8vUmVxdWlyZXM6IE1sRmlsZVxuLy9SZXF1aXJlczogY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoLGNhbWxfYmxpdF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9ieXRlc19nZXRcbmZ1bmN0aW9uIE1sRmFrZUZpbGUoY29udGVudCl7XG4gIHRoaXMuZGF0YSA9IGNvbnRlbnQ7XG59XG5NbEZha2VGaWxlLnByb3RvdHlwZSA9IG5ldyBNbEZpbGUgKCk7XG5NbEZha2VGaWxlLnByb3RvdHlwZS50cnVuY2F0ZSA9IGZ1bmN0aW9uKGxlbil7XG4gIHZhciBvbGQgPSB0aGlzLmRhdGE7XG4gIHRoaXMuZGF0YSA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbnwwKTtcbiAgY2FtbF9ibGl0X2J5dGVzKG9sZCwgMCwgdGhpcy5kYXRhLCAwLCBsZW4pO1xufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY2FtbF9tbF9ieXRlc19sZW5ndGgodGhpcy5kYXRhKTtcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24ob2Zmc2V0LGJ1Zixwb3MsbGVuKXtcbiAgdmFyIGNsZW4gPSB0aGlzLmxlbmd0aCgpO1xuICBpZihvZmZzZXQgKyBsZW4gPj0gY2xlbikge1xuICAgIHZhciBuZXdfc3RyID0gY2FtbF9jcmVhdGVfYnl0ZXMob2Zmc2V0ICsgbGVuKTtcbiAgICB2YXIgb2xkX2RhdGEgPSB0aGlzLmRhdGE7XG4gICAgdGhpcy5kYXRhID0gbmV3X3N0cjtcbiAgICBjYW1sX2JsaXRfYnl0ZXMob2xkX2RhdGEsIDAsIHRoaXMuZGF0YSwgMCwgY2xlbik7XG4gIH1cbiAgY2FtbF9ibGl0X2J5dGVzKGJ1ZiwgcG9zLCB0aGlzLmRhdGEsIG9mZnNldCwgbGVuKTtcbiAgcmV0dXJuIDBcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihvZmZzZXQsYnVmLHBvcyxsZW4pe1xuICB2YXIgY2xlbiA9IHRoaXMubGVuZ3RoKCk7XG4gIGNhbWxfYmxpdF9ieXRlcyh0aGlzLmRhdGEsIG9mZnNldCwgYnVmLCBwb3MsIGxlbik7XG4gIHJldHVybiAwXG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5yZWFkX29uZSA9IGZ1bmN0aW9uKG9mZnNldCl7XG4gIHJldHVybiBjYW1sX2J5dGVzX2dldCh0aGlzLmRhdGEsIG9mZnNldCk7XG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCl7XG5cbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxGYWtlRmlsZVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogZnNfbm9kZV9zdXBwb3J0ZWRcbmZ1bmN0aW9uIGZzX25vZGVfc3VwcG9ydGVkICgpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygam9vX2dsb2JhbF9vYmplY3QucHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICYmIHR5cGVvZiBqb29fZ2xvYmFsX29iamVjdC5wcm9jZXNzLnZlcnNpb25zICE9PSAndW5kZWZpbmVkJ1xuICAgICAgJiYgdHlwZW9mIGpvb19nbG9iYWxfb2JqZWN0LnByb2Nlc3MudmVyc2lvbnMubm9kZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICYmIGpvb19nbG9iYWxfb2JqZWN0LnByb2Nlc3MucGxhdGZvcm0gIT09IFwiYnJvd3NlclwiKVxufVxuXG4vL1Byb3ZpZGVzOiBNbE5vZGVEZXZpY2Vcbi8vUmVxdWlyZXM6IE1sTm9kZUZpbGVcbmZ1bmN0aW9uIE1sTm9kZURldmljZShyb290KSB7XG4gIHRoaXMuZnMgPSByZXF1aXJlKCdmcycpO1xuICB0aGlzLnJvb3QgPSByb290O1xufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5ubSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuICh0aGlzLnJvb3QgKyBuYW1lKTtcbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUuZXhpc3RzID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gdGhpcy5mcy5leGlzdHNTeW5jKHRoaXMubm0obmFtZSkpPzE6MDtcbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUucmVhZGRpciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuZnMucmVhZGRpclN5bmModGhpcy5ubShuYW1lKSk7XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLmlzX2RpciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuZnMuc3RhdFN5bmModGhpcy5ubShuYW1lKSkuaXNEaXJlY3RvcnkoKT8xOjA7XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnVubGluayA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIGIgPSB0aGlzLmZzLmV4aXN0c1N5bmModGhpcy5ubShuYW1lKSk/MTowO1xuICB0aGlzLmZzLnVubGlua1N5bmModGhpcy5ubShuYW1lKSk7XG4gIHJldHVybiBiXG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbihuYW1lLCBmKSB7XG4gIHZhciBjb25zdHMgPSByZXF1aXJlKCdjb25zdGFudHMnKTtcbiAgdmFyIHJlcyA9IDA7XG4gIGZvcih2YXIga2V5IGluIGYpe1xuICAgIHN3aXRjaChrZXkpe1xuICAgIGNhc2UgXCJyZG9ubHlcIiAgOiByZXMgfD0gY29uc3RzLk9fUkRPTkxZOyBicmVhaztcbiAgICBjYXNlIFwid3Jvbmx5XCIgIDogcmVzIHw9IGNvbnN0cy5PX1dST05MWTsgYnJlYWs7XG4gICAgY2FzZSBcImFwcGVuZFwiICA6XG4gICAgICByZXMgfD0gY29uc3RzLk9fV1JPTkxZIHwgY29uc3RzLk9fQVBQRU5EO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNyZWF0ZVwiICAgOiByZXMgfD0gY29uc3RzLk9fQ1JFQVQ7ICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ0cnVuY2F0ZVwiIDogcmVzIHw9IGNvbnN0cy5PX1RSVU5DOyAgICBicmVhaztcbiAgICBjYXNlIFwiZXhjbFwiICAgICA6IHJlcyB8PSBjb25zdHMuT19FWENMOyAgICAgYnJlYWs7XG4gICAgY2FzZSBcImJpbmFyeVwiICAgOiByZXMgfD0gY29uc3RzLk9fQklOQVJZOyAgIGJyZWFrO1xuICAgIGNhc2UgXCJ0ZXh0XCIgICAgIDogcmVzIHw9IGNvbnN0cy5PX1RFWFQ7ICAgICBicmVhaztcbiAgICBjYXNlIFwibm9uYmxvY2tcIiA6IHJlcyB8PSBjb25zdHMuT19OT05CTE9DSzsgYnJlYWs7XG4gICAgfVxuICB9XG4gIHZhciBmZCA9IHRoaXMuZnMub3BlblN5bmModGhpcy5ubShuYW1lKSwgcmVzKTtcbiAgcmV0dXJuIG5ldyBNbE5vZGVGaWxlKGZkKTtcbn1cblxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5yZW5hbWUgPSBmdW5jdGlvbihvLG4pIHtcbiAgdGhpcy5mcy5yZW5hbWVTeW5jKHRoaXMubm0obyksIHRoaXMubm0obikpO1xufVxuXG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxOb2RlRGV2aWNlXG5cbi8vUHJvdmlkZXM6IE1sTm9kZUZpbGVcbi8vUmVxdWlyZXM6IE1sRmlsZSwgY2FtbF9hcnJheV9vZl9zdHJpbmcsIGNhbWxfYnl0ZXNfc2V0XG5cbnZhciBCdWZmZXIgPSBqb29fZ2xvYmFsX29iamVjdC5CdWZmZXJcblxuZnVuY3Rpb24gTWxOb2RlRmlsZShmZCl7XG4gIHRoaXMuZnMgPSByZXF1aXJlKCdmcycpO1xuICB0aGlzLmZkID0gZmQ7XG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZSA9IG5ldyBNbEZpbGUgKCk7XG5cbk1sTm9kZUZpbGUucHJvdG90eXBlLnRydW5jYXRlID0gZnVuY3Rpb24obGVuKXtcbiAgdGhpcy5mcy5mdHJ1bmNhdGVTeW5jKHRoaXMuZmQsbGVufDApXG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmZzLmZzdGF0U3luYyh0aGlzLmZkKS5zaXplO1xufVxuTWxOb2RlRmlsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihvZmZzZXQsYnVmLGJ1Zl9vZmZzZXQsbGVuKXtcbiAgdmFyIGEgPSBjYW1sX2FycmF5X29mX3N0cmluZyhidWYpO1xuICBpZighIChhIGluc3RhbmNlb2Ygam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheSkpXG4gICAgYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KGEpO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmZyb20oYSk7XG4gIHRoaXMuZnMud3JpdGVTeW5jKHRoaXMuZmQsIGJ1ZmZlciwgYnVmX29mZnNldCwgbGVuLCBvZmZzZXQpO1xuICByZXR1cm4gMDtcbn1cbk1sTm9kZUZpbGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihvZmZzZXQsYnVmLGJ1Zl9vZmZzZXQsbGVuKXtcbiAgdmFyIGEgPSBjYW1sX2FycmF5X29mX3N0cmluZyhidWYpO1xuICBpZighIChhIGluc3RhbmNlb2Ygam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheSkpXG4gICAgYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KGEpO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmZyb20oYSk7XG4gIHRoaXMuZnMucmVhZFN5bmModGhpcy5mZCwgYnVmZmVyLCBidWZfb2Zmc2V0LCBsZW4sIG9mZnNldCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKyl7XG4gICAgY2FtbF9ieXRlc19zZXQoYnVmLGJ1Zl9vZmZzZXQgKyBpLGJ1ZmZlcltidWZfb2Zmc2V0K2ldKTtcbiAgfVxuICByZXR1cm4gMFxufVxuTWxOb2RlRmlsZS5wcm90b3R5cGUucmVhZF9vbmUgPSBmdW5jdGlvbihvZmZzZXQpe1xuICB2YXIgYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KDEpO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmZyb20oYSk7XG4gIHRoaXMuZnMucmVhZFN5bmModGhpcy5mZCwgYnVmZmVyLCAwLCAxLCBvZmZzZXQpO1xuICByZXR1cm4gYnVmZmVyWzBdO1xufVxuTWxOb2RlRmlsZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpe1xuICB0aGlzLmZzLmNsb3NlU3luYyh0aGlzLmZkKTtcbn1cblxuTWxOb2RlRmlsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNbE5vZGVGaWxlO1xuIiwiLy9Qcm92aWRlczogaW5pdGlhbGl6ZV9uYXRcbi8vUmVxdWlyZXM6IGNhbWxfY3VzdG9tX29wc1xuLy9SZXF1aXJlczogc2VyaWFsaXplX25hdCwgZGVzZXJpYWxpemVfbmF0LCBjYW1sX2hhc2hfbmF0XG5mdW5jdGlvbiBpbml0aWFsaXplX25hdCgpIHtcbiAgY2FtbF9jdXN0b21fb3BzW1wiX25hdFwiXSA9XG4gICAgeyBkZXNlcmlhbGl6ZSA6IGRlc2VyaWFsaXplX25hdCxcbiAgICAgIHNlcmlhbGl6ZSA6IHNlcmlhbGl6ZV9uYXQsXG4gICAgICBoYXNoIDogY2FtbF9oYXNoX25hdFxuICAgIH1cbn1cblxuLy9Qcm92aWRlczogTWxOYXRcbmZ1bmN0aW9uIE1sTmF0KHgpe1xuICB0aGlzLmRhdGEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuSW50MzJBcnJheSh4KTtcbiAgLy8gbGVuZ3RoX25hdCBpc24ndCBleHRlcm5hbCwgc28gd2UgaGF2ZSB0byBtYWtlIHRoZSBPYmouc2l6ZVxuICAvLyB3b3JrIG91dCByaWdodC4gVGhlICsyIHRvIGFycmF5IGxlbmd0aCBzZWVtcyB0byB3b3JrLlxuICB0aGlzLmxlbmd0aCA9IHRoaXMuZGF0YS5sZW5ndGggKyAyXG59XG5cbk1sTmF0LnByb3RvdHlwZS5jYW1sX2N1c3RvbSA9IFwiX25hdFwiO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbmF0XG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludCwgbnVtX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIGNhbWxfaGFzaF9uYXQoeCkge1xuICB2YXIgbGVuID0gbnVtX2RpZ2l0c19uYXQoeCwgMCwgeC5kYXRhLmxlbmd0aCk7XG4gIHZhciBoID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB4LmRhdGFbaV0pO1xuICB9XG4gIHJldHVybiBoO1xufVxuXG5cbi8vUHJvdmlkZXM6IG5hdF9vZl9hcnJheVxuLy9SZXF1aXJlczogTWxOYXRcbmZ1bmN0aW9uIG5hdF9vZl9hcnJheShsKXtcbiAgcmV0dXJuIG5ldyBNbE5hdChsKTtcbn1cblxuLy9Qcm92aWRlczogY3JlYXRlX25hdFxuLy9SZXF1aXJlczogTWxOYXRcbmZ1bmN0aW9uIGNyZWF0ZV9uYXQoc2l6ZSkge1xuICB2YXIgYXJyID0gbmV3IE1sTmF0KHNpemUpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgYXJyLmRhdGFbaV0gPSAtMTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG4vL1Byb3ZpZGVzOiBzZXRfdG9femVyb19uYXRcbmZ1bmN0aW9uIHNldF90b196ZXJvX25hdChuYXQsIG9mcywgbGVuKSB7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG5hdC5kYXRhW29mcytpXSA9IDA7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGJsaXRfbmF0XG5mdW5jdGlvbiBibGl0X25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyLCBsZW4pIHtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSBuYXQyLmRhdGFbb2ZzMitpXTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogc2V0X2RpZ2l0X25hdFxuZnVuY3Rpb24gc2V0X2RpZ2l0X25hdChuYXQsIG9mcywgZGlnaXQpIHtcbiAgbmF0LmRhdGFbb2ZzXSA9IGRpZ2l0O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbnRoX2RpZ2l0X25hdFxuZnVuY3Rpb24gbnRoX2RpZ2l0X25hdChuYXQsIG9mcykge1xuICByZXR1cm4gbmF0LmRhdGFbb2ZzXTtcbn1cblxuLy9Qcm92aWRlczogc2V0X2RpZ2l0X25hdF9uYXRpdmVcbmZ1bmN0aW9uIHNldF9kaWdpdF9uYXRfbmF0aXZlKG5hdCwgb2ZzLCBkaWdpdCkge1xuICBuYXQuZGF0YVtvZnNdID0gZGlnaXQ7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBudGhfZGlnaXRfbmF0X25hdGl2ZVxuZnVuY3Rpb24gbnRoX2RpZ2l0X25hdF9uYXRpdmUobmF0LCBvZnMpIHtcbiAgcmV0dXJuIG5hdC5kYXRhW29mc107XG59XG5cbi8vUHJvdmlkZXM6IG51bV9kaWdpdHNfbmF0XG5mdW5jdGlvbiBudW1fZGlnaXRzX25hdChuYXQsIG9mcywgbGVuKSB7XG4gIGZvcih2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYobmF0LmRhdGFbb2ZzK2ldICE9IDApIHJldHVybiBpKzE7XG4gIH1cbiAgcmV0dXJuIDE7IC8vIDAgY291bnRzIGFzIDEgZGlnaXRcbn1cblxuLy9Qcm92aWRlczogbnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0XG5mdW5jdGlvbiBudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXQobmF0LCBvZnMpIHtcbiAgdmFyIGEgPSBuYXQuZGF0YVtvZnNdO1xuICB2YXIgYiA9IDA7XG4gIGlmKGEgJiAweEZGRkYwMDAwKSB7IGIgKz0xNjsgYSA+Pj49MTY7IH1cbiAgaWYoYSAmIDB4RkYwMCkgICAgIHsgYiArPSA4OyBhID4+Pj0gODsgfVxuICBpZihhICYgMHhGMCkgICAgICAgeyBiICs9IDQ7IGEgPj4+PSA0OyB9XG4gIGlmKGEgJiAxMikgICAgICAgICB7IGIgKz0gMjsgYSA+Pj49IDI7IH1cbiAgaWYoYSAmIDIpICAgICAgICAgIHsgYiArPSAxOyBhID4+Pj0gMTsgfVxuICBpZihhICYgMSkgICAgICAgICAgeyBiICs9IDE7IH1cbiAgcmV0dXJuIDMyIC0gYjtcbn1cblxuLy9Qcm92aWRlczogaXNfZGlnaXRfaW50XG5mdW5jdGlvbiBpc19kaWdpdF9pbnQobmF0LCBvZnMpIHtcbiAgaWYgKG5hdC5kYXRhW29mc10gPj0gMCkgcmV0dXJuIDFcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGlzX2RpZ2l0X3plcm9cbmZ1bmN0aW9uIGlzX2RpZ2l0X3plcm8obmF0LCBvZnMpIHtcbiAgaWYobmF0LmRhdGFbb2ZzXSA9PSAwKSByZXR1cm4gMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGlzX2RpZ2l0X29kZFxuZnVuY3Rpb24gaXNfZGlnaXRfb2RkKG5hdCwgb2ZzKSB7XG4gIGlmKG5hdC5kYXRhW29mc10gJiAxKSByZXR1cm4gMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGluY3JfbmF0XG5mdW5jdGlvbiBpbmNyX25hdChuYXQsIG9mcywgbGVuLCBjYXJyeV9pbikge1xuICB2YXIgY2FycnkgPSBjYXJyeV9pbjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0LmRhdGFbb2ZzK2ldID4+PiAwKSArIGNhcnJ5O1xuICAgIG5hdC5kYXRhW29mcytpXSA9ICh4IHwgMCk7XG4gICAgaWYoeCA9PSAoeCA+Pj4gMCkpIHtcbiAgICAgIGNhcnJ5ID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYXJyeSA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBjYXJyeTtcbn1cblxuLy8gbGVuMSA+PSBsZW4yXG4vL1Byb3ZpZGVzOiBhZGRfbmF0XG4vL1JlcXVpcmVzOiBpbmNyX25hdFxuZnVuY3Rpb24gYWRkX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBjYXJyeV9pbikge1xuICB2YXIgY2FycnkgPSBjYXJyeV9pbjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjI7IGkrKykge1xuICAgIHZhciB4ID0gKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSArIChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkgKyBjYXJyeTtcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IHhcbiAgICBpZih4ID09ICh4ID4+PiAwKSkge1xuICAgICAgY2FycnkgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYXJyeSA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmNyX25hdChuYXQxLCBvZnMxK2xlbjIsIGxlbjEtbGVuMiwgY2FycnkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wbGVtZW50X25hdFxuZnVuY3Rpb24gY29tcGxlbWVudF9uYXQobmF0LCBvZnMsIGxlbikge1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBuYXQuZGF0YVtvZnMraV0gPSAoLTEgPj4+IDApIC0gKG5hdC5kYXRhW29mcytpXSA+Pj4gMCk7XG4gIH1cbn1cblxuLy8gb2NhbWwgZmxpcHMgY2FycnlfaW5cbi8vUHJvdmlkZXM6IGRlY3JfbmF0XG5mdW5jdGlvbiBkZWNyX25hdChuYXQsIG9mcywgbGVuLCBjYXJyeV9pbikge1xuICB2YXIgYm9ycm93ID0gKGNhcnJ5X2luID09IDEpID8gMCA6IDE7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciB4ID0gKG5hdC5kYXRhW29mcytpXSA+Pj4wKSAtIGJvcnJvdztcbiAgICBuYXQuZGF0YVtvZnMraV0gPSB4O1xuICAgIGlmICh4ID49IDApIHtcbiAgICAgIGJvcnJvdyA9IDA7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgYm9ycm93ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIChib3Jyb3cgPT0gMSkgPyAwIDogMTtcbn1cblxuLy8gb2NhbWwgZmxpcHMgY2FycnlfaW5cbi8vIGxlbjEgPj0gbGVuMlxuLy9Qcm92aWRlczogc3ViX25hdFxuLy9SZXF1aXJlczogZGVjcl9uYXRcbmZ1bmN0aW9uIHN1Yl9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgY2FycnlfaW4pIHtcbiAgdmFyIGJvcnJvdyA9IChjYXJyeV9pbiA9PSAxKSA/IDAgOiAxO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0MS5kYXRhW29mczEraV0gPj4+IDApIC0gKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSAtIGJvcnJvdztcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IHg7XG4gICAgaWYgKHggPj0gMCkge1xuICAgICAgYm9ycm93ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgYm9ycm93ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlY3JfbmF0KG5hdDEsIG9mczErbGVuMiwgbGVuMS1sZW4yLCAoYm9ycm93PT0xKT8wOjEpO1xufVxuXG4vLyBuYXQxICs9IG5hdDIgKiBuYXQzW29mczNdXG4vLyBsZW4xID49IGxlbjJcbi8vUHJvdmlkZXM6IG11bHRfZGlnaXRfbmF0XG4vL1JlcXVpcmVzOiBhZGRfbmF0LCBuYXRfb2ZfYXJyYXlcbmZ1bmN0aW9uIG11bHRfZGlnaXRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIG5hdDMsIG9mczMpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgdmFyIGEgPSAobmF0My5kYXRhW29mczNdID4+PiAwKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjI7IGkrKykge1xuICAgIHZhciB4MSA9IChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgKyAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApICogKGEgJiAweDAwMDBGRkZGKSArIGNhcnJ5O1xuICAgIHZhciB4MiA9IChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkgKiAoYSA+Pj4gMTYpO1xuICAgIGNhcnJ5ID0gTWF0aC5mbG9vcih4Mi82NTUzNik7XG4gICAgdmFyIHgzID0geDEgKyAoeDIgJSA2NTUzNikgKiA2NTUzNjtcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IHgzO1xuICAgIGNhcnJ5ICs9IE1hdGguZmxvb3IoeDMvNDI5NDk2NzI5Nik7XG4gIH1cblxuICBpZihsZW4yIDwgbGVuMSAmJiBjYXJyeSkge1xuICAgIHJldHVybiBhZGRfbmF0KG5hdDEsIG9mczErbGVuMiwgbGVuMS1sZW4yLCBuYXRfb2ZfYXJyYXkoW2NhcnJ5XSksIDAsIDEsIDApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjYXJyeTtcbiAgfVxufVxuXG4vLyBuYXQxICs9IG5hdDIgKiBuYXQzXG4vLyBsZW4xID49IGxlbjIgKyBsZW4zLlxuLy9Qcm92aWRlczogbXVsdF9uYXRcbi8vUmVxdWlyZXM6IG11bHRfZGlnaXRfbmF0XG5mdW5jdGlvbiBtdWx0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXQzLCBvZnMzLCBsZW4zKSB7XG4gIHZhciBjYXJyeSA9IDA7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW4zOyBpKyspIHtcbiAgICBjYXJyeSArPSBtdWx0X2RpZ2l0X25hdChuYXQxLCBvZnMxK2ksIGxlbjEtaSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0Mywgb2ZzMytpKTtcbiAgfVxuICByZXR1cm4gY2Fycnk7XG59XG5cbi8vIG5hdDEgPSAyICogbmF0MSArIG5hdDIgKiBuYXQyXG4vLyBsZW4xID49IDIgKiBsZW4yXG4vL1Byb3ZpZGVzOiBzcXVhcmVfbmF0XG4vL1JlcXVpcmVzOiBtdWx0X25hdCwgYWRkX25hdFxuZnVuY3Rpb24gc3F1YXJlX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yKSB7XG4gIHZhciBjYXJyeSA9IDA7XG4gIGNhcnJ5ICs9IGFkZF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0MSwgb2ZzMSwgbGVuMSwgMCk7XG4gIGNhcnJ5ICs9IG11bHRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIG5hdDIsIG9mczIsIGxlbjIpO1xuICByZXR1cm4gY2Fycnk7XG59XG5cblxuLy8gMCA8PSBzaGlmdCA8IDMyXG4vL1Byb3ZpZGVzOiBzaGlmdF9sZWZ0X25hdFxuZnVuY3Rpb24gc2hpZnRfbGVmdF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbmJpdHMpIHtcbiAgaWYobmJpdHMgPT0gMCkge1xuICAgIG5hdDIuZGF0YVtvZnMyXSA9IDA7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgdmFyIHdyYXAgPSAwO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMTsgaSsrKSB7XG4gICAgdmFyIGEgPSAobmF0MS5kYXRhW29mczEraV0gPj4+IDApO1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0gKGEgPDwgbmJpdHMpIHwgd3JhcDtcbiAgICB3cmFwID0gYSA+Pj4gKDMyIC0gbmJpdHMpO1xuICB9XG4gIG5hdDIuZGF0YVtvZnMyXSA9IHdyYXA7XG4gIHJldHVybiAwO1xufVxuXG4vLyBBc3N1bWluZyBjID4gYSwgcmV0dXJucyBbcXVvdGllbnQsIHJlbWFpbmRlcl0gb2YgKGE8PDMyICsgYikvY1xuLy9Qcm92aWRlczogZGl2X2hlbHBlclxuZnVuY3Rpb24gZGl2X2hlbHBlcihhLCBiLCBjKSB7XG4gIHZhciB4ID0gYSAqIDY1NTM2ICsgKGI+Pj4xNik7XG4gIHZhciB5ID0gTWF0aC5mbG9vcih4L2MpICogNjU1MzY7XG4gIHZhciB6ID0gKHggJSBjKSAqIDY1NTM2O1xuICB2YXIgdyA9IHogKyAoYiAmIDB4MDAwMEZGRkYpO1xuICByZXR1cm4gW3kgKyBNYXRoLmZsb29yKHcvYyksIHcgJSBjXTtcbn1cblxuLy8gbmF0MVtvZnMxK2xlbl0gPCBuYXQyW29mczJdXG4vL1Byb3ZpZGVzOiBkaXZfZGlnaXRfbmF0XG4vL1JlcXVpcmVzOiBkaXZfaGVscGVyXG5mdW5jdGlvbiBkaXZfZGlnaXRfbmF0KG5hdHEsIG9mc3EsIG5hdHIsIG9mc3IsIG5hdDEsIG9mczEsIGxlbiwgbmF0Miwgb2ZzMikge1xuICB2YXIgcmVtID0gKG5hdDEuZGF0YVtvZnMxK2xlbi0xXSA+Pj4wKTtcbiAgLy8gbmF0cVtvZnNxK2xlbi0xXSBpcyBndWFyYW50ZWVkIHRvIGJlIHplcm8gKGR1ZSB0byB0aGUgTVNEIHJlcXVpcmVtZW50KSxcbiAgLy8gYW5kIHNob3VsZCBub3QgYmUgd3JpdHRlbiB0by5cbiAgZm9yKHZhciBpID0gbGVuLTI7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHggPSBkaXZfaGVscGVyKHJlbSwgKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSwgKG5hdDIuZGF0YVtvZnMyXSA+Pj4gMCkpO1xuICAgIG5hdHEuZGF0YVtvZnNxK2ldID0geFswXTtcbiAgICByZW0gPSB4WzFdO1xuICB9XG4gIG5hdHIuZGF0YVtvZnNyXSA9IHJlbTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vIG5hdDFbbmF0MjpdIDo9IG5hdDEgLyBuYXQyXG4vLyBuYXQxWzpuYXQyXSA6PSBuYXQxICUgbmF0MlxuLy8gbGVuMSA+IGxlbjIsIG5hdDJbb2ZzMitsZW4yLTFdID4gbmF0MVtvZnMxK2xlbjEtMV1cbi8vUHJvdmlkZXM6IGRpdl9uYXRcbi8vUmVxdWlyZXM6IGRpdl9kaWdpdF9uYXQsIGRpdl9oZWxwZXIsIG51bV9sZWFkaW5nX3plcm9fYml0c19pbl9kaWdpdCwgc2hpZnRfbGVmdF9uYXQsIHNoaWZ0X3JpZ2h0X25hdCwgY3JlYXRlX25hdCwgc2V0X3RvX3plcm9fbmF0LCBtdWx0X2RpZ2l0X25hdCwgc3ViX25hdCwgY29tcGFyZV9uYXQsIG5hdF9vZl9hcnJheVxuZnVuY3Rpb24gZGl2X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yKSB7XG4gIGlmKGxlbjIgPT0gMSkge1xuICAgIGRpdl9kaWdpdF9uYXQobmF0MSwgb2ZzMSsxLCBuYXQxLCBvZnMxLCBuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyKTtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBzID0gbnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0KG5hdDIsIG9mczIrbGVuMi0xKTtcbiAgc2hpZnRfbGVmdF9uYXQobmF0Miwgb2ZzMiwgbGVuMiwgbmF0X29mX2FycmF5KFswXSksIDAsIHMpO1xuICBzaGlmdF9sZWZ0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXRfb2ZfYXJyYXkoWzBdKSwgMCwgcyk7XG5cbiAgdmFyIGQgPSAobmF0Mi5kYXRhW29mczIrbGVuMi0xXSA+Pj4gMCkgKyAxO1xuICB2YXIgYSA9IGNyZWF0ZV9uYXQobGVuMisxKTtcbiAgZm9yICh2YXIgaSA9IGxlbjEgLSAxOyBpID49IGxlbjI7IGktLSkge1xuICAgIC8vIERlY2VudCBsb3dlciBib3VuZCBvbiBxdW9cbiAgICB2YXIgcXVvID0gZCA9PSA0Mjk0OTY3Mjk2ID8gKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSA6IGRpdl9oZWxwZXIoKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSwgKG5hdDEuZGF0YVtvZnMxK2ktMV0gPj4+MCksIGQpWzBdO1xuICAgIHNldF90b196ZXJvX25hdChhLCAwLCBsZW4yKzEpO1xuICAgIG11bHRfZGlnaXRfbmF0KGEsIDAsIGxlbjIrMSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0X29mX2FycmF5KFtxdW9dKSwgMCk7XG4gICAgc3ViX25hdChuYXQxLCBvZnMxK2ktbGVuMiwgbGVuMisxLCBhLCAwLCBsZW4yKzEsIDEpO1xuXG4gICAgd2hpbGUgKG5hdDEuZGF0YVtvZnMxK2ldICE9IDAgfHwgY29tcGFyZV9uYXQobmF0MSwgb2ZzMStpLWxlbjIsIGxlbjIsIG5hdDIsIG9mczIsIGxlbjIpID49IDApIHtcbiAgICAgIHF1byA9IHF1byArIDE7XG4gICAgICBzdWJfbmF0KG5hdDEsIG9mczEraS1sZW4yLCBsZW4yKzEsIG5hdDIsIG9mczIsIGxlbjIsIDEpO1xuICAgIH1cblxuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0gcXVvO1xuICB9XG5cbiAgc2hpZnRfcmlnaHRfbmF0KG5hdDEsIG9mczEsIGxlbjIsIG5hdF9vZl9hcnJheShbMF0pLCAwLCBzKTsgLy8gc2hpZnQgcmVtYWluZGVyXG4gIHNoaWZ0X3JpZ2h0X25hdChuYXQyLCBvZnMyLCBsZW4yLCBuYXRfb2ZfYXJyYXkoWzBdKSwgMCwgcyk7IC8vIHJlc3RvcmVcbiAgcmV0dXJuIDA7XG59XG5cblxuLy8gMCA8PSBzaGlmdCA8IDMyXG4vL1Byb3ZpZGVzOiBzaGlmdF9yaWdodF9uYXRcbmZ1bmN0aW9uIHNoaWZ0X3JpZ2h0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBuYml0cykge1xuICBpZihuYml0cyA9PSAwKSB7XG4gICAgbmF0Mi5kYXRhW29mczJdID0gMDtcbiAgICByZXR1cm4gMDtcbiAgfVxuICB2YXIgd3JhcCA9IDA7XG4gIGZvcih2YXIgaSA9IGxlbjEtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgYSA9IG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwO1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0gKGEgPj4+IG5iaXRzKSB8IHdyYXA7XG4gICAgd3JhcCA9IGEgPDwgKDMyIC0gbmJpdHMpO1xuICB9XG4gIG5hdDIuZGF0YVtvZnMyXSA9IHdyYXA7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wYXJlX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIGNvbXBhcmVfZGlnaXRzX25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyKSB7XG4gIGlmKG5hdDEuZGF0YVtvZnMxXSA+IG5hdDIuZGF0YVtvZnMyXSkgcmV0dXJuIDE7XG4gIGlmKG5hdDEuZGF0YVtvZnMxXSA8IG5hdDIuZGF0YVtvZnMyXSkgcmV0dXJuIC0xO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY29tcGFyZV9uYXRcbi8vUmVxdWlyZXM6IG51bV9kaWdpdHNfbmF0XG5mdW5jdGlvbiBjb21wYXJlX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yKSB7XG4gIHZhciBhID0gbnVtX2RpZ2l0c19uYXQobmF0MSwgb2ZzMSwgbGVuMSk7XG4gIHZhciBiID0gbnVtX2RpZ2l0c19uYXQobmF0Miwgb2ZzMiwgbGVuMik7XG4gIGlmKGEgPiBiKSByZXR1cm4gMTtcbiAgaWYoYSA8IGIpIHJldHVybiAtMTtcbiAgZm9yKHZhciBpID0gbGVuMSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgPiAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApKSByZXR1cm4gMTtcbiAgICBpZiAoKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSA8IChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkpIHJldHVybiAtMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY29tcGFyZV9uYXRfcmVhbFxuLy9SZXF1aXJlczogY29tcGFyZV9uYXRcbmZ1bmN0aW9uIGNvbXBhcmVfbmF0X3JlYWwobmF0MSxuYXQyKXtcbiAgcmV0dXJuIGNvbXBhcmVfbmF0KG5hdDEsMCxuYXQxLmRhdGEubGVuZ3RoLG5hdDIsMCxuYXQyLmRhdGEubGVuZ3RoKTtcbn1cblxuLy9Qcm92aWRlczogbGFuZF9kaWdpdF9uYXRcbmZ1bmN0aW9uIGxhbmRfZGlnaXRfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIpIHtcbiAgbmF0MS5kYXRhW29mczFdICY9IG5hdDIuZGF0YVtvZnMyXTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGxvcl9kaWdpdF9uYXRcbmZ1bmN0aW9uIGxvcl9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMikge1xuICBuYXQxLmRhdGFbb2ZzMV0gfD0gbmF0Mi5kYXRhW29mczJdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbHhvcl9kaWdpdF9uYXRcbmZ1bmN0aW9uIGx4b3JfZGlnaXRfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIpIHtcbiAgbmF0MS5kYXRhW29mczFdIF49IG5hdDIuZGF0YVtvZnMyXTtcbiAgcmV0dXJuIDA7XG59XG5cblxuLy9Qcm92aWRlczogc2VyaWFsaXplX25hdFxuZnVuY3Rpb24gc2VyaWFsaXplX25hdCh3cml0ZXIsIG5hdCwgc3ope1xuICB2YXIgbGVuID0gbmF0LmRhdGEubGVuZ3RoO1xuICB3cml0ZXIud3JpdGUoMzIsIGxlbik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKyl7XG4gICAgd3JpdGVyLndyaXRlKDMyLCBuYXQuZGF0YVtpXSk7XG4gIH1cbiAgc3pbMF0gPSBsZW4gKiA0O1xuICBzelsxXSA9IGxlbiAqIDg7XG59XG5cbi8vUHJvdmlkZXM6IGRlc2VyaWFsaXplX25hdFxuLy9SZXF1aXJlczogTWxOYXRcbmZ1bmN0aW9uIGRlc2VyaWFsaXplX25hdChyZWFkZXIsIHN6KXtcbiAgdmFyIGxlbiA9IHJlYWRlci5yZWFkMzJzKCk7XG4gIHZhciBuYXQgPSBuZXcgTWxOYXQobGVuKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICBuYXQuZGF0YVtpXSA9IHJlYWRlci5yZWFkMzJzKCk7XG4gIH1cbiAgc3pbMF0gPSBsZW4gKiA0O1xuICByZXR1cm4gbmF0O1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFyc2hhbF9jb25zdGFudHNcbnZhciBjYW1sX21hcnNoYWxfY29uc3RhbnRzID0ge1xuICBQUkVGSVhfU01BTExfQkxPQ0s6ICAgICAgICAgMHg4MCxcbiAgUFJFRklYX1NNQUxMX0lOVDogICAgICAgICAgIDB4NDAsXG4gIFBSRUZJWF9TTUFMTF9TVFJJTkc6ICAgICAgICAweDIwLFxuICBDT0RFX0lOVDg6ICAgICAgICAgICAgICAgICAgMHgwMCxcbiAgQ09ERV9JTlQxNjogICAgICAgICAgICAgICAgIDB4MDEsXG4gIENPREVfSU5UMzI6ICAgICAgICAgICAgICAgICAweDAyLFxuICBDT0RFX0lOVDY0OiAgICAgICAgICAgICAgICAgMHgwMyxcbiAgQ09ERV9TSEFSRUQ4OiAgICAgICAgICAgICAgIDB4MDQsXG4gIENPREVfU0hBUkVEMTY6ICAgICAgICAgICAgICAweDA1LFxuICBDT0RFX1NIQVJFRDMyOiAgICAgICAgICAgICAgMHgwNixcbiAgQ09ERV9CTE9DSzMyOiAgICAgICAgICAgICAgIDB4MDgsXG4gIENPREVfQkxPQ0s2NDogICAgICAgICAgICAgICAweDEzLFxuICBDT0RFX1NUUklORzg6ICAgICAgICAgICAgICAgMHgwOSxcbiAgQ09ERV9TVFJJTkczMjogICAgICAgICAgICAgIDB4MEEsXG4gIENPREVfRE9VQkxFX0JJRzogICAgICAgICAgICAweDBCLFxuICBDT0RFX0RPVUJMRV9MSVRUTEU6ICAgICAgICAgMHgwQyxcbiAgQ09ERV9ET1VCTEVfQVJSQVk4X0JJRzogICAgIDB4MEQsXG4gIENPREVfRE9VQkxFX0FSUkFZOF9MSVRUTEU6ICAweDBFLFxuICBDT0RFX0RPVUJMRV9BUlJBWTMyX0JJRzogICAgMHgwRixcbiAgQ09ERV9ET1VCTEVfQVJSQVkzMl9MSVRUTEU6IDB4MDcsXG4gIENPREVfQ09ERVBPSU5URVI6ICAgICAgICAgICAweDEwLFxuICBDT0RFX0lORklYUE9JTlRFUjogICAgICAgICAgMHgxMSxcbiAgQ09ERV9DVVNUT006ICAgICAgICAgICAgICAgIDB4MTIsXG4gIENPREVfQ1VTVE9NX0xFTjogICAgICAgICAgICAweDE4LFxuICBDT0RFX0NVU1RPTV9GSVhFRDogICAgICAgICAgMHgxOVxufVxuXG5cbi8vUHJvdmlkZXM6IE1sQnl0ZXNSZWFkZXJcbi8vUmVxdWlyZXM6IGNhbWxfbmV3X3N0cmluZywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gTWxCeXRlc1JlYWRlciAocywgaSkgeyB0aGlzLnMgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHMpOyB0aGlzLmkgPSBpOyB9XG5NbEJ5dGVzUmVhZGVyLnByb3RvdHlwZSA9IHtcbiAgcmVhZDh1OmZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucy5jaGFyQ29kZUF0KHRoaXMuaSsrKTsgfSxcbiAgcmVhZDhzOmZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucy5jaGFyQ29kZUF0KHRoaXMuaSsrKSA8PCAyNCA+PiAyNDsgfSxcbiAgcmVhZDE2dTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChzLmNoYXJDb2RlQXQoaSkgPDwgOCkgfCBzLmNoYXJDb2RlQXQoaSArIDEpXG4gIH0sXG4gIHJlYWQxNnM6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyAyO1xuICAgIHJldHVybiAocy5jaGFyQ29kZUF0KGkpIDw8IDI0ID4+IDE2KSB8IHMuY2hhckNvZGVBdChpICsgMSk7XG4gIH0sXG4gIHJlYWQzMnU6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyA0O1xuICAgIHJldHVybiAoKHMuY2hhckNvZGVBdChpKSA8PCAyNCkgfCAocy5jaGFyQ29kZUF0KGkrMSkgPDwgMTYpIHxcbiAgICAgICAgICAgIChzLmNoYXJDb2RlQXQoaSsyKSA8PCA4KSB8IHMuY2hhckNvZGVBdChpKzMpKSA+Pj4gMDtcbiAgfSxcbiAgcmVhZDMyczpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuIChzLmNoYXJDb2RlQXQoaSkgPDwgMjQpIHwgKHMuY2hhckNvZGVBdChpKzEpIDw8IDE2KSB8XG4gICAgICAocy5jaGFyQ29kZUF0KGkrMikgPDwgOCkgfCBzLmNoYXJDb2RlQXQoaSszKTtcbiAgfSxcbiAgcmVhZHN0cjpmdW5jdGlvbiAobGVuKSB7XG4gICAgdmFyIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIGxlbjtcbiAgICByZXR1cm4gY2FtbF9uZXdfc3RyaW5nKHRoaXMucy5zdWJzdHJpbmcoaSwgaSArIGxlbikpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IEJpZ1N0cmluZ1JlYWRlclxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfYXJyYXksIGNhbWxfYmFfZ2V0XzFcbmZ1bmN0aW9uIEJpZ1N0cmluZ1JlYWRlciAoYnMsIGkpIHsgdGhpcy5zID0gYnM7IHRoaXMuaSA9IGk7IH1cbkJpZ1N0cmluZ1JlYWRlci5wcm90b3R5cGUgPSB7XG4gIHJlYWQ4dTpmdW5jdGlvbiAoKSB7IHJldHVybiBjYW1sX2JhX2dldF8xKHRoaXMucyx0aGlzLmkrKyk7IH0sXG4gIHJlYWQ4czpmdW5jdGlvbiAoKSB7IHJldHVybiBjYW1sX2JhX2dldF8xKHRoaXMucyx0aGlzLmkrKykgPDwgMjQgPj4gMjQ7IH0sXG4gIHJlYWQxNnU6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyAyO1xuICAgIHJldHVybiAoY2FtbF9iYV9nZXRfMShzLGkpIDw8IDgpIHwgY2FtbF9iYV9nZXRfMShzLGkgKyAxKVxuICB9LFxuICByZWFkMTZzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKGNhbWxfYmFfZ2V0XzEocyxpKSA8PCAyNCA+PiAxNikgfCBjYW1sX2JhX2dldF8xKHMsaSArIDEpO1xuICB9LFxuICByZWFkMzJ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKChjYW1sX2JhX2dldF8xKHMsaSkgICA8PCAyNCkgfCAoY2FtbF9iYV9nZXRfMShzLGkrMSkgPDwgMTYpIHxcbiAgICAgICAgICAgIChjYW1sX2JhX2dldF8xKHMsaSsyKSA8PCA4KSAgfCBjYW1sX2JhX2dldF8xKHMsaSszKSAgICAgICAgICkgPj4+IDA7XG4gIH0sXG4gIHJlYWQzMnM6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyA0O1xuICAgIHJldHVybiAoY2FtbF9iYV9nZXRfMShzLGkpICAgPDwgMjQpIHwgKGNhbWxfYmFfZ2V0XzEocyxpKzEpIDw8IDE2KSB8XG4gICAgICAoY2FtbF9iYV9nZXRfMShzLGkrMikgPDwgOCkgIHwgY2FtbF9iYV9nZXRfMShzLGkrMyk7XG4gIH0sXG4gIHJlYWRzdHI6ZnVuY3Rpb24gKGxlbikge1xuICAgIHZhciBpID0gdGhpcy5pO1xuICAgIHZhciBhcnIgPSBuZXcgQXJyYXkobGVuKVxuICAgIGZvcih2YXIgaiA9IDA7IGogPCBsZW47IGorKyl7XG4gICAgICBhcnJbal0gPSBjYW1sX2JhX2dldF8xKHRoaXMucywgaStqKTtcbiAgICB9XG4gICAgdGhpcy5pID0gaSArIGxlbjtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYXJyYXkoYXJyKTtcbiAgfVxufVxuXG5cblxuLy9Qcm92aWRlczogY2FtbF9mbG9hdF9vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzLCBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2Zsb2F0X29mX2J5dGVzIChhKSB7XG4gIHJldHVybiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMgKGNhbWxfaW50NjRfb2ZfYnl0ZXMgKGEpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3N0cmluZyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBNbEJ5dGVzUmVhZGVyLCBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyXG5mdW5jdGlvbiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fc3RyaW5nKHMsb2ZzKSB7XG4gIHZhciByZWFkZXIgPSBuZXcgTWxCeXRlc1JlYWRlciAocywgdHlwZW9mIG9mcz09XCJudW1iZXJcIj9vZnM6b2ZzWzBdKTtcbiAgcmV0dXJuIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIocmVhZGVyLCBvZnMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBNbEJ5dGVzUmVhZGVyLCBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyXG5mdW5jdGlvbiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXMocyxvZnMpIHtcbiAgdmFyIHJlYWRlciA9IG5ldyBNbEJ5dGVzUmVhZGVyIChzLCB0eXBlb2Ygb2ZzPT1cIm51bWJlclwiP29mczpvZnNbMF0pO1xuICByZXR1cm4gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlcihyZWFkZXIsIG9mcylcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF91bm1hcnNoYWxcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdW5tYXJzaGFsKHJlYWRlciwgc2l6ZSl7XG4gIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICBzaXplWzBdID0gODtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMgKHQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X21hcnNoYWxcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbWFyc2hhbCh3cml0ZXIsIHYsIHNpemVzKSB7XG4gIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyAodik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB3cml0ZXIud3JpdGUgKDgsIGJbaV0pO1xuICBzaXplc1swXSA9IDg7IHNpemVzWzFdID0gODtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQzMl91bm1hcnNoYWxcbmZ1bmN0aW9uIGNhbWxfaW50MzJfdW5tYXJzaGFsKHJlYWRlciwgc2l6ZSl7XG4gIHNpemVbMF0gPSA0O1xuICByZXR1cm4gcmVhZGVyLnJlYWQzMnMgKCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsKHJlYWRlciwgc2l6ZSl7XG4gIHN3aXRjaCAocmVhZGVyLnJlYWQ4dSAoKSkge1xuICBjYXNlIDE6XG4gICAgc2l6ZVswXSA9IDQ7XG4gICAgcmV0dXJuIHJlYWRlci5yZWFkMzJzICgpO1xuICBjYXNlIDI6XG4gICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBuYXRpdmUgaW50ZWdlciB2YWx1ZSB0b28gbGFyZ2VcIik7XG4gIGRlZmF1bHQ6IGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogaWxsLWZvcm1lZCBuYXRpdmUgaW50ZWdlclwiKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdW5tYXJzaGFsLCBjYW1sX2ludDY0X21hcnNoYWwsIGNhbWxfaW50NjRfY29tcGFyZSwgY2FtbF9pbnQ2NF9oYXNoXG4vL1JlcXVpcmVzOiBjYW1sX2ludDMyX3VubWFyc2hhbCwgY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsXG4vL1JlcXVpcmVzOiBjYW1sX2JhX3NlcmlhbGl6ZSwgY2FtbF9iYV9kZXNlcmlhbGl6ZSwgY2FtbF9iYV9jb21wYXJlLCBjYW1sX2JhX2hhc2hcbnZhciBjYW1sX2N1c3RvbV9vcHMgPVxuICAgIHtcIl9qXCI6IHtcbiAgICAgIGRlc2VyaWFsaXplIDogY2FtbF9pbnQ2NF91bm1hcnNoYWwsXG4gICAgICBzZXJpYWxpemUgIDogY2FtbF9pbnQ2NF9tYXJzaGFsLFxuICAgICAgZml4ZWRfbGVuZ3RoIDogOCxcbiAgICAgIGNvbXBhcmUgOiBjYW1sX2ludDY0X2NvbXBhcmUsXG4gICAgICBoYXNoIDogY2FtbF9pbnQ2NF9oYXNoXG4gICAgfSxcbiAgICAgXCJfaVwiOiB7XG4gICAgICAgZGVzZXJpYWxpemUgOiBjYW1sX2ludDMyX3VubWFyc2hhbCxcbiAgICAgICBmaXhlZF9sZW5ndGggOiA0LFxuICAgICB9LFxuICAgICBcIl9uXCI6IHtcbiAgICAgICBkZXNlcmlhbGl6ZSA6IGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbCxcbiAgICAgICBmaXhlZF9sZW5ndGggOiA0LFxuICAgICB9LFxuICAgICBcIl9iaWdhcnJheVwiOntcbiAgICAgICBkZXNlcmlhbGl6ZSA6IGNhbWxfYmFfZGVzZXJpYWxpemUsXG4gICAgICAgc2VyaWFsaXplIDogY2FtbF9iYV9zZXJpYWxpemUsXG4gICAgICAgY29tcGFyZSA6IGNhbWxfYmFfY29tcGFyZSxcbiAgICAgICBoYXNoOiBjYW1sX2JhX2hhc2gsXG4gICAgIH1cbiAgICB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9SZXF1aXJlczogY2FtbF9mbG9hdF9vZl9ieXRlcywgY2FtbF9jdXN0b21fb3BzXG5cbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIocmVhZGVyLCBvZnMpIHtcbiAgdmFyIF9tYWdpYyA9IHJlYWRlci5yZWFkMzJ1ICgpXG4gIHZhciBfYmxvY2tfbGVuID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gIHZhciBudW1fb2JqZWN0cyA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICB2YXIgX3NpemVfMzIgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgdmFyIF9zaXplXzY0ID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgaW50ZXJuX29ial90YWJsZSA9IChudW1fb2JqZWN0cyA+IDApP1tdOm51bGw7XG4gIHZhciBvYmpfY291bnRlciA9IDA7XG4gIGZ1bmN0aW9uIGludGVybl9yZWMgKCkge1xuICAgIHZhciBjb2RlID0gcmVhZGVyLnJlYWQ4dSAoKTtcbiAgICBpZiAoY29kZSA+PSAweDQwIC8qY3N0LlBSRUZJWF9TTUFMTF9JTlQqLykge1xuICAgICAgaWYgKGNvZGUgPj0gMHg4MCAvKmNzdC5QUkVGSVhfU01BTExfQkxPQ0sqLykge1xuICAgICAgICB2YXIgdGFnID0gY29kZSAmIDB4RjtcbiAgICAgICAgdmFyIHNpemUgPSAoY29kZSA+PiA0KSAmIDB4NztcbiAgICAgICAgdmFyIHYgPSBbdGFnXTtcbiAgICAgICAgaWYgKHNpemUgPT0gMCkgcmV0dXJuIHY7XG4gICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgc3RhY2sucHVzaCh2LCBzaXplKTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9IGVsc2VcbiAgICAgICAgcmV0dXJuIChjb2RlICYgMHgzRik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjb2RlID49IDB4MjAvKmNzdC5QUkVGSVhfU01BTExfU1RSSU5HICovKSB7XG4gICAgICAgIHZhciBsZW4gPSBjb2RlICYgMHgxRjtcbiAgICAgICAgdmFyIHYgPSByZWFkZXIucmVhZHN0ciAobGVuKTtcbiAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaChjb2RlKSB7XG4gICAgICAgIGNhc2UgMHgwMDogLy9jc3QuQ09ERV9JTlQ4OlxuICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZDhzICgpO1xuICAgICAgICBjYXNlIDB4MDE6IC8vY3N0LkNPREVfSU5UMTY6XG4gICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkMTZzICgpO1xuICAgICAgICBjYXNlIDB4MDI6IC8vY3N0LkNPREVfSU5UMzI6XG4gICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkMzJzICgpO1xuICAgICAgICBjYXNlIDB4MDM6IC8vY3N0LkNPREVfSU5UNjQ6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBpbnRlZ2VyIHRvbyBsYXJnZVwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDA0OiAvL2NzdC5DT0RFX1NIQVJFRDg6XG4gICAgICAgICAgdmFyIG9mZnNldCA9IHJlYWRlci5yZWFkOHUgKCk7XG4gICAgICAgICAgcmV0dXJuIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIgLSBvZmZzZXRdO1xuICAgICAgICBjYXNlIDB4MDU6IC8vY3N0LkNPREVfU0hBUkVEMTY6XG4gICAgICAgICAgdmFyIG9mZnNldCA9IHJlYWRlci5yZWFkMTZ1ICgpO1xuICAgICAgICAgIHJldHVybiBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyIC0gb2Zmc2V0XTtcbiAgICAgICAgY2FzZSAweDA2OiAvL2NzdC5DT0RFX1NIQVJFRDMyOlxuICAgICAgICAgIHZhciBvZmZzZXQgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgICAgICAgICByZXR1cm4gaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlciAtIG9mZnNldF07XG4gICAgICAgIGNhc2UgMHgwODogLy9jc3QuQ09ERV9CTE9DSzMyOlxuICAgICAgICAgIHZhciBoZWFkZXIgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgICAgICAgICB2YXIgdGFnID0gaGVhZGVyICYgMHhGRjtcbiAgICAgICAgICB2YXIgc2l6ZSA9IGhlYWRlciA+PiAxMDtcbiAgICAgICAgICB2YXIgdiA9IFt0YWddO1xuICAgICAgICAgIGlmIChzaXplID09IDApIHJldHVybiB2O1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICBzdGFjay5wdXNoKHYsIHNpemUpO1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MTM6IC8vY3N0LkNPREVfQkxPQ0s2NDpcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoIChcImlucHV0X3ZhbHVlOiBkYXRhIGJsb2NrIHRvbyBsYXJnZVwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDA5OiAvL2NzdC5DT0RFX1NUUklORzg6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICB2YXIgdiA9IHJlYWRlci5yZWFkc3RyIChsZW4pO1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBBOiAvL2NzdC5DT0RFX1NUUklORzMyOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICAgIHZhciB2ID0gcmVhZGVyLnJlYWRzdHIgKGxlbik7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEM6IC8vY3N0LkNPREVfRE9VQkxFX0xJVFRMRTpcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IDg7aSsrKSB0WzcgLSBpXSA9IHJlYWRlci5yZWFkOHUgKCk7XG4gICAgICAgICAgdmFyIHYgPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwQjogLy9jc3QuQ09ERV9ET1VCTEVfQklHOlxuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgODtpKyspIHRbaV0gPSByZWFkZXIucmVhZDh1ICgpO1xuICAgICAgICAgIHZhciB2ID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEU6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZOF9MSVRUTEU6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICB2YXIgdiA9IG5ldyBBcnJheShsZW4rMSk7XG4gICAgICAgICAgdlswXSA9IDI1NDtcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxO2kgPD0gbGVuO2krKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0WzcgLSBqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHZbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwRDogLy9jc3QuQ09ERV9ET1VCTEVfQVJSQVk4X0JJRzpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgIHZhciB2ID0gbmV3IEFycmF5KGxlbisxKTtcbiAgICAgICAgICB2WzBdID0gMjU0O1xuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7aSA8PSBsZW47aSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2IFtpXSA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDA3OiAvL2NzdC5DT0RFX0RPVUJMRV9BUlJBWTMyX0xJVFRMRTpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgICAgICB2YXIgdiA9IG5ldyBBcnJheShsZW4rMSk7XG4gICAgICAgICAgdlswXSA9IDI1NDtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxO2kgPD0gbGVuO2krKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0WzcgLSBqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHZbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwRjogLy9jc3QuQ09ERV9ET1VCTEVfQVJSQVkzMl9CSUc6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxO2kgPD0gbGVuO2krKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgICAgdiBbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgxMDogLy9jc3QuQ09ERV9DT0RFUE9JTlRFUjpcbiAgICAgICAgY2FzZSAweDExOiAvL2NzdC5DT0RFX0lORklYUE9JTlRFUjpcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoIChcImlucHV0X3ZhbHVlOiBjb2RlIHBvaW50ZXJcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgxMjogLy9jc3QuQ09ERV9DVVNUT006XG4gICAgICAgIGNhc2UgMHgxODogLy9jc3QuQ09ERV9DVVNUT01fTEVOOlxuICAgICAgICBjYXNlIDB4MTk6IC8vY3N0LkNPREVfQ1VTVE9NX0ZJWEVEOlxuICAgICAgICAgIHZhciBjLCBzID0gXCJcIjtcbiAgICAgICAgICB3aGlsZSAoKGMgPSByZWFkZXIucmVhZDh1ICgpKSAhPSAwKSBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUgKGMpO1xuICAgICAgICAgIHZhciBvcHMgPSBjYW1sX2N1c3RvbV9vcHNbc107XG4gICAgICAgICAgdmFyIGV4cGVjdGVkX3NpemU7XG4gICAgICAgICAgaWYoIW9wcylcbiAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogdW5rbm93biBjdXN0b20gYmxvY2sgaWRlbnRpZmllclwiKTtcbiAgICAgICAgICBzd2l0Y2goY29kZSl7XG4gICAgICAgICAgY2FzZSAweDEyOiAvLyBjc3QuQ09ERV9DVVNUT00gKGRlcHJlY2F0ZWQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDB4MTk6IC8vIGNzdC5DT0RFX0NVU1RPTV9GSVhFRFxuICAgICAgICAgICAgaWYoIW9wcy5maXhlZF9sZW5ndGgpXG4gICAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogZXhwZWN0ZWQgYSBmaXhlZC1zaXplIGN1c3RvbSBibG9ja1wiKTtcbiAgICAgICAgICAgIGV4cGVjdGVkX3NpemUgPSBvcHMuZml4ZWRfbGVuZ3RoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAweDE4OiAvLyBjc3QuQ09ERV9DVVNUT01fTEVOXG4gICAgICAgICAgICBleHBlY3RlZF9zaXplID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgICAgICAgICAvLyBTa2lwIHNpemU2NFxuICAgICAgICAgICAgcmVhZGVyLnJlYWQzMnMoKTsgcmVhZGVyLnJlYWQzMnMoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgb2xkX3BvcyA9IHJlYWRlci5pO1xuICAgICAgICAgIHZhciBzaXplID0gWzBdO1xuICAgICAgICAgIHZhciB2ID0gb3BzLmRlc2VyaWFsaXplKHJlYWRlciwgc2l6ZSk7XG4gICAgICAgICAgaWYoZXhwZWN0ZWRfc2l6ZSAhPSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgaWYoZXhwZWN0ZWRfc2l6ZSAhPSBzaXplWzBdKVxuICAgICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGluY29ycmVjdCBsZW5ndGggb2Ygc2VyaWFsaXplZCBjdXN0b20gYmxvY2tcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoIChcImlucHV0X3ZhbHVlOiBpbGwtZm9ybWVkIG1lc3NhZ2VcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIHJlcyA9IGludGVybl9yZWMgKCk7XG4gIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgdmFyIHNpemUgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgdiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBkID0gdi5sZW5ndGg7XG4gICAgaWYgKGQgPCBzaXplKSBzdGFjay5wdXNoKHYsIHNpemUpO1xuICAgIHZbZF0gPSBpbnRlcm5fcmVjICgpO1xuICB9XG4gIGlmICh0eXBlb2Ygb2ZzIT1cIm51bWJlclwiKSBvZnNbMF0gPSByZWFkZXIuaTtcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCBjYW1sX2J5dGVzX3Vuc2FmZV9nZXRcbmZ1bmN0aW9uIGNhbWxfbWFyc2hhbF9kYXRhX3NpemUgKHMsIG9mcykge1xuICBmdW5jdGlvbiBnZXQzMihzLGkpIHtcbiAgICByZXR1cm4gKGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLCBpKSA8PCAyNCkgfFxuICAgICAgKGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLCBpICsgMSkgPDwgMTYpIHxcbiAgICAgIChjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocywgaSArIDIpIDw8IDgpIHxcbiAgICAgIGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLCBpICsgMyk7XG4gIH1cbiAgaWYgKGdldDMyKHMsIG9mcykgIT0gKDB4ODQ5NUE2QkV8MCkpXG4gICAgY2FtbF9mYWlsd2l0aChcIk1hcnNoYWwuZGF0YV9zaXplOiBiYWQgb2JqZWN0XCIpO1xuICByZXR1cm4gKGdldDMyKHMsIG9mcyArIDQpKTtcbn1cblxuLy9Qcm92aWRlczogTWxPYmplY3RUYWJsZVxudmFyIE1sT2JqZWN0VGFibGU7XG5pZiAodHlwZW9mIGpvb19nbG9iYWxfb2JqZWN0LldlYWtNYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gIE1sT2JqZWN0VGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICAvKiBwb2x5ZmlsbCAodXNpbmcgbGluZWFyIHNlYXJjaCkgKi9cbiAgICBmdW5jdGlvbiBOYWl2ZUxvb2t1cChvYmpzKSB7IHRoaXMub2JqcyA9IG9ianM7IH1cbiAgICBOYWl2ZUxvb2t1cC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24odikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9ianMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMub2Jqc1tpXSA9PT0gdikgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfTtcbiAgICBOYWl2ZUxvb2t1cC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBEbyBub3RoaW5nIGhlcmUuIFtNbE9iamVjdFRhYmxlLnN0b3JlXSB3aWxsIHB1c2ggdG8gW3RoaXMub2Jqc10gZGlyZWN0bHkuXG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBNbE9iamVjdFRhYmxlKCkge1xuICAgICAgdGhpcy5vYmpzID0gW107IHRoaXMubG9va3VwID0gbmV3IE5haXZlTG9va3VwKHRoaXMub2Jqcyk7XG4gICAgfTtcbiAgfSgpO1xufVxuZWxzZSB7XG4gIE1sT2JqZWN0VGFibGUgPSBmdW5jdGlvbiBNbE9iamVjdFRhYmxlKCkge1xuICAgIHRoaXMub2JqcyA9IFtdOyB0aGlzLmxvb2t1cCA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5XZWFrTWFwKCk7XG4gIH07XG59XG5cbk1sT2JqZWN0VGFibGUucHJvdG90eXBlLnN0b3JlID0gZnVuY3Rpb24odikge1xuICB0aGlzLmxvb2t1cC5zZXQodiwgdGhpcy5vYmpzLmxlbmd0aCk7XG4gIHRoaXMub2Jqcy5wdXNoKHYpO1xufVxuXG5NbE9iamVjdFRhYmxlLnByb3RvdHlwZS5yZWNhbGwgPSBmdW5jdGlvbih2KSB7XG4gIHZhciBpID0gdGhpcy5sb29rdXAuZ2V0KHYpO1xuICByZXR1cm4gKGkgPT09IHVuZGVmaW5lZClcbiAgICA/IHVuZGVmaW5lZCA6IHRoaXMub2Jqcy5sZW5ndGggLSBpOyAgIC8qIGluZGV4IGlzIHJlbGF0aXZlICovXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlXG4vL1ZlcnNpb246ID49IDQuMDhcbnZhciBjYW1sX2xlZ2FjeV9jdXN0b21fY29kZSA9IGZhbHNlXG5cbi8vUHJvdmlkZXM6IGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlXG4vL1ZlcnNpb246IDwgNC4wOFxudmFyIGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlID0gdHJ1ZVxuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWxcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXMsIGNhbWxfZmFpbHdpdGhcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdFxuLy9SZXF1aXJlczogTWxCeXRlcywgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0XG4vL1JlcXVpcmVzOiBNbE9iamVjdFRhYmxlLCBjYW1sX2xpc3RfdG9fanNfYXJyYXksIGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlLCBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxudmFyIGNhbWxfb3V0cHV0X3ZhbCA9IGZ1bmN0aW9uICgpe1xuICBmdW5jdGlvbiBXcml0ZXIgKCkgeyB0aGlzLmNodW5rID0gW107IH1cbiAgV3JpdGVyLnByb3RvdHlwZSA9IHtcbiAgICBjaHVua19pZHg6MjAsIGJsb2NrX2xlbjowLCBvYmpfY291bnRlcjowLCBzaXplXzMyOjAsIHNpemVfNjQ6MCxcbiAgICB3cml0ZTpmdW5jdGlvbiAoc2l6ZSwgdmFsdWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSBzaXplIC0gODtpID49IDA7aSAtPSA4KVxuICAgICAgICB0aGlzLmNodW5rW3RoaXMuY2h1bmtfaWR4KytdID0gKHZhbHVlID4+IGkpICYgMHhGRjtcbiAgICB9LFxuICAgIHdyaXRlX2F0OmZ1bmN0aW9uIChwb3MsIHNpemUsIHZhbHVlKSB7XG4gICAgICB2YXIgcG9zID0gcG9zO1xuICAgICAgZm9yICh2YXIgaSA9IHNpemUgLSA4O2kgPj0gMDtpIC09IDgpXG4gICAgICAgIHRoaXMuY2h1bmtbcG9zKytdID0gKHZhbHVlID4+IGkpICYgMHhGRjtcbiAgICB9LFxuICAgIHdyaXRlX2NvZGU6ZnVuY3Rpb24gKHNpemUsIGNvZGUsIHZhbHVlKSB7XG4gICAgICB0aGlzLmNodW5rW3RoaXMuY2h1bmtfaWR4KytdID0gY29kZTtcbiAgICAgIGZvciAodmFyIGkgPSBzaXplIC0gODtpID49IDA7aSAtPSA4KVxuICAgICAgICB0aGlzLmNodW5rW3RoaXMuY2h1bmtfaWR4KytdID0gKHZhbHVlID4+IGkpICYgMHhGRjtcbiAgICB9LFxuICAgIHdyaXRlX3NoYXJlZDpmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICBpZiAob2Zmc2V0IDwgKDEgPDwgOCkpIHRoaXMud3JpdGVfY29kZSg4LCAweDA0IC8qY3N0LkNPREVfU0hBUkVEOCovLCBvZmZzZXQpO1xuICAgICAgZWxzZSBpZiAob2Zmc2V0IDwgKDEgPDwgMTYpKSB0aGlzLndyaXRlX2NvZGUoMTYsIDB4MDUgLypjc3QuQ09ERV9TSEFSRUQxNiovLCBvZmZzZXQpO1xuICAgICAgZWxzZSB0aGlzLndyaXRlX2NvZGUoMzIsIDB4MDYgLypjc3QuQ09ERV9TSEFSRUQzMiovLCBvZmZzZXQpO1xuICAgIH0sXG4gICAgcG9zOmZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY2h1bmtfaWR4IH0sXG4gICAgZmluYWxpemU6ZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5ibG9ja19sZW4gPSB0aGlzLmNodW5rX2lkeCAtIDIwO1xuICAgICAgdGhpcy5jaHVua19pZHggPSAwO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIDB4ODQ5NUE2QkUpO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIHRoaXMuYmxvY2tfbGVuKTtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCB0aGlzLm9ial9jb3VudGVyKTtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCB0aGlzLnNpemVfMzIpO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIHRoaXMuc2l6ZV82NCk7XG4gICAgICByZXR1cm4gdGhpcy5jaHVuaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICh2LCBmbGFncykge1xuICAgIGZsYWdzID0gY2FtbF9saXN0X3RvX2pzX2FycmF5KGZsYWdzKTtcblxuICAgIHZhciBub19zaGFyaW5nID0gKGZsYWdzLmluZGV4T2YoMCAvKk1hcnNoYWwuTm9fc2hhcmluZyovKSAhPT0gLTEpLFxuICAgICAgICBjbG9zdXJlcyA9ICAoZmxhZ3MuaW5kZXhPZigxIC8qTWFyc2hhbC5DbG9zdXJlcyovKSAhPT0gLTEpO1xuICAgICAgICAvKiBNYXJzaGFsLkNvbXBhdF8zMiBpcyByZWR1bmRhbnQgc2luY2UgaW50ZWdlcnMgYXJlIDMyLWJpdCBhbnl3YXkgKi9cblxuICAgIGlmIChjbG9zdXJlcylcbiAgICAgIGpvb19nbG9iYWxfb2JqZWN0LmNvbnNvbGUud2FybihcImluIGNhbWxfb3V0cHV0X3ZhbDogZmxhZyBNYXJzaGFsLkNsb3N1cmVzIGlzIG5vdCBzdXBwb3J0ZWQuXCIpO1xuXG4gICAgdmFyIHdyaXRlciA9IG5ldyBXcml0ZXIgKCk7XG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgdmFyIGludGVybl9vYmpfdGFibGUgPSBub19zaGFyaW5nID8gbnVsbCA6IG5ldyBNbE9iamVjdFRhYmxlKCk7XG5cbiAgICBmdW5jdGlvbiBtZW1vKHYpIHtcbiAgICAgIGlmIChub19zaGFyaW5nKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgZXhpc3Rpbmdfb2Zmc2V0ID0gaW50ZXJuX29ial90YWJsZS5yZWNhbGwodik7XG4gICAgICBpZiAoZXhpc3Rpbmdfb2Zmc2V0KSB7IHdyaXRlci53cml0ZV9zaGFyZWQoZXhpc3Rpbmdfb2Zmc2V0KTsgcmV0dXJuIHRydWU7IH1cbiAgICAgIGVsc2UgeyBpbnRlcm5fb2JqX3RhYmxlLnN0b3JlKHYpOyByZXR1cm4gZmFsc2U7IH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlcm5fcmVjICh2KSB7XG4gICAgICBpZiAodi5jYW1sX2N1c3RvbSB8fCAodiBpbnN0YW5jZW9mIEFycmF5ICYmIHZbMF0gPT09IDI1NSkpIHtcbiAgICAgICAgaWYgKG1lbW8odikpIHJldHVybjtcbiAgICAgICAgdmFyIG5hbWUgPSB2LmNhbWxfY3VzdG9tIHx8IFwiX2pcIjtcbiAgICAgICAgdmFyIG9wcyA9IGNhbWxfY3VzdG9tX29wc1tuYW1lXTtcbiAgICAgICAgdmFyIHN6XzMyXzY0ID0gWzAsMF07XG4gICAgICAgIGlmKCFvcHMuc2VyaWFsaXplKVxuICAgICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIm91dHB1dF92YWx1ZTogYWJzdHJhY3QgdmFsdWUgKEN1c3RvbSlcIik7XG4gICAgICAgIGlmKGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlKSB7XG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDEyIC8qY3N0LkNPREVfQ1VTVE9NKi8pO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgbmFtZS5jaGFyQ29kZUF0KGkpKTtcbiAgICAgICAgICB3cml0ZXIud3JpdGUoOCwgMCk7XG4gICAgICAgICAgb3BzLnNlcmlhbGl6ZSh3cml0ZXIsIHYsIHN6XzMyXzY0KTtcbiAgICAgICAgfSBlbHNlIGlmKG9wcy5maXhlZF9sZW5ndGggPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MTggLypjc3QuQ09ERV9DVVNUT01fTEVOKi8pO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgbmFtZS5jaGFyQ29kZUF0KGkpKTtcbiAgICAgICAgICB3cml0ZXIud3JpdGUoOCwgMCk7XG4gICAgICAgICAgdmFyIGhlYWRlcl9wb3MgPSB3cml0ZXIucG9zICgpO1xuICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICB3cml0ZXIud3JpdGUoOCwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9wcy5zZXJpYWxpemUod3JpdGVyLCB2LCBzel8zMl82NCk7XG4gICAgICAgICAgd3JpdGVyLndyaXRlX2F0KGhlYWRlcl9wb3MsIDMyLCBzel8zMl82NFswXSk7XG4gICAgICAgICAgd3JpdGVyLndyaXRlX2F0KGhlYWRlcl9wb3MgKyA0LCAzMiwgMCk7IC8vIHplcm9cbiAgICAgICAgICB3cml0ZXIud3JpdGVfYXQoaGVhZGVyX3BvcyArIDgsIDMyLCBzel8zMl82NFsxXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDE5IC8qY3N0LkNPREVfQ1VTVE9NX0ZJWEVEKi8pO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgbmFtZS5jaGFyQ29kZUF0KGkpKTtcbiAgICAgICAgICB3cml0ZXIud3JpdGUoOCwgMCk7XG4gICAgICAgICAgdmFyIG9sZF9wb3MgPSB3cml0ZXIucG9zKCk7XG4gICAgICAgICAgb3BzLnNlcmlhbGl6ZSh3cml0ZXIsIHYsIHN6XzMyXzY0KTtcbiAgICAgICAgICBpZiAob3BzLmZpeGVkX2xlbmd0aCAhPSB3cml0ZXIucG9zKCkgLSBvbGRfcG9zKVxuICAgICAgICAgICAgY2FtbF9mYWlsd2l0aChcIm91dHB1dF92YWx1ZTogaW5jb3JyZWN0IGZpeGVkIHNpemVzIHNwZWNpZmllZCBieSBcIiArIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlci5zaXplXzMyICs9IDIgKyAoKHN6XzMyXzY0WzBdICsgMykgPj4gMik7XG4gICAgICAgIHdyaXRlci5zaXplXzY0ICs9IDIgKyAoKHN6XzMyXzY0WzFdICsgNykgPj4gMyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh2IGluc3RhbmNlb2YgQXJyYXkgJiYgdlswXSA9PT0gKHZbMF18MCkpIHtcbiAgICAgICAgaWYgKHZbMF0gPT0gMjUxKSB7XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIm91dHB1dF92YWx1ZTogYWJzdHJhY3QgdmFsdWUgKEFic3RyYWN0KVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodi5sZW5ndGggPiAxICYmIG1lbW8odikpIHJldHVybjtcbiAgICAgICAgaWYgKHZbMF0gPCAxNiAmJiB2Lmxlbmd0aCAtIDEgPCA4KVxuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHg4MCAvKmNzdC5QUkVGSVhfU01BTExfQkxPQ0sqLyArIHZbMF0gKyAoKHYubGVuZ3RoIC0gMSk8PDQpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlKDMyLCAweDA4IC8qY3N0LkNPREVfQkxPQ0szMiovLCAoKHYubGVuZ3RoLTEpIDw8IDEwKSB8IHZbMF0pO1xuICAgICAgICB3cml0ZXIuc2l6ZV8zMiArPSB2Lmxlbmd0aDtcbiAgICAgICAgd3JpdGVyLnNpemVfNjQgKz0gdi5sZW5ndGg7XG4gICAgICAgIGlmICh2Lmxlbmd0aCA+IDEpIHN0YWNrLnB1c2ggKHYsIDEpO1xuICAgICAgfSBlbHNlIGlmICh2IGluc3RhbmNlb2YgTWxCeXRlcykge1xuICAgICAgICBpZiAobWVtbyh2KSkgcmV0dXJuO1xuICAgICAgICB2YXIgbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHYpO1xuICAgICAgICBpZiAobGVuIDwgMHgyMClcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MjAgLypjc3QuUFJFRklYX1NNQUxMX1NUUklORyovICsgbGVuKTtcbiAgICAgICAgZWxzZSBpZiAobGVuIDwgMHgxMDApXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUgKDgsIDB4MDkvKmNzdC5DT0RFX1NUUklORzgqLywgbGVuKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlICgzMiwgMHgwQSAvKmNzdC5DT0RFX1NUUklORzMyKi8sIGxlbik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwO2kgPCBsZW47aSsrKVxuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldCh2LGkpKTtcbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gMSArICgoKGxlbiArIDQpIC8gNCl8MCk7XG4gICAgICAgIHdyaXRlci5zaXplXzY0ICs9IDEgKyAoKChsZW4gKyA4KSAvIDgpfDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHYgIT0gKHZ8MCkpe1xuICAgICAgICAgIHZhciB0eXBlX29mX3YgPSB0eXBlb2YgdjtcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIElmIGEgZmxvYXQgaGFwcGVucyB0byBiZSBhbiBpbnRlZ2VyIGl0IGlzIHNlcmlhbGl6ZWQgYXMgYW4gaW50ZWdlclxuICAgICAgICAgIC8vIChKc19vZl9vY2FtbCBjYW5ub3QgdGVsbCB3aGV0aGVyIHRoZSB0eXBlIG9mIGFuIGludGVnZXIgbnVtYmVyIGlzXG4gICAgICAgICAgLy8gZmxvYXQgb3IgaW50ZWdlci4pIFRoaXMgY2FuIHJlc3VsdCBpbiB1bmV4cGVjdGVkIGNyYXNoZXMgd2hlblxuICAgICAgICAgIC8vIHVubWFyc2hhbGxpbmcgdXNpbmcgdGhlIHN0YW5kYXJkIHJ1bnRpbWUuIEl0IHNlZW1zIGJldHRlciB0b1xuICAgICAgICAgIC8vIHN5c3RlbWF0aWNhbGx5IGZhaWwgb24gbWFyc2hhbGxpbmcuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyAgICAgICAgICBpZih0eXBlX29mX3YgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBhYnN0cmFjdCB2YWx1ZSAoXCIrdHlwZV9vZl92K1wiKVwiKTtcbiAgICAgICAgICAvLyAgICAgICAgICB2YXIgdCA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KHYpKTtcbiAgICAgICAgICAvLyAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MEIgLypjc3QuQ09ERV9ET1VCTEVfQklHKi8pO1xuICAgICAgICAgIC8vICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGk8ODsgaSsrKXt3cml0ZXIud3JpdGUoOCx0W2ldKX1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ID49IDAgJiYgdiA8IDB4NDApIHtcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDBYNDAgLypjc3QuUFJFRklYX1NNQUxMX0lOVCovICsgdik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHYgPj0gLSgxIDw8IDcpICYmIHYgPCAoMSA8PCA3KSlcbiAgICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlKDgsIDB4MDAgLypjc3QuQ09ERV9JTlQ4Ki8sIHYpO1xuICAgICAgICAgIGVsc2UgaWYgKHYgPj0gLSgxIDw8IDE1KSAmJiB2IDwgKDEgPDwgMTUpKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoMTYsIDB4MDEgLypjc3QuQ09ERV9JTlQxNiovLCB2KTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSgzMiwgMHgwMiAvKmNzdC5DT0RFX0lOVDMyKi8sIHYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGV4dGVybl9yZWMgKHYpO1xuICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgaSA9IHN0YWNrLnBvcCAoKTtcbiAgICAgIHZhciB2ID0gc3RhY2sucG9wICgpO1xuICAgICAgaWYgKGkgKyAxIDwgdi5sZW5ndGgpIHN0YWNrLnB1c2ggKHYsIGkgKyAxKTtcbiAgICAgIGV4dGVybl9yZWMgKHZbaV0pO1xuICAgIH1cbiAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgd3JpdGVyLm9ial9jb3VudGVyID0gaW50ZXJuX29ial90YWJsZS5vYmpzLmxlbmd0aDtcbiAgICB3cml0ZXIuZmluYWxpemUoKTtcbiAgICByZXR1cm4gd3JpdGVyLmNodW5rO1xuICB9XG59ICgpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsLCBjYW1sX3N0cmluZ19vZl9hcnJheVxuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nICh2LCBmbGFncykge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYXJyYXkgKGNhbWxfb3V0cHV0X3ZhbCAodiwgZmxhZ3MpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnl0ZXMgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsLCBjYW1sX3N0cmluZ19vZl9hcnJheVxuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnl0ZXMgKHYsIGZsYWdzKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9hcnJheSAoY2FtbF9vdXRwdXRfdmFsICh2LCBmbGFncykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWx1ZV90b19idWZmZXJcbi8vUmVxdWlyZXM6IGNhbWxfb3V0cHV0X3ZhbCwgY2FtbF9mYWlsd2l0aCwgY2FtbF9ibGl0X2J5dGVzXG5mdW5jdGlvbiBjYW1sX291dHB1dF92YWx1ZV90b19idWZmZXIgKHMsIG9mcywgbGVuLCB2LCBmbGFncykge1xuICB2YXIgdCA9IGNhbWxfb3V0cHV0X3ZhbCAodiwgZmxhZ3MpO1xuICBpZiAodC5sZW5ndGggPiBsZW4pIGNhbWxfZmFpbHdpdGggKFwiTWFyc2hhbC50b19idWZmZXI6IGJ1ZmZlciBvdmVyZmxvd1wiKTtcbiAgY2FtbF9ibGl0X2J5dGVzKHQsIDAsIHMsIG9mcywgdC5sZW5ndGgpO1xuICByZXR1cm4gMDtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSW9cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY2xvc2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfc3lzX2Nsb3NlKGZkKSB7XG4gIGRlbGV0ZSBjYW1sX2dsb2JhbF9kYXRhLmZkc1tmZF07XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0ZF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfbmV3X3N0cmluZywgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX3N0ZF9vdXRwdXQoY2hhbmlkLHMpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgdmFyIHN0ciA9IGNhbWxfbmV3X3N0cmluZyhzKTtcbiAgdmFyIHNsZW4gPSBjYW1sX21sX3N0cmluZ19sZW5ndGgoc3RyKTtcbiAgY2hhbi5maWxlLndyaXRlKGNoYW4ub2Zmc2V0LCBzdHIsIDAsIHNsZW4pO1xuICBjaGFuLm9mZnNldCArPSBzbGVuO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfb3BlblxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfZ2xvYmFsX2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfY3JlYXRlX2J5dGVzLE1sRmFrZUZpbGVcbi8vUmVxdWlyZXM6IGpzX3ByaW50X3N0ZGVyciwganNfcHJpbnRfc3Rkb3V0XG4vL1JlcXVpcmVzOiBjYW1sX3N0ZF9vdXRwdXRcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19vcGVuX2ludGVybmFsKGlkeCxvdXRwdXQsZmlsZSxmbGFncykge1xuICBpZihjYW1sX2dsb2JhbF9kYXRhLmZkcyA9PT0gdW5kZWZpbmVkKSBjYW1sX2dsb2JhbF9kYXRhLmZkcyA9IG5ldyBBcnJheSgpO1xuICBmbGFncz1mbGFncz9mbGFnczp7fTtcbiAgdmFyIGluZm8gPSB7fTtcbiAgaW5mby5maWxlID0gZmlsZTtcbiAgaW5mby5vZmZzZXQgPSBmbGFncy5hcHBlbmQ/ZmlsZS5sZW5ndGgoKTowO1xuICBpbmZvLmZsYWdzID0gZmxhZ3M7XG4gIGluZm8ub3V0cHV0ID0gb3V0cHV0O1xuICBjYW1sX2dsb2JhbF9kYXRhLmZkc1tpZHhdID0gaW5mbztcbiAgaWYoIWNhbWxfZ2xvYmFsX2RhdGEuZmRfbGFzdF9pZHggfHwgaWR4ID4gY2FtbF9nbG9iYWxfZGF0YS5mZF9sYXN0X2lkeClcbiAgICBjYW1sX2dsb2JhbF9kYXRhLmZkX2xhc3RfaWR4ID0gaWR4O1xuICByZXR1cm4gaWR4O1xufVxuZnVuY3Rpb24gY2FtbF9zeXNfb3BlbiAobmFtZSwgZmxhZ3MsIF9wZXJtcykge1xuICB2YXIgZiA9IHt9O1xuICB3aGlsZShmbGFncyl7XG4gICAgc3dpdGNoKGZsYWdzWzFdKXtcbiAgICBjYXNlIDA6IGYucmRvbmx5ID0gMTticmVhaztcbiAgICBjYXNlIDE6IGYud3Jvbmx5ID0gMTticmVhaztcbiAgICBjYXNlIDI6IGYuYXBwZW5kID0gMTticmVhaztcbiAgICBjYXNlIDM6IGYuY3JlYXRlID0gMTticmVhaztcbiAgICBjYXNlIDQ6IGYudHJ1bmNhdGUgPSAxO2JyZWFrO1xuICAgIGNhc2UgNTogZi5leGNsID0gMTsgYnJlYWs7XG4gICAgY2FzZSA2OiBmLmJpbmFyeSA9IDE7YnJlYWs7XG4gICAgY2FzZSA3OiBmLnRleHQgPSAxO2JyZWFrO1xuICAgIGNhc2UgODogZi5ub25ibG9jayA9IDE7YnJlYWs7XG4gICAgfVxuICAgIGZsYWdzPWZsYWdzWzJdO1xuICB9XG4gIGlmKGYucmRvbmx5ICYmIGYud3Jvbmx5KVxuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKG5hbWUudG9TdHJpbmcoKSArIFwiIDogZmxhZ3MgT3Blbl9yZG9ubHkgYW5kIE9wZW5fd3Jvbmx5IGFyZSBub3QgY29tcGF0aWJsZVwiKTtcbiAgaWYoZi50ZXh0ICYmIGYuYmluYXJ5KVxuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKG5hbWUudG9TdHJpbmcoKSArIFwiIDogZmxhZ3MgT3Blbl90ZXh0IGFuZCBPcGVuX2JpbmFyeSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBmaWxlID0gcm9vdC5kZXZpY2Uub3Blbihyb290LnJlc3QsZik7XG4gIHZhciBpZHggPSBjYW1sX2dsb2JhbF9kYXRhLmZkX2xhc3RfaWR4P2NhbWxfZ2xvYmFsX2RhdGEuZmRfbGFzdF9pZHg6MDtcbiAgcmV0dXJuIGNhbWxfc3lzX29wZW5faW50ZXJuYWwgKGlkeCsxLGNhbWxfc3RkX291dHB1dCxmaWxlLGYpO1xufVxuY2FtbF9zeXNfb3Blbl9pbnRlcm5hbCgwLGNhbWxfc3RkX291dHB1dCwgbmV3IE1sRmFrZUZpbGUoY2FtbF9jcmVhdGVfYnl0ZXMoMCkpKTsgLy9zdGRpblxuY2FtbF9zeXNfb3Blbl9pbnRlcm5hbCgxLGpzX3ByaW50X3N0ZG91dCwgbmV3IE1sRmFrZUZpbGUoY2FtbF9jcmVhdGVfYnl0ZXMoMCkpKTsgLy9zdGRvdXRcbmNhbWxfc3lzX29wZW5faW50ZXJuYWwoMixqc19wcmludF9zdGRlcnIsIG5ldyBNbEZha2VGaWxlKGNhbWxfY3JlYXRlX2J5dGVzKDApKSk7IC8vc3RkZXJyXG5cblxuLy8gb2NhbWwgQ2hhbm5lbHNcblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lXG5mdW5jdGlvbiBjYW1sX21sX3NldF9jaGFubmVsX25hbWUoKSB7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbHNcbnZhciBjYW1sX21sX2NoYW5uZWxzID0gbmV3IEFycmF5KCk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0X2NoYW5uZWxzX2xpc3Rcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0X2NoYW5uZWxzX2xpc3QgKCkge1xuICB2YXIgbCA9IDA7XG4gIGZvcih2YXIgYyA9IDA7IGMgPCBjYW1sX21sX2NoYW5uZWxzLmxlbmd0aDsgYysrKXtcbiAgICBpZihjYW1sX21sX2NoYW5uZWxzW2NdICYmIGNhbWxfbWxfY2hhbm5lbHNbY10ub3BlbmVkICYmIGNhbWxfbWxfY2hhbm5lbHNbY10ub3V0KVxuICAgICAgbD1bMCxjYW1sX21sX2NoYW5uZWxzW2NdLmZkLGxdO1xuICB9XG4gIHJldHVybiBsO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVscywgY2FtbF9nbG9iYWxfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dCAoZmQpIHtcbiAgdmFyIGRhdGEgPSBjYW1sX2dsb2JhbF9kYXRhLmZkc1tmZF07XG4gIGlmKGRhdGEuZmxhZ3MucmRvbmx5KSBjYW1sX3JhaXNlX3N5c19lcnJvcihcImZkIFwiKyBmZCArIFwiIGlzIHJlYWRvbmx5XCIpO1xuICB2YXIgY2hhbm5lbCA9IHtcbiAgICBmaWxlOmRhdGEuZmlsZSxcbiAgICBvZmZzZXQ6ZGF0YS5vZmZzZXQsXG4gICAgZmQ6ZmQsXG4gICAgb3BlbmVkOnRydWUsXG4gICAgb3V0OnRydWUsXG4gICAgYnVmZmVyOlwiXCJcbiAgfTtcbiAgY2FtbF9tbF9jaGFubmVsc1tjaGFubmVsLmZkXT1jaGFubmVsO1xuICByZXR1cm4gY2hhbm5lbC5mZDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW5cbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsY2FtbF9zeXNfb3BlbixjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW4gKGZkKSAge1xuICB2YXIgZGF0YSA9IGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2ZkXTtcbiAgaWYoZGF0YS5mbGFncy53cm9ubHkpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiZmQgXCIrIGZkICsgXCIgaXMgd3JpdGVvbmx5XCIpO1xuXG4gIHZhciBjaGFubmVsID0ge1xuICAgIGZpbGU6ZGF0YS5maWxlLFxuICAgIG9mZnNldDpkYXRhLm9mZnNldCxcbiAgICBmZDpmZCxcbiAgICBvcGVuZWQ6dHJ1ZSxcbiAgICBvdXQ6IGZhbHNlLFxuICAgIHJlZmlsbDpudWxsXG4gIH07XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbm5lbC5mZF09Y2hhbm5lbDtcbiAgcmV0dXJuIGNoYW5uZWwuZmQ7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZXRfYmluYXJ5X21vZGVcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2JpbmFyeV9tb2RlKGNoYW5pZCxtb2RlKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciBkYXRhID0gY2FtbF9nbG9iYWxfZGF0YS5mZHNbY2hhbi5mZF07XG4gIGRhdGEuZmxhZ3MudGV4dCA9ICFtb2RlXG4gIGRhdGEuZmxhZ3MuYmluYXJ5ID0gbW9kZVxuICByZXR1cm4gMDtcbn1cblxuLy9JbnB1dCBmcm9tIGluX2NoYW5uZWxcblxuLy9Qcm92aWRlczogY2FtbF9tbF9jbG9zZV9jaGFubmVsXG4vL1JlcXVpcmVzOiBjYW1sX21sX2ZsdXNoLCBjYW1sX21sX2NoYW5uZWxzXG4vL1JlcXVpcmVzOiBjYW1sX3N5c19jbG9zZVxuZnVuY3Rpb24gY2FtbF9tbF9jbG9zZV9jaGFubmVsIChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGNhbWxfbWxfZmx1c2goY2hhbmlkKTtcbiAgY2hhbi5vcGVuZWQgPSBmYWxzZTtcbiAgY2hhbi5maWxlLmNsb3NlKCk7XG4gIGNhbWxfc3lzX2Nsb3NlKGNoYW4uZmQpXG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2NoYW5uZWxfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9jaGFubmVsX3NpemUoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICByZXR1cm4gY2hhbi5maWxlLmxlbmd0aCgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2NoYW5uZWxfc2l6ZV82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9mbG9hdCxjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2NoYW5uZWxfc2l6ZV82NChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2Zsb2F0KGNoYW4uZmlsZS5sZW5ndGggKCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9jaGFubmVsX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVscywgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9tbF9zZXRfY2hhbm5lbF9vdXRwdXQoY2hhbmlkLGYpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2NoYW4uZmRdLm91dHB1dCA9IGY7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9jaGFubmVsX3JlZmlsbFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVscywgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9tbF9zZXRfY2hhbm5lbF9yZWZpbGwoY2hhbmlkLGYpIHtcbiAgY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLnJlZmlsbCA9IGY7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3JlZmlsbF9pbnB1dFxuLy9SZXF1aXJlczogY2FtbF9tbF9ieXRlc19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfbWxfcmVmaWxsX2lucHV0IChjaGFuKSB7XG4gIHZhciBzdHIgPSBjaGFuLnJlZmlsbCgpO1xuICB2YXIgc3RyX2xlbiA9IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHN0cik7XG4gIGlmIChzdHJfbGVuID09IDApIGNoYW4ucmVmaWxsID0gbnVsbDtcbiAgY2hhbi5maWxlLndyaXRlKGNoYW4uZmlsZS5sZW5ndGgoKSwgc3RyLCAwLCBzdHJfbGVuKTtcbiAgcmV0dXJuIHN0cl9sZW47XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dFxuLy9SZXF1aXJlczogY2FtbF9tbF9yZWZpbGxfaW5wdXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dCAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBpZiAoY2hhbi5yZWZpbGwgPT0gbnVsbCkgcmV0dXJuO1xuICBpZiAoY2hhbi5maWxlLmxlbmd0aCgpICE9IGNoYW4ub2Zmc2V0KSByZXR1cm47XG4gIGNhbWxfbWxfcmVmaWxsX2lucHV0IChjaGFuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dFxuLy9SZXF1aXJlczogY2FtbF9tbF9yZWZpbGxfaW5wdXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfaW5wdXQgKGNoYW5pZCwgcywgaSwgbCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgdmFyIGwyID0gY2hhbi5maWxlLmxlbmd0aCgpIC0gY2hhbi5vZmZzZXQ7XG4gIGlmIChsMiA9PSAwICYmIGNoYW4ucmVmaWxsICE9IG51bGwpIGwyID0gY2FtbF9tbF9yZWZpbGxfaW5wdXQoY2hhbik7XG4gIGlmIChsMiA8IGwpIGwgPSBsMjtcbiAgY2hhbi5maWxlLnJlYWQoY2hhbi5vZmZzZXQsIHMsIGksIGwpO1xuICBjaGFuLm9mZnNldCArPSBsO1xuICByZXR1cm4gbDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnB1dF92YWx1ZVxuLy9SZXF1aXJlczogY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSwgY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3N0cmluZywgY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWUgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcblxuICB2YXIgYnVmID0gY2FtbF9jcmVhdGVfYnl0ZXMoOCk7XG4gIGNoYW4uZmlsZS5yZWFkKGNoYW4ub2Zmc2V0LGJ1ZiwwLDgpO1xuXG4gIC8vIEhlYWRlciBpcyAyMCBieXRlc1xuICB2YXIgbGVuID0gY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSAoYnVmLCAwKSArIDIwO1xuXG4gIHZhciBidWYgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICBjaGFuLmZpbGUucmVhZChjaGFuLm9mZnNldCxidWYsMCxsZW4pO1xuXG4gIHZhciBvZmZzZXQgPSBbMF07XG4gIHZhciByZXMgPSBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fc3RyaW5nKGJ1Ziwgb2Zmc2V0KTtcbiAgY2hhbi5vZmZzZXQgPSBjaGFuLm9mZnNldCArIG9mZnNldFswXTtcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dF9jaGFyXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlLCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX21heV9yZWZpbGxfaW5wdXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfaW5wdXRfY2hhciAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBjYW1sX21sX21heV9yZWZpbGxfaW5wdXQoY2hhbmlkKTtcbiAgaWYgKGNoYW4ub2Zmc2V0ID49IGNoYW4uZmlsZS5sZW5ndGgoKSlcbiAgICBjYW1sX3JhaXNlX2VuZF9vZl9maWxlKCk7XG4gIHZhciByZXMgPSBjaGFuLmZpbGUucmVhZF9vbmUoY2hhbi5vZmZzZXQpO1xuICBjaGFuLm9mZnNldCsrO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0X2ludFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9tbF9yZWZpbGxfaW5wdXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfaW5wdXRfaW50IChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciBmaWxlID0gY2hhbi5maWxlO1xuICB3aGlsZSAoKGNoYW4ub2Zmc2V0ICsgMykgPj0gZmlsZS5sZW5ndGgoKSkge1xuICAgIHZhciBsID0gY2FtbF9tbF9yZWZpbGxfaW5wdXQoY2hhbik7XG4gICAgaWYgKGwgPT0gMCkgY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSgpO1xuICB9XG4gIHZhciBvID0gY2hhbi5vZmZzZXQ7XG4gIHZhciByID0oZmlsZS5yZWFkX29uZShvICApIDw8IDI0KVxuICAgICAgfCAgKGZpbGUucmVhZF9vbmUobysxKSA8PCAxNilcbiAgICAgIHwgIChmaWxlLnJlYWRfb25lKG8rMikgPDwgOClcbiAgICAgIHwgIChmaWxlLnJlYWRfb25lKG8rMykpO1xuICBjaGFuLm9mZnNldCs9NDtcbiAgcmV0dXJuIHI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19pblxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19pbihjaGFuaWQscG9zKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGlmIChjaGFuLnJlZmlsbCAhPSBudWxsKSBjYW1sX3JhaXNlX3N5c19lcnJvcihcIklsbGVnYWwgc2Vla1wiKTtcbiAgY2hhbi5vZmZzZXQgPSBwb3M7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NlZWtfaW5fNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fZmxvYXQsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3NlZWtfaW5fNjQoY2hhbmlkLHBvcyl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBpZiAoY2hhbi5yZWZpbGwgIT0gbnVsbCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJJbGxlZ2FsIHNlZWtcIik7XG4gIGNoYW4ub2Zmc2V0ID0gY2FtbF9pbnQ2NF90b19mbG9hdChwb3MpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9wb3NfaW5cbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX2luKGNoYW5pZCkge3JldHVybiBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ub2Zmc2V0fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19pbl82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9mbG9hdCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9wb3NfaW5fNjQoY2hhbmlkKSB7cmV0dXJuIGNhbWxfaW50NjRfb2ZfZmxvYXQoY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldCl9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRfc2Nhbl9saW5lXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX21heV9yZWZpbGxfaW5wdXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfaW5wdXRfc2Nhbl9saW5lKGNoYW5pZCl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBjYW1sX21sX21heV9yZWZpbGxfaW5wdXQoY2hhbmlkKTtcbiAgdmFyIHAgPSBjaGFuLm9mZnNldDtcbiAgdmFyIGxlbiA9IGNoYW4uZmlsZS5sZW5ndGgoKTtcbiAgaWYocCA+PSBsZW4pIHsgcmV0dXJuIDA7fVxuICB3aGlsZSh0cnVlKSB7XG4gICAgaWYocCA+PSBsZW4pIHJldHVybiAtIChwIC0gY2hhbi5vZmZzZXQpO1xuICAgIGlmKGNoYW4uZmlsZS5yZWFkX29uZShwKSA9PSAxMCkgcmV0dXJuIHAgLSBjaGFuLm9mZnNldCArIDE7XG4gICAgcCsrO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZmx1c2hcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX2dsb2JhbF9kYXRhLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2ZsdXNoIChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGlmKCEgY2hhbi5vcGVuZWQpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiQ2Fubm90IGZsdXNoIGEgY2xvc2VkIGNoYW5uZWxcIik7XG4gIGlmKCFjaGFuLmJ1ZmZlciB8fCBjaGFuLmJ1ZmZlciA9PSBcIlwiKSByZXR1cm4gMDtcbiAgaWYoY2hhbi5mZFxuICAgICAmJiBjYW1sX2dsb2JhbF9kYXRhLmZkc1tjaGFuLmZkXVxuICAgICAmJiBjYW1sX2dsb2JhbF9kYXRhLmZkc1tjaGFuLmZkXS5vdXRwdXQpIHtcbiAgICB2YXIgb3V0cHV0ID0gY2FtbF9nbG9iYWxfZGF0YS5mZHNbY2hhbi5mZF0ub3V0cHV0O1xuICAgIHN3aXRjaChvdXRwdXQubGVuZ3RoKXtcbiAgICBjYXNlIDI6IG91dHB1dChjaGFuaWQsY2hhbi5idWZmZXIpO2JyZWFrO1xuICAgIGRlZmF1bHQ6IG91dHB1dChjaGFuLmJ1ZmZlcilcbiAgICB9O1xuICB9XG4gIGNoYW4uYnVmZmVyID0gXCJcIjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vb3V0cHV0IHRvIG91dF9jaGFubmVsXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0X2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX21sX2ZsdXNoLGNhbWxfbWxfYnl0ZXNfbGVuZ3RoXG4vL1JlcXVpcmVzOiBjYW1sX2NyZWF0ZV9ieXRlcywgY2FtbF9ibGl0X2J5dGVzLCBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9tbF9jaGFubmVscywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXRfYnl0ZXMoY2hhbmlkLGJ1ZmZlcixvZmZzZXQsbGVuKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBpZighIGNoYW4ub3BlbmVkKSBjYW1sX3JhaXNlX3N5c19lcnJvcihcIkNhbm5vdCBvdXRwdXQgdG8gYSBjbG9zZWQgY2hhbm5lbFwiKTtcbiAgdmFyIHN0cmluZztcbiAgaWYob2Zmc2V0ID09IDAgJiYgY2FtbF9tbF9ieXRlc19sZW5ndGgoYnVmZmVyKSA9PSBsZW4pXG4gICAgc3RyaW5nID0gYnVmZmVyO1xuICBlbHNlIHtcbiAgICBzdHJpbmcgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICAgIGNhbWxfYmxpdF9ieXRlcyhidWZmZXIsb2Zmc2V0LHN0cmluZywwLGxlbik7XG4gIH1cbiAgdmFyIGpzc3RyaW5nID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzdHJpbmcpO1xuICB2YXIgaWQgPSBqc3N0cmluZy5sYXN0SW5kZXhPZihcIlxcblwiKTtcbiAgaWYoaWQgPCAwKVxuICAgIGNoYW4uYnVmZmVyKz1qc3N0cmluZztcbiAgZWxzZSB7XG4gICAgY2hhbi5idWZmZXIrPWpzc3RyaW5nLnN1YnN0cigwLGlkKzEpO1xuICAgIGNhbWxfbWxfZmx1c2ggKGNoYW5pZCk7XG4gICAgY2hhbi5idWZmZXIgKz0ganNzdHJpbmcuc3Vic3RyKGlkKzEpO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9tbF9vdXRwdXRfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0KGNoYW5pZCxidWZmZXIsb2Zmc2V0LGxlbil7XG4gIHJldHVybiBjYW1sX21sX291dHB1dF9ieXRlcyhjaGFuaWQsYnVmZmVyLG9mZnNldCxsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dHB1dF9jaGFyXG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9uZXdfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX21sX291dHB1dF9jaGFyIChjaGFuaWQsYykge1xuICB2YXIgcyA9IGNhbWxfbmV3X3N0cmluZyhTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgY2FtbF9tbF9vdXRwdXQoY2hhbmlkLHMsMCwxKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcsIGNhbWxfbWxfb3V0cHV0LGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWUgKGNoYW5pZCx2LGZsYWdzKSB7XG4gIHZhciBzID0gY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nKHYsIGZsYWdzKTtcbiAgY2FtbF9tbF9vdXRwdXQoY2hhbmlkLHMsMCxjYW1sX21sX3N0cmluZ19sZW5ndGgocykpO1xuICByZXR1cm4gMDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NlZWtfb3V0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX21sX2ZsdXNoXG5mdW5jdGlvbiBjYW1sX21sX3NlZWtfb3V0KGNoYW5pZCxwb3Mpe1xuICBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXQgPSBwb3M7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NlZWtfb3V0XzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2Zsb2F0LCBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX21sX2ZsdXNoXG5mdW5jdGlvbiBjYW1sX21sX3NlZWtfb3V0XzY0KGNoYW5pZCxwb3Mpe1xuICBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXQgPSBjYW1sX2ludDY0X3RvX2Zsb2F0KHBvcyk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19vdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfbWxfZmx1c2hcbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX291dChjaGFuaWQpIHtcbiAgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICByZXR1cm4gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19vdXRfNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQsIGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfbWxfZmx1c2hcbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX291dF82NChjaGFuaWQpIHtcbiAgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9mbG9hdCAoY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0X2ludFxuLy9SZXF1aXJlczogY2FtbF9tbF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5XG5mdW5jdGlvbiBjYW1sX21sX291dHB1dF9pbnQgKGNoYW5pZCxpKSB7XG4gIHZhciBhcnIgPSBbKGk+PjI0KSAmIDB4RkYsKGk+PjE2KSAmIDB4RkYsKGk+PjgpICYgMHhGRixpICYgMHhGRiBdO1xuICB2YXIgcyA9IGNhbWxfc3RyaW5nX29mX2FycmF5KGFycik7XG4gIGNhbWxfbWxfb3V0cHV0KGNoYW5pZCxzLDAsNCk7XG4gIHJldHVybiAwXG59XG4iLCJcblxuLy9Qcm92aWRlczogY2FtbF9nY19taW5vclxuZnVuY3Rpb24gY2FtbF9nY19taW5vcigpeyByZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfbWFqb3JcbmZ1bmN0aW9uIGNhbWxfZ2NfbWFqb3IoKXsgcmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2djX2Z1bGxfbWFqb3JcbmZ1bmN0aW9uIGNhbWxfZ2NfZnVsbF9tYWpvcigpeyByZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfY29tcGFjdGlvblxuZnVuY3Rpb24gY2FtbF9nY19jb21wYWN0aW9uKCl7IHJldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9nY19jb3VudGVyc1xuZnVuY3Rpb24gY2FtbF9nY19jb3VudGVycygpIHsgcmV0dXJuIFsyNTQsMCwwLDBdIH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfcXVpY2tfc3RhdFxuZnVuY3Rpb24gY2FtbF9nY19xdWlja19zdGF0KCl7XG4gIHJldHVybiBbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwXVxufVxuLy9Qcm92aWRlczogY2FtbF9nY19zdGF0XG5mdW5jdGlvbiBjYW1sX2djX3N0YXQoKSB7XG4gIHJldHVybiBbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwXVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX3NldFxuZnVuY3Rpb24gY2FtbF9nY19zZXQoX2NvbnRyb2wpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfZ2V0XG5mdW5jdGlvbiBjYW1sX2djX2dldCgpe1xuICByZXR1cm4gWzAsMCwwLDAsMCwwLDAsMCwwXVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21lbXByb2Zfc2V0XG5mdW5jdGlvbiBjYW1sX21lbXByb2Zfc2V0KF9jb250cm9sKSB7XG4gIHJldHVybiAwO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmQsIEFuZHkgUmF5XG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG4vL1xuLy8gQmlnYXJyYXkuXG4vL1xuLy8gLSBhbGwgYmlnYXJyYXkgdHlwZXMgaW5jbHVkaW5nIEludDY0IGFuZCBDb21wbGV4LlxuLy8gLSBmb3J0cmFuICsgYyBsYXlvdXRzXG4vLyAtIHN1Yi9zbGljZS9yZXNoYXBlXG4vLyAtIHJldGFpbiBmYXN0IHBhdGggZm9yIDFkIGFycmF5IGFjY2Vzc1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2luaXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfYmFfaW5pdCgpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfc2l6ZShkaW1zKSB7XG4gIHZhciBuX2RpbXMgPSBkaW1zLmxlbmd0aDtcbiAgdmFyIHNpemUgPSAxO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5fZGltczsgaSsrKSB7XG4gICAgaWYgKGRpbXNbaV0gPCAwKVxuICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuY3JlYXRlOiBuZWdhdGl2ZSBkaW1lbnNpb25cIik7XG4gICAgc2l6ZSA9IHNpemUgKiBkaW1zW2ldO1xuICB9XG4gIHJldHVybiBzaXplO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGtpbmQpe1xuICBzd2l0Y2goa2luZCl7XG4gIGNhc2UgNzogY2FzZSAxMDogY2FzZSAxMTogcmV0dXJuIDI7XG4gIGRlZmF1bHQ6IHJldHVybiAxO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlX2J1ZmZlclxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZV9idWZmZXIoa2luZCwgc2l6ZSl7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIHZhciB2aWV3O1xuICBzd2l0Y2goa2luZCl7XG4gIGNhc2UgMDogIHZpZXcgPSBnLkZsb2F0MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgMTogIHZpZXcgPSBnLkZsb2F0NjRBcnJheTsgYnJlYWs7XG4gIGNhc2UgMjogIHZpZXcgPSBnLkludDhBcnJheTsgYnJlYWs7XG4gIGNhc2UgMzogIHZpZXcgPSBnLlVpbnQ4QXJyYXk7IGJyZWFrO1xuICBjYXNlIDQ6ICB2aWV3ID0gZy5JbnQxNkFycmF5OyBicmVhaztcbiAgY2FzZSA1OiAgdmlldyA9IGcuVWludDE2QXJyYXk7IGJyZWFrO1xuICBjYXNlIDY6ICB2aWV3ID0gZy5JbnQzMkFycmF5OyBicmVhaztcbiAgY2FzZSA3OiAgdmlldyA9IGcuSW50MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgODogIHZpZXcgPSBnLkludDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDk6ICB2aWV3ID0gZy5JbnQzMkFycmF5OyBicmVhaztcbiAgY2FzZSAxMDogdmlldyA9IGcuRmxvYXQzMkFycmF5OyBicmVhaztcbiAgY2FzZSAxMTogdmlldyA9IGcuRmxvYXQ2NEFycmF5OyBicmVhaztcbiAgY2FzZSAxMjogdmlldyA9IGcuVWludDhBcnJheTsgYnJlYWs7XG4gIH1cbiAgaWYgKCF2aWV3KSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5jcmVhdGU6IHVuc3VwcG9ydGVkIGtpbmRcIik7XG4gIHZhciBkYXRhID0gbmV3IHZpZXcoc2l6ZSAqIGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoa2luZCkpO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLy9Qcm92aWRlczogTWxfQmlnYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGksIGNhbWxfaW50NjRfaGkzMiwgY2FtbF9pbnQ2NF9sbzMyXG5mdW5jdGlvbiBNbF9CaWdhcnJheSAoa2luZCwgbGF5b3V0LCBkaW1zLCBidWZmZXIpIHtcblxuICB0aGlzLmtpbmQgICA9IGtpbmQgO1xuICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgdGhpcy5kaW1zICAgPSBkaW1zO1xuICB0aGlzLmRhdGEgPSBidWZmZXI7XG59XG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5jYW1sX2N1c3RvbSA9IFwiX2JpZ2FycmF5XCI7XG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHZhciBvZnMgPSAwO1xuICBpZih0eXBlb2YgYXJnID09PSBcIm51bWJlclwiKSBhcmcgPSBbYXJnXTtcbiAgaWYgKCEgKGFyZyBpbnN0YW5jZW9mIEFycmF5KSkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiYmlnYXJyYXkuanM6IGludmFsaWQgb2Zmc2V0XCIpO1xuICBpZiAodGhpcy5kaW1zLmxlbmd0aCAhPSBhcmcubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmdldC9zZXQ6IGJhZCBudW1iZXIgb2YgZGltZW5zaW9uc1wiKTtcbiAgaWYodGhpcy5sYXlvdXQgPT0gMCAvKiBjX2xheW91dCAqLykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kaW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXJnW2ldIDwgMCB8fCBhcmdbaV0gPj0gdGhpcy5kaW1zW2ldKVxuICAgICAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gICAgICBvZnMgPSAob2ZzICogdGhpcy5kaW1zW2ldKSArIGFyZ1tpXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuZGltcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKGFyZ1tpXSA8IDEgfHwgYXJnW2ldID4gdGhpcy5kaW1zW2ldKXtcbiAgICAgICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICAgICAgfVxuICAgICAgb2ZzID0gKG9mcyAqIHRoaXMuZGltc1tpXSkgKyAoYXJnW2ldIC0gMSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvZnM7XG59XG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAob2ZzKSB7XG4gIHN3aXRjaCh0aGlzLmtpbmQpe1xuICBjYXNlIDc6XG4gICAgLy8gSW50NjRcbiAgICB2YXIgbCA9IHRoaXMuZGF0YVtvZnMgKiAyICsgMF07XG4gICAgdmFyIGggPSB0aGlzLmRhdGFbb2ZzICogMiArIDFdO1xuICAgIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19oaShsLGgpO1xuICBjYXNlIDEwOiBjYXNlIDExOlxuICAgIC8vIENvbXBsZXgzMiwgQ29tcGxleDY0XG4gICAgdmFyIHIgPSB0aGlzLmRhdGFbb2ZzICogMiArIDBdO1xuICAgIHZhciBpID0gdGhpcy5kYXRhW29mcyAqIDIgKyAxXTtcbiAgICByZXR1cm4gWzI1NCwgciwgaV07XG4gIGRlZmF1bHQ6XG4gICAgcmV0dXJuIHRoaXMuZGF0YVtvZnNdXG4gIH1cbn1cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChvZnMsdikge1xuICBzd2l0Y2godGhpcy5raW5kKXtcbiAgY2FzZSA3OlxuICAgIC8vIEludDY0XG4gICAgdGhpcy5kYXRhW29mcyAqIDIgKyAwXSA9IGNhbWxfaW50NjRfbG8zMih2KTtcbiAgICB0aGlzLmRhdGFbb2ZzICogMiArIDFdID0gY2FtbF9pbnQ2NF9oaTMyKHYpO1xuICAgIGJyZWFrO1xuICBjYXNlIDEwOiBjYXNlIDExOlxuICAgIC8vIENvbXBsZXgzMiwgQ29tcGxleDY0XG4gICAgdGhpcy5kYXRhW29mcyAqIDIgKyAwXSA9IHZbMV07XG4gICAgdGhpcy5kYXRhW29mcyAqIDIgKyAxXSA9IHZbMl07XG4gICAgYnJlYWs7XG4gIGRlZmF1bHQ6XG4gICAgdGhpcy5kYXRhW29mc10gPSB2O1xuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiAwXG59XG5cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAodikge1xuICBzd2l0Y2godGhpcy5raW5kKXtcbiAgY2FzZSA3OlxuICAgIC8vIEludDY0XG4gICAgdmFyIGEgPSBjYW1sX2ludDY0X2xvMzIodik7XG4gICAgdmFyIGIgPSBjYW1sX2ludDY0X2hpMzIodik7XG4gICAgaWYoYSA9PSBiKXtcbiAgICAgIHRoaXMuZGF0YS5maWxsKGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGk8dGhpcy5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdGhpcy5kYXRhW2ldID0gKGklMiA9PSAwKSA/IGEgOiBiO1xuICAgICAgfVxuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMDogY2FzZSAxMTpcbiAgICAvLyBDb21wbGV4MzIsIENvbXBsZXg2NFxuICAgIHZhciBpbSA9IHZbMV07XG4gICAgdmFyIHJlID0gdlsyXTtcbiAgICBpZihpbSA9PSByZSl7XG4gICAgICB0aGlzLmRhdGEuZmlsbChpbSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZm9yKHZhciBpID0gMDsgaTx0aGlzLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgICB0aGlzLmRhdGFbaV0gPSAoaSUyID09IDApID8gaW0gOiByZTtcbiAgICAgIH1cbiAgICB9XG4gICAgYnJlYWs7XG4gIGRlZmF1bHQ6XG4gICAgdGhpcy5kYXRhLmZpbGwodik7XG4gICAgYnJlYWs7XG4gIH1cbn1cblxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChiLCB0b3RhbCkge1xuICBpZiAodGhpcy5sYXlvdXQgIT0gYi5sYXlvdXQgfHwgdGhpcy5raW5kICE9IGIua2luZCkge1xuICAgIHZhciBrMSA9IHRoaXMua2luZCB8ICh0aGlzLmxheW91dCA8PCA4KTtcbiAgICB2YXIgazIgPSAgICBiLmtpbmQgfCAoYi5sYXlvdXQgPDwgOCk7XG4gICAgcmV0dXJuIGsyIC0gazE7XG4gIH1cbiAgaWYgKHRoaXMuZGltcy5sZW5ndGggIT0gYi5kaW1zLmxlbmd0aCkge1xuICAgIHJldHVybiBiLmRpbXMubGVuZ3RoIC0gdGhpcy5kaW1zLmxlbmd0aDtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGltcy5sZW5ndGg7IGkrKylcbiAgICBpZiAodGhpcy5kaW1zW2ldICE9IGIuZGltc1tpXSlcbiAgICAgIHJldHVybiAodGhpcy5kaW1zW2ldIDwgYi5kaW1zW2ldKSA/IC0xIDogMTtcbiAgc3dpdGNoICh0aGlzLmtpbmQpIHtcbiAgY2FzZSAwOlxuICBjYXNlIDE6XG4gIGNhc2UgMTA6XG4gIGNhc2UgMTE6XG4gICAgLy8gRmxvYXRzXG4gICAgdmFyIHgsIHk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHggPSB0aGlzLmRhdGFbaV07XG4gICAgICB5ID0gYi5kYXRhW2ldO1xuICAgICAgaWYgKHggPCB5KVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICBpZiAoeCA+IHkpXG4gICAgICAgIHJldHVybiAxO1xuICAgICAgaWYgKHggIT0geSkge1xuICAgICAgICBpZiAoIXRvdGFsKSByZXR1cm4gTmFOO1xuICAgICAgICBpZiAoeCA9PSB4KSByZXR1cm4gMTtcbiAgICAgICAgaWYgKHkgPT0geSkgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA3OlxuICAgIC8vIEludDY0XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKz0yKSB7XG4gICAgICAvLyBDaGVjayBoaWdoZXN0IGJpdHMgZmlyc3RcbiAgICAgIGlmICh0aGlzLmRhdGFbaSsxXSA8IGIuZGF0YVtpKzFdKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICBpZiAodGhpcy5kYXRhW2krMV0gPiBiLmRhdGFbaSsxXSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBpZiAoKHRoaXMuZGF0YVtpXSA+Pj4gMCkgPCAoYi5kYXRhW2ldID4+PiAwKSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKCh0aGlzLmRhdGFbaV0gPj4+IDApID4gKGIuZGF0YVtpXSA+Pj4gMCkpXG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAyOlxuICBjYXNlIDM6XG4gIGNhc2UgNDpcbiAgY2FzZSA1OlxuICBjYXNlIDY6XG4gIGNhc2UgODpcbiAgY2FzZSA5OlxuICBjYXNlIDEyOlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5kYXRhW2ldIDwgYi5kYXRhW2ldKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICBpZiAodGhpcy5kYXRhW2ldID4gYi5kYXRhW2ldKVxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IE1sX0JpZ2FycmF5X2NfMV8xXG4vL1JlcXVpcmVzOiBNbF9CaWdhcnJheSwgY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBNbF9CaWdhcnJheV9jXzFfMShraW5kLCBsYXlvdXQsIGRpbXMsIGJ1ZmZlcikge1xuICB0aGlzLmtpbmQgICA9IGtpbmQgO1xuICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgdGhpcy5kaW1zICAgPSBkaW1zO1xuICB0aGlzLmRhdGEgICA9IGJ1ZmZlcjtcbn1cblxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlID0gbmV3IE1sX0JpZ2FycmF5KClcbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIGlmKHR5cGVvZiBhcmcgIT09IFwibnVtYmVyXCIpe1xuICAgIGlmKChhcmcgaW5zdGFuY2VvZiBBcnJheSkgJiYgYXJnLmxlbmd0aCA9PSAxKVxuICAgICAgYXJnID0gYXJnWzBdO1xuICAgIGVsc2UgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiTWxfQmlnYXJyYXlfY18xXzEub2Zmc2V0XCIpO1xuICB9XG4gIGlmIChhcmcgPCAwIHx8IGFyZyA+PSB0aGlzLmRpbXNbMF0pXG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gYXJnO1xufVxuXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG9mcykge1xuICByZXR1cm4gdGhpcy5kYXRhW29mc107XG59XG5cbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAob2ZzLHYpIHtcbiAgdGhpcy5kYXRhW29mc10gPSB2O1xuICByZXR1cm4gMFxufVxuXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICh2KSB7XG4gIHRoaXMuZGF0YS5maWxsKHYpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NvbXBhcmVcbmZ1bmN0aW9uIGNhbWxfYmFfY29tcGFyZShhLGIsdG90YWwpe1xuICByZXR1cm4gYS5jb21wYXJlKGIsdG90YWwpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuLy9SZXF1aXJlczogTWxfQmlnYXJyYXksIE1sX0JpZ2FycmF5X2NfMV8xLCBjYW1sX2JhX2dldF9zaXplLCBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpe1xuICB2YXIgc2l6ZV9wZXJfZWxlbWVudCA9IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoa2luZCk7XG4gIGlmKGNhbWxfYmFfZ2V0X3NpemUoZGltcykgKiBzaXplX3Blcl9lbGVtZW50ICE9IGRhdGEubGVuZ3RoKSB7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwibGVuZ3RoIGRvZXNuJ3QgbWF0Y2ggZGltc1wiKTtcbiAgfVxuICBpZihsYXlvdXQgPT0gMCAmJiAvLyBjX2xheW91dFxuICAgICBkaW1zLmxlbmd0aCA9PSAxICYmIC8vIEFycmF5MVxuICAgICBzaXplX3Blcl9lbGVtZW50ID09IDEpIC8vIDEtdG8tMSBtYXBwaW5nXG4gICAgcmV0dXJuIG5ldyBNbF9CaWdhcnJheV9jXzFfMShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xuICByZXR1cm4gbmV3IE1sX0JpZ2FycmF5KGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG5cbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplLCBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX2J1ZmZlclxuZnVuY3Rpb24gY2FtbF9iYV9jcmVhdGUoa2luZCwgbGF5b3V0LCBkaW1zX21sKSB7XG4gIHZhciBkaW1zID0gY2FtbF9qc19mcm9tX2FycmF5KGRpbXNfbWwpO1xuICB2YXIgZGF0YSA9IGNhbWxfYmFfY3JlYXRlX2J1ZmZlcihraW5kLCBjYW1sX2JhX2dldF9zaXplKGRpbXMpKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NoYW5nZV9sYXlvdXRcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gY2FtbF9iYV9jaGFuZ2VfbGF5b3V0KGJhLCBsYXlvdXQpIHtcbiAgaWYoYmEubGF5b3V0ID09IGxheW91dCkgcmV0dXJuIGJhO1xuICB2YXIgbmV3X2RpbXMgPSBbXVxuICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKykgbmV3X2RpbXNbaV0gPSBiYS5kaW1zW2JhLmRpbXMubGVuZ3RoIC0gaSAtIDFdO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGJhLmtpbmQsIGxheW91dCwgbmV3X2RpbXMsIGJhLmRhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2tpbmRcbmZ1bmN0aW9uIGNhbWxfYmFfa2luZChiYSkge1xuICByZXR1cm4gYmEua2luZDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9sYXlvdXRcbmZ1bmN0aW9uIGNhbWxfYmFfbGF5b3V0KGJhKSB7XG4gIHJldHVybiBiYS5sYXlvdXQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfbnVtX2RpbXNcbmZ1bmN0aW9uIGNhbWxfYmFfbnVtX2RpbXMoYmEpIHtcbiAgcmV0dXJuIGJhLmRpbXMubGVuZ3RoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2RpbShiYSwgaSkge1xuICBpZiAoaSA8IDAgfHwgaSA+PSBiYS5kaW1zLmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5kaW1cIik7XG4gIHJldHVybiBiYS5kaW1zW2ldO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbV8xXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2RpbVxuZnVuY3Rpb24gY2FtbF9iYV9kaW1fMShiYSkge1xuICByZXR1cm4gY2FtbF9iYV9kaW0oYmEsIDApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbV8yXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2RpbVxuZnVuY3Rpb24gY2FtbF9iYV9kaW1fMihiYSkge1xuICByZXR1cm4gY2FtbF9iYV9kaW0oYmEsIDEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbV8zXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2RpbVxuZnVuY3Rpb24gY2FtbF9iYV9kaW1fMyhiYSkge1xuICByZXR1cm4gY2FtbF9iYV9kaW0oYmEsIDIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF9nZW5lcmljXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0X2dlbmVyaWMoYmEsIGkpIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChjYW1sX2pzX2Zyb21fYXJyYXkoaSkpO1xuICByZXR1cm4gYmEuZ2V0KG9mcyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfZ2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfZ2V0MTYoYmEsIGkwKSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyAxID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGJhLmdldChvZnMpO1xuICB2YXIgYjIgPSBiYS5nZXQob2ZzICsgMSk7XG4gIHJldHVybiAoYjEgfCAoYjIgPDwgOCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X2dldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X2dldDMyKGJhLCBpMCkge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgMyA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBiYS5nZXQob2ZzKzApO1xuICB2YXIgYjIgPSBiYS5nZXQob2ZzKzEpO1xuICB2YXIgYjMgPSBiYS5nZXQob2ZzKzIpO1xuICB2YXIgYjQgPSBiYS5nZXQob2ZzKzMpO1xuICByZXR1cm4gKCAoYjEgPDwgMCkgIHxcbiAgICAgICAgICAgKGIyIDw8IDgpICB8XG4gICAgICAgICAgIChiMyA8PCAxNikgfFxuICAgICAgICAgICAoYjQgPDwgMjQpICk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfZ2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfZ2V0NjQoYmEsIGkwKSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyA3ID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGJhLmdldChvZnMrMCk7XG4gIHZhciBiMiA9IGJhLmdldChvZnMrMSk7XG4gIHZhciBiMyA9IGJhLmdldChvZnMrMik7XG4gIHZhciBiNCA9IGJhLmdldChvZnMrMyk7XG4gIHZhciBiNSA9IGJhLmdldChvZnMrNCk7XG4gIHZhciBiNiA9IGJhLmdldChvZnMrNSk7XG4gIHZhciBiNyA9IGJhLmdldChvZnMrNik7XG4gIHZhciBiOCA9IGJhLmdldChvZnMrNyk7XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzKFtiOCxiNyxiNixiNSxiNCxiMyxiMixiMV0pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBjYW1sX2JhX2dldF8xKGJhLCBpMCkge1xuICByZXR1cm4gYmEuZ2V0KGJhLm9mZnNldChpMCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF8yXG5mdW5jdGlvbiBjYW1sX2JhX2dldF8yKGJhLCBpMCwgaTEpIHtcbiAgcmV0dXJuIGJhLmdldChiYS5vZmZzZXQoW2kwLGkxXSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF8zXG5mdW5jdGlvbiBjYW1sX2JhX2dldF8zKGJhLCBpMCwgaTEsIGkyKSB7XG4gIHJldHVybiBiYS5nZXQoYmEub2Zmc2V0KFtpMCxpMSxpMl0pKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXRfZ2VuZXJpY1xuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2JhX3NldF9nZW5lcmljKGJhLCBpLCB2KSB7XG4gIGJhLnNldChiYS5vZmZzZXQoY2FtbF9qc19mcm9tX2FycmF5KGkpKSwgdik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfc2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfc2V0MTYoYmEsIGkwLCB2KSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyAxID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIGJhLnNldChvZnMrMCwgIHYgICAgICAgICYgMHhmZik7XG4gIGJhLnNldChvZnMrMSwgKHYgPj4+IDgpICYgMHhmZik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X3NldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X3NldDMyKGJhLCBpMCwgdikge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgMyA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICBiYS5zZXQob2ZzKzAsICB2ICAgICAgICAgJiAweGZmKTtcbiAgYmEuc2V0KG9mcysxLCAodiA+Pj4gOCkgICYgMHhmZik7XG4gIGJhLnNldChvZnMrMiwgKHYgPj4+IDE2KSAmIDB4ZmYpO1xuICBiYS5zZXQob2ZzKzMsICh2ID4+PiAyNCkgJiAweGZmKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfc2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfaW50NjRfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfc2V0NjQoYmEsIGkwLCB2KSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyA3ID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciB2ID0gY2FtbF9pbnQ2NF90b19ieXRlcyh2KTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IDg7IGkrKykgYmEuc2V0KG9mcytpLCB2WzctaV0pXG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF8xXG5mdW5jdGlvbiBjYW1sX2JhX3NldF8xKGJhLCBpMCwgdikge1xuICBiYS5zZXQoYmEub2Zmc2V0KGkwKSwgdik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2V0XzJcbmZ1bmN0aW9uIGNhbWxfYmFfc2V0XzIoYmEsIGkwLCBpMSwgdikge1xuICBiYS5zZXQoYmEub2Zmc2V0KFtpMCxpMV0pLCB2KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2V0XzNcbmZ1bmN0aW9uIGNhbWxfYmFfc2V0XzMoYmEsIGkwLCBpMSwgaTIsIHYpIHtcbiAgYmEuc2V0KGJhLm9mZnNldChbaTAsaTEsaTJdKSwgdik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2ZpbGxcbmZ1bmN0aW9uIGNhbWxfYmFfZmlsbChiYSwgdikge1xuICBiYS5maWxsKHYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9ibGl0XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfYmxpdChzcmMsIGRzdCkge1xuICBpZiAoZHN0LmRpbXMubGVuZ3RoICE9IHNyYy5kaW1zLmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5ibGl0OiBkaW1lbnNpb24gbWlzbWF0Y2hcIik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZHN0LmRpbXMubGVuZ3RoOyBpKyspXG4gICAgaWYgKGRzdC5kaW1zW2ldICE9IHNyYy5kaW1zW2ldKVxuICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuYmxpdDogZGltZW5zaW9uIG1pc21hdGNoXCIpO1xuICBkc3QuZGF0YS5zZXQoc3JjLmRhdGEpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zdWJcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2JhX2dldF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG5mdW5jdGlvbiBjYW1sX2JhX3N1YihiYSwgb2ZzLCBsZW4pIHtcbiAgdmFyIGNoYW5nZWRfZGltO1xuICB2YXIgbXVsID0gMTtcbiAgaWYgKGJhLmxheW91dCA9PSAwKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKVxuICAgICAgbXVsID0gbXVsICogYmEuZGltc1tpXTtcbiAgICBjaGFuZ2VkX2RpbSA9IDA7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAoYmEuZGltcy5sZW5ndGggLSAxKTsgaSsrKVxuICAgICAgbXVsID0gbXVsICogYmEuZGltc1tpXTtcbiAgICBjaGFuZ2VkX2RpbSA9IGJhLmRpbXMubGVuZ3RoIC0gMTtcbiAgICBvZnMgPSBvZnMgLSAxO1xuICB9XG4gIGlmIChvZnMgPCAwIHx8IGxlbiA8IDAgfHwgKG9mcyArIGxlbikgPiBiYS5kaW1zW2NoYW5nZWRfZGltXSl7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuc3ViOiBiYWQgc3ViLWFycmF5XCIpO1xuICB9XG4gIHZhciBuZXdfZGltcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspXG4gICAgbmV3X2RpbXNbaV0gPSBiYS5kaW1zW2ldO1xuICBuZXdfZGltc1tjaGFuZ2VkX2RpbV0gPSBsZW47XG4gIG11bCAqPSBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGJhLmtpbmQpO1xuICB2YXIgbmV3X2RhdGEgPSBiYS5kYXRhLnN1YmFycmF5KG9mcyAqIG11bCwgKG9mcyArIGxlbikgKiBtdWwpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGJhLmtpbmQsIGJhLmxheW91dCwgbmV3X2RpbXMsIG5ld19kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zbGljZVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5LCBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9nZXRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuZnVuY3Rpb24gY2FtbF9iYV9zbGljZShiYSwgdmluZCkge1xuICB2aW5kID0gY2FtbF9qc19mcm9tX2FycmF5KHZpbmQpO1xuICB2YXIgbnVtX2luZHMgPSB2aW5kLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gW107XG4gIHZhciBzdWJfZGltcyA9IFtdO1xuICB2YXIgb2ZzO1xuXG4gIGlmIChudW1faW5kcyA+IGJhLmRpbXMubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnNsaWNlOiB0b28gbWFueSBpbmRpY2VzXCIpO1xuXG4gIC8vIENvbXB1dGUgb2Zmc2V0IGFuZCBjaGVjayBib3VuZHNcbiAgaWYgKGJhLmxheW91dCA9PSAwKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1faW5kczsgaSsrKVxuICAgICAgaW5kZXhbaV0gPSB2aW5kW2ldO1xuICAgIGZvciAoOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKylcbiAgICAgIGluZGV4W2ldID0gMDtcbiAgICBzdWJfZGltcyA9IGJhLmRpbXMuc2xpY2UobnVtX2luZHMpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2luZHM7IGkrKylcbiAgICAgIGluZGV4W2JhLmRpbXMubGVuZ3RoIC0gbnVtX2luZHMgKyBpXSA9IHZpbmRbaV07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aCAtIG51bV9pbmRzOyBpKyspXG4gICAgICBpbmRleFtpXSA9IDE7XG4gICAgc3ViX2RpbXMgPSBiYS5kaW1zLnNsaWNlKDAsIGJhLmRpbXMubGVuZ3RoIC0gbnVtX2luZHMpO1xuICB9XG4gIG9mcyA9IGJhLm9mZnNldChpbmRleCk7XG4gIHZhciBzaXplID0gY2FtbF9iYV9nZXRfc2l6ZShzdWJfZGltcyk7XG4gIHZhciBzaXplX3Blcl9lbGVtZW50ID0gY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChiYS5raW5kKTtcbiAgdmFyIG5ld19kYXRhID0gYmEuZGF0YS5zdWJhcnJheShvZnMgKiBzaXplX3Blcl9lbGVtZW50LCAob2ZzICsgc2l6ZSkgKiBzaXplX3Blcl9lbGVtZW50KTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShiYS5raW5kLCBiYS5sYXlvdXQsIHN1Yl9kaW1zLCBuZXdfZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfcmVzaGFwZVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5LCBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9iYV9nZXRfc2l6ZVxuZnVuY3Rpb24gY2FtbF9iYV9yZXNoYXBlKGJhLCB2aW5kKSB7XG4gIHZpbmQgPSBjYW1sX2pzX2Zyb21fYXJyYXkodmluZCk7XG4gIHZhciBuZXdfZGltID0gW107XG4gIHZhciBudW1fZGltcyA9IHZpbmQubGVuZ3RoO1xuXG4gIGlmIChudW1fZGltcyA8IDAgfHwgbnVtX2RpbXMgPiAxNil7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkucmVzaGFwZTogYmFkIG51bWJlciBvZiBkaW1lbnNpb25zXCIpO1xuICB9XG4gIHZhciBudW1fZWx0cyA9IDE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2RpbXM7IGkrKykge1xuICAgIG5ld19kaW1baV0gPSB2aW5kW2ldO1xuICAgIGlmIChuZXdfZGltW2ldIDwgMClcbiAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnJlc2hhcGU6IG5lZ2F0aXZlIGRpbWVuc2lvblwiKTtcbiAgICBudW1fZWx0cyA9IG51bV9lbHRzICogbmV3X2RpbVtpXTtcbiAgfVxuXG4gIHZhciBzaXplID0gY2FtbF9iYV9nZXRfc2l6ZShiYS5kaW1zKTtcbiAgLy8gQ2hlY2sgdGhhdCBzaXplcyBhZ3JlZVxuICBpZiAobnVtX2VsdHMgIT0gc2l6ZSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5yZXNoYXBlOiBzaXplIG1pc21hdGNoXCIpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGJhLmtpbmQsIGJhLmxheW91dCwgbmV3X2RpbSwgYmEuZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2VyaWFsaXplXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQsIGNhbWxfaW50NjRfdG9fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaW50MzJfYml0c19vZl9mbG9hdFxuZnVuY3Rpb24gY2FtbF9iYV9zZXJpYWxpemUod3JpdGVyLCBiYSwgc3opIHtcbiAgd3JpdGVyLndyaXRlKDMyLCBiYS5kaW1zLmxlbmd0aCk7XG4gIHdyaXRlci53cml0ZSgzMiwgKGJhLmtpbmQgfCAoYmEubGF5b3V0IDw8IDgpKSk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKSB3cml0ZXIud3JpdGUoMzIsYmEuZGltc1tpXSk7XG4gIHN3aXRjaChiYS5raW5kKXtcbiAgY2FzZSAyOiAgLy9JbnQ4QXJyYXlcbiAgY2FzZSAzOiAgLy9VaW50OEFycmF5XG4gIGNhc2UgMTI6IC8vVWludDhBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHdyaXRlci53cml0ZSg4LCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNDogIC8vIEludDE2QXJyYXlcbiAgY2FzZSA1OiAgLy8gVWludDE2QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB3cml0ZXIud3JpdGUoMTYsIGJhLmRhdGFbaV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA2OiAgLy8gSW50MzJBcnJheSAoaW50MzIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgODogIC8vIEludDMyQXJyYXkgKGludClcbiAgY2FzZSA5OiAgLy8gSW50MzJBcnJheSAobmF0aXZlaW50KVxuICAgIHdyaXRlci53cml0ZSg4LDApO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHdyaXRlci53cml0ZSgzMiwgYmEuZGF0YVtpXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDc6ICAvLyBJbnQzMkFycmF5IChpbnQ2NClcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGggLyAyOyBpKyspe1xuICAgICAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGJhLmdldChpKSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlICg4LCBiW2pdKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTogIC8vIEZsb2F0NjRBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyhjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoYmEuZ2V0KGkpKSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlICg4LCBiW2pdKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMDogIC8vIEZsb2F0MzJBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0KGJhLmdldChpKSk7XG4gICAgICB3cml0ZXIud3JpdGUoMzIsIGIpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMDogLy8gRmxvYXQzMkFycmF5IChjb21wbGV4MzIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoIC8gMjsgaSsrKXtcbiAgICAgIHZhciBqID0gYmEuZ2V0KGkpO1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQoalsxXSkpO1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQoalsyXSkpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMTogLy8gRmxvYXQ2NEFycmF5IChjb21wbGV4NjQpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoIC8gMjsgaSsrKXtcbiAgICAgIHZhciBjb21wbGV4ID0gYmEuZ2V0KGkpO1xuICAgICAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdChjb21wbGV4WzFdKSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlICg4LCBiW2pdKTtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyhjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoY29tcGxleFsyXSkpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHdyaXRlci53cml0ZSAoOCwgYltqXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG4gIHN6WzBdID0gKDQgKyBiYS5kaW1zLmxlbmd0aCkgKiA0O1xuICBzelsxXSA9ICg0ICsgYmEuZGltcy5sZW5ndGgpICogODtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kZXNlcmlhbGl6ZVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2ZhaWx3aXRoXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzLCBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNcbi8vUmVxdWlyZXM6IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0c1xuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfYnVmZmVyXG5mdW5jdGlvbiBjYW1sX2JhX2Rlc2VyaWFsaXplKHJlYWRlciwgc3ope1xuICB2YXIgbnVtX2RpbXMgPSByZWFkZXIucmVhZDMycygpO1xuICBpZiAobnVtX2RpbXMgPCAwIHx8IG51bV9kaW1zID4gMTYpXG4gICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiB3cm9uZyBudW1iZXIgb2YgYmlnYXJyYXkgZGltZW5zaW9uc1wiKTtcbiAgdmFyIHRhZyA9IHJlYWRlci5yZWFkMzJzKCk7XG4gIHZhciBraW5kID0gdGFnICYgMHhmZlxuICB2YXIgbGF5b3V0ID0gKHRhZyA+PiA4KSAmIDE7XG4gIHZhciBkaW1zID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZGltczsgaSsrKSBkaW1zLnB1c2gocmVhZGVyLnJlYWQzMnUoKSk7XG4gIHZhciBzaXplID0gY2FtbF9iYV9nZXRfc2l6ZShkaW1zKTtcbiAgdmFyIGRhdGEgPSBjYW1sX2JhX2NyZWF0ZV9idWZmZXIoa2luZCwgc2l6ZSk7XG4gIHZhciBiYSA9IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xuICBzd2l0Y2goa2luZCl7XG4gIGNhc2UgMjogIC8vSW50OEFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQ4cygpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAzOiAgLy9VaW50OEFycmF5XG4gIGNhc2UgMTI6IC8vVWludDhBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNDogIC8vIEludDE2QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDE2cygpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA1OiAgLy8gVWludDE2QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDE2dSgpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA2OiAgLy8gSW50MzJBcnJheSAoaW50MzIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgODogIC8vIEludDMyQXJyYXkgKGludClcbiAgY2FzZSA5OiAgLy8gSW50MzJBcnJheSAobmF0aXZlaW50KVxuICAgIHZhciBzaXh0eSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICBpZihzaXh0eSkgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBjYW5ub3QgcmVhZCBiaWdhcnJheSB3aXRoIDY0LWJpdCBPQ2FtbCBpbnRzXCIpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkMzJzKCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDc6IC8vIChpbnQ2NClcbiAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICB2YXIgaW50NjQgPSBjYW1sX2ludDY0X29mX2J5dGVzKHQpO1xuICAgICAgYmEuc2V0KGksaW50NjQpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxOiAgLy8gRmxvYXQ2NEFycmF5XG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgdmFyIGYgPSBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMoY2FtbF9pbnQ2NF9vZl9ieXRlcyh0KSk7XG4gICAgICBiYS5zZXQoaSxmKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMDogIC8vIEZsb2F0MzJBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgdmFyIGYgPSBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMocmVhZGVyLnJlYWQzMnMoKSk7XG4gICAgICBiYS5zZXQoaSxmKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTA6IC8vIEZsb2F0MzJBcnJheSAoY29tcGxleDMyKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgdmFyIHJlID0gY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzKHJlYWRlci5yZWFkMzJzKCkpO1xuICAgICAgdmFyIGltID0gY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzKHJlYWRlci5yZWFkMzJzKCkpO1xuICAgICAgYmEuc2V0KGksWzI1NCxyZSxpbV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMTogLy8gRmxvYXQ2NEFycmF5IChjb21wbGV4NjQpXG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgdmFyIHJlID0gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzKGNhbWxfaW50NjRfb2ZfYnl0ZXModCkpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgdmFyIGltID0gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzKGNhbWxfaW50NjRfb2ZfYnl0ZXModCkpO1xuICAgICAgYmEuc2V0KGksWzI1NCxyZSxpbV0pO1xuICAgIH1cbiAgICBicmVha1xuICB9XG4gIHN6WzBdID0gKDQgKyBudW1fZGltcykgKiA0O1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG59XG5cbi8vRGVwcmVjYXRlZFxuLy9Qcm92aWRlczogY2FtbF9iYV9jcmVhdGVfZnJvbVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfY3JlYXRlX2Zyb20oZGF0YTEsIGRhdGEyLCBqc3R5cCwga2luZCwgbGF5b3V0LCBkaW1zKXtcbiAgaWYoZGF0YTIgfHwgY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChraW5kKSA9PSAyKXtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JhX2NyZWF0ZV9mcm9tOiB1c2UgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVwiKTtcbiAgfVxuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YTEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2hhc2ggY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemUsIGNhbWxfaGFzaF9taXhfaW50LCBjYW1sX2hhc2hfbWl4X2Zsb2F0XG5mdW5jdGlvbiBjYW1sX2JhX2hhc2goYmEpe1xuICB2YXIgbnVtX2VsdHMgPSBjYW1sX2JhX2dldF9zaXplKGJhLmRpbXMpO1xuICB2YXIgaCA9IDA7XG4gIHN3aXRjaChiYS5raW5kKXtcbiAgY2FzZSAyOiAgLy9JbnQ4QXJyYXlcbiAgY2FzZSAzOiAgLy9VaW50OEFycmF5XG4gIGNhc2UgMTI6IC8vVWludDhBcnJheVxuICAgIGlmKG51bV9lbHRzID4gMjU2KSBudW1fZWx0cyA9IDI1NjtcbiAgICB2YXIgdyA9IDAsIGkgPTA7XG4gICAgZm9yKGkgPSAwOyBpICsgNCA8PSBiYS5kYXRhLmxlbmd0aDsgaSs9NCl7XG4gICAgICB3ID0gYmEuZGF0YVtpKzBdIHwgKGJhLmRhdGFbaSsxXSA8PCA4KSB8IChiYS5kYXRhW2krMl0gPDwgMTYpIHwgKGJhLmRhdGFbaSszXSA8PCAyNCk7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCx3KTtcbiAgICB9XG4gICAgdyA9IDA7XG4gICAgc3dpdGNoIChudW1fZWx0cyAmIDMpIHtcbiAgICBjYXNlIDM6IHcgID0gYmEuZGF0YVtpKzJdIDw8IDE2OyAgICAvKiBmYWxsdGhyb3VnaCAqL1xuICAgIGNhc2UgMjogdyB8PSBiYS5kYXRhW2krMV0gPDwgODsgICAgIC8qIGZhbGx0aHJvdWdoICovXG4gICAgY2FzZSAxOiB3IHw9IGJhLmRhdGFbaSswXTtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNDogIC8vIEludDE2QXJyYXlcbiAgY2FzZSA1OiAgLy8gVWludDE2QXJyYXlcbiAgICBpZihudW1fZWx0cyA+IDEyOCkgbnVtX2VsdHMgPSAxMjg7XG4gICAgdmFyIHcgPSAwLCBpID0wO1xuICAgIGZvcihpID0gMDsgaSArIDIgPD0gYmEuZGF0YS5sZW5ndGg7IGkrPTIpe1xuICAgICAgdyA9IGJhLmRhdGFbaSswXSB8IChiYS5kYXRhW2krMV0gPDwgMTYpO1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsdyk7XG4gICAgfVxuICAgIGlmICgobnVtX2VsdHMgJiAxKSAhPSAwKVxuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGJhLmRhdGFbaV0pO1xuICAgIGJyZWFrO1xuICBjYXNlIDY6ICAvLyBJbnQzMkFycmF5IChpbnQzMilcbiAgICBpZiAobnVtX2VsdHMgPiA2NCkgbnVtX2VsdHMgPSA2NDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBiYS5kYXRhW2ldKTtcbiAgICBicmVhaztcbiAgY2FzZSA4OiAgLy8gSW50MzJBcnJheSAoaW50KVxuICBjYXNlIDk6ICAvLyBJbnQzMkFycmF5IChuYXRpdmVpbnQpXG4gICAgaWYgKG51bV9lbHRzID4gNjQpIG51bV9lbHRzID0gNjQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgNzogIC8vIEludDMyQXJyYXkgKGludDY0KVxuICAgIGlmIChudW1fZWx0cyA+IDMyKSBudW1fZWx0cyA9IDMyO1xuICAgIG51bV9lbHRzICo9IDJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIHtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTA6IC8vIEZsb2F0MzJBcnJheSAoY29tcGxleDMyKVxuICAgIG51bV9lbHRzICo9MjsgLyogZmFsbHRocm91Z2ggKi9cbiAgY2FzZSAwOiAgLy8gRmxvYXQzMkFycmF5XG4gICAgaWYgKG51bV9lbHRzID4gNjQpIG51bV9lbHRzID0gNjQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSBoID0gY2FtbF9oYXNoX21peF9mbG9hdChoLCBiYS5kYXRhW2ldKTtcbiAgICBicmVhaztcbiAgY2FzZSAxMTogLy8gRmxvYXQ2NEFycmF5IChjb21wbGV4NjQpXG4gICAgbnVtX2VsdHMgKj0yOyAvKiBmYWxsdGhyb3VnaCAqL1xuICBjYXNlIDE6ICAvLyBGbG9hdDY0QXJyYXlcbiAgICBpZiAobnVtX2VsdHMgPiAzMikgbnVtX2VsdHMgPSAzMjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIGggPSBjYW1sX2hhc2hfbWl4X2Zsb2F0KGgsIGJhLmRhdGFbaV0pO1xuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBoO1xufVxuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3RpdmUgQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAqL1xuLyogIGVuIEF1dG9tYXRpcXVlLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCAgICAqL1xuLyogIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlLCB3aXRoICAgICAqL1xuLyogIHRoZSBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiBmaWxlIC4uL0xJQ0VOU0UuICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKiAkSWQ6IHBhcnNpbmcuYyA4OTgzIDIwMDgtMDgtMDYgMDk6Mzg6MjVaIHhsZXJveSAkICovXG5cbi8qIFRoZSBQREEgYXV0b21hdG9uIGZvciBwYXJzZXJzIGdlbmVyYXRlZCBieSBjYW1seWFjYyAqL1xuXG4vKiBUaGUgcHVzaGRvd24gYXV0b21hdGEgKi9cblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9lbmdpbmVcbi8vUmVxdWlyZXM6IGNhbWxfbGV4X2FycmF5XG5mdW5jdGlvbiBjYW1sX3BhcnNlX2VuZ2luZSh0YWJsZXMsIGVudiwgY21kLCBhcmcpXG57XG4gIHZhciBFUlJDT0RFID0gMjU2O1xuXG4gIC8vdmFyIFNUQVJUID0gMDtcbiAgLy92YXIgVE9LRU5fUkVBRCA9IDE7XG4gIC8vdmFyIFNUQUNLU19HUk9XTl8xID0gMjtcbiAgLy92YXIgU1RBQ0tTX0dST1dOXzIgPSAzO1xuICAvL3ZhciBTRU1BTlRJQ19BQ1RJT05fQ09NUFVURUQgPSA0O1xuICAvL3ZhciBFUlJPUl9ERVRFQ1RFRCA9IDU7XG4gIHZhciBsb29wID0gNjtcbiAgdmFyIHRlc3RzaGlmdCA9IDc7XG4gIHZhciBzaGlmdCA9IDg7XG4gIHZhciBzaGlmdF9yZWNvdmVyID0gOTtcbiAgdmFyIHJlZHVjZSA9IDEwO1xuXG4gIHZhciBSRUFEX1RPS0VOID0gMDtcbiAgdmFyIFJBSVNFX1BBUlNFX0VSUk9SID0gMTtcbiAgdmFyIEdST1dfU1RBQ0tTXzEgPSAyO1xuICB2YXIgR1JPV19TVEFDS1NfMiA9IDM7XG4gIHZhciBDT01QVVRFX1NFTUFOVElDX0FDVElPTiA9IDQ7XG4gIHZhciBDQUxMX0VSUk9SX0ZVTkNUSU9OID0gNTtcblxuICB2YXIgZW52X3Nfc3RhY2sgPSAxO1xuICB2YXIgZW52X3Zfc3RhY2sgPSAyO1xuICB2YXIgZW52X3N5bWJfc3RhcnRfc3RhY2sgPSAzO1xuICB2YXIgZW52X3N5bWJfZW5kX3N0YWNrID0gNDtcbiAgdmFyIGVudl9zdGFja3NpemUgPSA1O1xuICB2YXIgZW52X3N0YWNrYmFzZSA9IDY7XG4gIHZhciBlbnZfY3Vycl9jaGFyID0gNztcbiAgdmFyIGVudl9sdmFsID0gODtcbiAgdmFyIGVudl9zeW1iX3N0YXJ0ID0gOTtcbiAgdmFyIGVudl9zeW1iX2VuZCA9IDEwO1xuICB2YXIgZW52X2FzcCA9IDExO1xuICB2YXIgZW52X3J1bGVfbGVuID0gMTI7XG4gIHZhciBlbnZfcnVsZV9udW1iZXIgPSAxMztcbiAgdmFyIGVudl9zcCA9IDE0O1xuICB2YXIgZW52X3N0YXRlID0gMTU7XG4gIHZhciBlbnZfZXJyZmxhZyA9IDE2O1xuXG4gIC8vIHZhciBfdGJsX2FjdGlvbnMgPSAxO1xuICB2YXIgdGJsX3RyYW5zbF9jb25zdCA9IDI7XG4gIHZhciB0YmxfdHJhbnNsX2Jsb2NrID0gMztcbiAgdmFyIHRibF9saHMgPSA0O1xuICB2YXIgdGJsX2xlbiA9IDU7XG4gIHZhciB0YmxfZGVmcmVkID0gNjtcbiAgdmFyIHRibF9kZ290byA9IDc7XG4gIHZhciB0Ymxfc2luZGV4ID0gODtcbiAgdmFyIHRibF9yaW5kZXggPSA5O1xuICB2YXIgdGJsX2dpbmRleCA9IDEwO1xuICB2YXIgdGJsX3RhYmxlc2l6ZSA9IDExO1xuICB2YXIgdGJsX3RhYmxlID0gMTI7XG4gIHZhciB0YmxfY2hlY2sgPSAxMztcbiAgLy8gdmFyIF90YmxfZXJyb3JfZnVuY3Rpb24gPSAxNDtcbiAgLy8gdmFyIF90YmxfbmFtZXNfY29uc3QgPSAxNTtcbiAgLy8gdmFyIF90YmxfbmFtZXNfYmxvY2sgPSAxNjtcblxuICBpZiAoIXRhYmxlcy5kZ290bykge1xuICAgIHRhYmxlcy5kZWZyZWQgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9kZWZyZWRdKTtcbiAgICB0YWJsZXMuc2luZGV4ID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0Ymxfc2luZGV4XSk7XG4gICAgdGFibGVzLmNoZWNrICA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2NoZWNrXSk7XG4gICAgdGFibGVzLnJpbmRleCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX3JpbmRleF0pO1xuICAgIHRhYmxlcy50YWJsZSAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF90YWJsZV0pO1xuICAgIHRhYmxlcy5sZW4gICAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9sZW5dKTtcbiAgICB0YWJsZXMubGhzICAgID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfbGhzXSk7XG4gICAgdGFibGVzLmdpbmRleCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2dpbmRleF0pO1xuICAgIHRhYmxlcy5kZ290byAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9kZ290b10pO1xuICB9XG5cbiAgdmFyIHJlcyA9IDAsIG4sIG4xLCBuMiwgc3RhdGUxO1xuXG4gIC8vIFJFU1RPUkVcbiAgdmFyIHNwID0gZW52W2Vudl9zcF07XG4gIHZhciBzdGF0ZSA9IGVudltlbnZfc3RhdGVdO1xuICB2YXIgZXJyZmxhZyA9IGVudltlbnZfZXJyZmxhZ107XG5cbiAgZXhpdDpmb3IgKDs7KSB7XG4gICAgc3dpdGNoKGNtZCkge1xuICAgIGNhc2UgMDovL1NUQVJUOlxuICAgICAgc3RhdGUgPSAwO1xuICAgICAgZXJyZmxhZyA9IDA7XG4gICAgICAvLyBGYWxsIHRocm91Z2hcblxuICAgIGNhc2UgNjovL2xvb3A6XG4gICAgICBuID0gdGFibGVzLmRlZnJlZFtzdGF0ZV07XG4gICAgICBpZiAobiAhPSAwKSB7IGNtZCA9IHJlZHVjZTsgYnJlYWs7IH1cbiAgICAgIGlmIChlbnZbZW52X2N1cnJfY2hhcl0gPj0gMCkgeyBjbWQgPSB0ZXN0c2hpZnQ7IGJyZWFrOyB9XG4gICAgICByZXMgPSBSRUFEX1RPS0VOO1xuICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIC8qIFRoZSBNTCBjb2RlIGNhbGxzIHRoZSBsZXhlciBhbmQgdXBkYXRlcyAqL1xuICAgICAgLyogc3ltYl9zdGFydCBhbmQgc3ltYl9lbmQgKi9cbiAgICBjYXNlIDE6Ly9UT0tFTl9SRUFEOlxuICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGVudltlbnZfY3Vycl9jaGFyXSA9IHRhYmxlc1t0YmxfdHJhbnNsX2Jsb2NrXVthcmdbMF0gKyAxXTtcbiAgICAgICAgZW52W2Vudl9sdmFsXSA9IGFyZ1sxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVudltlbnZfY3Vycl9jaGFyXSA9IHRhYmxlc1t0YmxfdHJhbnNsX2NvbnN0XVthcmcgKyAxXTtcbiAgICAgICAgZW52W2Vudl9sdmFsXSA9IDA7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcblxuICAgIGNhc2UgNzovL3Rlc3RzaGlmdDpcbiAgICAgIG4xID0gdGFibGVzLnNpbmRleFtzdGF0ZV07XG4gICAgICBuMiA9IG4xICsgZW52W2Vudl9jdXJyX2NoYXJdO1xuICAgICAgaWYgKG4xICE9IDAgJiYgbjIgPj0gMCAmJiBuMiA8PSB0YWJsZXNbdGJsX3RhYmxlc2l6ZV0gJiZcbiAgICAgICAgICB0YWJsZXMuY2hlY2tbbjJdID09IGVudltlbnZfY3Vycl9jaGFyXSkge1xuICAgICAgICBjbWQgPSBzaGlmdDsgYnJlYWs7XG4gICAgICB9XG4gICAgICBuMSA9IHRhYmxlcy5yaW5kZXhbc3RhdGVdO1xuICAgICAgbjIgPSBuMSArIGVudltlbnZfY3Vycl9jaGFyXTtcbiAgICAgIGlmIChuMSAhPSAwICYmIG4yID49IDAgJiYgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgdGFibGVzLmNoZWNrW24yXSA9PSBlbnZbZW52X2N1cnJfY2hhcl0pIHtcbiAgICAgICAgbiA9IHRhYmxlcy50YWJsZVtuMl07XG4gICAgICAgIGNtZCA9IHJlZHVjZTsgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoZXJyZmxhZyA8PSAwKSB7XG4gICAgICAgIHJlcyA9IENBTExfRVJST1JfRlVOQ1RJT047XG4gICAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICAgIC8qIFRoZSBNTCBjb2RlIGNhbGxzIHRoZSBlcnJvciBmdW5jdGlvbiAqL1xuICAgIGNhc2UgNTovL0VSUk9SX0RFVEVDVEVEOlxuICAgICAgaWYgKGVycmZsYWcgPCAzKSB7XG4gICAgICAgIGVycmZsYWcgPSAzO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgc3RhdGUxID0gZW52W2Vudl9zX3N0YWNrXVtzcCArIDFdO1xuICAgICAgICAgIG4xID0gdGFibGVzLnNpbmRleFtzdGF0ZTFdO1xuICAgICAgICAgIG4yID0gbjEgKyBFUlJDT0RFO1xuICAgICAgICAgIGlmIChuMSAhPSAwICYmIG4yID49IDAgJiYgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgICAgIHRhYmxlcy5jaGVja1tuMl0gPT0gRVJSQ09ERSkge1xuICAgICAgICAgICAgY21kID0gc2hpZnRfcmVjb3ZlcjsgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzcCA8PSBlbnZbZW52X3N0YWNrYmFzZV0pIHJldHVybiBSQUlTRV9QQVJTRV9FUlJPUjtcbiAgICAgICAgICAgIC8qIFRoZSBNTCBjb2RlIHJhaXNlcyBQYXJzZV9lcnJvciAqL1xuICAgICAgICAgICAgc3AtLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlbnZbZW52X2N1cnJfY2hhcl0gPT0gMCkgcmV0dXJuIFJBSVNFX1BBUlNFX0VSUk9SO1xuICAgICAgICAvKiBUaGUgTUwgY29kZSByYWlzZXMgUGFyc2VfZXJyb3IgKi9cbiAgICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gLTE7XG4gICAgICAgIGNtZCA9IGxvb3A7IGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgY2FzZSA4Oi8vc2hpZnQ6XG4gICAgICBlbnZbZW52X2N1cnJfY2hhcl0gPSAtMTtcbiAgICAgIGlmIChlcnJmbGFnID4gMCkgZXJyZmxhZy0tO1xuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgY2FzZSA5Oi8vc2hpZnRfcmVjb3ZlcjpcbiAgICAgIHN0YXRlID0gdGFibGVzLnRhYmxlW24yXTtcbiAgICAgIHNwKys7XG4gICAgICBpZiAoc3AgPj0gZW52W2Vudl9zdGFja3NpemVdKSB7XG4gICAgICAgIHJlcyA9IEdST1dfU1RBQ0tTXzE7XG4gICAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICAgIC8qIFRoZSBNTCBjb2RlIHJlc2l6ZXMgdGhlIHN0YWNrcyAqL1xuICAgIGNhc2UgMjovL1NUQUNLU19HUk9XTl8xOlxuICAgICAgZW52W2Vudl9zX3N0YWNrXVtzcCArIDFdID0gc3RhdGU7XG4gICAgICBlbnZbZW52X3Zfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X2x2YWxdO1xuICAgICAgZW52W2Vudl9zeW1iX3N0YXJ0X3N0YWNrXVtzcCArIDFdID0gZW52W2Vudl9zeW1iX3N0YXJ0XTtcbiAgICAgIGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfZW5kXTtcbiAgICAgIGNtZCA9IGxvb3A7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMTA6Ly9yZWR1Y2U6XG4gICAgICB2YXIgbSA9IHRhYmxlcy5sZW5bbl07XG4gICAgICBlbnZbZW52X2FzcF0gPSBzcDtcbiAgICAgIGVudltlbnZfcnVsZV9udW1iZXJdID0gbjtcbiAgICAgIGVudltlbnZfcnVsZV9sZW5dID0gbTtcbiAgICAgIHNwID0gc3AgLSBtICsgMTtcbiAgICAgIG0gPSB0YWJsZXMubGhzW25dO1xuICAgICAgc3RhdGUxID0gZW52W2Vudl9zX3N0YWNrXVtzcF07XG4gICAgICBuMSA9IHRhYmxlcy5naW5kZXhbbV07XG4gICAgICBuMiA9IG4xICsgc3RhdGUxO1xuICAgICAgaWYgKG4xICE9IDAgJiYgbjIgPj0gMCAmJiBuMiA8PSB0YWJsZXNbdGJsX3RhYmxlc2l6ZV0gJiZcbiAgICAgICAgICB0YWJsZXMuY2hlY2tbbjJdID09IHN0YXRlMSlcbiAgICAgICAgc3RhdGUgPSB0YWJsZXMudGFibGVbbjJdO1xuICAgICAgZWxzZVxuICAgICAgICBzdGF0ZSA9IHRhYmxlcy5kZ290b1ttXTtcbiAgICAgIGlmIChzcCA+PSBlbnZbZW52X3N0YWNrc2l6ZV0pIHtcbiAgICAgICAgcmVzID0gR1JPV19TVEFDS1NfMjtcbiAgICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIH1cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgICAgLyogVGhlIE1MIGNvZGUgcmVzaXplcyB0aGUgc3RhY2tzICovXG4gICAgY2FzZSAzOi8vU1RBQ0tTX0dST1dOXzI6XG4gICAgICByZXMgPSBDT01QVVRFX1NFTUFOVElDX0FDVElPTjtcbiAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICAvKiBUaGUgTUwgY29kZSBjYWxscyB0aGUgc2VtYW50aWMgYWN0aW9uICovXG4gICAgY2FzZSA0Oi8vU0VNQU5USUNfQUNUSU9OX0NPTVBVVEVEOlxuICAgICAgZW52W2Vudl9zX3N0YWNrXVtzcCArIDFdID0gc3RhdGU7XG4gICAgICBlbnZbZW52X3Zfc3RhY2tdW3NwICsgMV0gPSBhcmc7XG4gICAgICB2YXIgYXNwID0gZW52W2Vudl9hc3BdO1xuICAgICAgZW52W2Vudl9zeW1iX2VuZF9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW2FzcCArIDFdO1xuICAgICAgaWYgKHNwID4gYXNwKSB7XG4gICAgICAgIC8qIFRoaXMgaXMgYW4gZXBzaWxvbiBwcm9kdWN0aW9uLiBUYWtlIHN5bWJfc3RhcnQgZXF1YWwgdG8gc3ltYl9lbmQuICovXG4gICAgICAgIGVudltlbnZfc3ltYl9zdGFydF9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW2FzcCArIDFdO1xuICAgICAgfVxuICAgICAgY21kID0gbG9vcDsgYnJlYWs7XG4gICAgICAvKiBTaG91bGQgbm90IGhhcHBlbiAqL1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gUkFJU0VfUEFSU0VfRVJST1I7XG4gICAgfVxuICB9XG4gIC8vIFNBVkVcbiAgZW52W2Vudl9zcF0gPSBzcDtcbiAgZW52W2Vudl9zdGF0ZV0gPSBzdGF0ZTtcbiAgZW52W2Vudl9lcnJmbGFnXSA9IGVycmZsYWc7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2V0X3BhcnNlcl90cmFjZSBjb25zdFxuLy9EdW1teSBmdW5jdGlvbiFcbmZ1bmN0aW9uIGNhbWxfc2V0X3BhcnNlcl90cmFjZSgpIHsgcmV0dXJuIDA7IH1cbiIsIi8vUHJvdmlkZXM6IHVuaXhfZ2V0dGltZW9mZGF5XG5mdW5jdGlvbiB1bml4X2dldHRpbWVvZmRheSAoKSB7XG4gIHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpIC8gMTAwMDtcbn1cblxuLy9Qcm92aWRlczogdW5peF90aW1lXG4vL1JlcXVpcmVzOiB1bml4X2dldHRpbWVvZmRheVxuZnVuY3Rpb24gdW5peF90aW1lICgpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IodW5peF9nZXR0aW1lb2ZkYXkgKCkpO1xufVxuXG4vL1Byb3ZpZGVzOiB1bml4X2dtdGltZVxuZnVuY3Rpb24gdW5peF9nbXRpbWUgKHQpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSAodCAqIDEwMDApO1xuICB2YXIgZF9udW0gPSBkLmdldFRpbWUoKTtcbiAgdmFyIGphbnVhcnlmaXJzdCA9IChuZXcgRGF0ZShEYXRlLlVUQyhkLmdldFVUQ0Z1bGxZZWFyKCksIDAsIDEpKSkuZ2V0VGltZSgpO1xuICB2YXIgZG95ID0gTWF0aC5mbG9vcigoZF9udW0gLSBqYW51YXJ5Zmlyc3QpIC8gODY0MDAwMDApO1xuICByZXR1cm4gQkxPQ0soMCwgZC5nZXRVVENTZWNvbmRzKCksIGQuZ2V0VVRDTWludXRlcygpLCBkLmdldFVUQ0hvdXJzKCksXG4gICAgICAgICAgZC5nZXRVVENEYXRlKCksIGQuZ2V0VVRDTW9udGgoKSwgZC5nZXRVVENGdWxsWWVhcigpIC0gMTkwMCxcbiAgICAgICAgICBkLmdldFVUQ0RheSgpLCBkb3ksXG4gICAgICAgICAgZmFsc2UgfCAwIC8qIGZvciBVVEMgZGF5bGlnaHQgc2F2aW5ncyB0aW1lIGlzIGZhbHNlICovKVxufVxuXG4vL1Byb3ZpZGVzOiB1bml4X2xvY2FsdGltZVxuZnVuY3Rpb24gdW5peF9sb2NhbHRpbWUgKHQpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSAodCAqIDEwMDApO1xuICB2YXIgZF9udW0gPSBkLmdldFRpbWUoKTtcbiAgdmFyIGphbnVhcnlmaXJzdCA9IChuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIDAsIDEpKS5nZXRUaW1lKCk7XG4gIHZhciBkb3kgPSBNYXRoLmZsb29yKChkX251bSAtIGphbnVhcnlmaXJzdCkgLyA4NjQwMDAwMCk7XG4gIHZhciBqYW4gPSBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIDAsIDEpO1xuICB2YXIganVsID0gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCA2LCAxKTtcbiAgdmFyIHN0ZFRpbWV6b25lT2Zmc2V0ID0gTWF0aC5tYXgoamFuLmdldFRpbWV6b25lT2Zmc2V0KCksIGp1bC5nZXRUaW1lem9uZU9mZnNldCgpKTtcbiAgcmV0dXJuIEJMT0NLKDAsIGQuZ2V0U2Vjb25kcygpLCBkLmdldE1pbnV0ZXMoKSwgZC5nZXRIb3VycygpLFxuICAgICAgICAgIGQuZ2V0RGF0ZSgpLCBkLmdldE1vbnRoKCksIGQuZ2V0RnVsbFllYXIoKSAtIDE5MDAsXG4gICAgICAgICAgZC5nZXREYXkoKSwgZG95LFxuICAgICAgICAgIChkLmdldFRpbWV6b25lT2Zmc2V0KCkgPCBzdGRUaW1lem9uZU9mZnNldCkgfCAwIC8qIGRheWxpZ2h0IHNhdmluZ3MgdGltZSAgZmllbGQuICovKVxufVxuXG4vL1Byb3ZpZGVzOiB1bml4X21rdGltZVxuLy9SZXF1aXJlczogdW5peF9sb2NhbHRpbWVcbmZ1bmN0aW9uIHVuaXhfbWt0aW1lKHRtKXtcbiAgdmFyIGQgPSAobmV3IERhdGUodG1bNl0rMTkwMCx0bVs1XSx0bVs0XSx0bVszXSx0bVsyXSx0bVsxXSkpLmdldFRpbWUoKTtcbiAgdmFyIHQgPSBNYXRoLmZsb29yKGQgLyAxMDAwKTtcbiAgdmFyIHRtMiA9IHVuaXhfbG9jYWx0aW1lKHQpO1xuICByZXR1cm4gQkxPQ0soMCx0LHRtMik7XG59XG5cbi8vUHJvdmlkZXM6IHdpbl9zdGFydHVwIGNvbnN0XG5mdW5jdGlvbiB3aW5fc3RhcnR1cCgpIHt9XG5cbi8vUHJvdmlkZXM6IHdpbl9jbGVhbnVwIGNvbnN0XG5mdW5jdGlvbiB3aW5fY2xlYW51cCgpIHt9XG5cbi8vUHJvdmlkZXM6IHdpbl9oYW5kbGVfZmQgY29uc3RcbmZ1bmN0aW9uIHdpbl9oYW5kbGVfZmQoeCkge3JldHVybiB4O31cbiIsIi8vIEpzX29mX29jYW1sIGxpYnJhcnlcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBKc2xpYjogY29kZSBzcGVjaWZpYyB0byBKc19vZl9vY2FtbFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Zyb21fYm9vbCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fYm9vbCh4KSB7IHJldHVybiAhIXg7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fYm9vbCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2Jvb2woeCkgeyByZXR1cm4gK3g7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9mbG9hdCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fZmxvYXQoeCkgeyByZXR1cm4geDsgfVxuLy9Qcm92aWRlczogY2FtbF9qc190b19mbG9hdCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2Zsb2F0KHgpIHsgcmV0dXJuIHg7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9zdHJpbmcgbXV0YWJsZSAoY29uc3QpXG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fc3RyaW5nKHMpIHsgcmV0dXJuIHMudG9TdHJpbmcoKTsgfVxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX2FycmF5IG11dGFibGUgKHNoYWxsb3cpXG4vL1JlcXVpcmVzOiByYXdfYXJyYXlfc3ViXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fYXJyYXkoYSkgeyByZXR1cm4gcmF3X2FycmF5X3N1YihhLDEsYS5sZW5ndGgtMSk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fYXJyYXkgbXV0YWJsZSAoc2hhbGxvdylcbi8vUmVxdWlyZXM6IHJhd19hcnJheV9jb25zXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2FycmF5KGEpIHsgcmV0dXJuIHJhd19hcnJheV9jb25zKGEsMCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc192YXIgbXV0YWJsZSAoY29uc3QpXG4vL1JlcXVpcmVzOiBqc19wcmludF9zdGRlcnJcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfanNfdmFyKHgpIHtcbiAgdmFyIHggPSB4LnRvU3RyaW5nKCk7XG4gIC8vQ2hlY2tzIHRoYXQgeCBoYXMgdGhlIGZvcm0gaWRlbnRbLmlkZW50XSpcbiAgaWYoIXgubWF0Y2goL15bYS16QS1aXyRdW2EtekEtWl8kMC05XSooXFwuW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qKSokLykpe1xuICAgIGpzX3ByaW50X3N0ZGVycihcImNhbWxfanNfdmFyOiBcXFwiXCIgKyB4ICsgXCJcXFwiIGlzIG5vdCBhIHZhbGlkIEphdmFTY3JpcHQgdmFyaWFibGUuIGNvbnRpbnVpbmcgLi5cIik7XG4gICAgLy9qb29fZ2xvYmFsX29iamVjdC5jb25zb2xlLmVycm9yKFwiSnMuVW5zYWZlLmV2YWxfc3RyaW5nXCIpXG4gIH1cbiAgcmV0dXJuIGV2YWwoeCk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2NhbGwgKGNvbnN0LCBtdXRhYmxlLCBzaGFsbG93KVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2pzX2NhbGwoZiwgbywgYXJncykgeyByZXR1cm4gZi5hcHBseShvLCBjYW1sX2pzX2Zyb21fYXJyYXkoYXJncykpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Z1bl9jYWxsIChjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9qc19mdW5fY2FsbChmLCBhKSB7XG4gIHN3aXRjaCAoYS5sZW5ndGgpIHtcbiAgY2FzZSAxOiByZXR1cm4gZigpO1xuICBjYXNlIDI6IHJldHVybiBmIChhWzFdKTtcbiAgY2FzZSAzOiByZXR1cm4gZiAoYVsxXSxhWzJdKTtcbiAgY2FzZSA0OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10pO1xuICBjYXNlIDU6IHJldHVybiBmIChhWzFdLGFbMl0sYVszXSxhWzRdKTtcbiAgY2FzZSA2OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdKTtcbiAgY2FzZSA3OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0pO1xuICBjYXNlIDg6IHJldHVybiBmIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSxhWzddKTtcbiAgfVxuICByZXR1cm4gZi5hcHBseShudWxsLCBjYW1sX2pzX2Zyb21fYXJyYXkoYSkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc19tZXRoX2NhbGwgKG11dGFibGUsIGNvbnN0LCBzaGFsbG93KVxuLy9SZXF1aXJlczogTWxCeXRlc1xuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2pzX21ldGhfY2FsbChvLCBmLCBhcmdzKSB7XG4gIHJldHVybiBvW2YudG9TdHJpbmcoKV0uYXBwbHkobywgY2FtbF9qc19mcm9tX2FycmF5KGFyZ3MpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfbmV3IChjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9qc19uZXcoYywgYSkge1xuICBzd2l0Y2ggKGEubGVuZ3RoKSB7XG4gIGNhc2UgMTogcmV0dXJuIG5ldyBjO1xuICBjYXNlIDI6IHJldHVybiBuZXcgYyAoYVsxXSk7XG4gIGNhc2UgMzogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0pO1xuICBjYXNlIDQ6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10pO1xuICBjYXNlIDU6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10sYVs0XSk7XG4gIGNhc2UgNjogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0pO1xuICBjYXNlIDc6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0pO1xuICBjYXNlIDg6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0sYVs3XSk7XG4gIH1cbiAgZnVuY3Rpb24gRigpIHsgcmV0dXJuIGMuYXBwbHkodGhpcywgY2FtbF9qc19mcm9tX2FycmF5KGEpKTsgfVxuICBGLnByb3RvdHlwZSA9IGMucHJvdG90eXBlO1xuICByZXR1cm4gbmV3IEY7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX29qc19uZXdfYXJyIChjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9vanNfbmV3X2FycihjLCBhKSB7XG4gIHN3aXRjaCAoYS5sZW5ndGgpIHtcbiAgY2FzZSAwOiByZXR1cm4gbmV3IGM7XG4gIGNhc2UgMTogcmV0dXJuIG5ldyBjIChhWzBdKTtcbiAgY2FzZSAyOiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSk7XG4gIGNhc2UgMzogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSk7XG4gIGNhc2UgNDogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSxhWzNdKTtcbiAgY2FzZSA1OiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSxhWzJdLGFbM10sYVs0XSk7XG4gIGNhc2UgNjogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSk7XG4gIGNhc2UgNzogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdKTtcbiAgfVxuICBmdW5jdGlvbiBGKCkgeyByZXR1cm4gYy5hcHBseSh0aGlzLCBhKTsgfVxuICBGLnByb3RvdHlwZSA9IGMucHJvdG90eXBlO1xuICByZXR1cm4gbmV3IEY7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfY2FsbGJhY2sgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlblxuZnVuY3Rpb24gY2FtbF9qc193cmFwX2NhbGxiYWNrKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZihhcmd1bWVudHMubGVuZ3RoID4gMCl7XG4gICAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBhcmd1bWVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBbdW5kZWZpbmVkXSk7XG4gICAgfVxuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9jYWxsYmFja19hcmd1bWVudHNcbi8vUmVxdWlyZXM6IGNhbWxfanNfd3JhcF9jYWxsYmFja1xuZnVuY3Rpb24gY2FtbF9qc193cmFwX2NhbGxiYWNrX2FyZ3VtZW50cyhmKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY2FtbF9qc193cmFwX2NhbGxiYWNrKGYpKGFyZ3VtZW50cyk7XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9jYWxsYmFja19zdHJpY3QgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9jYWxsYmFja19zdHJpY3QoYXJpdHksIGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYobiA9PSBhcml0eSkgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgYXJndW1lbnRzKTtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcml0eSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuICYmIGkgPCBhcml0eTsgaSsrKSBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIGFyZ3MpO1xuICB9O1xufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2sgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlbixyYXdfYXJyYXlfY29uc1xuZnVuY3Rpb24gY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2soZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYscmF3X2FycmF5X2NvbnMoYXJndW1lbnRzLHRoaXMpKTtcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfYXJndW1lbnRzIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW4scmF3X2FycmF5X2NvbnNcbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX2FyZ3VtZW50cyhmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZixbdGhpcyxhcmd1bWVudHNdKTtcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfc3RyaWN0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuLCByYXdfYXJyYXlfY29uc1xuZnVuY3Rpb24gY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfc3RyaWN0KGFyaXR5LCBmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmKG4gPT0gYXJpdHkpIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIHJhd19hcnJheV9jb25zKGFyZ3VtZW50cyx0aGlzKSk7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJpdHkgKyAxKTtcbiAgICBhcmdzWzBdID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IG4gJiYgaSA8PSBhcml0eTsgaSsrKSBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIGFyZ3MpO1xuICB9O1xufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfdW5zYWZlIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW4scmF3X2FycmF5X2NvbnNcbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3Vuc2FmZShmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7IGYuYXBwbHkobnVsbCwgcmF3X2FycmF5X2NvbnMoYXJndW1lbnRzLHRoaXMpKTsgfVxufVxuLy9Qcm92aWRlczogY2FtbF9qc19lcXVhbHMgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19lcXVhbHMgKHgsIHkpIHsgcmV0dXJuICsoeCA9PSB5KTsgfVxuLy9Qcm92aWRlczogY2FtbF9qc190b19ieXRlX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9uZXdfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2J5dGVfc3RyaW5nIChzKSB7cmV0dXJuIGNhbWxfbmV3X3N0cmluZyAocyk7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2V2YWxfc3RyaW5nIChjb25zdClcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfanNfZXZhbF9zdHJpbmcgKHMpIHtyZXR1cm4gZXZhbChzLnRvU3RyaW5nKCkpO31cblxuLy9Qcm92aWRlczogY2FtbF9qc19leHByIChjb25zdClcbi8vUmVxdWlyZXM6IGpzX3ByaW50X3N0ZGVyclxuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9qc19leHByKHMpIHtcbiAganNfcHJpbnRfc3RkZXJyKFwiY2FtbF9qc19leHByOiBmYWxsYmFjayB0byBydW50aW1lIGV2YWx1YXRpb25cIik7XG4gIHJldHVybiBldmFsKHMudG9TdHJpbmcoKSk7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3B1cmVfanNfZXhwciBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBqc19wcmludF9zdGRlcnJcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfcHVyZV9qc19leHByIChzKXtcbiAganNfcHJpbnRfc3RkZXJyKFwiY2FtbF9wdXJlX2pzX2V4cHI6IGZhbGxiYWNrIHRvIHJ1bnRpbWUgZXZhbHVhdGlvblwiKTtcbiAgcmV0dXJuIGV2YWwocy50b1N0cmluZygpKTt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfb2JqZWN0IChvYmplY3RfbGl0ZXJhbClcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfanNfb2JqZWN0IChhKSB7XG4gIHZhciBvID0ge307XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwID0gYVtpXTtcbiAgICBvW3BbMV0udG9TdHJpbmcoKV0gPSBwWzJdO1xuICB9XG4gIHJldHVybiBvO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXhwb3J0X3ZhclxuZnVuY3Rpb24gY2FtbF9qc19leHBvcnRfdmFyICgpe1xuICBpZih0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpXG4gICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzXG4gIGVsc2VcbiAgICByZXR1cm4gam9vX2dsb2JhbF9vYmplY3Q7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBsaWJyYXJ5XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSnNsaWJcblxuLy9Qcm92aWRlczogY2FtbF9qc19wdXJlX2V4cHIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfanNfcHVyZV9leHByIChmKSB7IHJldHVybiBmKCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19zZXQgKG11dGFibGUsIGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfc2V0KG8sZix2KSB7IG9bZl09djtyZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZ2V0IG11dGFibGUgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZ2V0KG8sZikgeyByZXR1cm4gb1tmXTsgfVxuLy9Qcm92aWRlczogY2FtbF9qc19kZWxldGUgKG11dGFibGUsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19kZWxldGUobyxmKSB7IGRlbGV0ZSBvW2ZdOyByZXR1cm4gMH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19pbnN0YW5jZW9mIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2luc3RhbmNlb2YobyxjKSB7IHJldHVybiBvIGluc3RhbmNlb2YgYzsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3R5cGVvZiAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX3R5cGVvZihvKSB7IHJldHVybiB0eXBlb2YgbzsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX29uX2llIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2pzX29uX2llICgpIHtcbiAgdmFyIHVhID1cbiAgICAgIGpvb19nbG9iYWxfb2JqZWN0Lm5hdmlnYXRvcj9qb29fZ2xvYmFsX29iamVjdC5uYXZpZ2F0b3IudXNlckFnZW50OlwiXCI7XG4gIHJldHVybiB1YS5pbmRleE9mKFwiTVNJRVwiKSAhPSAtMSAmJiB1YS5pbmRleE9mKFwiT3BlcmFcIikgIT0gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc19odG1sX2VzY2FwZSBjb25zdCAoY29uc3QpXG52YXIgY2FtbF9qc19yZWdleHBzID0geyBhbXA6LyYvZywgbHQ6LzwvZywgcXVvdDovXFxcIi9nLCBhbGw6L1smPFxcXCJdLyB9O1xuZnVuY3Rpb24gY2FtbF9qc19odG1sX2VzY2FwZSAocykge1xuICBpZiAoIWNhbWxfanNfcmVnZXhwcy5hbGwudGVzdChzKSkgcmV0dXJuIHM7XG4gIHJldHVybiBzLnJlcGxhY2UoY2FtbF9qc19yZWdleHBzLmFtcCwgXCImYW1wO1wiKVxuICAgIC5yZXBsYWNlKGNhbWxfanNfcmVnZXhwcy5sdCwgXCImbHQ7XCIpXG4gICAgLnJlcGxhY2UoY2FtbF9qc19yZWdleHBzLnF1b3QsIFwiJnF1b3Q7XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2h0bWxfZW50aXRpZXNcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfanNfaHRtbF9lbnRpdGllcyhzKSB7XG4gIHZhciBlbnRpdHkgPSAvXiYjP1swLTlhLXpBLVpdKzskL1xuICBpZihzLm1hdGNoKGVudGl0eSkpXG4gIHtcbiAgICB2YXIgc3RyLCB0ZW1wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuICAgIHRlbXAuaW5uZXJIVE1MPSBzO1xuICAgIHN0cj0gdGVtcC50ZXh0Q29udGVudCB8fCB0ZW1wLmlubmVyVGV4dDtcbiAgICB0ZW1wPW51bGw7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBlbHNlIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiSW52YWxpZCBlbnRpdHkgXCIgKyBzKTtcbiAgfVxufVxuXG4vLy8vLy8vLy8vLyBEZWJ1Z2dpbmcgY29uc29sZVxuLy9Qcm92aWRlczogY2FtbF9qc19nZXRfY29uc29sZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9qc19nZXRfY29uc29sZSAoKSB7XG4gIHZhciBjID0gam9vX2dsb2JhbF9vYmplY3QuY29uc29sZT9qb29fZ2xvYmFsX29iamVjdC5jb25zb2xlOnt9O1xuICB2YXIgbSA9IFtcImxvZ1wiLCBcImRlYnVnXCIsIFwiaW5mb1wiLCBcIndhcm5cIiwgXCJlcnJvclwiLCBcImFzc2VydFwiLCBcImRpclwiLCBcImRpcnhtbFwiLFxuICAgICAgICAgICBcInRyYWNlXCIsIFwiZ3JvdXBcIiwgXCJncm91cENvbGxhcHNlZFwiLCBcImdyb3VwRW5kXCIsIFwidGltZVwiLCBcInRpbWVFbmRcIl07XG4gIGZ1bmN0aW9uIGYgKCkge31cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSsrKSBpZiAoIWNbbVtpXV0pIGNbbVtpXV09ZjtcbiAgcmV0dXJuIGM7XG59XG5cbi8vUHJvdmlkZXM6Y2FtbF90cmFtcG9saW5lXG5mdW5jdGlvbiBjYW1sX3RyYW1wb2xpbmUocmVzKSB7XG4gIHZhciBjID0gMTtcbiAgd2hpbGUocmVzICYmIHJlcy5qb29fdHJhbXApe1xuICAgIHJlcyA9IHJlcy5qb29fdHJhbXAuYXBwbHkobnVsbCwgcmVzLmpvb19hcmdzKTtcbiAgICBjKys7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczpjYW1sX3RyYW1wb2xpbmVfcmV0dXJuXG5mdW5jdGlvbiBjYW1sX3RyYW1wb2xpbmVfcmV0dXJuKGYsYXJncykge1xuICByZXR1cm4ge2pvb190cmFtcDpmLGpvb19hcmdzOmFyZ3N9O1xufVxuXG4vL1Byb3ZpZGVzOiBqc19wcmludF9zdGRvdXQgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF91dGYxNl9vZl91dGY4XG5mdW5jdGlvbiBqc19wcmludF9zdGRvdXQocykge1xuICB2YXIgcyA9IGNhbWxfdXRmMTZfb2ZfdXRmOChzKTtcbiAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgaWYgKGcucHJvY2VzcyAmJiBnLnByb2Nlc3Muc3Rkb3V0ICYmIGcucHJvY2Vzcy5zdGRvdXQud3JpdGUpIHtcbiAgICBnLnByb2Nlc3Muc3Rkb3V0LndyaXRlKHMpXG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gbm90IG91dHB1dCB0aGUgbGFzdCBcXG4gaWYgcHJlc2VudFxuICAgIC8vIGFzIGNvbnNvbGUgbG9nZ2luZyBkaXNwbGF5IGEgbmV3bGluZSBhdCB0aGUgZW5kXG4gICAgaWYocy5jaGFyQ29kZUF0KHMubGVuZ3RoIC0gMSkgPT0gMTApXG4gICAgICBzID0gcy5zdWJzdHIoMCxzLmxlbmd0aCAtIDEgKTtcbiAgICB2YXIgdiA9IGcuY29uc29sZTtcbiAgICB2ICAmJiB2LmxvZyAmJiB2LmxvZyhzKTtcbiAgfVxufVxuLy9Qcm92aWRlczoganNfcHJpbnRfc3RkZXJyIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfdXRmMTZfb2ZfdXRmOFxuZnVuY3Rpb24ganNfcHJpbnRfc3RkZXJyKHMpIHtcbiAgdmFyIHMgPSBjYW1sX3V0ZjE2X29mX3V0Zjgocyk7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIGlmIChnLnByb2Nlc3MgJiYgZy5wcm9jZXNzLnN0ZG91dCAmJiBnLnByb2Nlc3Muc3Rkb3V0LndyaXRlKSB7XG4gICAgZy5wcm9jZXNzLnN0ZGVyci53cml0ZShzKVxuICB9IGVsc2Uge1xuICAgIC8vIERvIG5vdCBvdXRwdXQgdGhlIGxhc3QgXFxuIGlmIHByZXNlbnRcbiAgICAvLyBhcyBjb25zb2xlIGxvZ2dpbmcgZGlzcGxheSBhIG5ld2xpbmUgYXQgdGhlIGVuZFxuICAgIGlmKHMuY2hhckNvZGVBdChzLmxlbmd0aCAtIDEpID09IDEwKVxuICAgICAgcyA9IHMuc3Vic3RyKDAscy5sZW5ndGggLSAxICk7XG4gICAgdmFyIHYgPSBnLmNvbnNvbGU7XG4gICAgdiAmJiB2LmVycm9yICYmIHYuZXJyb3Iocyk7XG4gIH1cbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfQ2FtbGludGVybmFsTW9kX2luaXRfbW9kXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfYXJnLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX0NhbWxpbnRlcm5hbE1vZF9pbml0X21vZChsb2Msc2hhcGUpIHtcbiAgZnVuY3Rpb24gdW5kZWZfbW9kdWxlIChfeCkge1xuICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmcoY2FtbF9nbG9iYWxfZGF0YS5VbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZSwgbG9jKTtcbiAgfVxuICBmdW5jdGlvbiBsb29wIChzaGFwZSxzdHJ1Y3QsaWR4KXtcbiAgICBpZih0eXBlb2Ygc2hhcGUgPT09IFwibnVtYmVyXCIpXG4gICAgICBzd2l0Y2goc2hhcGUpe1xuICAgICAgY2FzZSAwOi8vZnVuY3Rpb25cbiAgICAgICAgc3RydWN0W2lkeF09e2Z1bjp1bmRlZl9tb2R1bGV9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTovL2xhenlcbiAgICAgICAgc3RydWN0W2lkeF09WzI0NiwgdW5kZWZfbW9kdWxlXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0Oi8vY2FzZSAyOi8vY2xhc3NcbiAgICAgICAgc3RydWN0W2lkeF09W107XG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgc3dpdGNoKHNoYXBlWzBdKXtcbiAgICAgIGNhc2UgMDovL21vZHVsZVxuICAgICAgICBzdHJ1Y3RbaWR4XSA9IFswXTtcbiAgICAgICAgZm9yKHZhciBpPTE7aTxzaGFwZVsxXS5sZW5ndGg7aSsrKVxuICAgICAgICAgIGxvb3Aoc2hhcGVbMV1baV0sc3RydWN0W2lkeF0saSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDovL2Nhc2UgMTovL1ZhbHVlXG4gICAgICAgIHN0cnVjdFtpZHhdID0gc2hhcGVbMV07XG4gICAgICB9XG4gIH1cbiAgdmFyIHJlcyA9IFtdO1xuICBsb29wKHNoYXBlLHJlcywwKTtcbiAgcmV0dXJuIHJlc1swXVxufVxuLy9Qcm92aWRlczogY2FtbF9DYW1saW50ZXJuYWxNb2RfdXBkYXRlX21vZFxuLy9SZXF1aXJlczogY2FtbF91cGRhdGVfZHVtbXlcbmZ1bmN0aW9uIGNhbWxfQ2FtbGludGVybmFsTW9kX3VwZGF0ZV9tb2Qoc2hhcGUscmVhbCx4KSB7XG4gIGlmKHR5cGVvZiBzaGFwZSA9PT0gXCJudW1iZXJcIilcbiAgICBzd2l0Y2goc2hhcGUpe1xuICAgIGNhc2UgMDovL2Z1bmN0aW9uXG4gICAgICByZWFsLmZ1biA9IHg7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6Ly9sYXp5XG4gICAgZGVmYXVsdDovL2Nhc2UgMjovL2NsYXNzXG4gICAgICBjYW1sX3VwZGF0ZV9kdW1teShyZWFsLHgpO1xuICAgIH1cbiAgZWxzZVxuICAgIHN3aXRjaChzaGFwZVswXSl7XG4gICAgY2FzZSAwOi8vbW9kdWxlXG4gICAgICBmb3IodmFyIGk9MTtpPHNoYXBlWzFdLmxlbmd0aDtpKyspXG4gICAgICAgIGNhbWxfQ2FtbGludGVybmFsTW9kX3VwZGF0ZV9tb2Qoc2hhcGVbMV1baV0scmVhbFtpXSx4W2ldKTtcbiAgICAgIGJyZWFrO1xuICAgICAgLy9jYXNlIDE6Ly9WYWx1ZVxuICAgIGRlZmF1bHQ6XG4gICAgfTtcbiAgcmV0dXJuIDBcbn1cbiIsIi8vLy8vLy8vLyBCSUdTVFJJTkdcblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9iaWdzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfc3RyaW5nX2FyclxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9iaWdzdHJpbmcoaCwgYnMpIHtcbiAgcmV0dXJuIGNhbWxfaGFzaF9taXhfc3RyaW5nX2FycihoLGJzLmRhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfdG9fYXJyYXlfYnVmZmVyIG11dGFibGVcbmZ1bmN0aW9uIGJpZ3N0cmluZ190b19hcnJheV9idWZmZXIoYnMpIHtcbiAgcmV0dXJuIGJzLmRhdGEuYnVmZmVyXG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ190b190eXBlZF9hcnJheSBtdXRhYmxlXG5mdW5jdGlvbiBiaWdzdHJpbmdfdG9fdHlwZWRfYXJyYXkoYnMpIHtcbiAgcmV0dXJuIGJzLmRhdGFcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX29mX2FycmF5X2J1ZmZlciBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbmZ1bmN0aW9uIGJpZ3N0cmluZ19vZl9hcnJheV9idWZmZXIoYWIpIHtcbiAgdmFyIHRhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkoYWIpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKDEyLCAwLCBbdGEubGVuZ3RoXSwgdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfb2ZfdHlwZWRfYXJyYXkgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG5mdW5jdGlvbiBiaWdzdHJpbmdfb2ZfdHlwZWRfYXJyYXkoYmEpIHtcbiAgdmFyIHRhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkoYmEuYnVmZmVyLCBiYS5ieXRlT2Zmc2V0LCBiYS5sZW5ndGggKiBiYS5CWVRFU19QRVJfRUxFTUVOVCk7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoMTIsIDAsIFt0YS5sZW5ndGhdLCB0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX21lbWNtcFxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfMVxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfbWVtY21wKHMxLCBwb3MxLCBzMiwgcG9zMiwgbGVuKXtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBhID0gY2FtbF9iYV9nZXRfMShzMSxwb3MxICsgaSk7XG4gICAgdmFyIGIgPSBjYW1sX2JhX2dldF8xKHMyLHBvczIgKyBpKTtcbiAgICBpZiAoYSA8IGIpIHJldHVybiAtMTtcbiAgICBpZiAoYSA+IGIpIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmEoYmExLCBwb3MxLCBiYTIsIHBvczIsIGxlbil7XG4gIGlmKDEyICE9IGJhMS5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmKDEyICE9IGJhMi5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmKGxlbiA9PSAwKSByZXR1cm4gMDtcbiAgdmFyIG9mczEgPSBiYTEub2Zmc2V0KHBvczEpO1xuICB2YXIgb2ZzMiA9IGJhMi5vZmZzZXQocG9zMik7XG4gIGlmKG9mczEgKyBsZW4gPiBiYTEuZGF0YS5sZW5ndGgpe1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICBpZihvZnMyICsgbGVuID4gYmEyLmRhdGEubGVuZ3RoKXtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgdmFyIHNsaWNlID0gYmExLmRhdGEuc3ViYXJyYXkob2ZzMSxvZnMxK2xlbik7XG4gIGJhMi5kYXRhLnNldChzbGljZSxwb3MyKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmFcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9hcnJheV9vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhKHN0cjEsIHBvczEsIGJhMiwgcG9zMiwgbGVuKXtcbiAgaWYoMTIgIT0gYmEyLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmKGxlbiA9PSAwKSByZXR1cm4gMDtcbiAgdmFyIG9mczIgPSBiYTIub2Zmc2V0KHBvczIpO1xuICBpZihwb3MxICsgbGVuID4gc3RyMS5sKSB7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIGlmKG9mczIgKyBsZW4gPiBiYTIuZGF0YS5sZW5ndGgpIHtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgdmFyIHNsaWNlID0gY2FtbF9hcnJheV9vZl9zdHJpbmcoc3RyMSkuc2xpY2UocG9zMSxwb3MxICsgbGVuKTtcbiAgYmEyLmRhdGEuc2V0KHNsaWNlLG9mczIpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYXJyYXlfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfYmxpdF9ieXRlcywgY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXMoYmExLCBwb3MxLCBieXRlczIsIHBvczIsIGxlbil7XG4gIGlmKDEyICE9IGJhMS5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhOiBraW5kIG1pc21hdGNoXCIpO1xuICBpZihsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIHZhciBvZnMxID0gYmExLm9mZnNldChwb3MxKTtcbiAgaWYob2ZzMSArIGxlbiA+IGJhMS5kYXRhLmxlbmd0aCl7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIGlmKHBvczIgKyBsZW4gPiBieXRlczIubCl7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIHZhciBzbGljZSA9IGJhMS5kYXRhLnNsaWNlKG9mczEsIG9mczErbGVuKTtcbiAgY2FtbF9ibGl0X2J5dGVzKGNhbWxfc3RyaW5nX29mX2FycmF5KHNsaWNlKSwgMCwgYnl0ZXMyLCBwb3MyLCBsZW4pO1xuICByZXR1cm4gMFxufVxuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3RpdmUgQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAqL1xuLyogIGVuIEF1dG9tYXRpcXVlLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCAgICAqL1xuLyogIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlLCB3aXRoICAgICAqL1xuLyogIHRoZSBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiBmaWxlIC4uL0xJQ0VOU0UuICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKiAkSWQ6IGxleGluZy5jIDYwNDUgMjAwNC0wMS0wMSAxNjo0Mjo0M1ogZG9saWdleiAkICovXG5cbi8qIFRoZSB0YWJsZS1kcml2ZW4gYXV0b21hdG9uIGZvciBsZXhlcnMgZ2VuZXJhdGVkIGJ5IGNhbWxsZXguICovXG5cbi8vUHJvdmlkZXM6IGNhbWxfbGV4X2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2xleF9hcnJheShzKSB7XG4gIHMgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHMpO1xuICB2YXIgbCA9IHMubGVuZ3RoIC8gMjtcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgIGFbaV0gPSAocy5jaGFyQ29kZUF0KDIgKiBpKSB8IChzLmNoYXJDb2RlQXQoMiAqIGkgKyAxKSA8PCA4KSkgPDwgMTYgPj4gMTY7XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xleF9lbmdpbmVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIGNhbWxfbGV4X2FycmF5LCBjYW1sX2FycmF5X29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9sZXhfZW5naW5lKHRibCwgc3RhcnRfc3RhdGUsIGxleGJ1Zikge1xuICB2YXIgbGV4X2J1ZmZlciA9IDI7XG4gIHZhciBsZXhfYnVmZmVyX2xlbiA9IDM7XG4gIHZhciBsZXhfc3RhcnRfcG9zID0gNTtcbiAgdmFyIGxleF9jdXJyX3BvcyA9IDY7XG4gIHZhciBsZXhfbGFzdF9wb3MgPSA3O1xuICB2YXIgbGV4X2xhc3RfYWN0aW9uID0gODtcbiAgdmFyIGxleF9lb2ZfcmVhY2hlZCA9IDk7XG4gIHZhciBsZXhfYmFzZSA9IDE7XG4gIHZhciBsZXhfYmFja3RyayA9IDI7XG4gIHZhciBsZXhfZGVmYXVsdCA9IDM7XG4gIHZhciBsZXhfdHJhbnMgPSA0O1xuICB2YXIgbGV4X2NoZWNrID0gNTtcblxuICBpZiAoIXRibC5sZXhfZGVmYXVsdCkge1xuICAgIHRibC5sZXhfYmFzZSA9ICAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2Jhc2VdKTtcbiAgICB0YmwubGV4X2JhY2t0cmsgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYWNrdHJrXSk7XG4gICAgdGJsLmxleF9jaGVjayA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfY2hlY2tdKTtcbiAgICB0YmwubGV4X3RyYW5zID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF90cmFuc10pO1xuICAgIHRibC5sZXhfZGVmYXVsdCA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2RlZmF1bHRdKTtcbiAgfVxuXG4gIHZhciBjLCBzdGF0ZSA9IHN0YXJ0X3N0YXRlO1xuXG4gIHZhciBidWZmZXIgPSBjYW1sX2FycmF5X29mX3N0cmluZyhsZXhidWZbbGV4X2J1ZmZlcl0pO1xuXG4gIGlmIChzdGF0ZSA+PSAwKSB7XG4gICAgLyogRmlyc3QgZW50cnkgKi9cbiAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfc3RhcnRfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID0gLTE7XG4gIH0gZWxzZSB7XG4gICAgLyogUmVlbnRyeSBhZnRlciByZWZpbGwgKi9cbiAgICBzdGF0ZSA9IC1zdGF0ZSAtIDE7XG4gIH1cbiAgZm9yKDs7KSB7XG4gICAgLyogTG9va3VwIGJhc2UgYWRkcmVzcyBvciBhY3Rpb24gbnVtYmVyIGZvciBjdXJyZW50IHN0YXRlICovXG4gICAgdmFyIGJhc2UgPSB0YmwubGV4X2Jhc2Vbc3RhdGVdO1xuICAgIGlmIChiYXNlIDwgMCkgcmV0dXJuIC1iYXNlLTE7XG4gICAgLyogU2VlIGlmIGl0J3MgYSBiYWNrdHJhY2sgcG9pbnQgKi9cbiAgICB2YXIgYmFja3RyayA9IHRibC5sZXhfYmFja3Rya1tzdGF0ZV07XG4gICAgaWYgKGJhY2t0cmsgPj0gMCkge1xuICAgICAgbGV4YnVmW2xleF9sYXN0X3Bvc10gPSBsZXhidWZbbGV4X2N1cnJfcG9zXTtcbiAgICAgIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID0gYmFja3RyaztcbiAgICB9XG4gICAgLyogU2VlIGlmIHdlIG5lZWQgYSByZWZpbGwgKi9cbiAgICBpZiAobGV4YnVmW2xleF9jdXJyX3Bvc10gPj0gbGV4YnVmW2xleF9idWZmZXJfbGVuXSl7XG4gICAgICBpZiAobGV4YnVmW2xleF9lb2ZfcmVhY2hlZF0gPT0gMClcbiAgICAgICAgcmV0dXJuIC1zdGF0ZSAtIDE7XG4gICAgICBlbHNlXG4gICAgICAgIGMgPSAyNTY7XG4gICAgfWVsc2V7XG4gICAgICAvKiBSZWFkIG5leHQgaW5wdXQgY2hhciAqL1xuICAgICAgYyA9IGJ1ZmZlcltsZXhidWZbbGV4X2N1cnJfcG9zXV07XG4gICAgICBsZXhidWZbbGV4X2N1cnJfcG9zXSArKztcbiAgICB9XG4gICAgLyogRGV0ZXJtaW5lIG5leHQgc3RhdGUgKi9cbiAgICBpZiAodGJsLmxleF9jaGVja1tiYXNlICsgY10gPT0gc3RhdGUpXG4gICAgICBzdGF0ZSA9IHRibC5sZXhfdHJhbnNbYmFzZSArIGNdO1xuICAgIGVsc2VcbiAgICAgIHN0YXRlID0gdGJsLmxleF9kZWZhdWx0W3N0YXRlXTtcbiAgICAvKiBJZiBubyB0cmFuc2l0aW9uIG9uIHRoaXMgY2hhciwgcmV0dXJuIHRvIGxhc3QgYmFja3RyYWNrIHBvaW50ICovXG4gICAgaWYgKHN0YXRlIDwgMCkge1xuICAgICAgbGV4YnVmW2xleF9jdXJyX3Bvc10gPSBsZXhidWZbbGV4X2xhc3RfcG9zXTtcbiAgICAgIGlmIChsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9PSAtMSlcbiAgICAgICAgY2FtbF9mYWlsd2l0aChcImxleGluZzogZW1wdHkgdG9rZW5cIik7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXTtcbiAgICB9ZWxzZXtcbiAgICAgIC8qIEVyYXNlIHRoZSBFT0YgY29uZGl0aW9uIG9ubHkgaWYgdGhlIEVPRiBwc2V1ZG8tY2hhcmFjdGVyIHdhc1xuICAgICAgICAgY29uc3VtZWQgYnkgdGhlIGF1dG9tYXRvbiAoaS5lLiB0aGVyZSB3YXMgbm8gYmFja3RyYWNrIGFib3ZlKVxuICAgICAgKi9cbiAgICAgIGlmIChjID09IDI1NikgbGV4YnVmW2xleF9lb2ZfcmVhY2hlZF0gPSAwO1xuICAgIH1cbiAgfVxufVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiBOZXcgbGV4ZXIgZW5naW5lLCB3aXRoIG1lbW9yeSBvZiBwb3NpdGlvbnMgICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vUHJvdmlkZXM6IGNhbWxfbmV3X2xleF9lbmdpbmVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIGNhbWxfbGV4X2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX2FycmF5X29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9sZXhfcnVuX21lbShzLCBpLCBtZW0sIGN1cnJfcG9zKSB7XG4gIGZvciAoOzspIHtcbiAgICB2YXIgZHN0ID0gcy5jaGFyQ29kZUF0KGkpOyBpKys7XG4gICAgaWYgKGRzdCA9PSAweGZmKSByZXR1cm47XG4gICAgdmFyIHNyYyA9IHMuY2hhckNvZGVBdChpKTsgaSsrO1xuICAgIGlmIChzcmMgPT0gMHhmZilcbiAgICAgIG1lbSBbZHN0ICsgMV0gPSBjdXJyX3BvcztcbiAgICBlbHNlXG4gICAgICBtZW0gW2RzdCArIDFdID0gbWVtIFtzcmMgKyAxXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYW1sX2xleF9ydW5fdGFnKHMsIGksIG1lbSkge1xuICBmb3IgKDs7KSB7XG4gICAgdmFyIGRzdCA9IHMuY2hhckNvZGVBdChpKTsgaSsrO1xuICAgIGlmIChkc3QgPT0gMHhmZikgcmV0dXJuIDtcbiAgICB2YXIgc3JjID0gcy5jaGFyQ29kZUF0KGkpOyBpKys7XG4gICAgaWYgKHNyYyA9PSAweGZmKVxuICAgICAgbWVtIFtkc3QgKyAxXSA9IC0xO1xuICAgIGVsc2VcbiAgICAgIG1lbSBbZHN0ICsgMV0gPSBtZW0gW3NyYyArIDFdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbWxfbmV3X2xleF9lbmdpbmUodGJsLCBzdGFydF9zdGF0ZSwgbGV4YnVmKSB7XG4gIHZhciBsZXhfYnVmZmVyID0gMjtcbiAgdmFyIGxleF9idWZmZXJfbGVuID0gMztcbiAgdmFyIGxleF9zdGFydF9wb3MgPSA1O1xuICB2YXIgbGV4X2N1cnJfcG9zID0gNjtcbiAgdmFyIGxleF9sYXN0X3BvcyA9IDc7XG4gIHZhciBsZXhfbGFzdF9hY3Rpb24gPSA4O1xuICB2YXIgbGV4X2VvZl9yZWFjaGVkID0gOTtcbiAgdmFyIGxleF9tZW0gPSAxMDtcbiAgdmFyIGxleF9iYXNlID0gMTtcbiAgdmFyIGxleF9iYWNrdHJrID0gMjtcbiAgdmFyIGxleF9kZWZhdWx0ID0gMztcbiAgdmFyIGxleF90cmFucyA9IDQ7XG4gIHZhciBsZXhfY2hlY2sgPSA1O1xuICB2YXIgbGV4X2Jhc2VfY29kZSA9IDY7XG4gIHZhciBsZXhfYmFja3Rya19jb2RlID0gNztcbiAgdmFyIGxleF9kZWZhdWx0X2NvZGUgPSA4O1xuICB2YXIgbGV4X3RyYW5zX2NvZGUgPSA5O1xuICB2YXIgbGV4X2NoZWNrX2NvZGUgPSAxMDtcbiAgdmFyIGxleF9jb2RlID0gMTE7XG5cbiAgaWYgKCF0YmwubGV4X2RlZmF1bHQpIHtcbiAgICB0YmwubGV4X2Jhc2UgPSAgICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYXNlXSk7XG4gICAgdGJsLmxleF9iYWNrdHJrID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFja3Rya10pO1xuICAgIHRibC5sZXhfY2hlY2sgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2NoZWNrXSk7XG4gICAgdGJsLmxleF90cmFucyA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfdHJhbnNdKTtcbiAgICB0YmwubGV4X2RlZmF1bHQgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9kZWZhdWx0XSk7XG4gIH1cbiAgaWYgKCF0YmwubGV4X2RlZmF1bHRfY29kZSkge1xuICAgIHRibC5sZXhfYmFzZV9jb2RlID0gICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFzZV9jb2RlXSk7XG4gICAgdGJsLmxleF9iYWNrdHJrX2NvZGUgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYWNrdHJrX2NvZGVdKTtcbiAgICB0YmwubGV4X2NoZWNrX2NvZGUgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2NoZWNrX2NvZGVdKTtcbiAgICB0YmwubGV4X3RyYW5zX2NvZGUgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X3RyYW5zX2NvZGVdKTtcbiAgICB0YmwubGV4X2RlZmF1bHRfY29kZSA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2RlZmF1bHRfY29kZV0pO1xuICB9XG4gIGlmICh0YmwubGV4X2NvZGUgPT0gbnVsbCkgdGJsLmxleF9jb2RlID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyh0YmxbbGV4X2NvZGVdKTtcblxuICB2YXIgYywgc3RhdGUgPSBzdGFydF9zdGF0ZTtcblxuICB2YXIgYnVmZmVyID0gY2FtbF9hcnJheV9vZl9zdHJpbmcobGV4YnVmW2xleF9idWZmZXJdKTtcblxuICBpZiAoc3RhdGUgPj0gMCkge1xuICAgIC8qIEZpcnN0IGVudHJ5ICovXG4gICAgbGV4YnVmW2xleF9sYXN0X3Bvc10gPSBsZXhidWZbbGV4X3N0YXJ0X3Bvc10gPSBsZXhidWZbbGV4X2N1cnJfcG9zXTtcbiAgICBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9IC0xO1xuICB9IGVsc2Uge1xuICAgIC8qIFJlZW50cnkgYWZ0ZXIgcmVmaWxsICovXG4gICAgc3RhdGUgPSAtc3RhdGUgLSAxO1xuICB9XG4gIGZvcig7Oykge1xuICAgIC8qIExvb2t1cCBiYXNlIGFkZHJlc3Mgb3IgYWN0aW9uIG51bWJlciBmb3IgY3VycmVudCBzdGF0ZSAqL1xuICAgIHZhciBiYXNlID0gdGJsLmxleF9iYXNlW3N0YXRlXTtcbiAgICBpZiAoYmFzZSA8IDApIHtcbiAgICAgIHZhciBwY19vZmYgPSB0YmwubGV4X2Jhc2VfY29kZVtzdGF0ZV07XG4gICAgICBjYW1sX2xleF9ydW5fdGFnKHRibC5sZXhfY29kZSwgcGNfb2ZmLCBsZXhidWZbbGV4X21lbV0pO1xuICAgICAgcmV0dXJuIC1iYXNlLTE7XG4gICAgfVxuICAgIC8qIFNlZSBpZiBpdCdzIGEgYmFja3RyYWNrIHBvaW50ICovXG4gICAgdmFyIGJhY2t0cmsgPSB0YmwubGV4X2JhY2t0cmtbc3RhdGVdO1xuICAgIGlmIChiYWNrdHJrID49IDApIHtcbiAgICAgIHZhciBwY19vZmYgPSB0YmwubGV4X2JhY2t0cmtfY29kZVtzdGF0ZV07XG4gICAgICBjYW1sX2xleF9ydW5fdGFnKHRibC5sZXhfY29kZSwgcGNfb2ZmLCBsZXhidWZbbGV4X21lbV0pO1xuICAgICAgbGV4YnVmW2xleF9sYXN0X3Bvc10gPSBsZXhidWZbbGV4X2N1cnJfcG9zXTtcbiAgICAgIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID0gYmFja3RyaztcbiAgICB9XG4gICAgLyogU2VlIGlmIHdlIG5lZWQgYSByZWZpbGwgKi9cbiAgICBpZiAobGV4YnVmW2xleF9jdXJyX3Bvc10gPj0gbGV4YnVmW2xleF9idWZmZXJfbGVuXSl7XG4gICAgICBpZiAobGV4YnVmW2xleF9lb2ZfcmVhY2hlZF0gPT0gMClcbiAgICAgICAgcmV0dXJuIC1zdGF0ZSAtIDE7XG4gICAgICBlbHNlXG4gICAgICAgIGMgPSAyNTY7XG4gICAgfWVsc2V7XG4gICAgICAvKiBSZWFkIG5leHQgaW5wdXQgY2hhciAqL1xuICAgICAgYyA9IGJ1ZmZlcltsZXhidWZbbGV4X2N1cnJfcG9zXV07XG4gICAgICBsZXhidWZbbGV4X2N1cnJfcG9zXSArKztcbiAgICB9XG4gICAgLyogRGV0ZXJtaW5lIG5leHQgc3RhdGUgKi9cbiAgICB2YXIgcHN0YXRlID0gc3RhdGUgO1xuICAgIGlmICh0YmwubGV4X2NoZWNrW2Jhc2UgKyBjXSA9PSBzdGF0ZSlcbiAgICAgIHN0YXRlID0gdGJsLmxleF90cmFuc1tiYXNlICsgY107XG4gICAgZWxzZVxuICAgICAgc3RhdGUgPSB0YmwubGV4X2RlZmF1bHRbc3RhdGVdO1xuICAgIC8qIElmIG5vIHRyYW5zaXRpb24gb24gdGhpcyBjaGFyLCByZXR1cm4gdG8gbGFzdCBiYWNrdHJhY2sgcG9pbnQgKi9cbiAgICBpZiAoc3RhdGUgPCAwKSB7XG4gICAgICBsZXhidWZbbGV4X2N1cnJfcG9zXSA9IGxleGJ1ZltsZXhfbGFzdF9wb3NdO1xuICAgICAgaWYgKGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID09IC0xKVxuICAgICAgICBjYW1sX2ZhaWx3aXRoKFwibGV4aW5nOiBlbXB0eSB0b2tlblwiKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dO1xuICAgIH1lbHNle1xuICAgICAgLyogSWYgc29tZSB0cmFuc2l0aW9uLCBnZXQgYW5kIHBlcmZvcm0gbWVtb3J5IG1vdmVzICovXG4gICAgICB2YXIgYmFzZV9jb2RlID0gdGJsLmxleF9iYXNlX2NvZGVbcHN0YXRlXSwgcGNfb2ZmO1xuICAgICAgaWYgKHRibC5sZXhfY2hlY2tfY29kZVtiYXNlX2NvZGUgKyBjXSA9PSBwc3RhdGUpXG4gICAgICAgIHBjX29mZiA9IHRibC5sZXhfdHJhbnNfY29kZVtiYXNlX2NvZGUgKyBjXTtcbiAgICAgIGVsc2VcbiAgICAgICAgcGNfb2ZmID0gdGJsLmxleF9kZWZhdWx0X2NvZGVbcHN0YXRlXTtcbiAgICAgIGlmIChwY19vZmYgPiAwKVxuICAgICAgICBjYW1sX2xleF9ydW5fbWVtXG4gICAgICAodGJsLmxleF9jb2RlLCBwY19vZmYsIGxleGJ1ZltsZXhfbWVtXSwgbGV4YnVmW2xleF9jdXJyX3Bvc10pO1xuICAgICAgLyogRXJhc2UgdGhlIEVPRiBjb25kaXRpb24gb25seSBpZiB0aGUgRU9GIHBzZXVkby1jaGFyYWN0ZXIgd2FzXG4gICAgICAgICBjb25zdW1lZCBieSB0aGUgYXV0b21hdG9uIChpLmUuIHRoZXJlIHdhcyBubyBiYWNrdHJhY2sgYWJvdmUpXG4gICAgICAqL1xuICAgICAgaWYgKGMgPT0gMjU2KSBsZXhidWZbbGV4X2VvZl9yZWFjaGVkXSA9IDA7XG4gICAgfVxuICB9XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8gV2VhayBBUEksIGJ1dCB3aXRob3V0IHRoZSB3ZWFrIHNlbWFudGljc1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfa2V5X29mZnNldFxuLy9WZXJzaW9uOiA8IDQuMDNcbnZhciBjYW1sX2VwaGVfa2V5X29mZnNldCA9IDJcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbi8vVmVyc2lvbjogPj0gNC4wM1xudmFyIGNhbWxfZXBoZV9rZXlfb2Zmc2V0ID0gM1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vVmVyc2lvbjogPj0gNC4wM1xudmFyIGNhbWxfZXBoZV9kYXRhX29mZnNldCA9IDJcblxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXQsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF93ZWFrX2NyZWF0ZSAobikge1xuICBpZiAobiA8IDApIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJXZWFrLmNyZWF0ZVwiKTtcbiAgdmFyIHggPSBbMjUxLFwiY2FtbF9lcGhlX2xpc3RfaGVhZFwiXTtcbiAgeC5sZW5ndGggPSBjYW1sX2VwaGVfa2V5X29mZnNldCArIG47XG4gIHJldHVybiB4O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3dlYWtfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfa2V5X29mZnNldCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3dlYWtfc2V0KHgsIGksIHYpIHtcbiAgaWYoaSA8IDAgfHwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpID49IHgubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJXZWFrLnNldFwiKTtcbiAgeFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldID0gdjtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3dlYWtfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfa2V5X29mZnNldCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3dlYWtfZ2V0KHgsIGkpIHtcbiAgaWYoaSA8IDAgfHwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpID49IHgubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJXZWFrLmdldF9rZXlcIik7XG4gIHJldHVybiAoeFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGkgXT09PXVuZGVmaW5lZCk/MDp4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3dlYWtfZ2V0X2NvcHlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19nZXQsY2FtbF9lcGhlX2tleV9vZmZzZXRcbi8vUmVxdWlyZXM6IGNhbWxfb2JqX2R1cCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3dlYWtfZ2V0X2NvcHkoeCwgaSkge1xuICBpZihpIDwgMCB8fCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkgPj0geC5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuZ2V0X2NvcHlcIik7XG4gIHZhciB5ID0gY2FtbF93ZWFrX2dldCh4LCBpKTtcbiAgaWYgKHkgPT09IDApIHJldHVybiB5O1xuICB2YXIgeiA9IHlbMV07XG4gIGlmICh6IGluc3RhbmNlb2YgQXJyYXkpIHJldHVybiBbMCwgY2FtbF9vYmpfZHVwKHopXTtcbiAgcmV0dXJuIHk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19jaGVjayBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfa2V5X29mZnNldFxuZnVuY3Rpb24gY2FtbF93ZWFrX2NoZWNrKHgsIGkpIHtcbiAgaWYoeFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldIT09dW5kZWZpbmVkICYmIHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXSAhPT0wKVxuICAgIHJldHVybiAxO1xuICBlbHNlXG4gICAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19ibGl0XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JsaXRcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX3dlYWtfYmxpdChhMSwgaTEsIGEyLCBpMiwgbGVuKSB7XG4gIC8vIG1pbnVzIG9uZSBiZWNhdXNlIGNhbWxfYXJyYXlfYmxpdCB3b3JrcyBvbiBvY2FtbCBhcnJheVxuICBjYW1sX2FycmF5X2JsaXQoYTEsIGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaTEgLSAxLFxuICAgICAgICAgICAgICAgICAgYTIsIGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaTIgLSAxLFxuICAgICAgICAgICAgICAgICAgbGVuKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19jcmVhdGVcbnZhciBjYW1sX2VwaGVfY3JlYXRlID0gY2FtbF93ZWFrX2NyZWF0ZVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfYmxpdF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19ibGl0XG52YXIgY2FtbF9lcGhlX2JsaXRfa2V5ID0gY2FtbF93ZWFrX2JsaXRcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19nZXRcbnZhciBjYW1sX2VwaGVfZ2V0X2tleSA9IGNhbWxfd2Vha19nZXRcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9rZXlfY29weVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2dldF9jb3B5XG52YXIgY2FtbF9lcGhlX2dldF9rZXlfY29weSA9IGNhbWxfd2Vha19nZXRfY29weVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfY2hlY2tfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfY2hlY2tcbnZhciBjYW1sX2VwaGVfY2hlY2tfa2V5ID0gY2FtbF93ZWFrX2NoZWNrXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9zZXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfc2V0XG5mdW5jdGlvbiBjYW1sX2VwaGVfc2V0X2tleSh4LCBpLCB2KSB7XG4gIHJldHVybiBjYW1sX3dlYWtfc2V0KHgsIGksIFswLCB2XSlcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3Vuc2V0X2tleVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX3NldFxuZnVuY3Rpb24gY2FtbF9lcGhlX3Vuc2V0X2tleSh4LCBpKSB7XG4gIHJldHVybiBjYW1sX3dlYWtfc2V0KHgsIGksIDApXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9ibGl0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuLy9WZXJzaW9uOiA+PSA0LjAzXG5mdW5jdGlvbiBjYW1sX2VwaGVfYmxpdF9kYXRhKHNyYywgZHN0KXtcbiAgZHN0W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPSBzcmNbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9nZXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1ZlcnNpb246ID49IDQuMDNcbmZ1bmN0aW9uIGNhbWxfZXBoZV9nZXRfZGF0YSh4KXtcbiAgaWYoeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIDA7XG4gIGVsc2VcbiAgICByZXR1cm4gWzAsIHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9nZXRfZGF0YV9jb3B5XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vUmVxdWlyZXM6IGNhbWxfb2JqX2R1cFxuLy9WZXJzaW9uOiA+PSA0LjAzXG5mdW5jdGlvbiBjYW1sX2VwaGVfZ2V0X2RhdGFfY29weSh4KXtcbiAgaWYoeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIDA7XG4gIGVsc2VcbiAgICByZXR1cm4gWzAsIGNhbWxfb2JqX2R1cCh4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0pXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3NldF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vVmVyc2lvbjogPj0gNC4wM1xuZnVuY3Rpb24gY2FtbF9lcGhlX3NldF9kYXRhKHgsIGRhdGEpe1xuICB4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPSBkYXRhO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3Vuc2V0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuLy9WZXJzaW9uOiA+PSA0LjAzXG5mdW5jdGlvbiBjYW1sX2VwaGVfdW5zZXRfZGF0YSh4LCBkYXRhKXtcbiAgeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID0gdW5kZWZpbmVkO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2NoZWNrX2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuLy9WZXJzaW9uOiA+PSA0LjAzXG5mdW5jdGlvbiBjYW1sX2VwaGVfY2hlY2tfZGF0YSh4KXtcbiAgaWYoeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIDA7XG4gIGVsc2VcbiAgICByZXR1cm4gMTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWQ1X2NoYW5cbi8vUmVxdWlyZXM6IGNhbWxfbWQ1X3N0cmluZywgY2FtbF9zdHJpbmdfb2ZfYXJyYXksY2FtbF9tbF9jaGFubmVsc1xuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSwgY2FtbF9jcmVhdGVfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbWQ1X2NoYW4oY2hhbmlkLGxlbil7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICB2YXIgY2hhbl9sZW4gPSBjaGFuLmZpbGUubGVuZ3RoKCk7XG4gIGlmKGxlbjwwKSBsZW4gPSBjaGFuX2xlbiAtIGNoYW4ub2Zmc2V0O1xuICBpZihjaGFuLm9mZnNldCArIGxlbiA+IGNoYW5fbGVuKSBjYW1sX3JhaXNlX2VuZF9vZl9maWxlKCk7XG4gIHZhciBidWYgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICBjaGFuLmZpbGUucmVhZChjaGFuLm9mZnNldCxidWYsMCxsZW4pO1xuICByZXR1cm4gY2FtbF9tZDVfc3RyaW5nKGJ1ZiwwLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWQ1X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfYXJyYXksIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbnZhciBjYW1sX21kNV9zdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGFkZCAoeCwgeSkgeyByZXR1cm4gKHggKyB5KSB8IDA7IH1cbiAgZnVuY3Rpb24geHgocSxhLGIseCxzLHQpIHtcbiAgICBhID0gYWRkKGFkZChhLCBxKSwgYWRkKHgsIHQpKTtcbiAgICByZXR1cm4gYWRkKChhIDw8IHMpIHwgKGEgPj4+ICgzMiAtIHMpKSwgYik7XG4gIH1cbiAgZnVuY3Rpb24gZmYoYSxiLGMsZCx4LHMsdCkge1xuICAgIHJldHVybiB4eCgoYiAmIGMpIHwgKCh+YikgJiBkKSwgYSwgYiwgeCwgcywgdCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2coYSxiLGMsZCx4LHMsdCkge1xuICAgIHJldHVybiB4eCgoYiAmIGQpIHwgKGMgJiAofmQpKSwgYSwgYiwgeCwgcywgdCk7XG4gIH1cbiAgZnVuY3Rpb24gaGgoYSxiLGMsZCx4LHMsdCkgeyByZXR1cm4geHgoYiBeIGMgXiBkLCBhLCBiLCB4LCBzLCB0KTsgfVxuICBmdW5jdGlvbiBpaShhLGIsYyxkLHgscyx0KSB7IHJldHVybiB4eChjIF4gKGIgfCAofmQpKSwgYSwgYiwgeCwgcywgdCk7IH1cblxuICBmdW5jdGlvbiBtZDUoYnVmZmVyLCBsZW5ndGgpIHtcbiAgICB2YXIgaSA9IGxlbmd0aDtcbiAgICBidWZmZXJbaSA+PiAyXSB8PSAweDgwIDw8ICg4ICogKGkgJiAzKSk7XG4gICAgZm9yIChpID0gKGkgJiB+MHgzKSArIDg7KGkgJiAweDNGKSA8IDYwIDtpICs9IDQpXG4gICAgICBidWZmZXJbKGkgPj4gMikgLSAxXSA9IDA7XG4gICAgYnVmZmVyWyhpID4+IDIpIC0xXSA9IGxlbmd0aCA8PCAzO1xuICAgIGJ1ZmZlcltpID4+IDJdID0gKGxlbmd0aCA+PiAyOSkgJiAweDFGRkZGRkZGO1xuXG4gICAgdmFyIHcgPSBbMHg2NzQ1MjMwMSwgMHhFRkNEQUI4OSwgMHg5OEJBRENGRSwgMHgxMDMyNTQ3Nl07XG5cbiAgICBmb3IoaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgICB2YXIgYSA9IHdbMF0sIGIgPSB3WzFdLCBjID0gd1syXSwgZCA9IHdbM107XG5cbiAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXJbaSsgMF0sIDcsIDB4RDc2QUE0NzgpO1xuICAgICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyAxXSwgMTIsIDB4RThDN0I3NTYpO1xuICAgICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKyAyXSwgMTcsIDB4MjQyMDcwREIpO1xuICAgICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyAzXSwgMjIsIDB4QzFCRENFRUUpO1xuICAgICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA0XSwgNywgMHhGNTdDMEZBRik7XG4gICAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyW2krIDVdLCAxMiwgMHg0Nzg3QzYyQSk7XG4gICAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyW2krIDZdLCAxNywgMHhBODMwNDYxMyk7XG4gICAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyW2krIDddLCAyMiwgMHhGRDQ2OTUwMSk7XG4gICAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyW2krIDhdLCA3LCAweDY5ODA5OEQ4KTtcbiAgICAgIGQgPSBmZihkLCBhLCBiLCBjLCBidWZmZXJbaSsgOV0sIDEyLCAweDhCNDRGN0FGKTtcbiAgICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXJbaSsxMF0sIDE3LCAweEZGRkY1QkIxKTtcbiAgICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXJbaSsxMV0sIDIyLCAweDg5NUNEN0JFKTtcbiAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXJbaSsxMl0sIDcsIDB4NkI5MDExMjIpO1xuICAgICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKzEzXSwgMTIsIDB4RkQ5ODcxOTMpO1xuICAgICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzE0XSwgMTcsIDB4QTY3OTQzOEUpO1xuICAgICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzE1XSwgMjIsIDB4NDlCNDA4MjEpO1xuXG4gICAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyW2krIDFdLCA1LCAweEY2MUUyNTYyKTtcbiAgICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBidWZmZXJbaSsgNl0sIDksIDB4QzA0MEIzNDApO1xuICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzExXSwgMTQsIDB4MjY1RTVBNTEpO1xuICAgICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyAwXSwgMjAsIDB4RTlCNkM3QUEpO1xuICAgICAgYSA9IGdnKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA1XSwgNSwgMHhENjJGMTA1RCk7XG4gICAgICBkID0gZ2coZCwgYSwgYiwgYywgYnVmZmVyW2krMTBdLCA5LCAweDAyNDQxNDUzKTtcbiAgICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbaSsxNV0sIDE0LCAweEQ4QTFFNjgxKTtcbiAgICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBidWZmZXJbaSsgNF0sIDIwLCAweEU3RDNGQkM4KTtcbiAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbaSsgOV0sIDUsIDB4MjFFMUNERTYpO1xuICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKzE0XSwgOSwgMHhDMzM3MDdENik7XG4gICAgICBjID0gZ2coYywgZCwgYSwgYiwgYnVmZmVyW2krIDNdLCAxNCwgMHhGNEQ1MEQ4Nyk7XG4gICAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyW2krIDhdLCAyMCwgMHg0NTVBMTRFRCk7XG4gICAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyW2krMTNdLCA1LCAweEE5RTNFOTA1KTtcbiAgICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBidWZmZXJbaSsgMl0sIDksIDB4RkNFRkEzRjgpO1xuICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKyA3XSwgMTQsIDB4Njc2RjAyRDkpO1xuICAgICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzEyXSwgMjAsIDB4OEQyQTRDOEEpO1xuXG4gICAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyW2krIDVdLCA0LCAweEZGRkEzOTQyKTtcbiAgICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXJbaSsgOF0sIDExLCAweDg3NzFGNjgxKTtcbiAgICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbaSsxMV0sIDE2LCAweDZEOUQ2MTIyKTtcbiAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXJbaSsxNF0sIDIzLCAweEZERTUzODBDKTtcbiAgICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbaSsgMV0sIDQsIDB4QTRCRUVBNDQpO1xuICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA0XSwgMTEsIDB4NEJERUNGQTkpO1xuICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKyA3XSwgMTYsIDB4RjZCQjRCNjApO1xuICAgICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzEwXSwgMjMsIDB4QkVCRkJDNzApO1xuICAgICAgYSA9IGhoKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKzEzXSwgNCwgMHgyODlCN0VDNik7XG4gICAgICBkID0gaGgoZCwgYSwgYiwgYywgYnVmZmVyW2krIDBdLCAxMSwgMHhFQUExMjdGQSk7XG4gICAgICBjID0gaGgoYywgZCwgYSwgYiwgYnVmZmVyW2krIDNdLCAxNiwgMHhENEVGMzA4NSk7XG4gICAgICBiID0gaGgoYiwgYywgZCwgYSwgYnVmZmVyW2krIDZdLCAyMywgMHgwNDg4MUQwNSk7XG4gICAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyW2krIDldLCA0LCAweEQ5RDREMDM5KTtcbiAgICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXJbaSsxMl0sIDExLCAweEU2REI5OUU1KTtcbiAgICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbaSsxNV0sIDE2LCAweDFGQTI3Q0Y4KTtcbiAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXJbaSsgMl0sIDIzLCAweEM0QUM1NjY1KTtcblxuICAgICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyAwXSwgNiwgMHhGNDI5MjI0NCk7XG4gICAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyW2krIDddLCAxMCwgMHg0MzJBRkY5Nyk7XG4gICAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyW2krMTRdLCAxNSwgMHhBQjk0MjNBNyk7XG4gICAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyW2krIDVdLCAyMSwgMHhGQzkzQTAzOSk7XG4gICAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyW2krMTJdLCA2LCAweDY1NUI1OUMzKTtcbiAgICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbaSsgM10sIDEwLCAweDhGMENDQzkyKTtcbiAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbaSsxMF0sIDE1LCAweEZGRUZGNDdEKTtcbiAgICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbaSsgMV0sIDIxLCAweDg1ODQ1REQxKTtcbiAgICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXJbaSsgOF0sIDYsIDB4NkZBODdFNEYpO1xuICAgICAgZCA9IGlpKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKzE1XSwgMTAsIDB4RkUyQ0U2RTApO1xuICAgICAgYyA9IGlpKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKyA2XSwgMTUsIDB4QTMwMTQzMTQpO1xuICAgICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzEzXSwgMjEsIDB4NEUwODExQTEpO1xuICAgICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA0XSwgNiwgMHhGNzUzN0U4Mik7XG4gICAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyW2krMTFdLCAxMCwgMHhCRDNBRjIzNSk7XG4gICAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyW2krIDJdLCAxNSwgMHgyQUQ3RDJCQik7XG4gICAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyW2krIDldLCAyMSwgMHhFQjg2RDM5MSk7XG5cbiAgICAgIHdbMF0gPSBhZGQoYSwgd1swXSk7XG4gICAgICB3WzFdID0gYWRkKGIsIHdbMV0pO1xuICAgICAgd1syXSA9IGFkZChjLCB3WzJdKTtcbiAgICAgIHdbM10gPSBhZGQoZCwgd1szXSk7XG4gICAgfVxuXG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoMTYpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA0OyBqKyspXG4gICAgICAgIHRbaSAqIDQgKyBqXSA9ICh3W2ldID4+ICg4ICogaikpICYgMHhGRjtcbiAgICByZXR1cm4gdDtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAocywgb2ZzLCBsZW4pIHtcbiAgICAvLyBGSVg6IG1heWJlIHdlIHNob3VsZCBwZXJmb3JtIHRoZSBjb21wdXRhdGlvbiBieSBjaHVuayBvZiA2NCBieXRlc1xuICAgIC8vIGFzIGluIGh0dHA6Ly93d3cubXllcnNkYWlseS5vcmcvam9zZXBoL2phdmFzY3JpcHQvbWQ1LmpzXG4gICAgdmFyIGJ1ZiA9IFtdO1xuICAgIHN3aXRjaCAocy50ICYgNikge1xuICAgIGRlZmF1bHQ6XG4gICAgICBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMpO1xuICAgIGNhc2UgMDogLyogQllURVMgKi9cbiAgICAgIHZhciBiID0gcy5jO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrPTQpIHtcbiAgICAgICAgdmFyIGogPSBpICsgb2ZzO1xuICAgICAgICBidWZbaT4+Ml0gPVxuICAgICAgICAgIGIuY2hhckNvZGVBdChqKSB8IChiLmNoYXJDb2RlQXQoaisxKSA8PCA4KSB8XG4gICAgICAgICAgKGIuY2hhckNvZGVBdChqKzIpIDw8IDE2KSB8IChiLmNoYXJDb2RlQXQoaiszKSA8PCAyNCk7XG4gICAgICB9XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSBidWZbaT4+Ml0gfD0gYi5jaGFyQ29kZUF0KGkgKyBvZnMpIDw8ICg4ICogKGkgJiAzKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQ6IC8qIEFSUkFZICovXG4gICAgICB2YXIgYSA9IHMuYztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKz00KSB7XG4gICAgICAgIHZhciBqID0gaSArIG9mcztcbiAgICAgICAgYnVmW2k+PjJdID0gYVtqXSB8IChhW2orMV0gPDwgOCkgfCAoYVtqKzJdIDw8IDE2KSB8IChhW2orM10gPDwgMjQpO1xuICAgICAgfVxuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykgYnVmW2k+PjJdIHw9IGFbaSArIG9mc10gPDwgKDggKiAoaSAmIDMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5KG1kNShidWYsIGxlbikpO1xuICB9XG59ICgpO1xuIiwiLy9UaGUgZm9sbG93aW5nIGFyZSBkZWZpbmVkIGluIENzdHJ1Y3Rcbi8vVGhlcmUgYXJlIGp1c3QgcHJvdmlkZWQgaGVyZSBmb3IgY29tcGF0aWJpbGl0eSByZWFzb25zXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fYmlnc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhXG4vL1dlYWtkZWZcbnZhciBjYW1sX2JsaXRfYmlnc3RyaW5nX3RvX2JpZ3N0cmluZyA9IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmFcbi8vUHJvdmlkZXM6IGNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2J5dGVzXG4vL1dlYWtkZWZcbnZhciBjYW1sX2JsaXRfYmlnc3RyaW5nX3RvX3N0cmluZyA9IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXNcbi8vUHJvdmlkZXM6IGNhbWxfYmxpdF9zdHJpbmdfdG9fYmlnc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYVxuLy9XZWFrZGVmXG52YXIgY2FtbF9ibGl0X3N0cmluZ190b19iaWdzdHJpbmcgPSBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYVxuIixudWxsLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgIERhbmllbCBDLiBCdWVuemxpICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE0IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4dGVybmFsIGZvcm1hdF9pbnQgOiBzdHJpbmcgLT4gaW50IC0+IHN0cmluZyA9IFwiY2FtbF9mb3JtYXRfaW50XCJcblxubGV0IGVycl9ub19wcmVkID0gXCJVKzAwMDAgaGFzIG5vIHByZWRlY2Vzc29yXCJcbmxldCBlcnJfbm9fc3VjYyA9IFwiVSsxMEZGRkYgaGFzIG5vIHN1Y2Nlc3NvclwiXG5sZXQgZXJyX25vdF9zdiBpID0gZm9ybWF0X2ludCBcIiVYXCIgaSBeIFwiIGlzIG5vdCBhbiBVbmljb2RlIHNjYWxhciB2YWx1ZVwiXG5sZXQgZXJyX25vdF9sYXRpbjEgdSA9IFwiVStcIiBeIGZvcm1hdF9pbnQgXCIlMDRYXCIgdSBeIFwiIGlzIG5vdCBhIGxhdGluMSBjaGFyYWN0ZXJcIlxuXG50eXBlIHQgPSBpbnRcblxubGV0IG1pbiA9IDB4MDAwMFxubGV0IG1heCA9IDB4MTBGRkZGXG5sZXQgbG9fYm91bmQgPSAweEQ3RkZcbmxldCBoaV9ib3VuZCA9IDB4RTAwMFxuXG5sZXQgYm9tID0gMHhGRUZGXG5sZXQgcmVwID0gMHhGRkZEXG5cbmxldCBzdWNjIHUgPVxuICBpZiB1ID0gbG9fYm91bmQgdGhlbiBoaV9ib3VuZCBlbHNlXG4gIGlmIHUgPSBtYXggdGhlbiBpbnZhbGlkX2FyZyBlcnJfbm9fc3VjYyBlbHNlXG4gIHUgKyAxXG5cbmxldCBwcmVkIHUgPVxuICBpZiB1ID0gaGlfYm91bmQgdGhlbiBsb19ib3VuZCBlbHNlXG4gIGlmIHUgPSBtaW4gdGhlbiBpbnZhbGlkX2FyZyBlcnJfbm9fcHJlZCBlbHNlXG4gIHUgLSAxXG5cbmxldCBpc192YWxpZCBpID0gKG1pbiA8PSBpICYmIGkgPD0gbG9fYm91bmQpIHx8IChoaV9ib3VuZCA8PSBpICYmIGkgPD0gbWF4KVxubGV0IG9mX2ludCBpID0gaWYgaXNfdmFsaWQgaSB0aGVuIGkgZWxzZSBpbnZhbGlkX2FyZyAoZXJyX25vdF9zdiBpKVxuZXh0ZXJuYWwgdW5zYWZlX29mX2ludCA6IGludCAtPiB0ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgdG9faW50IDogdCAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5cbmxldCBpc19jaGFyIHUgPSB1IDwgMjU2XG5sZXQgb2ZfY2hhciBjID0gQ2hhci5jb2RlIGNcbmxldCB0b19jaGFyIHUgPVxuICBpZiB1ID4gMjU1IHRoZW4gaW52YWxpZF9hcmcgKGVycl9ub3RfbGF0aW4xIHUpIGVsc2VcbiAgQ2hhci51bnNhZmVfY2hyIHVcblxubGV0IHVuc2FmZV90b19jaGFyID0gQ2hhci51bnNhZmVfY2hyXG5cbmxldCBlcXVhbCA6IGludCAtPiBpbnQgLT4gYm9vbCA9ICggPSApXG5sZXQgY29tcGFyZSA6IGludCAtPiBpbnQgLT4gaW50ID0gUGVydmFzaXZlcy5jb21wYXJlXG5sZXQgaGFzaCA9IHRvX2ludFxuIiwiIzIgXCJzdGRsaWIvc3lzLm1scFwiXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFdBUk5JTkc6IHN5cy5tbCBpcyBnZW5lcmF0ZWQgZnJvbSBzeXMubWxwLiAgRE8gTk9UIEVESVQgc3lzLm1sIG9yXG4gICB5b3VyIGNoYW5nZXMgd2lsbCBiZSBsb3N0LlxuKilcblxudHlwZSBiYWNrZW5kX3R5cGUgPVxuICB8IE5hdGl2ZVxuICB8IEJ5dGVjb2RlXG4gIHwgT3RoZXIgb2Ygc3RyaW5nXG4oKiBTeXN0ZW0gaW50ZXJmYWNlICopXG5cbmV4dGVybmFsIGdldF9jb25maWc6IHVuaXQgLT4gc3RyaW5nICogaW50ICogYm9vbCA9IFwiY2FtbF9zeXNfZ2V0X2NvbmZpZ1wiXG5leHRlcm5hbCBnZXRfYXJndjogdW5pdCAtPiBzdHJpbmcgKiBzdHJpbmcgYXJyYXkgPSBcImNhbWxfc3lzX2dldF9hcmd2XCJcbmV4dGVybmFsIGJpZ19lbmRpYW4gOiB1bml0IC0+IGJvb2wgPSBcIiViaWdfZW5kaWFuXCJcbmV4dGVybmFsIHdvcmRfc2l6ZSA6IHVuaXQgLT4gaW50ID0gXCIld29yZF9zaXplXCJcbmV4dGVybmFsIGludF9zaXplIDogdW5pdCAtPiBpbnQgPSBcIiVpbnRfc2l6ZVwiXG5leHRlcm5hbCBtYXhfd29zaXplIDogdW5pdCAtPiBpbnQgPSBcIiVtYXhfd29zaXplXCJcbmV4dGVybmFsIHVuaXggOiB1bml0IC0+IGJvb2wgPSBcIiVvc3R5cGVfdW5peFwiXG5leHRlcm5hbCB3aW4zMiA6IHVuaXQgLT4gYm9vbCA9IFwiJW9zdHlwZV93aW4zMlwiXG5leHRlcm5hbCBjeWd3aW4gOiB1bml0IC0+IGJvb2wgPSBcIiVvc3R5cGVfY3lnd2luXCJcbmV4dGVybmFsIGdldF9iYWNrZW5kX3R5cGUgOiB1bml0IC0+IGJhY2tlbmRfdHlwZSA9IFwiJWJhY2tlbmRfdHlwZVwiXG5cbmxldCAoZXhlY3V0YWJsZV9uYW1lLCBhcmd2KSA9IGdldF9hcmd2KClcbmxldCAob3NfdHlwZSwgXywgXykgPSBnZXRfY29uZmlnKClcbmxldCBiYWNrZW5kX3R5cGUgPSBnZXRfYmFja2VuZF90eXBlICgpXG5sZXQgYmlnX2VuZGlhbiA9IGJpZ19lbmRpYW4gKClcbmxldCB3b3JkX3NpemUgPSB3b3JkX3NpemUgKClcbmxldCBpbnRfc2l6ZSA9IGludF9zaXplICgpXG5sZXQgdW5peCA9IHVuaXggKClcbmxldCB3aW4zMiA9IHdpbjMyICgpXG5sZXQgY3lnd2luID0gY3lnd2luICgpXG5sZXQgbWF4X2FycmF5X2xlbmd0aCA9IG1heF93b3NpemUgKClcbmxldCBtYXhfc3RyaW5nX2xlbmd0aCA9IHdvcmRfc2l6ZSAvIDggKiBtYXhfYXJyYXlfbGVuZ3RoIC0gMVxuZXh0ZXJuYWwgcnVudGltZV92YXJpYW50IDogdW5pdCAtPiBzdHJpbmcgPSBcImNhbWxfcnVudGltZV92YXJpYW50XCJcbmV4dGVybmFsIHJ1bnRpbWVfcGFyYW1ldGVycyA6IHVuaXQgLT4gc3RyaW5nID0gXCJjYW1sX3J1bnRpbWVfcGFyYW1ldGVyc1wiXG5cbmV4dGVybmFsIGZpbGVfZXhpc3RzOiBzdHJpbmcgLT4gYm9vbCA9IFwiY2FtbF9zeXNfZmlsZV9leGlzdHNcIlxuZXh0ZXJuYWwgaXNfZGlyZWN0b3J5IDogc3RyaW5nIC0+IGJvb2wgPSBcImNhbWxfc3lzX2lzX2RpcmVjdG9yeVwiXG5leHRlcm5hbCByZW1vdmU6IHN0cmluZyAtPiB1bml0ID0gXCJjYW1sX3N5c19yZW1vdmVcIlxuZXh0ZXJuYWwgcmVuYW1lIDogc3RyaW5nIC0+IHN0cmluZyAtPiB1bml0ID0gXCJjYW1sX3N5c19yZW5hbWVcIlxuZXh0ZXJuYWwgZ2V0ZW52OiBzdHJpbmcgLT4gc3RyaW5nID0gXCJjYW1sX3N5c19nZXRlbnZcIlxuXG5sZXQgZ2V0ZW52X29wdCBzID1cbiAgKCogVE9ETzogZXhwb3NlIGEgbm9uLXJhaXNpbmcgcHJpbWl0aXZlIGRpcmVjdGx5LiAqKVxuICB0cnkgU29tZSAoZ2V0ZW52IHMpXG4gIHdpdGggTm90X2ZvdW5kIC0+IE5vbmVcblxuZXh0ZXJuYWwgY29tbWFuZDogc3RyaW5nIC0+IGludCA9IFwiY2FtbF9zeXNfc3lzdGVtX2NvbW1hbmRcIlxuZXh0ZXJuYWwgdGltZTogdW5pdCAtPiAoZmxvYXQgW0B1bmJveGVkXSkgPVxuICBcImNhbWxfc3lzX3RpbWVcIiBcImNhbWxfc3lzX3RpbWVfdW5ib3hlZFwiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjaGRpcjogc3RyaW5nIC0+IHVuaXQgPSBcImNhbWxfc3lzX2NoZGlyXCJcbmV4dGVybmFsIGdldGN3ZDogdW5pdCAtPiBzdHJpbmcgPSBcImNhbWxfc3lzX2dldGN3ZFwiXG5leHRlcm5hbCByZWFkZGlyIDogc3RyaW5nIC0+IHN0cmluZyBhcnJheSA9IFwiY2FtbF9zeXNfcmVhZF9kaXJlY3RvcnlcIlxuXG5sZXQgaW50ZXJhY3RpdmUgPSByZWYgZmFsc2VcblxudHlwZSBzaWduYWxfYmVoYXZpb3IgPVxuICAgIFNpZ25hbF9kZWZhdWx0XG4gIHwgU2lnbmFsX2lnbm9yZVxuICB8IFNpZ25hbF9oYW5kbGUgb2YgKGludCAtPiB1bml0KVxuXG5leHRlcm5hbCBzaWduYWwgOiBpbnQgLT4gc2lnbmFsX2JlaGF2aW9yIC0+IHNpZ25hbF9iZWhhdmlvclxuICAgICAgICAgICAgICAgID0gXCJjYW1sX2luc3RhbGxfc2lnbmFsX2hhbmRsZXJcIlxuXG5sZXQgc2V0X3NpZ25hbCBzaWdfbnVtIHNpZ19iZWggPSBpZ25vcmUoc2lnbmFsIHNpZ19udW0gc2lnX2JlaClcblxubGV0IHNpZ2FicnQgPSAtMVxubGV0IHNpZ2Fscm0gPSAtMlxubGV0IHNpZ2ZwZSA9IC0zXG5sZXQgc2lnaHVwID0gLTRcbmxldCBzaWdpbGwgPSAtNVxubGV0IHNpZ2ludCA9IC02XG5sZXQgc2lna2lsbCA9IC03XG5sZXQgc2lncGlwZSA9IC04XG5sZXQgc2lncXVpdCA9IC05XG5sZXQgc2lnc2VndiA9IC0xMFxubGV0IHNpZ3Rlcm0gPSAtMTFcbmxldCBzaWd1c3IxID0gLTEyXG5sZXQgc2lndXNyMiA9IC0xM1xubGV0IHNpZ2NobGQgPSAtMTRcbmxldCBzaWdjb250ID0gLTE1XG5sZXQgc2lnc3RvcCA9IC0xNlxubGV0IHNpZ3RzdHAgPSAtMTdcbmxldCBzaWd0dGluID0gLTE4XG5sZXQgc2lndHRvdSA9IC0xOVxubGV0IHNpZ3Z0YWxybSA9IC0yMFxubGV0IHNpZ3Byb2YgPSAtMjFcbmxldCBzaWdidXMgPSAtMjJcbmxldCBzaWdwb2xsID0gLTIzXG5sZXQgc2lnc3lzID0gLTI0XG5sZXQgc2lndHJhcCA9IC0yNVxubGV0IHNpZ3VyZyA9IC0yNlxubGV0IHNpZ3hjcHUgPSAtMjdcbmxldCBzaWd4ZnN6ID0gLTI4XG5cbmV4Y2VwdGlvbiBCcmVha1xuXG5sZXQgY2F0Y2hfYnJlYWsgb24gPVxuICBpZiBvbiB0aGVuXG4gICAgc2V0X3NpZ25hbCBzaWdpbnQgKFNpZ25hbF9oYW5kbGUoZnVuIF8gLT4gcmFpc2UgQnJlYWspKVxuICBlbHNlXG4gICAgc2V0X3NpZ25hbCBzaWdpbnQgU2lnbmFsX2RlZmF1bHRcblxuXG5leHRlcm5hbCBlbmFibGVfcnVudGltZV93YXJuaW5nczogYm9vbCAtPiB1bml0ID1cbiAgXCJjYW1sX21sX2VuYWJsZV9ydW50aW1lX3dhcm5pbmdzXCJcbmV4dGVybmFsIHJ1bnRpbWVfd2FybmluZ3NfZW5hYmxlZDogdW5pdCAtPiBib29sID1cbiAgXCJjYW1sX21sX3J1bnRpbWVfd2FybmluZ3NfZW5hYmxlZFwiXG5cbigqIFRoZSB2ZXJzaW9uIHN0cmluZyBpcyBmb3VuZCBpbiBmaWxlIC4uL1ZFUlNJT04gKilcblxubGV0IG9jYW1sX3ZlcnNpb24gPSBcIjQuMDYuMFwiXG5cbigqIE9wdGltaXphdGlvbiAqKVxuXG5leHRlcm5hbCBvcGFxdWVfaWRlbnRpdHkgOiAnYSAtPiAnYSA9IFwiJW9wYXF1ZVwiXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbSW50NjRdOiA2NC1iaXQgaW50ZWdlcnMgKilcblxuZXh0ZXJuYWwgbmVnIDogaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9uZWdcIlxuZXh0ZXJuYWwgYWRkIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hZGRcIlxuZXh0ZXJuYWwgc3ViIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9zdWJcIlxuZXh0ZXJuYWwgbXVsIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9tdWxcIlxuZXh0ZXJuYWwgZGl2IDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9kaXZcIlxuZXh0ZXJuYWwgcmVtIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9tb2RcIlxuZXh0ZXJuYWwgbG9nYW5kIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hbmRcIlxuZXh0ZXJuYWwgbG9nb3IgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X29yXCJcbmV4dGVybmFsIGxvZ3hvciA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfeG9yXCJcbmV4dGVybmFsIHNoaWZ0X2xlZnQgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9sc2xcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHQgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hc3JcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHRfbG9naWNhbCA6IGludDY0IC0+IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X2xzclwiXG5leHRlcm5hbCBvZl9pbnQgOiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9pbnRcIlxuZXh0ZXJuYWwgdG9faW50IDogaW50NjQgLT4gaW50ID0gXCIlaW50NjRfdG9faW50XCJcbmV4dGVybmFsIG9mX2Zsb2F0IDogZmxvYXQgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfb2ZfZmxvYXRcIiBcImNhbWxfaW50NjRfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0b19mbG9hdCA6IGludDY0IC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDY0X3RvX2Zsb2F0XCIgXCJjYW1sX2ludDY0X3RvX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgb2ZfaW50MzIgOiBpbnQzMiAtPiBpbnQ2NCA9IFwiJWludDY0X29mX2ludDMyXCJcbmV4dGVybmFsIHRvX2ludDMyIDogaW50NjQgLT4gaW50MzIgPSBcIiVpbnQ2NF90b19pbnQzMlwiXG5leHRlcm5hbCBvZl9uYXRpdmVpbnQgOiBuYXRpdmVpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9uYXRpdmVpbnRcIlxuZXh0ZXJuYWwgdG9fbmF0aXZlaW50IDogaW50NjQgLT4gbmF0aXZlaW50ID0gXCIlaW50NjRfdG9fbmF0aXZlaW50XCJcblxubGV0IHplcm8gPSAwTFxubGV0IG9uZSA9IDFMXG5sZXQgbWludXNfb25lID0gLTFMXG5sZXQgc3VjYyBuID0gYWRkIG4gMUxcbmxldCBwcmVkIG4gPSBzdWIgbiAxTFxubGV0IGFicyBuID0gaWYgbiA+PSAwTCB0aGVuIG4gZWxzZSBuZWcgblxubGV0IG1pbl9pbnQgPSAweDgwMDAwMDAwMDAwMDAwMDBMXG5sZXQgbWF4X2ludCA9IDB4N0ZGRkZGRkZGRkZGRkZGRkxcbmxldCBsb2dub3QgbiA9IGxvZ3hvciBuICgtMUwpXG5cbmV4dGVybmFsIGZvcm1hdCA6IHN0cmluZyAtPiBpbnQ2NCAtPiBzdHJpbmcgPSBcImNhbWxfaW50NjRfZm9ybWF0XCJcbmxldCB0b19zdHJpbmcgbiA9IGZvcm1hdCBcIiVkXCIgblxuXG5leHRlcm5hbCBvZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50NjQgPSBcImNhbWxfaW50NjRfb2Zfc3RyaW5nXCJcblxubGV0IG9mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IGV4cG9zZSBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZSBkaXJlY3RseS4gKilcbiAgdHJ5IFNvbWUgKG9mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cblxuXG5leHRlcm5hbCBiaXRzX29mX2Zsb2F0IDogZmxvYXQgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfYml0c19vZl9mbG9hdFwiIFwiY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZmxvYXRfb2ZfYml0cyA6IGludDY0IC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNcIiBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c191bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxudHlwZSB0ID0gaW50NjRcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFBlcnZhc2l2ZXMuY29tcGFyZSB4IHlcbmxldCBlcXVhbCAoeDogdCkgKHk6IHQpID0gY29tcGFyZSB4IHkgPSAwXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFRoZSBydW4tdGltZSBsaWJyYXJ5IGZvciBsZXhlcnMgZ2VuZXJhdGVkIGJ5IGNhbWxsZXggKilcblxudHlwZSBwb3NpdGlvbiA9IHtcbiAgcG9zX2ZuYW1lIDogc3RyaW5nO1xuICBwb3NfbG51bSA6IGludDtcbiAgcG9zX2JvbCA6IGludDtcbiAgcG9zX2NudW0gOiBpbnQ7XG59XG5cbmxldCBkdW1teV9wb3MgPSB7XG4gIHBvc19mbmFtZSA9IFwiXCI7XG4gIHBvc19sbnVtID0gMDtcbiAgcG9zX2JvbCA9IDA7XG4gIHBvc19jbnVtID0gLTE7XG59XG5cbnR5cGUgbGV4YnVmID1cbiAgeyByZWZpbGxfYnVmZiA6IGxleGJ1ZiAtPiB1bml0O1xuICAgIG11dGFibGUgbGV4X2J1ZmZlciA6IGJ5dGVzO1xuICAgIG11dGFibGUgbGV4X2J1ZmZlcl9sZW4gOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfYWJzX3BvcyA6IGludDtcbiAgICBtdXRhYmxlIGxleF9zdGFydF9wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfY3Vycl9wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfbGFzdF9wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfbGFzdF9hY3Rpb24gOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfZW9mX3JlYWNoZWQgOiBib29sO1xuICAgIG11dGFibGUgbGV4X21lbSA6IGludCBhcnJheTtcbiAgICBtdXRhYmxlIGxleF9zdGFydF9wIDogcG9zaXRpb247XG4gICAgbXV0YWJsZSBsZXhfY3Vycl9wIDogcG9zaXRpb247XG4gIH1cblxudHlwZSBsZXhfdGFibGVzID1cbiAgeyBsZXhfYmFzZTogc3RyaW5nO1xuICAgIGxleF9iYWNrdHJrOiBzdHJpbmc7XG4gICAgbGV4X2RlZmF1bHQ6IHN0cmluZztcbiAgICBsZXhfdHJhbnM6IHN0cmluZztcbiAgICBsZXhfY2hlY2s6IHN0cmluZztcbiAgICBsZXhfYmFzZV9jb2RlIDogc3RyaW5nO1xuICAgIGxleF9iYWNrdHJrX2NvZGUgOiBzdHJpbmc7XG4gICAgbGV4X2RlZmF1bHRfY29kZSA6IHN0cmluZztcbiAgICBsZXhfdHJhbnNfY29kZSA6IHN0cmluZztcbiAgICBsZXhfY2hlY2tfY29kZSA6IHN0cmluZztcbiAgICBsZXhfY29kZTogc3RyaW5nO31cblxuZXh0ZXJuYWwgY19lbmdpbmUgOiBsZXhfdGFibGVzIC0+IGludCAtPiBsZXhidWYgLT4gaW50ID0gXCJjYW1sX2xleF9lbmdpbmVcIlxuZXh0ZXJuYWwgY19uZXdfZW5naW5lIDogbGV4X3RhYmxlcyAtPiBpbnQgLT4gbGV4YnVmIC0+IGludFxuICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX25ld19sZXhfZW5naW5lXCJcblxubGV0IGVuZ2luZSB0Ymwgc3RhdGUgYnVmID1cbiAgbGV0IHJlc3VsdCA9IGNfZW5naW5lIHRibCBzdGF0ZSBidWYgaW5cbiAgaWYgcmVzdWx0ID49IDAgdGhlbiBiZWdpblxuICAgIGJ1Zi5sZXhfc3RhcnRfcCA8LSBidWYubGV4X2N1cnJfcDtcbiAgICBidWYubGV4X2N1cnJfcCA8LSB7YnVmLmxleF9jdXJyX3BcbiAgICAgICAgICAgICAgICAgICAgICAgd2l0aCBwb3NfY251bSA9IGJ1Zi5sZXhfYWJzX3BvcyArIGJ1Zi5sZXhfY3Vycl9wb3N9O1xuICBlbmQ7XG4gIHJlc3VsdFxuXG5cbmxldCBuZXdfZW5naW5lIHRibCBzdGF0ZSBidWYgPVxuICBsZXQgcmVzdWx0ID0gY19uZXdfZW5naW5lIHRibCBzdGF0ZSBidWYgaW5cbiAgaWYgcmVzdWx0ID49IDAgdGhlbiBiZWdpblxuICAgIGJ1Zi5sZXhfc3RhcnRfcCA8LSBidWYubGV4X2N1cnJfcDtcbiAgICBidWYubGV4X2N1cnJfcCA8LSB7YnVmLmxleF9jdXJyX3BcbiAgICAgICAgICAgICAgICAgICAgICAgd2l0aCBwb3NfY251bSA9IGJ1Zi5sZXhfYWJzX3BvcyArIGJ1Zi5sZXhfY3Vycl9wb3N9O1xuICBlbmQ7XG4gIHJlc3VsdFxuXG5cbmxldCBsZXhfcmVmaWxsIHJlYWRfZnVuIGF1eF9idWZmZXIgbGV4YnVmID1cbiAgbGV0IHJlYWQgPVxuICAgIHJlYWRfZnVuIGF1eF9idWZmZXIgKEJ5dGVzLmxlbmd0aCBhdXhfYnVmZmVyKSBpblxuICBsZXQgbiA9XG4gICAgaWYgcmVhZCA+IDBcbiAgICB0aGVuIHJlYWRcbiAgICBlbHNlIChsZXhidWYubGV4X2VvZl9yZWFjaGVkIDwtIHRydWU7IDApIGluXG4gICgqIEN1cnJlbnQgc3RhdGUgb2YgdGhlIGJ1ZmZlcjpcbiAgICAgICAgPC0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tPlxuICAgICAgICB8ICBqdW5rIHwgICAgICB2YWxpZCBkYXRhICAgICB8ICAganVuayAgICB8XG4gICAgICAgIF4gICAgICAgXiAgICAgICAgICAgICAgICAgICAgIF4gICAgICAgICAgIF5cbiAgICAgICAgMCAgICBzdGFydF9wb3MgICAgICAgICAgICAgYnVmZmVyX2VuZCAgICBCeXRlcy5sZW5ndGggYnVmZmVyXG4gICopXG4gIGlmIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiArIG4gPiBCeXRlcy5sZW5ndGggbGV4YnVmLmxleF9idWZmZXIgdGhlbiBiZWdpblxuICAgICgqIFRoZXJlIGlzIG5vdCBlbm91Z2ggc3BhY2UgYXQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyICopXG4gICAgaWYgbGV4YnVmLmxleF9idWZmZXJfbGVuIC0gbGV4YnVmLmxleF9zdGFydF9wb3MgKyBuXG4gICAgICAgPD0gQnl0ZXMubGVuZ3RoIGxleGJ1Zi5sZXhfYnVmZmVyXG4gICAgdGhlbiBiZWdpblxuICAgICAgKCogQnV0IHRoZXJlIGlzIGVub3VnaCBzcGFjZSBpZiB3ZSByZWNsYWltIHRoZSBqdW5rIGF0IHRoZSBiZWdpbm5pbmdcbiAgICAgICAgIG9mIHRoZSBidWZmZXIgKilcbiAgICAgIEJ5dGVzLmJsaXQgbGV4YnVmLmxleF9idWZmZXIgbGV4YnVmLmxleF9zdGFydF9wb3NcbiAgICAgICAgICAgICAgICAgIGxleGJ1Zi5sZXhfYnVmZmVyIDBcbiAgICAgICAgICAgICAgICAgIChsZXhidWYubGV4X2J1ZmZlcl9sZW4gLSBsZXhidWYubGV4X3N0YXJ0X3BvcylcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgKCogV2UgbXVzdCBncm93IHRoZSBidWZmZXIuICBEb3VibGluZyBpdHMgc2l6ZSB3aWxsIHByb3ZpZGUgZW5vdWdoXG4gICAgICAgICBzcGFjZSBzaW5jZSBuIDw9IFN0cmluZy5sZW5ndGggYXV4X2J1ZmZlciA8PSBTdHJpbmcubGVuZ3RoIGJ1ZmZlci5cbiAgICAgICAgIFdhdGNoIG91dCBmb3Igc3RyaW5nIGxlbmd0aCBvdmVyZmxvdywgdGhvdWdoLiAqKVxuICAgICAgbGV0IG5ld2xlbiA9XG4gICAgICAgIG1pbiAoMiAqIEJ5dGVzLmxlbmd0aCBsZXhidWYubGV4X2J1ZmZlcikgU3lzLm1heF9zdHJpbmdfbGVuZ3RoIGluXG4gICAgICBpZiBsZXhidWYubGV4X2J1ZmZlcl9sZW4gLSBsZXhidWYubGV4X3N0YXJ0X3BvcyArIG4gPiBuZXdsZW5cbiAgICAgIHRoZW4gZmFpbHdpdGggXCJMZXhpbmcubGV4X3JlZmlsbDogY2Fubm90IGdyb3cgYnVmZmVyXCI7XG4gICAgICBsZXQgbmV3YnVmID0gQnl0ZXMuY3JlYXRlIG5ld2xlbiBpblxuICAgICAgKCogQ29weSB0aGUgdmFsaWQgZGF0YSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBuZXcgYnVmZmVyICopXG4gICAgICBCeXRlcy5ibGl0IGxleGJ1Zi5sZXhfYnVmZmVyIGxleGJ1Zi5sZXhfc3RhcnRfcG9zXG4gICAgICAgICAgICAgICAgICBuZXdidWYgMFxuICAgICAgICAgICAgICAgICAgKGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zKTtcbiAgICAgIGxleGJ1Zi5sZXhfYnVmZmVyIDwtIG5ld2J1ZlxuICAgIGVuZDtcbiAgICAoKiBSZWFsbG9jYXRpb24gb3Igbm90LCB3ZSBoYXZlIHNoaWZ0ZWQgdGhlIGRhdGEgbGVmdCBieVxuICAgICAgIHN0YXJ0X3BvcyBjaGFyYWN0ZXJzOyB1cGRhdGUgdGhlIHBvc2l0aW9ucyAqKVxuICAgIGxldCBzID0gbGV4YnVmLmxleF9zdGFydF9wb3MgaW5cbiAgICBsZXhidWYubGV4X2Fic19wb3MgPC0gbGV4YnVmLmxleF9hYnNfcG9zICsgcztcbiAgICBsZXhidWYubGV4X2N1cnJfcG9zIDwtIGxleGJ1Zi5sZXhfY3Vycl9wb3MgLSBzO1xuICAgIGxleGJ1Zi5sZXhfc3RhcnRfcG9zIDwtIDA7XG4gICAgbGV4YnVmLmxleF9sYXN0X3BvcyA8LSBsZXhidWYubGV4X2xhc3RfcG9zIC0gcztcbiAgICBsZXhidWYubGV4X2J1ZmZlcl9sZW4gPC0gbGV4YnVmLmxleF9idWZmZXJfbGVuIC0gcyA7XG4gICAgbGV0IHQgPSBsZXhidWYubGV4X21lbSBpblxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggdC0xIGRvXG4gICAgICBsZXQgdiA9IHQuKGkpIGluXG4gICAgICBpZiB2ID49IDAgdGhlblxuICAgICAgICB0LihpKSA8LSB2LXNcbiAgICBkb25lXG4gIGVuZDtcbiAgKCogVGhlcmUgaXMgbm93IGVub3VnaCBzcGFjZSBhdCB0aGUgZW5kIG9mIHRoZSBidWZmZXIgKilcbiAgQnl0ZXMuYmxpdCBhdXhfYnVmZmVyIDAgbGV4YnVmLmxleF9idWZmZXIgbGV4YnVmLmxleF9idWZmZXJfbGVuIG47XG4gIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiA8LSBsZXhidWYubGV4X2J1ZmZlcl9sZW4gKyBuXG5cbmxldCB6ZXJvX3BvcyA9IHtcbiAgcG9zX2ZuYW1lID0gXCJcIjtcbiAgcG9zX2xudW0gPSAxO1xuICBwb3NfYm9sID0gMDtcbiAgcG9zX2NudW0gPSAwO1xufVxuXG5sZXQgZnJvbV9mdW5jdGlvbiBmID1cbiAgeyByZWZpbGxfYnVmZiA9IGxleF9yZWZpbGwgZiAoQnl0ZXMuY3JlYXRlIDUxMik7XG4gICAgbGV4X2J1ZmZlciA9IEJ5dGVzLmNyZWF0ZSAxMDI0O1xuICAgIGxleF9idWZmZXJfbGVuID0gMDtcbiAgICBsZXhfYWJzX3BvcyA9IDA7XG4gICAgbGV4X3N0YXJ0X3BvcyA9IDA7XG4gICAgbGV4X2N1cnJfcG9zID0gMDtcbiAgICBsZXhfbGFzdF9wb3MgPSAwO1xuICAgIGxleF9sYXN0X2FjdGlvbiA9IDA7XG4gICAgbGV4X21lbSA9IFt8fF07XG4gICAgbGV4X2VvZl9yZWFjaGVkID0gZmFsc2U7XG4gICAgbGV4X3N0YXJ0X3AgPSB6ZXJvX3BvcztcbiAgICBsZXhfY3Vycl9wID0gemVyb19wb3M7XG4gIH1cblxubGV0IGZyb21fY2hhbm5lbCBpYyA9XG4gIGZyb21fZnVuY3Rpb24gKGZ1biBidWYgbiAtPiBpbnB1dCBpYyBidWYgMCBuKVxuXG5sZXQgZnJvbV9zdHJpbmcgcyA9XG4gIHsgcmVmaWxsX2J1ZmYgPSAoZnVuIGxleGJ1ZiAtPiBsZXhidWYubGV4X2VvZl9yZWFjaGVkIDwtIHRydWUpO1xuICAgIGxleF9idWZmZXIgPSBCeXRlcy5vZl9zdHJpbmcgczsgKCogaGF2ZSB0byBtYWtlIGEgY29weSBmb3IgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCB1bnNhZmUtc3RyaW5nIG1vZGUgKilcbiAgICBsZXhfYnVmZmVyX2xlbiA9IFN0cmluZy5sZW5ndGggcztcbiAgICBsZXhfYWJzX3BvcyA9IDA7XG4gICAgbGV4X3N0YXJ0X3BvcyA9IDA7XG4gICAgbGV4X2N1cnJfcG9zID0gMDtcbiAgICBsZXhfbGFzdF9wb3MgPSAwO1xuICAgIGxleF9sYXN0X2FjdGlvbiA9IDA7XG4gICAgbGV4X21lbSA9IFt8fF07XG4gICAgbGV4X2VvZl9yZWFjaGVkID0gdHJ1ZTtcbiAgICBsZXhfc3RhcnRfcCA9IHplcm9fcG9zO1xuICAgIGxleF9jdXJyX3AgPSB6ZXJvX3BvcztcbiAgfVxuXG5sZXQgbGV4ZW1lIGxleGJ1ZiA9XG4gIGxldCBsZW4gPSBsZXhidWYubGV4X2N1cnJfcG9zIC0gbGV4YnVmLmxleF9zdGFydF9wb3MgaW5cbiAgQnl0ZXMuc3ViX3N0cmluZyBsZXhidWYubGV4X2J1ZmZlciBsZXhidWYubGV4X3N0YXJ0X3BvcyBsZW5cblxubGV0IHN1Yl9sZXhlbWUgbGV4YnVmIGkxIGkyID1cbiAgbGV0IGxlbiA9IGkyLWkxIGluXG4gIEJ5dGVzLnN1Yl9zdHJpbmcgbGV4YnVmLmxleF9idWZmZXIgaTEgbGVuXG5cbmxldCBzdWJfbGV4ZW1lX29wdCBsZXhidWYgaTEgaTIgPVxuICBpZiBpMSA+PSAwIHRoZW4gYmVnaW5cbiAgICBsZXQgbGVuID0gaTItaTEgaW5cbiAgICBTb21lIChCeXRlcy5zdWJfc3RyaW5nIGxleGJ1Zi5sZXhfYnVmZmVyIGkxIGxlbilcbiAgZW5kIGVsc2UgYmVnaW5cbiAgICBOb25lXG4gIGVuZFxuXG5sZXQgc3ViX2xleGVtZV9jaGFyIGxleGJ1ZiBpID0gQnl0ZXMuZ2V0IGxleGJ1Zi5sZXhfYnVmZmVyIGlcblxubGV0IHN1Yl9sZXhlbWVfY2hhcl9vcHQgbGV4YnVmIGkgPVxuICBpZiBpID49IDAgdGhlblxuICAgIFNvbWUgKEJ5dGVzLmdldCBsZXhidWYubGV4X2J1ZmZlciBpKVxuICBlbHNlXG4gICAgTm9uZVxuXG5cbmxldCBsZXhlbWVfY2hhciBsZXhidWYgaSA9XG4gIEJ5dGVzLmdldCBsZXhidWYubGV4X2J1ZmZlciAobGV4YnVmLmxleF9zdGFydF9wb3MgKyBpKVxuXG5sZXQgbGV4ZW1lX3N0YXJ0IGxleGJ1ZiA9IGxleGJ1Zi5sZXhfc3RhcnRfcC5wb3NfY251bVxubGV0IGxleGVtZV9lbmQgbGV4YnVmID0gbGV4YnVmLmxleF9jdXJyX3AucG9zX2NudW1cblxubGV0IGxleGVtZV9zdGFydF9wIGxleGJ1ZiA9IGxleGJ1Zi5sZXhfc3RhcnRfcFxubGV0IGxleGVtZV9lbmRfcCBsZXhidWYgPSBsZXhidWYubGV4X2N1cnJfcFxuXG5sZXQgbmV3X2xpbmUgbGV4YnVmID1cbiAgbGV0IGxjcCA9IGxleGJ1Zi5sZXhfY3Vycl9wIGluXG4gIGxleGJ1Zi5sZXhfY3Vycl9wIDwtIHsgbGNwIHdpdGhcbiAgICBwb3NfbG51bSA9IGxjcC5wb3NfbG51bSArIDE7XG4gICAgcG9zX2JvbCA9IGxjcC5wb3NfY251bTtcbiAgfVxuXG5cblxuKCogRGlzY2FyZCBkYXRhIGxlZnQgaW4gbGV4ZXIgYnVmZmVyLiAqKVxuXG5sZXQgZmx1c2hfaW5wdXQgbGIgPVxuICBsYi5sZXhfY3Vycl9wb3MgPC0gMDtcbiAgbGIubGV4X2Fic19wb3MgPC0gMDtcbiAgbGIubGV4X2N1cnJfcCA8LSB7bGIubGV4X2N1cnJfcCB3aXRoIHBvc19jbnVtID0gMH07XG4gIGxiLmxleF9idWZmZXJfbGVuIDwtIDA7XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgQmVub2l0IFZhdWdvbiwgRU5TVEEgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE0IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICgqIFRvb2xzIHRvIG1hbmlwdWxhdGUgc2Nhbm5pbmcgc2V0IG9mIGNoYXJzIChzZWUgJVsuLi5dKSAqKVxuXG50eXBlIG11dGFibGVfY2hhcl9zZXQgPSBieXRlc1xuXG4oKiBDcmVhdGUgYSBmcmVzaCwgZW1wdHksIG11dGFibGUgY2hhciBzZXQuICopXG5sZXQgY3JlYXRlX2NoYXJfc2V0ICgpID0gQnl0ZXMubWFrZSAzMiAnXFwwMDAnXG5cbigqIEFkZCBhIGNoYXIgaW4gYSBtdXRhYmxlIGNoYXIgc2V0LiAqKVxubGV0IGFkZF9pbl9jaGFyX3NldCBjaGFyX3NldCBjID1cbiAgbGV0IGluZCA9IGludF9vZl9jaGFyIGMgaW5cbiAgbGV0IHN0cl9pbmQgPSBpbmQgbHNyIDMgYW5kIG1hc2sgPSAxIGxzbCAoaW5kIGxhbmQgMGIxMTEpIGluXG4gIEJ5dGVzLnNldCBjaGFyX3NldCBzdHJfaW5kXG4gICAgKGNoYXJfb2ZfaW50IChpbnRfb2ZfY2hhciAoQnl0ZXMuZ2V0IGNoYXJfc2V0IHN0cl9pbmQpIGxvciBtYXNrKSlcblxubGV0IGZyZWV6ZV9jaGFyX3NldCBjaGFyX3NldCA9XG4gIEJ5dGVzLnRvX3N0cmluZyBjaGFyX3NldFxuXG4oKiBDb21wdXRlIHRoZSBjb21wbGVtZW50IG9mIGEgY2hhciBzZXQuICopXG5sZXQgcmV2X2NoYXJfc2V0IGNoYXJfc2V0ID1cbiAgbGV0IGNoYXJfc2V0JyA9IGNyZWF0ZV9jaGFyX3NldCAoKSBpblxuICBmb3IgaSA9IDAgdG8gMzEgZG9cbiAgICBCeXRlcy5zZXQgY2hhcl9zZXQnIGlcbiAgICAgIChjaGFyX29mX2ludCAoaW50X29mX2NoYXIgKFN0cmluZy5nZXQgY2hhcl9zZXQgaSkgbHhvciAweEZGKSk7XG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgY2hhcl9zZXQnXG5cbigqIFJldHVybiB0cnVlIGlmIGEgYGMnIGlzIGluIGBjaGFyX3NldCcuICopXG5sZXQgaXNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgYyA9XG4gIGxldCBpbmQgPSBpbnRfb2ZfY2hhciBjIGluXG4gIGxldCBzdHJfaW5kID0gaW5kIGxzciAzIGFuZCBtYXNrID0gMSBsc2wgKGluZCBsYW5kIDBiMTExKSBpblxuICAoaW50X29mX2NoYXIgKFN0cmluZy5nZXQgY2hhcl9zZXQgc3RyX2luZCkgbGFuZCBtYXNrKSA8PiAwXG5cblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAoKiBJZ25vcmVkIHBhcmFtIGNvbnZlcnNpb24gKilcblxuKCogR0FEVCB1c2VkIHRvIGFic3RyYWN0IGFuIGV4aXN0ZW50aWFsIHR5cGUgcGFyYW1ldGVyLiAqKVxuKCogU2VlIHBhcmFtX2Zvcm1hdF9vZl9pZ25vcmVkX2Zvcm1hdC4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhcmFtX2Zvcm1hdF9lYmIgPSBQYXJhbV9mb3JtYXRfRUJCIDpcbiAgICAoJ3ggLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhcmFtX2Zvcm1hdF9lYmJcblxuKCogQ29tcHV0ZSBhIHBhZGRpbmcgYXNzb2NpYXRlZCB0byBhIHBhZF9vcHRpb24gKHNlZSBcIiVfNDJkXCIpLiAqKVxubGV0IHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQgPSBtYXRjaCBwYWRfb3B0IHdpdGhcbiAgfCBOb25lIC0+IE5vX3BhZGRpbmdcbiAgfCBTb21lIHdpZHRoIC0+IExpdF9wYWRkaW5nIChSaWdodCwgd2lkdGgpXG5cbigqIENvbXB1dGUgYSBwcmVjaXNpb24gYXNzb2NpYXRlZCB0byBhIHByZWNfb3B0aW9uIChzZWUgXCIlXy40MmZcIikuICopXG5sZXQgcHJlY19vZl9wcmVjX29wdCBwcmVjX29wdCA9IG1hdGNoIHByZWNfb3B0IHdpdGhcbiAgfCBOb25lIC0+IE5vX3ByZWNpc2lvblxuICB8IFNvbWUgbmRlYyAtPiBMaXRfcHJlY2lzaW9uIG5kZWNcblxuKCogVHVybiBhbiBpZ25vcmVkIHBhcmFtIGludG8gaXRzIGVxdWl2YWxlbnQgbm90LWlnbm9yZWQgZm9ybWF0IG5vZGUuICopXG4oKiBVc2VkIGZvciBmb3JtYXQgcHJldHR5LXByaW50aW5nIGFuZCBTY2FuZi4gKilcbmxldCBwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQgOiB0eXBlIGEgYiBjIGQgZSBmIHggeSAuXG4gICAgKGEsIGIsIGMsIGQsIHksIHgpIGlnbm9yZWQgLT4gKHgsIGIsIGMsIHksIGUsIGYpIGZtdCAtPlxuICAgICAgKGEsIGIsIGMsIGQsIGUsIGYpIHBhcmFtX2Zvcm1hdF9lYmIgPVxuZnVuIGlnbiBmbXQgLT4gbWF0Y2ggaWduIHdpdGhcbiAgfCBJZ25vcmVkX2NoYXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChDaGFyIGZtdClcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKENhbWxfY2hhciBmbXQpXG4gIHwgSWdub3JlZF9zdHJpbmcgcGFkX29wdCAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKFN0cmluZyAocGFkX29mX3BhZF9vcHQgcGFkX29wdCwgZm10KSlcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIHBhZF9vcHQgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChDYW1sX3N0cmluZyAocGFkX29mX3BhZF9vcHQgcGFkX29wdCwgZm10KSlcbiAgfCBJZ25vcmVkX2ludCAoaWNvbnYsIHBhZF9vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoSW50IChpY29udiwgcGFkX29mX3BhZF9vcHQgcGFkX29wdCwgTm9fcHJlY2lzaW9uLCBmbXQpKVxuICB8IElnbm9yZWRfaW50MzIgKGljb252LCBwYWRfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkJcbiAgICAgIChJbnQzMiAoaWNvbnYsIHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIE5vX3ByZWNpc2lvbiwgZm10KSlcbiAgfCBJZ25vcmVkX25hdGl2ZWludCAoaWNvbnYsIHBhZF9vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKE5hdGl2ZWludCAoaWNvbnYsIHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIE5vX3ByZWNpc2lvbiwgZm10KSlcbiAgfCBJZ25vcmVkX2ludDY0IChpY29udiwgcGFkX29wdCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCXG4gICAgICAoSW50NjQgKGljb252LCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBOb19wcmVjaXNpb24sIGZtdCkpXG4gIHwgSWdub3JlZF9mbG9hdCAocGFkX29wdCwgcHJlY19vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKEZsb2F0IChGbG9hdF9mLCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBwcmVjX29mX3ByZWNfb3B0IHByZWNfb3B0LCBmbXQpKVxuICB8IElnbm9yZWRfYm9vbCBwYWRfb3B0IC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoQm9vbCAocGFkX29mX3BhZF9vcHQgcGFkX29wdCwgZm10KSlcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgKHBhZF9vcHQsIGZtdHR5KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKEZvcm1hdF9hcmcgKHBhZF9vcHQsIGZtdHR5LCBmbXQpKVxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IChwYWRfb3B0LCBmbXR0eSkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCXG4gICAgICAoRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBmbXR0eSwgZm10KSlcbiAgfCBJZ25vcmVkX3JlYWRlciAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKFJlYWRlciBmbXQpXG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIGZtdCkpXG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIGNvdW50ZXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBmbXQpKVxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChTY2FuX25leHRfY2hhciBmbXQpXG5cblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFR5cGVzICopXG5cbnR5cGUgKCdiLCAnYykgYWNjX2Zvcm1hdHRpbmdfZ2VuID1cbiAgfCBBY2Nfb3Blbl90YWcgb2YgKCdiLCAnYykgYWNjXG4gIHwgQWNjX29wZW5fYm94IG9mICgnYiwgJ2MpIGFjY1xuXG4oKiBSZXZlcnNlZCBsaXN0IG9mIHByaW50aW5nIGF0b21zLiAqKVxuKCogVXNlZCB0byBhY2N1bXVsYXRlIHByaW50ZiBhcmd1bWVudHMuICopXG5hbmQgKCdiLCAnYykgYWNjID1cbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgb2YgKCdiLCAnYykgYWNjICogZm9ybWF0dGluZ19saXRcbiAgICAgICgqIFNwZWNpYWwgZm10dGluZyAoYm94KSAqKVxuICB8IEFjY19mb3JtYXR0aW5nX2dlbiBvZiAoJ2IsICdjKSBhY2MgKiAoJ2IsICdjKSBhY2NfZm9ybWF0dGluZ19nZW5cbiAgICAgICgqIFNwZWNpYWwgZm10dGluZyAoYm94KSAqKVxuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCBvZiAoJ2IsICdjKSBhY2MgKiBzdHJpbmcgICAgICgqIExpdGVyYWwgc3RyaW5nICopXG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAgIG9mICgnYiwgJ2MpIGFjYyAqIGNoYXIgICAgICAgKCogTGl0ZXJhbCBjaGFyICopXG4gIHwgQWNjX2RhdGFfc3RyaW5nICAgIG9mICgnYiwgJ2MpIGFjYyAqIHN0cmluZyAgICAgKCogR2VuZXJhdGVkIHN0cmluZyAqKVxuICB8IEFjY19kYXRhX2NoYXIgICAgICBvZiAoJ2IsICdjKSBhY2MgKiBjaGFyICAgICAgICgqIEdlbmVyYXRlZCBjaGFyICopXG4gIHwgQWNjX2RlbGF5ICAgICAgICAgIG9mICgnYiwgJ2MpIGFjYyAqICgnYiAtPiAnYylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIERlbGF5ZWQgcHJpbnRpbmcgKCVhLCAldCkgKilcbiAgfCBBY2NfZmx1c2ggICAgICAgICAgb2YgKCdiLCAnYykgYWNjICAgICAgICAgICAgICAoKiBGbHVzaCAqKVxuICB8IEFjY19pbnZhbGlkX2FyZyAgICBvZiAoJ2IsICdjKSBhY2MgKiBzdHJpbmdcbiAgICAgICgqIFJhaXNlIEludmFsaWRfYXJndW1lbnQgbXNnICopXG4gIHwgRW5kX29mX2FjY1xuXG4oKiBMaXN0IG9mIGhldGVyb2dlbmVvdXMgdmFsdWVzLiAqKVxuKCogVXNlZCB0byBhY2N1bXVsYXRlIHNjYW5mIGNhbGxiYWNrIGFyZ3VtZW50cy4gKilcbnR5cGUgKCdhLCAnYikgaGV0ZXJfbGlzdCA9XG4gIHwgQ29ucyA6ICdjICogKCdhLCAnYikgaGV0ZXJfbGlzdCAtPiAoJ2MgLT4gJ2EsICdiKSBoZXRlcl9saXN0XG4gIHwgTmlsIDogKCdiLCAnYikgaGV0ZXJfbGlzdFxuXG4oKiBFeGlzdGVudGlhbCBCbGFjayBCb3hlcy4gKilcbigqIFVzZWQgdG8gYWJzdHJhY3Qgc29tZSBleGlzdGVudGlhbCB0eXBlIHBhcmFtZXRlcnMuICopXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHBhZGRpbmcgYW5kIGFuIGZtdHR5LiAqKVxuKCogU2VlIHRoZSB0eXBlX3BhZGRpbmcgZnVuY3Rpb24uICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYWRkaW5nX2ZtdHR5X2ViYiA9IFBhZGRpbmdfZm10dHlfRUJCIDpcbiAgICAgKCd4LCAneSkgcGFkZGluZyAqICgneSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSAtPlxuICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgcGFkZGluZ19mbXR0eV9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGEgcGFkZGluZywgYSBwcmVjaXNpb24gYW5kIGFuIGZtdHR5LiAqKVxuKCogU2VlIHRoZSB0eXBlX3BhZHByZWMgZnVuY3Rpb24uICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYWRwcmVjX2ZtdHR5X2ViYiA9IFBhZHByZWNfZm10dHlfRUJCIDpcbiAgICAgKCd4LCAneSkgcGFkZGluZyAqICgneSwgJ3opIHByZWNpc2lvbiAqICgneiwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSAtPlxuICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgcGFkcHJlY19mbXR0eV9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGEgcGFkZGluZyBhbmQgYW4gZm10LiAqKVxuKCogU2VlIG1ha2VfcGFkZGluZ19mbXRfZWJiIGFuZCBwYXJzZV9mb3JtYXQgZnVuY3Rpb25zLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2UsICdmKSBwYWRkaW5nX2ZtdF9lYmIgPSBQYWRkaW5nX2ZtdF9FQkIgOlxuICAgICAoXywgJ3ggLT4gJ2EpIHBhZGRpbmcgKlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICgneCwgJ2IsICdjLCAnZSwgJ2YpIHBhZGRpbmdfZm10X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYSBwcmVjaXNpb24gYW5kIGFuIGZtdC4gKilcbigqIFNlZSBtYWtlX3ByZWNpc2lvbl9mbXRfZWJiIGFuZCBwYXJzZV9mb3JtYXQgZnVuY3Rpb25zLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2UsICdmKSBwcmVjaXNpb25fZm10X2ViYiA9IFByZWNpc2lvbl9mbXRfRUJCIDpcbiAgICAgKF8sICd4IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICgneCwgJ2IsICdjLCAnZSwgJ2YpIHByZWNpc2lvbl9mbXRfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHBhZGRpbmcsIGEgcHJlY2lzaW9uIGFuZCBhbiBmbXQuICopXG4oKiBTZWUgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgYW5kIHBhcnNlX2Zvcm1hdCBmdW5jdGlvbnMuICopXG50eXBlICgncCwgJ2IsICdjLCAnZSwgJ2YpIHBhZHByZWNfZm10X2ViYiA9IFBhZHByZWNfZm10X0VCQiA6XG4gICAgICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksICdwIC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICgncCwgJ2IsICdjLCAnZSwgJ2YpIHBhZHByZWNfZm10X2ViYlxuXG4oKiBBYnN0cmFjdCB0aGUgJ2EgYW5kICdkIHBhcmFtZXRlcnMgb2YgYW4gZm10LiAqKVxuKCogT3V0cHV0IHR5cGUgb2YgdGhlIGZvcm1hdCBwYXJzaW5nIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2IsICdjLCAnZSwgJ2YpIGZtdF9lYmIgPSBGbXRfRUJCIDpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAoJ2IsICdjLCAnZSwgJ2YpIGZtdF9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGFuIGZtdHR5IGFuZCBhbiBmbXQuICopXG4oKiBTZWUgdGhlIHR5cGVfZm9ybWF0X2dlbiBmdW5jdGlvbi4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdF9mbXR0eV9lYmIgPSBGbXRfZm10dHlfRUJCIDpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAneSwgJ3gpIGZtdCAqXG4gICAgICgneCwgJ2IsICdjLCAneSwgJ2UsICdmKSBmbXR0eSAtPlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10X2ZtdHR5X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYW4gZm10dHkgYW5kIGFuIGZtdC4gKilcbigqIFNlZSB0aGUgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gZnVuY3Rpb24uICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eV9mbXRfZWJiID0gRm10dHlfZm10X0VCQiA6XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ3ksICd4KSBmbXR0eSAqXG4gICAgICgneCwgJ2IsICdjLCAneSwgJ2UsICdmKSBmbXRfZm10dHlfZWJiIC0+XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eV9mbXRfZWJiXG5cbigqIEFic3RyYWN0IGFsbCBmbXR0eSB0eXBlIHBhcmFtZXRlcnMuICopXG4oKiBVc2VkIHRvIGNvbXBhcmUgZm9ybWF0IHR5cGVzLiAqKVxudHlwZSBmbXR0eV9lYmIgPSBGbXR0eV9FQkIgOiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgLT4gZm10dHlfZWJiXG5cbigqIEFic3RyYWN0IGFsbCBwYWRkaW5nIHR5cGUgcGFyYW1ldGVycy4gKilcbigqIFVzZWQgdG8gY29tcGFyZSBwYWRkaW5ncy4gKilcbnR5cGUgcGFkZGluZ19lYmIgPSBQYWRkaW5nX0VCQiA6ICgnYSwgJ2IpIHBhZGRpbmcgLT4gcGFkZGluZ19lYmJcblxuKCogQWJzdHJhY3QgYWxsIHByZWNpc2lvbiB0eXBlIHBhcmFtZXRlcnMuICopXG4oKiBVc2VkIHRvIGNvbXBhcmUgcHJlY2lzaW9ucy4gKilcbnR5cGUgcHJlY2lzaW9uX2ViYiA9IFByZWNpc2lvbl9FQkIgOiAoJ2EsICdiKSBwcmVjaXNpb24gLT4gcHJlY2lzaW9uX2ViYlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIENvbnN0YW50cyAqKVxuXG4oKiBEZWZhdWx0IHByZWNpc2lvbiBmb3IgZmxvYXQgcHJpbnRpbmcuICopXG5sZXQgZGVmYXVsdF9mbG9hdF9wcmVjaXNpb24gPSAtNlxuICAoKiBGb3IgJWggYW5kICVIIGZvcm1hdHMsIGEgbmVnYXRpdmUgcHJlY2lzaW9uIG1lYW5zIFwiYXMgbWFueSBkaWdpdHMgYXNcbiAgICAgbmVjZXNzYXJ5XCIuICBGb3IgdGhlIG90aGVyIEZQIGZvcm1hdHMsIHdlIHRha2UgdGhlIGFic29sdXRlIHZhbHVlXG4gICAgIG9mIHRoZSBwcmVjaXNpb24sIGhlbmNlIDYgZGlnaXRzIGJ5IGRlZmF1bHQuICopXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRXh0ZXJuYWxzICopXG5cbmV4dGVybmFsIGZvcm1hdF9mbG9hdDogc3RyaW5nIC0+IGZsb2F0IC0+IHN0cmluZ1xuICA9IFwiY2FtbF9mb3JtYXRfZmxvYXRcIlxuZXh0ZXJuYWwgZm9ybWF0X2ludDogc3RyaW5nIC0+IGludCAtPiBzdHJpbmdcbiAgPSBcImNhbWxfZm9ybWF0X2ludFwiXG5leHRlcm5hbCBmb3JtYXRfaW50MzI6IHN0cmluZyAtPiBpbnQzMiAtPiBzdHJpbmdcbiAgPSBcImNhbWxfaW50MzJfZm9ybWF0XCJcbmV4dGVybmFsIGZvcm1hdF9uYXRpdmVpbnQ6IHN0cmluZyAtPiBuYXRpdmVpbnQgLT4gc3RyaW5nXG4gID0gXCJjYW1sX25hdGl2ZWludF9mb3JtYXRcIlxuZXh0ZXJuYWwgZm9ybWF0X2ludDY0OiBzdHJpbmcgLT4gaW50NjQgLT4gc3RyaW5nXG4gID0gXCJjYW1sX2ludDY0X2Zvcm1hdFwiXG5leHRlcm5hbCBoZXhzdHJpbmdfb2ZfZmxvYXQ6IGZsb2F0IC0+IGludCAtPiBjaGFyIC0+IHN0cmluZ1xuICA9IFwiY2FtbF9oZXhzdHJpbmdfb2ZfZmxvYXRcIlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgKCogVG9vbHMgdG8gcHJldHR5LXByaW50IGZvcm1hdHMgKilcblxuKCogVHlwZSBvZiBleHRlbnNpYmxlIGNoYXJhY3RlciBidWZmZXJzLiAqKVxudHlwZSBidWZmZXIgPSB7XG4gIG11dGFibGUgaW5kIDogaW50O1xuICBtdXRhYmxlIGJ5dGVzIDogYnl0ZXM7XG59XG5cbigqIENyZWF0ZSBhIGZyZXNoIGJ1ZmZlci4gKilcbmxldCBidWZmZXJfY3JlYXRlIGluaXRfc2l6ZSA9IHsgaW5kID0gMDsgYnl0ZXMgPSBCeXRlcy5jcmVhdGUgaW5pdF9zaXplIH1cblxuKCogQ2hlY2sgc2l6ZSBvZiB0aGUgYnVmZmVyIGFuZCBncm93IGl0IGlmIG5lZWRlZC4gKilcbmxldCBidWZmZXJfY2hlY2tfc2l6ZSBidWYgb3ZlcmhlYWQgPVxuICBsZXQgbGVuID0gQnl0ZXMubGVuZ3RoIGJ1Zi5ieXRlcyBpblxuICBsZXQgbWluX2xlbiA9IGJ1Zi5pbmQgKyBvdmVyaGVhZCBpblxuICBpZiBtaW5fbGVuID4gbGVuIHRoZW4gKFxuICAgIGxldCBuZXdfbGVuID0gbWF4IChsZW4gKiAyKSBtaW5fbGVuIGluXG4gICAgbGV0IG5ld19zdHIgPSBCeXRlcy5jcmVhdGUgbmV3X2xlbiBpblxuICAgIEJ5dGVzLmJsaXQgYnVmLmJ5dGVzIDAgbmV3X3N0ciAwIGxlbjtcbiAgICBidWYuYnl0ZXMgPC0gbmV3X3N0cjtcbiAgKVxuXG4oKiBBZGQgdGhlIGNoYXJhY3RlciBgYycgdG8gdGhlIGJ1ZmZlciBgYnVmJy4gKilcbmxldCBidWZmZXJfYWRkX2NoYXIgYnVmIGMgPVxuICBidWZmZXJfY2hlY2tfc2l6ZSBidWYgMTtcbiAgQnl0ZXMuc2V0IGJ1Zi5ieXRlcyBidWYuaW5kIGM7XG4gIGJ1Zi5pbmQgPC0gYnVmLmluZCArIDFcblxuKCogQWRkIHRoZSBzdHJpbmcgYHMnIHRvIHRoZSBidWZmZXIgYGJ1ZicuICopXG5sZXQgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIHMgPVxuICBsZXQgc3RyX2xlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBidWZmZXJfY2hlY2tfc2l6ZSBidWYgc3RyX2xlbjtcbiAgU3RyaW5nLmJsaXQgcyAwIGJ1Zi5ieXRlcyBidWYuaW5kIHN0cl9sZW47XG4gIGJ1Zi5pbmQgPC0gYnVmLmluZCArIHN0cl9sZW5cblxuKCogR2V0IHRoZSBjb250ZW50IG9mIHRoZSBidWZmZXIuICopXG5sZXQgYnVmZmVyX2NvbnRlbnRzIGJ1ZiA9XG4gIEJ5dGVzLnN1Yl9zdHJpbmcgYnVmLmJ5dGVzIDAgYnVmLmluZFxuXG4oKioqKVxuXG4oKiBDb252ZXJ0IGFuIGludGVnZXIgY29udmVyc2lvbiB0byBjaGFyLiAqKVxubGV0IGNoYXJfb2ZfaWNvbnYgaWNvbnYgPSBtYXRjaCBpY29udiB3aXRoXG4gIHwgSW50X2QgfCBJbnRfcGQgfCBJbnRfc2QgLT4gJ2QnIHwgSW50X2kgfCBJbnRfcGkgfCBJbnRfc2kgLT4gJ2knXG4gIHwgSW50X3ggfCBJbnRfQ3ggLT4gJ3gnIHwgSW50X1ggfCBJbnRfQ1ggLT4gJ1gnIHwgSW50X28gfCBJbnRfQ28gLT4gJ28nXG4gIHwgSW50X3UgLT4gJ3UnXG5cbigqIENvbnZlcnQgYSBmbG9hdCBjb252ZXJzaW9uIHRvIGNoYXIuICopXG5sZXQgY2hhcl9vZl9mY29udiBmY29udiA9IG1hdGNoIGZjb252IHdpdGhcbiAgfCBGbG9hdF9mIHwgRmxvYXRfcGYgfCBGbG9hdF9zZiAtPiAnZicgfCBGbG9hdF9lIHwgRmxvYXRfcGUgfCBGbG9hdF9zZSAtPiAnZSdcbiAgfCBGbG9hdF9FIHwgRmxvYXRfcEUgfCBGbG9hdF9zRSAtPiAnRScgfCBGbG9hdF9nIHwgRmxvYXRfcGcgfCBGbG9hdF9zZyAtPiAnZydcbiAgfCBGbG9hdF9HIHwgRmxvYXRfcEcgfCBGbG9hdF9zRyAtPiAnRycgfCBGbG9hdF9GIC0+ICdGJ1xuICB8IEZsb2F0X2ggfCBGbG9hdF9waCB8IEZsb2F0X3NoIC0+ICdoJyB8IEZsb2F0X0ggfCBGbG9hdF9wSCB8IEZsb2F0X3NIIC0+ICdIJ1xuXG5cbigqIENvbnZlcnQgYSBzY2FubmluZyBjb3VudGVyIHRvIGNoYXIuICopXG5sZXQgY2hhcl9vZl9jb3VudGVyIGNvdW50ZXIgPSBtYXRjaCBjb3VudGVyIHdpdGhcbiAgfCBMaW5lX2NvdW50ZXIgIC0+ICdsJ1xuICB8IENoYXJfY291bnRlciAgLT4gJ24nXG4gIHwgVG9rZW5fY291bnRlciAtPiAnTidcblxuKCoqKilcblxuKCogUHJpbnQgYSBjaGFyX3NldCBpbiBhIGJ1ZmZlciB3aXRoIHRoZSBPQ2FtbCBmb3JtYXQgbGV4aWNhbCBjb252ZW50aW9uLiAqKVxubGV0IGJwcmludF9jaGFyX3NldCBidWYgY2hhcl9zZXQgPVxuICBsZXQgcmVjIHByaW50X3N0YXJ0IHNldCA9XG4gICAgbGV0IGlzX2Fsb25lIGMgPVxuICAgICAgbGV0IGJlZm9yZSwgYWZ0ZXIgPSBDaGFyLihjaHIgKGNvZGUgYyAtIDEpLCBjaHIgKGNvZGUgYyArIDEpKSBpblxuICAgICAgaXNfaW5fY2hhcl9zZXQgc2V0IGNcbiAgICAgICYmIG5vdCAoaXNfaW5fY2hhcl9zZXQgc2V0IGJlZm9yZSAmJiBpc19pbl9jaGFyX3NldCBzZXQgYWZ0ZXIpIGluXG4gICAgaWYgaXNfYWxvbmUgJ10nIHRoZW4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnXSc7XG4gICAgcHJpbnRfb3V0IHNldCAxO1xuICAgIGlmIGlzX2Fsb25lICctJyB0aGVuIGJ1ZmZlcl9hZGRfY2hhciBidWYgJy0nO1xuICBhbmQgcHJpbnRfb3V0IHNldCBpID1cbiAgICBpZiBpIDwgMjU2IHRoZW5cbiAgICAgIGlmIGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgaSkgdGhlbiBwcmludF9maXJzdCBzZXQgaVxuICAgICAgZWxzZSBwcmludF9vdXQgc2V0IChpICsgMSlcbiAgYW5kIHByaW50X2ZpcnN0IHNldCBpID1cbiAgICBtYXRjaCBjaGFyX29mX2ludCBpIHdpdGhcbiAgICB8ICdcXDI1NScgLT4gcHJpbnRfY2hhciBidWYgMjU1O1xuICAgIHwgJ10nIHwgJy0nIC0+IHByaW50X291dCBzZXQgKGkgKyAxKTtcbiAgICB8IF8gLT4gcHJpbnRfc2Vjb25kIHNldCAoaSArIDEpO1xuICBhbmQgcHJpbnRfc2Vjb25kIHNldCBpID1cbiAgICBpZiBpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IGkpIHRoZW5cbiAgICAgIG1hdGNoIGNoYXJfb2ZfaW50IGkgd2l0aFxuICAgICAgfCAnXFwyNTUnIC0+XG4gICAgICAgIHByaW50X2NoYXIgYnVmIDI1NDtcbiAgICAgICAgcHJpbnRfY2hhciBidWYgMjU1O1xuICAgICAgfCAnXScgfCAnLScgd2hlbiBub3QgKGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgKGkgKyAxKSkpIC0+XG4gICAgICAgIHByaW50X2NoYXIgYnVmIChpIC0gMSk7XG4gICAgICAgIHByaW50X291dCBzZXQgKGkgKyAxKTtcbiAgICAgIHwgXyB3aGVuIG5vdCAoaXNfaW5fY2hhcl9zZXQgc2V0IChjaGFyX29mX2ludCAoaSArIDEpKSkgLT5cbiAgICAgICAgcHJpbnRfY2hhciBidWYgKGkgLSAxKTtcbiAgICAgICAgcHJpbnRfY2hhciBidWYgaTtcbiAgICAgICAgcHJpbnRfb3V0IHNldCAoaSArIDIpO1xuICAgICAgfCBfIC0+XG4gICAgICAgIHByaW50X2luIHNldCAoaSAtIDEpIChpICsgMik7XG4gICAgZWxzZSAoXG4gICAgICBwcmludF9jaGFyIGJ1ZiAoaSAtIDEpO1xuICAgICAgcHJpbnRfb3V0IHNldCAoaSArIDEpO1xuICAgIClcbiAgYW5kIHByaW50X2luIHNldCBpIGogPVxuICAgIGlmIGogPSAyNTYgfHwgbm90IChpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IGopKSB0aGVuIChcbiAgICAgIHByaW50X2NoYXIgYnVmIGk7XG4gICAgICBwcmludF9jaGFyIGJ1ZiAoaW50X29mX2NoYXIgJy0nKTtcbiAgICAgIHByaW50X2NoYXIgYnVmIChqIC0gMSk7XG4gICAgICBpZiBqIDwgMjU2IHRoZW4gcHJpbnRfb3V0IHNldCAoaiArIDEpO1xuICAgICkgZWxzZVxuICAgICAgcHJpbnRfaW4gc2V0IGkgKGogKyAxKTtcbiAgYW5kIHByaW50X2NoYXIgYnVmIGkgPSBtYXRjaCBjaGFyX29mX2ludCBpIHdpdGhcbiAgICB8ICclJyAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gICAgfCAnQCcgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ0AnO1xuICAgIHwgYyAgIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgYztcbiAgaW5cbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnWyc7XG4gIHByaW50X3N0YXJ0IChcbiAgICBpZiBpc19pbl9jaGFyX3NldCBjaGFyX3NldCAnXFwwMDAnXG4gICAgdGhlbiAoIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ14nOyByZXZfY2hhcl9zZXQgY2hhcl9zZXQgKVxuICAgIGVsc2UgY2hhcl9zZXRcbiAgKTtcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnXSdcblxuKCoqKilcblxuKCogUHJpbnQgYSBwYWR0eSBpbiBhIGJ1ZmZlciB3aXRoIHRoZSBmb3JtYXQtbGlrZSBzeW50YXguICopXG5sZXQgYnByaW50X3BhZHR5IGJ1ZiBwYWR0eSA9IG1hdGNoIHBhZHR5IHdpdGhcbiAgfCBMZWZ0ICAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICctJ1xuICB8IFJpZ2h0IC0+ICgpXG4gIHwgWmVyb3MgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnMCdcblxuKCogUHJpbnQgdGhlICdfJyBvZiBhbiBpZ25vcmVkIGZsYWcgaWYgbmVlZGVkLiAqKVxubGV0IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnID1cbiAgaWYgaWduX2ZsYWcgdGhlbiBidWZmZXJfYWRkX2NoYXIgYnVmICdfJ1xuXG4oKioqKVxuXG5sZXQgYnByaW50X3BhZF9vcHQgYnVmIHBhZF9vcHQgPSBtYXRjaCBwYWRfb3B0IHdpdGhcbiAgfCBOb25lIC0+ICgpXG4gIHwgU29tZSB3aWR0aCAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgKHN0cmluZ19vZl9pbnQgd2lkdGgpXG5cbigqKiopXG5cbigqIFByaW50IHBhZGRpbmcgaW4gYSBidWZmZXIgd2l0aCB0aGUgZm9ybWF0LWxpa2Ugc3ludGF4LiAqKVxubGV0IGJwcmludF9wYWRkaW5nIDogdHlwZSBhIGIgLiBidWZmZXIgLT4gKGEsIGIpIHBhZGRpbmcgLT4gdW5pdCA9XG5mdW4gYnVmIHBhZCAtPiBtYXRjaCBwYWQgd2l0aFxuICB8IE5vX3BhZGRpbmcgLT4gKClcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIG4pIC0+XG4gICAgYnByaW50X3BhZHR5IGJ1ZiBwYWR0eTtcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgKHN0cmluZ19vZl9pbnQgbik7XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHkgLT5cbiAgICBicHJpbnRfcGFkdHkgYnVmIHBhZHR5O1xuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyonXG5cbigqIFByaW50IHByZWNpc2lvbiBpbiBhIGJ1ZmZlciB3aXRoIHRoZSBmb3JtYXQtbGlrZSBzeW50YXguICopXG5sZXQgYnByaW50X3ByZWNpc2lvbiA6IHR5cGUgYSBiIC4gYnVmZmVyIC0+IChhLCBiKSBwcmVjaXNpb24gLT4gdW5pdCA9XG4gIGZ1biBidWYgcHJlYyAtPiBtYXRjaCBwcmVjIHdpdGhcbiAgfCBOb19wcmVjaXNpb24gLT4gKClcbiAgfCBMaXRfcHJlY2lzaW9uIG4gLT5cbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmICcuJztcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgKHN0cmluZ19vZl9pbnQgbik7XG4gIHwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIi4qXCJcblxuKCoqKilcblxuKCogUHJpbnQgdGhlIG9wdGlvbmFsICcrJywgJyAnIG9yICcjJyBhc3NvY2lhdGVkIHRvIGFuIGludCBjb252ZXJzaW9uLiAqKVxubGV0IGJwcmludF9pY29udl9mbGFnIGJ1ZiBpY29udiA9IG1hdGNoIGljb252IHdpdGhcbiAgfCBJbnRfcGQgfCBJbnRfcGkgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKydcbiAgfCBJbnRfc2QgfCBJbnRfc2kgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnICdcbiAgfCBJbnRfQ3ggfCBJbnRfQ1ggfCBJbnRfQ28gLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnIydcbiAgfCBJbnRfZCB8IEludF9pIHwgSW50X3ggfCBJbnRfWCB8IEludF9vIHwgSW50X3UgLT4gKClcblxuKCogUHJpbnQgYW4gY29tcGxldGUgaW50IGZvcm1hdCBpbiBhIGJ1ZmZlciAoZXg6IFwiJTMuKmRcIikuICopXG5sZXQgYnByaW50X2ludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjID1cbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gIGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICBicHJpbnRfaWNvbnZfZmxhZyBidWYgaWNvbnY7XG4gIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7XG4gIGJwcmludF9wcmVjaXNpb24gYnVmIHByZWM7XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpXG5cbigqIFByaW50IGEgY29tcGxldGUgaW50MzIsIG5hdGl2ZWludCBvciBpbnQ2NCBmb3JtYXQgaW4gYSBidWZmZXIuICopXG5sZXQgYnByaW50X2FsdGludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjIGMgPVxuICBidWZmZXJfYWRkX2NoYXIgYnVmICclJztcbiAgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gIGJwcmludF9pY29udl9mbGFnIGJ1ZiBpY29udjtcbiAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDtcbiAgYnByaW50X3ByZWNpc2lvbiBidWYgcHJlYztcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiBjO1xuICBidWZmZXJfYWRkX2NoYXIgYnVmIChjaGFyX29mX2ljb252IGljb252KVxuXG4oKioqKVxuXG4oKiBQcmludCB0aGUgb3B0aW9uYWwgJysnIGFzc29jaWF0ZWQgdG8gYSBmbG9hdCBjb252ZXJzaW9uLiAqKVxubGV0IGJwcmludF9mY29udl9mbGFnIGJ1ZiBmY29udiA9IG1hdGNoIGZjb252IHdpdGhcbiAgfCBGbG9hdF9wZiB8IEZsb2F0X3BlIHwgRmxvYXRfcEVcbiAgfCBGbG9hdF9wZyB8IEZsb2F0X3BHIHwgRmxvYXRfcGggfCBGbG9hdF9wSCAtPlxuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJysnXG4gIHwgRmxvYXRfc2YgfCBGbG9hdF9zZSB8IEZsb2F0X3NFXG4gIHwgRmxvYXRfc2cgfCBGbG9hdF9zRyB8IEZsb2F0X3NoIHwgRmxvYXRfc0ggLT5cbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmICcgJ1xuICB8IEZsb2F0X2YgfCBGbG9hdF9lIHwgRmxvYXRfRVxuICB8IEZsb2F0X2cgfCBGbG9hdF9HIHwgRmxvYXRfRiB8IEZsb2F0X2ggfCBGbG9hdF9IIC0+XG4gICAgKClcblxuKCogUHJpbnQgYSBjb21wbGV0ZSBmbG9hdCBmb3JtYXQgaW4gYSBidWZmZXIgKGV4OiBcIiUrKi4zZlwiKS4gKilcbmxldCBicHJpbnRfZmxvYXRfZm10IGJ1ZiBpZ25fZmxhZyBmY29udiBwYWQgcHJlYyA9XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnO1xuICBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgYnByaW50X2Zjb252X2ZsYWcgYnVmIGZjb252O1xuICBicHJpbnRfcGFkZGluZyBidWYgcGFkO1xuICBicHJpbnRfcHJlY2lzaW9uIGJ1ZiBwcmVjO1xuICBidWZmZXJfYWRkX2NoYXIgYnVmIChjaGFyX29mX2Zjb252IGZjb252KVxuXG4oKiBDb21wdXRlIHRoZSBsaXRlcmFsIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGZvcm1hdHRpbmdfbGl0LiAqKVxuKCogQWxzbyB1c2VkIGJ5IFByaW50ZiBhbmQgU2NhbmYgd2hlcmUgZm9ybWF0dGluZyBpcyBub3QgaW50ZXJwcmV0ZWQuICopXG5sZXQgc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZvcm1hdHRpbmdfbGl0ID0gbWF0Y2ggZm9ybWF0dGluZ19saXQgd2l0aFxuICB8IENsb3NlX2JveCAgICAgICAgICAgIC0+IFwiQF1cIlxuICB8IENsb3NlX3RhZyAgICAgICAgICAgIC0+IFwiQH1cIlxuICB8IEJyZWFrIChzdHIsIF8sIF8pICAgIC0+IHN0clxuICB8IEZGbHVzaCAgICAgICAgICAgICAgIC0+IFwiQD9cIlxuICB8IEZvcmNlX25ld2xpbmUgICAgICAgIC0+IFwiQFxcblwiXG4gIHwgRmx1c2hfbmV3bGluZSAgICAgICAgLT4gXCJALlwiXG4gIHwgTWFnaWNfc2l6ZSAoc3RyLCBfKSAgLT4gc3RyXG4gIHwgRXNjYXBlZF9hdCAgICAgICAgICAgLT4gXCJAQFwiXG4gIHwgRXNjYXBlZF9wZXJjZW50ICAgICAgLT4gXCJAJVwiXG4gIHwgU2Nhbl9pbmRpYyBjIC0+IFwiQFwiIF4gKFN0cmluZy5tYWtlIDEgYylcblxuKCogQ29tcHV0ZSB0aGUgbGl0ZXJhbCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBmb3JtYXR0aW5nLiAqKVxuKCogQWxzbyB1c2VkIGJ5IFByaW50ZiBhbmQgU2NhbmYgd2hlcmUgZm9ybWF0dGluZyBpcyBub3QgaW50ZXJwcmV0ZWQuICopXG5sZXQgc3RyaW5nX29mX2Zvcm1hdHRpbmdfZ2VuIDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZvcm1hdHRpbmdfZ2VuIC0+IHN0cmluZyA9XG4gIGZ1biBmb3JtYXR0aW5nX2dlbiAtPiBtYXRjaCBmb3JtYXR0aW5nX2dlbiB3aXRoXG4gIHwgT3Blbl90YWcgKEZvcm1hdCAoXywgc3RyKSkgLT4gc3RyXG4gIHwgT3Blbl9ib3ggKEZvcm1hdCAoXywgc3RyKSkgLT4gc3RyXG5cbigqKiopXG5cbigqIFByaW50IGEgbGl0ZXJhbCBjaGFyIGluIGEgYnVmZmVyLCBlc2NhcGUgJyUnIGJ5IFwiJSVcIi4gKilcbmxldCBicHJpbnRfY2hhcl9saXRlcmFsIGJ1ZiBjaHIgPSBtYXRjaCBjaHIgd2l0aFxuICB8ICclJyAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlJVwiXG4gIHwgXyAtPiBidWZmZXJfYWRkX2NoYXIgYnVmIGNoclxuXG4oKiBQcmludCBhIGxpdGVyYWwgc3RyaW5nIGluIGEgYnVmZmVyLCBlc2NhcGUgYWxsICclJyBieSBcIiUlXCIuICopXG5sZXQgYnByaW50X3N0cmluZ19saXRlcmFsIGJ1ZiBzdHIgPVxuICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzdHIgLSAxIGRvXG4gICAgYnByaW50X2NoYXJfbGl0ZXJhbCBidWYgc3RyLltpXVxuICBkb25lXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCBwcmV0dHktcHJpbnRpbmcgKilcblxuKCogUHJpbnQgYSBjb21wbGV0ZSBmb3JtYXQgdHlwZSAoYW4gZm10dHkpIGluIGEgYnVmZmVyLiAqKVxubGV0IHJlYyBicHJpbnRfZm10dHkgOiB0eXBlIGEgYiBjIGQgZSBmIGcgaCBpIGogayBsIC5cbiAgICBidWZmZXIgLT4gKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGosIGssIGwpIGZtdHR5X3JlbCAtPiB1bml0ID1cbmZ1biBidWYgZm10dHkgLT4gbWF0Y2ggZm10dHkgd2l0aFxuICB8IENoYXJfdHkgcmVzdCAgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVjXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgU3RyaW5nX3R5IHJlc3QgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJXNcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBJbnRfdHkgcmVzdCAgICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlaVwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEludDMyX3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVsaVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJW5pXCI7IGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBJbnQ2NF90eSByZXN0ICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlTGlcIjsgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEZsb2F0X3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVmXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgQm9vbF90eSByZXN0ICAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJUJcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBBbHBoYV90eSByZXN0ICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlYVwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IFRoZXRhX3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiV0XCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgQW55X3R5IHJlc3QgICAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJT9cIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBSZWFkZXJfdHkgcmVzdCAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlclwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPlxuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVfclwiO1xuICAgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcblxuICB8IEZvcm1hdF9hcmdfdHkgKHN1Yl9mbXR0eSwgcmVzdCkgLT5cbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIle1wiOyBicHJpbnRfZm10dHkgYnVmIHN1Yl9mbXR0eTtcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlfVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgRm9ybWF0X3N1YnN0X3R5IChzdWJfZm10dHksIF8sIHJlc3QpIC0+XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJShcIjsgYnByaW50X2ZtdHR5IGJ1ZiBzdWJfZm10dHk7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJSlcIjsgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuXG4gIHwgRW5kX29mX2ZtdHR5IC0+ICgpXG5cbigqKiopXG5cbmxldCByZWMgaW50X29mX2N1c3RvbV9hcml0eSA6IHR5cGUgYSBiIGMgLlxuICAoYSwgYiwgYykgY3VzdG9tX2FyaXR5IC0+IGludCA9XG4gIGZ1bmN0aW9uXG4gIHwgQ3VzdG9tX3plcm8gLT4gMFxuICB8IEN1c3RvbV9zdWNjIHggLT4gMSArIGludF9vZl9jdXN0b21fYXJpdHkgeFxuXG4oKiBQcmludCBhIGNvbXBsZXRlIGZvcm1hdCBpbiBhIGJ1ZmZlci4gKilcbmxldCBicHJpbnRfZm10IGJ1ZiBmbXQgPVxuICBsZXQgcmVjIGZtdGl0ZXIgOiB0eXBlIGEgYiBjIGQgZSBmIC5cbiAgICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gYm9vbCAtPiB1bml0ID1cbiAgZnVuIGZtdCBpZ25fZmxhZyAtPiBtYXRjaCBmbXQgd2l0aFxuICAgIHwgU3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkZGluZyBidWYgcGFkOyBidWZmZXJfYWRkX2NoYXIgYnVmICdzJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkZGluZyBidWYgcGFkOyBidWZmZXJfYWRkX2NoYXIgYnVmICdTJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcblxuICAgIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2ludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfYWx0aW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWMgJ2wnO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2FsdGludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjICduJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2FsdGludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjICdMJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2Zsb2F0X2ZtdCBidWYgaWduX2ZsYWcgZmNvbnYgcGFkIHByZWM7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG5cbiAgICB8IENoYXIgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnYyc7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICdDJzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQm9vbCAocGFkLCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnQic7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBBbHBoYSByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICdhJzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgVGhldGEgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAndCc7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEN1c3RvbSAoYXJpdHksIF8sIHJlc3QpIC0+XG4gICAgICBmb3IgX2kgPSAxIHRvIGludF9vZl9jdXN0b21fYXJpdHkgYXJpdHkgZG9cbiAgICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICc/JztcbiAgICAgIGRvbmU7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBSZWFkZXIgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAncic7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEZsdXNoIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiUhXCI7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG5cbiAgICB8IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfc3RyaW5nX2xpdGVyYWwgYnVmIHN0cjtcbiAgICAgIGZtdGl0ZXIgcmVzdCBpZ25fZmxhZztcbiAgICB8IENoYXJfbGl0ZXJhbCAoY2hyLCByZXN0KSAtPlxuICAgICAgYnByaW50X2NoYXJfbGl0ZXJhbCBidWYgY2hyO1xuICAgICAgZm10aXRlciByZXN0IGlnbl9mbGFnO1xuXG4gICAgfCBGb3JtYXRfYXJnIChwYWRfb3B0LCBmbXR0eSwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRfb3B0IGJ1ZiBwYWRfb3B0OyBidWZmZXJfYWRkX2NoYXIgYnVmICd7JztcbiAgICAgIGJwcmludF9mbXR0eSBidWYgZm10dHk7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBidWZmZXJfYWRkX2NoYXIgYnVmICd9JztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEZvcm1hdF9zdWJzdCAocGFkX29wdCwgZm10dHksIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkX29wdCBidWYgcGFkX29wdDsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKCc7XG4gICAgICBicHJpbnRfZm10dHkgYnVmIGZtdHR5OyBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKSc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG5cbiAgICB8IFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkX29wdCBidWYgd2lkdGhfb3B0OyBicHJpbnRfY2hhcl9zZXQgYnVmIGNoYXJfc2V0O1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgKGNoYXJfb2ZfY291bnRlciBjb3VudGVyKTtcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9zdHJpbmdfbGl0ZXJhbCBidWYgXCIwY1wiOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG5cbiAgICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICAgIGxldCBQYXJhbV9mb3JtYXRfRUJCIGZtdCcgPSBwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQgaWduIHJlc3QgaW5cbiAgICAgIGZtdGl0ZXIgZm10JyB0cnVlO1xuXG4gICAgfCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkgLT5cbiAgICAgIGJwcmludF9zdHJpbmdfbGl0ZXJhbCBidWYgKHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0KTtcbiAgICAgIGZtdGl0ZXIgcmVzdCBpZ25fZmxhZztcbiAgICB8IEZvcm1hdHRpbmdfZ2VuIChmbXRpbmdfZ2VuLCByZXN0KSAtPlxuICAgICAgYnByaW50X3N0cmluZ19saXRlcmFsIGJ1ZiBcIkB7XCI7XG4gICAgICBicHJpbnRfc3RyaW5nX2xpdGVyYWwgYnVmIChzdHJpbmdfb2ZfZm9ybWF0dGluZ19nZW4gZm10aW5nX2dlbik7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG5cbiAgICB8IEVuZF9vZl9mb3JtYXQgLT4gKClcblxuICBpbiBmbXRpdGVyIGZtdCBmYWxzZVxuXG4oKioqKVxuXG4oKiBDb252ZXJ0IGEgZm9ybWF0IHRvIHN0cmluZy4gKilcbmxldCBzdHJpbmdfb2ZfZm10IGZtdCA9XG4gIGxldCBidWYgPSBidWZmZXJfY3JlYXRlIDE2IGluXG4gIGJwcmludF9mbXQgYnVmIGZtdDtcbiAgYnVmZmVyX2NvbnRlbnRzIGJ1ZlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBUeXBlIGV4dHJhY3Rpb24gKilcblxudHlwZSAoXywgXykgZXEgPSBSZWZsIDogKCdhLCAnYSkgZXFcblxuKCogSW52YXJpYW50OiB0aGlzIGZ1bmN0aW9uIGlzIHRoZSBpZGVudGl0eSBvbiB2YWx1ZXMuXG5cbiAgIEluIHBhcnRpY3VsYXIsIGlmICh0eTEsIHR5MikgaGF2ZSBlcXVhbCB2YWx1ZXMsIHRoZW5cbiAgICh0cmFucyAoc3ltbSB0eTEpIHR5MikgcmVzcGVjdHMgdGhlICd0cmFucycgcHJlY29uZGl0aW9uLiAqKVxubGV0IHJlYyBzeW1tIDogdHlwZSBhMSBiMSBjMSBkMSBlMSBmMSBhMiBiMiBjMiBkMiBlMiBmMiAuXG4gICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSxcbiAgICBhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eV9yZWxcbi0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyLFxuICAgIGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdHR5X3JlbFxuPSBmdW5jdGlvblxuICB8IENoYXJfdHkgcmVzdCAtPiBDaGFyX3R5IChzeW1tIHJlc3QpXG4gIHwgSW50X3R5IHJlc3QgLT4gSW50X3R5IChzeW1tIHJlc3QpXG4gIHwgSW50MzJfdHkgcmVzdCAtPiBJbnQzMl90eSAoc3ltbSByZXN0KVxuICB8IEludDY0X3R5IHJlc3QgLT4gSW50NjRfdHkgKHN5bW0gcmVzdClcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPiBOYXRpdmVpbnRfdHkgKHN5bW0gcmVzdClcbiAgfCBGbG9hdF90eSByZXN0IC0+IEZsb2F0X3R5IChzeW1tIHJlc3QpXG4gIHwgQm9vbF90eSByZXN0IC0+IEJvb2xfdHkgKHN5bW0gcmVzdClcbiAgfCBTdHJpbmdfdHkgcmVzdCAtPiBTdHJpbmdfdHkgKHN5bW0gcmVzdClcbiAgfCBUaGV0YV90eSByZXN0IC0+IFRoZXRhX3R5IChzeW1tIHJlc3QpXG4gIHwgQWxwaGFfdHkgcmVzdCAtPiBBbHBoYV90eSAoc3ltbSByZXN0KVxuICB8IEFueV90eSByZXN0IC0+IEFueV90eSAoc3ltbSByZXN0KVxuICB8IFJlYWRlcl90eSByZXN0IC0+IFJlYWRlcl90eSAoc3ltbSByZXN0KVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QgLT4gSWdub3JlZF9yZWFkZXJfdHkgKHN5bW0gcmVzdClcbiAgfCBGb3JtYXRfYXJnX3R5ICh0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0eSwgc3ltbSByZXN0KVxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTIsIHR5MSwgc3ltbSByZXN0KVxuICB8IEVuZF9vZl9mbXR0eSAtPiBFbmRfb2ZfZm10dHlcblxubGV0IHJlYyBmbXR0eV9yZWxfZGV0IDogdHlwZSBhMSBiIGMgZDEgZTEgZjEgYTIgZDIgZTIgZjIgLlxuICAoYTEsIGIsIGMsIGQxLCBlMSwgZjEsXG4gICBhMiwgYiwgYywgZDIsIGUyLCBmMikgZm10dHlfcmVsIC0+XG4gICAgKChmMSwgZjIpIGVxIC0+IChhMSwgYTIpIGVxKVxuICAqICgoYTEsIGEyKSBlcSAtPiAoZjEsIGYyKSBlcSlcbiAgKiAoKGUxLCBlMikgZXEgLT4gKGQxLCBkMikgZXEpXG4gICogKChkMSwgZDIpIGVxIC0+IChlMSwgZTIpIGVxKVxuPSBmdW5jdGlvblxuICB8IEVuZF9vZl9mbXR0eSAtPlxuICAgIChmdW4gUmVmbCAtPiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBSZWZsKVxuICB8IENoYXJfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBTdHJpbmdfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBJbnRfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBJbnQzMl90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEludDY0X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgRmxvYXRfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBCb29sX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG5cbiAgfCBUaGV0YV90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEFscGhhX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgQW55X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgUmVhZGVyX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZWQgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBkZSBSZWZsIGluIFJlZmwpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBlZCBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGRlIFJlZmwgaW4gUmVmbClcbiAgfCBGb3JtYXRfYXJnX3R5IChfdHksIHJlc3QpIC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgbGV0IHR5ID0gdHJhbnMgKHN5bW0gdHkxKSB0eTIgaW5cbiAgICBsZXQgYWcsIGdhLCBkaiwgamQgPSBmbXR0eV9yZWxfZGV0IHR5IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBsZXQgUmVmbCA9IGFnIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZ2EgUmVmbCBpbiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZWQgUmVmbCBpbiBsZXQgUmVmbCA9IGRqIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gamQgUmVmbCBpbiBsZXQgUmVmbCA9IGRlIFJlZmwgaW4gUmVmbClcblxuKCogUHJlY29uZGl0aW9uOiB3ZSBhc3N1bWUgdGhhdCB0aGUgdHdvIGZtdHR5X3JlbCBhcmd1bWVudHMgaGF2ZSBlcXVhbFxuICAgdmFsdWVzIChhdCBwb3NzaWJseSBkaXN0aW5jdCB0eXBlcyk7IHRoaXMgaW52YXJpYW50IGNvbWVzIGZyb20gdGhlIHdheVxuICAgZm10dHlfcmVsIHdpdG5lc3NlcyBhcmUgcHJvZHVjZWQgYnkgdGhlIHR5cGUtY2hlY2tlclxuXG4gICBUaGUgY29kZSBiZWxvdyB1c2VzIChhc3NlcnQgZmFsc2UpIHdoZW4gdGhpcyBhc3N1bXB0aW9uIGlzIGJyb2tlbi4gVGhlXG4gICBjb2RlIHBhdHRlcm4gaXMgdGhlIGZvbGxvd2luZzpcblxuICAgICB8IEZvbyB4LCBGb28geSAtPlxuICAgICAgICgqIGNhc2Ugd2hlcmUgaW5kZWVkIGJvdGggdmFsdWVzXG4gICAgICAgICAgc3RhcnQgd2l0aCBjb25zdHJ1Y3RvciBGb28gKilcbiAgICAgfCBGb28gXywgX1xuICAgICB8IF8sIEZvbyBfIC0+XG4gICAgICAgKCogZGlmZmVyZW50IGhlYWQgY29uc3RydWN0b3JzOiBicm9rZW4gcHJlY29uZGl0aW9uICopXG4gICAgICAgYXNzZXJ0IGZhbHNlXG4qKVxuYW5kIHRyYW5zIDogdHlwZVxuICBhMSBiMSBjMSBkMSBlMSBmMVxuICBhMiBiMiBjMiBkMiBlMiBmMlxuICBhMyBiMyBjMyBkMyBlMyBmM1xuLlxuICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlfcmVsXG4tPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMixcbiAgICBhMywgYjMsIGMzLCBkMywgZTMsIGYzKSBmbXR0eV9yZWxcbi0+IChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgIGEzLCBiMywgYzMsIGQzLCBlMywgZjMpIGZtdHR5X3JlbFxuPSBmdW4gdHkxIHR5MiAtPiBtYXRjaCB0eTEsIHR5MiB3aXRoXG4gIHwgQ2hhcl90eSByZXN0MSwgQ2hhcl90eSByZXN0MiAtPiBDaGFyX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBTdHJpbmdfdHkgcmVzdDEsIFN0cmluZ190eSByZXN0MiAtPiBTdHJpbmdfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEJvb2xfdHkgcmVzdDEsIEJvb2xfdHkgcmVzdDIgLT4gQm9vbF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgSW50X3R5IHJlc3QxLCBJbnRfdHkgcmVzdDIgLT4gSW50X3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBJbnQzMl90eSByZXN0MSwgSW50MzJfdHkgcmVzdDIgLT4gSW50MzJfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEludDY0X3R5IHJlc3QxLCBJbnQ2NF90eSByZXN0MiAtPiBJbnQ2NF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QxLCBOYXRpdmVpbnRfdHkgcmVzdDIgLT4gTmF0aXZlaW50X3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBGbG9hdF90eSByZXN0MSwgRmxvYXRfdHkgcmVzdDIgLT4gRmxvYXRfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuXG4gIHwgQWxwaGFfdHkgcmVzdDEsIEFscGhhX3R5IHJlc3QyIC0+IEFscGhhX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBBbHBoYV90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIEFscGhhX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBUaGV0YV90eSByZXN0MSwgVGhldGFfdHkgcmVzdDIgLT4gVGhldGFfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IFRoZXRhX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgVGhldGFfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IEFueV90eSByZXN0MSwgQW55X3R5IHJlc3QyIC0+IEFueV90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgQW55X3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgQW55X3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBSZWFkZXJfdHkgcmVzdDEsIFJlYWRlcl90eSByZXN0MiAtPiBSZWFkZXJfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IFJlYWRlcl90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIFJlYWRlcl90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdDEsIElnbm9yZWRfcmVhZGVyX3R5IHJlc3QyIC0+XG4gICAgSWdub3JlZF9yZWFkZXJfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgSWdub3JlZF9yZWFkZXJfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IEZvcm1hdF9hcmdfdHkgKHR5MSwgcmVzdDEpLCBGb3JtYXRfYXJnX3R5ICh0eTIsIHJlc3QyKSAtPlxuICAgIEZvcm1hdF9hcmdfdHkgKHRyYW5zIHR5MSB0eTIsIHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEZvcm1hdF9hcmdfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBGb3JtYXRfYXJnX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MTEsIHR5MTIsIHJlc3QxKSxcbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5MjEsIHR5MjIsIHJlc3QyKSAtPlxuICAgIGxldCB0eSA9IHRyYW5zIChzeW1tIHR5MTIpIHR5MjEgaW5cbiAgICBsZXQgXywgZjIsIF8sIGY0ID0gZm10dHlfcmVsX2RldCB0eSBpblxuICAgIGxldCBSZWZsID0gZjIgUmVmbCBpblxuICAgIGxldCBSZWZsID0gZjQgUmVmbCBpblxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkxMSwgdHkyMiwgdHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgRm9ybWF0X3N1YnN0X3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgRm9ybWF0X3N1YnN0X3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBFbmRfb2ZfZm10dHksIEVuZF9vZl9mbXR0eSAtPiBFbmRfb2ZfZm10dHlcbiAgfCBFbmRfb2ZfZm10dHksIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgRW5kX29mX2ZtdHR5IC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgcmVjIGZtdHR5X29mX2Zvcm1hdHRpbmdfZ2VuIDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gIChhLCBiLCBjLCBkLCBlLCBmKSBmb3JtYXR0aW5nX2dlbiAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG5mdW4gZm9ybWF0dGluZ19nZW4gLT4gbWF0Y2ggZm9ybWF0dGluZ19nZW4gd2l0aFxuICB8IE9wZW5fdGFnIChGb3JtYXQgKGZtdCwgXykpIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBPcGVuX2JveCAoRm9ybWF0IChmbXQsIF8pKSAtPiBmbXR0eV9vZl9mbXQgZm10XG5cbigqIEV4dHJhY3QgdGhlIHR5cGUgcmVwcmVzZW50YXRpb24gKGFuIGZtdHR5KSBvZiBhIGZvcm1hdC4gKilcbmFuZCBmbXR0eV9vZl9mbXQgOiB0eXBlIGEgYiBjIGQgZSBmIC5cbiAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuZnVuIGZtdHR5IC0+IG1hdGNoIGZtdHR5IHdpdGhcbiAgfCBTdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCAoU3RyaW5nX3R5IChmbXR0eV9vZl9mbXQgcmVzdCkpXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCAoU3RyaW5nX3R5IChmbXR0eV9vZl9mbXQgcmVzdCkpXG5cbiAgfCBJbnQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoSW50X3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuICB8IEludDMyIChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IHR5X3Jlc3QgPSBmbXR0eV9vZl9mbXQgcmVzdCBpblxuICAgIGxldCBwcmVjX3R5ID0gZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IHByZWMgKEludDMyX3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuICB8IE5hdGl2ZWludCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCB0eV9yZXN0ID0gZm10dHlfb2ZfZm10IHJlc3QgaW5cbiAgICBsZXQgcHJlY190eSA9IGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSBwcmVjIChOYXRpdmVpbnRfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG4gIHwgSW50NjQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoSW50NjRfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG4gIHwgRmxvYXQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoRmxvYXRfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG5cbiAgfCBDaGFyIHJlc3QgICAgICAgICAgICAgICAgICAtPiBDaGFyX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBDYW1sX2NoYXIgcmVzdCAgICAgICAgICAgICAtPiBDaGFyX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBCb29sIChwYWQsIHJlc3QpICAgICAgICAgICAtPiBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCAoQm9vbF90eSAoZm10dHlfb2ZfZm10IHJlc3QpKVxuICB8IEFscGhhIHJlc3QgICAgICAgICAgICAgICAgIC0+IEFscGhhX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBUaGV0YSByZXN0ICAgICAgICAgICAgICAgICAtPiBUaGV0YV90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgQ3VzdG9tIChhcml0eSwgXywgcmVzdCkgICAgLT4gZm10dHlfb2ZfY3VzdG9tIGFyaXR5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBSZWFkZXIgcmVzdCAgICAgICAgICAgICAgICAtPiBSZWFkZXJfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuXG4gIHwgRm9ybWF0X2FyZyAoXywgdHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHksIGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IEZvcm1hdF9zdWJzdCAoXywgdHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eSwgdHksIGZtdHR5X29mX2ZtdCByZXN0KVxuXG4gIHwgRmx1c2ggcmVzdCAgICAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IHJlc3RcbiAgfCBTdHJpbmdfbGl0ZXJhbCAoXywgcmVzdCkgICAtPiBmbXR0eV9vZl9mbXQgcmVzdFxuICB8IENoYXJfbGl0ZXJhbCAoXywgcmVzdCkgICAgIC0+IGZtdHR5X29mX2ZtdCByZXN0XG5cbiAgfCBTY2FuX2NoYXJfc2V0IChfLCBfLCByZXN0KSAtPiBTdHJpbmdfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKF8sIHJlc3QpIC0+IEludF90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAgICAgICAgLT4gQ2hhcl90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAgLT4gZm10dHlfb2ZfaWdub3JlZF9mb3JtYXQgaWduIHJlc3RcbiAgfCBGb3JtYXR0aW5nX2xpdCAoXywgcmVzdCkgICAtPiBmbXR0eV9vZl9mbXQgcmVzdFxuICB8IEZvcm1hdHRpbmdfZ2VuIChmbXRpbmdfZ2VuLCByZXN0KSAgLT5cbiAgICBjb25jYXRfZm10dHkgKGZtdHR5X29mX2Zvcm1hdHRpbmdfZ2VuIGZtdGluZ19nZW4pIChmbXR0eV9vZl9mbXQgcmVzdClcblxuICB8IEVuZF9vZl9mb3JtYXQgICAgICAgICAgICAgIC0+IEVuZF9vZl9mbXR0eVxuXG5hbmQgZm10dHlfb2ZfY3VzdG9tIDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAoYSwgeCwgeSkgY3VzdG9tX2FyaXR5IC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPlxuICAoeSwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuZnVuIGFyaXR5IGZtdHR5IC0+IG1hdGNoIGFyaXR5IHdpdGhcbiAgfCBDdXN0b21femVybyAtPiBmbXR0eVxuICB8IEN1c3RvbV9zdWNjIGFyaXR5IC0+IEFueV90eSAoZm10dHlfb2ZfY3VzdG9tIGFyaXR5IGZtdHR5KVxuXG4oKiBFeHRyYWN0IHRoZSBmbXR0eSBvZiBhbiBpZ25vcmVkIHBhcmFtZXRlciBmb2xsb3dlZCBieSB0aGUgcmVzdCBvZlxuICAgdGhlIGZvcm1hdC4gKilcbmFuZCBmbXR0eV9vZl9pZ25vcmVkX2Zvcm1hdCA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgICAoYSwgYiwgYywgZCwgeSwgeCkgaWdub3JlZCAtPlxuICAgICh4LCBiLCBjLCB5LCBlLCBmKSBmbXQgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuZnVuIGlnbiBmbXQgLT4gbWF0Y2ggaWduIHdpdGhcbiAgfCBJZ25vcmVkX2NoYXIgICAgICAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX3N0cmluZyBfICAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIF8gICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2ludCAoXywgXykgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2ludDMyIChfLCBfKSAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX25hdGl2ZWludCAoXywgXykgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2ludDY0IChfLCBfKSAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2Zsb2F0IChfLCBfKSAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2Jvb2wgXyAgICAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgXyAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAoXywgZm10dHkpIC0+IGNvbmNhdF9mbXR0eSBmbXR0eSAoZm10dHlfb2ZfZm10IGZtdClcbiAgfCBJZ25vcmVkX3JlYWRlciAgICAgICAgICAgICAgICAgIC0+IElnbm9yZWRfcmVhZGVyX3R5IChmbXR0eV9vZl9mbXQgZm10KVxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCBfICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBfICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuXG4oKiBBZGQgYW4gSW50X3R5IG5vZGUgaWYgcGFkZGluZyBpcyB0YWtlbiBhcyBhbiBleHRyYSBhcmd1bWVudCAoZXg6IFwiJSpzXCIpLiAqKVxuYW5kIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgOiB0eXBlIHggYSBiIGMgZCBlIGYgLlxuICAgICh4LCBhKSBwYWRkaW5nIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPiAoeCwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuICBmdW4gcGFkIGZtdHR5IC0+IG1hdGNoIHBhZCB3aXRoXG4gICAgfCBOb19wYWRkaW5nICAgIC0+IGZtdHR5XG4gICAgfCBMaXRfcGFkZGluZyBfIC0+IGZtdHR5XG4gICAgfCBBcmdfcGFkZGluZyBfIC0+IEludF90eSBmbXR0eVxuXG4oKiBBZGQgYW4gSW50X3R5IG5vZGUgaWYgcHJlY2lzaW9uIGlzIHRha2VuIGFzIGFuIGV4dHJhIGFyZ3VtZW50IChleDogXCIlLipmXCIpLiopXG5hbmQgZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IDogdHlwZSB4IGEgYiBjIGQgZSBmIC5cbiAgICAoeCwgYSkgcHJlY2lzaW9uIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPiAoeCwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuICBmdW4gcHJlYyBmbXR0eSAtPiBtYXRjaCBwcmVjIHdpdGhcbiAgICB8IE5vX3ByZWNpc2lvbiAgICAtPiBmbXR0eVxuICAgIHwgTGl0X3ByZWNpc2lvbiBfIC0+IGZtdHR5XG4gICAgfCBBcmdfcHJlY2lzaW9uICAgLT4gSW50X3R5IGZtdHR5XG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IHR5cGluZyAqKVxuXG4oKiBFeGNlcHRpb24gcmFpc2VkIHdoZW4gYSBmb3JtYXQgZG9lcyBub3QgbWF0Y2ggYSBnaXZlbiBmb3JtYXQgdHlwZS4gKilcbmV4Y2VwdGlvbiBUeXBlX21pc21hdGNoXG5cbigqIFR5cGUgYSBwYWRkaW5nLiAqKVxuKCogVGFrZSBhbiBJbnRfdHkgZnJvbSB0aGUgZm10dHkgaWYgdGhlIGludGVnZXIgc2hvdWxkIGJlIGtlcHQgYXMgYXJndW1lbnQuICopXG4oKiBSYWlzZSBUeXBlX21pc21hdGNoIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCB0eXBlX3BhZGRpbmcgOiB0eXBlIGEgYiBjIGQgZSBmIHggeSAuXG4gICAgKHgsIHkpIHBhZGRpbmcgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICAgICAoYSwgYiwgYywgZCwgZSwgZikgcGFkZGluZ19mbXR0eV9lYmIgPVxuZnVuIHBhZCBmbXR0eSAtPiBtYXRjaCBwYWQsIGZtdHR5IHdpdGhcbiAgfCBOb19wYWRkaW5nLCBfIC0+IFBhZGRpbmdfZm10dHlfRUJCIChOb19wYWRkaW5nLCBmbXR0eSlcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBfIC0+IFBhZGRpbmdfZm10dHlfRUJCIChMaXRfcGFkZGluZyAocGFkdHksdyksZm10dHkpXG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIEludF90eSByZXN0IC0+IFBhZGRpbmdfZm10dHlfRUJCIChBcmdfcGFkZGluZyBwYWR0eSxyZXN0KVxuICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG4oKiBDb252ZXJ0IGEgKHVwYWRkaW5nLCB1cHJlY2lzaW9uKSB0byBhIChwYWRkaW5nLCBwcmVjaXNpb24pLiAqKVxuKCogVGFrZSBvbmUgb3IgdHdvIEludF90eSBmcm9tIHRoZSBmbXR0eSBpZiBuZWVkZWQuICopXG4oKiBSYWlzZSBUeXBlX21pc21hdGNoIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCB0eXBlX3BhZHByZWMgOiB0eXBlIGEgYiBjIGQgZSBmIHggeSB6IC5cbiAgKHgsIHkpIHBhZGRpbmcgLT4gKHksIHopIHByZWNpc2lvbiAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgcGFkcHJlY19mbXR0eV9lYmIgPVxuZnVuIHBhZCBwcmVjIGZtdHR5IC0+IG1hdGNoIHByZWMsIHR5cGVfcGFkZGluZyBwYWQgZm10dHkgd2l0aFxuICB8IE5vX3ByZWNpc2lvbiwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgcmVzdCkgLT5cbiAgICBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBOb19wcmVjaXNpb24sIHJlc3QpXG4gIHwgTGl0X3ByZWNpc2lvbiBwLCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCByZXN0KSAtPlxuICAgIFBhZHByZWNfZm10dHlfRUJCIChwYWQsIExpdF9wcmVjaXNpb24gcCwgcmVzdClcbiAgfCBBcmdfcHJlY2lzaW9uLCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCBJbnRfdHkgcmVzdCkgLT5cbiAgICBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBBcmdfcHJlY2lzaW9uLCByZXN0KVxuICB8IF8sIFBhZGRpbmdfZm10dHlfRUJCIChfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbigqIFR5cGUgYSBmb3JtYXQgYWNjb3JkaW5nIHRvIGFuIGZtdHR5LiAqKVxuKCogSWYgdHlwaW5nIHN1Y2NlZWQsIGdlbmVyYXRlIGEgY29weSBvZiB0aGUgZm9ybWF0IHdpdGggdGhlIHNhbWVcbiAgICB0eXBlIHBhcmFtZXRlcnMgYXMgdGhlIGZtdHR5LiAqKVxuKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYW4gZXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgcmVjIHR5cGVfZm9ybWF0IDpcbiAgdHlwZSBhMSBiMSBjMSBkMSBlMSBmMVxuICAgICAgIGEyIGIyIGMyIGQyIGUyIGYyICAuXG4gICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmbXRcbiAgLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5XG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXRcbj0gZnVuIGZtdCBmbXR0eSAtPiBtYXRjaCB0eXBlX2Zvcm1hdF9nZW4gZm10IGZtdHR5IHdpdGhcbiAgfCBGbXRfZm10dHlfRUJCIChmbXQnLCBFbmRfb2ZfZm10dHkpIC0+IGZtdCdcbiAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcblxuYW5kIHR5cGVfZm9ybWF0X2dlbiA6XG4gIHR5cGUgYTEgYjEgYzEgZDEgZTEgZjFcbiAgICAgICBhMiBiMiBjMiBkMiBlMiBmMiAgLlxuICAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10XG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eVxuICAtPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10X2ZtdHR5X2ViYlxuPSBmdW4gZm10IGZtdHR5IC0+IG1hdGNoIGZtdCwgZm10dHkgd2l0aFxuICB8IENoYXIgZm10X3Jlc3QsIENoYXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChDaGFyIGZtdCcsIGZtdHR5JylcbiAgfCBDYW1sX2NoYXIgZm10X3Jlc3QsIENoYXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChDYW1sX2NoYXIgZm10JywgZm10dHknKVxuICB8IFN0cmluZyAocGFkLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkZGluZyBwYWQgZm10dHkgd2l0aFxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgU3RyaW5nX3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChTdHJpbmcgKHBhZCwgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBDYW1sX3N0cmluZyAocGFkLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkZGluZyBwYWQgZm10dHkgd2l0aFxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgU3RyaW5nX3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChDYW1sX3N0cmluZyAocGFkLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZHByZWMgcGFkIHByZWMgZm10dHkgd2l0aFxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgcHJlYywgSW50X3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChJbnQgKGljb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIEludDMyX3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIE5hdGl2ZWludF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKF8sIF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkcHJlYyBwYWQgcHJlYyBmbXR0eSB3aXRoXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBwcmVjLCBJbnQ2NF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoSW50NjQgKGljb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIEZsb2F0X3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBCb29sIChwYWQsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRkaW5nIHBhZCBmbXR0eSB3aXRoXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCBCb29sX3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChCb29sIChwYWQsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAoXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgRmx1c2ggZm10X3Jlc3QsIGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRmx1c2ggZm10JywgZm10dHknKVxuXG4gIHwgU3RyaW5nX2xpdGVyYWwgKHN0ciwgZm10X3Jlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFN0cmluZ19saXRlcmFsIChzdHIsIGZtdCcpLCBmbXR0eScpXG4gIHwgQ2hhcl9saXRlcmFsIChjaHIsIGZtdF9yZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChDaGFyX2xpdGVyYWwgKGNociwgZm10JyksIGZtdHR5JylcblxuICB8IEZvcm1hdF9hcmcgKHBhZF9vcHQsIHN1Yl9mbXR0eSwgZm10X3Jlc3QpLFxuICAgIEZvcm1hdF9hcmdfdHkgKHN1Yl9mbXR0eScsIGZtdHR5X3Jlc3QpIC0+XG4gICAgaWYgRm10dHlfRUJCIHN1Yl9mbXR0eSA8PiBGbXR0eV9FQkIgc3ViX2ZtdHR5JyB0aGVuIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdF9hcmcgKHBhZF9vcHQsIHN1Yl9mbXR0eScsIGZtdCcpLCBmbXR0eScpXG4gIHwgRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBzdWJfZm10dHksIGZtdF9yZXN0KSxcbiAgICBGb3JtYXRfc3Vic3RfdHkgKHN1Yl9mbXR0eTEsIF9zdWJfZm10dHkyLCBmbXR0eV9yZXN0KSAtPlxuICAgIGlmIEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1Yl9mbXR0eSkgPD4gRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViX2ZtdHR5MSkgdGhlblxuICAgICAgcmFpc2UgVHlwZV9taXNtYXRjaDtcbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9XG4gICAgICB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgKGVyYXNlX3JlbCBmbXR0eV9yZXN0KVxuICAgIGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBzdWJfZm10dHkxLCBmbXQnKSwgZm10dHknKVxuICAoKiBQcmludGYgYW5kIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3RvcnM6ICopXG4gIHwgQWxwaGEgZm10X3Jlc3QsIEFscGhhX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoQWxwaGEgZm10JywgZm10dHknKVxuICB8IFRoZXRhIGZtdF9yZXN0LCBUaGV0YV90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFRoZXRhIGZtdCcsIGZtdHR5JylcblxuICAoKiBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3JzOiAqKVxuICB8IEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10X3Jlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10JyksIGZtdHR5JylcbiAgfCBGb3JtYXR0aW5nX2dlbiAoZm9ybWF0dGluZ19nZW4sIGZtdF9yZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIHR5cGVfZm9ybWF0dGluZ19nZW4gZm9ybWF0dGluZ19nZW4gZm10X3Jlc3QgZm10dHlfcmVzdFxuXG4gICgqIFNjYW5mIHNwZWNpZmljIGNvbnN0cnVjdG9yczogKilcbiAgfCBSZWFkZXIgZm10X3Jlc3QsIFJlYWRlcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFJlYWRlciBmbXQnLCBmbXR0eScpXG4gIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgZm10X3Jlc3QpLCBTdHJpbmdfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBmbXQnKSwgZm10dHknKVxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGZtdF9yZXN0KSwgSW50X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10JyksIGZtdHR5JylcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgdHlwZV9pZ25vcmVkX3BhcmFtIGlnbiByZXN0IGZtdHR5X3Jlc3RcblxuICB8IEVuZF9vZl9mb3JtYXQsIGZtdHR5X3Jlc3QgLT4gRm10X2ZtdHR5X0VCQiAoRW5kX29mX2Zvcm1hdCwgZm10dHlfcmVzdClcblxuICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG5hbmQgdHlwZV9mb3JtYXR0aW5nX2dlbiA6IHR5cGUgYTEgYTMgYjEgYjMgYzEgYzMgZDEgZDMgZTEgZTIgZTMgZjEgZjIgZjMgLlxuICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmb3JtYXR0aW5nX2dlbiAtPlxuICAgIChmMSwgYjEsIGMxLCBlMSwgZTIsIGYyKSBmbXQgLT5cbiAgICAoYTMsIGIzLCBjMywgZDMsIGUzLCBmMykgZm10dHkgLT5cbiAgICAoYTMsIGIzLCBjMywgZDMsIGUzLCBmMykgZm10X2ZtdHR5X2ViYiA9XG5mdW4gZm9ybWF0dGluZ19nZW4gZm10MCBmbXR0eTAgLT4gbWF0Y2ggZm9ybWF0dGluZ19nZW4gd2l0aFxuICB8IE9wZW5fdGFnIChGb3JtYXQgKGZtdDEsIHN0cikpIC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdDIsIGZtdHR5MikgPSB0eXBlX2Zvcm1hdF9nZW4gZm10MSBmbXR0eTAgaW5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10MywgZm10dHkzKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQwIGZtdHR5MiBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdHRpbmdfZ2VuIChPcGVuX3RhZyAoRm9ybWF0IChmbXQyLCBzdHIpKSwgZm10MyksIGZtdHR5MylcbiAgfCBPcGVuX2JveCAoRm9ybWF0IChmbXQxLCBzdHIpKSAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQyLCBmbXR0eTIpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdDEgZm10dHkwIGluXG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdDMsIGZtdHR5MykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10MCBmbXR0eTIgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10Miwgc3RyKSksIGZtdDMpLCBmbXR0eTMpXG5cbigqIFR5cGUgYW4gSWdub3JlZF9wYXJhbSBub2RlIGFjY29yZGluZyB0byBhbiBmbXR0eS4gKilcbmFuZCB0eXBlX2lnbm9yZWRfcGFyYW0gOiB0eXBlIHAgcSB4IHkgeiB0IHUgdiBhIGIgYyBkIGUgZiAuXG4gICAgKHgsIHksIHosIHQsIHEsIHApIGlnbm9yZWQgLT5cbiAgICAocCwgeSwgeiwgcSwgdSwgdikgZm10IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdF9mbXR0eV9lYmIgPVxuZnVuIGlnbiBmbXQgZm10dHkgLT4gbWF0Y2ggaWduIHdpdGhcbiAgfCBJZ25vcmVkX2NoYXIgICAgICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX3N0cmluZyBfICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIF8gICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2ludCBfICAgICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2ludDMyIF8gICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX25hdGl2ZWludCBfICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2ludDY0IF8gICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2Zsb2F0IF8gICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2Jvb2wgXyAgICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgXyAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgXyBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgKHBhZF9vcHQsIHN1Yl9mbXR0eSkgLT5cbiAgICB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIChJZ25vcmVkX2Zvcm1hdF9hcmcgKHBhZF9vcHQsIHN1Yl9mbXR0eSkpIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IChwYWRfb3B0LCBzdWJfZm10dHkpIC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eScsIEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eSBmbXQgZm10dHkgaW5cbiAgICBGbXRfZm10dHlfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX2Zvcm1hdF9zdWJzdCAocGFkX29wdCwgc3ViX2ZtdHR5JyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm10JyksXG4gICAgICAgICAgICAgICAgICAgZm10dHknKVxuICB8IElnbm9yZWRfcmVhZGVyIC0+IChcbiAgICBtYXRjaCBmbXR0eSB3aXRoXG4gICAgfCBJZ25vcmVkX3JlYWRlcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9yZWFkZXIsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuXG5hbmQgdHlwZV9pZ25vcmVkX3BhcmFtX29uZSA6IHR5cGUgYTEgYTIgYjEgYjIgYzEgYzIgZDEgZDIgZTEgZTIgZjEgZjIgLlxuICAgIChhMiwgYjIsIGMyLCBkMiwgZDIsIGEyKSBpZ25vcmVkIC0+XG4gICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdCAtPlxuICAgIChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eSAtPlxuICAgIChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXRfZm10dHlfZWJiXG49IGZ1biBpZ24gZm10IGZtdHR5IC0+XG4gIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdCBmbXR0eSBpblxuICBGbXRfZm10dHlfRUJCIChJZ25vcmVkX3BhcmFtIChpZ24sIGZtdCcpLCBmbXR0eScpXG5cbigqIFR5cGluZyBvZiB0aGUgY29tcGxleCBjYXNlOiBcIiVfKC4uLiUpXCIuICopXG5hbmQgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gOiB0eXBlIHcgeCB5IHogcCBzIHQgdSBhIGIgYyBkIGUgZiAuXG4gICAgKHcsIHgsIHksIHosIHMsIHApIGZtdHR5IC0+XG4gICAgKHAsIHgsIHksIHMsIHQsIHUpIGZtdCAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHlfZm10X2ViYiA9XG5mdW4gc3ViX2ZtdHR5IGZtdCBmbXR0eSAtPiBtYXRjaCBzdWJfZm10dHksIGZtdHR5IHdpdGhcbiAgfCBDaGFyX3R5IHN1Yl9mbXR0eV9yZXN0LCBDaGFyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKENoYXJfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IFN0cmluZ190eSBzdWJfZm10dHlfcmVzdCwgU3RyaW5nX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKFN0cmluZ190eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgSW50X3R5IHN1Yl9mbXR0eV9yZXN0LCBJbnRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoSW50X3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBJbnQzMl90eSBzdWJfZm10dHlfcmVzdCwgSW50MzJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoSW50MzJfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IE5hdGl2ZWludF90eSBzdWJfZm10dHlfcmVzdCwgTmF0aXZlaW50X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKE5hdGl2ZWludF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgSW50NjRfdHkgc3ViX2ZtdHR5X3Jlc3QsIEludDY0X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEludDY0X3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBGbG9hdF90eSBzdWJfZm10dHlfcmVzdCwgRmxvYXRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoRmxvYXRfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEJvb2xfdHkgc3ViX2ZtdHR5X3Jlc3QsIEJvb2xfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoQm9vbF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgQWxwaGFfdHkgc3ViX2ZtdHR5X3Jlc3QsIEFscGhhX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEFscGhhX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBUaGV0YV90eSBzdWJfZm10dHlfcmVzdCwgVGhldGFfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoVGhldGFfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IFJlYWRlcl90eSBzdWJfZm10dHlfcmVzdCwgUmVhZGVyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKFJlYWRlcl90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgc3ViX2ZtdHR5X3Jlc3QsIElnbm9yZWRfcmVhZGVyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKElnbm9yZWRfcmVhZGVyX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcblxuICB8IEZvcm1hdF9hcmdfdHkgKHN1YjJfZm10dHksIHN1Yl9mbXR0eV9yZXN0KSxcbiAgICBGb3JtYXRfYXJnX3R5IChzdWIyX2ZtdHR5JywgZm10dHlfcmVzdCkgLT5cbiAgICBpZiBGbXR0eV9FQkIgc3ViMl9mbXR0eSA8PiBGbXR0eV9FQkIgc3ViMl9mbXR0eScgdGhlbiByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoRm9ybWF0X2FyZ190eSAoc3ViMl9mbXR0eScsIHN1Yl9mbXR0eV9yZXN0JyksIGZtdCcpXG4gIHwgRm9ybWF0X3N1YnN0X3R5IChzdWIxX2ZtdHR5LCAgc3ViMl9mbXR0eSwgIHN1Yl9mbXR0eV9yZXN0KSxcbiAgICBGb3JtYXRfc3Vic3RfdHkgKHN1YjFfZm10dHknLCBzdWIyX2ZtdHR5JywgZm10dHlfcmVzdCkgLT5cbiAgICAoKiBUT0RPIGRlZmluZSBGbXR0eV9yZWxfRUJCIHRvIHJlbW92ZSB0aG9zZSBlcmFzZV9yZWwgKilcbiAgICBpZiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWIxX2ZtdHR5KSA8PiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWIxX2ZtdHR5JylcbiAgICB0aGVuIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgaWYgRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViMl9mbXR0eSkgPD4gRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViMl9mbXR0eScpXG4gICAgdGhlbiByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGxldCBzdWJfZm10dHknID0gdHJhbnMgKHN5bW0gc3ViMV9mbXR0eScpIHN1YjJfZm10dHknIGluXG4gICAgbGV0IF8sIGYyLCBfLCBmNCA9IGZtdHR5X3JlbF9kZXQgc3ViX2ZtdHR5JyBpblxuICAgIGxldCBSZWZsID0gZjIgUmVmbCBpblxuICAgIGxldCBSZWZsID0gZjQgUmVmbCBpblxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIChlcmFzZV9yZWwgc3ViX2ZtdHR5X3Jlc3QpIGZtdCBmbXR0eV9yZXN0XG4gICAgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChGb3JtYXRfc3Vic3RfdHkgKHN1YjFfZm10dHknLCBzdWIyX2ZtdHR5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bW0gc3ViX2ZtdHR5X3Jlc3QnKSxcbiAgICAgICAgICAgICAgICAgICBmbXQnKVxuICB8IEVuZF9vZl9mbXR0eSwgZm10dHkgLT5cbiAgICBGbXR0eV9mbXRfRUJCIChFbmRfb2ZfZm10dHksIHR5cGVfZm9ybWF0X2dlbiBmbXQgZm10dHkpXG4gIHwgXyAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbigqIFRoaXMgaW1wbGVtZW50YXRpb24gb2YgYHJlY2FzdGAgaXMgYSBiaXQgZGlzYXBwb2ludGluZy4gVGhlXG4gICBpbnZhcmlhbnQgcHJvdmlkZWQgYnkgdGhlIHR5cGUgYXJlIHZlcnkgc3Ryb25nOiB0aGUgaW5wdXQgZm9ybWF0J3NcbiAgIHR5cGUgaXMgaW4gcmVsYXRpb24gdG8gdGhlIG91dHB1dCB0eXBlJ3MgYXMgd2l0bmVzc2VkIGJ5IHRoZVxuICAgZm10dHlfcmVsIGFyZ3VtZW50LiBPbmUgd291bGQgYXQgZmlyc3QgZXhwZWN0IHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgIHRvdGFsLCBhbmQgaW1wbGVtZW50YWJsZSBieSBleGhhdXN0aXZlIHBhdHRlcm4gbWF0Y2hpbmcuIEluc3RlYWQsXG4gICB3ZSByZXVzZSB0aGUgaGlnaGx5IHBhcnRpYWwgYW5kIG11Y2ggbGVzcyB3ZWxsLWRlZmluZWQgZnVuY3Rpb25cbiAgIGB0eXBlX2Zvcm1hdGAgdGhhdCBoYXMgbG9zdCBhbGwga25vd2xlZGdlIG9mIHRoZSBjb3JyZXNwb25kZW5jZVxuICAgYmV0d2VlbiB0aGUgYXJndW1lbnQncyB0eXBlcy5cblxuICAgQmVzaWRlcyB0aGUgZmFjdCB0aGF0IHRoaXMgZnVuY3Rpb24gcmV1c2VzIGEgbG90IG9mIHRoZVxuICAgYHR5cGVfZm9ybWF0YCBsb2dpYyAoZWcuOiBzZWVpbmcgSW50X3R5IGluIHRoZSBmbXR0eSBwYXJhbWV0ZXIgZG9lc1xuICAgbm90IGxldCB5b3UgbWF0Y2ggb24gSW50IG9ubHksIGFzIHlvdSBtYXkgaW4gZmFjdCBoYXZlIEZsb2F0XG4gICAoQXJnX3BhZGRpbmcsIC4uLikgKFwiJS4qZFwiKSBiZWdpbm5pbmcgd2l0aCBhbiBJbnRfdHkpLCBpdCBpcyBhbHNvXG4gICBhIHBhcnRpYWwgZnVuY3Rpb24sIGJlY2F1c2UgdGhlIHR5cGluZyBpbmZvcm1hdGlvbiBpbiBhIGZvcm1hdCBpc1xuICAgbm90IHF1aXRlIGVub3VnaCB0byByZWNvbnN0cnVjdCBpdCB1bmFtYmlndW91c2x5LiBGb3IgZXhhbXBsZSwgdGhlXG4gICBmb3JtYXQgdHlwZXMgb2YgXCIlZCVfclwiIGFuZCBcIiVfciVkXCIgaGF2ZSB0aGUgc2FtZSBmb3JtYXQ2XG4gICBwYXJhbWV0ZXJzLCBidXQgdGhleSBhcmUgbm90IGF0IGFsbCBleGNoYW5nZWFibGUsIGFuZCBwdXR0aW5nIG9uZVxuICAgaW4gcGxhY2Ugb2YgdGhlIG90aGVyIG11c3QgcmVzdWx0IGluIGEgZHluYW1pYyBmYWlsdXJlLlxuXG4gICBHaXZlbiB0aGF0OlxuICAgLSB3ZSdkIGhhdmUgdG8gZHVwbGljYXRlIGEgbG90IG9mIG5vbi10cml2aWFsIHR5cGluZyBsb2dpYyBmcm9tIHR5cGVfZm9ybWF0XG4gICAtIHRoaXMgd291bGRuJ3QgZXZlbiBlbGltaW5hdGUgKGFsbCkgdGhlIGR5bmFtaWMgZmFpbHVyZXNcbiAgIHdlIGRlY2lkZWQgdG8ganVzdCByZXVzZSB0eXBlX2Zvcm1hdCBkaXJlY3RseSBmb3Igbm93LlxuKilcbmxldCByZWNhc3QgOlxuICB0eXBlIGExIGIxIGMxIGQxIGUxIGYxXG4gICAgICAgYTIgYjIgYzIgZDIgZTIgZjJcbiAgLlxuICAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10XG4gIC0+IChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgICAgYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlfcmVsXG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXRcbj0gZnVuIGZtdCBmbXR0eSAtPlxuICB0eXBlX2Zvcm1hdCBmbXQgKGVyYXNlX3JlbCAoc3ltbSBmbXR0eSkpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFByaW50aW5nIHRvb2xzICopXG5cbigqIEFkZCBwYWRkaW5nIHNwYWNlcyBhcm91bmQgYSBzdHJpbmcuICopXG5sZXQgZml4X3BhZGRpbmcgcGFkdHkgd2lkdGggc3RyID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIGxldCB3aWR0aCwgcGFkdHkgPVxuICAgIGFicyB3aWR0aCxcbiAgICAoKiB3aGlsZSBsaXRlcmFsIHBhZGRpbmcgd2lkdGhzIGFyZSBhbHdheXMgbm9uLW5lZ2F0aXZlLFxuICAgICAgIGR5bmFtaWNhbGx5LXNldCB3aWR0aHMgKEFyZ19wYWRkaW5nLCBlZy4gJSpkKSBtYXkgYmUgbmVnYXRpdmU7XG4gICAgICAgd2UgaW50ZXJwcmV0IHRob3NlIGFzIHNwZWNpZnlpbmcgYSBwYWRkaW5nLXRvLXRoZS1sZWZ0OyB0aGlzXG4gICAgICAgbWVhbnMgdGhhdCAnMCcgbWF5IGdldCBkcm9wcGVkIGV2ZW4gaWYgaXQgd2FzIGV4cGxpY2l0bHkgc2V0LFxuICAgICAgIGJ1dDpcbiAgICAgICAtIHRoaXMgaXMgd2hhdCB0aGUgbGVnYWN5IGltcGxlbWVudGF0aW9uIGRvZXMsIGFuZFxuICAgICAgICAgd2UgcHJlc2VydmUgY29tcGF0aWJpbGl0eSBpZiBwb3NzaWJsZVxuICAgICAgIC0gd2UgY291bGQgb25seSBzaWduYWwgdGhpcyBpc3N1ZSBieSBmYWlsaW5nIGF0IHJ1bnRpbWUsXG4gICAgICAgICB3aGljaCBpcyBub3QgdmVyeSBuaWNlLi4uICopXG4gICAgaWYgd2lkdGggPCAwIHRoZW4gTGVmdCBlbHNlIHBhZHR5IGluXG4gIGlmIHdpZHRoIDw9IGxlbiB0aGVuIHN0ciBlbHNlXG4gICAgbGV0IHJlcyA9IEJ5dGVzLm1ha2Ugd2lkdGggKGlmIHBhZHR5ID0gWmVyb3MgdGhlbiAnMCcgZWxzZSAnICcpIGluXG4gICAgYmVnaW4gbWF0Y2ggcGFkdHkgd2l0aFxuICAgIHwgTGVmdCAgLT4gU3RyaW5nLmJsaXQgc3RyIDAgcmVzIDAgbGVuXG4gICAgfCBSaWdodCAtPiBTdHJpbmcuYmxpdCBzdHIgMCByZXMgKHdpZHRoIC0gbGVuKSBsZW5cbiAgICB8IFplcm9zIHdoZW4gbGVuID4gMCAmJiAoc3RyLlswXSA9ICcrJyB8fCBzdHIuWzBdID0gJy0nIHx8IHN0ci5bMF0gPSAnICcpIC0+XG4gICAgICBCeXRlcy5zZXQgcmVzIDAgc3RyLlswXTtcbiAgICAgIFN0cmluZy5ibGl0IHN0ciAxIHJlcyAod2lkdGggLSBsZW4gKyAxKSAobGVuIC0gMSlcbiAgICB8IFplcm9zIHdoZW4gbGVuID4gMSAmJiBzdHIuWzBdID0gJzAnICYmIChzdHIuWzFdID0gJ3gnIHx8IHN0ci5bMV0gPSAnWCcpIC0+XG4gICAgICBCeXRlcy5zZXQgcmVzIDEgc3RyLlsxXTtcbiAgICAgIFN0cmluZy5ibGl0IHN0ciAyIHJlcyAod2lkdGggLSBsZW4gKyAyKSAobGVuIC0gMilcbiAgICB8IFplcm9zIC0+XG4gICAgICBTdHJpbmcuYmxpdCBzdHIgMCByZXMgKHdpZHRoIC0gbGVuKSBsZW5cbiAgICBlbmQ7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcblxuKCogQWRkICcwJyBwYWRkaW5nIHRvIGludCwgaW50MzIsIG5hdGl2ZWludCBvciBpbnQ2NCBzdHJpbmcgcmVwcmVzZW50YXRpb24uICopXG5sZXQgZml4X2ludF9wcmVjaXNpb24gcHJlYyBzdHIgPVxuICBsZXQgcHJlYyA9IGFicyBwcmVjIGluXG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBtYXRjaCBzdHIuWzBdIHdpdGhcbiAgfCAoJysnIHwgJy0nIHwgJyAnKSBhcyBjIHdoZW4gcHJlYyArIDEgPiBsZW4gLT5cbiAgICBsZXQgcmVzID0gQnl0ZXMubWFrZSAocHJlYyArIDEpICcwJyBpblxuICAgIEJ5dGVzLnNldCByZXMgMCBjO1xuICAgIFN0cmluZy5ibGl0IHN0ciAxIHJlcyAocHJlYyAtIGxlbiArIDIpIChsZW4gLSAxKTtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuICB8ICcwJyB3aGVuIHByZWMgKyAyID4gbGVuICYmIGxlbiA+IDEgJiYgKHN0ci5bMV0gPSAneCcgfHwgc3RyLlsxXSA9ICdYJykgLT5cbiAgICBsZXQgcmVzID0gQnl0ZXMubWFrZSAocHJlYyArIDIpICcwJyBpblxuICAgIEJ5dGVzLnNldCByZXMgMSBzdHIuWzFdO1xuICAgIFN0cmluZy5ibGl0IHN0ciAyIHJlcyAocHJlYyAtIGxlbiArIDQpIChsZW4gLSAyKTtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuICB8ICcwJyAuLiAnOScgfCAnYScgLi4gJ2YnIHwgJ0EnIC4uICdGJyB3aGVuIHByZWMgPiBsZW4gLT5cbiAgICBsZXQgcmVzID0gQnl0ZXMubWFrZSBwcmVjICcwJyBpblxuICAgIFN0cmluZy5ibGl0IHN0ciAwIHJlcyAocHJlYyAtIGxlbikgbGVuO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG4gIHwgXyAtPlxuICAgIHN0clxuXG4oKiBFc2NhcGUgYSBzdHJpbmcgYWNjb3JkaW5nIHRvIHRoZSBPQ2FtbCBsZXhpbmcgY29udmVudGlvbi4gKilcbmxldCBzdHJpbmdfdG9fY2FtbF9zdHJpbmcgc3RyID1cbiAgbGV0IHN0ciA9IFN0cmluZy5lc2NhcGVkIHN0ciBpblxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIGxldCByZXMgPSBCeXRlcy5tYWtlIChsICsgMikgJ1xcXCInIGluXG4gIFN0cmluZy51bnNhZmVfYmxpdCBzdHIgMCByZXMgMSBsO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuXG4oKiBHZW5lcmF0ZSB0aGUgZm9ybWF0X2ludC9pbnQzMi9uYXRpdmVpbnQvaW50NjQgZmlyc3QgYXJndW1lbnRcbiAgIGZyb20gYW4gaW50X2NvbnYuICopXG5sZXQgZm9ybWF0X29mX2ljb252ID0gZnVuY3Rpb25cbiAgfCBJbnRfZCAtPiBcIiVkXCIgfCBJbnRfcGQgLT4gXCIlK2RcIiB8IEludF9zZCAtPiBcIiUgZFwiXG4gIHwgSW50X2kgLT4gXCIlaVwiIHwgSW50X3BpIC0+IFwiJStpXCIgfCBJbnRfc2kgLT4gXCIlIGlcIlxuICB8IEludF94IC0+IFwiJXhcIiB8IEludF9DeCAtPiBcIiUjeFwiXG4gIHwgSW50X1ggLT4gXCIlWFwiIHwgSW50X0NYIC0+IFwiJSNYXCJcbiAgfCBJbnRfbyAtPiBcIiVvXCIgfCBJbnRfQ28gLT4gXCIlI29cIlxuICB8IEludF91IC0+IFwiJXVcIlxuXG5sZXQgZm9ybWF0X29mX2ljb252TCA9IGZ1bmN0aW9uXG4gIHwgSW50X2QgLT4gXCIlTGRcIiB8IEludF9wZCAtPiBcIiUrTGRcIiB8IEludF9zZCAtPiBcIiUgTGRcIlxuICB8IEludF9pIC0+IFwiJUxpXCIgfCBJbnRfcGkgLT4gXCIlK0xpXCIgfCBJbnRfc2kgLT4gXCIlIExpXCJcbiAgfCBJbnRfeCAtPiBcIiVMeFwiIHwgSW50X0N4IC0+IFwiJSNMeFwiXG4gIHwgSW50X1ggLT4gXCIlTFhcIiB8IEludF9DWCAtPiBcIiUjTFhcIlxuICB8IEludF9vIC0+IFwiJUxvXCIgfCBJbnRfQ28gLT4gXCIlI0xvXCJcbiAgfCBJbnRfdSAtPiBcIiVMdVwiXG5cbmxldCBmb3JtYXRfb2ZfaWNvbnZsID0gZnVuY3Rpb25cbiAgfCBJbnRfZCAtPiBcIiVsZFwiIHwgSW50X3BkIC0+IFwiJStsZFwiIHwgSW50X3NkIC0+IFwiJSBsZFwiXG4gIHwgSW50X2kgLT4gXCIlbGlcIiB8IEludF9waSAtPiBcIiUrbGlcIiB8IEludF9zaSAtPiBcIiUgbGlcIlxuICB8IEludF94IC0+IFwiJWx4XCIgfCBJbnRfQ3ggLT4gXCIlI2x4XCJcbiAgfCBJbnRfWCAtPiBcIiVsWFwiIHwgSW50X0NYIC0+IFwiJSNsWFwiXG4gIHwgSW50X28gLT4gXCIlbG9cIiB8IEludF9DbyAtPiBcIiUjbG9cIlxuICB8IEludF91IC0+IFwiJWx1XCJcblxubGV0IGZvcm1hdF9vZl9pY29udm4gPSBmdW5jdGlvblxuICB8IEludF9kIC0+IFwiJW5kXCIgfCBJbnRfcGQgLT4gXCIlK25kXCIgfCBJbnRfc2QgLT4gXCIlIG5kXCJcbiAgfCBJbnRfaSAtPiBcIiVuaVwiIHwgSW50X3BpIC0+IFwiJStuaVwiIHwgSW50X3NpIC0+IFwiJSBuaVwiXG4gIHwgSW50X3ggLT4gXCIlbnhcIiB8IEludF9DeCAtPiBcIiUjbnhcIlxuICB8IEludF9YIC0+IFwiJW5YXCIgfCBJbnRfQ1ggLT4gXCIlI25YXCJcbiAgfCBJbnRfbyAtPiBcIiVub1wiIHwgSW50X0NvIC0+IFwiJSNub1wiXG4gIHwgSW50X3UgLT4gXCIlbnVcIlxuXG4oKiBHZW5lcmF0ZSB0aGUgZm9ybWF0X2Zsb2F0IGZpcnN0IGFyZ3VtZW50IGZvcm0gYSBmbG9hdF9jb252LiAqKVxubGV0IGZvcm1hdF9vZl9mY29udiBmY29udiBwcmVjID1cbiAgaWYgZmNvbnYgPSBGbG9hdF9GIHRoZW4gXCIlLjEyZ1wiIGVsc2VcbiAgICBsZXQgcHJlYyA9IGFicyBwcmVjIGluXG4gICAgbGV0IHN5bWIgPSBjaGFyX29mX2Zjb252IGZjb252IGluXG4gICAgbGV0IGJ1ZiA9IGJ1ZmZlcl9jcmVhdGUgMTYgaW5cbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJztcbiAgICBicHJpbnRfZmNvbnZfZmxhZyBidWYgZmNvbnY7XG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnLic7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIChzdHJpbmdfb2ZfaW50IHByZWMpO1xuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgc3ltYjtcbiAgICBidWZmZXJfY29udGVudHMgYnVmXG5cbigqIENvbnZlcnQgYW4gaW50ZWdlciB0byBhIHN0cmluZyBhY2NvcmRpbmcgdG8gYSBjb252ZXJzaW9uLiAqKVxubGV0IGNvbnZlcnRfaW50IGljb252IG4gPSBmb3JtYXRfaW50IChmb3JtYXRfb2ZfaWNvbnYgaWNvbnYpIG5cbmxldCBjb252ZXJ0X2ludDMyIGljb252IG4gPSBmb3JtYXRfaW50MzIgKGZvcm1hdF9vZl9pY29udmwgaWNvbnYpIG5cbmxldCBjb252ZXJ0X25hdGl2ZWludCBpY29udiBuID0gZm9ybWF0X25hdGl2ZWludCAoZm9ybWF0X29mX2ljb252biBpY29udikgblxubGV0IGNvbnZlcnRfaW50NjQgaWNvbnYgbiA9IGZvcm1hdF9pbnQ2NCAoZm9ybWF0X29mX2ljb252TCBpY29udikgblxuXG4oKiBDb252ZXJ0IGEgZmxvYXQgdG8gc3RyaW5nLiAqKVxuKCogRml4IHNwZWNpYWwgY2FzZSBvZiBcIk9DYW1sIGZsb2F0IGZvcm1hdFwiLiAqKVxubGV0IGNvbnZlcnRfZmxvYXQgZmNvbnYgcHJlYyB4ID1cbiAgbWF0Y2ggZmNvbnYgd2l0aFxuICB8IEZsb2F0X2ggfCBGbG9hdF9waCB8IEZsb2F0X3NoIHwgRmxvYXRfSCB8IEZsb2F0X3BIIHwgRmxvYXRfc0ggLT5cbiAgICBsZXQgc2lnbiA9XG4gICAgICBtYXRjaCBmY29udiB3aXRoXG4gICAgICB8IEZsb2F0X3BoIHwgRmxvYXRfcEggLT4gJysnXG4gICAgICB8IEZsb2F0X3NoIHwgRmxvYXRfc0ggLT4gJyAnXG4gICAgICB8IF8gLT4gJy0nIGluXG4gICAgbGV0IHN0ciA9IGhleHN0cmluZ19vZl9mbG9hdCB4IHByZWMgc2lnbiBpblxuICAgIGJlZ2luIG1hdGNoIGZjb252IHdpdGhcbiAgICB8IEZsb2F0X0ggfCBGbG9hdF9wSCB8IEZsb2F0X3NIIC0+IFN0cmluZy51cHBlcmNhc2VfYXNjaWkgc3RyXG4gICAgfCBfIC0+IHN0clxuICAgIGVuZFxuICB8IF8gLT5cbiAgICBsZXQgc3RyID0gZm9ybWF0X2Zsb2F0IChmb3JtYXRfb2ZfZmNvbnYgZmNvbnYgcHJlYykgeCBpblxuICAgIGlmIGZjb252IDw+IEZsb2F0X0YgdGhlbiBzdHIgZWxzZVxuICAgICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gICAgICBsZXQgcmVjIGlzX3ZhbGlkIGkgPVxuICAgICAgICBpZiBpID0gbGVuIHRoZW4gZmFsc2UgZWxzZVxuICAgICAgICAgIG1hdGNoIHN0ci5baV0gd2l0aFxuICAgICAgICAgIHwgJy4nIHwgJ2UnIHwgJ0UnIC0+IHRydWVcbiAgICAgICAgICB8IF8gLT4gaXNfdmFsaWQgKGkgKyAxKVxuICAgICAgaW5cbiAgICAgIG1hdGNoIGNsYXNzaWZ5X2Zsb2F0IHggd2l0aFxuICAgICAgfCBGUF9ub3JtYWwgfCBGUF9zdWJub3JtYWwgfCBGUF96ZXJvIC0+XG4gICAgICAgIGlmIGlzX3ZhbGlkIDAgdGhlbiBzdHIgZWxzZSBzdHIgXiBcIi5cIlxuICAgICAgfCBGUF9pbmZpbml0ZSAtPlxuICAgICAgICBpZiB4IDwgMC4wIHRoZW4gXCJuZWdfaW5maW5pdHlcIiBlbHNlIFwiaW5maW5pdHlcIlxuICAgICAgfCBGUF9uYW4gLT4gXCJuYW5cIlxuXG4oKiBDb252ZXJ0IGEgY2hhciB0byBhIHN0cmluZyBhY2NvcmRpbmcgdG8gdGhlIE9DYW1sIGxleGljYWwgY29udmVudGlvbi4gKilcbmxldCBmb3JtYXRfY2FtbF9jaGFyIGMgPVxuICBsZXQgc3RyID0gQ2hhci5lc2NhcGVkIGMgaW5cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgcmVzID0gQnl0ZXMubWFrZSAobCArIDIpICdcXCcnIGluXG4gIFN0cmluZy51bnNhZmVfYmxpdCBzdHIgMCByZXMgMSBsO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuXG4oKiBDb252ZXJ0IGEgZm9ybWF0IHR5cGUgdG8gc3RyaW5nICopXG5sZXQgc3RyaW5nX29mX2ZtdHR5IGZtdHR5ID1cbiAgbGV0IGJ1ZiA9IGJ1ZmZlcl9jcmVhdGUgMTYgaW5cbiAgYnByaW50X2ZtdHR5IGJ1ZiBmbXR0eTtcbiAgYnVmZmVyX2NvbnRlbnRzIGJ1ZlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgKCogR2VuZXJpYyBwcmludGluZyBmdW5jdGlvbiAqKVxuXG4oKiBNYWtlIGEgZ2VuZXJpYyBwcmludGluZyBmdW5jdGlvbi4gKilcbigqIFVzZWQgdG8gZ2VuZXJhdGUgUHJpbnRmIGFuZCBGb3JtYXQgcHJpbnRpbmcgZnVuY3Rpb25zLiAqKVxuKCogUGFyYW1ldGVyczpcbiAgICAgazogYSBjb250aW51YXRpb24gZmluYWxseSBhcHBsaWVkIHRvIHRoZSBvdXRwdXQgc3RyZWFtIGFuZCB0aGUgYWNjdW11bGF0b3IuXG4gICAgIG86IHRoZSBvdXRwdXQgc3RyZWFtIChzZWUgaywgJWEgYW5kICV0KS5cbiAgICAgYWNjOiByZXYgbGlzdCBvZiBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzaCwgZm9ybWF0dGluZywgLi4uKS5cbiAgICAgZm10OiB0aGUgZm9ybWF0LiAqKVxubGV0IHJlYyBtYWtlX3ByaW50ZiA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAgIChiIC0+IChiLCBjKSBhY2MgLT4gZikgLT4gYiAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiBhID1cbmZ1biBrIG8gYWNjIGZtdCAtPiBtYXRjaCBmbXQgd2l0aFxuICB8IENoYXIgcmVzdCAtPlxuICAgIGZ1biBjIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX2NoYXIgKGFjYywgYykgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyBuZXdfYWNjIHJlc3RcbiAgfCBDYW1sX2NoYXIgcmVzdCAtPlxuICAgIGZ1biBjIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCBmb3JtYXRfY2FtbF9jaGFyIGMpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gbmV3X2FjYyByZXN0XG4gIHwgU3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgbWFrZV9wYWRkaW5nIGsgbyBhY2MgcmVzdCBwYWQgKGZ1biBzdHIgLT4gc3RyKVxuICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgbWFrZV9wYWRkaW5nIGsgbyBhY2MgcmVzdCBwYWQgc3RyaW5nX3RvX2NhbWxfc3RyaW5nXG4gIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIGsgbyBhY2MgcmVzdCBwYWQgcHJlYyBjb252ZXJ0X2ludCBpY29udlxuICB8IEludDMyIChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIGsgbyBhY2MgcmVzdCBwYWQgcHJlYyBjb252ZXJ0X2ludDMyIGljb252XG4gIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIGsgbyBhY2MgcmVzdCBwYWQgcHJlYyBjb252ZXJ0X25hdGl2ZWludCBpY29udlxuICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIGsgbyBhY2MgcmVzdCBwYWQgcHJlYyBjb252ZXJ0X2ludDY0IGljb252XG4gIHwgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbWFrZV9mbG9hdF9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gYWNjIHJlc3QgcGFkIHByZWMgZmNvbnZcbiAgfCBCb29sIChwYWQsIHJlc3QpIC0+XG4gICAgbWFrZV9wYWRkaW5nIGsgbyBhY2MgcmVzdCBwYWQgc3RyaW5nX29mX2Jvb2xcbiAgfCBBbHBoYSByZXN0IC0+XG4gICAgZnVuIGYgeCAtPiBtYWtlX3ByaW50ZiBrIG8gKEFjY19kZWxheSAoYWNjLCBmdW4gbyAtPiBmIG8geCkpIHJlc3RcbiAgfCBUaGV0YSByZXN0IC0+XG4gICAgZnVuIGYgLT4gbWFrZV9wcmludGYgayBvIChBY2NfZGVsYXkgKGFjYywgZikpIHJlc3RcbiAgfCBDdXN0b20gKGFyaXR5LCBmLCByZXN0KSAtPlxuICAgIG1ha2VfY3VzdG9tIGsgbyBhY2MgcmVzdCBhcml0eSAoZiAoKSlcbiAgfCBSZWFkZXIgXyAtPlxuICAgICgqIFRoaXMgY2FzZSBpcyBpbXBvc3NpYmxlLCBieSB0eXBpbmcgb2YgZm9ybWF0cy4gKilcbiAgICAoKiBJbmRlZWQsIHNpbmNlIHByaW50ZiBhbmQgY28uIHRha2UgYSBmb3JtYXQ0IGFzIGFyZ3VtZW50LCB0aGUgJ2QgYW5kICdlXG4gICAgICAgdHlwZSBwYXJhbWV0ZXJzIG9mIGZtdCBhcmUgb2J2aW91c2x5IGVxdWFscy4gVGhlIFJlYWRlciBpcyB0aGVcbiAgICAgICBvbmx5IGNvbnN0cnVjdG9yIHdoaWNoIHRvdWNoICdkIGFuZCAnZSB0eXBlIHBhcmFtZXRlcnMgb2YgdGhlIGZvcm1hdFxuICAgICAgIHR5cGUsIGl0IGFkZHMgYW4gKC0+KSB0byB0aGUgJ2QgcGFyYW1ldGVycy4gQ29uc2VxdWVudGx5LCBhIGZvcm1hdDRcbiAgICAgICBjYW5ub3QgY29udGFpbiBhIFJlYWRlciBub2RlLCBleGNlcHQgaW4gdGhlIHN1Yi1mb3JtYXQgYXNzb2NpYXRlZCB0b1xuICAgICAgIGFuICV7Li4uJX0uIEl0J3Mgbm90IGEgcHJvYmxlbSBiZWNhdXNlIG1ha2VfcHJpbnRmIGRvIG5vdCBjYWxsXG4gICAgICAgaXRzZWxmIHJlY3Vyc2l2ZWx5IG9uIHRoZSBzdWItZm9ybWF0IGFzc29jaWF0ZWQgdG8gJXsuLi4lfS4gKilcbiAgICBhc3NlcnQgZmFsc2VcbiAgfCBGbHVzaCByZXN0IC0+XG4gICAgbWFrZV9wcmludGYgayBvIChBY2NfZmx1c2ggYWNjKSByZXN0XG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSAtPlxuICAgIG1ha2VfcHJpbnRmIGsgbyAoQWNjX3N0cmluZ19saXRlcmFsIChhY2MsIHN0cikpIHJlc3RcbiAgfCBDaGFyX2xpdGVyYWwgKGNociwgcmVzdCkgLT5cbiAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19jaGFyX2xpdGVyYWwgKGFjYywgY2hyKSkgcmVzdFxuXG4gIHwgRm9ybWF0X2FyZyAoXywgc3ViX2ZtdHR5LCByZXN0KSAtPlxuICAgIGxldCB0eSA9IHN0cmluZ19vZl9mbXR0eSBzdWJfZm10dHkgaW5cbiAgICAoZnVuIHN0ciAtPlxuICAgICAgaWdub3JlIHN0cjtcbiAgICAgIG1ha2VfcHJpbnRmIGsgbyAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHR5KSkgcmVzdClcbiAgfCBGb3JtYXRfc3Vic3QgKF8sIGZtdHR5LCByZXN0KSAtPlxuICAgIGZ1biAoRm9ybWF0IChmbXQsIF8pKSAtPiBtYWtlX3ByaW50ZiBrIG8gYWNjXG4gICAgICAoY29uY2F0X2ZtdCAocmVjYXN0IGZtdCBmbXR0eSkgcmVzdClcblxuICB8IFNjYW5fY2hhcl9zZXQgKF8sIF8sIHJlc3QpIC0+XG4gICAgbGV0IG5ld19hY2MgPSBBY2NfaW52YWxpZF9hcmcgKGFjYywgXCJQcmludGY6IGJhZCBjb252ZXJzaW9uICVbXCIpIGluXG4gICAgZnVuIF8gLT4gbWFrZV9wcmludGYgayBvIG5ld19hY2MgcmVzdFxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKF8sIHJlc3QpIC0+XG4gICAgKCogVGhpcyBjYXNlIHNob3VsZCBiZSByZWZ1c2VkIGZvciBQcmludGYuICopXG4gICAgKCogQWNjZXB0ZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuICopXG4gICAgKCogSW50ZXJwcmV0ICVsLCAlbiBhbmQgJUwgYXMgJXUuICopXG4gICAgZnVuIG4gLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfc3RyaW5nIChhY2MsIGZvcm1hdF9pbnQgXCIldVwiIG4pIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gbmV3X2FjYyByZXN0XG4gIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAtPlxuICAgIGZ1biBjIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX2NoYXIgKGFjYywgYykgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyBuZXdfYWNjIHJlc3RcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpIC0+XG4gICAgbWFrZV9pZ25vcmVkX3BhcmFtIGsgbyBhY2MgaWduIHJlc3RcblxuICB8IEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCByZXN0KSAtPlxuICAgIG1ha2VfcHJpbnRmIGsgbyAoQWNjX2Zvcm1hdHRpbmdfbGl0IChhY2MsIGZtdGluZ19saXQpKSByZXN0XG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICBsZXQgaycga29jIGthY2MgPVxuICAgICAgbWFrZV9wcmludGYgayBrb2MgKEFjY19mb3JtYXR0aW5nX2dlbiAoYWNjLCBBY2Nfb3Blbl90YWcga2FjYykpIHJlc3QgaW5cbiAgICBtYWtlX3ByaW50ZiBrJyBvIEVuZF9vZl9hY2MgZm10J1xuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgbGV0IGsnIGtvYyBrYWNjID1cbiAgICAgIG1ha2VfcHJpbnRmIGsga29jIChBY2NfZm9ybWF0dGluZ19nZW4gKGFjYywgQWNjX29wZW5fYm94IGthY2MpKSByZXN0IGluXG4gICAgbWFrZV9wcmludGYgaycgbyBFbmRfb2ZfYWNjIGZtdCdcblxuICB8IEVuZF9vZl9mb3JtYXQgLT5cbiAgICBrIG8gYWNjXG5cbigqIERlbGF5IHRoZSBlcnJvciAoSW52YWxpZF9hcmd1bWVudCBcIlByaW50ZjogYmFkIGNvbnZlcnNpb24gJV9cIikuICopXG4oKiBHZW5lcmF0ZSBmdW5jdGlvbnMgdG8gdGFrZSByZW1haW5pbmcgYXJndW1lbnRzIChhZnRlciB0aGUgXCIlX1wiKS4gKilcbmFuZCBtYWtlX2lnbm9yZWRfcGFyYW0gOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gICAgKGIgLT4gKGIsIGMpIGFjYyAtPiBmKSAtPiBiIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgeSwgeCkgaWdub3JlZCAtPlxuICAgICh4LCBiLCBjLCB5LCBlLCBmKSBmbXQgLT4gYSA9XG5mdW4gayBvIGFjYyBpZ24gZm10IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9jaGFyICAgICAgICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgbyBhY2MgZm10XG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgbyBhY2MgZm10XG4gIHwgSWdub3JlZF9zdHJpbmcgXyAgICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgbyBhY2MgZm10XG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBfICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgbyBhY2MgZm10XG4gIHwgSWdub3JlZF9pbnQgKF8sIF8pICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgbyBhY2MgZm10XG4gIHwgSWdub3JlZF9pbnQzMiAoXywgXykgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgbyBhY2MgZm10XG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgKF8sIF8pICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgbyBhY2MgZm10XG4gIHwgSWdub3JlZF9pbnQ2NCAoXywgXykgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgbyBhY2MgZm10XG4gIHwgSWdub3JlZF9mbG9hdCAoXywgXykgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgbyBhY2MgZm10XG4gIHwgSWdub3JlZF9ib29sIF8gICAgICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgbyBhY2MgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIF8gICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgbyBhY2MgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKF8sIGZtdHR5KSAtPiBtYWtlX2Zyb21fZm10dHkgayBvIGFjYyBmbXR0eSBmbXRcbiAgfCBJZ25vcmVkX3JlYWRlciAgICAgICAgICAgICAgICAgIC0+IGFzc2VydCBmYWxzZVxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCBfICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIG8gYWNjIGZtdFxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBfICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIG8gYWNjIGZtdFxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIG8gYWNjIGZtdFxuXG5cbigqIFNwZWNpYWwgY2FzZSBvZiBwcmludGYgXCIlXyhcIi4gKilcbmFuZCBtYWtlX2Zyb21fZm10dHkgOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gICAgKGIgLT4gKGIsIGMpIGFjYyAtPiBmKSAtPiBiIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgeSwgeCkgZm10dHkgLT5cbiAgICAoeCwgYiwgYywgeSwgZSwgZikgZm10IC0+IGEgPVxuZnVuIGsgbyBhY2MgZm10dHkgZm10IC0+IG1hdGNoIGZtdHR5IHdpdGhcbiAgfCBDaGFyX3R5IHJlc3QgICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBvIGFjYyByZXN0IGZtdFxuICB8IFN0cmluZ190eSByZXN0ICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIG8gYWNjIHJlc3QgZm10XG4gIHwgSW50X3R5IHJlc3QgICAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgbyBhY2MgcmVzdCBmbXRcbiAgfCBJbnQzMl90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBvIGFjYyByZXN0IGZtdFxuICB8IE5hdGl2ZWludF90eSByZXN0ICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIG8gYWNjIHJlc3QgZm10XG4gIHwgSW50NjRfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgbyBhY2MgcmVzdCBmbXRcbiAgfCBGbG9hdF90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBvIGFjYyByZXN0IGZtdFxuICB8IEJvb2xfdHkgcmVzdCAgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIG8gYWNjIHJlc3QgZm10XG4gIHwgQWxwaGFfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBvIGFjYyByZXN0IGZtdFxuICB8IFRoZXRhX3R5IHJlc3QgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIG8gYWNjIHJlc3QgZm10XG4gIHwgQW55X3R5IHJlc3QgICAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgbyBhY2MgcmVzdCBmbXRcbiAgfCBSZWFkZXJfdHkgXyAgICAgICAgICAgICAtPiBhc3NlcnQgZmFsc2VcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSBfICAgICAtPiBhc3NlcnQgZmFsc2VcbiAgfCBGb3JtYXRfYXJnX3R5IChfLCByZXN0KSAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBvIGFjYyByZXN0IGZtdFxuICB8IEVuZF9vZl9mbXR0eSAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBvIGFjYyBmbXRcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIGxldCB0eSA9IHRyYW5zIChzeW1tIHR5MSkgdHkyIGluXG4gICAgZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgbyBhY2MgKGNvbmNhdF9mbXR0eSB0eSByZXN0KSBmbXRcblxuKCogSW5zZXJ0IGFuIEFjY19pbnZhbGlkX2FyZyBpbiB0aGUgYWNjdW11bGF0b3IgYW5kIGNvbnRpbnVlIHRvIGdlbmVyYXRlXG4gICBjbG9zdXJlcyB0byBnZXQgdGhlIHJlbWFpbmluZyBhcmd1bWVudHMuICopXG5hbmQgbWFrZV9pbnZhbGlkX2FyZyA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAgIChiIC0+IChiLCBjKSBhY2MgLT4gZikgLT4gYiAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiBhID1cbmZ1biBrIG8gYWNjIGZtdCAtPlxuICBtYWtlX3ByaW50ZiBrIG8gKEFjY19pbnZhbGlkX2FyZyAoYWNjLCBcIlByaW50ZjogYmFkIGNvbnZlcnNpb24gJV9cIikpIGZtdFxuXG4oKiBGaXggcGFkZGluZywgdGFrZSBpdCBhcyBhbiBleHRyYSBpbnRlZ2VyIGFyZ3VtZW50IGlmIG5lZWRlZC4gKilcbmFuZCBtYWtlX3BhZGRpbmcgOiB0eXBlIHggeiBhIGIgYyBkIGUgZiAuXG4gICAgKGIgLT4gKGIsIGMpIGFjYyAtPiBmKSAtPiBiIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgKHgsIHogLT4gYSkgcGFkZGluZyAtPiAoeiAtPiBzdHJpbmcpIC0+IHggPVxuICBmdW4gayBvIGFjYyBmbXQgcGFkIHRyYW5zIC0+IG1hdGNoIHBhZCB3aXRoXG4gIHwgTm9fcGFkZGluZyAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCB0cmFucyB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayBvIG5ld19hY2MgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3aWR0aCkgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9zdHJpbmcgKGFjYywgZml4X3BhZGRpbmcgcGFkdHkgd2lkdGggKHRyYW5zIHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayBvIG5ld19hY2MgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHkgLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCBmaXhfcGFkZGluZyBwYWR0eSB3ICh0cmFucyB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyBuZXdfYWNjIGZtdFxuXG4oKiBGaXggcGFkZGluZyBhbmQgcHJlY2lzaW9uIGZvciBpbnQsIGludDMyLCBuYXRpdmVpbnQgb3IgaW50NjQuICopXG4oKiBUYWtlIG9uZSBvciB0d28gZXh0cmEgaW50ZWdlciBhcmd1bWVudHMgaWYgbmVlZGVkLiAqKVxuYW5kIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIDogdHlwZSB4IHkgeiBhIGIgYyBkIGUgZiAuXG4gICAgKGIgLT4gKGIsIGMpIGFjYyAtPiBmKSAtPiBiIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgKHgsIHkpIHBhZGRpbmcgLT4gKHksIHogLT4gYSkgcHJlY2lzaW9uIC0+IChpbnRfY29udiAtPiB6IC0+IHN0cmluZykgLT5cbiAgICBpbnRfY29udiAtPiB4ID1cbiAgZnVuIGsgbyBhY2MgZm10IHBhZCBwcmVjIHRyYW5zIGljb252IC0+IG1hdGNoIHBhZCwgcHJlYyB3aXRoXG4gIHwgTm9fcGFkZGluZywgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSB0cmFucyBpY29udiB4IGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBOb19wYWRkaW5nLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBOb19wYWRkaW5nLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKHRyYW5zIGljb252IHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayBvIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAodHJhbnMgaWNvbnYgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB3IHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayBvIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG5cbigqIENvbnZlcnQgYSBmbG9hdCwgZml4IHBhZGRpbmcgYW5kIHByZWNpc2lvbiBpZiBuZWVkZWQuICopXG4oKiBUYWtlIHRoZSBmbG9hdCBhcmd1bWVudCBhbmQgb25lIG9yIHR3byBleHRyYSBpbnRlZ2VyIGFyZ3VtZW50cyBpZiBuZWVkZWQuICopXG5hbmQgbWFrZV9mbG9hdF9wYWRkaW5nX3ByZWNpc2lvbiA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgICAoYiAtPiAoYiwgYykgYWNjIC0+IGYpIC0+IGIgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoeSwgZmxvYXQgLT4gYSkgcHJlY2lzaW9uIC0+IGZsb2F0X2NvbnYgLT4geCA9XG4gIGZ1biBrIG8gYWNjIGZtdCBwYWQgcHJlYyBmY29udiAtPiBtYXRjaCBwYWQsIHByZWMgd2l0aFxuICB8IE5vX3BhZGRpbmcsIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gY29udmVydF9mbG9hdCBmY29udiBkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiB4IGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBOb19wYWRkaW5nLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4IGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBOb19wYWRkaW5nLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4IGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgZGVmYXVsdF9mbG9hdF9wcmVjaXNpb24geCBpblxuICAgICAgbGV0IHN0cicgPSBmaXhfcGFkZGluZyBwYWR0eSB3IHN0ciBpblxuICAgICAgbWFrZV9wcmludGYgayBvIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyJykpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoY29udmVydF9mbG9hdCBmY29udiBwIHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayBvIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB3IHggLT5cbiAgICAgIGxldCBzdHIgPSBjb252ZXJ0X2Zsb2F0IGZjb252IGRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uIHggaW5cbiAgICAgIGxldCBzdHInID0gZml4X3BhZGRpbmcgcGFkdHkgdyBzdHIgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cicpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHcgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayBvIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gdyBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuYW5kIG1ha2VfY3VzdG9tIDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAoYiAtPiAoYiwgYykgYWNjIC0+IGYpIC0+IGIgLT4gKGIsIGMpIGFjYyAtPlxuICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gIChhLCB4LCB5KSBjdXN0b21fYXJpdHkgLT4geCAtPiB5ID1cbiAgZnVuIGsgbyBhY2MgcmVzdCBhcml0eSBmIC0+IG1hdGNoIGFyaXR5IHdpdGhcbiAgfCBDdXN0b21femVybyAtPiBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBmKSkgcmVzdFxuICB8IEN1c3RvbV9zdWNjIGFyaXR5IC0+XG4gICAgZnVuIHggLT5cbiAgICAgIG1ha2VfY3VzdG9tIGsgbyBhY2MgcmVzdCBhcml0eSAoZiB4KVxuXG5sZXQgY29uc3QgeCBfID0geFxuXG5sZXQgcmVjIG1ha2VfaXByaW50ZiA6IHR5cGUgYSBiIGMgZCBlIGYuXG4gIChiIC0+IGYpIC0+IGIgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiBhID1cbiAgZnVuIGsgbyBmbXQgLT4gbWF0Y2ggZm10IHdpdGhcbiAgICB8IENoYXIgcmVzdCAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQ2FtbF9jaGFyIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFN0cmluZyAoTm9fcGFkZGluZywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFN0cmluZyAoTGl0X3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFN0cmluZyAoQXJnX3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpKVxuICAgIHwgQ2FtbF9zdHJpbmcgKE5vX3BhZGRpbmcsIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBDYW1sX3N0cmluZyAoTGl0X3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IENhbWxfc3RyaW5nIChBcmdfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdCkpXG4gICAgfCBJbnQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IEludDMyIChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIGsgbyByZXN0IHBhZCBwcmVjXG4gICAgfCBOYXRpdmVpbnQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IEludDY0IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIGsgbyByZXN0IHBhZCBwcmVjXG4gICAgfCBGbG9hdCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gcmVzdCBwYWQgcHJlY1xuICAgIHwgQm9vbCAoTm9fcGFkZGluZywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IEJvb2wgKExpdF9wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBCb29sIChBcmdfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdCkpXG4gICAgfCBBbHBoYSByZXN0IC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KSlcbiAgICB8IFRoZXRhIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IEN1c3RvbSAoYXJpdHksIF8sIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX2N1c3RvbV9hcml0eSBrIG8gcmVzdCBhcml0eVxuICAgIHwgUmVhZGVyIF8gLT5cbiAgICAgICAgKCogVGhpcyBjYXNlIGlzIGltcG9zc2libGUsIGJ5IHR5cGluZyBvZiBmb3JtYXRzLiAgU2VlIHRoZVxuICAgICAgICAgICBub3RlIGluIHRoZSBjb3JyZXNwb25kaW5nIGNhc2UgZm9yIG1ha2VfcHJpbnRmLiAqKVxuICAgICAgICBhc3NlcnQgZmFsc2VcbiAgICB8IEZsdXNoIHJlc3QgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyByZXN0XG4gICAgfCBTdHJpbmdfbGl0ZXJhbCAoXywgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyByZXN0XG4gICAgfCBDaGFyX2xpdGVyYWwgKF8sIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiBrIG8gcmVzdFxuICAgIHwgRm9ybWF0X2FyZyAoXywgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IEZvcm1hdF9zdWJzdCAoXywgZm10dHksIHJlc3QpIC0+XG4gICAgICAgIGZ1biAoRm9ybWF0IChmbXQsIF8pKSAtPlxuICAgICAgICAgIG1ha2VfaXByaW50ZiBrIG9cbiAgICAgICAgICAgIChjb25jYXRfZm10IChyZWNhc3QgZm10IGZtdHR5KSByZXN0KVxuICAgIHwgU2Nhbl9jaGFyX3NldCAoXywgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFNjYW5fZ2V0X2NvdW50ZXIgKF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBTY2FuX25leHRfY2hhciByZXN0IC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaWdub3JlZF9wYXJhbSAoZnVuIHggXyAtPiBrIHgpIG8gKEVuZF9vZl9hY2MpIGlnbiByZXN0XG4gICAgfCBGb3JtYXR0aW5nX2xpdCAoXywgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyByZXN0XG4gICAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lwcmludGYgKGZ1biBrb2MgLT4gbWFrZV9pcHJpbnRmIGsga29jIHJlc3QpIG8gZm10J1xuICAgIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIChmdW4ga29jIC0+IG1ha2VfaXByaW50ZiBrIGtvYyByZXN0KSBvIGZtdCdcbiAgICB8IEVuZF9vZl9mb3JtYXQgLT5cbiAgICAgICAgayBvXG5hbmQgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gOlxuICB0eXBlIHggeSB6IGEgYiBjIGQgZSBmLlxuICAoYiAtPiBmKSAtPiBiIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgKHgsIHkpIHBhZGRpbmcgLT4gKHksIHogLT4gYSkgcHJlY2lzaW9uIC0+IHggPVxuICBmdW4gayBvIGZtdCBwYWQgcHJlYyAtPiBtYXRjaCBwYWQsIHByZWMgd2l0aFxuICAgIHwgTm9fcGFkZGluZyAgICwgTm9fcHJlY2lzaW9uICAgIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdClcbiAgICB8IE5vX3BhZGRpbmcgICAsIExpdF9wcmVjaXNpb24gXyAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpXG4gICAgfCBOb19wYWRkaW5nICAgLCBBcmdfcHJlY2lzaW9uICAgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdCkpXG4gICAgfCBMaXRfcGFkZGluZyBfLCBOb19wcmVjaXNpb24gICAgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KVxuICAgIHwgTGl0X3BhZGRpbmcgXywgTGl0X3ByZWNpc2lvbiBfIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdClcbiAgICB8IExpdF9wYWRkaW5nIF8sIEFyZ19wcmVjaXNpb24gICAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSlcbiAgICB8IEFyZ19wYWRkaW5nIF8sIE5vX3ByZWNpc2lvbiAgICAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSlcbiAgICB8IEFyZ19wYWRkaW5nIF8sIExpdF9wcmVjaXNpb24gXyAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSlcbiAgICB8IEFyZ19wYWRkaW5nIF8sIEFyZ19wcmVjaXNpb24gICAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdCkpKVxuYW5kIGZuX29mX2N1c3RvbV9hcml0eSA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgKGIgLT4gZikgLT4gYiAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IChhLCB4LCB5KSBjdXN0b21fYXJpdHkgLT4geSA9XG4gIGZ1biBrIG8gZm10IC0+IGZ1bmN0aW9uXG4gICAgfCBDdXN0b21femVybyAtPlxuICAgICAgICBtYWtlX2lwcmludGYgayBvIGZtdFxuICAgIHwgQ3VzdG9tX3N1Y2MgYXJpdHkgLT5cbiAgICAgICAgY29uc3QgKGZuX29mX2N1c3RvbV9hcml0eSBrIG8gZm10IGFyaXR5KVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBDb250aW51YXRpb25zIGZvciBtYWtlX3ByaW50ZiAqKVxuXG4oKiBSZWN1cnNpdmVseSBvdXRwdXQgYW4gXCJhY2N1bXVsYXRvclwiIGNvbnRhaW5pbmcgYSByZXZlcnNlZCBsaXN0IG9mXG4gICBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzLCAuLi4pIGluIGFuIG91dHB1dF9zdHJlYW0uICopXG4oKiBVc2VkIGFzIGEgY29udGludWF0aW9uIG9mIG1ha2VfcHJpbnRmLiAqKVxubGV0IHJlYyBvdXRwdXRfYWNjIG8gYWNjID0gbWF0Y2ggYWNjIHdpdGhcbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgKHAsIGZtdGluZ19saXQpIC0+XG4gICAgbGV0IHMgPSBzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfc3RyaW5nIG8gcztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX3RhZyBhY2MnKSAtPlxuICAgIG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfc3RyaW5nIG8gXCJAe1wiOyBvdXRwdXRfYWNjIG8gYWNjJztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX2JveCBhY2MnKSAtPlxuICAgIG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfc3RyaW5nIG8gXCJAW1wiOyBvdXRwdXRfYWNjIG8gYWNjJztcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKHAsIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChwLCBzKSAgIC0+IG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfc3RyaW5nIG8gc1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfY2hhciBvIGNcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gb3V0cHV0X2FjYyBvIHA7IGYgb1xuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBvdXRwdXRfYWNjIG8gcDsgZmx1c2ggb1xuICB8IEFjY19pbnZhbGlkX2FyZyAocCwgbXNnKSAtPiBvdXRwdXRfYWNjIG8gcDsgaW52YWxpZF9hcmcgbXNnO1xuICB8IEVuZF9vZl9hY2MgICAgICAgICAgICAgICAtPiAoKVxuXG4oKiBSZWN1cnNpdmVseSBvdXRwdXQgYW4gXCJhY2N1bXVsYXRvclwiIGNvbnRhaW5pbmcgYSByZXZlcnNlZCBsaXN0IG9mXG4gICBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzLCAuLi4pIGluIGEgYnVmZmVyLiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBtYWtlX3ByaW50Zi4gKilcbmxldCByZWMgYnVmcHV0X2FjYyBiIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmbXRpbmdfbGl0KSAtPlxuICAgIGxldCBzID0gc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQgaW5cbiAgICBidWZwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBzO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgXCJAe1wiOyBidWZwdXRfYWNjIGIgYWNjJztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX2JveCBhY2MnKSAtPlxuICAgIGJ1ZnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIFwiQFtcIjsgYnVmcHV0X2FjYyBiIGFjYyc7XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBidWZwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBzXG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAocCwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChwLCBjKSAgICAgLT4gYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfY2hhciBiIGNcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gYnVmcHV0X2FjYyBiIHA7IGYgYlxuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBidWZwdXRfYWNjIGIgcDtcbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gYnVmcHV0X2FjYyBiIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhIGJ1ZmZlci4gKilcbigqIERpZmZlciBmcm9tIGJ1ZnB1dF9hY2MgYnkgdGhlIGludGVycHJldGF0aW9uIG9mICVhIGFuZCAldC4gKilcbigqIFVzZWQgYXMgYSBjb250aW51YXRpb24gb2YgbWFrZV9wcmludGYuICopXG5sZXQgcmVjIHN0cnB1dF9hY2MgYiBhY2MgPSBtYXRjaCBhY2Mgd2l0aFxuICB8IEFjY19mb3JtYXR0aW5nX2xpdCAocCwgZm10aW5nX2xpdCkgLT5cbiAgICBsZXQgcyA9IHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgcztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX3RhZyBhY2MnKSAtPlxuICAgIHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIFwiQHtcIjsgc3RycHV0X2FjYyBiIGFjYyc7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBcIkBbXCI7IHN0cnB1dF9hY2MgYiBhY2MnO1xuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgc1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX2NoYXIgYiBjXG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIChmICgpKVxuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBzdHJwdXRfYWNjIGIgcDtcbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gc3RycHV0X2FjYyBiIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRXJyb3IgbWFuYWdlbWVudCAqKVxuXG4oKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhIHByZXR0eS1wcmludGVkIGVycm9yIG1lc3NhZ2UuICopXG5sZXQgZmFpbHdpdGhfbWVzc2FnZSAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIDI1NiBpblxuICBsZXQgayAoKSBhY2MgPSBzdHJwdXRfYWNjIGJ1ZiBhY2M7IGZhaWx3aXRoIChCdWZmZXIuY29udGVudHMgYnVmKSBpblxuICBtYWtlX3ByaW50ZiBrICgpIEVuZF9vZl9hY2MgZm10XG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0dGluZyB0b29scyAqKVxuXG4oKiBDb252ZXJ0IGEgc3RyaW5nIHRvIGFuIG9wZW4gYmxvY2sgZGVzY3JpcHRpb24gKGluZGVudCwgYmxvY2tfdHlwZSkgKilcbmxldCBvcGVuX2JveF9vZl9zdHJpbmcgc3RyID1cbiAgaWYgc3RyID0gXCJcIiB0aGVuICgwLCBQcF9ib3gpIGVsc2VcbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgICBsZXQgaW52YWxpZF9ib3ggKCkgPSBmYWlsd2l0aF9tZXNzYWdlIFwiaW52YWxpZCBib3ggZGVzY3JpcHRpb24gJVNcIiBzdHIgaW5cbiAgICBsZXQgcmVjIHBhcnNlX3NwYWNlcyBpID1cbiAgICAgIGlmIGkgPSBsZW4gdGhlbiBpIGVsc2VcbiAgICAgICAgbWF0Y2ggc3RyLltpXSB3aXRoXG4gICAgICAgIHwgJyAnIHwgJ1xcdCcgLT4gcGFyc2Vfc3BhY2VzIChpICsgMSlcbiAgICAgICAgfCBfIC0+IGlcbiAgICBhbmQgcGFyc2VfbHdvcmQgaSBqID1cbiAgICAgIGlmIGogPSBsZW4gdGhlbiBqIGVsc2VcbiAgICAgICAgbWF0Y2ggc3RyLltqXSB3aXRoXG4gICAgICAgIHwgJ2EnIC4uICd6JyAtPiBwYXJzZV9sd29yZCBpIChqICsgMSlcbiAgICAgICAgfCBfIC0+IGpcbiAgICBhbmQgcGFyc2VfaW50IGkgaiA9XG4gICAgICBpZiBqID0gbGVuIHRoZW4gaiBlbHNlXG4gICAgICAgIG1hdGNoIHN0ci5bal0gd2l0aFxuICAgICAgICB8ICcwJyAuLiAnOScgfCAnLScgLT4gcGFyc2VfaW50IGkgKGogKyAxKVxuICAgICAgICB8IF8gLT4gaiBpblxuICAgIGxldCB3c3RhcnQgPSBwYXJzZV9zcGFjZXMgMCBpblxuICAgIGxldCB3ZW5kID0gcGFyc2VfbHdvcmQgd3N0YXJ0IHdzdGFydCBpblxuICAgIGxldCBib3hfbmFtZSA9IFN0cmluZy5zdWIgc3RyIHdzdGFydCAod2VuZCAtIHdzdGFydCkgaW5cbiAgICBsZXQgbnN0YXJ0ID0gcGFyc2Vfc3BhY2VzIHdlbmQgaW5cbiAgICBsZXQgbmVuZCA9IHBhcnNlX2ludCBuc3RhcnQgbnN0YXJ0IGluXG4gICAgbGV0IGluZGVudCA9XG4gICAgICBpZiBuc3RhcnQgPSBuZW5kIHRoZW4gMCBlbHNlXG4gICAgICAgIHRyeSBpbnRfb2Zfc3RyaW5nIChTdHJpbmcuc3ViIHN0ciBuc3RhcnQgKG5lbmQgLSBuc3RhcnQpKVxuICAgICAgICB3aXRoIEZhaWx1cmUgXyAtPiBpbnZhbGlkX2JveCAoKSBpblxuICAgIGxldCBleHBfZW5kID0gcGFyc2Vfc3BhY2VzIG5lbmQgaW5cbiAgICBpZiBleHBfZW5kIDw+IGxlbiB0aGVuIGludmFsaWRfYm94ICgpO1xuICAgIGxldCBib3hfdHlwZSA9IG1hdGNoIGJveF9uYW1lIHdpdGhcbiAgICAgIHwgXCJcIiB8IFwiYlwiIC0+IFBwX2JveFxuICAgICAgfCBcImhcIiAgICAgIC0+IFBwX2hib3hcbiAgICAgIHwgXCJ2XCIgICAgICAtPiBQcF92Ym94XG4gICAgICB8IFwiaHZcIiAgICAgLT4gUHBfaHZib3hcbiAgICAgIHwgXCJob3ZcIiAgICAtPiBQcF9ob3Zib3hcbiAgICAgIHwgXyAgICAgICAgLT4gaW52YWxpZF9ib3ggKCkgaW5cbiAgICAoaW5kZW50LCBib3hfdHlwZSlcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBQYXJzaW5nIHRvb2xzICopXG5cbigqIENyZWF0ZSBhIHBhZGRpbmdfZm10X2ViYiBmcm9tIGEgcGFkZGluZyBhbmQgYSBmb3JtYXQuICopXG4oKiBDb3B5IHRoZSBwYWRkaW5nIHRvIGRpc2pvaW4gdGhlIHR5cGUgcGFyYW1ldGVycyBvZiBhcmd1bWVudCBhbmQgcmVzdWx0LiAqKVxubGV0IG1ha2VfcGFkZGluZ19mbXRfZWJiIDogdHlwZSB4IHkgLlxuICAgICh4LCB5KSBwYWRkaW5nIC0+IChfLCBfLCBfLCBfLCBfLCBfKSBmbXQgLT5cbiAgICAgIChfLCBfLCBfLCBfLCBfKSBwYWRkaW5nX2ZtdF9lYmIgPVxuZnVuIHBhZCBmbXQgLT4gbWF0Y2ggcGFkIHdpdGhcbiAgfCBOb19wYWRkaW5nICAgICAgICAgLT4gUGFkZGluZ19mbXRfRUJCIChOb19wYWRkaW5nLCBmbXQpXG4gIHwgTGl0X3BhZGRpbmcgKHMsIHcpIC0+IFBhZGRpbmdfZm10X0VCQiAoTGl0X3BhZGRpbmcgKHMsIHcpLCBmbXQpXG4gIHwgQXJnX3BhZGRpbmcgcyAgICAgIC0+IFBhZGRpbmdfZm10X0VCQiAoQXJnX3BhZGRpbmcgcywgZm10KVxuXG4oKiBDcmVhdGUgYSBwcmVjaXNpb25fZm10X2ViYiBmcm9tIGEgcHJlY2lzaW9uIGFuZCBhIGZvcm1hdC4gKilcbigqIENvcHkgdGhlIHByZWNpc2lvbiB0byBkaXNqb2luIHRoZSB0eXBlIHBhcmFtZXRlcnMgb2YgYXJndW1lbnQgYW5kIHJlc3VsdC4gKilcbmxldCBtYWtlX3ByZWNpc2lvbl9mbXRfZWJiIDogdHlwZSB4IHkgLlxuICAgICh4LCB5KSBwcmVjaXNpb24gLT4gKF8sIF8sIF8sIF8sIF8sIF8pIGZtdCAtPlxuICAgICAgKF8sIF8sIF8sIF8sIF8pIHByZWNpc2lvbl9mbXRfZWJiID1cbmZ1biBwcmVjIGZtdCAtPiBtYXRjaCBwcmVjIHdpdGhcbiAgfCBOb19wcmVjaXNpb24gICAgLT4gUHJlY2lzaW9uX2ZtdF9FQkIgKE5vX3ByZWNpc2lvbiwgZm10KVxuICB8IExpdF9wcmVjaXNpb24gcCAtPiBQcmVjaXNpb25fZm10X0VCQiAoTGl0X3ByZWNpc2lvbiBwLCBmbXQpXG4gIHwgQXJnX3ByZWNpc2lvbiAgIC0+IFByZWNpc2lvbl9mbXRfRUJCIChBcmdfcHJlY2lzaW9uLCBmbXQpXG5cbigqIENyZWF0ZSBhIHBhZHByZWNfZm10X2ViYiBmcm9tIGEgcGFkZGluZywgYSBwcmVjaXNpb24gYW5kIGEgZm9ybWF0LiAqKVxuKCogQ29weSB0aGUgcGFkZGluZyBhbmQgdGhlIHByZWNpc2lvbiB0byBkaXNqb2luIHR5cGUgcGFyYW1ldGVycyBvZiBhcmd1bWVudHNcbiAgIGFuZCByZXN1bHQuICopXG5sZXQgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgOiB0eXBlIHggeSB6IHQgLlxuICAgICh4LCB5KSBwYWRkaW5nIC0+ICh6LCB0KSBwcmVjaXNpb24gLT5cbiAgICAoXywgXywgXywgXywgXywgXykgZm10IC0+XG4gICAgKF8sIF8sIF8sIF8sIF8pIHBhZHByZWNfZm10X2ViYiA9XG5mdW4gcGFkIHByZWMgZm10IC0+XG4gIGxldCBQcmVjaXNpb25fZm10X0VCQiAocHJlYywgZm10JykgPSBtYWtlX3ByZWNpc2lvbl9mbXRfZWJiIHByZWMgZm10IGluXG4gIG1hdGNoIHBhZCB3aXRoXG4gIHwgTm9fcGFkZGluZyAgICAgICAgIC0+IFBhZHByZWNfZm10X0VCQiAoTm9fcGFkZGluZywgcHJlYywgZm10JylcbiAgfCBMaXRfcGFkZGluZyAocywgdykgLT4gUGFkcHJlY19mbXRfRUJCIChMaXRfcGFkZGluZyAocywgdyksIHByZWMsIGZtdCcpXG4gIHwgQXJnX3BhZGRpbmcgcyAgICAgIC0+IFBhZHByZWNfZm10X0VCQiAoQXJnX3BhZGRpbmcgcywgcHJlYywgZm10JylcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IHBhcnNpbmcgKilcblxuKCogUGFyc2UgYSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZm9ybWF0IGFuZCBjcmVhdGUgYSBmbXRfZWJiLiAqKVxuKCogUmFpc2UgW0ZhaWx1cmVdIGluIGNhc2Ugb2YgaW52YWxpZCBmb3JtYXQuICopXG5sZXQgZm10X2ViYl9vZl9zdHJpbmcgP2xlZ2FjeV9iZWhhdmlvciBzdHIgPVxuICAoKiBQYXJhbWV0ZXJzIG5hbWluZyBjb252ZW50aW9uOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBsaXRfc3RhcnQ6IHN0YXJ0IG9mIHRoZSBsaXRlcmFsIHNlcXVlbmNlLiAgICAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIHN0cl9pbmQ6IGN1cnJlbnQgaW5kZXggaW4gdGhlIHN0cmluZy4gICAgICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gZW5kX2luZDogZW5kIG9mIHRoZSBjdXJyZW50IChzdWItKWZvcm1hdC4gICAgICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBwY3RfaW5kOiBpbmRleCBvZiB0aGUgJyUnIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICAgICAgKilcbiAgKCogICAtIHplcm86ICBpcyB0aGUgJzAnIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gbWludXM6IGlzIHRoZSAnLScgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBwbHVzOiAgaXMgdGhlICcrJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIGhhc2g6ICBpcyB0aGUgJyMnIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gc3BhY2U6IGlzIHRoZSAnICcgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBpZ246ICAgaXMgdGhlICdfJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIHBhZDogcGFkZGluZyBvZiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gcHJlYzogcHJlY2lzaW9uIG9mIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBzeW1iOiBjaGFyIHJlcHJlc2VudGluZyB0aGUgY29udmVyc2lvbiAoJ2MnLCAncycsICdkJywgLi4uKS4gKilcbiAgKCogICAtIGNoYXJfc2V0OiBzZXQgb2YgY2hhcmFjdGVycyBhcyBiaXRtYXAgKHNlZSBzY2FuZiAlWy4uLl0pLiAgICAqKVxuXG4gIGxldCBsZWdhY3lfYmVoYXZpb3IgPSBtYXRjaCBsZWdhY3lfYmVoYXZpb3Igd2l0aFxuICAgIHwgU29tZSBmbGFnIC0+IGZsYWdcbiAgICB8IE5vbmUgLT4gdHJ1ZVxuICAoKiAgV2hlbiB0aGlzIGZsYWcgaXMgZW5hYmxlZCwgdGhlIGZvcm1hdCBwYXJzZXIgdHJpZXMgdG8gYmVoYXZlIGFzXG4gICAgICB0aGUgPDQuMDIgaW1wbGVtZW50YXRpb25zLCBpbiBwYXJ0aWN1bGFyIGl0IGlnbm9yZXMgbW9zdCBiZW5pbmVcbiAgICAgIG5vbnNlbnNpY2FsIGZvcm1hdC4gV2hlbiB0aGUgZmxhZyBpcyBkaXNhYmxlZCwgaXQgd2lsbCByZWplY3QgYW55XG4gICAgICBmb3JtYXQgdGhhdCBpcyBub3QgYWNjZXB0ZWQgYnkgdGhlIHNwZWNpZmljYXRpb24uXG5cbiAgICAgIEEgdHlwaWNhbCBleGFtcGxlIHdvdWxkIGJlIFwiJSsgZFwiOiBzcGVjaWZ5aW5nIGJvdGggJysnIChpZiB0aGVcbiAgICAgIG51bWJlciBpcyBwb3NpdGl2ZSwgcGFkIHdpdGggYSAnKycgdG8gZ2V0IHRoZSBzYW1lIHdpZHRoIGFzXG4gICAgICBuZWdhdGl2ZSBudW1iZXJzKSBhbmQgJyAnIChpZiB0aGUgbnVtYmVyIGlzIHBvc2l0aXZlLCBwYWQgd2l0aFxuICAgICAgYSBzcGFjZSkgZG9lcyBub3QgbWFrZSBzZW5zZSwgYnV0IHRoZSBsZWdhY3kgKDwgNC4wMilcbiAgICAgIGltcGxlbWVudGF0aW9uIHdhcyBoYXBweSB0byBqdXN0IGlnbm9yZSB0aGUgc3BhY2UuXG4gICopXG4gIGluXG5cbiAgKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBmcmllbmRseSBlcnJvciBtZXNzYWdlLiAqKVxuICBsZXQgaW52YWxpZF9mb3JtYXRfbWVzc2FnZSBzdHJfaW5kIG1zZyA9XG4gICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgJXNcIlxuICAgICAgc3RyIHN0cl9pbmQgbXNnXG4gIGluXG5cbiAgKCogVXNlZCB3aGVuIHRoZSBlbmQgb2YgdGhlIGZvcm1hdCAob3IgdGhlIGN1cnJlbnQgc3ViLWZvcm1hdCkgd2FzIGVuY291bnRlcmVkXG4gICAgICB1bmV4cGVjdGVkbHkuICopXG4gIGxldCB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZCA9XG4gICAgaW52YWxpZF9mb3JtYXRfbWVzc2FnZSBlbmRfaW5kXG4gICAgICBcInVuZXhwZWN0ZWQgZW5kIG9mIGZvcm1hdFwiXG4gIGluXG5cbiAgKCogVXNlZCBmb3IgJTBjOiBubyBvdGhlciB3aWR0aHMgYXJlIGltcGxlbWVudGVkICopXG4gIGxldCBpbnZhbGlkX25vbm51bGxfY2hhcl93aWR0aCBzdHJfaW5kID1cbiAgICBpbnZhbGlkX2Zvcm1hdF9tZXNzYWdlIHN0cl9pbmRcbiAgICAgIFwibm9uLXplcm8gd2lkdGhzIGFyZSB1bnN1cHBvcnRlZCBmb3IgJWMgY29udmVyc2lvbnNcIlxuICBpblxuICAoKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhIGZyaWVuZGx5IGVycm9yIG1lc3NhZ2UgYWJvdXQgYW4gb3B0aW9uIGRlcGVuZGVuY3lcbiAgICAgcHJvYmxlbS4gKilcbiAgbGV0IGludmFsaWRfZm9ybWF0X3dpdGhvdXQgc3RyX2luZCBjIHMgPVxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsICclYycgd2l0aG91dCAlc1wiXG4gICAgICBzdHIgc3RyX2luZCBjIHNcbiAgaW5cblxuICAoKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhIGZyaWVuZGx5IGVycm9yIG1lc3NhZ2UgYWJvdXQgYW4gdW5leHBlY3RlZFxuICAgICBjaGFyYWN0ZXIuICopXG4gIGxldCBleHBlY3RlZF9jaGFyYWN0ZXIgc3RyX2luZCBleHBlY3RlZCByZWFkID1cbiAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsICVzIGV4cGVjdGVkLCByZWFkICVDXCJcbiAgICAgIHN0ciBzdHJfaW5kIGV4cGVjdGVkIHJlYWRcbiAgaW5cblxuICAoKiBQYXJzZSB0aGUgc3RyaW5nIGZyb20gYmVnX2luZCAoaW5jbHVkZWQpIHRvIGVuZF9pbmQgKGV4Y2x1ZGVkKS4gKilcbiAgbGV0IHJlYyBwYXJzZSA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBiZWdfaW5kIGVuZF9pbmQgLT4gcGFyc2VfbGl0ZXJhbCBiZWdfaW5kIGJlZ19pbmQgZW5kX2luZFxuXG4gICgqIFJlYWQgbGl0ZXJhbCBjaGFyYWN0ZXJzIHVwIHRvICclJyBvciAnQCcgc3BlY2lhbCBjaGFyYWN0ZXJzLiAqKVxuICBhbmQgcGFyc2VfbGl0ZXJhbCA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gbGl0X3N0YXJ0IHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gYWRkX2xpdGVyYWwgbGl0X3N0YXJ0IHN0cl9pbmQgRW5kX29mX2Zvcm1hdCBlbHNlXG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJyUnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2VfZm9ybWF0IHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgICBhZGRfbGl0ZXJhbCBsaXRfc3RhcnQgc3RyX2luZCBmbXRfcmVzdFxuICAgICAgfCAnQCcgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZV9hZnRlcl9hdCAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgYWRkX2xpdGVyYWwgbGl0X3N0YXJ0IHN0cl9pbmQgZm10X3Jlc3RcbiAgICAgIHwgXyAtPlxuICAgICAgICBwYXJzZV9saXRlcmFsIGxpdF9zdGFydCAoc3RyX2luZCArIDEpIGVuZF9pbmRcblxuICAoKiBQYXJzZSBhIGZvcm1hdCBhZnRlciAnJScgKilcbiAgYW5kIHBhcnNlX2Zvcm1hdCA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIGVuZF9pbmQgLT4gcGFyc2VfaWduIHBjdF9pbmQgKHBjdF9pbmQgKyAxKSBlbmRfaW5kXG5cbiAgYW5kIHBhcnNlX2lnbiA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnXycgLT4gcGFyc2VfZmxhZ3MgcGN0X2luZCAoc3RyX2luZCsxKSBlbmRfaW5kIHRydWVcbiAgICAgIHwgXyAtPiBwYXJzZV9mbGFncyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBmYWxzZVxuXG4gIGFuZCBwYXJzZV9mbGFncyA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiAoXywgXywgZSwgZikgZm10X2ViYlxuICA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBpZ24gLT5cbiAgICBsZXQgemVybyA9IHJlZiBmYWxzZSBhbmQgbWludXMgPSByZWYgZmFsc2VcbiAgICBhbmQgcGx1cyA9IHJlZiBmYWxzZSBhbmQgc3BhY2UgPSByZWYgZmFsc2VcbiAgICBhbmQgaGFzaCA9IHJlZiBmYWxzZSBpblxuICAgIGxldCBzZXRfZmxhZyBzdHJfaW5kIGZsYWcgPVxuICAgICAgKCogaW4gbGVnYWN5IG1vZGUsIGR1cGxpY2F0ZSBmbGFncyBhcmUgYWNjZXB0ZWQgKilcbiAgICAgIGlmICFmbGFnICYmIG5vdCBsZWdhY3lfYmVoYXZpb3IgdGhlblxuICAgICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgZHVwbGljYXRlIGZsYWcgJUNcIlxuICAgICAgICAgIHN0ciBzdHJfaW5kIHN0ci5bc3RyX2luZF07XG4gICAgICBmbGFnIDo9IHRydWU7XG4gICAgaW5cbiAgICBsZXQgcmVjIHJlYWRfZmxhZ3Mgc3RyX2luZCA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgYmVnaW4gbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICcwJyAtPiBzZXRfZmxhZyBzdHJfaW5kIHplcm87ICByZWFkX2ZsYWdzIChzdHJfaW5kICsgMSlcbiAgICAgIHwgJy0nIC0+IHNldF9mbGFnIHN0cl9pbmQgbWludXM7IHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCAnKycgLT4gc2V0X2ZsYWcgc3RyX2luZCBwbHVzOyAgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8ICcjJyAtPiBzZXRfZmxhZyBzdHJfaW5kIGhhc2g7IHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCAnICcgLT4gc2V0X2ZsYWcgc3RyX2luZCBzcGFjZTsgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8IF8gLT5cbiAgICAgICAgcGFyc2VfcGFkZGluZyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZFxuICAgICAgICAgICF6ZXJvICFtaW51cyAhcGx1cyAhaGFzaCAhc3BhY2UgaWduXG4gICAgICBlbmRcbiAgICBpblxuICAgIHJlYWRfZmxhZ3Mgc3RyX2luZFxuXG4gICgqIFRyeSB0byByZWFkIGEgZGlnaXRhbCBvciBhICcqJyBwYWRkaW5nLiAqKVxuICBhbmQgcGFyc2VfcGFkZGluZyA6IHR5cGUgZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+XG4gICAgICAgIChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIHplcm8gbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnbiAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbGV0IHBhZHR5ID0gbWF0Y2ggemVybywgbWludXMgd2l0aFxuICAgICAgfCBmYWxzZSwgZmFsc2UgLT4gUmlnaHRcbiAgICAgIHwgZmFsc2UsIHRydWUgIC0+IExlZnRcbiAgICAgIHwgIHRydWUsIGZhbHNlIC0+IFplcm9zXG4gICAgICB8ICB0cnVlLCB0cnVlICAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBMZWZ0XG4gICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICctJyBcIjBcIiBpblxuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJzAnIC4uICc5JyAtPlxuICAgICAgbGV0IG5ld19pbmQsIHdpZHRoID0gcGFyc2VfcG9zaXRpdmUgc3RyX2luZCBlbmRfaW5kIDAgaW5cbiAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCBuZXdfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAoTGl0X3BhZGRpbmcgKHBhZHR5LCB3aWR0aCkpXG4gICAgfCAnKicgLT5cbiAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlXG4gICAgICAgIGlnbiAoQXJnX3BhZGRpbmcgcGFkdHkpXG4gICAgfCBfIC0+XG4gICAgICBiZWdpbiBtYXRjaCBwYWR0eSB3aXRoXG4gICAgICB8IExlZnQgIC0+XG4gICAgICAgIGlmIG5vdCBsZWdhY3lfYmVoYXZpb3IgdGhlblxuICAgICAgICAgIGludmFsaWRfZm9ybWF0X3dpdGhvdXQgKHN0cl9pbmQgLSAxKSAnLScgXCJwYWRkaW5nXCI7XG4gICAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAgIE5vX3BhZGRpbmdcbiAgICAgIHwgWmVyb3MgLT5cbiAgICAgICAgICgqIGEgJzAnIHBhZGRpbmcgaW5kaWNhdGlvbiBub3QgZm9sbG93ZWQgYnkgYW55dGhpbmcgc2hvdWxkXG4gICAgICAgICAgIGJlIGludGVycHJldGVkIGFzIGEgUmlnaHQgcGFkZGluZyBvZiB3aWR0aCAwLiBUaGlzIGlzIHVzZWRcbiAgICAgICAgICAgYnkgc2Nhbm5pbmcgY29udmVyc2lvbnMgJTBzIGFuZCAlMGMgKilcbiAgICAgICAgcGFyc2VfYWZ0ZXJfcGFkZGluZyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgICAgKExpdF9wYWRkaW5nIChSaWdodCwgMCkpXG4gICAgICB8IFJpZ2h0IC0+XG4gICAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAgIE5vX3BhZGRpbmdcbiAgICAgIGVuZFxuXG4gICgqIElzIHByZWNpc2lvbiBkZWZpbmVkPyAqKVxuICBhbmQgcGFyc2VfYWZ0ZXJfcGFkZGluZyA6IHR5cGUgeCBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+XG4gICAgICAgICh4LCBfKSBwYWRkaW5nIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICB8ICcuJyAtPlxuICAgICAgcGFyc2VfcHJlY2lzaW9uIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgcGFkXG4gICAgfCBzeW1iIC0+XG4gICAgICBwYXJzZV9jb252ZXJzaW9uIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkXG4gICAgICAgIE5vX3ByZWNpc2lvbiBwYWQgc3ltYlxuXG4gICgqIFJlYWQgdGhlIGRpZ2l0YWwgb3IgJyonIHByZWNpc2lvbi4gKilcbiAgYW5kIHBhcnNlX3ByZWNpc2lvbiA6IHR5cGUgeCBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+XG4gICAgICAgICh4LCBfKSBwYWRkaW5nIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBsZXQgcGFyc2VfbGl0ZXJhbCBtaW51cyBzdHJfaW5kID1cbiAgICAgIGxldCBuZXdfaW5kLCBwcmVjID0gcGFyc2VfcG9zaXRpdmUgc3RyX2luZCBlbmRfaW5kIDAgaW5cbiAgICAgIHBhcnNlX2FmdGVyX3ByZWNpc2lvbiBwY3RfaW5kIG5ld19pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgIHBhZCAoTGl0X3ByZWNpc2lvbiBwcmVjKSBpblxuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJzAnIC4uICc5JyAtPiBwYXJzZV9saXRlcmFsIG1pbnVzIHN0cl9pbmRcbiAgICB8ICgnKycgfCAnLScpIGFzIHN5bWIgd2hlbiBsZWdhY3lfYmVoYXZpb3IgLT5cbiAgICAgICgqIExlZ2FjeSBtb2RlIHdvdWxkIGFjY2VwdCBhbmQgaWdub3JlICcrJyBvciAnLScgYmVmb3JlIHRoZVxuICAgICAgICAgaW50ZWdlciBkZXNjcmliaW5nIHRoZSBkZXNpcmVkIHByZWNpc2lvbjsgbm90ZSB0aGF0IHRoaXNcbiAgICAgICAgIGNhbm5vdCBoYXBwZW4gZm9yIHBhZGRpbmcgd2lkdGgsIGFzICcrJyBhbmQgJy0nIGFscmVhZHkgaGF2ZVxuICAgICAgICAgYSBzZW1hbnRpY3MgdGhlcmUuXG5cbiAgICAgICAgIFRoYXQgc2FpZCwgdGhlIGlkZWEgKHN1cHBvcnRlZCBieSB0aGlzIHR3ZWFrKSB0aGF0IHdpZHRoIGFuZFxuICAgICAgICAgcHJlY2lzaW9uIGxpdGVyYWxzIGFyZSBcImludGVnZXIgbGl0ZXJhbHNcIiBpbiB0aGUgT0NhbWwgc2Vuc2UgaXNcbiAgICAgICAgIHN0aWxsIGJsYXRhbnRseSB3cm9uZywgYXMgMTIzXzQ1NiBvciAweEZGIGFyZSByZWplY3RlZC4gKilcbiAgICAgIHBhcnNlX2xpdGVyYWwgKG1pbnVzIHx8IHN5bWIgPSAnLScpIChzdHJfaW5kICsgMSlcbiAgICB8ICcqJyAtPlxuICAgICAgcGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZVxuICAgICAgICBpZ24gcGFkIEFyZ19wcmVjaXNpb25cbiAgICB8IF8gLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuXG4gICAgICAgICgqIG5vdGUgdGhhdCBsZWdhY3kgaW1wbGVtZW50YXRpb24gZGlkIG5vdCBpZ25vcmUgJy4nIHdpdGhvdXRcbiAgICAgICAgICAgYSBudW1iZXIgKGFzIGl0IGRvZXMgZm9yIHBhZGRpbmcgaW5kaWNhdGlvbnMpLCBidXRcbiAgICAgICAgICAgaW50ZXJwcmV0cyBpdCBhcyAnLjAnICopXG4gICAgICAgIHBhcnNlX2FmdGVyX3ByZWNpc2lvbiBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgICAgcGFkIChMaXRfcHJlY2lzaW9uIDApXG4gICAgICBlbHNlXG4gICAgICAgIGludmFsaWRfZm9ybWF0X3dpdGhvdXQgKHN0cl9pbmQgLSAxKSAnLicgXCJwcmVjaXNpb25cIlxuXG4gICgqIFRyeSB0byByZWFkIHRoZSBjb252ZXJzaW9uLiAqKVxuICBhbmQgcGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIDogdHlwZSB4IHkgeiB0IGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT5cbiAgICAgICAgKHgsIHkpIHBhZGRpbmcgLT4gKHosIHQpIHByZWNpc2lvbiAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZCBwcmVjIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBsZXQgcGFyc2VfY29udiAodHlwZSB1KSAodHlwZSB2KSAocGFkcHJlYyA6ICh1LCB2KSBwYWRkaW5nKSA9XG4gICAgICBwYXJzZV9jb252ZXJzaW9uIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkXG4gICAgICAgIHByZWMgcGFkcHJlYyBzdHIuW3N0cl9pbmRdIGluXG4gICAgKCogaW4gbGVnYWN5IG1vZGUsIHNvbWUgZm9ybWF0cyAoJXMgYW5kICVTKSBhY2NlcHQgYSB3ZWlyZCBtaXggb2ZcbiAgICAgICBwYWRkaW5nIGFuZCBwcmVjaXNpb24sIHdoaWNoIGlzIG1lcmdlZCBhcyBhIHNpbmdsZSBwYWRkaW5nXG4gICAgICAgaW5mb3JtYXRpb24uIEZvciBleGFtcGxlLCBpbiAlLjEwcyB0aGUgcHJlY2lzaW9uIGlzIGltcGxpY2l0bHlcbiAgICAgICB1bmRlcnN0b29kIGFzIHBhZGRpbmcgJTEwcywgYnV0IHRoZSBsZWZ0LXBhZGRpbmcgY29tcG9uZW50IG1heVxuICAgICAgIGJlIHNwZWNpZmllZCBlaXRoZXIgYXMgYSBsZWZ0IHBhZGRpbmcgb3IgYSBuZWdhdGl2ZSBwcmVjaXNpb246XG4gICAgICAgJS0uM3MgYW5kICUuLTNzIGFyZSBlcXVpdmFsZW50IHRvICUtM3MgKilcbiAgICBtYXRjaCBwYWQgd2l0aFxuICAgIHwgTm9fcGFkZGluZyAtPiAoXG4gICAgICBtYXRjaCBtaW51cywgcHJlYyB3aXRoXG4gICAgICAgIHwgXywgTm9fcHJlY2lzaW9uIC0+IHBhcnNlX2NvbnYgTm9fcGFkZGluZ1xuICAgICAgICB8IGZhbHNlLCBMaXRfcHJlY2lzaW9uIG4gLT4gcGFyc2VfY29udiAoTGl0X3BhZGRpbmcgKFJpZ2h0LCBuKSlcbiAgICAgICAgfCB0cnVlLCBMaXRfcHJlY2lzaW9uIG4gLT4gcGFyc2VfY29udiAoTGl0X3BhZGRpbmcgKExlZnQsIG4pKVxuICAgICAgICB8IGZhbHNlLCBBcmdfcHJlY2lzaW9uIC0+IHBhcnNlX2NvbnYgKEFyZ19wYWRkaW5nIFJpZ2h0KVxuICAgICAgICB8IHRydWUsIEFyZ19wcmVjaXNpb24gLT4gcGFyc2VfY29udiAoQXJnX3BhZGRpbmcgTGVmdClcbiAgICApXG4gICAgfCBwYWQgLT4gcGFyc2VfY29udiBwYWRcblxuICAoKiBDYXNlIGFuYWx5c2lzIG9uIGNvbnZlcnNpb24uICopXG4gIGFuZCBwYXJzZV9jb252ZXJzaW9uIDogdHlwZSB4IHkgeiB0IHUgdiBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiAoeCwgeSkgcGFkZGluZyAtPlxuICAgICAgICAoeiwgdCkgcHJlY2lzaW9uIC0+ICh1LCB2KSBwYWRkaW5nIC0+IGNoYXIgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWQgcHJlYyBwYWRwcmVjIHN5bWIgLT5cbiAgICAoKiBGbGFncyB1c2VkIHRvIGNoZWNrIG9wdGlvbiB1c2FnZXMvY29tcGF0aWJpbGl0aWVzLiAqKVxuICAgIGxldCBwbHVzX3VzZWQgID0gcmVmIGZhbHNlIGFuZCBoYXNoX3VzZWQgPSByZWYgZmFsc2VcbiAgICBhbmQgc3BhY2VfdXNlZCA9IHJlZiBmYWxzZSBhbmQgaWduX3VzZWQgICA9IHJlZiBmYWxzZVxuICAgIGFuZCBwYWRfdXNlZCAgID0gcmVmIGZhbHNlIGFuZCBwcmVjX3VzZWQgID0gcmVmIGZhbHNlIGluXG5cbiAgICAoKiBBY2Nlc3MgdG8gb3B0aW9ucywgdXBkYXRlIGZsYWdzLiAqKVxuICAgIGxldCBnZXRfcGx1cyAgICAoKSA9IHBsdXNfdXNlZCAgOj0gdHJ1ZTsgcGx1c1xuICAgIGFuZCBnZXRfaGFzaCAgICgpID0gaGFzaF91c2VkIDo9IHRydWU7IGhhc2hcbiAgICBhbmQgZ2V0X3NwYWNlICAgKCkgPSBzcGFjZV91c2VkIDo9IHRydWU7IHNwYWNlXG4gICAgYW5kIGdldF9pZ24gICAgICgpID0gaWduX3VzZWQgICA6PSB0cnVlOyBpZ25cbiAgICBhbmQgZ2V0X3BhZCAgICAgKCkgPSBwYWRfdXNlZCAgIDo9IHRydWU7IHBhZFxuICAgIGFuZCBnZXRfcHJlYyAgICAoKSA9IHByZWNfdXNlZCAgOj0gdHJ1ZTsgcHJlY1xuICAgIGFuZCBnZXRfcGFkcHJlYyAoKSA9IHBhZF91c2VkICAgOj0gdHJ1ZTsgcGFkcHJlYyBpblxuXG4gICAgbGV0IGdldF9pbnRfcGFkICgpID1cbiAgICAgICgqICU1LjNkIGlzIGFjY2VwdGVkIGFuZCBtZWFuaW5nZnVsOiBwYWQgdG8gbGVuZ3RoIDUgd2l0aFxuICAgICAgICAgc3BhY2VzLCBidXQgZmlyc3QgcGFkIHdpdGggemVyb3MgdXB0byBsZW5ndGggMyAoMC1wYWRkaW5nXG4gICAgICAgICBpcyB0aGUgaW50ZXJwcmV0YXRpb24gb2YgXCJwcmVjaXNpb25cIiBmb3IgaW50ZWdlciBmb3JtYXRzKS5cblxuICAgICAgICAgJTA1LjNkIGlzIHJlZHVuZGFudDogcGFkIHRvIGxlbmd0aCA1ICp3aXRoIHplcm9zKiwgYnV0XG4gICAgICAgICBmaXJzdCBwYWQgd2l0aCB6ZXJvcy4uLiBUbyBhZGQgaW5zdWx0IHRvIHRoZSBpbmp1cnksIHRoZVxuICAgICAgICAgbGVnYWN5IGltcGxlbWVudGF0aW9uIGlnbm9yZXMgdGhlIDAtcGFkZGluZyBpbmRpY2F0aW9uIGFuZFxuICAgICAgICAgZG9lcyB0aGUgNSBwYWRkaW5nIHdpdGggc3BhY2VzIGluc3RlYWQuIFdlIHJldXNlIHRoaXNcbiAgICAgICAgIGludGVycHJldGF0aW9uIGZvciBjb21wYXRpYmlsaXR5LCBidXQgc3RhdGljYWxseSByZWplY3QgdGhpc1xuICAgICAgICAgZm9ybWF0IHdoZW4gdGhlIGxlZ2FjeSBtb2RlIGlzIGRpc2FibGVkLCB0byBwcm90ZWN0IHN0cmljdFxuICAgICAgICAgdXNlcnMgZnJvbSB0aGlzIGNvcm5lciBjYXNlLiAqKVxuICAgICAgIG1hdGNoIGdldF9wYWQgKCksIGdldF9wcmVjICgpIHdpdGhcbiAgICAgICAgIHwgcGFkLCBOb19wcmVjaXNpb24gLT4gcGFkXG4gICAgICAgICB8IE5vX3BhZGRpbmcsIF8gICAgIC0+IE5vX3BhZGRpbmdcbiAgICAgICAgIHwgTGl0X3BhZGRpbmcgKFplcm9zLCBuKSwgXyAtPlxuICAgICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBMaXRfcGFkZGluZyAoUmlnaHQsIG4pXG4gICAgICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcwJyBcInByZWNpc2lvblwiXG4gICAgICAgICB8IEFyZ19wYWRkaW5nIFplcm9zLCBfIC0+XG4gICAgICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIEFyZ19wYWRkaW5nIFJpZ2h0XG4gICAgICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcwJyBcInByZWNpc2lvblwiXG4gICAgICAgICB8IExpdF9wYWRkaW5nIF8gYXMgcGFkLCBfIC0+IHBhZFxuICAgICAgICAgfCBBcmdfcGFkZGluZyBfIGFzIHBhZCwgXyAtPiBwYWQgaW5cblxuICAgICgqIENoZWNrIHRoYXQgcGFkdHkgPD4gWmVyb3MuICopXG4gICAgbGV0IGNoZWNrX25vXzAgc3ltYiAodHlwZSBhKSAodHlwZSBiKSAocGFkIDogKGEsIGIpIHBhZGRpbmcpID1cbiAgICAgIG1hdGNoIHBhZCB3aXRoXG4gICAgICB8IE5vX3BhZGRpbmcgLT4gcGFkXG4gICAgICB8IExpdF9wYWRkaW5nICgoTGVmdCB8IFJpZ2h0KSwgXykgLT4gcGFkXG4gICAgICB8IEFyZ19wYWRkaW5nIChMZWZ0IHwgUmlnaHQpIC0+IHBhZFxuICAgICAgfCBMaXRfcGFkZGluZyAoWmVyb3MsIHdpZHRoKSAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBMaXRfcGFkZGluZyAoUmlnaHQsIHdpZHRoKVxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiMFwiXG4gICAgICB8IEFyZ19wYWRkaW5nIFplcm9zIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIEFyZ19wYWRkaW5nIFJpZ2h0XG4gICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCIwXCJcbiAgICBpblxuXG4gICAgKCogR2V0IHBhZGRpbmcgYXMgYSBwYWRfb3B0aW9uIChzZWUgXCIlX1wiLCBcIiV7XCIsIFwiJShcIiBhbmQgXCIlW1wiKS5cbiAgICAgICAobm8gbmVlZCBmb3IgbGVnYWN5IG1vZGUgdHdlYWtpbmcsIHRob3NlIHdlcmUgcmVqZWN0ZWQgYnkgdGhlXG4gICAgICAgbGVnYWN5IHBhcnNlciBhcyB3ZWxsKSAqKVxuICAgIGxldCBvcHRfb2ZfcGFkIGMgKHR5cGUgYSkgKHR5cGUgYikgKHBhZCA6IChhLCBiKSBwYWRkaW5nKSA9IG1hdGNoIHBhZCB3aXRoXG4gICAgICB8IE5vX3BhZGRpbmcgLT4gTm9uZVxuICAgICAgfCBMaXRfcGFkZGluZyAoUmlnaHQsIHdpZHRoKSAtPiBTb21lIHdpZHRoXG4gICAgICB8IExpdF9wYWRkaW5nIChaZXJvcywgd2lkdGgpIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIFNvbWUgd2lkdGhcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgYyBcIicwJ1wiXG4gICAgICB8IExpdF9wYWRkaW5nIChMZWZ0LCB3aWR0aCkgLT5cbiAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gU29tZSB3aWR0aFxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBjIFwiJy0nXCJcbiAgICAgIHwgQXJnX3BhZGRpbmcgXyAtPiBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgYyBcIicqJ1wiXG4gICAgaW5cbiAgICBsZXQgZ2V0X3BhZF9vcHQgYyA9IG9wdF9vZl9wYWQgYyAoZ2V0X3BhZCAoKSkgaW5cbiAgICBsZXQgZ2V0X3BhZHByZWNfb3B0IGMgPSBvcHRfb2ZfcGFkIGMgKGdldF9wYWRwcmVjICgpKSBpblxuXG4gICAgKCogR2V0IHByZWNpc2lvbiBhcyBhIHByZWNfb3B0aW9uIChzZWUgXCIlX2ZcIikuXG4gICAgICAgKG5vIG5lZWQgZm9yIGxlZ2FjeSBtb2RlIHR3ZWFraW5nLCB0aG9zZSB3ZXJlIHJlamVjdGVkIGJ5IHRoZVxuICAgICAgIGxlZ2FjeSBwYXJzZXIgYXMgd2VsbCkgKilcbiAgICBsZXQgZ2V0X3ByZWNfb3B0ICgpID0gbWF0Y2ggZ2V0X3ByZWMgKCkgd2l0aFxuICAgICAgfCBOb19wcmVjaXNpb24gICAgICAgLT4gTm9uZVxuICAgICAgfCBMaXRfcHJlY2lzaW9uIG5kZWMgLT4gU29tZSBuZGVjXG4gICAgICB8IEFyZ19wcmVjaXNpb24gICAgICAtPiBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJ18nIFwiJyonXCJcbiAgICBpblxuXG4gICAgbGV0IGZtdF9yZXN1bHQgPSBtYXRjaCBzeW1iIHdpdGhcbiAgICB8ICcsJyAtPlxuICAgICAgcGFyc2Ugc3RyX2luZCBlbmRfaW5kXG4gICAgfCAnYycgLT5cbiAgICAgIGxldCBjaGFyX2Zvcm1hdCBmbXRfcmVzdCA9ICgqICVjICopXG4gICAgICAgIGlmIGdldF9pZ24gKClcbiAgICAgICAgdGhlbiBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX2NoYXIsIGZtdF9yZXN0KSlcbiAgICAgICAgZWxzZSBGbXRfRUJCIChDaGFyIGZtdF9yZXN0KVxuICAgICAgaW5cbiAgICAgIGxldCBzY2FuX2Zvcm1hdCBmbXRfcmVzdCA9ICgqICUwYyAqKVxuICAgICAgICBpZiBnZXRfaWduICgpXG4gICAgICAgIHRoZW4gRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9zY2FuX25leHRfY2hhciwgZm10X3Jlc3QpKVxuICAgICAgICBlbHNlIEZtdF9FQkIgKFNjYW5fbmV4dF9jaGFyIGZtdF9yZXN0KVxuICAgICAgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBiZWdpbiBtYXRjaCBnZXRfcGFkX29wdCAnYycgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gY2hhcl9mb3JtYXQgZm10X3Jlc3RcbiAgICAgICAgfCBTb21lIDAgLT4gc2Nhbl9mb3JtYXQgZm10X3Jlc3RcbiAgICAgICAgfCBTb21lIF9uIC0+XG4gICAgICAgICAgIGlmIG5vdCBsZWdhY3lfYmVoYXZpb3JcbiAgICAgICAgICAgdGhlbiBpbnZhbGlkX25vbm51bGxfY2hhcl93aWR0aCBzdHJfaW5kXG4gICAgICAgICAgIGVsc2UgKCogbGVnYWN5IGlnbm9yZXMgJWMgd2lkdGhzICopIGNoYXJfZm9ybWF0IGZtdF9yZXN0XG4gICAgICBlbmRcbiAgICB8ICdDJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlbiBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX2NhbWxfY2hhcixmbXRfcmVzdCkpXG4gICAgICBlbHNlIEZtdF9FQkIgKENhbWxfY2hhciBmbXRfcmVzdClcbiAgICB8ICdzJyAtPlxuICAgICAgbGV0IHBhZCA9IGNoZWNrX25vXzAgc3ltYiAoZ2V0X3BhZHByZWMgKCkpIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9zdHJpbmcgKGdldF9wYWRwcmVjX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZGRpbmdfZm10X0VCQiAocGFkJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgcGFkIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKFN0cmluZyAocGFkJywgZm10X3Jlc3QnKSlcbiAgICB8ICdTJyAtPlxuICAgICAgbGV0IHBhZCA9IGNoZWNrX25vXzAgc3ltYiAoZ2V0X3BhZHByZWMgKCkpIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9jYW1sX3N0cmluZyAoZ2V0X3BhZHByZWNfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkZGluZ19mbXRfRUJCIChwYWQnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZGRpbmdfZm10X2ViYiBwYWQgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoQ2FtbF9zdHJpbmcgKHBhZCcsIGZtdF9yZXN0JykpXG4gICAgfCAnZCcgfCAnaScgfCAneCcgfCAnWCcgfCAnbycgfCAndScgLT5cbiAgICAgIGxldCBpY29udiA9IGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIChnZXRfcGx1cyAoKSkgKGdldF9oYXNoICgpKVxuICAgICAgICAoZ2V0X3NwYWNlICgpKSBzeW1iIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9pbnQgKGljb252LCBnZXRfcGFkX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfaW50X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChJbnQgKGljb252LCBwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSlcbiAgICB8ICdOJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGxldCBjb3VudGVyID0gVG9rZW5fY291bnRlciBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIGNvdW50ZXIgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBGbXRfRUJCIChTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBmbXRfcmVzdCkpXG4gICAgfCAnbCcgfCAnbicgfCAnTCcgd2hlbiBzdHJfaW5kPWVuZF9pbmQgfHwgbm90IChpc19pbnRfYmFzZSBzdHIuW3N0cl9pbmRdKSAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGxldCBjb3VudGVyID0gY291bnRlcl9vZl9jaGFyIHN5bWIgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBjb3VudGVyIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10X3Jlc3QpKVxuICAgIHwgJ2wnIC0+XG4gICAgICBsZXQgaWNvbnYgPVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgKHN0cl9pbmQgKyAxKSAoZ2V0X3BsdXMgKCkpIChnZXRfaGFzaCAoKSlcbiAgICAgICAgICAoZ2V0X3NwYWNlICgpKSBzdHIuW3N0cl9pbmRdIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9pbnQzMiAoaWNvbnYsIGdldF9wYWRfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9pbnRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEludDMyIChpY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnbicgLT5cbiAgICAgIGxldCBpY29udiA9XG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCAoc3RyX2luZCArIDEpIChnZXRfcGx1cyAoKSlcbiAgICAgICAgICAoZ2V0X2hhc2ggKCkpIChnZXRfc3BhY2UgKCkpIHN0ci5bc3RyX2luZF0gaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX25hdGl2ZWludCAoaWNvbnYsIGdldF9wYWRfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9pbnRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKE5hdGl2ZWludCAoaWNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ0wnIC0+XG4gICAgICBsZXQgaWNvbnYgPVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgKHN0cl9pbmQgKyAxKSAoZ2V0X3BsdXMgKCkpIChnZXRfaGFzaCAoKSlcbiAgICAgICAgICAoZ2V0X3NwYWNlICgpKSBzdHIuW3N0cl9pbmRdIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9pbnQ2NCAoaWNvbnYsIGdldF9wYWRfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9pbnRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEludDY0IChpY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnZicgfCAnZScgfCAnRScgfCAnZycgfCAnRycgfCAnRicgfCAnaCcgfCAnSCcgLT5cbiAgICAgIGxldCBmY29udiA9IGNvbXB1dGVfZmxvYXRfY29udiBwY3RfaW5kIHN0cl9pbmQgKGdldF9wbHVzICgpKVxuICAgICAgICAoZ2V0X3NwYWNlICgpKSBzeW1iIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9mbG9hdCAoZ2V0X3BhZF9vcHQgJ18nLCBnZXRfcHJlY19vcHQgKCkpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEZsb2F0IChmY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnYicgfCAnQicgLT5cbiAgICAgIGxldCBwYWQgPSBjaGVja19ub18wIHN5bWIgKGdldF9wYWRwcmVjICgpKSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfYm9vbCAoZ2V0X3BhZHByZWNfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkZGluZ19mbXRfRUJCIChwYWQnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZGRpbmdfZm10X2ViYiBwYWQgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoQm9vbCAocGFkJywgZm10X3Jlc3QnKSlcbiAgICB8ICdhJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEFscGhhIGZtdF9yZXN0KVxuICAgIHwgJ3QnIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgRm10X0VCQiAoVGhldGEgZm10X3Jlc3QpXG4gICAgfCAncicgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW4gRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9yZWFkZXIsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2UgRm10X0VCQiAoUmVhZGVyIGZtdF9yZXN0KVxuICAgIHwgJyEnIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgRm10X0VCQiAoRmx1c2ggZm10X3Jlc3QpXG4gICAgfCAoJyUnIHwgJ0AnKSBhcyBjIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgRm10X0VCQiAoQ2hhcl9saXRlcmFsIChjLCBmbXRfcmVzdCkpXG4gICAgfCAneycgLT5cbiAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgc3RyX2luZCBlbmRfaW5kICd9JyBpblxuICAgICAgbGV0IEZtdF9FQkIgc3ViX2ZtdCA9IHBhcnNlIHN0cl9pbmQgc3ViX2VuZCBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3ViX2VuZCArIDIpIGVuZF9pbmQgaW5cbiAgICAgIGxldCBzdWJfZm10dHkgPSBmbXR0eV9vZl9mbXQgc3ViX2ZtdCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9mb3JtYXRfYXJnIChnZXRfcGFkX29wdCAnXycsIHN1Yl9mbXR0eSkgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBGbXRfRUJCIChGb3JtYXRfYXJnIChnZXRfcGFkX29wdCAneycsIHN1Yl9mbXR0eSwgZm10X3Jlc3QpKVxuICAgIHwgJygnIC0+XG4gICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIHN0cl9pbmQgZW5kX2luZCAnKScgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN1Yl9lbmQgKyAyKSBlbmRfaW5kIGluXG4gICAgICBsZXQgRm10X0VCQiBzdWJfZm10ID0gcGFyc2Ugc3RyX2luZCBzdWJfZW5kIGluXG4gICAgICBsZXQgc3ViX2ZtdHR5ID0gZm10dHlfb2ZfZm10IHN1Yl9mbXQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfZm9ybWF0X3N1YnN0IChnZXRfcGFkX29wdCAnXycsIHN1Yl9mbXR0eSkgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBGbXRfRUJCIChGb3JtYXRfc3Vic3QgKGdldF9wYWRfb3B0ICcoJywgc3ViX2ZtdHR5LCBmbXRfcmVzdCkpXG4gICAgfCAnWycgLT5cbiAgICAgIGxldCBuZXh0X2luZCwgY2hhcl9zZXQgPSBwYXJzZV9jaGFyX3NldCBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgbmV4dF9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9zY2FuX2NoYXJfc2V0IChnZXRfcGFkX29wdCAnXycsIGNoYXJfc2V0KSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIEZtdF9FQkIgKFNjYW5fY2hhcl9zZXQgKGdldF9wYWRfb3B0ICdbJywgY2hhcl9zZXQsIGZtdF9yZXN0KSlcbiAgICB8ICctJyB8ICcrJyB8ICcjJyB8ICcgJyB8ICdfJyAtPlxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCBcXFxuICAgICAgICAgZmxhZyAlQyBpcyBvbmx5IGFsbG93ZWQgYWZ0ZXIgdGhlICclJScsIGJlZm9yZSBwYWRkaW5nIGFuZCBwcmVjaXNpb25cIlxuICAgICAgICBzdHIgcGN0X2luZCBzeW1iXG4gICAgfCBfIC0+XG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsIFxcXG4gICAgICAgICBpbnZhbGlkIGNvbnZlcnNpb24gXFxcIiUlJWNcXFwiXCIgc3RyIChzdHJfaW5kIC0gMSkgc3ltYlxuICAgIGluXG4gICAgKCogQ2hlY2sgZm9yIHVudXNlZCBvcHRpb25zLCBhbmQgcmVqZWN0IHRoZW0gYXMgaW5jb21wYXRpYmxlLlxuXG4gICAgICAgU3VjaCBjaGVja3MgbmVlZCB0byBiZSBkaXNhYmxlZCBpbiBsZWdhY3kgbW9kZSwgYXMgdGhlIGxlZ2FjeVxuICAgICAgIHBhcnNlciBzaWxlbnRseSBpZ25vcmVkIGluY29tcGF0aWJsZSBmbGFncy4gKilcbiAgICBpZiBub3QgbGVnYWN5X2JlaGF2aW9yIHRoZW4gYmVnaW5cbiAgICBpZiBub3QgIXBsdXNfdXNlZCAmJiBwbHVzIHRoZW5cbiAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJysnXCI7XG4gICAgaWYgbm90ICFoYXNoX3VzZWQgJiYgaGFzaCB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicjJ1wiO1xuICAgIGlmIG5vdCAhc3BhY2VfdXNlZCAmJiBzcGFjZSB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicgJ1wiO1xuICAgIGlmIG5vdCAhcGFkX3VzZWQgICYmIFBhZGRpbmdfRUJCIHBhZCA8PiBQYWRkaW5nX0VCQiBOb19wYWRkaW5nIHRoZW5cbiAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiYHBhZGRpbmcnXCI7XG4gICAgaWYgbm90ICFwcmVjX3VzZWQgJiYgUHJlY2lzaW9uX0VCQiBwcmVjIDw+IFByZWNpc2lvbl9FQkIgTm9fcHJlY2lzaW9uIHRoZW5cbiAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAoaWYgaWduIHRoZW4gJ18nIGVsc2Ugc3ltYilcbiAgICAgICAgXCJgcHJlY2lzaW9uJ1wiO1xuICAgIGlmIGlnbiAmJiBwbHVzIHRoZW4gaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICdfJyBcIicrJ1wiO1xuICAgIGVuZDtcbiAgICAoKiB0aGlzIGxhc3QgdGVzdCBtdXN0IG5vdCBiZSBkaXNhYmxlZCBpbiBsZWdhY3kgbW9kZSxcbiAgICAgICBhcyBpZ25vcmluZyBpdCB3b3VsZCB0eXBpY2FsbHkgcmVzdWx0IGluIGEgZGlmZmVyZW50IHR5cGluZ1xuICAgICAgIHRoYW4gd2hhdCB0aGUgbGVnYWN5IHBhcnNlciB1c2VkICopXG4gICAgaWYgbm90ICFpZ25fdXNlZCAmJiBpZ24gdGhlblxuICAgICAgYmVnaW4gbWF0Y2ggc3ltYiB3aXRoXG4gICAgICAgICgqIGFyZ3VtZW50LWxlc3MgZm9ybWF0cyBjYW4gc2FmZWx5IGJlIGlnbm9yZWQgaW4gbGVnYWN5IG1vZGUgKilcbiAgICAgICAgfCAoJ0AnIHwgJyUnIHwgJyEnIHwgJywnKSB3aGVuIGxlZ2FjeV9iZWhhdmlvciAtPiAoKVxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIidfJ1wiXG4gICAgICBlbmQ7XG4gICAgZm10X3Jlc3VsdFxuXG4gICgqIFBhcnNlIGZvcm1hdHRpbmcgaW5mb3JtYXRpb25zIChhZnRlciAnQCcpLiAqKVxuICBhbmQgcGFyc2VfYWZ0ZXJfYXQgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiBGbXRfRUJCIChDaGFyX2xpdGVyYWwgKCdAJywgRW5kX29mX2Zvcm1hdCkpXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICdbJyAtPlxuICAgICAgICBwYXJzZV90YWcgZmFsc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8ICddJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoQ2xvc2VfYm94LCBmbXRfcmVzdCkpXG4gICAgICB8ICd7JyAtPlxuICAgICAgICBwYXJzZV90YWcgdHJ1ZSAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICAgIHwgJ30nIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChDbG9zZV90YWcsIGZtdF9yZXN0KSlcbiAgICAgIHwgJywnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChCcmVhayAoXCJALFwiLCAwLCAwKSwgZm10X3Jlc3QpKVxuICAgICAgfCAnICcgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEJyZWFrIChcIkAgXCIsIDEsIDApLCBmbXRfcmVzdCkpXG4gICAgICB8ICc7JyAtPlxuICAgICAgICBwYXJzZV9nb29kX2JyZWFrIChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCAnPycgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEZGbHVzaCwgZm10X3Jlc3QpKVxuICAgICAgfCAnXFxuJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoRm9yY2VfbmV3bGluZSwgZm10X3Jlc3QpKVxuICAgICAgfCAnLicgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEZsdXNoX25ld2xpbmUsIGZtdF9yZXN0KSlcbiAgICAgIHwgJzwnIC0+XG4gICAgICAgIHBhcnNlX21hZ2ljX3NpemUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8ICdAJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoRXNjYXBlZF9hdCwgZm10X3Jlc3QpKVxuICAgICAgfCAnJScgd2hlbiBzdHJfaW5kICsgMSA8IGVuZF9pbmQgJiYgc3RyLltzdHJfaW5kICsgMV0gPSAnJScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDIpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEVzY2FwZWRfcGVyY2VudCwgZm10X3Jlc3QpKVxuICAgICAgfCAnJScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoQ2hhcl9saXRlcmFsICgnQCcsIGZtdF9yZXN0KSlcbiAgICAgIHwgYyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoU2Nhbl9pbmRpYyBjLCBmbXRfcmVzdCkpXG5cbiAgYW5kIGNoZWNrX29wZW5fYm94IDogdHlwZSBhIGIgYyBkIGUgZiAuIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gdW5pdCA9XG4gIGZ1biBmbXQgLT4gbWF0Y2ggZm10IHdpdGhcbiAgICB8IFN0cmluZ19saXRlcmFsIChzdHIsIEVuZF9vZl9mb3JtYXQpIC0+IChcbiAgICAgIHRyeSBpZ25vcmUgKG9wZW5fYm94X29mX3N0cmluZyBzdHIpIHdpdGggRmFpbHVyZSBfIC0+XG4gICAgICAgICgoKiBFbWl0IHdhcm5pbmc6IGludmFsaWQgb3BlbiBib3ggKikpXG4gICAgKVxuICAgIHwgXyAtPiAoKVxuXG4gICgqIFRyeSB0byByZWFkIHRoZSBvcHRpb25hbCA8bmFtZT4gYWZ0ZXIgXCJAe1wiIG9yIFwiQFtcIi4gKilcbiAgYW5kIHBhcnNlX3RhZyA6IHR5cGUgZSBmIC4gYm9vbCAtPiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIGlzX29wZW5fdGFnIHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIHRyeVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJzwnIC0+XG4gICAgICAgIGxldCBpbmQgPSBTdHJpbmcuaW5kZXhfZnJvbSBzdHIgKHN0cl9pbmQgKyAxKSAnPicgaW5cbiAgICAgICAgaWYgaW5kID49IGVuZF9pbmQgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICAgIGxldCBzdWJfc3RyID0gU3RyaW5nLnN1YiBzdHIgc3RyX2luZCAoaW5kIC0gc3RyX2luZCArIDEpIGluXG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKGluZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgbGV0IEZtdF9FQkIgc3ViX2ZtdCA9IHBhcnNlIHN0cl9pbmQgKGluZCArIDEpIGluXG4gICAgICAgIGxldCBzdWJfZm9ybWF0ID0gRm9ybWF0IChzdWJfZm10LCBzdWJfc3RyKSBpblxuICAgICAgICBsZXQgZm9ybWF0dGluZyA9IGlmIGlzX29wZW5fdGFnIHRoZW4gT3Blbl90YWcgc3ViX2Zvcm1hdCBlbHNlIChcbiAgICAgICAgICBjaGVja19vcGVuX2JveCBzdWJfZm10O1xuICAgICAgICAgIE9wZW5fYm94IHN1Yl9mb3JtYXQpIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfZ2VuIChmb3JtYXR0aW5nLCBmbXRfcmVzdCkpXG4gICAgICB8IF8gLT5cbiAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgc3ViX2Zvcm1hdCA9IEZvcm1hdCAoRW5kX29mX2Zvcm1hdCwgXCJcIikgaW5cbiAgICAgIGxldCBmb3JtYXR0aW5nID1cbiAgICAgICAgaWYgaXNfb3Blbl90YWcgdGhlbiBPcGVuX3RhZyBzdWJfZm9ybWF0IGVsc2UgT3Blbl9ib3ggc3ViX2Zvcm1hdCBpblxuICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19nZW4gKGZvcm1hdHRpbmcsIGZtdF9yZXN0KSlcblxuICAoKiBUcnkgdG8gcmVhZCB0aGUgb3B0aW9uYWwgPHdpZHRoIG9mZnNldD4gYWZ0ZXIgXCJAO1wiLiAqKVxuICBhbmQgcGFyc2VfZ29vZF9icmVhayA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBsZXQgbmV4dF9pbmQsIGZvcm1hdHRpbmdfbGl0ID1cbiAgICAgIHRyeVxuICAgICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB8fCBzdHIuW3N0cl9pbmRdIDw+ICc8JyB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgICAgbGV0IHN0cl9pbmRfMSA9IHBhcnNlX3NwYWNlcyAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXzFdIHdpdGhcbiAgICAgICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+IChcbiAgICAgICAgICBsZXQgc3RyX2luZF8yLCB3aWR0aCA9IHBhcnNlX2ludGVnZXIgc3RyX2luZF8xIGVuZF9pbmQgaW5cbiAgICAgICAgICAgIGxldCBzdHJfaW5kXzMgPSBwYXJzZV9zcGFjZXMgc3RyX2luZF8yIGVuZF9pbmQgaW5cbiAgICAgICAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF8zXSB3aXRoXG4gICAgICAgICAgICAgIHwgJz4nIC0+XG4gICAgICAgICAgICAgICAgbGV0IHMgPSBTdHJpbmcuc3ViIHN0ciAoc3RyX2luZC0yKSAoc3RyX2luZF8zLXN0cl9pbmQrMykgaW5cbiAgICAgICAgICAgICAgICBzdHJfaW5kXzMgKyAxLCBCcmVhayAocywgd2lkdGgsIDApXG4gICAgICAgICAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPlxuICAgICAgICAgICAgICAgIGxldCBzdHJfaW5kXzQsIG9mZnNldCA9IHBhcnNlX2ludGVnZXIgc3RyX2luZF8zIGVuZF9pbmQgaW5cbiAgICAgICAgICAgICAgICBsZXQgc3RyX2luZF81ID0gcGFyc2Vfc3BhY2VzIHN0cl9pbmRfNCBlbmRfaW5kIGluXG4gICAgICAgICAgICAgICAgaWYgc3RyLltzdHJfaW5kXzVdIDw+ICc+JyB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgICAgICAgICAgICBsZXQgcyA9IFN0cmluZy5zdWIgc3RyIChzdHJfaW5kLTIpIChzdHJfaW5kXzUtc3RyX2luZCszKSBpblxuICAgICAgICAgICAgICAgIHN0cl9pbmRfNSArIDEsIEJyZWFrIChzLCB3aWR0aCwgb2Zmc2V0KVxuICAgICAgICAgICAgICB8IF8gLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgIClcbiAgICAgICAgfCBfIC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgd2l0aCBOb3RfZm91bmQgfCBGYWlsdXJlIF8gLT5cbiAgICAgICAgc3RyX2luZCwgQnJlYWsgKFwiQDtcIiwgMSwgMClcbiAgICBpblxuICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgbmV4dF9pbmQgZW5kX2luZCBpblxuICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10X3Jlc3QpKVxuXG4gICgqIFBhcnNlIHRoZSBzaXplIGluIGEgPG4+LiAqKVxuICBhbmQgcGFyc2VfbWFnaWNfc2l6ZSA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBtYXRjaFxuICAgICAgdHJ5XG4gICAgICAgIGxldCBzdHJfaW5kXzEgPSBwYXJzZV9zcGFjZXMgc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF8xXSB3aXRoXG4gICAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPlxuICAgICAgICAgIGxldCBzdHJfaW5kXzIsIHNpemUgPSBwYXJzZV9pbnRlZ2VyIHN0cl9pbmRfMSBlbmRfaW5kIGluXG4gICAgICAgICAgbGV0IHN0cl9pbmRfMyA9IHBhcnNlX3NwYWNlcyBzdHJfaW5kXzIgZW5kX2luZCBpblxuICAgICAgICAgIGlmIHN0ci5bc3RyX2luZF8zXSA8PiAnPicgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICAgICAgbGV0IHMgPSBTdHJpbmcuc3ViIHN0ciAoc3RyX2luZCAtIDIpIChzdHJfaW5kXzMgLSBzdHJfaW5kICsgMykgaW5cbiAgICAgICAgICBTb21lIChzdHJfaW5kXzMgKyAxLCBNYWdpY19zaXplIChzLCBzaXplKSlcbiAgICAgICAgfCBfIC0+IE5vbmVcbiAgICAgIHdpdGggTm90X2ZvdW5kIHwgRmFpbHVyZSBfIC0+XG4gICAgICAgIE5vbmVcbiAgICB3aXRoXG4gICAgfCBTb21lIChuZXh0X2luZCwgZm9ybWF0dGluZ19saXQpIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIG5leHRfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10X3Jlc3QpKVxuICAgIHwgTm9uZSAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChTY2FuX2luZGljICc8JywgZm10X3Jlc3QpKVxuXG4gICgqIFBhcnNlIGFuZCBjb25zdHJ1Y3QgYSBjaGFyIHNldC4gKilcbiAgYW5kIHBhcnNlX2NoYXJfc2V0IHN0cl9pbmQgZW5kX2luZCA9XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcblxuICAgIGxldCBjaGFyX3NldCA9IGNyZWF0ZV9jaGFyX3NldCAoKSBpblxuICAgIGxldCBhZGRfY2hhciBjID1cbiAgICAgIGFkZF9pbl9jaGFyX3NldCBjaGFyX3NldCBjO1xuICAgIGluXG4gICAgbGV0IGFkZF9yYW5nZSBjIGMnID1cbiAgICAgIGZvciBpID0gaW50X29mX2NoYXIgYyB0byBpbnRfb2ZfY2hhciBjJyBkb1xuICAgICAgICBhZGRfaW5fY2hhcl9zZXQgY2hhcl9zZXQgKGNoYXJfb2ZfaW50IGkpO1xuICAgICAgZG9uZTtcbiAgICBpblxuXG4gICAgbGV0IGZhaWxfc2luZ2xlX3BlcmNlbnQgc3RyX2luZCA9XG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6ICclJScgYWxvbmUgaXMgbm90IGFjY2VwdGVkIGluIGNoYXJhY3RlciBzZXRzLCBcXFxuICAgICAgICAgdXNlICUlJSUgaW5zdGVhZCBhdCBwb3NpdGlvbiAlZC5cIiBzdHIgc3RyX2luZFxuICAgIGluXG5cbiAgICAoKiBQYXJzZSB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgY2hhciBzZXQuICopXG4gICAgbGV0IHJlYyBwYXJzZV9jaGFyX3NldF9zdGFydCBzdHJfaW5kIGVuZF9pbmQgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIGxldCBjID0gc3RyLltzdHJfaW5kXSBpblxuICAgICAgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuXG4gICAgKCogUGFyc2UgdGhlIGNvbnRlbnQgb2YgYSBjaGFyIHNldCB1bnRpbCB0aGUgZmlyc3QgJ10nLiAqKVxuICAgIGFuZCBwYXJzZV9jaGFyX3NldF9jb250ZW50IHN0cl9pbmQgZW5kX2luZCA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICddJyAtPlxuICAgICAgICBzdHJfaW5kICsgMVxuICAgICAgfCAnLScgLT5cbiAgICAgICAgYWRkX2NoYXIgJy0nO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCBjIC0+XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGNcblxuICAgICgqIFRlc3QgZm9yIHJhbmdlIGluIGNoYXIgc2V0LiAqKVxuICAgIGFuZCBwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIHN0cl9pbmQgZW5kX2luZCBjID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ10nIC0+XG4gICAgICAgIGFkZF9jaGFyIGM7XG4gICAgICAgIHN0cl9pbmQgKyAxXG4gICAgICB8ICctJyAtPlxuICAgICAgICBwYXJzZV9jaGFyX3NldF9hZnRlcl9taW51cyAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuICAgICAgfCAoJyUnIHwgJ0AnKSBhcyBjJyB3aGVuIGMgPSAnJScgLT5cbiAgICAgICAgYWRkX2NoYXIgYyc7XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2NvbnRlbnQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8IGMnIC0+XG4gICAgICAgIGlmIGMgPSAnJScgdGhlbiBmYWlsX3NpbmdsZV9wZXJjZW50IHN0cl9pbmQ7XG4gICAgICAgICgqIG5vdGUgdGhhdCAnQCcgYWxvbmUgaXMgYWNjZXB0ZWQsIGFzIGRvbmUgYnkgdGhlIGxlZ2FjeVxuICAgICAgICAgICBpbXBsZW1lbnRhdGlvbjsgdGhlIGRvY3VtZW50YXRpb24gc3BlY2lmaWNhbGx5IHJlcXVpcmVzICVAXG4gICAgICAgICAgIHNvIHdlIGNvdWxkIHdhcm4gb24gdGhhdCAqKVxuICAgICAgICBhZGRfY2hhciBjO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIChzdHJfaW5kICsgMSkgZW5kX2luZCBjJ1xuXG4gICAgKCogTWFuYWdlIHJhbmdlIGluIGNoYXIgc2V0IChleGNlcHQgaWYgdGhlICctJyB0aGUgbGFzdCBjaGFyIGJlZm9yZSAnXScpICopXG4gICAgYW5kIHBhcnNlX2NoYXJfc2V0X2FmdGVyX21pbnVzIHN0cl9pbmQgZW5kX2luZCBjID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ10nIC0+XG4gICAgICAgIGFkZF9jaGFyIGM7XG4gICAgICAgIGFkZF9jaGFyICctJztcbiAgICAgICAgc3RyX2luZCArIDFcbiAgICAgIHwgJyUnIC0+XG4gICAgICAgIGlmIHN0cl9pbmQgKyAxID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgICBiZWdpbiBtYXRjaCBzdHIuW3N0cl9pbmQgKyAxXSB3aXRoXG4gICAgICAgICAgfCAoJyUnIHwgJ0AnKSBhcyBjJyAtPlxuICAgICAgICAgICAgYWRkX3JhbmdlIGMgYyc7XG4gICAgICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMikgZW5kX2luZFxuICAgICAgICAgIHwgXyAtPiBmYWlsX3NpbmdsZV9wZXJjZW50IHN0cl9pbmRcbiAgICAgICAgZW5kXG4gICAgICB8IGMnIC0+XG4gICAgICAgIGFkZF9yYW5nZSBjIGMnO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgIGluXG4gICAgbGV0IHN0cl9pbmQsIHJldmVyc2UgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgICB8ICdeJyAtPiBzdHJfaW5kICsgMSwgdHJ1ZVxuICAgICAgICB8IF8gLT4gc3RyX2luZCwgZmFsc2UgaW5cbiAgICBsZXQgbmV4dF9pbmQgPSBwYXJzZV9jaGFyX3NldF9zdGFydCBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICBsZXQgY2hhcl9zZXQgPSBmcmVlemVfY2hhcl9zZXQgY2hhcl9zZXQgaW5cbiAgICBuZXh0X2luZCwgKGlmIHJldmVyc2UgdGhlbiByZXZfY2hhcl9zZXQgY2hhcl9zZXQgZWxzZSBjaGFyX3NldClcblxuICAoKiBDb25zdW1lIGFsbCBuZXh0IHNwYWNlcywgcmFpc2UgYW4gRmFpbHVyZSBpZiBlbmRfaW5kIGlzIHJlYWNoZWQuICopXG4gIGFuZCBwYXJzZV9zcGFjZXMgc3RyX2luZCBlbmRfaW5kID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIGlmIHN0ci5bc3RyX2luZF0gPSAnICcgdGhlbiBwYXJzZV9zcGFjZXMgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGVsc2Ugc3RyX2luZFxuXG4gICgqIFJlYWQgYSBwb3NpdGl2ZSBpbnRlZ2VyIGZyb20gdGhlIHN0cmluZywgcmFpc2UgYSBGYWlsdXJlIGlmIGVuZF9pbmQgaXNcbiAgICAgcmVhY2hlZC4gKilcbiAgYW5kIHBhcnNlX3Bvc2l0aXZlIHN0cl9pbmQgZW5kX2luZCBhY2MgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIGFzIGMgLT5cbiAgICAgIGxldCBuZXdfYWNjID0gYWNjICogMTAgKyAoaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICcwJykgaW5cbiAgICAgIGlmIG5ld19hY2MgPiBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlblxuICAgICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogaW50ZWdlciAlZCBpcyBncmVhdGVyIHRoYW4gdGhlIGxpbWl0ICVkXCJcbiAgICAgICAgICBzdHIgbmV3X2FjYyBTeXMubWF4X3N0cmluZ19sZW5ndGhcbiAgICAgIGVsc2VcbiAgICAgICAgcGFyc2VfcG9zaXRpdmUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIG5ld19hY2NcbiAgICB8IF8gLT4gc3RyX2luZCwgYWNjXG5cbiAgKCogUmVhZCBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIGludGVnZXIgZnJvbSB0aGUgc3RyaW5nLCByYWlzZSBhIEZhaWx1cmVcbiAgICAgaWYgZW5kX2luZCBpcyByZWFjaGVkLiAqKVxuICBhbmQgcGFyc2VfaW50ZWdlciBzdHJfaW5kIGVuZF9pbmQgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIC0+IHBhcnNlX3Bvc2l0aXZlIHN0cl9pbmQgZW5kX2luZCAwXG4gICAgfCAnLScgLT4gKFxuICAgICAgaWYgc3RyX2luZCArIDEgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmQgKyAxXSB3aXRoXG4gICAgICB8ICcwJyAuLiAnOScgLT5cbiAgICAgICAgbGV0IG5leHRfaW5kLCBuID0gcGFyc2VfcG9zaXRpdmUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIDAgaW5cbiAgICAgICAgbmV4dF9pbmQsIC1uXG4gICAgICB8IGMgLT5cbiAgICAgICAgZXhwZWN0ZWRfY2hhcmFjdGVyIChzdHJfaW5kICsgMSkgXCJkaWdpdFwiIGNcbiAgICApXG4gICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG4gICgqIEFkZCBhIGxpdGVyYWwgdG8gYSBmb3JtYXQgZnJvbSBhIGxpdGVyYWwgY2hhcmFjdGVyIHN1Yi1zZXF1ZW5jZS4gKilcbiAgYW5kIGFkZF9saXRlcmFsIDogdHlwZSBhIGQgZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gKGEsIF8sIF8sIGQsIGUsIGYpIGZtdCAtPlxuICAgICAgKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gbGl0X3N0YXJ0IHN0cl9pbmQgZm10IC0+IG1hdGNoIHN0cl9pbmQgLSBsaXRfc3RhcnQgd2l0aFxuICAgIHwgMCAgICAtPiBGbXRfRUJCIGZtdFxuICAgIHwgMSAgICAtPiBGbXRfRUJCIChDaGFyX2xpdGVyYWwgKHN0ci5bbGl0X3N0YXJ0XSwgZm10KSlcbiAgICB8IHNpemUgLT4gRm10X0VCQiAoU3RyaW5nX2xpdGVyYWwgKFN0cmluZy5zdWIgc3RyIGxpdF9zdGFydCBzaXplLCBmbXQpKVxuXG4gICgqIFNlYXJjaCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHN1Yi1mb3JtYXRcbiAgICAgKGkuZS4gdGhlIGNvcnJlc3BvbmRpbmcgXCIlfVwiIG9yIFwiJSlcIikgKilcbiAgYW5kIHNlYXJjaF9zdWJmb3JtYXRfZW5kIHN0cl9pbmQgZW5kX2luZCBjID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuXG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IHVuY2xvc2VkIHN1Yi1mb3JtYXQsIFxcXG4gICAgICAgICBleHBlY3RlZCBcXFwiJSUlY1xcXCIgYXQgY2hhcmFjdGVyIG51bWJlciAlZFwiIHN0ciBjIGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnJScgLT5cbiAgICAgIGlmIHN0cl9pbmQgKyAxID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgaWYgc3RyLltzdHJfaW5kICsgMV0gPSBjIHRoZW4gKCogRW5kIG9mIGZvcm1hdCBmb3VuZCAqKSBzdHJfaW5kIGVsc2VcbiAgICAgICAgYmVnaW4gbWF0Y2ggc3RyLltzdHJfaW5kICsgMV0gd2l0aFxuICAgICAgICB8ICdfJyAtPlxuICAgICAgICAgICgqIFNlYXJjaCBmb3IgXCIlXyhcIiBvciBcIiVfe1wiLiAqKVxuICAgICAgICAgIGlmIHN0cl9pbmQgKyAyID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgICAgIGJlZ2luIG1hdGNoIHN0ci5bc3RyX2luZCArIDJdIHdpdGhcbiAgICAgICAgICB8ICd7JyAtPlxuICAgICAgICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDMpIGVuZF9pbmQgJ30nIGluXG4gICAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3ViX2VuZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICAgIHwgJygnIC0+XG4gICAgICAgICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMykgZW5kX2luZCAnKScgaW5cbiAgICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgICAgfCBfIC0+IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMykgZW5kX2luZCBjXG4gICAgICAgICAgZW5kXG4gICAgICAgIHwgJ3snIC0+XG4gICAgICAgICAgKCogJXsuLi4lfSBzdWItZm9ybWF0IGZvdW5kLiAqKVxuICAgICAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAyKSBlbmRfaW5kICd9JyBpblxuICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgIHwgJygnIC0+XG4gICAgICAgICAgKCogJSguLi4lKSBzdWItZm9ybWF0IGZvdW5kLiAqKVxuICAgICAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAyKSBlbmRfaW5kICcpJyBpblxuICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgIHwgJ30nIC0+XG4gICAgICAgICAgKCogRXJyb3I6ICUoLi4uJX0uICopXG4gICAgICAgICAgZXhwZWN0ZWRfY2hhcmFjdGVyIChzdHJfaW5kICsgMSkgXCJjaGFyYWN0ZXIgJyknXCIgJ30nXG4gICAgICAgIHwgJyknIC0+XG4gICAgICAgICAgKCogRXJyb3I6ICV7Li4uJSkuICopXG4gICAgICAgICAgZXhwZWN0ZWRfY2hhcmFjdGVyIChzdHJfaW5kICsgMSkgXCJjaGFyYWN0ZXIgJ30nXCIgJyknXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgIGVuZFxuICAgIHwgXyAtPiBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuXG4gICgqIENoZWNrIGlmIHN5bWIgaXMgYSB2YWxpZCBpbnQgY29udmVyc2lvbiBhZnRlciBcIiVsXCIsIFwiJW5cIiBvciBcIiVMXCIgKilcbiAgYW5kIGlzX2ludF9iYXNlIHN5bWIgPSBtYXRjaCBzeW1iIHdpdGhcbiAgICB8ICdkJyB8ICdpJyB8ICd4JyB8ICdYJyB8ICdvJyB8ICd1JyAtPiB0cnVlXG4gICAgfCBfIC0+IGZhbHNlXG5cbiAgKCogQ29udmVydCBhIGNoYXIgKGwsIG4gb3IgTCkgdG8gaXRzIGFzc29jaWF0ZWQgY291bnRlci4gKilcbiAgYW5kIGNvdW50ZXJfb2ZfY2hhciBzeW1iID0gbWF0Y2ggc3ltYiB3aXRoXG4gICAgfCAnbCcgLT4gTGluZV9jb3VudGVyICB8ICduJyAtPiBDaGFyX2NvdW50ZXJcbiAgICB8ICdMJyAtPiBUb2tlbl9jb3VudGVyIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuICAoKiBDb252ZXJ0IChwbHVzLCBzeW1iKSB0byBpdHMgYXNzb2NpYXRlZCBpbnRfY29udi4gKilcbiAgYW5kIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgaGFzaCBzcGFjZSBzeW1iID1cbiAgICBtYXRjaCBwbHVzLCBoYXNoLCBzcGFjZSwgc3ltYiB3aXRoXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnZCcgLT4gSW50X2QgIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ2knIC0+IEludF9pXG4gICAgfCBmYWxzZSwgZmFsc2UsICB0cnVlLCAnZCcgLT4gSW50X3NkIHwgZmFsc2UsIGZhbHNlLCAgdHJ1ZSwgJ2knIC0+IEludF9zaVxuICAgIHwgIHRydWUsIGZhbHNlLCBmYWxzZSwgJ2QnIC0+IEludF9wZCB8ICB0cnVlLCBmYWxzZSwgZmFsc2UsICdpJyAtPiBJbnRfcGlcbiAgICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICd4JyAtPiBJbnRfeCAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnWCcgLT4gSW50X1hcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICd4JyAtPiBJbnRfQ3ggfCBmYWxzZSwgIHRydWUsIGZhbHNlLCAnWCcgLT4gSW50X0NYXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnbycgLT4gSW50X29cbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICdvJyAtPiBJbnRfQ29cbiAgICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICd1JyAtPiBJbnRfdVxuICAgIHwgXywgdHJ1ZSwgXywgJ3gnIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+IEludF9DeFxuICAgIHwgXywgdHJ1ZSwgXywgJ1gnIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+IEludF9DWFxuICAgIHwgXywgdHJ1ZSwgXywgJ28nIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+IEludF9Db1xuICAgIHwgXywgdHJ1ZSwgXywgKCdkJyB8ICdpJyB8ICd1JykgLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuICgqIGlnbm9yZSAqKVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIGZhbHNlIHNwYWNlIHN5bWJcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInIydcIlxuICAgIHwgdHJ1ZSwgXywgdHJ1ZSwgXyAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW5cbiAgICAgICAgKCogcGx1cyBhbmQgc3BhY2U6IGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBwcmVmZXJzIHBsdXMgKilcbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBoYXNoIGZhbHNlIHN5bWJcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcgJyBcIicrJ1wiXG4gICAgfCBmYWxzZSwgXywgdHJ1ZSwgXyAgICAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gKCogaWdub3JlICopXG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgaGFzaCBmYWxzZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJyAnXCJcbiAgICB8IHRydWUsIF8sIGZhbHNlLCBfICAgIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiAoKiBpZ25vcmUgKilcbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgZmFsc2UgaGFzaCBzcGFjZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJysnXCJcbiAgICB8IGZhbHNlLCBfLCBmYWxzZSwgXyAtPiBhc3NlcnQgZmFsc2VcblxuICAoKiBDb252ZXJ0IChwbHVzLCBzeW1iKSB0byBpdHMgYXNzb2NpYXRlZCBmbG9hdF9jb252LiAqKVxuICBhbmQgY29tcHV0ZV9mbG9hdF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIHNwYWNlIHN5bWIgPVxuICBtYXRjaCBwbHVzLCBzcGFjZSwgc3ltYiB3aXRoXG4gICAgfCBmYWxzZSwgZmFsc2UsICdmJyAtPiBGbG9hdF9mICB8IGZhbHNlLCBmYWxzZSwgJ2UnIC0+IEZsb2F0X2VcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgJ2YnIC0+IEZsb2F0X3NmIHwgZmFsc2UsICB0cnVlLCAnZScgLT4gRmxvYXRfc2VcbiAgICB8ICB0cnVlLCBmYWxzZSwgJ2YnIC0+IEZsb2F0X3BmIHwgIHRydWUsIGZhbHNlLCAnZScgLT4gRmxvYXRfcGVcbiAgICB8IGZhbHNlLCBmYWxzZSwgJ0UnIC0+IEZsb2F0X0UgIHwgZmFsc2UsIGZhbHNlLCAnZycgLT4gRmxvYXRfZ1xuICAgIHwgZmFsc2UsICB0cnVlLCAnRScgLT4gRmxvYXRfc0UgfCBmYWxzZSwgIHRydWUsICdnJyAtPiBGbG9hdF9zZ1xuICAgIHwgIHRydWUsIGZhbHNlLCAnRScgLT4gRmxvYXRfcEUgfCAgdHJ1ZSwgZmFsc2UsICdnJyAtPiBGbG9hdF9wZ1xuICAgIHwgZmFsc2UsIGZhbHNlLCAnRycgLT4gRmxvYXRfR1xuICAgIHwgZmFsc2UsICB0cnVlLCAnRycgLT4gRmxvYXRfc0dcbiAgICB8ICB0cnVlLCBmYWxzZSwgJ0cnIC0+IEZsb2F0X3BHXG4gICAgfCBmYWxzZSwgZmFsc2UsICdoJyAtPiBGbG9hdF9oXG4gICAgfCBmYWxzZSwgIHRydWUsICdoJyAtPiBGbG9hdF9zaFxuICAgIHwgIHRydWUsIGZhbHNlLCAnaCcgLT4gRmxvYXRfcGhcbiAgICB8IGZhbHNlLCBmYWxzZSwgJ0gnIC0+IEZsb2F0X0hcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgJ0gnIC0+IEZsb2F0X3NIXG4gICAgfCAgdHJ1ZSwgZmFsc2UsICdIJyAtPiBGbG9hdF9wSFxuICAgIHwgZmFsc2UsIGZhbHNlLCAnRicgLT4gRmxvYXRfRlxuICAgIHwgIHRydWUsICB0cnVlLCBfIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlblxuICAgICAgICAoKiBwbHVzIGFuZCBzcGFjZTogbGVnYWN5IGltcGxlbWVudGF0aW9uIHByZWZlcnMgcGx1cyAqKVxuICAgICAgICBjb21wdXRlX2Zsb2F0X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgZmFsc2Ugc3ltYlxuICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJyAnIFwiJysnXCJcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgXyAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gKCogaWdub3JlICopXG4gICAgICAgIGNvbXB1dGVfZmxvYXRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBmYWxzZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJyAnXCJcbiAgICB8ICB0cnVlLCBmYWxzZSwgXyAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gKCogaWdub3JlICopXG4gICAgICAgIGNvbXB1dGVfZmxvYXRfY29udiBwY3RfaW5kIHN0cl9pbmQgZmFsc2Ugc3BhY2Ugc3ltYlxuICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicrJ1wiXG4gICAgfCBmYWxzZSwgZmFsc2UsIF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBmcmllbmRseSBlcnJvciBtZXNzYWdlIGFib3V0IGluY29tcGF0aWJsZSBvcHRpb25zLiopXG4gIGFuZCBpbmNvbXBhdGlibGVfZmxhZyA6IHR5cGUgYSAuIGludCAtPiBpbnQgLT4gY2hhciAtPiBzdHJpbmcgLT4gYSA9XG4gICAgZnVuIHBjdF9pbmQgc3RyX2luZCBzeW1iIG9wdGlvbiAtPlxuICAgICAgbGV0IHN1YmZtdCA9IFN0cmluZy5zdWIgc3RyIHBjdF9pbmQgKHN0cl9pbmQgLSBwY3RfaW5kKSBpblxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCBcXFxuICAgICAgICAgJXMgaXMgaW5jb21wYXRpYmxlIHdpdGggJyVjJyBpbiBzdWItZm9ybWF0ICVTXCJcbiAgICAgICAgc3RyIHBjdF9pbmQgb3B0aW9uIHN5bWIgc3ViZm10XG5cbiAgaW4gcGFyc2UgMCAoU3RyaW5nLmxlbmd0aCBzdHIpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAoKiBHdWFyZGVkIHN0cmluZyB0byBmb3JtYXQgY29udmVyc2lvbnMgKilcblxuKCogQ29udmVydCBhIHN0cmluZyB0byBhIGZvcm1hdCBhY2NvcmRpbmcgdG8gYW4gZm10dHkuICopXG4oKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhbiBlcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCBmb3JtYXRfb2Zfc3RyaW5nX2ZtdHR5IHN0ciBmbXR0eSA9XG4gIGxldCBGbXRfRUJCIGZtdCA9IGZtdF9lYmJfb2Zfc3RyaW5nIHN0ciBpblxuICB0cnkgRm9ybWF0ICh0eXBlX2Zvcm1hdCBmbXQgZm10dHksIHN0cilcbiAgd2l0aCBUeXBlX21pc21hdGNoIC0+XG4gICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgXCJiYWQgaW5wdXQ6IGZvcm1hdCB0eXBlIG1pc21hdGNoIGJldHdlZW4gJVMgYW5kICVTXCJcbiAgICAgIHN0ciAoc3RyaW5nX29mX2ZtdHR5IGZtdHR5KVxuXG4oKiBDb252ZXJ0IGEgc3RyaW5nIHRvIGEgZm9ybWF0IGNvbXBhdGlibGUgd2l0aCBhbiBvdGhlciBmb3JtYXQuICopXG4oKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhbiBlcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCBmb3JtYXRfb2Zfc3RyaW5nX2Zvcm1hdCBzdHIgKEZvcm1hdCAoZm10Jywgc3RyJykpID1cbiAgbGV0IEZtdF9FQkIgZm10ID0gZm10X2ViYl9vZl9zdHJpbmcgc3RyIGluXG4gIHRyeSBGb3JtYXQgKHR5cGVfZm9ybWF0IGZtdCAoZm10dHlfb2ZfZm10IGZtdCcpLCBzdHIpXG4gIHdpdGggVHlwZV9taXNtYXRjaCAtPlxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgIFwiYmFkIGlucHV0OiBmb3JtYXQgdHlwZSBtaXNtYXRjaCBiZXR3ZWVuICVTIGFuZCAlU1wiIHN0ciBzdHInXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gUHJpbnRmXG5cbmxldCBwcmludGVycyA9IHJlZiBbXVxuXG5sZXQgbG9jZm10ID0gZm9ybWF0X29mX3N0cmluZyBcIkZpbGUgXFxcIiVzXFxcIiwgbGluZSAlZCwgY2hhcmFjdGVycyAlZC0lZDogJXNcIlxuXG5sZXQgZmllbGQgeCBpID1cbiAgbGV0IGYgPSBPYmouZmllbGQgeCBpIGluXG4gIGlmIG5vdCAoT2JqLmlzX2Jsb2NrIGYpIHRoZW5cbiAgICBzcHJpbnRmIFwiJWRcIiAoT2JqLm1hZ2ljIGYgOiBpbnQpICAgICAgICAgICAoKiBjYW4gYWxzbyBiZSBhIGNoYXIgKilcbiAgZWxzZSBpZiBPYmoudGFnIGYgPSBPYmouc3RyaW5nX3RhZyB0aGVuXG4gICAgc3ByaW50ZiBcIiVTXCIgKE9iai5tYWdpYyBmIDogc3RyaW5nKVxuICBlbHNlIGlmIE9iai50YWcgZiA9IE9iai5kb3VibGVfdGFnIHRoZW5cbiAgICBzdHJpbmdfb2ZfZmxvYXQgKE9iai5tYWdpYyBmIDogZmxvYXQpXG4gIGVsc2VcbiAgICBcIl9cIlxuXG5sZXQgcmVjIG90aGVyX2ZpZWxkcyB4IGkgPVxuICBpZiBpID49IE9iai5zaXplIHggdGhlbiBcIlwiXG4gIGVsc2Ugc3ByaW50ZiBcIiwgJXMlc1wiIChmaWVsZCB4IGkpIChvdGhlcl9maWVsZHMgeCAoaSsxKSlcblxubGV0IGZpZWxkcyB4ID1cbiAgbWF0Y2ggT2JqLnNpemUgeCB3aXRoXG4gIHwgMCAtPiBcIlwiXG4gIHwgMSAtPiBcIlwiXG4gIHwgMiAtPiBzcHJpbnRmIFwiKCVzKVwiIChmaWVsZCB4IDEpXG4gIHwgXyAtPiBzcHJpbnRmIFwiKCVzJXMpXCIgKGZpZWxkIHggMSkgKG90aGVyX2ZpZWxkcyB4IDIpXG5cbmxldCB0b19zdHJpbmcgeCA9XG4gIGxldCByZWMgY29udiA9IGZ1bmN0aW9uXG4gICAgfCBoZCA6OiB0bCAtPlxuICAgICAgICAobWF0Y2ggdHJ5IGhkIHggd2l0aCBfIC0+IE5vbmUgd2l0aFxuICAgICAgICB8IFNvbWUgcyAtPiBzXG4gICAgICAgIHwgTm9uZSAtPiBjb252IHRsKVxuICAgIHwgW10gLT5cbiAgICAgICAgbWF0Y2ggeCB3aXRoXG4gICAgICAgIHwgT3V0X29mX21lbW9yeSAtPiBcIk91dCBvZiBtZW1vcnlcIlxuICAgICAgICB8IFN0YWNrX292ZXJmbG93IC0+IFwiU3RhY2sgb3ZlcmZsb3dcIlxuICAgICAgICB8IE1hdGNoX2ZhaWx1cmUoZmlsZSwgbGluZSwgY2hhcikgLT5cbiAgICAgICAgICAgIHNwcmludGYgbG9jZm10IGZpbGUgbGluZSBjaGFyIChjaGFyKzUpIFwiUGF0dGVybiBtYXRjaGluZyBmYWlsZWRcIlxuICAgICAgICB8IEFzc2VydF9mYWlsdXJlKGZpbGUsIGxpbmUsIGNoYXIpIC0+XG4gICAgICAgICAgICBzcHJpbnRmIGxvY2ZtdCBmaWxlIGxpbmUgY2hhciAoY2hhcis2KSBcIkFzc2VydGlvbiBmYWlsZWRcIlxuICAgICAgICB8IFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlKGZpbGUsIGxpbmUsIGNoYXIpIC0+XG4gICAgICAgICAgICBzcHJpbnRmIGxvY2ZtdCBmaWxlIGxpbmUgY2hhciAoY2hhcis2KSBcIlVuZGVmaW5lZCByZWN1cnNpdmUgbW9kdWxlXCJcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICBsZXQgeCA9IE9iai5yZXByIHggaW5cbiAgICAgICAgICAgIGlmIE9iai50YWcgeCA8PiAwIHRoZW5cbiAgICAgICAgICAgICAgKE9iai5tYWdpYyAoT2JqLmZpZWxkIHggMCkgOiBzdHJpbmcpXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCBjb25zdHJ1Y3RvciA9XG4gICAgICAgICAgICAgICAgKE9iai5tYWdpYyAoT2JqLmZpZWxkIChPYmouZmllbGQgeCAwKSAwKSA6IHN0cmluZykgaW5cbiAgICAgICAgICAgICAgY29uc3RydWN0b3IgXiAoZmllbGRzIHgpIGluXG4gIGNvbnYgIXByaW50ZXJzXG5cbmxldCBwcmludCBmY3QgYXJnID1cbiAgdHJ5XG4gICAgZmN0IGFyZ1xuICB3aXRoIHggLT5cbiAgICBlcHJpbnRmIFwiVW5jYXVnaHQgZXhjZXB0aW9uOiAlc1xcblwiICh0b19zdHJpbmcgeCk7XG4gICAgZmx1c2ggc3RkZXJyO1xuICAgIHJhaXNlIHhcblxubGV0IGNhdGNoIGZjdCBhcmcgPVxuICB0cnlcbiAgICBmY3QgYXJnXG4gIHdpdGggeCAtPlxuICAgIGZsdXNoIHN0ZG91dDtcbiAgICBlcHJpbnRmIFwiVW5jYXVnaHQgZXhjZXB0aW9uOiAlc1xcblwiICh0b19zdHJpbmcgeCk7XG4gICAgZXhpdCAyXG5cbnR5cGUgcmF3X2JhY2t0cmFjZV9zbG90XG50eXBlIHJhd19iYWNrdHJhY2VcblxuZXh0ZXJuYWwgZ2V0X3Jhd19iYWNrdHJhY2U6XG4gIHVuaXQgLT4gcmF3X2JhY2t0cmFjZSA9IFwiY2FtbF9nZXRfZXhjZXB0aW9uX3Jhd19iYWNrdHJhY2VcIlxuXG5leHRlcm5hbCByYWlzZV93aXRoX2JhY2t0cmFjZTogZXhuIC0+IHJhd19iYWNrdHJhY2UgLT4gJ2FcbiAgPSBcIiVyYWlzZV93aXRoX2JhY2t0cmFjZVwiXG5cbnR5cGUgYmFja3RyYWNlX3Nsb3QgPVxuICB8IEtub3duX2xvY2F0aW9uIG9mIHtcbiAgICAgIGlzX3JhaXNlICAgIDogYm9vbDtcbiAgICAgIGZpbGVuYW1lICAgIDogc3RyaW5nO1xuICAgICAgbGluZV9udW1iZXIgOiBpbnQ7XG4gICAgICBzdGFydF9jaGFyICA6IGludDtcbiAgICAgIGVuZF9jaGFyICAgIDogaW50O1xuICAgICAgaXNfaW5saW5lICAgOiBib29sO1xuICAgIH1cbiAgfCBVbmtub3duX2xvY2F0aW9uIG9mIHtcbiAgICAgIGlzX3JhaXNlIDogYm9vbFxuICAgIH1cblxuKCogdG8gYXZvaWQgd2FybmluZyAqKVxubGV0IF8gPSBbS25vd25fbG9jYXRpb24geyBpc19yYWlzZSA9IGZhbHNlOyBmaWxlbmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVfbnVtYmVyID0gMDsgc3RhcnRfY2hhciA9IDA7IGVuZF9jaGFyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaXNfaW5saW5lID0gZmFsc2UgfTtcbiAgICAgICAgIFVua25vd25fbG9jYXRpb24geyBpc19yYWlzZSA9IGZhbHNlIH1dXG5cbmV4dGVybmFsIGNvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90OlxuICByYXdfYmFja3RyYWNlX3Nsb3QgLT4gYmFja3RyYWNlX3Nsb3QgPSBcImNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3RcIlxuXG5leHRlcm5hbCBjb252ZXJ0X3Jhd19iYWNrdHJhY2U6XG4gIHJhd19iYWNrdHJhY2UgLT4gYmFja3RyYWNlX3Nsb3QgYXJyYXkgPSBcImNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlXCJcblxubGV0IGNvbnZlcnRfcmF3X2JhY2t0cmFjZSBidCA9XG4gIHRyeSBTb21lIChjb252ZXJ0X3Jhd19iYWNrdHJhY2UgYnQpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxubGV0IGZvcm1hdF9iYWNrdHJhY2Vfc2xvdCBwb3Mgc2xvdCA9XG4gIGxldCBpbmZvIGlzX3JhaXNlID1cbiAgICBpZiBpc19yYWlzZSB0aGVuXG4gICAgICBpZiBwb3MgPSAwIHRoZW4gXCJSYWlzZWQgYXRcIiBlbHNlIFwiUmUtcmFpc2VkIGF0XCJcbiAgICBlbHNlXG4gICAgICBpZiBwb3MgPSAwIHRoZW4gXCJSYWlzZWQgYnkgcHJpbWl0aXZlIG9wZXJhdGlvbiBhdFwiIGVsc2UgXCJDYWxsZWQgZnJvbVwiXG4gIGluXG4gIG1hdGNoIHNsb3Qgd2l0aFxuICB8IFVua25vd25fbG9jYXRpb24gbCAtPlxuICAgICAgaWYgbC5pc19yYWlzZSB0aGVuXG4gICAgICAgICgqIGNvbXBpbGVyLWluc2VydGVkIHJlLXJhaXNlLCBza2lwcGVkICopIE5vbmVcbiAgICAgIGVsc2VcbiAgICAgICAgU29tZSAoc3ByaW50ZiBcIiVzIHVua25vd24gbG9jYXRpb25cIiAoaW5mbyBmYWxzZSkpXG4gIHwgS25vd25fbG9jYXRpb24gbCAtPlxuICAgICAgU29tZSAoc3ByaW50ZiBcIiVzIGZpbGUgXFxcIiVzXFxcIiVzLCBsaW5lICVkLCBjaGFyYWN0ZXJzICVkLSVkXCJcbiAgICAgICAgICAgICAgKGluZm8gbC5pc19yYWlzZSkgbC5maWxlbmFtZVxuICAgICAgICAgICAgICAoaWYgbC5pc19pbmxpbmUgdGhlbiBcIiAoaW5saW5lZClcIiBlbHNlIFwiXCIpXG4gICAgICAgICAgICAgIGwubGluZV9udW1iZXIgbC5zdGFydF9jaGFyIGwuZW5kX2NoYXIpXG5cbmxldCBwcmludF9leGNlcHRpb25fYmFja3RyYWNlIG91dGNoYW4gYmFja3RyYWNlID1cbiAgbWF0Y2ggYmFja3RyYWNlIHdpdGhcbiAgfCBOb25lIC0+XG4gICAgICBmcHJpbnRmIG91dGNoYW5cbiAgICAgICAgXCIoUHJvZ3JhbSBub3QgbGlua2VkIHdpdGggLWcsIGNhbm5vdCBwcmludCBzdGFjayBiYWNrdHJhY2UpXFxuXCJcbiAgfCBTb21lIGEgLT5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggYSAtIDEgZG9cbiAgICAgICAgbWF0Y2ggZm9ybWF0X2JhY2t0cmFjZV9zbG90IGkgYS4oaSkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgIHwgU29tZSBzdHIgLT4gZnByaW50ZiBvdXRjaGFuIFwiJXNcXG5cIiBzdHJcbiAgICAgIGRvbmVcblxubGV0IHByaW50X3Jhd19iYWNrdHJhY2Ugb3V0Y2hhbiByYXdfYmFja3RyYWNlID1cbiAgcHJpbnRfZXhjZXB0aW9uX2JhY2t0cmFjZSBvdXRjaGFuIChjb252ZXJ0X3Jhd19iYWNrdHJhY2UgcmF3X2JhY2t0cmFjZSlcblxuKCogY29uZnVzaW5nbHkgbmFtZWQ6IHByaW50cyB0aGUgZ2xvYmFsIGN1cnJlbnQgYmFja3RyYWNlICopXG5sZXQgcHJpbnRfYmFja3RyYWNlIG91dGNoYW4gPVxuICBwcmludF9yYXdfYmFja3RyYWNlIG91dGNoYW4gKGdldF9yYXdfYmFja3RyYWNlICgpKVxuXG5sZXQgYmFja3RyYWNlX3RvX3N0cmluZyBiYWNrdHJhY2UgPVxuICBtYXRjaCBiYWNrdHJhY2Ugd2l0aFxuICB8IE5vbmUgLT5cbiAgICAgXCIoUHJvZ3JhbSBub3QgbGlua2VkIHdpdGggLWcsIGNhbm5vdCBwcmludCBzdGFjayBiYWNrdHJhY2UpXFxuXCJcbiAgfCBTb21lIGEgLT5cbiAgICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAxMDI0IGluXG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGEgLSAxIGRvXG4gICAgICAgIG1hdGNoIGZvcm1hdF9iYWNrdHJhY2Vfc2xvdCBpIGEuKGkpIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICB8IFNvbWUgc3RyIC0+IGJwcmludGYgYiBcIiVzXFxuXCIgc3RyXG4gICAgICBkb25lO1xuICAgICAgQnVmZmVyLmNvbnRlbnRzIGJcblxubGV0IHJhd19iYWNrdHJhY2VfdG9fc3RyaW5nIHJhd19iYWNrdHJhY2UgPVxuICBiYWNrdHJhY2VfdG9fc3RyaW5nIChjb252ZXJ0X3Jhd19iYWNrdHJhY2UgcmF3X2JhY2t0cmFjZSlcblxubGV0IGJhY2t0cmFjZV9zbG90X2lzX3JhaXNlID0gZnVuY3Rpb25cbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+IGwuaXNfcmFpc2VcbiAgfCBVbmtub3duX2xvY2F0aW9uIGwgLT4gbC5pc19yYWlzZVxuXG5sZXQgYmFja3RyYWNlX3Nsb3RfaXNfaW5saW5lID0gZnVuY3Rpb25cbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+IGwuaXNfaW5saW5lXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBfIC0+IGZhbHNlXG5cbnR5cGUgbG9jYXRpb24gPSB7XG4gIGZpbGVuYW1lIDogc3RyaW5nO1xuICBsaW5lX251bWJlciA6IGludDtcbiAgc3RhcnRfY2hhciA6IGludDtcbiAgZW5kX2NoYXIgOiBpbnQ7XG59XG5cbmxldCBiYWNrdHJhY2Vfc2xvdF9sb2NhdGlvbiA9IGZ1bmN0aW9uXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBfIC0+IE5vbmVcbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+XG4gICAgU29tZSB7XG4gICAgICBmaWxlbmFtZSAgICA9IGwuZmlsZW5hbWU7XG4gICAgICBsaW5lX251bWJlciA9IGwubGluZV9udW1iZXI7XG4gICAgICBzdGFydF9jaGFyICA9IGwuc3RhcnRfY2hhcjtcbiAgICAgIGVuZF9jaGFyICAgID0gbC5lbmRfY2hhcjtcbiAgICB9XG5cbmxldCBiYWNrdHJhY2Vfc2xvdHMgcmF3X2JhY2t0cmFjZSA9XG4gICgqIFRoZSBkb2N1bWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gZ3VhcmFudGVlcyB0aGF0IFNvbWUgaXNcbiAgICAgcmV0dXJuZWQgb25seSBpZiBhIHBhcnQgb2YgdGhlIHRyYWNlIGlzIHVzYWJsZS4gVGhpcyBnaXZlcyB1c1xuICAgICBhIGJpdCBtb3JlIHdvcmsgdGhhbiBqdXN0IGNvbnZlcnRfcmF3X2JhY2t0cmFjZSwgYnV0IGl0IG1ha2VzIHRoZVxuICAgICBBUEkgbW9yZSB1c2VyLWZyaWVuZGx5IC0tIG90aGVyd2lzZSBtb3N0IHVzZXJzIHdvdWxkIGhhdmUgdG9cbiAgICAgcmVpbXBsZW1lbnQgdGhlIFwiUHJvZ3JhbSBub3QgbGlua2VkIHdpdGggLWcsIHNvcnJ5XCIgbG9naWNcbiAgICAgdGhlbXNlbHZlcy4gKilcbiAgbWF0Y2ggY29udmVydF9yYXdfYmFja3RyYWNlIHJhd19iYWNrdHJhY2Ugd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIGJhY2t0cmFjZSAtPlxuICAgICAgbGV0IHVzYWJsZV9zbG90ID0gZnVuY3Rpb25cbiAgICAgICAgfCBVbmtub3duX2xvY2F0aW9uIF8gLT4gZmFsc2VcbiAgICAgICAgfCBLbm93bl9sb2NhdGlvbiBfIC0+IHRydWUgaW5cbiAgICAgIGxldCByZWMgZXhpc3RzX3VzYWJsZSA9IGZ1bmN0aW9uXG4gICAgICAgIHwgKC0xKSAtPiBmYWxzZVxuICAgICAgICB8IGkgLT4gdXNhYmxlX3Nsb3QgYmFja3RyYWNlLihpKSB8fCBleGlzdHNfdXNhYmxlIChpIC0gMSkgaW5cbiAgICAgIGlmIGV4aXN0c191c2FibGUgKEFycmF5Lmxlbmd0aCBiYWNrdHJhY2UgLSAxKVxuICAgICAgdGhlbiBTb21lIGJhY2t0cmFjZVxuICAgICAgZWxzZSBOb25lXG5cbm1vZHVsZSBTbG90ID0gc3RydWN0XG4gIHR5cGUgdCA9IGJhY2t0cmFjZV9zbG90XG4gIGxldCBmb3JtYXQgPSBmb3JtYXRfYmFja3RyYWNlX3Nsb3RcbiAgbGV0IGlzX3JhaXNlID0gYmFja3RyYWNlX3Nsb3RfaXNfcmFpc2VcbiAgbGV0IGlzX2lubGluZSA9IGJhY2t0cmFjZV9zbG90X2lzX2lubGluZVxuICBsZXQgbG9jYXRpb24gPSBiYWNrdHJhY2Vfc2xvdF9sb2NhdGlvblxuZW5kXG5cbmV4dGVybmFsIHJhd19iYWNrdHJhY2VfbGVuZ3RoIDpcbiAgcmF3X2JhY2t0cmFjZSAtPiBpbnQgPSBcImNhbWxfcmF3X2JhY2t0cmFjZV9sZW5ndGhcIiBbQEBub2FsbG9jXVxuXG5leHRlcm5hbCBnZXRfcmF3X2JhY2t0cmFjZV9zbG90IDpcbiAgcmF3X2JhY2t0cmFjZSAtPiBpbnQgLT4gcmF3X2JhY2t0cmFjZV9zbG90ID0gXCJjYW1sX3Jhd19iYWNrdHJhY2Vfc2xvdFwiXG5cbmV4dGVybmFsIGdldF9yYXdfYmFja3RyYWNlX25leHRfc2xvdCA6XG4gIHJhd19iYWNrdHJhY2Vfc2xvdCAtPiByYXdfYmFja3RyYWNlX3Nsb3Qgb3B0aW9uXG4gID0gXCJjYW1sX3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90XCJcblxuKCogY29uZnVzaW5nbHkgbmFtZWQ6XG4gICByZXR1cm5zIHRoZSAqc3RyaW5nKiBjb3JyZXNwb25kaW5nIHRvIHRoZSBnbG9iYWwgY3VycmVudCBiYWNrdHJhY2UgKilcbmxldCBnZXRfYmFja3RyYWNlICgpID0gcmF3X2JhY2t0cmFjZV90b19zdHJpbmcgKGdldF9yYXdfYmFja3RyYWNlICgpKVxuXG5leHRlcm5hbCByZWNvcmRfYmFja3RyYWNlOiBib29sIC0+IHVuaXQgPSBcImNhbWxfcmVjb3JkX2JhY2t0cmFjZVwiXG5leHRlcm5hbCBiYWNrdHJhY2Vfc3RhdHVzOiB1bml0IC0+IGJvb2wgPSBcImNhbWxfYmFja3RyYWNlX3N0YXR1c1wiXG5cbmxldCByZWdpc3Rlcl9wcmludGVyIGZuID1cbiAgcHJpbnRlcnMgOj0gZm4gOjogIXByaW50ZXJzXG5cbmV4dGVybmFsIGdldF9jYWxsc3RhY2s6IGludCAtPiByYXdfYmFja3RyYWNlID0gXCJjYW1sX2dldF9jdXJyZW50X2NhbGxzdGFja1wiXG5cbmxldCBleG5fc2xvdCB4ID1cbiAgbGV0IHggPSBPYmoucmVwciB4IGluXG4gIGlmIE9iai50YWcgeCA9IDAgdGhlbiBPYmouZmllbGQgeCAwIGVsc2UgeFxuXG5sZXQgZXhuX3Nsb3RfaWQgeCA9XG4gIGxldCBzbG90ID0gZXhuX3Nsb3QgeCBpblxuICAoT2JqLm9iaiAoT2JqLmZpZWxkIHNsb3QgMSkgOiBpbnQpXG5cbmxldCBleG5fc2xvdF9uYW1lIHggPVxuICBsZXQgc2xvdCA9IGV4bl9zbG90IHggaW5cbiAgKE9iai5vYmogKE9iai5maWVsZCBzbG90IDApIDogc3RyaW5nKVxuXG5cbmxldCB1bmNhdWdodF9leGNlcHRpb25faGFuZGxlciA9IHJlZiBOb25lXG5cbmxldCBzZXRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgZm4gPSB1bmNhdWdodF9leGNlcHRpb25faGFuZGxlciA6PSBTb21lIGZuXG5cbmxldCBlbXB0eV9iYWNrdHJhY2UgOiByYXdfYmFja3RyYWNlID0gT2JqLm9iaiAoT2JqLm5ld19ibG9jayBPYmouYWJzdHJhY3RfdGFnIDApXG5cbmxldCB0cnlfZ2V0X3Jhd19iYWNrdHJhY2UgKCkgPVxuICB0cnlcbiAgICBnZXRfcmF3X2JhY2t0cmFjZSAoKVxuICB3aXRoIF8gKCogT3V0X29mX21lbW9yeT8gKikgLT5cbiAgICBlbXB0eV9iYWNrdHJhY2VcblxubGV0IGhhbmRsZV91bmNhdWdodF9leGNlcHRpb24nIGV4biBkZWJ1Z2dlcl9pbl91c2UgPVxuICB0cnlcbiAgICAoKiBHZXQgdGhlIGJhY2t0cmFjZSBub3csIGluIGNhc2Ugb25lIG9mIHRoZSBbYXRfZXhpdF0gZnVuY3Rpb25cbiAgICAgICBkZXN0cm95cyBpdC4gKilcbiAgICBsZXQgcmF3X2JhY2t0cmFjZSA9XG4gICAgICBpZiBkZWJ1Z2dlcl9pbl91c2UgKCogU2FtZSB0ZXN0IGFzIGluIFtieXRlcnVuL3ByaW50ZXhjLmNdICopIHRoZW5cbiAgICAgICAgZW1wdHlfYmFja3RyYWNlXG4gICAgICBlbHNlXG4gICAgICAgIHRyeV9nZXRfcmF3X2JhY2t0cmFjZSAoKVxuICAgIGluXG4gICAgKHRyeSBQZXJ2YXNpdmVzLmRvX2F0X2V4aXQgKCkgd2l0aCBfIC0+ICgpKTtcbiAgICBtYXRjaCAhdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgd2l0aFxuICAgIHwgTm9uZSAtPlxuICAgICAgICBlcHJpbnRmIFwiRmF0YWwgZXJyb3I6IGV4Y2VwdGlvbiAlc1xcblwiICh0b19zdHJpbmcgZXhuKTtcbiAgICAgICAgcHJpbnRfcmF3X2JhY2t0cmFjZSBzdGRlcnIgcmF3X2JhY2t0cmFjZTtcbiAgICAgICAgZmx1c2ggc3RkZXJyXG4gICAgfCBTb21lIGhhbmRsZXIgLT5cbiAgICAgICAgdHJ5XG4gICAgICAgICAgaGFuZGxlciBleG4gcmF3X2JhY2t0cmFjZVxuICAgICAgICB3aXRoIGV4bicgLT5cbiAgICAgICAgICBsZXQgcmF3X2JhY2t0cmFjZScgPSB0cnlfZ2V0X3Jhd19iYWNrdHJhY2UgKCkgaW5cbiAgICAgICAgICBlcHJpbnRmIFwiRmF0YWwgZXJyb3I6IGV4Y2VwdGlvbiAlc1xcblwiICh0b19zdHJpbmcgZXhuKTtcbiAgICAgICAgICBwcmludF9yYXdfYmFja3RyYWNlIHN0ZGVyciByYXdfYmFja3RyYWNlO1xuICAgICAgICAgIGVwcmludGYgXCJGYXRhbCBlcnJvciBpbiB1bmNhdWdodCBleGNlcHRpb24gaGFuZGxlcjogZXhjZXB0aW9uICVzXFxuXCJcbiAgICAgICAgICAgICh0b19zdHJpbmcgZXhuJyk7XG4gICAgICAgICAgcHJpbnRfcmF3X2JhY2t0cmFjZSBzdGRlcnIgcmF3X2JhY2t0cmFjZSc7XG4gICAgICAgICAgZmx1c2ggc3RkZXJyXG4gIHdpdGhcbiAgICB8IE91dF9vZl9tZW1vcnkgLT5cbiAgICAgICAgcHJlcnJfZW5kbGluZVxuICAgICAgICAgIFwiRmF0YWwgZXJyb3I6IG91dCBvZiBtZW1vcnkgaW4gdW5jYXVnaHQgZXhjZXB0aW9uIGhhbmRsZXJcIlxuXG4oKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBieSBbY2FtbF9mYXRhbF91bmNhdWdodF9leGNlcHRpb25dIGluXG4gICBbYnl0ZXJ1bi9wcmludGV4Yy5jXSB3aGljaCBleHBlY3RzIG5vIGV4Y2VwdGlvbiBpcyByYWlzZWQuICopXG5sZXQgaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvbiBleG4gZGVidWdnZXJfaW5fdXNlID1cbiAgdHJ5XG4gICAgaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvbicgZXhuIGRlYnVnZ2VyX2luX3VzZVxuICB3aXRoIF8gLT5cbiAgICAoKiBUaGVyZSBpcyBub3QgbXVjaCB3ZSBjYW4gZG8gYXQgdGhpcyBwb2ludCAqKVxuICAgICgpXG5cbmV4dGVybmFsIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIDogc3RyaW5nIC0+ICdhIC0+IHVuaXRcbiAgPSBcImNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWVcIlxuXG5sZXQgKCkgPVxuICByZWdpc3Rlcl9uYW1lZF92YWx1ZSBcIlByaW50ZXhjLmhhbmRsZV91bmNhdWdodF9leGNlcHRpb25cIlxuICAgIGhhbmRsZV91bmNhdWdodF9leGNlcHRpb25cbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICBYYXZpZXIgTGVyb3kgYW5kIERhbWllbiBEb2xpZ2V6LCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubGV0IGdlbmVyaWNfcXVvdGUgcXVvdGVxdW90ZSBzID1cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIChsICsgMjApIGluXG4gIEJ1ZmZlci5hZGRfY2hhciBiICdcXCcnO1xuICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICBpZiBzLltpXSA9ICdcXCcnXG4gICAgdGhlbiBCdWZmZXIuYWRkX3N0cmluZyBiIHF1b3RlcXVvdGVcbiAgICBlbHNlIEJ1ZmZlci5hZGRfY2hhciBiICBzLltpXVxuICBkb25lO1xuICBCdWZmZXIuYWRkX2NoYXIgYiAnXFwnJztcbiAgQnVmZmVyLmNvbnRlbnRzIGJcblxuKCogVGhpcyBmdW5jdGlvbiBpbXBsZW1lbnRzIHRoZSBPcGVuIEdyb3VwIHNwZWNpZmljYXRpb24gZm91bmQgaGVyZTpcbiAgW1sxXV0gaHR0cDovL3B1YnMub3Blbmdyb3VwLm9yZy9vbmxpbmVwdWJzLzk2OTk5MTk3OTkvdXRpbGl0aWVzL2Jhc2VuYW1lLmh0bWxcbiAgSW4gc3RlcCAxIG9mIFtbMV1dLCB3ZSBjaG9vc2UgdG8gcmV0dXJuIFwiLlwiIGZvciBlbXB0eSBpbnB1dC5cbiAgICAoZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBwcmV2aW91cyB2ZXJzaW9ucyBvZiBPQ2FtbClcbiAgSW4gc3RlcCAyLCB3ZSBjaG9vc2UgdG8gcHJvY2VzcyBcIi8vXCIgbm9ybWFsbHkuXG4gIFN0ZXAgNiBpcyBub3QgaW1wbGVtZW50ZWQ6IHdlIGNvbnNpZGVyIHRoYXQgdGhlIFtzdWZmaXhdIG9wZXJhbmQgaXNcbiAgICBhbHdheXMgYWJzZW50LiAgU3VmZml4ZXMgYXJlIGhhbmRsZWQgYnkgW2Nob3Bfc3VmZml4XSBhbmQgW2Nob3BfZXh0ZW5zaW9uXS5cbiopXG5sZXQgZ2VuZXJpY19iYXNlbmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWUgbmFtZSA9XG4gIGxldCByZWMgZmluZF9lbmQgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCAxXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIGZpbmRfZW5kIChuIC0gMSlcbiAgICBlbHNlIGZpbmRfYmVnIG4gKG4gKyAxKVxuICBhbmQgZmluZF9iZWcgbiBwID1cbiAgICBpZiBuIDwgMCB0aGVuIFN0cmluZy5zdWIgbmFtZSAwIHBcbiAgICBlbHNlIGlmIGlzX2Rpcl9zZXAgbmFtZSBuIHRoZW4gU3RyaW5nLnN1YiBuYW1lIChuICsgMSkgKHAgLSBuIC0gMSlcbiAgICBlbHNlIGZpbmRfYmVnIChuIC0gMSkgcFxuICBpblxuICBpZiBuYW1lID0gXCJcIlxuICB0aGVuIGN1cnJlbnRfZGlyX25hbWVcbiAgZWxzZSBmaW5kX2VuZCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gMSlcblxuKCogVGhpcyBmdW5jdGlvbiBpbXBsZW1lbnRzIHRoZSBPcGVuIEdyb3VwIHNwZWNpZmljYXRpb24gZm91bmQgaGVyZTpcbiAgW1syXV0gaHR0cDovL3B1YnMub3Blbmdyb3VwLm9yZy9vbmxpbmVwdWJzLzk2OTk5MTk3OTkvdXRpbGl0aWVzL2Rpcm5hbWUuaHRtbFxuICBJbiBzdGVwIDYgb2YgW1syXV0sIHdlIGNob29zZSB0byBwcm9jZXNzIFwiLy9cIiBub3JtYWxseS5cbiopXG5sZXQgZ2VuZXJpY19kaXJuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZSBuYW1lID1cbiAgbGV0IHJlYyB0cmFpbGluZ19zZXAgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCAxXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIHRyYWlsaW5nX3NlcCAobiAtIDEpXG4gICAgZWxzZSBiYXNlIG5cbiAgYW5kIGJhc2UgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBjdXJyZW50X2Rpcl9uYW1lXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIGludGVybWVkaWF0ZV9zZXAgblxuICAgIGVsc2UgYmFzZSAobiAtIDEpXG4gIGFuZCBpbnRlcm1lZGlhdGVfc2VwIG4gPVxuICAgIGlmIG4gPCAwIHRoZW4gU3RyaW5nLnN1YiBuYW1lIDAgMVxuICAgIGVsc2UgaWYgaXNfZGlyX3NlcCBuYW1lIG4gdGhlbiBpbnRlcm1lZGlhdGVfc2VwIChuIC0gMSlcbiAgICBlbHNlIFN0cmluZy5zdWIgbmFtZSAwIChuICsgMSlcbiAgaW5cbiAgaWYgbmFtZSA9IFwiXCJcbiAgdGhlbiBjdXJyZW50X2Rpcl9uYW1lXG4gIGVsc2UgdHJhaWxpbmdfc2VwIChTdHJpbmcubGVuZ3RoIG5hbWUgLSAxKVxuXG5tb2R1bGUgVW5peCA9IHN0cnVjdFxuICBsZXQgY3VycmVudF9kaXJfbmFtZSA9IFwiLlwiXG4gIGxldCBwYXJlbnRfZGlyX25hbWUgPSBcIi4uXCJcbiAgbGV0IGRpcl9zZXAgPSBcIi9cIlxuICBsZXQgaXNfZGlyX3NlcCBzIGkgPSBzLltpXSA9ICcvJ1xuICBsZXQgaXNfcmVsYXRpdmUgbiA9IFN0cmluZy5sZW5ndGggbiA8IDEgfHwgbi5bMF0gPD4gJy8nXG4gIGxldCBpc19pbXBsaWNpdCBuID1cbiAgICBpc19yZWxhdGl2ZSBuXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDIgfHwgU3RyaW5nLnN1YiBuIDAgMiA8PiBcIi4vXCIpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDMgfHwgU3RyaW5nLnN1YiBuIDAgMyA8PiBcIi4uL1wiKVxuICBsZXQgY2hlY2tfc3VmZml4IG5hbWUgc3VmZiA9XG4gICAgU3RyaW5nLmxlbmd0aCBuYW1lID49IFN0cmluZy5sZW5ndGggc3VmZiAmJlxuICAgIFN0cmluZy5zdWIgbmFtZSAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gU3RyaW5nLmxlbmd0aCBzdWZmKVxuICAgICAgICAgICAgICAgICAgICAoU3RyaW5nLmxlbmd0aCBzdWZmKSA9IHN1ZmZcbiAgbGV0IHRlbXBfZGlyX25hbWUgPVxuICAgIHRyeSBTeXMuZ2V0ZW52IFwiVE1QRElSXCIgd2l0aCBOb3RfZm91bmQgLT4gXCIvdG1wXCJcbiAgbGV0IHF1b3RlID0gZ2VuZXJpY19xdW90ZSBcIidcXFxcJydcIlxuICBsZXQgYmFzZW5hbWUgPSBnZW5lcmljX2Jhc2VuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZVxuICBsZXQgZGlybmFtZSA9IGdlbmVyaWNfZGlybmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWVcbmVuZFxuXG5tb2R1bGUgV2luMzIgPSBzdHJ1Y3RcbiAgbGV0IGN1cnJlbnRfZGlyX25hbWUgPSBcIi5cIlxuICBsZXQgcGFyZW50X2Rpcl9uYW1lID0gXCIuLlwiXG4gIGxldCBkaXJfc2VwID0gXCJcXFxcXCJcbiAgbGV0IGlzX2Rpcl9zZXAgcyBpID0gbGV0IGMgPSBzLltpXSBpbiBjID0gJy8nIHx8IGMgPSAnXFxcXCcgfHwgYyA9ICc6J1xuICBsZXQgaXNfcmVsYXRpdmUgbiA9XG4gICAgKFN0cmluZy5sZW5ndGggbiA8IDEgfHwgbi5bMF0gPD4gJy8nKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAxIHx8IG4uWzBdIDw+ICdcXFxcJylcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMiB8fCBuLlsxXSA8PiAnOicpXG4gIGxldCBpc19pbXBsaWNpdCBuID1cbiAgICBpc19yZWxhdGl2ZSBuXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDIgfHwgU3RyaW5nLnN1YiBuIDAgMiA8PiBcIi4vXCIpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDIgfHwgU3RyaW5nLnN1YiBuIDAgMiA8PiBcIi5cXFxcXCIpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDMgfHwgU3RyaW5nLnN1YiBuIDAgMyA8PiBcIi4uL1wiKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAzIHx8IFN0cmluZy5zdWIgbiAwIDMgPD4gXCIuLlxcXFxcIilcbiAgbGV0IGNoZWNrX3N1ZmZpeCBuYW1lIHN1ZmYgPVxuICAgU3RyaW5nLmxlbmd0aCBuYW1lID49IFN0cmluZy5sZW5ndGggc3VmZiAmJlxuICAgKGxldCBzID0gU3RyaW5nLnN1YiBuYW1lIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBTdHJpbmcubGVuZ3RoIHN1ZmYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFN0cmluZy5sZW5ndGggc3VmZikgaW5cbiAgICBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHMgPSBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHN1ZmYpXG4gIGxldCB0ZW1wX2Rpcl9uYW1lID1cbiAgICB0cnkgU3lzLmdldGVudiBcIlRFTVBcIiB3aXRoIE5vdF9mb3VuZCAtPiBcIi5cIlxuICBsZXQgcXVvdGUgcyA9XG4gICAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgKGwgKyAyMCkgaW5cbiAgICBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcIic7XG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA9IGwgdGhlbiBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcIicgZWxzZVxuICAgICAgbWF0Y2ggcy5baV0gd2l0aFxuICAgICAgfCAnXFxcIicgLT4gbG9vcF9icyAwIGk7XG4gICAgICB8ICdcXFxcJyAtPiBsb29wX2JzIDAgaTtcbiAgICAgIHwgYyAgICAtPiBCdWZmZXIuYWRkX2NoYXIgYiBjOyBsb29wIChpKzEpO1xuICAgIGFuZCBsb29wX2JzIG4gaSA9XG4gICAgICBpZiBpID0gbCB0aGVuIGJlZ2luXG4gICAgICAgIEJ1ZmZlci5hZGRfY2hhciBiICdcXFwiJztcbiAgICAgICAgYWRkX2JzIG47XG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBtYXRjaCBzLltpXSB3aXRoXG4gICAgICAgIHwgJ1xcXCInIC0+IGFkZF9icyAoMipuKzEpOyBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcIic7IGxvb3AgKGkrMSk7XG4gICAgICAgIHwgJ1xcXFwnIC0+IGxvb3BfYnMgKG4rMSkgKGkrMSk7XG4gICAgICAgIHwgXyAgICAtPiBhZGRfYnMgbjsgbG9vcCBpXG4gICAgICBlbmRcbiAgICBhbmQgYWRkX2JzIG4gPSBmb3IgX2ogPSAxIHRvIG4gZG8gQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXFwnOyBkb25lXG4gICAgaW5cbiAgICBsb29wIDA7XG4gICAgQnVmZmVyLmNvbnRlbnRzIGJcbiAgbGV0IGhhc19kcml2ZSBzID1cbiAgICBsZXQgaXNfbGV0dGVyID0gZnVuY3Rpb25cbiAgICAgIHwgJ0EnIC4uICdaJyB8ICdhJyAuLiAneicgLT4gdHJ1ZVxuICAgICAgfCBfIC0+IGZhbHNlXG4gICAgaW5cbiAgICBTdHJpbmcubGVuZ3RoIHMgPj0gMiAmJiBpc19sZXR0ZXIgcy5bMF0gJiYgcy5bMV0gPSAnOidcbiAgbGV0IGRyaXZlX2FuZF9wYXRoIHMgPVxuICAgIGlmIGhhc19kcml2ZSBzXG4gICAgdGhlbiAoU3RyaW5nLnN1YiBzIDAgMiwgU3RyaW5nLnN1YiBzIDIgKFN0cmluZy5sZW5ndGggcyAtIDIpKVxuICAgIGVsc2UgKFwiXCIsIHMpXG4gIGxldCBkaXJuYW1lIHMgPVxuICAgIGxldCAoZHJpdmUsIHBhdGgpID0gZHJpdmVfYW5kX3BhdGggcyBpblxuICAgIGxldCBkaXIgPSBnZW5lcmljX2Rpcm5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lIHBhdGggaW5cbiAgICBkcml2ZSBeIGRpclxuICBsZXQgYmFzZW5hbWUgcyA9XG4gICAgbGV0IChfZHJpdmUsIHBhdGgpID0gZHJpdmVfYW5kX3BhdGggcyBpblxuICAgIGdlbmVyaWNfYmFzZW5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lIHBhdGhcbmVuZFxuXG5tb2R1bGUgQ3lnd2luID0gc3RydWN0XG4gIGxldCBjdXJyZW50X2Rpcl9uYW1lID0gXCIuXCJcbiAgbGV0IHBhcmVudF9kaXJfbmFtZSA9IFwiLi5cIlxuICBsZXQgZGlyX3NlcCA9IFwiL1wiXG4gIGxldCBpc19kaXJfc2VwID0gV2luMzIuaXNfZGlyX3NlcFxuICBsZXQgaXNfcmVsYXRpdmUgPSBXaW4zMi5pc19yZWxhdGl2ZVxuICBsZXQgaXNfaW1wbGljaXQgPSBXaW4zMi5pc19pbXBsaWNpdFxuICBsZXQgY2hlY2tfc3VmZml4ID0gV2luMzIuY2hlY2tfc3VmZml4XG4gIGxldCB0ZW1wX2Rpcl9uYW1lID0gVW5peC50ZW1wX2Rpcl9uYW1lXG4gIGxldCBxdW90ZSA9IFVuaXgucXVvdGVcbiAgbGV0IGJhc2VuYW1lID0gZ2VuZXJpY19iYXNlbmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWVcbiAgbGV0IGRpcm5hbWUgPSBnZW5lcmljX2Rpcm5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lXG5lbmRcblxubGV0IChjdXJyZW50X2Rpcl9uYW1lLCBwYXJlbnRfZGlyX25hbWUsIGRpcl9zZXAsIGlzX2Rpcl9zZXAsXG4gICAgIGlzX3JlbGF0aXZlLCBpc19pbXBsaWNpdCwgY2hlY2tfc3VmZml4LCB0ZW1wX2Rpcl9uYW1lLCBxdW90ZSwgYmFzZW5hbWUsXG4gICAgIGRpcm5hbWUpID1cbiAgbWF0Y2ggU3lzLm9zX3R5cGUgd2l0aFxuICB8IFwiV2luMzJcIiAtPlxuICAgICAgKFdpbjMyLmN1cnJlbnRfZGlyX25hbWUsIFdpbjMyLnBhcmVudF9kaXJfbmFtZSwgV2luMzIuZGlyX3NlcCxcbiAgICAgICBXaW4zMi5pc19kaXJfc2VwLFxuICAgICAgIFdpbjMyLmlzX3JlbGF0aXZlLCBXaW4zMi5pc19pbXBsaWNpdCwgV2luMzIuY2hlY2tfc3VmZml4LFxuICAgICAgIFdpbjMyLnRlbXBfZGlyX25hbWUsIFdpbjMyLnF1b3RlLCBXaW4zMi5iYXNlbmFtZSwgV2luMzIuZGlybmFtZSlcbiAgfCBcIkN5Z3dpblwiIC0+XG4gICAgICAoQ3lnd2luLmN1cnJlbnRfZGlyX25hbWUsIEN5Z3dpbi5wYXJlbnRfZGlyX25hbWUsIEN5Z3dpbi5kaXJfc2VwLFxuICAgICAgIEN5Z3dpbi5pc19kaXJfc2VwLFxuICAgICAgIEN5Z3dpbi5pc19yZWxhdGl2ZSwgQ3lnd2luLmlzX2ltcGxpY2l0LCBDeWd3aW4uY2hlY2tfc3VmZml4LFxuICAgICAgIEN5Z3dpbi50ZW1wX2Rpcl9uYW1lLCBDeWd3aW4ucXVvdGUsIEN5Z3dpbi5iYXNlbmFtZSwgQ3lnd2luLmRpcm5hbWUpXG4gIHwgXyAtPiAoKiBub3JtYWxseSBcIlVuaXhcIiAqKVxuICAgICAgKFVuaXguY3VycmVudF9kaXJfbmFtZSwgVW5peC5wYXJlbnRfZGlyX25hbWUsIFVuaXguZGlyX3NlcCxcbiAgICAgICBVbml4LmlzX2Rpcl9zZXAsXG4gICAgICAgVW5peC5pc19yZWxhdGl2ZSwgVW5peC5pc19pbXBsaWNpdCwgVW5peC5jaGVja19zdWZmaXgsXG4gICAgICAgVW5peC50ZW1wX2Rpcl9uYW1lLCBVbml4LnF1b3RlLCBVbml4LmJhc2VuYW1lLCBVbml4LmRpcm5hbWUpXG5cbmxldCBjb25jYXQgZGlybmFtZSBmaWxlbmFtZSA9XG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBkaXJuYW1lIGluXG4gIGlmIGwgPSAwIHx8IGlzX2Rpcl9zZXAgZGlybmFtZSAobC0xKVxuICB0aGVuIGRpcm5hbWUgXiBmaWxlbmFtZVxuICBlbHNlIGRpcm5hbWUgXiBkaXJfc2VwIF4gZmlsZW5hbWVcblxubGV0IGNob3Bfc3VmZml4IG5hbWUgc3VmZiA9XG4gIGxldCBuID0gU3RyaW5nLmxlbmd0aCBuYW1lIC0gU3RyaW5nLmxlbmd0aCBzdWZmIGluXG4gIGlmIG4gPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJGaWxlbmFtZS5jaG9wX3N1ZmZpeFwiIGVsc2UgU3RyaW5nLnN1YiBuYW1lIDAgblxuXG5sZXQgZXh0ZW5zaW9uX2xlbiBuYW1lID1cbiAgbGV0IHJlYyBjaGVjayBpMCBpID1cbiAgICBpZiBpIDwgMCB8fCBpc19kaXJfc2VwIG5hbWUgaSB0aGVuIDBcbiAgICBlbHNlIGlmIG5hbWUuW2ldID0gJy4nIHRoZW4gY2hlY2sgaTAgKGkgLSAxKVxuICAgIGVsc2UgU3RyaW5nLmxlbmd0aCBuYW1lIC0gaTBcbiAgaW5cbiAgbGV0IHJlYyBzZWFyY2hfZG90IGkgPVxuICAgIGlmIGkgPCAwIHx8IGlzX2Rpcl9zZXAgbmFtZSBpIHRoZW4gMFxuICAgIGVsc2UgaWYgbmFtZS5baV0gPSAnLicgdGhlbiBjaGVjayBpIChpIC0gMSlcbiAgICBlbHNlIHNlYXJjaF9kb3QgKGkgLSAxKVxuICBpblxuICBzZWFyY2hfZG90IChTdHJpbmcubGVuZ3RoIG5hbWUgLSAxKVxuXG5sZXQgZXh0ZW5zaW9uIG5hbWUgPVxuICBsZXQgbCA9IGV4dGVuc2lvbl9sZW4gbmFtZSBpblxuICBpZiBsID0gMCB0aGVuIFwiXCIgZWxzZSBTdHJpbmcuc3ViIG5hbWUgKFN0cmluZy5sZW5ndGggbmFtZSAtIGwpIGxcblxubGV0IGNob3BfZXh0ZW5zaW9uIG5hbWUgPVxuICBsZXQgbCA9IGV4dGVuc2lvbl9sZW4gbmFtZSBpblxuICBpZiBsID0gMCB0aGVuIGludmFsaWRfYXJnIFwiRmlsZW5hbWUuY2hvcF9leHRlbnNpb25cIlxuICBlbHNlIFN0cmluZy5zdWIgbmFtZSAwIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBsKVxuXG5sZXQgcmVtb3ZlX2V4dGVuc2lvbiBuYW1lID1cbiAgbGV0IGwgPSBleHRlbnNpb25fbGVuIG5hbWUgaW5cbiAgaWYgbCA9IDAgdGhlbiBuYW1lIGVsc2UgU3RyaW5nLnN1YiBuYW1lIDAgKFN0cmluZy5sZW5ndGggbmFtZSAtIGwpXG5cbmV4dGVybmFsIG9wZW5fZGVzYzogc3RyaW5nIC0+IG9wZW5fZmxhZyBsaXN0IC0+IGludCAtPiBpbnQgPSBcImNhbWxfc3lzX29wZW5cIlxuZXh0ZXJuYWwgY2xvc2VfZGVzYzogaW50IC0+IHVuaXQgPSBcImNhbWxfc3lzX2Nsb3NlXCJcblxubGV0IHBybmcgPSBsYXp5KFJhbmRvbS5TdGF0ZS5tYWtlX3NlbGZfaW5pdCAoKSlcblxubGV0IHRlbXBfZmlsZV9uYW1lIHRlbXBfZGlyIHByZWZpeCBzdWZmaXggPVxuICBsZXQgcm5kID0gKFJhbmRvbS5TdGF0ZS5iaXRzIChMYXp5LmZvcmNlIHBybmcpKSBsYW5kIDB4RkZGRkZGIGluXG4gIGNvbmNhdCB0ZW1wX2RpciAoUHJpbnRmLnNwcmludGYgXCIlcyUwNnglc1wiIHByZWZpeCBybmQgc3VmZml4KVxuXG5cbmxldCBjdXJyZW50X3RlbXBfZGlyX25hbWUgPSByZWYgdGVtcF9kaXJfbmFtZVxuXG5sZXQgc2V0X3RlbXBfZGlyX25hbWUgcyA9IGN1cnJlbnRfdGVtcF9kaXJfbmFtZSA6PSBzXG5sZXQgZ2V0X3RlbXBfZGlyX25hbWUgKCkgPSAhY3VycmVudF90ZW1wX2Rpcl9uYW1lXG5cbmxldCB0ZW1wX2ZpbGUgPyh0ZW1wX2RpciA9ICFjdXJyZW50X3RlbXBfZGlyX25hbWUpIHByZWZpeCBzdWZmaXggPVxuICBsZXQgcmVjIHRyeV9uYW1lIGNvdW50ZXIgPVxuICAgIGxldCBuYW1lID0gdGVtcF9maWxlX25hbWUgdGVtcF9kaXIgcHJlZml4IHN1ZmZpeCBpblxuICAgIHRyeVxuICAgICAgY2xvc2VfZGVzYyhvcGVuX2Rlc2MgbmFtZSBbT3Blbl93cm9ubHk7IE9wZW5fY3JlYXQ7IE9wZW5fZXhjbF0gMG82MDApO1xuICAgICAgbmFtZVxuICAgIHdpdGggU3lzX2Vycm9yIF8gYXMgZSAtPlxuICAgICAgaWYgY291bnRlciA+PSAxMDAwIHRoZW4gcmFpc2UgZSBlbHNlIHRyeV9uYW1lIChjb3VudGVyICsgMSlcbiAgaW4gdHJ5X25hbWUgMFxuXG5sZXQgb3Blbl90ZW1wX2ZpbGUgPyhtb2RlID0gW09wZW5fdGV4dF0pID8ocGVybXMgPSAwbzYwMClcbiAgICAgICAgICAgICAgICAgICA/KHRlbXBfZGlyID0gIWN1cnJlbnRfdGVtcF9kaXJfbmFtZSkgcHJlZml4IHN1ZmZpeCA9XG4gIGxldCByZWMgdHJ5X25hbWUgY291bnRlciA9XG4gICAgbGV0IG5hbWUgPSB0ZW1wX2ZpbGVfbmFtZSB0ZW1wX2RpciBwcmVmaXggc3VmZml4IGluXG4gICAgdHJ5XG4gICAgICAobmFtZSxcbiAgICAgICBvcGVuX291dF9nZW4gKE9wZW5fd3Jvbmx5OjpPcGVuX2NyZWF0OjpPcGVuX2V4Y2w6Om1vZGUpIHBlcm1zIG5hbWUpXG4gICAgd2l0aCBTeXNfZXJyb3IgXyBhcyBlIC0+XG4gICAgICBpZiBjb3VudGVyID49IDEwMDAgdGhlbiByYWlzZSBlIGVsc2UgdHJ5X25hbWUgKGNvdW50ZXIgKyAxKVxuICBpbiB0cnlfbmFtZSAwXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIENvbXBsZXggbnVtYmVycyAqKVxuXG50eXBlIHQgPSB7IHJlOiBmbG9hdDsgaW06IGZsb2F0IH1cblxubGV0IHplcm8gPSB7IHJlID0gMC4wOyBpbSA9IDAuMCB9XG5sZXQgb25lID0geyByZSA9IDEuMDsgaW0gPSAwLjAgfVxubGV0IGkgPSB7IHJlID0gMC4wOyBpbSA9IDEuMCB9XG5cbmxldCBhZGQgeCB5ID0geyByZSA9IHgucmUgKy4geS5yZTsgaW0gPSB4LmltICsuIHkuaW0gfVxuXG5sZXQgc3ViIHggeSA9IHsgcmUgPSB4LnJlIC0uIHkucmU7IGltID0geC5pbSAtLiB5LmltIH1cblxubGV0IG5lZyB4ID0geyByZSA9IC0uIHgucmU7IGltID0gLS4geC5pbSB9XG5cbmxldCBjb25qIHggPSB7IHJlID0geC5yZTsgaW0gPSAtLiB4LmltIH1cblxubGV0IG11bCB4IHkgPSB7IHJlID0geC5yZSAqLiB5LnJlIC0uIHguaW0gKi4geS5pbTtcbiAgICAgICAgICAgICAgICBpbSA9IHgucmUgKi4geS5pbSArLiB4LmltICouIHkucmUgfVxuXG5sZXQgZGl2IHggeSA9XG4gIGlmIGFic19mbG9hdCB5LnJlID49IGFic19mbG9hdCB5LmltIHRoZW5cbiAgICBsZXQgciA9IHkuaW0gLy4geS5yZSBpblxuICAgIGxldCBkID0geS5yZSArLiByICouIHkuaW0gaW5cbiAgICB7IHJlID0gKHgucmUgKy4gciAqLiB4LmltKSAvLiBkO1xuICAgICAgaW0gPSAoeC5pbSAtLiByICouIHgucmUpIC8uIGQgfVxuICBlbHNlXG4gICAgbGV0IHIgPSB5LnJlIC8uIHkuaW0gaW5cbiAgICBsZXQgZCA9IHkuaW0gKy4gciAqLiB5LnJlIGluXG4gICAgeyByZSA9IChyICouIHgucmUgKy4geC5pbSkgLy4gZDtcbiAgICAgIGltID0gKHIgKi4geC5pbSAtLiB4LnJlKSAvLiBkIH1cblxubGV0IGludiB4ID0gZGl2IG9uZSB4XG5cbmxldCBub3JtMiB4ID0geC5yZSAqLiB4LnJlICsuIHguaW0gKi4geC5pbVxuXG5sZXQgbm9ybSB4ID1cbiAgKCogV2F0Y2ggb3V0IGZvciBvdmVyZmxvdyBpbiBjb21wdXRpbmcgcmVeMiArIGltXjIgKilcbiAgbGV0IHIgPSBhYnNfZmxvYXQgeC5yZSBhbmQgaSA9IGFic19mbG9hdCB4LmltIGluXG4gIGlmIHIgPSAwLjAgdGhlbiBpXG4gIGVsc2UgaWYgaSA9IDAuMCB0aGVuIHJcbiAgZWxzZSBpZiByID49IGkgdGhlblxuICAgIGxldCBxID0gaSAvLiByIGluIHIgKi4gc3FydCgxLjAgKy4gcSAqLiBxKVxuICBlbHNlXG4gICAgbGV0IHEgPSByIC8uIGkgaW4gaSAqLiBzcXJ0KDEuMCArLiBxICouIHEpXG5cbmxldCBhcmcgeCA9IGF0YW4yIHguaW0geC5yZVxuXG5sZXQgcG9sYXIgbiBhID0geyByZSA9IGNvcyBhICouIG47IGltID0gc2luIGEgKi4gbiB9XG5cbmxldCBzcXJ0IHggPVxuICBpZiB4LnJlID0gMC4wICYmIHguaW0gPSAwLjAgdGhlbiB7IHJlID0gMC4wOyBpbSA9IDAuMCB9XG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGFic19mbG9hdCB4LnJlIGFuZCBpID0gYWJzX2Zsb2F0IHguaW0gaW5cbiAgICBsZXQgdyA9XG4gICAgICBpZiByID49IGkgdGhlbiBiZWdpblxuICAgICAgICBsZXQgcSA9IGkgLy4gciBpblxuICAgICAgICBzcXJ0KHIpICouIHNxcnQoMC41ICouICgxLjAgKy4gc3FydCgxLjAgKy4gcSAqLiBxKSkpXG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBsZXQgcSA9IHIgLy4gaSBpblxuICAgICAgICBzcXJ0KGkpICouIHNxcnQoMC41ICouIChxICsuIHNxcnQoMS4wICsuIHEgKi4gcSkpKVxuICAgICAgZW5kIGluXG4gICAgaWYgeC5yZSA+PSAwLjBcbiAgICB0aGVuIHsgcmUgPSB3OyAgaW0gPSAwLjUgKi4geC5pbSAvLiB3IH1cbiAgICBlbHNlIHsgcmUgPSAwLjUgKi4gaSAvLiB3OyAgaW0gPSBpZiB4LmltID49IDAuMCB0aGVuIHcgZWxzZSAtLiB3IH1cbiAgZW5kXG5cbmxldCBleHAgeCA9XG4gIGxldCBlID0gZXhwIHgucmUgaW4geyByZSA9IGUgKi4gY29zIHguaW07IGltID0gZSAqLiBzaW4geC5pbSB9XG5cbmxldCBsb2cgeCA9IHsgcmUgPSBsb2cgKG5vcm0geCk7IGltID0gYXRhbjIgeC5pbSB4LnJlIH1cblxubGV0IHBvdyB4IHkgPSBleHAgKG11bCB5IChsb2cgeCkpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgQmVub2l0IFZhdWdvbiwgRU5TVEEgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE0IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFBhZGRpbmcgcG9zaXRpb24uICopXG50eXBlIHBhZHR5ID1cbiAgfCBMZWZ0ICAgKCogVGV4dCBpcyBsZWZ0IGp1c3RpZmllZCAoJy0nIG9wdGlvbikuICAgICAgICAgICAgICAgKilcbiAgfCBSaWdodCAgKCogVGV4dCBpcyByaWdodCBqdXN0aWZpZWQgKG5vICctJyBvcHRpb24pLiAgICAgICAgICAgKilcbiAgfCBaZXJvcyAgKCogVGV4dCBpcyByaWdodCBqdXN0aWZpZWQgYnkgemVyb3MgKHNlZSAnMCcgb3B0aW9uKS4gKilcblxuKCoqKilcblxuKCogSW50ZWdlciBjb252ZXJzaW9uLiAqKVxudHlwZSBpbnRfY29udiA9XG4gIHwgSW50X2QgfCBJbnRfcGQgfCBJbnRfc2QgICAgICAgICgqICAlZCB8ICUrZCB8ICUgZCAgKilcbiAgfCBJbnRfaSB8IEludF9waSB8IEludF9zaSAgICAgICAgKCogICVpIHwgJStpIHwgJSBpICAqKVxuICB8IEludF94IHwgSW50X0N4ICAgICAgICAgICAgICAgICAoKiAgJXggfCAlI3ggICAgICAgICopXG4gIHwgSW50X1ggfCBJbnRfQ1ggICAgICAgICAgICAgICAgICgqICAlWCB8ICUjWCAgICAgICAgKilcbiAgfCBJbnRfbyB8IEludF9DbyAgICAgICAgICAgICAgICAgKCogICVvIHwgJSNvICAgICAgICAqKVxuICB8IEludF91ICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJXUgICAgICAgICAgICAgICopXG5cbigqIEZsb2F0IGNvbnZlcnNpb24uICopXG50eXBlIGZsb2F0X2NvbnYgPVxuICB8IEZsb2F0X2YgfCBGbG9hdF9wZiB8IEZsb2F0X3NmICAoKiAgJWYgfCAlK2YgfCAlIGYgICopXG4gIHwgRmxvYXRfZSB8IEZsb2F0X3BlIHwgRmxvYXRfc2UgICgqICAlZSB8ICUrZSB8ICUgZSAgKilcbiAgfCBGbG9hdF9FIHwgRmxvYXRfcEUgfCBGbG9hdF9zRSAgKCogICVFIHwgJStFIHwgJSBFICAqKVxuICB8IEZsb2F0X2cgfCBGbG9hdF9wZyB8IEZsb2F0X3NnICAoKiAgJWcgfCAlK2cgfCAlIGcgICopXG4gIHwgRmxvYXRfRyB8IEZsb2F0X3BHIHwgRmxvYXRfc0cgICgqICAlRyB8ICUrRyB8ICUgRyAgKilcbiAgfCBGbG9hdF9GICAgICAgICAgICAgICAgICAgICAgICAgKCogICVGICAgICAgICAgICAgICAqKVxuICB8IEZsb2F0X2ggfCBGbG9hdF9waCB8IEZsb2F0X3NoICAoKiAgJWggfCAlK2ggfCAlIGggICopXG4gIHwgRmxvYXRfSCB8IEZsb2F0X3BIIHwgRmxvYXRfc0ggICgqICAlSCB8ICUrSCB8ICUgSCAgKilcblxuKCoqKilcblxuKCogQ2hhciBzZXRzIChzZWUgJVsuLi5dKSBhcmUgYml0bWFwcyBpbXBsZW1lbnRlZCBhcyAzMi1jaGFyIHN0cmluZ3MuICopXG50eXBlIGNoYXJfc2V0ID0gc3RyaW5nXG5cbigqKiopXG5cbigqIENvdW50ZXIgdXNlZCBpbiBTY2FuZi4gKilcbnR5cGUgY291bnRlciA9XG4gIHwgTGluZV9jb3VudGVyICAgICAoKiAgJWwgICAgICAqKVxuICB8IENoYXJfY291bnRlciAgICAgKCogICVuICAgICAgKilcbiAgfCBUb2tlbl9jb3VudGVyICAgICgqICAlTiwgJUwgICopXG5cbigqKiopXG5cbigqIFBhZGRpbmcgb2Ygc3RyaW5ncyBhbmQgbnVtYmVycy4gKilcbnR5cGUgKCdhLCAnYikgcGFkZGluZyA9XG4gICgqIE5vIHBhZGRpbmcgKGV4OiBcIiVkXCIpICopXG4gIHwgTm9fcGFkZGluZyAgOiAoJ2EsICdhKSBwYWRkaW5nXG4gICgqIExpdGVyYWwgcGFkZGluZyAoZXg6IFwiJThkXCIpICopXG4gIHwgTGl0X3BhZGRpbmcgOiBwYWR0eSAqIGludCAtPiAoJ2EsICdhKSBwYWRkaW5nXG4gICgqIFBhZGRpbmcgYXMgZXh0cmEgYXJndW1lbnQgKGV4OiBcIiUqZFwiKSAqKVxuICB8IEFyZ19wYWRkaW5nIDogcGFkdHkgLT4gKGludCAtPiAnYSwgJ2EpIHBhZGRpbmdcblxuKCogU29tZSBmb3JtYXRzLCBzdWNoIGFzICVfZCxcbiAgIG9ubHkgYWNjZXB0IGFuIG9wdGlvbmFsIG51bWJlciBhcyBwYWRkaW5nIG9wdGlvbiAobm8gZXh0cmEgYXJndW1lbnQpICopXG50eXBlIHBhZF9vcHRpb24gPSBpbnQgb3B0aW9uXG5cbigqIFByZWNpc2lvbiBvZiBmbG9hdHMgYW5kICcwJy1wYWRkaW5nIG9mIGludGVnZXJzLiAqKVxudHlwZSAoJ2EsICdiKSBwcmVjaXNpb24gPVxuICAoKiBObyBwcmVjaXNpb24gKGV4OiBcIiVmXCIpICopXG4gIHwgTm9fcHJlY2lzaW9uIDogKCdhLCAnYSkgcHJlY2lzaW9uXG4gICgqIExpdGVyYWwgcHJlY2lzaW9uIChleDogXCIlLjNmXCIpICopXG4gIHwgTGl0X3ByZWNpc2lvbiA6IGludCAtPiAoJ2EsICdhKSBwcmVjaXNpb25cbiAgKCogUHJlY2lzaW9uIGFzIGV4dHJhIGFyZ3VtZW50IChleDogXCIlLipmXCIpICopXG4gIHwgQXJnX3ByZWNpc2lvbiA6IChpbnQgLT4gJ2EsICdhKSBwcmVjaXNpb25cblxuKCogU29tZSBmb3JtYXRzLCBzdWNoIGFzICVfZixcbiAgIG9ubHkgYWNjZXB0IGFuIG9wdGlvbmFsIG51bWJlciBhcyBwcmVjaXNpb24gb3B0aW9uIChubyBleHRyYSBhcmd1bWVudCkgKilcbnR5cGUgcHJlY19vcHRpb24gPSBpbnQgb3B0aW9uXG5cbigqIHNlZSB0aGUgQ3VzdG9tIGZvcm1hdCBjb21iaW5hdG9yICopXG50eXBlICgnYSwgJ2IsICdjKSBjdXN0b21fYXJpdHkgPVxuICB8IEN1c3RvbV96ZXJvIDogKCdhLCBzdHJpbmcsICdhKSBjdXN0b21fYXJpdHlcbiAgfCBDdXN0b21fc3VjYyA6ICgnYSwgJ2IsICdjKSBjdXN0b21fYXJpdHkgLT5cbiAgICAoJ2EsICd4IC0+ICdiLCAneCAtPiAnYykgY3VzdG9tX2FyaXR5XG5cbigqKiopXG5cbigqICAgICAgICBSZWxhdGlvbmFsIGZvcm1hdCB0eXBlc1xuXG5JbiB0aGUgZmlyc3QgZm9ybWF0K2dhZHRzIGltcGxlbWVudGF0aW9uLCB0aGUgdHlwZSBmb3IgJSguLiUpIGluIHRoZVxuZm10IEdBRFQgd2FzIGFzIGZvbGxvd3M6XG5cbnwgRm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSguLi4lKSAqKVxuICAgIHBhZF9vcHRpb24gKiAoJ2QxLCAncTEsICdkMiwgJ3EyKSByZWFkZXJfbmJfdW5pZmllciAqXG4gICAgKCd4LCAnYiwgJ2MsICdkMSwgJ3ExLCAndSkgZm10dHkgKlxuICAgICgndSwgJ2IsICdjLCAncTEsICdlMSwgJ2YpIGZtdCAtPlxuICAgICAgKCgneCwgJ2IsICdjLCAnZDIsICdxMiwgJ3UpIGZvcm1hdDYgLT4gJ3gsICdiLCAnYywgJ2QxLCAnZTEsICdmKSBmbXRcblxuTm90aWNlIHRoYXQgdGhlICd1IHBhcmFtZXRlciBpbiAnZiBwb3NpdGlvbiBpbiB0aGUgZm9ybWF0IGFyZ3VtZW50XG4oKCd4LCAuLiwgJ3UpIGZvcm1hdDYgLT4gLi4pIGlzIGVxdWFsIHRvIHRoZSAndSBwYXJhbWV0ZXIgaW4gJ2FcbnBvc2l0aW9uIGluIHRoZSBmb3JtYXQgdGFpbCAoKCd1LCAuLiwgJ2YpIGZtdCkuIFRoaXMgbWVhbnMgdGhhdCB0aGVcbnR5cGUgb2YgdGhlIGV4cGVjdGVkIGZvcm1hdCBwYXJhbWV0ZXIgZGVwZW5kcyBvZiB3aGVyZSB0aGUgJSguLi4lKVxuYXJlIGluIHRoZSBmb3JtYXQgc3RyaW5nOlxuXG4gICMgUHJpbnRmLnByaW50ZiBcIiUoJSlcIlxuICAtIDogKHVuaXQsIG91dF9jaGFubmVsLCB1bml0LCAnX2EsICdfYSwgdW5pdClcbiAgICAgIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mb3JtYXQ2IC0+IHVuaXRcbiAgPSA8ZnVuPlxuICAjIFByaW50Zi5wcmludGYgXCIlKCUpJWRcIlxuICAtIDogKGludCAtPiB1bml0LCBvdXRfY2hhbm5lbCwgdW5pdCwgJ19hLCAnX2EsIGludCAtPiB1bml0KVxuICAgICAgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZvcm1hdDYgLT4gaW50IC0+IHVuaXRcbiAgPSA8ZnVuPlxuXG5PbiB0aGUgY29udHJhcnksIHRoZSBsZWdhY3kgdHlwZXIgZ2l2ZXMgYSBjbGV2ZXIgdHlwZSB0aGF0IGRvZXMgbm90XG5kZXBlbmQgb24gdGhlIHBvc2l0aW9uIG9mICUoLi4lKSBpbiB0aGUgZm9ybWF0IHN0cmluZy4gRm9yIGV4YW1wbGUsXG4lKCUpIHdpbGwgaGF2ZSB0aGUgcG9seW1vcnBoaWMgdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSk6IGl0IGNhblxuYmUgY29uY2F0ZW5hdGVkIHRvIGFueSBmb3JtYXQgdHlwZSwgYW5kIG9ubHkgZW5mb3JjZXMgdGhlIGNvbnN0cmFpbnRcbnRoYXQgaXRzICdhIGFuZCAnZiBwYXJhbWV0ZXJzIGFyZSBlcXVhbCAobm8gZm9ybWF0IGFyZ3VtZW50cykgYW5kICdkXG5hbmQgJ2UgYXJlIGVxdWFsIChubyByZWFkZXIgYXJndW1lbnQpLlxuXG5UaGUgd2Vha2VuaW5nIG9mIHRoaXMgcGFyYW1ldGVyIHR5cGUgaW4gdGhlIEdBRFQgdmVyc2lvbiBicm9rZSB1c2VyXG5jb2RlIChpbiBmYWN0IGl0IGVzc2VudGlhbGx5IG1hZGUgJSguLi4lKSB1bnVzYWJsZSBleGNlcHQgYXQgdGhlIGxhc3RcbnBvc2l0aW9uIG9mIGEgZm9ybWF0KS4gSW4gcGFydGljdWxhciwgdGhlIGZvbGxvd2luZyB3b3VsZCBub3Qgd29ya1xuYW55bW9yZTpcblxuICBmdW4gc2VwIC0+XG4gICAgRm9ybWF0LnByaW50ZiBcImZvbyUoJSliYXIlKCUpYmF6XCIgc2VwIHNlcFxuXG5BcyB0aGUgdHlwZS1jaGVja2VyIHdvdWxkIHJlcXVpcmUgdHdvICppbmNvbXBhdGlibGUqIHR5cGVzIGZvciB0aGUgJSglKVxuaW4gZGlmZmVyZW50IHBvc2l0aW9ucy5cblxuVGhlIHNvbHV0aW9uIHRvIHJlZ2FpbiBhIGdlbmVyYWwgdHlwZSBmb3IgJSguLiUpIGlzIHRvIGdlbmVyYWxpemUgdGhpc1xudGVjaG5pcXVlLCBub3Qgb25seSBvbiB0aGUgJ2QsICdlIHBhcmFtZXRlcnMsIGJ1dCBvbiBhbGwgc2l4XG5wYXJhbWV0ZXJzIG9mIGEgZm9ybWF0OiB3ZSBpbnRyb2R1Y2UgYSBcInJlbGF0aW9uYWxcIiB0eXBlXG4gICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG53aG9zZSB2YWx1ZXMgYXJlIHByb29mcyB0aGF0ICgnYTEsIC4uLCAnZjEpIGFuZCAoJ2EyLCAuLiwgJ2YyKSBtb3JhbGx5XG5jb3JyZXNwb25kIHRvIHRoZSBzYW1lIGZvcm1hdCB0eXBlOiAnYTEgaXMgb2J0YWluZWQgZnJvbSAnZjEsJ2IxLCdjMVxuaW4gdGhlIGV4YWN0IHNhbWUgd2F5IHRoYXQgJ2EyIGlzIG9idGFpbmVkIGZyb20gJ2YyLCdiMiwnYzIsIGV0Yy5cblxuRm9yIGV4YW1wbGUsIHRoZSByZWxhdGlvbiBiZXR3ZWVuIHR3byBmb3JtYXQgdHlwZXMgYmVnaW5uaW5nIHdpdGggYSBDaGFyXG5wYXJhbWV0ZXIgaXMgYXMgZm9sbG93czpcblxufCBDaGFyX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWMgICopXG4gICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgIChjaGFyIC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgIGNoYXIgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG5cbkluIHRoZSBnZW5lcmFsIGNhc2UsIHRoZSB0ZXJtIHN0cnVjdHVyZSBvZiBmbXR0eV9yZWwgaXMgKGFsbW9zdFsxXSlcbmlzb21vcnBoaWMgdG8gdGhlIGZtdHR5IG9mIHRoZSBwcmV2aW91cyBpbXBsZW1lbnRhdGlvbjogZXZlcnlcbmNvbnN0cnVjdG9yIGlzIHJlLXJlYWQgd2l0aCBhIGJpbmFyeSwgcmVsYXRpb25hbCB0eXBlLCBpbnN0ZWFkIG9mIHRoZVxucHJldmlvdXMgdW5hcnkgdHlwaW5nLiBmbXR0eSBjYW4gdGhlbiBiZSByZS1kZWZpbmVkIGFzIHRoZSBkaWFnb25hbCBvZlxuZm10dHlfcmVsOlxuXG4gIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5ID1cbiAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZixcbiAgICAgICAgJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHlfcmVsXG5cbk9uY2Ugd2UgaGF2ZSB0aGlzIGZtdHR5X3JlbCB0eXBlIGluIHBsYWNlLCB3ZSBjYW4gZ2l2ZSB0aGUgbW9yZVxuZ2VuZXJhbCB0eXBlIHRvICUoLi4uJSk6XG5cbnwgRm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSguLi4lKSAqKVxuICAgIHBhZF9vcHRpb24gKlxuICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsLFxuICAgICAnZzIsICdiLCAnYywgJ2oyLCAnZCwgJ2EpIGZtdHR5X3JlbCAqXG4gICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzIsICdiLCAnYywgJ2oyLCAnZSwgJ2YpIGZtdFxuXG5XZSBhY2NlcHQgYW55IGZvcm1hdCAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYpICh0aGlzIGlzXG5jb21wbGV0ZWx5IHVucmVsYXRlZCB0byB0aGUgdHlwZSBvZiB0aGUgY3VycmVudCBmb3JtYXQpLCBidXQgYWxzb1xucmVxdWlyZSBhIHByb29mIHRoYXQgdGhpcyBmb3JtYXQgaXMgaW4gcmVsYXRpb24gdG8gYW5vdGhlciBmb3JtYXQgdGhhdFxuaXMgY29uY2F0ZW5hYmxlIHRvIHRoZSBmb3JtYXQgdGFpbC4gV2hlbiBleGVjdXRpbmcgYSAlKC4uLiUpIGZvcm1hdFxuKGluIGNhbWxpbnRlcm5hbEZvcm1hdC5tbDptYWtlX3ByaW50ZiBvciBzY2FuZi5tbDptYWtlX3NjYW5mKSwgd2VcbnRyYW5zdHlwZSB0aGUgZm9ybWF0IGFsb25nIHRoaXMgcmVsYXRpb24gdXNpbmcgdGhlICdyZWNhc3QnIGZ1bmN0aW9uXG50byB0cmFuc3Bvc2UgYmV0d2VlbiByZWxhdGVkIGZvcm1hdCB0eXBlcy5cblxuICB2YWwgcmVjYXN0IDpcbiAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEpIGZtdFxuICAtPiAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICAtPiAoJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10XG5cbk5PVEUgWzFdOiB0aGUgdHlwaW5nIG9mIEZvcm1hdF9zdWJzdF90eSByZXF1aXJlcyBub3Qgb25lIGZvcm1hdCB0eXBlLCBidXRcbnR3bywgb25lIHRvIGVzdGFibGlzaCB0aGUgbGluayBiZXR3ZWVuIHRoZSBmb3JtYXQgYXJndW1lbnQgYW5kIHRoZVxuZmlyc3Qgc2l4IHBhcmFtZXRlcnMsIGFuZCB0aGUgb3RoZXIgZm9yIHRoZSBsaW5rIGJldHdlZW4gdGhlIGZvcm1hdFxuYXJndW1lbnQgYW5kIHRoZSBsYXN0IHNpeCBwYXJhbWV0ZXJzLlxuXG58IEZvcm1hdF9zdWJzdF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2QxLCAnYTEpIGZtdHR5X3JlbCAqXG4gICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICdnMiwgJ2IyLCAnYzIsICdqMiwgJ2QyLCAnYTIpIGZtdHR5X3JlbCAqXG4gICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzEsICdiMSwgJ2MxLCAnajEsICdlMSwgJ2YxLFxuICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzIsICdiMiwgJ2MyLCAnajIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcblxuV2hlbiB3ZSBnZW5lcmF0ZSBhIGZvcm1hdCBBU1QsIHdlIGdlbmVyYXRlIGV4YWN0bHkgdGhlIHNhbWUgd2l0bmVzc1xuZm9yIGJvdGggcmVsYXRpb25zLCBhbmQgdGhlIHdpdG5lc3MtY29udmVyc2lvbiBmdW5jdGlvbnMgaW5cbmNhbWxpbnRlcm5hbEZvcm1hdCBkbyByZWx5IG9uIHRoaXMgaW52YXJpYW50LiBGb3IgZXhhbXBsZSwgdGhlXG5mdW5jdGlvbiB0aGF0IHByb3ZlcyB0aGF0IHRoZSByZWxhdGlvbiBpcyB0cmFuc2l0aXZlXG5cbiAgdmFsIHRyYW5zIDpcbiAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgLT4gKCdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIsXG4gICAgICAnYTMsICdiMywgJ2MzLCAnZDMsICdlMywgJ2YzKSBmbXR0eV9yZWxcbiAgLT4gKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAnYTMsICdiMywgJ2MzLCAnZDMsICdlMywgJ2YzKSBmbXR0eV9yZWxcblxuZG9lcyBhc3N1bWUgdGhhdCB0aGUgdHdvIGlucHV0cyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgdGVybSBzdHJ1Y3R1cmVcbihhbmQgaXMgb25seSBldmVyeSB1c2VkIGZvciBhcmd1bWVudCB3aXRuZXNzZXMgb2YgdGhlXG5Gb3JtYXRfc3Vic3RfdHkgY29uc3RydWN0b3IpLlxuKilcblxuKCogVHlwZSBvZiBhIGJsb2NrIHVzZWQgYnkgdGhlIEZvcm1hdCBwcmV0dHktcHJpbnRlci4gKilcbnR5cGUgYmxvY2tfdHlwZSA9XG4gIHwgUHBfaGJveCAgICgqIEhvcml6b250YWwgYmxvY2sgbm8gbGluZSBicmVha2luZyAqKVxuICB8IFBwX3Zib3ggICAoKiBWZXJ0aWNhbCBibG9jayBlYWNoIGJyZWFrIGxlYWRzIHRvIGEgbmV3IGxpbmUgKilcbiAgfCBQcF9odmJveCAgKCogSG9yaXpvbnRhbC12ZXJ0aWNhbCBibG9jazogc2FtZSBhcyB2Ym94LCBleGNlcHQgaWYgdGhpcyBibG9ja1xuICAgICAgICAgICAgICAgICBpcyBzbWFsbCBlbm91Z2ggdG8gZml0IG9uIGEgc2luZ2xlIGxpbmUgKilcbiAgfCBQcF9ob3Zib3ggKCogSG9yaXpvbnRhbCBvciBWZXJ0aWNhbCBibG9jazogYnJlYWtzIGxlYWQgdG8gbmV3IGxpbmVcbiAgICAgICAgICAgICAgICAgb25seSB3aGVuIG5lY2Vzc2FyeSB0byBwcmludCB0aGUgY29udGVudCBvZiB0aGUgYmxvY2sgKilcbiAgfCBQcF9ib3ggICAgKCogSG9yaXpvbnRhbCBvciBJbmRlbnQgYmxvY2s6IGJyZWFrcyBsZWFkIHRvIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgIG9ubHkgd2hlbiBuZWNlc3NhcnkgdG8gcHJpbnQgdGhlIGNvbnRlbnQgb2YgdGhlIGJsb2NrLCBvclxuICAgICAgICAgICAgICAgICB3aGVuIGl0IGxlYWRzIHRvIGEgbmV3IGluZGVudGF0aW9uIG9mIHRoZSBjdXJyZW50IGxpbmUgKilcbiAgfCBQcF9maXRzICAgKCogSW50ZXJuYWwgdXNhZ2U6IHdoZW4gYSBibG9jayBmaXRzIG9uIGEgc2luZ2xlIGxpbmUgKilcblxuKCogRm9ybWF0dGluZyBlbGVtZW50IHVzZWQgYnkgdGhlIEZvcm1hdCBwcmV0dHktcHJpbnRlci4gKilcbnR5cGUgZm9ybWF0dGluZ19saXQgPVxuICB8IENsb3NlX2JveCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAXSAgICopXG4gIHwgQ2xvc2VfdGFnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEB9ICAgKilcbiAgfCBCcmVhayBvZiBzdHJpbmcgKiBpbnQgKiBpbnQgICAgICAgICAgKCogQCwgfCBAICB8IEA7IHwgQDs8PiAqKVxuICB8IEZGbHVzaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAPyAgICopXG4gIHwgRm9yY2VfbmV3bGluZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBcXG4gICopXG4gIHwgRmx1c2hfbmV3bGluZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEAuICAgKilcbiAgfCBNYWdpY19zaXplIG9mIHN0cmluZyAqIGludCAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQDxuPiAqKVxuICB8IEVzY2FwZWRfYXQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAQCAgICopXG4gIHwgRXNjYXBlZF9wZXJjZW50ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEAlJSAgKilcbiAgfCBTY2FuX2luZGljIG9mIGNoYXIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQFggICAqKVxuXG4oKiBGb3JtYXR0aW5nIGVsZW1lbnQgdXNlZCBieSB0aGUgRm9ybWF0IHByZXR0eS1wcmludGVyLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0dGluZ19nZW4gPVxuICB8IE9wZW5fdGFnIDogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT4gICAgICAoKiBAeyAgICopXG4gICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdHRpbmdfZ2VuXG4gIHwgT3Blbl9ib3ggOiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPiAgICAgICgqIEBbICAgKilcbiAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0dGluZ19nZW5cblxuKCoqKilcblxuKCogTGlzdCBvZiBmb3JtYXQgdHlwZSBlbGVtZW50cy4gKilcbigqIEluIHBhcnRpY3VsYXIgdXNlZCB0byByZXByZXNlbnQgJSguLi4lKSBhbmQgJXsuLi4lfSBjb250ZW50cy4gKilcbmFuZCAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgPVxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZixcbiAgICAgICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5X3JlbFxuYW5kICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgPVxuICB8IENoYXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYyAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGNoYXIgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBjaGFyIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IFN0cmluZ190eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlcyAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKHN0cmluZyAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIHN0cmluZyAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBJbnRfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWQgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChpbnQgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBpbnQgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgSW50MzJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVsZCAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoaW50MzIgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBpbnQzMiAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBOYXRpdmVpbnRfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJW5kICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChuYXRpdmVpbnQgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBuYXRpdmVpbnQgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgSW50NjRfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVMZCAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoaW50NjQgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBpbnQ2NCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBGbG9hdF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWYgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChmbG9hdCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGZsb2F0IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IEJvb2xfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlQiAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGJvb2wgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBib29sIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG4gIHwgRm9ybWF0X2FyZ190eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICV7Li4uJX0gKilcbiAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmbXR0eSAqXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpXG4gICAgICAgICAgIGZtdHR5X3JlbFxuICB8IEZvcm1hdF9zdWJzdF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgICAnZzEsICdiMSwgJ2MxLCAnajEsICdkMSwgJ2ExKSBmbXR0eV9yZWwgKlxuICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICAgJ2cyLCAnYjIsICdjMiwgJ2oyLCAnZDIsICdhMikgZm10dHlfcmVsICpcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2UxLCAnZjEsXG4gICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2cyLCAnYjIsICdjMiwgJ2oyLCAnZTIsICdmMilcbiAgICAgICAgICAgZm10dHlfcmVsXG5cbiAgKCogUHJpbnRmIGFuZCBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3JzLiAqKVxuICB8IEFscGhhX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYSAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnYjEgLT4gJ3ggLT4gJ2MxKSAtPiAneCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICgnYjIgLT4gJ3ggLT4gJ2MyKSAtPiAneCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBUaGV0YV90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXQgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgoJ2IxIC0+ICdjMSkgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAoJ2IyIC0+ICdjMikgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgQW55X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBVc2VkIGZvciBjdXN0b20gZm9ybWF0cyAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoJ3ggLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAneCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcblxuICAoKiBTY2FuZiBzcGVjaWZpYyBjb25zdHJ1Y3Rvci4gKilcbiAgfCBSZWFkZXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXIgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgneCAtPiAnYTEsICdiMSwgJ2MxLCAoJ2IxIC0+ICd4KSAtPiAnZDEsICdlMSwgJ2YxLFxuICAgICAgICd4IC0+ICdhMiwgJ2IyLCAnYzIsICgnYjIgLT4gJ3gpIC0+ICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IElnbm9yZWRfcmVhZGVyX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX3IgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgnYTEsICdiMSwgJ2MxLCAoJ2IxIC0+ICd4KSAtPiAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICgnYjIgLT4gJ3gpIC0+ICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG4gIHwgRW5kX29mX2ZtdHR5IDpcbiAgICAgICgnZjEsICdiMSwgJ2MxLCAnZDEsICdkMSwgJ2YxLFxuICAgICAgICdmMiwgJ2IyLCAnYzIsICdkMiwgJ2QyLCAnZjIpIGZtdHR5X3JlbFxuXG4oKioqKVxuXG4oKiBMaXN0IG9mIGZvcm1hdCBlbGVtZW50cy4gKilcbmFuZCAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10ID1cbiAgfCBDaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoY2hhciAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBDYW1sX2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlQyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoY2hhciAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBTdHJpbmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlcyAqKVxuICAgICAgKCd4LCBzdHJpbmcgLT4gJ2EpIHBhZGRpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBDYW1sX3N0cmluZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlUyAqKVxuICAgICAgKCd4LCBzdHJpbmcgLT4gJ2EpIHBhZGRpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBJbnQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlW2RpeFh1b10gKilcbiAgICAgIGludF9jb252ICogKCd4LCAneSkgcGFkZGluZyAqICgneSwgaW50IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgSW50MzIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWxbZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBpbnQzMiAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IE5hdGl2ZWludCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVuW2RpeFh1b10gKilcbiAgICAgIGludF9jb252ICogKCd4LCAneSkgcGFkZGluZyAqICgneSwgbmF0aXZlaW50IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgSW50NjQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJUxbZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBpbnQ2NCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEZsb2F0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbZmVFZ0dGXSAqKVxuICAgICAgZmxvYXRfY29udiAqICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksIGZsb2F0IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgQm9vbCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJVtiQl0gKilcbiAgICAgICgneCwgYm9vbCAtPiAnYSkgcGFkZGluZyAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEZsdXNoIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUhICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICB8IFN0cmluZ19saXRlcmFsIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIGFiYyAqKVxuICAgICAgc3RyaW5nICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgQ2hhcl9saXRlcmFsIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogeCAqKVxuICAgICAgY2hhciAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuXG4gIHwgRm9ybWF0X2FyZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXsuLi4lfSAqKVxuICAgICAgcGFkX29wdGlvbiAqICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmbXR0eSAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBGb3JtYXRfc3Vic3QgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgICBwYWRfb3B0aW9uICpcbiAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsLFxuICAgICAgICdnMiwgJ2IsICdjLCAnajIsICdkLCAnYSkgZm10dHlfcmVsICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzIsICdiLCAnYywgJ2oyLCAnZSwgJ2YpIGZtdFxuXG4gICgqIFByaW50ZiBhbmQgRm9ybWF0IHNwZWNpZmljIGNvbnN0cnVjdG9yLiAqKVxuICB8IEFscGhhIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVhICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgoJ2IgLT4gJ3ggLT4gJ2MpIC0+ICd4IC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IFRoZXRhIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICV0ICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgoJ2IgLT4gJ2MpIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuXG4gICgqIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3RvcjogKilcbiAgfCBGb3JtYXR0aW5nX2xpdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAXyAqKVxuICAgICAgZm9ybWF0dGluZ19saXQgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBGb3JtYXR0aW5nX2dlbiA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQF8gKilcbiAgICAgICgnYTEsICdiLCAnYywgJ2QxLCAnZTEsICdmMSkgZm9ybWF0dGluZ19nZW4gKlxuICAgICAgKCdmMSwgJ2IsICdjLCAnZTEsICdlMiwgJ2YyKSBmbXQgLT4gKCdhMSwgJ2IsICdjLCAnZDEsICdlMiwgJ2YyKSBmbXRcblxuICAoKiBTY2FuZiBzcGVjaWZpYyBjb25zdHJ1Y3RvcnM6ICopXG4gIHwgUmVhZGVyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXIgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4IC0+ICdhLCAnYiwgJ2MsICgnYiAtPiAneCkgLT4gJ2QsICdlLCAnZikgZm10XG4gIHwgU2Nhbl9jaGFyX3NldCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJVsuLi5dICopXG4gICAgICBwYWRfb3B0aW9uICogY2hhcl9zZXQgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgIChzdHJpbmcgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgU2Nhbl9nZXRfY291bnRlciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJVtubE5MXSAqKVxuICAgICAgY291bnRlciAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKGludCAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBTY2FuX25leHRfY2hhciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlMGMgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgIChjaGFyIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IElnbm9yZWRfcGFyYW0gOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICd5LCAneCkgaWdub3JlZCAqICgneCwgJ2IsICdjLCAneSwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuXG4gICgqIEN1c3RvbSBwcmludGluZyBmb3JtYXQgKFBSIzY0NTIsIEdQUiMxNDApXG5cbiAgICAgV2UgaW5jbHVkZSBhIHR5cGUgQ3VzdG9tIG9mIFwiY3VzdG9tIGNvbnZlcnRlcnNcIiwgd2hlcmUgYW5cbiAgICAgYXJiaXRyYXJ5IGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIGNvbnZlcnQgb25lIG9yIG1vcmVcbiAgICAgYXJndW1lbnRzLiBUaGVyZSBpcyBubyBzeW50YXggZm9yIGN1c3RvbSBjb252ZXJ0ZXJzLCBpdCBpcyBvbmx5XG4gICAgIGludGVuZGVkIGZvciBjdXN0b20gcHJvY2Vzc29ycyB0aGF0IHdpc2ggdG8gcmVseSBvbiB0aGVcbiAgICAgc3RkbGliLWRlZmluZWQgZm9ybWF0IEdBRFRzLlxuXG4gICAgIEZvciBpbnN0YW5jZSBhIHByZS1wcm9jZXNzb3IgY291bGQgY2hvb3NlIHRvIGludGVycHJldCBzdHJpbmdzXG4gICAgIHByZWZpeGVkIHdpdGggW1wiIVwiXSBhcyBmb3JtYXQgc3RyaW5ncyB3aGVyZSBbJXt7IC4uLiB9fV0gaXNcbiAgICAgYSBzcGVjaWFsIGZvcm0gdG8gcGFzcyBhIHRvX3N0cmluZyBmdW5jdGlvbiwgc28gdGhhdCBvbmUgY291bGRcbiAgICAgd3JpdGU6XG5cbiAgICAge1tcbiAgICAgICB0eXBlIHQgPSB7IHggOiBpbnQ7IHkgOiBpbnQgfVxuXG4gICAgICAgbGV0IHN0cmluZ19vZl90IHQgPSBQcmludGYuc3ByaW50ZiBcInsgeCA9ICVkOyB5ID0gJWQgfVwiIHQueCB0LnlcblxuICAgICAgIFByaW50Zi5wcmludGYgIVwidCA9ICV7e3N0cmluZ19vZl90fX1cIiB7IHggPSA0MjsgeSA9IDQyIH1cbiAgICAgXX1cbiAgKilcbiAgfCBDdXN0b20gOlxuICAgICAgKCdhLCAneCwgJ3kpIGN1c3RvbV9hcml0eSAqICh1bml0IC0+ICd4KSAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICgneSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICAoKiBlbmQgb2YgYSBmb3JtYXQgc3BlY2lmaWNhdGlvbiAqKVxuICB8IEVuZF9vZl9mb3JtYXQgOlxuICAgICAgICAoJ2YsICdiLCAnYywgJ2UsICdlLCAnZikgZm10XG5cbigqKiopXG5cbigqIFR5cGUgZm9yIGlnbm9yZWQgcGFyYW1ldGVycyAoc2VlIFwiJV9cIikuICopXG5hbmQgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGlnbm9yZWQgPVxuICB8IElnbm9yZWRfY2hhciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfYyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX0MgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9zdHJpbmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9zICopXG4gICAgICBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9TICopXG4gICAgICBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9pbnQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9kICopXG4gICAgICBpbnRfY29udiAqIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2ludDMyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX2xkICopXG4gICAgICBpbnRfY29udiAqIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX25hdGl2ZWludCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX25kICopXG4gICAgICBpbnRfY29udiAqIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2ludDY0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX0xkICopXG4gICAgICBpbnRfY29udiAqIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2Zsb2F0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX2YgKilcbiAgICAgIHBhZF9vcHRpb24gKiBwcmVjX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfYm9vbCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfQiAqKVxuICAgICAgcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfZm9ybWF0X2FyZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfey4uLiV9ICopXG4gICAgICBwYWRfb3B0aW9uICogKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZtdHR5IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV8oLi4uJSkgKilcbiAgICAgIHBhZF9vcHRpb24gKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX3JlYWRlciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX3IgKilcbiAgICAgICgnYSwgJ2IsICdjLCAoJ2IgLT4gJ3gpIC0+ICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX1suLi5dICopXG4gICAgICBwYWRfb3B0aW9uICogY2hhcl9zZXQgLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX1tubE5MXSAqKVxuICAgICAgY291bnRlciAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfMGMgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG5cbmFuZCAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA9XG4gIEZvcm1hdCBvZiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10ICogc3RyaW5nXG5cbmxldCByZWMgZXJhc2VfcmVsIDogdHlwZSBhIGIgYyBkIGUgZiBnIGggaSBqIGsgbCAuXG4gIChhLCBiLCBjLCBkLCBlLCBmLFxuICAgZywgaCwgaSwgaiwgaywgbCkgZm10dHlfcmVsIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eVxuPSBmdW5jdGlvblxuICB8IENoYXJfdHkgcmVzdCAtPlxuICAgIENoYXJfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IFN0cmluZ190eSByZXN0IC0+XG4gICAgU3RyaW5nX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBJbnRfdHkgcmVzdCAtPlxuICAgIEludF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgSW50MzJfdHkgcmVzdCAtPlxuICAgIEludDMyX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBJbnQ2NF90eSByZXN0IC0+XG4gICAgSW50NjRfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IE5hdGl2ZWludF90eSByZXN0IC0+XG4gICAgTmF0aXZlaW50X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBGbG9hdF90eSByZXN0IC0+XG4gICAgRmxvYXRfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEJvb2xfdHkgcmVzdCAtPlxuICAgIEJvb2xfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEZvcm1hdF9hcmdfdHkgKHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9hcmdfdHkgKHR5LCBlcmFzZV9yZWwgcmVzdClcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgX3R5MiwgcmVzdCkgLT5cbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkxLCBlcmFzZV9yZWwgcmVzdClcbiAgfCBBbHBoYV90eSByZXN0IC0+XG4gICAgQWxwaGFfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IFRoZXRhX3R5IHJlc3QgLT5cbiAgICBUaGV0YV90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgQW55X3R5IHJlc3QgLT5cbiAgICBBbnlfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IFJlYWRlcl90eSByZXN0IC0+XG4gICAgUmVhZGVyX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0IC0+XG4gICAgSWdub3JlZF9yZWFkZXJfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEVuZF9vZl9mbXR0eSAtPiBFbmRfb2ZfZm10dHlcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXQgdHlwZSBjb25jYXRlbmF0aW9uICopXG5cbigqIENvbmNhdGVuYXRlIHR3byBmb3JtYXQgdHlwZXMuICopXG4oKiBVc2VkIGJ5OlxuICAgKiByZWFkZXJfbmJfdW5pZmllcl9vZl9mbXR0eSB0byBjb3VudCByZWFkZXJzIGluIGFuIGZtdHR5LFxuICAgKiBTY2FuZi50YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIHRvIGV4dHJhY3QgcmVhZGVycyBpbnNpZGUgJSguLi4lKSxcbiAgICogQ2FtbGludGVybmFsRm9ybWF0LmZtdHR5X29mX2lnbm9yZWRfZm9ybWF0IHRvIGV4dHJhY3QgZm9ybWF0IHR5cGUuICopXG5cbigqXG5sZXQgcmVjIGNvbmNhdF9mbXR0eSA6IHR5cGUgYSBiIGMgZCBlIGYgZyBoIC5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT5cbiAgICAoZiwgYiwgYywgZSwgZywgaCkgZm10dHkgLT5cbiAgICAoYSwgYiwgYywgZCwgZywgaCkgZm10dHkgPVxuKilcbmxldCByZWMgY29uY2F0X2ZtdHR5IDpcbiAgdHlwZSBhMSBiMSBjMSBkMSBlMSBmMVxuICAgICAgIGEyIGIyIGMyIGQyIGUyIGYyXG4gICAgICAgZzEgajEgZzIgajJcbiAgLlxuICAgIChnMSwgYjEsIGMxLCBqMSwgZDEsIGExLFxuICAgICBnMiwgYjIsIGMyLCBqMiwgZDIsIGEyKSBmbXR0eV9yZWwgLT5cbiAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSxcbiAgICAgYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlfcmVsIC0+XG4gICAgKGcxLCBiMSwgYzEsIGoxLCBlMSwgZjEsXG4gICAgIGcyLCBiMiwgYzIsIGoyLCBlMiwgZjIpIGZtdHR5X3JlbCA9XG5mdW4gZm10dHkxIGZtdHR5MiAtPiBtYXRjaCBmbXR0eTEgd2l0aFxuICB8IENoYXJfdHkgcmVzdCAtPlxuICAgIENoYXJfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBTdHJpbmdfdHkgcmVzdCAtPlxuICAgIFN0cmluZ190eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEludF90eSByZXN0IC0+XG4gICAgSW50X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgSW50MzJfdHkgcmVzdCAtPlxuICAgIEludDMyX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgLT5cbiAgICBOYXRpdmVpbnRfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBJbnQ2NF90eSByZXN0IC0+XG4gICAgSW50NjRfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBGbG9hdF90eSByZXN0IC0+XG4gICAgRmxvYXRfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBCb29sX3R5IHJlc3QgLT5cbiAgICBCb29sX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgQWxwaGFfdHkgcmVzdCAtPlxuICAgIEFscGhhX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgVGhldGFfdHkgcmVzdCAtPlxuICAgIFRoZXRhX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgQW55X3R5IHJlc3QgLT5cbiAgICBBbnlfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBSZWFkZXJfdHkgcmVzdCAtPlxuICAgIFJlYWRlcl90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QgLT5cbiAgICBJZ25vcmVkX3JlYWRlcl90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEZvcm1hdF9hcmdfdHkgKHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9hcmdfdHkgKHR5LCBjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgcmVzdCkgLT5cbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCBjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgRW5kX29mX2ZtdHR5IC0+IGZtdHR5MlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IGNvbmNhdGVuYXRpb24gKilcblxuKCogQ29uY2F0ZW5hdGUgdHdvIGZvcm1hdHMuICopXG5sZXQgcmVjIGNvbmNhdF9mbXQgOiB0eXBlIGEgYiBjIGQgZSBmIGcgaCAuXG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgIChmLCBiLCBjLCBlLCBnLCBoKSBmbXQgLT5cbiAgICAoYSwgYiwgYywgZCwgZywgaCkgZm10ID1cbmZ1biBmbXQxIGZtdDIgLT4gbWF0Y2ggZm10MSB3aXRoXG4gIHwgU3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgU3RyaW5nIChwYWQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgQ2FtbF9zdHJpbmcgKHBhZCwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBJbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgSW50IChpY29udiwgcGFkLCBwcmVjLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgSW50NjQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgSW50NjQgKGljb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IENoYXIgKHJlc3QpIC0+XG4gICAgQ2hhciAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQ2FtbF9jaGFyIHJlc3QgLT5cbiAgICBDYW1sX2NoYXIgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEJvb2wgKHBhZCwgcmVzdCkgLT5cbiAgICBCb29sIChwYWQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEFscGhhIHJlc3QgLT5cbiAgICBBbHBoYSAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgVGhldGEgcmVzdCAtPlxuICAgIFRoZXRhIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBDdXN0b20gKGFyaXR5LCBmLCByZXN0KSAtPlxuICAgIEN1c3RvbSAoYXJpdHksIGYsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IFJlYWRlciByZXN0IC0+XG4gICAgUmVhZGVyIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBGbHVzaCByZXN0IC0+XG4gICAgRmx1c2ggKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgLT5cbiAgICBTdHJpbmdfbGl0ZXJhbCAoc3RyLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBDaGFyX2xpdGVyYWwgKGNociwgcmVzdCkgLT5cbiAgICBDaGFyX2xpdGVyYWwgICAoY2hyLCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IEZvcm1hdF9hcmcgKHBhZCwgZm10dHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X2FyZyAgIChwYWQsIGZtdHR5LCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBGb3JtYXRfc3Vic3QgKHBhZCwgZm10dHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0IChwYWQsIGZtdHR5LCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIHJlc3QpIC0+XG4gICAgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgcmVzdCkgLT5cbiAgICBTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBTY2FuX25leHRfY2hhciAocmVzdCkgLT5cbiAgICBTY2FuX25leHRfY2hhciAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAtPlxuICAgIElnbm9yZWRfcGFyYW0gKGlnbiwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkgLT5cbiAgICBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgRm9ybWF0dGluZ19nZW4gKGZtdGluZ19nZW4sIHJlc3QpIC0+XG4gICAgRm9ybWF0dGluZ19nZW4gKGZtdGluZ19nZW4sIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgRW5kX29mX2Zvcm1hdCAtPlxuICAgIGZtdDJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogdHlwZSAnYSBvcHRpb24gPSBOb25lIHwgU29tZSBvZiAnYSAqKVxuXG4oKiBFeGNlcHRpb25zICopXG5cbmV4dGVybmFsIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIDogc3RyaW5nIC0+ICdhIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlXCJcblxubGV0ICgpID1cbiAgKCogZm9yIGFzbXJ1bi9mYWlsLmMgKilcbiAgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgXCJQZXJ2YXNpdmVzLmFycmF5X2JvdW5kX2Vycm9yXCJcbiAgICAoSW52YWxpZF9hcmd1bWVudCBcImluZGV4IG91dCBvZiBib3VuZHNcIilcblxuXG5leHRlcm5hbCByYWlzZSA6IGV4biAtPiAnYSA9IFwiJXJhaXNlXCJcbmV4dGVybmFsIHJhaXNlX25vdHJhY2UgOiBleG4gLT4gJ2EgPSBcIiVyYWlzZV9ub3RyYWNlXCJcblxubGV0IGZhaWx3aXRoIHMgPSByYWlzZShGYWlsdXJlIHMpXG5sZXQgaW52YWxpZF9hcmcgcyA9IHJhaXNlKEludmFsaWRfYXJndW1lbnQgcylcblxuZXhjZXB0aW9uIEV4aXRcblxuKCogQ29tcG9zaXRpb24gb3BlcmF0b3JzICopXG5cbmV4dGVybmFsICggfD4gKSA6ICdhIC0+ICgnYSAtPiAnYikgLT4gJ2IgPSBcIiVyZXZhcHBseVwiXG5leHRlcm5hbCAoIEBAICkgOiAoJ2EgLT4gJ2IpIC0+ICdhIC0+ICdiID0gXCIlYXBwbHlcIlxuXG4oKiBEZWJ1Z2dpbmcgKilcblxuZXh0ZXJuYWwgX19MT0NfXyA6IHN0cmluZyA9IFwiJWxvY19MT0NcIlxuZXh0ZXJuYWwgX19GSUxFX18gOiBzdHJpbmcgPSBcIiVsb2NfRklMRVwiXG5leHRlcm5hbCBfX0xJTkVfXyA6IGludCA9IFwiJWxvY19MSU5FXCJcbmV4dGVybmFsIF9fTU9EVUxFX18gOiBzdHJpbmcgPSBcIiVsb2NfTU9EVUxFXCJcbmV4dGVybmFsIF9fUE9TX18gOiBzdHJpbmcgKiBpbnQgKiBpbnQgKiBpbnQgPSBcIiVsb2NfUE9TXCJcblxuZXh0ZXJuYWwgX19MT0NfT0ZfXyA6ICdhIC0+IHN0cmluZyAqICdhID0gXCIlbG9jX0xPQ1wiXG5leHRlcm5hbCBfX0xJTkVfT0ZfXyA6ICdhIC0+IGludCAqICdhID0gXCIlbG9jX0xJTkVcIlxuZXh0ZXJuYWwgX19QT1NfT0ZfXyA6ICdhIC0+IChzdHJpbmcgKiBpbnQgKiBpbnQgKiBpbnQpICogJ2EgPSBcIiVsb2NfUE9TXCJcblxuKCogQ29tcGFyaXNvbnMgKilcblxuZXh0ZXJuYWwgKCA9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZXF1YWxcIlxuZXh0ZXJuYWwgKCA8PiApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJW5vdGVxdWFsXCJcbmV4dGVybmFsICggPCApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWxlc3N0aGFuXCJcbmV4dGVybmFsICggPiApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWdyZWF0ZXJ0aGFuXCJcbmV4dGVybmFsICggPD0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVsZXNzZXF1YWxcIlxuZXh0ZXJuYWwgKCA+PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWdyZWF0ZXJlcXVhbFwiXG5leHRlcm5hbCBjb21wYXJlIDogJ2EgLT4gJ2EgLT4gaW50ID0gXCIlY29tcGFyZVwiXG5cbmxldCBtaW4geCB5ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmxldCBtYXggeCB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcblxuZXh0ZXJuYWwgKCA9PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWVxXCJcbmV4dGVybmFsICggIT0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVub3RlcVwiXG5cbigqIEJvb2xlYW4gb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBub3QgOiBib29sIC0+IGJvb2wgPSBcIiVib29sbm90XCJcbmV4dGVybmFsICggJiApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1YW5kXCJcbmV4dGVybmFsICggJiYgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdWFuZFwiXG5leHRlcm5hbCAoIG9yICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVvclwiXG5leHRlcm5hbCAoIHx8ICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVvclwiXG5cbigqIEludGVnZXIgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCAoIH4tICkgOiBpbnQgLT4gaW50ID0gXCIlbmVnaW50XCJcbmV4dGVybmFsICggfisgKSA6IGludCAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBzdWNjIDogaW50IC0+IGludCA9IFwiJXN1Y2NpbnRcIlxuZXh0ZXJuYWwgcHJlZCA6IGludCAtPiBpbnQgPSBcIiVwcmVkaW50XCJcbmV4dGVybmFsICggKyApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhZGRpbnRcIlxuZXh0ZXJuYWwgKCAtICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJXN1YmludFwiXG5leHRlcm5hbCAoICogKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbXVsaW50XCJcbmV4dGVybmFsICggLyApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVkaXZpbnRcIlxuZXh0ZXJuYWwgKCBtb2QgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbW9kaW50XCJcblxubGV0IGFicyB4ID0gaWYgeCA+PSAwIHRoZW4geCBlbHNlIC14XG5cbmV4dGVybmFsICggbGFuZCApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhbmRpbnRcIlxuZXh0ZXJuYWwgKCBsb3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlb3JpbnRcIlxuZXh0ZXJuYWwgKCBseG9yICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJXhvcmludFwiXG5cbmxldCBsbm90IHggPSB4IGx4b3IgKC0xKVxuXG5leHRlcm5hbCAoIGxzbCApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc2xpbnRcIlxuZXh0ZXJuYWwgKCBsc3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbHNyaW50XCJcbmV4dGVybmFsICggYXNyICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFzcmludFwiXG5cbmxldCBtYXhfaW50ID0gKC0xKSBsc3IgMVxubGV0IG1pbl9pbnQgPSBtYXhfaW50ICsgMVxuXG4oKiBGbG9hdGluZy1wb2ludCBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsICggfi0uICkgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJW5lZ2Zsb2F0XCJcbmV4dGVybmFsICggfisuICkgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsICggKy4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWRkZmxvYXRcIlxuZXh0ZXJuYWwgKCAtLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVzdWJmbG9hdFwiXG5leHRlcm5hbCAoICouICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJW11bGZsb2F0XCJcbmV4dGVybmFsICggLy4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlZGl2ZmxvYXRcIlxuZXh0ZXJuYWwgKCAqKiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfcG93ZXJfZmxvYXRcIiBcInBvd1wiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBfZmxvYXRcIiBcImV4cFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHBtMSA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cG0xX2Zsb2F0XCIgXCJjYW1sX2V4cG0xXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFjb3MgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hY29zX2Zsb2F0XCIgXCJhY29zXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFzaW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hc2luX2Zsb2F0XCIgXCJhc2luXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuX2Zsb2F0XCIgXCJhdGFuXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW4yIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbjJfZmxvYXRcIiBcImF0YW4yXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGh5cG90IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgICAgICAgICAgICAgID0gXCJjYW1sX2h5cG90X2Zsb2F0XCIgXCJjYW1sX2h5cG90XCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc19mbG9hdFwiIFwiY29zXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNvc2ggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jb3NoX2Zsb2F0XCIgXCJjb3NoXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZ19mbG9hdFwiIFwibG9nXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZzEwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nMTBfZmxvYXRcIiBcImxvZzEwXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZzFwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nMXBfZmxvYXRcIiBcImNhbWxfbG9nMXBcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2luIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc2luX2Zsb2F0XCIgXCJzaW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2luaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NpbmhfZmxvYXRcIiBcInNpbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc3FydCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NxcnRfZmxvYXRcIiBcInNxcnRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdGFuIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdGFuX2Zsb2F0XCIgXCJ0YW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdGFuaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3RhbmhfZmxvYXRcIiBcInRhbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY2VpbCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2NlaWxfZmxvYXRcIiBcImNlaWxcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZmxvb3IgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbG9vcl9mbG9hdFwiIFwiZmxvb3JcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWJzX2Zsb2F0IDogZmxvYXQgLT4gZmxvYXQgPSBcIiVhYnNmbG9hdFwiXG5leHRlcm5hbCBjb3B5c2lnbiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0XG4gICAgICAgICAgICAgICAgICA9IFwiY2FtbF9jb3B5c2lnbl9mbG9hdFwiIFwiY2FtbF9jb3B5c2lnblwiXG4gICAgICAgICAgICAgICAgICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbW9kX2Zsb2F0IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZm1vZF9mbG9hdFwiIFwiZm1vZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmcmV4cCA6IGZsb2F0IC0+IGZsb2F0ICogaW50ID0gXCJjYW1sX2ZyZXhwX2Zsb2F0XCJcbmV4dGVybmFsIGxkZXhwIDogKGZsb2F0IFtAdW5ib3hlZF0pIC0+IChpbnQgW0B1bnRhZ2dlZF0pIC0+IChmbG9hdCBbQHVuYm94ZWRdKSA9XG4gIFwiY2FtbF9sZGV4cF9mbG9hdFwiIFwiY2FtbF9sZGV4cF9mbG9hdF91bmJveGVkXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIG1vZGYgOiBmbG9hdCAtPiBmbG9hdCAqIGZsb2F0ID0gXCJjYW1sX21vZGZfZmxvYXRcIlxuZXh0ZXJuYWwgZmxvYXQgOiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdG9maW50XCJcbmV4dGVybmFsIGZsb2F0X29mX2ludCA6IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0b2ZpbnRcIlxuZXh0ZXJuYWwgdHJ1bmNhdGUgOiBmbG9hdCAtPiBpbnQgPSBcIiVpbnRvZmZsb2F0XCJcbmV4dGVybmFsIGludF9vZl9mbG9hdCA6IGZsb2F0IC0+IGludCA9IFwiJWludG9mZmxvYXRcIlxuZXh0ZXJuYWwgZmxvYXRfb2ZfYml0cyA6IGludDY0IC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNcIiBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c191bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmxldCBpbmZpbml0eSA9XG4gIGZsb2F0X29mX2JpdHMgMHg3Rl9GMF8wMF8wMF8wMF8wMF8wMF8wMExcbmxldCBuZWdfaW5maW5pdHkgPVxuICBmbG9hdF9vZl9iaXRzIDB4RkZfRjBfMDBfMDBfMDBfMDBfMDBfMDBMXG5sZXQgbmFuID1cbiAgZmxvYXRfb2ZfYml0cyAweDdGX0YwXzAwXzAwXzAwXzAwXzAwXzAxTFxubGV0IG1heF9mbG9hdCA9XG4gIGZsb2F0X29mX2JpdHMgMHg3Rl9FRl9GRl9GRl9GRl9GRl9GRl9GRkxcbmxldCBtaW5fZmxvYXQgPVxuICBmbG9hdF9vZl9iaXRzIDB4MDBfMTBfMDBfMDBfMDBfMDBfMDBfMDBMXG5sZXQgZXBzaWxvbl9mbG9hdCA9XG4gIGZsb2F0X29mX2JpdHMgMHgzQ19CMF8wMF8wMF8wMF8wMF8wMF8wMExcblxudHlwZSBmcGNsYXNzID1cbiAgICBGUF9ub3JtYWxcbiAgfCBGUF9zdWJub3JtYWxcbiAgfCBGUF96ZXJvXG4gIHwgRlBfaW5maW5pdGVcbiAgfCBGUF9uYW5cbmV4dGVybmFsIGNsYXNzaWZ5X2Zsb2F0IDogKGZsb2F0IFtAdW5ib3hlZF0pIC0+IGZwY2xhc3MgPVxuICBcImNhbWxfY2xhc3NpZnlfZmxvYXRcIiBcImNhbWxfY2xhc3NpZnlfZmxvYXRfdW5ib3hlZFwiIFtAQG5vYWxsb2NdXG5cbigqIFN0cmluZyBhbmQgYnl0ZSBzZXF1ZW5jZSBvcGVyYXRpb25zIC0tIG1vcmUgaW4gbW9kdWxlcyBTdHJpbmcgYW5kIEJ5dGVzICopXG5cbmV4dGVybmFsIHN0cmluZ19sZW5ndGggOiBzdHJpbmcgLT4gaW50ID0gXCIlc3RyaW5nX2xlbmd0aFwiXG5leHRlcm5hbCBieXRlc19sZW5ndGggOiBieXRlcyAtPiBpbnQgPSBcIiVieXRlc19sZW5ndGhcIlxuZXh0ZXJuYWwgYnl0ZXNfY3JlYXRlIDogaW50IC0+IGJ5dGVzID0gXCJjYW1sX2NyZWF0ZV9ieXRlc1wiXG5leHRlcm5hbCBzdHJpbmdfYmxpdCA6IHN0cmluZyAtPiBpbnQgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9ibGl0X3N0cmluZ1wiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBieXRlc19ibGl0IDogYnl0ZXMgLT4gaW50IC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9ieXRlc1wiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBieXRlc191bnNhZmVfdG9fc3RyaW5nIDogYnl0ZXMgLT4gc3RyaW5nID0gXCIlYnl0ZXNfdG9fc3RyaW5nXCJcblxubGV0ICggXiApIHMxIHMyID1cbiAgbGV0IGwxID0gc3RyaW5nX2xlbmd0aCBzMSBhbmQgbDIgPSBzdHJpbmdfbGVuZ3RoIHMyIGluXG4gIGxldCBzID0gYnl0ZXNfY3JlYXRlIChsMSArIGwyKSBpblxuICBzdHJpbmdfYmxpdCBzMSAwIHMgMCBsMTtcbiAgc3RyaW5nX2JsaXQgczIgMCBzIGwxIGwyO1xuICBieXRlc191bnNhZmVfdG9fc3RyaW5nIHNcblxuKCogQ2hhcmFjdGVyIG9wZXJhdGlvbnMgLS0gbW9yZSBpbiBtb2R1bGUgQ2hhciAqKVxuXG5leHRlcm5hbCBpbnRfb2ZfY2hhciA6IGNoYXIgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgdW5zYWZlX2NoYXJfb2ZfaW50IDogaW50IC0+IGNoYXIgPSBcIiVpZGVudGl0eVwiXG5sZXQgY2hhcl9vZl9pbnQgbiA9XG4gIGlmIG4gPCAwIHx8IG4gPiAyNTUgdGhlbiBpbnZhbGlkX2FyZyBcImNoYXJfb2ZfaW50XCIgZWxzZSB1bnNhZmVfY2hhcl9vZl9pbnQgblxuXG4oKiBVbml0IG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgaWdub3JlIDogJ2EgLT4gdW5pdCA9IFwiJWlnbm9yZVwiXG5cbigqIFBhaXIgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBmc3QgOiAnYSAqICdiIC0+ICdhID0gXCIlZmllbGQwXCJcbmV4dGVybmFsIHNuZCA6ICdhICogJ2IgLT4gJ2IgPSBcIiVmaWVsZDFcIlxuXG4oKiBSZWZlcmVuY2VzICopXG5cbnR5cGUgJ2EgcmVmID0geyBtdXRhYmxlIGNvbnRlbnRzIDogJ2EgfVxuZXh0ZXJuYWwgcmVmIDogJ2EgLT4gJ2EgcmVmID0gXCIlbWFrZW11dGFibGVcIlxuZXh0ZXJuYWwgKCAhICkgOiAnYSByZWYgLT4gJ2EgPSBcIiVmaWVsZDBcIlxuZXh0ZXJuYWwgKCA6PSApIDogJ2EgcmVmIC0+ICdhIC0+IHVuaXQgPSBcIiVzZXRmaWVsZDBcIlxuZXh0ZXJuYWwgaW5jciA6IGludCByZWYgLT4gdW5pdCA9IFwiJWluY3JcIlxuZXh0ZXJuYWwgZGVjciA6IGludCByZWYgLT4gdW5pdCA9IFwiJWRlY3JcIlxuXG4oKiBSZXN1bHQgdHlwZSAqKVxuXG50eXBlICgnYSwnYikgcmVzdWx0ID0gT2sgb2YgJ2EgfCBFcnJvciBvZiAnYlxuXG4oKiBTdHJpbmcgY29udmVyc2lvbiBmdW5jdGlvbnMgKilcblxuZXh0ZXJuYWwgZm9ybWF0X2ludCA6IHN0cmluZyAtPiBpbnQgLT4gc3RyaW5nID0gXCJjYW1sX2Zvcm1hdF9pbnRcIlxuZXh0ZXJuYWwgZm9ybWF0X2Zsb2F0IDogc3RyaW5nIC0+IGZsb2F0IC0+IHN0cmluZyA9IFwiY2FtbF9mb3JtYXRfZmxvYXRcIlxuXG5sZXQgc3RyaW5nX29mX2Jvb2wgYiA9XG4gIGlmIGIgdGhlbiBcInRydWVcIiBlbHNlIFwiZmFsc2VcIlxubGV0IGJvb2xfb2Zfc3RyaW5nID0gZnVuY3Rpb25cbiAgfCBcInRydWVcIiAtPiB0cnVlXG4gIHwgXCJmYWxzZVwiIC0+IGZhbHNlXG4gIHwgXyAtPiBpbnZhbGlkX2FyZyBcImJvb2xfb2Zfc3RyaW5nXCJcblxubGV0IGJvb2xfb2Zfc3RyaW5nX29wdCA9IGZ1bmN0aW9uXG4gIHwgXCJ0cnVlXCIgLT4gU29tZSB0cnVlXG4gIHwgXCJmYWxzZVwiIC0+IFNvbWUgZmFsc2VcbiAgfCBfIC0+IE5vbmVcblxubGV0IHN0cmluZ19vZl9pbnQgbiA9XG4gIGZvcm1hdF9pbnQgXCIlZFwiIG5cblxuZXh0ZXJuYWwgaW50X29mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQgPSBcImNhbWxfaW50X29mX3N0cmluZ1wiXG5cbmxldCBpbnRfb2Zfc3RyaW5nX29wdCBzID1cbiAgKCogVE9ETzogcHJvdmlkZSB0aGlzIGRpcmVjdGx5IGFzIGEgbm9uLXJhaXNpbmcgcHJpbWl0aXZlLiAqKVxuICB0cnkgU29tZSAoaW50X29mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbmV4dGVybmFsIHN0cmluZ19nZXQgOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgPSBcIiVzdHJpbmdfc2FmZV9nZXRcIlxuXG5sZXQgdmFsaWRfZmxvYXRfbGV4ZW0gcyA9XG4gIGxldCBsID0gc3RyaW5nX2xlbmd0aCBzIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID49IGwgdGhlbiBzIF4gXCIuXCIgZWxzZVxuICAgIG1hdGNoIHN0cmluZ19nZXQgcyBpIHdpdGhcbiAgICB8ICcwJyAuLiAnOScgfCAnLScgLT4gbG9vcCAoaSArIDEpXG4gICAgfCBfIC0+IHNcbiAgaW5cbiAgbG9vcCAwXG5cbmxldCBzdHJpbmdfb2ZfZmxvYXQgZiA9IHZhbGlkX2Zsb2F0X2xleGVtIChmb3JtYXRfZmxvYXQgXCIlLjEyZ1wiIGYpXG5cbmV4dGVybmFsIGZsb2F0X29mX3N0cmluZyA6IHN0cmluZyAtPiBmbG9hdCA9IFwiY2FtbF9mbG9hdF9vZl9zdHJpbmdcIlxuXG5sZXQgZmxvYXRfb2Zfc3RyaW5nX29wdCBzID1cbiAgKCogVE9ETzogcHJvdmlkZSB0aGlzIGRpcmVjdGx5IGFzIGEgbm9uLXJhaXNpbmcgcHJpbWl0aXZlLiAqKVxuICB0cnkgU29tZSAoZmxvYXRfb2Zfc3RyaW5nIHMpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxuKCogTGlzdCBvcGVyYXRpb25zIC0tIG1vcmUgaW4gbW9kdWxlIExpc3QgKilcblxubGV0IHJlYyAoIEAgKSBsMSBsMiA9XG4gIG1hdGNoIGwxIHdpdGhcbiAgICBbXSAtPiBsMlxuICB8IGhkIDo6IHRsIC0+IGhkIDo6ICh0bCBAIGwyKVxuXG4oKiBJL08gb3BlcmF0aW9ucyAqKVxuXG50eXBlIGluX2NoYW5uZWxcbnR5cGUgb3V0X2NoYW5uZWxcblxuZXh0ZXJuYWwgb3Blbl9kZXNjcmlwdG9yX291dCA6IGludCAtPiBvdXRfY2hhbm5lbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3Jfb3V0XCJcbmV4dGVybmFsIG9wZW5fZGVzY3JpcHRvcl9pbiA6IGludCAtPiBpbl9jaGFubmVsID0gXCJjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pblwiXG5cbmxldCBzdGRpbiA9IG9wZW5fZGVzY3JpcHRvcl9pbiAwXG5sZXQgc3Rkb3V0ID0gb3Blbl9kZXNjcmlwdG9yX291dCAxXG5sZXQgc3RkZXJyID0gb3Blbl9kZXNjcmlwdG9yX291dCAyXG5cbigqIEdlbmVyYWwgb3V0cHV0IGZ1bmN0aW9ucyAqKVxuXG50eXBlIG9wZW5fZmxhZyA9XG4gICAgT3Blbl9yZG9ubHkgfCBPcGVuX3dyb25seSB8IE9wZW5fYXBwZW5kXG4gIHwgT3Blbl9jcmVhdCB8IE9wZW5fdHJ1bmMgfCBPcGVuX2V4Y2xcbiAgfCBPcGVuX2JpbmFyeSB8IE9wZW5fdGV4dCB8IE9wZW5fbm9uYmxvY2tcblxuZXh0ZXJuYWwgb3Blbl9kZXNjIDogc3RyaW5nIC0+IG9wZW5fZmxhZyBsaXN0IC0+IGludCAtPiBpbnQgPSBcImNhbWxfc3lzX29wZW5cIlxuXG5leHRlcm5hbCBzZXRfb3V0X2NoYW5uZWxfbmFtZTogb3V0X2NoYW5uZWwgLT4gc3RyaW5nIC0+IHVuaXQgPVxuICBcImNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZVwiXG5cbmxldCBvcGVuX291dF9nZW4gbW9kZSBwZXJtIG5hbWUgPVxuICBsZXQgYyA9IG9wZW5fZGVzY3JpcHRvcl9vdXQob3Blbl9kZXNjIG5hbWUgbW9kZSBwZXJtKSBpblxuICBzZXRfb3V0X2NoYW5uZWxfbmFtZSBjIG5hbWU7XG4gIGNcblxubGV0IG9wZW5fb3V0IG5hbWUgPVxuICBvcGVuX291dF9nZW4gW09wZW5fd3Jvbmx5OyBPcGVuX2NyZWF0OyBPcGVuX3RydW5jOyBPcGVuX3RleHRdIDBvNjY2IG5hbWVcblxubGV0IG9wZW5fb3V0X2JpbiBuYW1lID1cbiAgb3Blbl9vdXRfZ2VuIFtPcGVuX3dyb25seTsgT3Blbl9jcmVhdDsgT3Blbl90cnVuYzsgT3Blbl9iaW5hcnldIDBvNjY2IG5hbWVcblxuZXh0ZXJuYWwgZmx1c2ggOiBvdXRfY2hhbm5lbCAtPiB1bml0ID0gXCJjYW1sX21sX2ZsdXNoXCJcblxuZXh0ZXJuYWwgb3V0X2NoYW5uZWxzX2xpc3QgOiB1bml0IC0+IG91dF9jaGFubmVsIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX291dF9jaGFubmVsc19saXN0XCJcblxubGV0IGZsdXNoX2FsbCAoKSA9XG4gIGxldCByZWMgaXRlciA9IGZ1bmN0aW9uXG4gICAgICBbXSAtPiAoKVxuICAgIHwgYTo6bCAtPlxuICAgICAgICBiZWdpbiB0cnlcbiAgICAgICAgICAgIGZsdXNoIGFcbiAgICAgICAgd2l0aCBTeXNfZXJyb3IgXyAtPlxuICAgICAgICAgICgpICgqIGlnbm9yZSBjaGFubmVscyBjbG9zZWQgZHVyaW5nIGEgcHJlY2VkaW5nIGZsdXNoLiAqKVxuICAgICAgICBlbmQ7XG4gICAgICAgIGl0ZXIgbFxuICBpbiBpdGVyIChvdXRfY2hhbm5lbHNfbGlzdCAoKSlcblxuZXh0ZXJuYWwgdW5zYWZlX291dHB1dCA6IG91dF9jaGFubmVsIC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9vdXRwdXRfYnl0ZXNcIlxuZXh0ZXJuYWwgdW5zYWZlX291dHB1dF9zdHJpbmcgOiBvdXRfY2hhbm5lbCAtPiBzdHJpbmcgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9vdXRwdXRcIlxuXG5leHRlcm5hbCBvdXRwdXRfY2hhciA6IG91dF9jaGFubmVsIC0+IGNoYXIgLT4gdW5pdCA9IFwiY2FtbF9tbF9vdXRwdXRfY2hhclwiXG5cbmxldCBvdXRwdXRfYnl0ZXMgb2MgcyA9XG4gIHVuc2FmZV9vdXRwdXQgb2MgcyAwIChieXRlc19sZW5ndGggcylcblxubGV0IG91dHB1dF9zdHJpbmcgb2MgcyA9XG4gIHVuc2FmZV9vdXRwdXRfc3RyaW5nIG9jIHMgMCAoc3RyaW5nX2xlbmd0aCBzKVxuXG5sZXQgb3V0cHV0IG9jIHMgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBieXRlc19sZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwib3V0cHV0XCJcbiAgZWxzZSB1bnNhZmVfb3V0cHV0IG9jIHMgb2ZzIGxlblxuXG5sZXQgb3V0cHV0X3N1YnN0cmluZyBvYyBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gc3RyaW5nX2xlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJvdXRwdXRfc3Vic3RyaW5nXCJcbiAgZWxzZSB1bnNhZmVfb3V0cHV0X3N0cmluZyBvYyBzIG9mcyBsZW5cblxuZXh0ZXJuYWwgb3V0cHV0X2J5dGUgOiBvdXRfY2hhbm5lbCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9tbF9vdXRwdXRfY2hhclwiXG5leHRlcm5hbCBvdXRwdXRfYmluYXJ5X2ludCA6IG91dF9jaGFubmVsIC0+IGludCAtPiB1bml0ID0gXCJjYW1sX21sX291dHB1dF9pbnRcIlxuXG5leHRlcm5hbCBtYXJzaGFsX3RvX2NoYW5uZWwgOiBvdXRfY2hhbm5lbCAtPiAnYSAtPiB1bml0IGxpc3QgLT4gdW5pdFxuICAgICA9IFwiY2FtbF9vdXRwdXRfdmFsdWVcIlxubGV0IG91dHB1dF92YWx1ZSBjaGFuIHYgPSBtYXJzaGFsX3RvX2NoYW5uZWwgY2hhbiB2IFtdXG5cbmV4dGVybmFsIHNlZWtfb3V0IDogb3V0X2NoYW5uZWwgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfbWxfc2Vla19vdXRcIlxuZXh0ZXJuYWwgcG9zX291dCA6IG91dF9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9wb3Nfb3V0XCJcbmV4dGVybmFsIG91dF9jaGFubmVsX2xlbmd0aCA6IG91dF9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9jaGFubmVsX3NpemVcIlxuZXh0ZXJuYWwgY2xvc2Vfb3V0X2NoYW5uZWwgOiBvdXRfY2hhbm5lbCAtPiB1bml0ID0gXCJjYW1sX21sX2Nsb3NlX2NoYW5uZWxcIlxubGV0IGNsb3NlX291dCBvYyA9IGZsdXNoIG9jOyBjbG9zZV9vdXRfY2hhbm5lbCBvY1xubGV0IGNsb3NlX291dF9ub2VyciBvYyA9XG4gICh0cnkgZmx1c2ggb2Mgd2l0aCBfIC0+ICgpKTtcbiAgKHRyeSBjbG9zZV9vdXRfY2hhbm5lbCBvYyB3aXRoIF8gLT4gKCkpXG5leHRlcm5hbCBzZXRfYmluYXJ5X21vZGVfb3V0IDogb3V0X2NoYW5uZWwgLT4gYm9vbCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX3NldF9iaW5hcnlfbW9kZVwiXG5cbigqIEdlbmVyYWwgaW5wdXQgZnVuY3Rpb25zICopXG5cbmV4dGVybmFsIHNldF9pbl9jaGFubmVsX25hbWU6IGluX2NoYW5uZWwgLT4gc3RyaW5nIC0+IHVuaXQgPVxuICBcImNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZVwiXG5cbmxldCBvcGVuX2luX2dlbiBtb2RlIHBlcm0gbmFtZSA9XG4gIGxldCBjID0gb3Blbl9kZXNjcmlwdG9yX2luKG9wZW5fZGVzYyBuYW1lIG1vZGUgcGVybSkgaW5cbiAgc2V0X2luX2NoYW5uZWxfbmFtZSBjIG5hbWU7XG4gIGNcblxubGV0IG9wZW5faW4gbmFtZSA9XG4gIG9wZW5faW5fZ2VuIFtPcGVuX3Jkb25seTsgT3Blbl90ZXh0XSAwIG5hbWVcblxubGV0IG9wZW5faW5fYmluIG5hbWUgPVxuICBvcGVuX2luX2dlbiBbT3Blbl9yZG9ubHk7IE9wZW5fYmluYXJ5XSAwIG5hbWVcblxuZXh0ZXJuYWwgaW5wdXRfY2hhciA6IGluX2NoYW5uZWwgLT4gY2hhciA9IFwiY2FtbF9tbF9pbnB1dF9jaGFyXCJcblxuZXh0ZXJuYWwgdW5zYWZlX2lucHV0IDogaW5fY2hhbm5lbCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IGludFxuICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX2lucHV0XCJcblxubGV0IGlucHV0IGljIHMgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBieXRlc19sZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiaW5wdXRcIlxuICBlbHNlIHVuc2FmZV9pbnB1dCBpYyBzIG9mcyBsZW5cblxubGV0IHJlYyB1bnNhZmVfcmVhbGx5X2lucHV0IGljIHMgb2ZzIGxlbiA9XG4gIGlmIGxlbiA8PSAwIHRoZW4gKCkgZWxzZSBiZWdpblxuICAgIGxldCByID0gdW5zYWZlX2lucHV0IGljIHMgb2ZzIGxlbiBpblxuICAgIGlmIHIgPSAwXG4gICAgdGhlbiByYWlzZSBFbmRfb2ZfZmlsZVxuICAgIGVsc2UgdW5zYWZlX3JlYWxseV9pbnB1dCBpYyBzIChvZnMgKyByKSAobGVuIC0gcilcbiAgZW5kXG5cbmxldCByZWFsbHlfaW5wdXQgaWMgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGJ5dGVzX2xlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJyZWFsbHlfaW5wdXRcIlxuICBlbHNlIHVuc2FmZV9yZWFsbHlfaW5wdXQgaWMgcyBvZnMgbGVuXG5cbmxldCByZWFsbHlfaW5wdXRfc3RyaW5nIGljIGxlbiA9XG4gIGxldCBzID0gYnl0ZXNfY3JlYXRlIGxlbiBpblxuICByZWFsbHlfaW5wdXQgaWMgcyAwIGxlbjtcbiAgYnl0ZXNfdW5zYWZlX3RvX3N0cmluZyBzXG5cbmV4dGVybmFsIGlucHV0X3NjYW5fbGluZSA6IGluX2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX2lucHV0X3NjYW5fbGluZVwiXG5cbmxldCBpbnB1dF9saW5lIGNoYW4gPVxuICBsZXQgcmVjIGJ1aWxkX3Jlc3VsdCBidWYgcG9zID0gZnVuY3Rpb25cbiAgICBbXSAtPiBidWZcbiAgfCBoZCA6OiB0bCAtPlxuICAgICAgbGV0IGxlbiA9IGJ5dGVzX2xlbmd0aCBoZCBpblxuICAgICAgYnl0ZXNfYmxpdCBoZCAwIGJ1ZiAocG9zIC0gbGVuKSBsZW47XG4gICAgICBidWlsZF9yZXN1bHQgYnVmIChwb3MgLSBsZW4pIHRsIGluXG4gIGxldCByZWMgc2NhbiBhY2N1IGxlbiA9XG4gICAgbGV0IG4gPSBpbnB1dF9zY2FuX2xpbmUgY2hhbiBpblxuICAgIGlmIG4gPSAwIHRoZW4gYmVnaW4gICAgICAgICAgICAgICAgICAgKCogbiA9IDA6IHdlIGFyZSBhdCBFT0YgKilcbiAgICAgIG1hdGNoIGFjY3Ugd2l0aFxuICAgICAgICBbXSAtPiByYWlzZSBFbmRfb2ZfZmlsZVxuICAgICAgfCBfICAtPiBidWlsZF9yZXN1bHQgKGJ5dGVzX2NyZWF0ZSBsZW4pIGxlbiBhY2N1XG4gICAgZW5kIGVsc2UgaWYgbiA+IDAgdGhlbiBiZWdpbiAgICAgICAgICAoKiBuID4gMDogbmV3bGluZSBmb3VuZCBpbiBidWZmZXIgKilcbiAgICAgIGxldCByZXMgPSBieXRlc19jcmVhdGUgKG4gLSAxKSBpblxuICAgICAgaWdub3JlICh1bnNhZmVfaW5wdXQgY2hhbiByZXMgMCAobiAtIDEpKTtcbiAgICAgIGlnbm9yZSAoaW5wdXRfY2hhciBjaGFuKTsgICAgICAgICAgICgqIHNraXAgdGhlIG5ld2xpbmUgKilcbiAgICAgIG1hdGNoIGFjY3Ugd2l0aFxuICAgICAgICBbXSAtPiByZXNcbiAgICAgIHwgIF8gLT4gbGV0IGxlbiA9IGxlbiArIG4gLSAxIGluXG4gICAgICAgICAgICAgIGJ1aWxkX3Jlc3VsdCAoYnl0ZXNfY3JlYXRlIGxlbikgbGVuIChyZXMgOjogYWNjdSlcbiAgICBlbmQgZWxzZSBiZWdpbiAgICAgICAgICAgICAgICAgICAgICAgICgqIG4gPCAwOiBuZXdsaW5lIG5vdCBmb3VuZCAqKVxuICAgICAgbGV0IGJlZyA9IGJ5dGVzX2NyZWF0ZSAoLW4pIGluXG4gICAgICBpZ25vcmUodW5zYWZlX2lucHV0IGNoYW4gYmVnIDAgKC1uKSk7XG4gICAgICBzY2FuIChiZWcgOjogYWNjdSkgKGxlbiAtIG4pXG4gICAgZW5kXG4gIGluIGJ5dGVzX3Vuc2FmZV90b19zdHJpbmcgKHNjYW4gW10gMClcblxuZXh0ZXJuYWwgaW5wdXRfYnl0ZSA6IGluX2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX2lucHV0X2NoYXJcIlxuZXh0ZXJuYWwgaW5wdXRfYmluYXJ5X2ludCA6IGluX2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX2lucHV0X2ludFwiXG5leHRlcm5hbCBpbnB1dF92YWx1ZSA6IGluX2NoYW5uZWwgLT4gJ2EgPSBcImNhbWxfaW5wdXRfdmFsdWVcIlxuZXh0ZXJuYWwgc2Vla19pbiA6IGluX2NoYW5uZWwgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfbWxfc2Vla19pblwiXG5leHRlcm5hbCBwb3NfaW4gOiBpbl9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9wb3NfaW5cIlxuZXh0ZXJuYWwgaW5fY2hhbm5lbF9sZW5ndGggOiBpbl9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9jaGFubmVsX3NpemVcIlxuZXh0ZXJuYWwgY2xvc2VfaW4gOiBpbl9jaGFubmVsIC0+IHVuaXQgPSBcImNhbWxfbWxfY2xvc2VfY2hhbm5lbFwiXG5sZXQgY2xvc2VfaW5fbm9lcnIgaWMgPSAodHJ5IGNsb3NlX2luIGljIHdpdGggXyAtPiAoKSlcbmV4dGVybmFsIHNldF9iaW5hcnlfbW9kZV9pbiA6IGluX2NoYW5uZWwgLT4gYm9vbCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfc2V0X2JpbmFyeV9tb2RlXCJcblxuKCogT3V0cHV0IGZ1bmN0aW9ucyBvbiBzdGFuZGFyZCBvdXRwdXQgKilcblxubGV0IHByaW50X2NoYXIgYyA9IG91dHB1dF9jaGFyIHN0ZG91dCBjXG5sZXQgcHJpbnRfc3RyaW5nIHMgPSBvdXRwdXRfc3RyaW5nIHN0ZG91dCBzXG5sZXQgcHJpbnRfYnl0ZXMgcyA9IG91dHB1dF9ieXRlcyBzdGRvdXQgc1xubGV0IHByaW50X2ludCBpID0gb3V0cHV0X3N0cmluZyBzdGRvdXQgKHN0cmluZ19vZl9pbnQgaSlcbmxldCBwcmludF9mbG9hdCBmID0gb3V0cHV0X3N0cmluZyBzdGRvdXQgKHN0cmluZ19vZl9mbG9hdCBmKVxubGV0IHByaW50X2VuZGxpbmUgcyA9XG4gIG91dHB1dF9zdHJpbmcgc3Rkb3V0IHM7IG91dHB1dF9jaGFyIHN0ZG91dCAnXFxuJzsgZmx1c2ggc3Rkb3V0XG5sZXQgcHJpbnRfbmV3bGluZSAoKSA9IG91dHB1dF9jaGFyIHN0ZG91dCAnXFxuJzsgZmx1c2ggc3Rkb3V0XG5cbigqIE91dHB1dCBmdW5jdGlvbnMgb24gc3RhbmRhcmQgZXJyb3IgKilcblxubGV0IHByZXJyX2NoYXIgYyA9IG91dHB1dF9jaGFyIHN0ZGVyciBjXG5sZXQgcHJlcnJfc3RyaW5nIHMgPSBvdXRwdXRfc3RyaW5nIHN0ZGVyciBzXG5sZXQgcHJlcnJfYnl0ZXMgcyA9IG91dHB1dF9ieXRlcyBzdGRlcnIgc1xubGV0IHByZXJyX2ludCBpID0gb3V0cHV0X3N0cmluZyBzdGRlcnIgKHN0cmluZ19vZl9pbnQgaSlcbmxldCBwcmVycl9mbG9hdCBmID0gb3V0cHV0X3N0cmluZyBzdGRlcnIgKHN0cmluZ19vZl9mbG9hdCBmKVxubGV0IHByZXJyX2VuZGxpbmUgcyA9XG4gIG91dHB1dF9zdHJpbmcgc3RkZXJyIHM7IG91dHB1dF9jaGFyIHN0ZGVyciAnXFxuJzsgZmx1c2ggc3RkZXJyXG5sZXQgcHJlcnJfbmV3bGluZSAoKSA9IG91dHB1dF9jaGFyIHN0ZGVyciAnXFxuJzsgZmx1c2ggc3RkZXJyXG5cbigqIElucHV0IGZ1bmN0aW9ucyBvbiBzdGFuZGFyZCBpbnB1dCAqKVxuXG5sZXQgcmVhZF9saW5lICgpID0gZmx1c2ggc3Rkb3V0OyBpbnB1dF9saW5lIHN0ZGluXG5sZXQgcmVhZF9pbnQgKCkgPSBpbnRfb2Zfc3RyaW5nKHJlYWRfbGluZSgpKVxubGV0IHJlYWRfaW50X29wdCAoKSA9IGludF9vZl9zdHJpbmdfb3B0KHJlYWRfbGluZSgpKVxubGV0IHJlYWRfZmxvYXQgKCkgPSBmbG9hdF9vZl9zdHJpbmcocmVhZF9saW5lKCkpXG5sZXQgcmVhZF9mbG9hdF9vcHQgKCkgPSBmbG9hdF9vZl9zdHJpbmdfb3B0KHJlYWRfbGluZSgpKVxuXG4oKiBPcGVyYXRpb25zIG9uIGxhcmdlIGZpbGVzICopXG5cbm1vZHVsZSBMYXJnZUZpbGUgPVxuICBzdHJ1Y3RcbiAgICBleHRlcm5hbCBzZWVrX291dCA6IG91dF9jaGFubmVsIC0+IGludDY0IC0+IHVuaXQgPSBcImNhbWxfbWxfc2Vla19vdXRfNjRcIlxuICAgIGV4dGVybmFsIHBvc19vdXQgOiBvdXRfY2hhbm5lbCAtPiBpbnQ2NCA9IFwiY2FtbF9tbF9wb3Nfb3V0XzY0XCJcbiAgICBleHRlcm5hbCBvdXRfY2hhbm5lbF9sZW5ndGggOiBvdXRfY2hhbm5lbCAtPiBpbnQ2NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9jaGFubmVsX3NpemVfNjRcIlxuICAgIGV4dGVybmFsIHNlZWtfaW4gOiBpbl9jaGFubmVsIC0+IGludDY0IC0+IHVuaXQgPSBcImNhbWxfbWxfc2Vla19pbl82NFwiXG4gICAgZXh0ZXJuYWwgcG9zX2luIDogaW5fY2hhbm5lbCAtPiBpbnQ2NCA9IFwiY2FtbF9tbF9wb3NfaW5fNjRcIlxuICAgIGV4dGVybmFsIGluX2NoYW5uZWxfbGVuZ3RoIDogaW5fY2hhbm5lbCAtPiBpbnQ2NCA9IFwiY2FtbF9tbF9jaGFubmVsX3NpemVfNjRcIlxuICBlbmRcblxuKCogRm9ybWF0cyAqKVxuXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2XG4gICA9ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuZm9ybWF0NlxuICAgPSBGb3JtYXQgb2YgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mbXRcbiAgICAgICAgICAgICAgICogc3RyaW5nXG5cbnR5cGUgKCdhLCAnYiwgJ2MsICdkKSBmb3JtYXQ0ID0gKCdhLCAnYiwgJ2MsICdjLCAnYywgJ2QpIGZvcm1hdDZcblxudHlwZSAoJ2EsICdiLCAnYykgZm9ybWF0ID0gKCdhLCAnYiwgJ2MsICdjKSBmb3JtYXQ0XG5cbmxldCBzdHJpbmdfb2ZfZm9ybWF0IChGb3JtYXQgKF9mbXQsIHN0cikpID0gc3RyXG5cbmV4dGVybmFsIGZvcm1hdF9vZl9zdHJpbmcgOlxuICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+XG4gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgPSBcIiVpZGVudGl0eVwiXG5cbmxldCAoIF5eICkgKEZvcm1hdCAoZm10MSwgc3RyMSkpIChGb3JtYXQgKGZtdDIsIHN0cjIpKSA9XG4gIEZvcm1hdCAoQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmNvbmNhdF9mbXQgZm10MSBmbXQyLFxuICAgICAgICAgIHN0cjEgXiBcIiUsXCIgXiBzdHIyKVxuXG4oKiBNaXNjZWxsYW5lb3VzICopXG5cbmV4dGVybmFsIHN5c19leGl0IDogaW50IC0+ICdhID0gXCJjYW1sX3N5c19leGl0XCJcblxubGV0IGV4aXRfZnVuY3Rpb24gPSByZWYgZmx1c2hfYWxsXG5cbmxldCBhdF9leGl0IGYgPVxuICBsZXQgZyA9ICFleGl0X2Z1bmN0aW9uIGluXG4gIGV4aXRfZnVuY3Rpb24gOj0gKGZ1biAoKSAtPiBmKCk7IGcoKSlcblxubGV0IGRvX2F0X2V4aXQgKCkgPSAoIWV4aXRfZnVuY3Rpb24pICgpXG5cbmxldCBleGl0IHJldGNvZGUgPVxuICBkb19hdF9leGl0ICgpO1xuICBzeXNfZXhpdCByZXRjb2RlXG5cbmxldCBfID0gcmVnaXN0ZXJfbmFtZWRfdmFsdWUgXCJQZXJ2YXNpdmVzLmRvX2F0X2V4aXRcIiBkb19hdF9leGl0XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIExpc3Qgb3BlcmF0aW9ucyAqKVxuXG5sZXQgcmVjIGxlbmd0aF9hdXggbGVuID0gZnVuY3Rpb25cbiAgICBbXSAtPiBsZW5cbiAgfCBfOjpsIC0+IGxlbmd0aF9hdXggKGxlbiArIDEpIGxcblxubGV0IGxlbmd0aCBsID0gbGVuZ3RoX2F1eCAwIGxcblxubGV0IGNvbnMgYSBsID0gYTo6bFxuXG5sZXQgaGQgPSBmdW5jdGlvblxuICAgIFtdIC0+IGZhaWx3aXRoIFwiaGRcIlxuICB8IGE6Ol8gLT4gYVxuXG5sZXQgdGwgPSBmdW5jdGlvblxuICAgIFtdIC0+IGZhaWx3aXRoIFwidGxcIlxuICB8IF86OmwgLT4gbFxuXG5sZXQgbnRoIGwgbiA9XG4gIGlmIG4gPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJMaXN0Lm50aFwiIGVsc2VcbiAgbGV0IHJlYyBudGhfYXV4IGwgbiA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBmYWlsd2l0aCBcIm50aFwiXG4gICAgfCBhOjpsIC0+IGlmIG4gPSAwIHRoZW4gYSBlbHNlIG50aF9hdXggbCAobi0xKVxuICBpbiBudGhfYXV4IGwgblxuXG5sZXQgbnRoX29wdCBsIG4gPVxuICBpZiBuIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiTGlzdC5udGhcIiBlbHNlXG4gIGxldCByZWMgbnRoX2F1eCBsIG4gPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gLT4gTm9uZVxuICAgIHwgYTo6bCAtPiBpZiBuID0gMCB0aGVuIFNvbWUgYSBlbHNlIG50aF9hdXggbCAobi0xKVxuICBpbiBudGhfYXV4IGwgblxuXG5sZXQgYXBwZW5kID0gKEApXG5cbmxldCByZWMgcmV2X2FwcGVuZCBsMSBsMiA9XG4gIG1hdGNoIGwxIHdpdGhcbiAgICBbXSAtPiBsMlxuICB8IGEgOjogbCAtPiByZXZfYXBwZW5kIGwgKGEgOjogbDIpXG5cbmxldCByZXYgbCA9IHJldl9hcHBlbmQgbCBbXVxuXG5sZXQgcmVjIGluaXRfdGFpbHJlY19hdXggYWNjIGkgbiBmID1cbiAgaWYgaSA+PSBuIHRoZW4gYWNjXG4gIGVsc2UgaW5pdF90YWlscmVjX2F1eCAoZiBpIDo6IGFjYykgKGkrMSkgbiBmXG5cbmxldCByZWMgaW5pdF9hdXggaSBuIGYgPVxuICBpZiBpID49IG4gdGhlbiBbXVxuICBlbHNlXG4gICAgbGV0IHIgPSBmIGkgaW5cbiAgICByIDo6IGluaXRfYXV4IChpKzEpIG4gZlxuXG5sZXQgaW5pdCBsZW4gZiA9XG4gIGlmIGxlbiA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkxpc3QuaW5pdFwiIGVsc2VcbiAgaWYgbGVuID4gMTBfMDAwIHRoZW4gcmV2IChpbml0X3RhaWxyZWNfYXV4IFtdIDAgbGVuIGYpXG4gIGVsc2UgaW5pdF9hdXggMCBsZW4gZlxuXG5sZXQgcmVjIGZsYXR0ZW4gPSBmdW5jdGlvblxuICAgIFtdIC0+IFtdXG4gIHwgbDo6ciAtPiBsIEAgZmxhdHRlbiByXG5cbmxldCBjb25jYXQgPSBmbGF0dGVuXG5cbmxldCByZWMgbWFwIGYgPSBmdW5jdGlvblxuICAgIFtdIC0+IFtdXG4gIHwgYTo6bCAtPiBsZXQgciA9IGYgYSBpbiByIDo6IG1hcCBmIGxcblxubGV0IHJlYyBtYXBpIGkgZiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW11cbiAgfCBhOjpsIC0+IGxldCByID0gZiBpIGEgaW4gciA6OiBtYXBpIChpICsgMSkgZiBsXG5cbmxldCBtYXBpIGYgbCA9IG1hcGkgMCBmIGxcblxubGV0IHJldl9tYXAgZiBsID1cbiAgbGV0IHJlYyBybWFwX2YgYWNjdSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBhY2N1XG4gICAgfCBhOjpsIC0+IHJtYXBfZiAoZiBhIDo6IGFjY3UpIGxcbiAgaW5cbiAgcm1hcF9mIFtdIGxcblxuXG5sZXQgcmVjIGl0ZXIgZiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gKClcbiAgfCBhOjpsIC0+IGYgYTsgaXRlciBmIGxcblxubGV0IHJlYyBpdGVyaSBpIGYgPSBmdW5jdGlvblxuICAgIFtdIC0+ICgpXG4gIHwgYTo6bCAtPiBmIGkgYTsgaXRlcmkgKGkgKyAxKSBmIGxcblxubGV0IGl0ZXJpIGYgbCA9IGl0ZXJpIDAgZiBsXG5cbmxldCByZWMgZm9sZF9sZWZ0IGYgYWNjdSBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gICAgW10gLT4gYWNjdVxuICB8IGE6OmwgLT4gZm9sZF9sZWZ0IGYgKGYgYWNjdSBhKSBsXG5cbmxldCByZWMgZm9sZF9yaWdodCBmIGwgYWNjdSA9XG4gIG1hdGNoIGwgd2l0aFxuICAgIFtdIC0+IGFjY3VcbiAgfCBhOjpsIC0+IGYgYSAoZm9sZF9yaWdodCBmIGwgYWNjdSlcblxubGV0IHJlYyBtYXAyIGYgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gW11cbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IGxldCByID0gZiBhMSBhMiBpbiByIDo6IG1hcDIgZiBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QubWFwMlwiXG5cbmxldCByZXZfbWFwMiBmIGwxIGwyID1cbiAgbGV0IHJlYyBybWFwMl9mIGFjY3UgbDEgbDIgPVxuICAgIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICB8IChbXSwgW10pIC0+IGFjY3VcbiAgICB8IChhMTo6bDEsIGEyOjpsMikgLT4gcm1hcDJfZiAoZiBhMSBhMiA6OiBhY2N1KSBsMSBsMlxuICAgIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5yZXZfbWFwMlwiXG4gIGluXG4gIHJtYXAyX2YgW10gbDEgbDJcblxuXG5sZXQgcmVjIGl0ZXIyIGYgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gKClcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IGYgYTEgYTI7IGl0ZXIyIGYgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0Lml0ZXIyXCJcblxubGV0IHJlYyBmb2xkX2xlZnQyIGYgYWNjdSBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBhY2N1XG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBmb2xkX2xlZnQyIGYgKGYgYWNjdSBhMSBhMikgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LmZvbGRfbGVmdDJcIlxuXG5sZXQgcmVjIGZvbGRfcmlnaHQyIGYgbDEgbDIgYWNjdSA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBhY2N1XG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBmIGExIGEyIChmb2xkX3JpZ2h0MiBmIGwxIGwyIGFjY3UpXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5mb2xkX3JpZ2h0MlwiXG5cbmxldCByZWMgZm9yX2FsbCBwID0gZnVuY3Rpb25cbiAgICBbXSAtPiB0cnVlXG4gIHwgYTo6bCAtPiBwIGEgJiYgZm9yX2FsbCBwIGxcblxubGV0IHJlYyBleGlzdHMgcCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFsc2VcbiAgfCBhOjpsIC0+IHAgYSB8fCBleGlzdHMgcCBsXG5cbmxldCByZWMgZm9yX2FsbDIgcCBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiB0cnVlXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBwIGExIGEyICYmIGZvcl9hbGwyIHAgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LmZvcl9hbGwyXCJcblxubGV0IHJlYyBleGlzdHMyIHAgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gZmFsc2VcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IHAgYTEgYTIgfHwgZXhpc3RzMiBwIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5leGlzdHMyXCJcblxubGV0IHJlYyBtZW0geCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFsc2VcbiAgfCBhOjpsIC0+IGNvbXBhcmUgYSB4ID0gMCB8fCBtZW0geCBsXG5cbmxldCByZWMgbWVtcSB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBmYWxzZVxuICB8IGE6OmwgLT4gYSA9PSB4IHx8IG1lbXEgeCBsXG5cbmxldCByZWMgYXNzb2MgeCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgKGEsYik6OmwgLT4gaWYgY29tcGFyZSBhIHggPSAwIHRoZW4gYiBlbHNlIGFzc29jIHggbFxuXG5sZXQgcmVjIGFzc29jX29wdCB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBOb25lXG4gIHwgKGEsYik6OmwgLT4gaWYgY29tcGFyZSBhIHggPSAwIHRoZW4gU29tZSBiIGVsc2UgYXNzb2Nfb3B0IHggbFxuXG5sZXQgcmVjIGFzc3EgeCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgKGEsYik6OmwgLT4gaWYgYSA9PSB4IHRoZW4gYiBlbHNlIGFzc3EgeCBsXG5cbmxldCByZWMgYXNzcV9vcHQgeCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gTm9uZVxuICB8IChhLGIpOjpsIC0+IGlmIGEgPT0geCB0aGVuIFNvbWUgYiBlbHNlIGFzc3Ffb3B0IHggbFxuXG5sZXQgcmVjIG1lbV9hc3NvYyB4ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBmYWxzZVxuICB8IChhLCBfKSA6OiBsIC0+IGNvbXBhcmUgYSB4ID0gMCB8fCBtZW1fYXNzb2MgeCBsXG5cbmxldCByZWMgbWVtX2Fzc3EgeCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gZmFsc2VcbiAgfCAoYSwgXykgOjogbCAtPiBhID09IHggfHwgbWVtX2Fzc3EgeCBsXG5cbmxldCByZWMgcmVtb3ZlX2Fzc29jIHggPSBmdW5jdGlvblxuICB8IFtdIC0+IFtdXG4gIHwgKGEsIF8gYXMgcGFpcikgOjogbCAtPlxuICAgICAgaWYgY29tcGFyZSBhIHggPSAwIHRoZW4gbCBlbHNlIHBhaXIgOjogcmVtb3ZlX2Fzc29jIHggbFxuXG5sZXQgcmVjIHJlbW92ZV9hc3NxIHggPSBmdW5jdGlvblxuICB8IFtdIC0+IFtdXG4gIHwgKGEsIF8gYXMgcGFpcikgOjogbCAtPiBpZiBhID09IHggdGhlbiBsIGVsc2UgcGFpciA6OiByZW1vdmVfYXNzcSB4IGxcblxubGV0IHJlYyBmaW5kIHAgPSBmdW5jdGlvblxuICB8IFtdIC0+IHJhaXNlIE5vdF9mb3VuZFxuICB8IHggOjogbCAtPiBpZiBwIHggdGhlbiB4IGVsc2UgZmluZCBwIGxcblxubGV0IHJlYyBmaW5kX29wdCBwID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBOb25lXG4gIHwgeCA6OiBsIC0+IGlmIHAgeCB0aGVuIFNvbWUgeCBlbHNlIGZpbmRfb3B0IHAgbFxuXG5sZXQgZmluZF9hbGwgcCA9XG4gIGxldCByZWMgZmluZCBhY2N1ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiByZXYgYWNjdVxuICB8IHggOjogbCAtPiBpZiBwIHggdGhlbiBmaW5kICh4IDo6IGFjY3UpIGwgZWxzZSBmaW5kIGFjY3UgbCBpblxuICBmaW5kIFtdXG5cbmxldCBmaWx0ZXIgPSBmaW5kX2FsbFxuXG5sZXQgcGFydGl0aW9uIHAgbCA9XG4gIGxldCByZWMgcGFydCB5ZXMgbm8gPSBmdW5jdGlvblxuICB8IFtdIC0+IChyZXYgeWVzLCByZXYgbm8pXG4gIHwgeCA6OiBsIC0+IGlmIHAgeCB0aGVuIHBhcnQgKHggOjogeWVzKSBubyBsIGVsc2UgcGFydCB5ZXMgKHggOjogbm8pIGwgaW5cbiAgcGFydCBbXSBbXSBsXG5cbmxldCByZWMgc3BsaXQgPSBmdW5jdGlvblxuICAgIFtdIC0+IChbXSwgW10pXG4gIHwgKHgseSk6OmwgLT5cbiAgICAgIGxldCAocngsIHJ5KSA9IHNwbGl0IGwgaW4gKHg6OnJ4LCB5OjpyeSlcblxubGV0IHJlYyBjb21iaW5lIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IFtdXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiAoYTEsIGEyKSA6OiBjb21iaW5lIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5jb21iaW5lXCJcblxuKCoqIHNvcnRpbmcgKilcblxubGV0IHJlYyBtZXJnZSBjbXAgbDEgbDIgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBsMiAtPiBsMlxuICB8IGwxLCBbXSAtPiBsMVxuICB8IGgxIDo6IHQxLCBoMiA6OiB0MiAtPlxuICAgICAgaWYgY21wIGgxIGgyIDw9IDBcbiAgICAgIHRoZW4gaDEgOjogbWVyZ2UgY21wIHQxIGwyXG4gICAgICBlbHNlIGgyIDo6IG1lcmdlIGNtcCBsMSB0MlxuXG5cbmxldCByZWMgY2hvcCBrIGwgPVxuICBpZiBrID0gMCB0aGVuIGwgZWxzZSBiZWdpblxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgXzo6dCAtPiBjaG9wIChrLTEpIHRcbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gIGVuZFxuXG5cbmxldCBzdGFibGVfc29ydCBjbXAgbCA9XG4gIGxldCByZWMgcmV2X21lcmdlIGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBpZiBjbXAgaDEgaDIgPD0gMFxuICAgICAgICB0aGVuIHJldl9tZXJnZSB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlIGwxIHQyIChoMjo6YWNjdSlcbiAgaW5cbiAgbGV0IHJlYyByZXZfbWVyZ2VfcmV2IGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBpZiBjbXAgaDEgaDIgPiAwXG4gICAgICAgIHRoZW4gcmV2X21lcmdlX3JldiB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlX3JldiBsMSB0MiAoaDI6OmFjY3UpXG4gIGluXG4gIGxldCByZWMgc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogXyAtPlxuICAgICAgIGlmIGNtcCB4MSB4MiA8PSAwIHRoZW4gW3gxOyB4Ml0gZWxzZSBbeDI7IHgxXVxuICAgIHwgMywgeDEgOjogeDIgOjogeDMgOjogXyAtPlxuICAgICAgIGlmIGNtcCB4MSB4MiA8PSAwIHRoZW4gYmVnaW5cbiAgICAgICAgIGlmIGNtcCB4MiB4MyA8PSAwIHRoZW4gW3gxOyB4MjsgeDNdXG4gICAgICAgICBlbHNlIGlmIGNtcCB4MSB4MyA8PSAwIHRoZW4gW3gxOyB4MzsgeDJdXG4gICAgICAgICBlbHNlIFt4MzsgeDE7IHgyXVxuICAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICBpZiBjbXAgeDEgeDMgPD0gMCB0aGVuIFt4MjsgeDE7IHgzXVxuICAgICAgICAgZWxzZSBpZiBjbXAgeDIgeDMgPD0gMCB0aGVuIFt4MjsgeDM7IHgxXVxuICAgICAgICAgZWxzZSBbeDM7IHgyOyB4MV1cbiAgICAgICBlbmRcbiAgICB8IG4sIGwgLT5cbiAgICAgICBsZXQgbjEgPSBuIGFzciAxIGluXG4gICAgICAgbGV0IG4yID0gbiAtIG4xIGluXG4gICAgICAgbGV0IGwyID0gY2hvcCBuMSBsIGluXG4gICAgICAgbGV0IHMxID0gcmV2X3NvcnQgbjEgbCBpblxuICAgICAgIGxldCBzMiA9IHJldl9zb3J0IG4yIGwyIGluXG4gICAgICAgcmV2X21lcmdlX3JldiBzMSBzMiBbXVxuICBhbmQgcmV2X3NvcnQgbiBsID1cbiAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICB8IDIsIHgxIDo6IHgyIDo6IF8gLT5cbiAgICAgICBpZiBjbXAgeDEgeDIgPiAwIHRoZW4gW3gxOyB4Ml0gZWxzZSBbeDI7IHgxXVxuICAgIHwgMywgeDEgOjogeDIgOjogeDMgOjogXyAtPlxuICAgICAgIGlmIGNtcCB4MSB4MiA+IDAgdGhlbiBiZWdpblxuICAgICAgICAgaWYgY21wIHgyIHgzID4gMCB0aGVuIFt4MTsgeDI7IHgzXVxuICAgICAgICAgZWxzZSBpZiBjbXAgeDEgeDMgPiAwIHRoZW4gW3gxOyB4MzsgeDJdXG4gICAgICAgICBlbHNlIFt4MzsgeDE7IHgyXVxuICAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICBpZiBjbXAgeDEgeDMgPiAwIHRoZW4gW3gyOyB4MTsgeDNdXG4gICAgICAgICBlbHNlIGlmIGNtcCB4MiB4MyA+IDAgdGhlbiBbeDI7IHgzOyB4MV1cbiAgICAgICAgIGVsc2UgW3gzOyB4MjsgeDFdXG4gICAgICAgZW5kXG4gICAgfCBuLCBsIC0+XG4gICAgICAgbGV0IG4xID0gbiBhc3IgMSBpblxuICAgICAgIGxldCBuMiA9IG4gLSBuMSBpblxuICAgICAgIGxldCBsMiA9IGNob3AgbjEgbCBpblxuICAgICAgIGxldCBzMSA9IHNvcnQgbjEgbCBpblxuICAgICAgIGxldCBzMiA9IHNvcnQgbjIgbDIgaW5cbiAgICAgICByZXZfbWVyZ2UgczEgczIgW11cbiAgaW5cbiAgbGV0IGxlbiA9IGxlbmd0aCBsIGluXG4gIGlmIGxlbiA8IDIgdGhlbiBsIGVsc2Ugc29ydCBsZW4gbFxuXG5cbmxldCBzb3J0ID0gc3RhYmxlX3NvcnRcbmxldCBmYXN0X3NvcnQgPSBzdGFibGVfc29ydFxuXG4oKiBOb3RlOiBvbiBhIGxpc3Qgb2YgbGVuZ3RoIGJldHdlZW4gYWJvdXQgMTAwMDAwIChkZXBlbmRpbmcgb24gdGhlIG1pbm9yXG4gICBoZWFwIHNpemUgYW5kIHRoZSB0eXBlIG9mIHRoZSBsaXN0KSBhbmQgU3lzLm1heF9hcnJheV9zaXplLCBpdCBpc1xuICAgYWN0dWFsbHkgZmFzdGVyIHRvIHVzZSB0aGUgZm9sbG93aW5nLCBidXQgaXQgbWlnaHQgYWxzbyB1c2UgbW9yZSBtZW1vcnlcbiAgIGJlY2F1c2UgdGhlIGFyZ3VtZW50IGxpc3QgY2Fubm90IGJlIGRlYWxsb2NhdGVkIGluY3JlbWVudGFsbHkuXG5cbiAgIEFsc28sIHRoZXJlIHNlZW1zIHRvIGJlIGEgYnVnIGluIHRoaXMgY29kZSBvciBpbiB0aGVcbiAgIGltcGxlbWVudGF0aW9uIG9mIG9ial90cnVuY2F0ZS5cblxuZXh0ZXJuYWwgb2JqX3RydW5jYXRlIDogJ2EgYXJyYXkgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfb2JqX3RydW5jYXRlXCJcblxubGV0IGFycmF5X3RvX2xpc3RfaW5fcGxhY2UgYSA9XG4gIGxldCBsID0gQXJyYXkubGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGFjY3UgbiBwID1cbiAgICBpZiBwIDw9IDAgdGhlbiBhY2N1IGVsc2UgYmVnaW5cbiAgICAgIGlmIHAgPSBuIHRoZW4gYmVnaW5cbiAgICAgICAgb2JqX3RydW5jYXRlIGEgcDtcbiAgICAgICAgbG9vcCAoYS4ocC0xKSA6OiBhY2N1KSAobi0xMDAwKSAocC0xKVxuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgbG9vcCAoYS4ocC0xKSA6OiBhY2N1KSBuIChwLTEpXG4gICAgICBlbmRcbiAgICBlbmRcbiAgaW5cbiAgbG9vcCBbXSAobC0xMDAwKSBsXG5cblxubGV0IHN0YWJsZV9zb3J0IGNtcCBsID1cbiAgbGV0IGEgPSBBcnJheS5vZl9saXN0IGwgaW5cbiAgQXJyYXkuc3RhYmxlX3NvcnQgY21wIGE7XG4gIGFycmF5X3RvX2xpc3RfaW5fcGxhY2UgYVxuXG4qKVxuXG5cbigqKiBzb3J0aW5nICsgcmVtb3ZpbmcgZHVwbGljYXRlcyAqKVxuXG5sZXQgc29ydF91bmlxIGNtcCBsID1cbiAgbGV0IHJlYyByZXZfbWVyZ2UgbDEgbDIgYWNjdSA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtdLCBsMiAtPiByZXZfYXBwZW5kIGwyIGFjY3VcbiAgICB8IGwxLCBbXSAtPiByZXZfYXBwZW5kIGwxIGFjY3VcbiAgICB8IGgxOjp0MSwgaDI6OnQyIC0+XG4gICAgICAgIGxldCBjID0gY21wIGgxIGgyIGluXG4gICAgICAgIGlmIGMgPSAwIHRoZW4gcmV2X21lcmdlIHQxIHQyIChoMTo6YWNjdSlcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIHJldl9tZXJnZSB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlIGwxIHQyIChoMjo6YWNjdSlcbiAgaW5cbiAgbGV0IHJlYyByZXZfbWVyZ2VfcmV2IGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBsZXQgYyA9IGNtcCBoMSBoMiBpblxuICAgICAgICBpZiBjID0gMCB0aGVuIHJldl9tZXJnZV9yZXYgdDEgdDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIGlmIGMgPiAwXG4gICAgICAgIHRoZW4gcmV2X21lcmdlX3JldiB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlX3JldiBsMSB0MiAoaDI6OmFjY3UpXG4gIGluXG4gIGxldCByZWMgc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogXyAtPlxuICAgICAgIGxldCBjID0gY21wIHgxIHgyIGluXG4gICAgICAgaWYgYyA9IDAgdGhlbiBbeDFdXG4gICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuIFt4MTsgeDJdIGVsc2UgW3gyOyB4MV1cbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IF8gLT5cbiAgICAgICBsZXQgYyA9IGNtcCB4MSB4MiBpblxuICAgICAgIGlmIGMgPSAwIHRoZW4gYmVnaW5cbiAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICBpZiBjID0gMCB0aGVuIFt4Ml1cbiAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDI7IHgzXSBlbHNlIFt4MzsgeDJdXG4gICAgICAgZW5kIGVsc2UgaWYgYyA8IDAgdGhlbiBiZWdpblxuICAgICAgICAgbGV0IGMgPSBjbXAgeDIgeDMgaW5cbiAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxOyB4Ml1cbiAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDE7IHgyOyB4M11cbiAgICAgICAgIGVsc2UgbGV0IGMgPSBjbXAgeDEgeDMgaW5cbiAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxOyB4Ml1cbiAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDE7IHgzOyB4Ml1cbiAgICAgICAgIGVsc2UgW3gzOyB4MTsgeDJdXG4gICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgIGxldCBjID0gY21wIHgxIHgzIGluXG4gICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW4gW3gyOyB4MTsgeDNdXG4gICAgICAgICBlbHNlIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW4gW3gyOyB4MzsgeDFdXG4gICAgICAgICBlbHNlIFt4MzsgeDI7IHgxXVxuICAgICAgIGVuZFxuICAgIHwgbiwgbCAtPlxuICAgICAgIGxldCBuMSA9IG4gYXNyIDEgaW5cbiAgICAgICBsZXQgbjIgPSBuIC0gbjEgaW5cbiAgICAgICBsZXQgbDIgPSBjaG9wIG4xIGwgaW5cbiAgICAgICBsZXQgczEgPSByZXZfc29ydCBuMSBsIGluXG4gICAgICAgbGV0IHMyID0gcmV2X3NvcnQgbjIgbDIgaW5cbiAgICAgICByZXZfbWVyZ2VfcmV2IHMxIHMyIFtdXG4gIGFuZCByZXZfc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogXyAtPlxuICAgICAgIGxldCBjID0gY21wIHgxIHgyIGluXG4gICAgICAgaWYgYyA9IDAgdGhlbiBbeDFdXG4gICAgICAgZWxzZSBpZiBjID4gMCB0aGVuIFt4MTsgeDJdIGVsc2UgW3gyOyB4MV1cbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IF8gLT5cbiAgICAgICBsZXQgYyA9IGNtcCB4MSB4MiBpblxuICAgICAgIGlmIGMgPSAwIHRoZW4gYmVnaW5cbiAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICBpZiBjID0gMCB0aGVuIFt4Ml1cbiAgICAgICAgIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDI7IHgzXSBlbHNlIFt4MzsgeDJdXG4gICAgICAgZW5kIGVsc2UgaWYgYyA+IDAgdGhlbiBiZWdpblxuICAgICAgICAgbGV0IGMgPSBjbXAgeDIgeDMgaW5cbiAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxOyB4Ml1cbiAgICAgICAgIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDE7IHgyOyB4M11cbiAgICAgICAgIGVsc2UgbGV0IGMgPSBjbXAgeDEgeDMgaW5cbiAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxOyB4Ml1cbiAgICAgICAgIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDE7IHgzOyB4Ml1cbiAgICAgICAgIGVsc2UgW3gzOyB4MTsgeDJdXG4gICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgIGxldCBjID0gY21wIHgxIHgzIGluXG4gICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW4gW3gyOyB4MTsgeDNdXG4gICAgICAgICBlbHNlIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW4gW3gyOyB4MzsgeDFdXG4gICAgICAgICBlbHNlIFt4MzsgeDI7IHgxXVxuICAgICAgIGVuZFxuICAgIHwgbiwgbCAtPlxuICAgICAgIGxldCBuMSA9IG4gYXNyIDEgaW5cbiAgICAgICBsZXQgbjIgPSBuIC0gbjEgaW5cbiAgICAgICBsZXQgbDIgPSBjaG9wIG4xIGwgaW5cbiAgICAgICBsZXQgczEgPSBzb3J0IG4xIGwgaW5cbiAgICAgICBsZXQgczIgPSBzb3J0IG4yIGwyIGluXG4gICAgICAgcmV2X21lcmdlIHMxIHMyIFtdXG4gIGluXG4gIGxldCBsZW4gPSBsZW5ndGggbCBpblxuICBpZiBsZW4gPCAyIHRoZW4gbCBlbHNlIHNvcnQgbGVuIGxcblxubGV0IHJlYyBjb21wYXJlX2xlbmd0aHMgbDEgbDIgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBbXSAtPiAwXG4gIHwgW10sIF8gLT4gLTFcbiAgfCBfLCBbXSAtPiAxXG4gIHwgXyA6OiBsMSwgXyA6OiBsMiAtPiBjb21wYXJlX2xlbmd0aHMgbDEgbDJcbjs7XG5cbmxldCByZWMgY29tcGFyZV9sZW5ndGhfd2l0aCBsIG4gPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPlxuICAgIGlmIG4gPSAwIHRoZW4gMCBlbHNlXG4gICAgICBpZiBuID4gMCB0aGVuIC0xIGVsc2UgMVxuICB8IF8gOjogbCAtPlxuICAgIGlmIG4gPD0gMCB0aGVuIDEgZWxzZVxuICAgICAgY29tcGFyZV9sZW5ndGhfd2l0aCBsIChuLTEpXG47O1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBDaGFyYWN0ZXIgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBjb2RlOiBjaGFyIC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHVuc2FmZV9jaHI6IGludCAtPiBjaGFyID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgY2hyIG4gPVxuICBpZiBuIDwgMCB8fCBuID4gMjU1IHRoZW4gaW52YWxpZF9hcmcgXCJDaGFyLmNoclwiIGVsc2UgdW5zYWZlX2NociBuXG5cbmV4dGVybmFsIGJ5dGVzX2NyZWF0ZTogaW50IC0+IGJ5dGVzID0gXCJjYW1sX2NyZWF0ZV9ieXRlc1wiXG5leHRlcm5hbCBieXRlc191bnNhZmVfc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcIiVieXRlc191bnNhZmVfc2V0XCJcbmV4dGVybmFsIHVuc2FmZV90b19zdHJpbmcgOiBieXRlcyAtPiBzdHJpbmcgPSBcIiVieXRlc190b19zdHJpbmdcIlxuXG5sZXQgZXNjYXBlZCA9IGZ1bmN0aW9uXG4gIHwgJ1xcJycgLT4gXCJcXFxcJ1wiXG4gIHwgJ1xcXFwnIC0+IFwiXFxcXFxcXFxcIlxuICB8ICdcXG4nIC0+IFwiXFxcXG5cIlxuICB8ICdcXHQnIC0+IFwiXFxcXHRcIlxuICB8ICdcXHInIC0+IFwiXFxcXHJcIlxuICB8ICdcXGInIC0+IFwiXFxcXGJcIlxuICB8ICcgJyAuLiAnficgYXMgYyAtPlxuICAgICAgbGV0IHMgPSBieXRlc19jcmVhdGUgMSBpblxuICAgICAgYnl0ZXNfdW5zYWZlX3NldCBzIDAgYztcbiAgICAgIHVuc2FmZV90b19zdHJpbmcgc1xuICB8IGMgLT5cbiAgICAgIGxldCBuID0gY29kZSBjIGluXG4gICAgICBsZXQgcyA9IGJ5dGVzX2NyZWF0ZSA0IGluXG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMCAnXFxcXCc7XG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMSAodW5zYWZlX2NociAoNDggKyBuIC8gMTAwKSk7XG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMiAodW5zYWZlX2NociAoNDggKyAobiAvIDEwKSBtb2QgMTApKTtcbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAzICh1bnNhZmVfY2hyICg0OCArIG4gbW9kIDEwKSk7XG4gICAgICB1bnNhZmVfdG9fc3RyaW5nIHNcblxubGV0IGxvd2VyY2FzZSBjID1cbiAgaWYgKGMgPj0gJ0EnICYmIGMgPD0gJ1onKVxuICB8fCAoYyA+PSAnXFwxOTInICYmIGMgPD0gJ1xcMjE0JylcbiAgfHwgKGMgPj0gJ1xcMjE2JyAmJiBjIDw9ICdcXDIyMicpXG4gIHRoZW4gdW5zYWZlX2Nocihjb2RlIGMgKyAzMilcbiAgZWxzZSBjXG5cbmxldCB1cHBlcmNhc2UgYyA9XG4gIGlmIChjID49ICdhJyAmJiBjIDw9ICd6JylcbiAgfHwgKGMgPj0gJ1xcMjI0JyAmJiBjIDw9ICdcXDI0NicpXG4gIHx8IChjID49ICdcXDI0OCcgJiYgYyA8PSAnXFwyNTQnKVxuICB0aGVuIHVuc2FmZV9jaHIoY29kZSBjIC0gMzIpXG4gIGVsc2UgY1xuXG5sZXQgbG93ZXJjYXNlX2FzY2lpIGMgPVxuICBpZiAoYyA+PSAnQScgJiYgYyA8PSAnWicpXG4gIHRoZW4gdW5zYWZlX2Nocihjb2RlIGMgKyAzMilcbiAgZWxzZSBjXG5cbmxldCB1cHBlcmNhc2VfYXNjaWkgYyA9XG4gIGlmIChjID49ICdhJyAmJiBjIDw9ICd6JylcbiAgdGhlbiB1bnNhZmVfY2hyKGNvZGUgYyAtIDMyKVxuICBlbHNlIGNcblxudHlwZSB0ID0gY2hhclxuXG5sZXQgY29tcGFyZSBjMSBjMiA9IGNvZGUgYzEgLSBjb2RlIGMyXG5sZXQgZXF1YWwgKGMxOiB0KSAoYzI6IHQpID0gY29tcGFyZSBjMSBjMiA9IDBcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQnl0ZSBzZXF1ZW5jZSBvcGVyYXRpb25zICopXG5cbigqIFdBUk5JTkc6IFNvbWUgZnVuY3Rpb25zIGluIHRoaXMgZmlsZSBhcmUgZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgZm9yXG4gICBlZmZpY2llbmN5IHJlYXNvbnMuIFdoZW4geW91IG1vZGlmeSB0aGUgb25lIGluIHRoaXMgZmlsZSB5b3UgbmVlZCB0b1xuICAgbW9kaWZ5IGl0cyBkdXBsaWNhdGUgaW4gc3RyaW5nLm1sLlxuICAgVGhlc2UgZnVuY3Rpb25zIGhhdmUgYSBcImR1cGxpY2F0ZWRcIiBjb21tZW50IGFib3ZlIHRoZWlyIGRlZmluaXRpb24uXG4qKVxuXG5leHRlcm5hbCBsZW5ndGggOiBieXRlcyAtPiBpbnQgPSBcIiVieXRlc19sZW5ndGhcIlxuZXh0ZXJuYWwgc3RyaW5nX2xlbmd0aCA6IHN0cmluZyAtPiBpbnQgPSBcIiVzdHJpbmdfbGVuZ3RoXCJcbmV4dGVybmFsIGdldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyID0gXCIlYnl0ZXNfc2FmZV9nZXRcIlxuZXh0ZXJuYWwgc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJWJ5dGVzX3NhZmVfc2V0XCJcbmV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiBieXRlcyA9IFwiY2FtbF9jcmVhdGVfYnl0ZXNcIlxuZXh0ZXJuYWwgdW5zYWZlX2dldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyID0gXCIlYnl0ZXNfdW5zYWZlX2dldFwiXG5leHRlcm5hbCB1bnNhZmVfc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJWJ5dGVzX3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2ZpbGwgOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IGNoYXIgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfZmlsbF9ieXRlc1wiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB1bnNhZmVfdG9fc3RyaW5nIDogYnl0ZXMgLT4gc3RyaW5nID0gXCIlYnl0ZXNfdG9fc3RyaW5nXCJcbmV4dGVybmFsIHVuc2FmZV9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gYnl0ZXMgPSBcIiVieXRlc19vZl9zdHJpbmdcIlxuXG5leHRlcm5hbCB1bnNhZmVfYmxpdCA6IGJ5dGVzIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfYnl0ZXNcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdW5zYWZlX2JsaXRfc3RyaW5nIDogc3RyaW5nIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfc3RyaW5nXCIgW0BAbm9hbGxvY11cblxubGV0IG1ha2UgbiBjID1cbiAgbGV0IHMgPSBjcmVhdGUgbiBpblxuICB1bnNhZmVfZmlsbCBzIDAgbiBjO1xuICBzXG5cbmxldCBpbml0IG4gZiA9XG4gIGxldCBzID0gY3JlYXRlIG4gaW5cbiAgZm9yIGkgPSAwIHRvIG4gLSAxIGRvXG4gICAgdW5zYWZlX3NldCBzIGkgKGYgaSlcbiAgZG9uZTtcbiAgc1xuXG5sZXQgZW1wdHkgPSBjcmVhdGUgMFxuXG5sZXQgY29weSBzID1cbiAgbGV0IGxlbiA9IGxlbmd0aCBzIGluXG4gIGxldCByID0gY3JlYXRlIGxlbiBpblxuICB1bnNhZmVfYmxpdCBzIDAgciAwIGxlbjtcbiAgclxuXG5sZXQgdG9fc3RyaW5nIGIgPSB1bnNhZmVfdG9fc3RyaW5nIChjb3B5IGIpXG5sZXQgb2Zfc3RyaW5nIHMgPSBjb3B5ICh1bnNhZmVfb2Zfc3RyaW5nIHMpXG5cbmxldCBzdWIgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGxlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuc3ViIC8gQnl0ZXMuc3ViXCJcbiAgZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGxlbiBpblxuICAgIHVuc2FmZV9ibGl0IHMgb2ZzIHIgMCBsZW47XG4gICAgclxuICBlbmRcblxubGV0IHN1Yl9zdHJpbmcgYiBvZnMgbGVuID0gdW5zYWZlX3RvX3N0cmluZyAoc3ViIGIgb2ZzIGxlbilcblxuKCogYWRkaXRpb24gd2l0aCBhbiBvdmVyZmxvdyBjaGVjayAqKVxubGV0ICgrKykgYSBiID1cbiAgbGV0IGMgPSBhICsgYiBpblxuICBtYXRjaCBhIDwgMCwgYiA8IDAsIGMgPCAwIHdpdGhcbiAgfCB0cnVlICwgdHJ1ZSAsIGZhbHNlXG4gIHwgZmFsc2UsIGZhbHNlLCB0cnVlICAtPiBpbnZhbGlkX2FyZyBcIkJ5dGVzLmV4dGVuZFwiICgqIG92ZXJmbG93ICopXG4gIHwgXyAtPiBjXG5cbmxldCBleHRlbmQgcyBsZWZ0IHJpZ2h0ID1cbiAgbGV0IGxlbiA9IGxlbmd0aCBzICsrIGxlZnQgKysgcmlnaHQgaW5cbiAgbGV0IHIgPSBjcmVhdGUgbGVuIGluXG4gIGxldCAoc3Jjb2ZmLCBkc3RvZmYpID0gaWYgbGVmdCA8IDAgdGhlbiAtbGVmdCwgMCBlbHNlIDAsIGxlZnQgaW5cbiAgbGV0IGNweWxlbiA9IG1pbiAobGVuZ3RoIHMgLSBzcmNvZmYpIChsZW4gLSBkc3RvZmYpIGluXG4gIGlmIGNweWxlbiA+IDAgdGhlbiB1bnNhZmVfYmxpdCBzIHNyY29mZiByIGRzdG9mZiBjcHlsZW47XG4gIHJcblxubGV0IGZpbGwgcyBvZnMgbGVuIGMgPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5maWxsIC8gQnl0ZXMuZmlsbFwiXG4gIGVsc2UgdW5zYWZlX2ZpbGwgcyBvZnMgbGVuIGNcblxubGV0IGJsaXQgczEgb2ZzMSBzMiBvZnMyIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgb2ZzMSA8IDAgfHwgb2ZzMSA+IGxlbmd0aCBzMSAtIGxlblxuICAgICAgICAgICAgIHx8IG9mczIgPCAwIHx8IG9mczIgPiBsZW5ndGggczIgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkJ5dGVzLmJsaXRcIlxuICBlbHNlIHVuc2FmZV9ibGl0IHMxIG9mczEgczIgb2ZzMiBsZW5cblxubGV0IGJsaXRfc3RyaW5nIHMxIG9mczEgczIgb2ZzMiBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IG9mczEgPCAwIHx8IG9mczEgPiBzdHJpbmdfbGVuZ3RoIHMxIC0gbGVuXG4gICAgICAgICAgICAgfHwgb2ZzMiA8IDAgfHwgb2ZzMiA+IGxlbmd0aCBzMiAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLmJsaXQgLyBCeXRlcy5ibGl0X3N0cmluZ1wiXG4gIGVsc2UgdW5zYWZlX2JsaXRfc3RyaW5nIHMxIG9mczEgczIgb2ZzMiBsZW5cblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpdGVyIGYgYSA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZih1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGl0ZXJpIGYgYSA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiBpICh1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG5sZXQgZW5zdXJlX2dlICh4OmludCkgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSBpbnZhbGlkX2FyZyBcIkJ5dGVzLmNvbmNhdFwiXG5cbmxldCByZWMgc3VtX2xlbmd0aHMgYWNjIHNlcGxlbiA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gYWNjXG4gIHwgaGQgOjogW10gLT4gbGVuZ3RoIGhkICsgYWNjXG4gIHwgaGQgOjogdGwgLT4gc3VtX2xlbmd0aHMgKGVuc3VyZV9nZSAobGVuZ3RoIGhkICsgc2VwbGVuICsgYWNjKSBhY2MpIHNlcGxlbiB0bFxuXG5sZXQgcmVjIHVuc2FmZV9ibGl0cyBkc3QgcG9zIHNlcCBzZXBsZW4gPSBmdW5jdGlvblxuICAgIFtdIC0+IGRzdFxuICB8IGhkIDo6IFtdIC0+XG4gICAgdW5zYWZlX2JsaXQgaGQgMCBkc3QgcG9zIChsZW5ndGggaGQpOyBkc3RcbiAgfCBoZCA6OiB0bCAtPlxuICAgIHVuc2FmZV9ibGl0IGhkIDAgZHN0IHBvcyAobGVuZ3RoIGhkKTtcbiAgICB1bnNhZmVfYmxpdCBzZXAgMCBkc3QgKHBvcyArIGxlbmd0aCBoZCkgc2VwbGVuO1xuICAgIHVuc2FmZV9ibGl0cyBkc3QgKHBvcyArIGxlbmd0aCBoZCArIHNlcGxlbikgc2VwIHNlcGxlbiB0bFxuXG5sZXQgY29uY2F0IHNlcCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZW1wdHlcbiAgfCBsIC0+IGxldCBzZXBsZW4gPSBsZW5ndGggc2VwIGluXG4gICAgICAgICAgdW5zYWZlX2JsaXRzXG4gICAgICAgICAgICAoY3JlYXRlIChzdW1fbGVuZ3RocyAwIHNlcGxlbiBsKSlcbiAgICAgICAgICAgIDAgc2VwIHNlcGxlbiBsXG5cbmxldCBjYXQgczEgczIgPVxuICBsZXQgbDEgPSBsZW5ndGggczEgaW5cbiAgbGV0IGwyID0gbGVuZ3RoIHMyIGluXG4gIGxldCByID0gY3JlYXRlIChsMSArIGwyKSBpblxuICB1bnNhZmVfYmxpdCBzMSAwIHIgMCBsMTtcbiAgdW5zYWZlX2JsaXQgczIgMCByIGwxIGwyO1xuICByXG5cblxuZXh0ZXJuYWwgY2hhcl9jb2RlOiBjaGFyIC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIGNoYXJfY2hyOiBpbnQgLT4gY2hhciA9IFwiJWlkZW50aXR5XCJcblxubGV0IGlzX3NwYWNlID0gZnVuY3Rpb25cbiAgfCAnICcgfCAnXFwwMTInIHwgJ1xcbicgfCAnXFxyJyB8ICdcXHQnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cbmxldCB0cmltIHMgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHMgaW5cbiAgbGV0IGkgPSByZWYgMCBpblxuICB3aGlsZSAhaSA8IGxlbiAmJiBpc19zcGFjZSAodW5zYWZlX2dldCBzICFpKSBkb1xuICAgIGluY3IgaVxuICBkb25lO1xuICBsZXQgaiA9IHJlZiAobGVuIC0gMSkgaW5cbiAgd2hpbGUgIWogPj0gIWkgJiYgaXNfc3BhY2UgKHVuc2FmZV9nZXQgcyAhaikgZG9cbiAgICBkZWNyIGpcbiAgZG9uZTtcbiAgaWYgIWogPj0gIWkgdGhlblxuICAgIHN1YiBzICFpICghaiAtICFpICsgMSlcbiAgZWxzZVxuICAgIGVtcHR5XG5cbmxldCBlc2NhcGVkIHMgPVxuICBsZXQgbiA9IHJlZiAwIGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggcyAtIDEgZG9cbiAgICBuIDo9ICFuICtcbiAgICAgIChtYXRjaCB1bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICAgfCAnXFxcIicgfCAnXFxcXCcgfCAnXFxuJyB8ICdcXHQnIHwgJ1xccicgfCAnXFxiJyAtPiAyXG4gICAgICAgfCAnICcgLi4gJ34nIC0+IDFcbiAgICAgICB8IF8gLT4gNClcbiAgZG9uZTtcbiAgaWYgIW4gPSBsZW5ndGggcyB0aGVuIGNvcHkgcyBlbHNlIGJlZ2luXG4gICAgbGV0IHMnID0gY3JlYXRlICFuIGluXG4gICAgbiA6PSAwO1xuICAgIGZvciBpID0gMCB0byBsZW5ndGggcyAtIDEgZG9cbiAgICAgIGJlZ2luIG1hdGNoIHVuc2FmZV9nZXQgcyBpIHdpdGhcbiAgICAgIHwgKCdcXFwiJyB8ICdcXFxcJykgYXMgYyAtPlxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnOyBpbmNyIG47IHVuc2FmZV9zZXQgcycgIW4gY1xuICAgICAgfCAnXFxuJyAtPlxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnOyBpbmNyIG47IHVuc2FmZV9zZXQgcycgIW4gJ24nXG4gICAgICB8ICdcXHQnIC0+XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7IGluY3IgbjsgdW5zYWZlX3NldCBzJyAhbiAndCdcbiAgICAgIHwgJ1xccicgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuICdyJ1xuICAgICAgfCAnXFxiJyAtPlxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnOyBpbmNyIG47IHVuc2FmZV9zZXQgcycgIW4gJ2InXG4gICAgICB8ICgnICcgLi4gJ34nKSBhcyBjIC0+IHVuc2FmZV9zZXQgcycgIW4gY1xuICAgICAgfCBjIC0+XG4gICAgICAgICAgbGV0IGEgPSBjaGFyX2NvZGUgYyBpblxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnO1xuICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuIChjaGFyX2NociAoNDggKyBhIC8gMTAwKSk7XG4gICAgICAgICAgaW5jciBuO1xuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gKGNoYXJfY2hyICg0OCArIChhIC8gMTApIG1vZCAxMCkpO1xuICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuIChjaGFyX2NociAoNDggKyBhIG1vZCAxMCkpO1xuICAgICAgZW5kO1xuICAgICAgaW5jciBuXG4gICAgZG9uZTtcbiAgICBzJ1xuICBlbmRcblxubGV0IG1hcCBmIHMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGwgPSAwIHRoZW4gcyBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbCBpblxuICAgIGZvciBpID0gMCB0byBsIC0gMSBkbyB1bnNhZmVfc2V0IHIgaSAoZiAodW5zYWZlX2dldCBzIGkpKSBkb25lO1xuICAgIHJcbiAgZW5kXG5cbmxldCBtYXBpIGYgcyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgbCA9IDAgdGhlbiBzIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsIGluXG4gICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvIHVuc2FmZV9zZXQgciBpIChmIGkgKHVuc2FmZV9nZXQgcyBpKSkgZG9uZTtcbiAgICByXG4gIGVuZFxuXG5sZXQgdXBwZXJjYXNlX2FzY2lpIHMgPSBtYXAgQ2hhci51cHBlcmNhc2VfYXNjaWkgc1xubGV0IGxvd2VyY2FzZV9hc2NpaSBzID0gbWFwIENoYXIubG93ZXJjYXNlX2FzY2lpIHNcblxubGV0IGFwcGx5MSBmIHMgPVxuICBpZiBsZW5ndGggcyA9IDAgdGhlbiBzIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNvcHkgcyBpblxuICAgIHVuc2FmZV9zZXQgciAwIChmKHVuc2FmZV9nZXQgcyAwKSk7XG4gICAgclxuICBlbmRcblxubGV0IGNhcGl0YWxpemVfYXNjaWkgcyA9IGFwcGx5MSBDaGFyLnVwcGVyY2FzZV9hc2NpaSBzXG5sZXQgdW5jYXBpdGFsaXplX2FzY2lpIHMgPSBhcHBseTEgQ2hhci5sb3dlcmNhc2VfYXNjaWkgc1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJlYyBpbmRleF9yZWMgcyBsaW0gaSBjID1cbiAgaWYgaSA+PSBsaW0gdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBpIGVsc2UgaW5kZXhfcmVjIHMgbGltIChpICsgMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGluZGV4IHMgYyA9IGluZGV4X3JlYyBzIChsZW5ndGggcykgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmVjIGluZGV4X3JlY19vcHQgcyBsaW0gaSBjID1cbiAgaWYgaSA+PSBsaW0gdGhlbiBOb25lIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gU29tZSBpIGVsc2UgaW5kZXhfcmVjX29wdCBzIGxpbSAoaSArIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpbmRleF9vcHQgcyBjID0gaW5kZXhfcmVjX29wdCBzIChsZW5ndGggcykgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaW5kZXhfZnJvbSBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5pbmRleF9mcm9tIC8gQnl0ZXMuaW5kZXhfZnJvbVwiIGVsc2VcbiAgaW5kZXhfcmVjIHMgbCBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpbmRleF9mcm9tX29wdCBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5pbmRleF9mcm9tX29wdCAvIEJ5dGVzLmluZGV4X2Zyb21fb3B0XCIgZWxzZVxuICBpbmRleF9yZWNfb3B0IHMgbCBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByZWMgcmluZGV4X3JlYyBzIGkgYyA9XG4gIGlmIGkgPCAwIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gaSBlbHNlIHJpbmRleF9yZWMgcyAoaSAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByaW5kZXggcyBjID0gcmluZGV4X3JlYyBzIChsZW5ndGggcyAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByaW5kZXhfZnJvbSBzIGkgYyA9XG4gIGlmIGkgPCAtMSB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yaW5kZXhfZnJvbSAvIEJ5dGVzLnJpbmRleF9mcm9tXCJcbiAgZWxzZVxuICAgIHJpbmRleF9yZWMgcyBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByZWMgcmluZGV4X3JlY19vcHQgcyBpIGMgPVxuICBpZiBpIDwgMCB0aGVuIE5vbmUgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBTb21lIGkgZWxzZSByaW5kZXhfcmVjX29wdCBzIChpIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJpbmRleF9vcHQgcyBjID0gcmluZGV4X3JlY19vcHQgcyAobGVuZ3RoIHMgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmluZGV4X2Zyb21fb3B0IHMgaSBjID1cbiAgaWYgaSA8IC0xIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJpbmRleF9mcm9tX29wdCAvIEJ5dGVzLnJpbmRleF9mcm9tX29wdFwiXG4gIGVsc2VcbiAgICByaW5kZXhfcmVjX29wdCBzIGkgY1xuXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgY29udGFpbnNfZnJvbSBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLmNvbnRhaW5zX2Zyb20gLyBCeXRlcy5jb250YWluc19mcm9tXCJcbiAgZWxzZVxuICAgIHRyeSBpZ25vcmUgKGluZGV4X3JlYyBzIGwgaSBjKTsgdHJ1ZSB3aXRoIE5vdF9mb3VuZCAtPiBmYWxzZVxuXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgY29udGFpbnMgcyBjID0gY29udGFpbnNfZnJvbSBzIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJjb250YWluc19mcm9tIHMgaSBjID1cbiAgaWYgaSA8IDAgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmNvbnRhaW5zX2Zyb20gLyBCeXRlcy5yY29udGFpbnNfZnJvbVwiXG4gIGVsc2VcbiAgICB0cnkgaWdub3JlIChyaW5kZXhfcmVjIHMgaSBjKTsgdHJ1ZSB3aXRoIE5vdF9mb3VuZCAtPiBmYWxzZVxuXG5cbnR5cGUgdCA9IGJ5dGVzXG5cbmxldCBjb21wYXJlICh4OiB0KSAoeTogdCkgPSBQZXJ2YXNpdmVzLmNvbXBhcmUgeCB5XG5leHRlcm5hbCBlcXVhbCA6IHQgLT4gdCAtPiBib29sID0gXCJjYW1sX2J5dGVzX2VxdWFsXCJcblxuKCogRGVwcmVjYXRlZCBmdW5jdGlvbnMgaW1wbGVtZW50ZWQgdmlhIG90aGVyIGRlcHJlY2F0ZWQgZnVuY3Rpb25zICopXG5bQEBAb2NhbWwud2FybmluZyBcIi0zXCJdXG5sZXQgdXBwZXJjYXNlIHMgPSBtYXAgQ2hhci51cHBlcmNhc2Ugc1xubGV0IGxvd2VyY2FzZSBzID0gbWFwIENoYXIubG93ZXJjYXNlIHNcblxubGV0IGNhcGl0YWxpemUgcyA9IGFwcGx5MSBDaGFyLnVwcGVyY2FzZSBzXG5sZXQgdW5jYXBpdGFsaXplIHMgPSBhcHBseTEgQ2hhci5sb3dlcmNhc2Ugc1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgR2FsbGl1bSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBTdHJpbmcgb3BlcmF0aW9ucywgYmFzZWQgb24gYnl0ZSBzZXF1ZW5jZSBvcGVyYXRpb25zICopXG5cbigqIFdBUk5JTkc6IFNvbWUgZnVuY3Rpb25zIGluIHRoaXMgZmlsZSBhcmUgZHVwbGljYXRlZCBpbiBieXRlcy5tbCBmb3JcbiAgIGVmZmljaWVuY3kgcmVhc29ucy4gV2hlbiB5b3UgbW9kaWZ5IHRoZSBvbmUgaW4gdGhpcyBmaWxlIHlvdSBuZWVkIHRvXG4gICBtb2RpZnkgaXRzIGR1cGxpY2F0ZSBpbiBieXRlcy5tbC5cbiAgIFRoZXNlIGZ1bmN0aW9ucyBoYXZlIGEgXCJkdXBsaWNhdGVkXCIgY29tbWVudCBhYm92ZSB0aGVpciBkZWZpbml0aW9uLlxuKilcblxuZXh0ZXJuYWwgbGVuZ3RoIDogc3RyaW5nIC0+IGludCA9IFwiJXN0cmluZ19sZW5ndGhcIlxuZXh0ZXJuYWwgZ2V0IDogc3RyaW5nIC0+IGludCAtPiBjaGFyID0gXCIlc3RyaW5nX3NhZmVfZ2V0XCJcbmV4dGVybmFsIHNldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyIC0+IHVuaXQgPSBcIiVzdHJpbmdfc2FmZV9zZXRcIlxuZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+IGJ5dGVzID0gXCJjYW1sX2NyZWF0ZV9zdHJpbmdcIlxuZXh0ZXJuYWwgdW5zYWZlX2dldCA6IHN0cmluZyAtPiBpbnQgLT4gY2hhciA9IFwiJXN0cmluZ191bnNhZmVfZ2V0XCJcbmV4dGVybmFsIHVuc2FmZV9zZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlc3RyaW5nX3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2JsaXQgOiBzdHJpbmcgLT4gaW50IC0+ICBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfc3RyaW5nXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIHVuc2FmZV9maWxsIDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiBjaGFyIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2ZpbGxfc3RyaW5nXCIgW0BAbm9hbGxvY11cblxubW9kdWxlIEIgPSBCeXRlc1xuXG5sZXQgYnRzID0gQi51bnNhZmVfdG9fc3RyaW5nXG5sZXQgYm9zID0gQi51bnNhZmVfb2Zfc3RyaW5nXG5cbmxldCBtYWtlIG4gYyA9XG4gIEIubWFrZSBuIGMgfD4gYnRzXG5sZXQgaW5pdCBuIGYgPVxuICBCLmluaXQgbiBmIHw+IGJ0c1xubGV0IGNvcHkgcyA9XG4gIEIuY29weSAoYm9zIHMpIHw+IGJ0c1xubGV0IHN1YiBzIG9mcyBsZW4gPVxuICBCLnN1YiAoYm9zIHMpIG9mcyBsZW4gfD4gYnRzXG5sZXQgZmlsbCA9XG4gIEIuZmlsbFxubGV0IGJsaXQgPVxuICBCLmJsaXRfc3RyaW5nXG5cbmxldCBlbnN1cmVfZ2UgKHg6aW50KSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIGludmFsaWRfYXJnIFwiU3RyaW5nLmNvbmNhdFwiXG5cbmxldCByZWMgc3VtX2xlbmd0aHMgYWNjIHNlcGxlbiA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gYWNjXG4gIHwgaGQgOjogW10gLT4gbGVuZ3RoIGhkICsgYWNjXG4gIHwgaGQgOjogdGwgLT4gc3VtX2xlbmd0aHMgKGVuc3VyZV9nZSAobGVuZ3RoIGhkICsgc2VwbGVuICsgYWNjKSBhY2MpIHNlcGxlbiB0bFxuXG5sZXQgcmVjIHVuc2FmZV9ibGl0cyBkc3QgcG9zIHNlcCBzZXBsZW4gPSBmdW5jdGlvblxuICAgIFtdIC0+IGRzdFxuICB8IGhkIDo6IFtdIC0+XG4gICAgdW5zYWZlX2JsaXQgaGQgMCBkc3QgcG9zIChsZW5ndGggaGQpOyBkc3RcbiAgfCBoZCA6OiB0bCAtPlxuICAgIHVuc2FmZV9ibGl0IGhkIDAgZHN0IHBvcyAobGVuZ3RoIGhkKTtcbiAgICB1bnNhZmVfYmxpdCBzZXAgMCBkc3QgKHBvcyArIGxlbmd0aCBoZCkgc2VwbGVuO1xuICAgIHVuc2FmZV9ibGl0cyBkc3QgKHBvcyArIGxlbmd0aCBoZCArIHNlcGxlbikgc2VwIHNlcGxlbiB0bFxuXG5sZXQgY29uY2F0IHNlcCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gXCJcIlxuICB8IGwgLT4gbGV0IHNlcGxlbiA9IGxlbmd0aCBzZXAgaW4gYnRzIEBAXG4gICAgICAgICAgdW5zYWZlX2JsaXRzXG4gICAgICAgICAgICAoQi5jcmVhdGUgKHN1bV9sZW5ndGhzIDAgc2VwbGVuIGwpKVxuICAgICAgICAgICAgMCBzZXAgc2VwbGVuIGxcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGl0ZXIgZiBzID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBzIC0gMSBkbyBmICh1bnNhZmVfZ2V0IHMgaSkgZG9uZVxuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaXRlcmkgZiBzID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBzIC0gMSBkbyBmIGkgKHVuc2FmZV9nZXQgcyBpKSBkb25lXG5cbmxldCBtYXAgZiBzID1cbiAgQi5tYXAgZiAoYm9zIHMpIHw+IGJ0c1xubGV0IG1hcGkgZiBzID1cbiAgQi5tYXBpIGYgKGJvcyBzKSB8PiBidHNcblxuKCogQmV3YXJlOiB3ZSBjYW5ub3QgdXNlIEIudHJpbSBvciBCLmVzY2FwZSBiZWNhdXNlIHRoZXkgYWx3YXlzIG1ha2UgYVxuICAgY29weSwgYnV0IFN0cmluZy5tbGkgc3BlbGxzIG91dCBzb21lIGNhc2VzIHdoZXJlIHdlIGFyZSBub3QgYWxsb3dlZFxuICAgdG8gbWFrZSBhIGNvcHkuICopXG5cbmxldCBpc19zcGFjZSA9IGZ1bmN0aW9uXG4gIHwgJyAnIHwgJ1xcMDEyJyB8ICdcXG4nIHwgJ1xccicgfCAnXFx0JyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuXG5sZXQgdHJpbSBzID1cbiAgaWYgcyA9IFwiXCIgdGhlbiBzXG4gIGVsc2UgaWYgaXNfc3BhY2UgKHVuc2FmZV9nZXQgcyAwKSB8fCBpc19zcGFjZSAodW5zYWZlX2dldCBzIChsZW5ndGggcyAtIDEpKVxuICAgIHRoZW4gYnRzIChCLnRyaW0gKGJvcyBzKSlcbiAgZWxzZSBzXG5cbmxldCBlc2NhcGVkIHMgPVxuICBsZXQgcmVjIG5lZWRzX2VzY2FwZSBpID1cbiAgICBpZiBpID49IGxlbmd0aCBzIHRoZW4gZmFsc2UgZWxzZVxuICAgICAgbWF0Y2ggdW5zYWZlX2dldCBzIGkgd2l0aFxuICAgICAgfCAnXFxcIicgfCAnXFxcXCcgfCAnXFxuJyB8ICdcXHQnIHwgJ1xccicgfCAnXFxiJyAtPiB0cnVlXG4gICAgICB8ICcgJyAuLiAnficgLT4gbmVlZHNfZXNjYXBlIChpKzEpXG4gICAgICB8IF8gLT4gdHJ1ZVxuICBpblxuICBpZiBuZWVkc19lc2NhcGUgMCB0aGVuXG4gICAgYnRzIChCLmVzY2FwZWQgKGJvcyBzKSlcbiAgZWxzZVxuICAgIHNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJlYyBpbmRleF9yZWMgcyBsaW0gaSBjID1cbiAgaWYgaSA+PSBsaW0gdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBpIGVsc2UgaW5kZXhfcmVjIHMgbGltIChpICsgMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaW5kZXggcyBjID0gaW5kZXhfcmVjIHMgKGxlbmd0aCBzKSAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJlYyBpbmRleF9yZWNfb3B0IHMgbGltIGkgYyA9XG4gIGlmIGkgPj0gbGltIHRoZW4gTm9uZSBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIFNvbWUgaSBlbHNlIGluZGV4X3JlY19vcHQgcyBsaW0gKGkgKyAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpbmRleF9vcHQgcyBjID0gaW5kZXhfcmVjX29wdCBzIChsZW5ndGggcykgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpbmRleF9mcm9tIHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLmluZGV4X2Zyb20gLyBCeXRlcy5pbmRleF9mcm9tXCIgZWxzZVxuICAgIGluZGV4X3JlYyBzIGwgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpbmRleF9mcm9tX29wdCBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5pbmRleF9mcm9tX29wdCAvIEJ5dGVzLmluZGV4X2Zyb21fb3B0XCIgZWxzZVxuICBpbmRleF9yZWNfb3B0IHMgbCBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJlYyByaW5kZXhfcmVjIHMgaSBjID1cbiAgaWYgaSA8IDAgdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBpIGVsc2UgcmluZGV4X3JlYyBzIChpIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmluZGV4IHMgYyA9IHJpbmRleF9yZWMgcyAobGVuZ3RoIHMgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByaW5kZXhfZnJvbSBzIGkgYyA9XG4gIGlmIGkgPCAtMSB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yaW5kZXhfZnJvbSAvIEJ5dGVzLnJpbmRleF9mcm9tXCJcbiAgZWxzZVxuICAgIHJpbmRleF9yZWMgcyBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJlYyByaW5kZXhfcmVjX29wdCBzIGkgYyA9XG4gIGlmIGkgPCAwIHRoZW4gTm9uZSBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIFNvbWUgaSBlbHNlIHJpbmRleF9yZWNfb3B0IHMgKGkgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByaW5kZXhfb3B0IHMgYyA9IHJpbmRleF9yZWNfb3B0IHMgKGxlbmd0aCBzIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmluZGV4X2Zyb21fb3B0IHMgaSBjID1cbiAgaWYgaSA8IC0xIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJpbmRleF9mcm9tX29wdCAvIEJ5dGVzLnJpbmRleF9mcm9tX29wdFwiXG4gIGVsc2VcbiAgICByaW5kZXhfcmVjX29wdCBzIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgY29udGFpbnNfZnJvbSBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLmNvbnRhaW5zX2Zyb20gLyBCeXRlcy5jb250YWluc19mcm9tXCJcbiAgZWxzZVxuICAgIHRyeSBpZ25vcmUgKGluZGV4X3JlYyBzIGwgaSBjKTsgdHJ1ZSB3aXRoIE5vdF9mb3VuZCAtPiBmYWxzZVxuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgY29udGFpbnMgcyBjID0gY29udGFpbnNfZnJvbSBzIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmNvbnRhaW5zX2Zyb20gcyBpIGMgPVxuICBpZiBpIDwgMCB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yY29udGFpbnNfZnJvbSAvIEJ5dGVzLnJjb250YWluc19mcm9tXCJcbiAgZWxzZVxuICAgIHRyeSBpZ25vcmUgKHJpbmRleF9yZWMgcyBpIGMpOyB0cnVlIHdpdGggTm90X2ZvdW5kIC0+IGZhbHNlXG5cbmxldCB1cHBlcmNhc2VfYXNjaWkgcyA9XG4gIEIudXBwZXJjYXNlX2FzY2lpIChib3MgcykgfD4gYnRzXG5sZXQgbG93ZXJjYXNlX2FzY2lpIHMgPVxuICBCLmxvd2VyY2FzZV9hc2NpaSAoYm9zIHMpIHw+IGJ0c1xubGV0IGNhcGl0YWxpemVfYXNjaWkgcyA9XG4gIEIuY2FwaXRhbGl6ZV9hc2NpaSAoYm9zIHMpIHw+IGJ0c1xubGV0IHVuY2FwaXRhbGl6ZV9hc2NpaSBzID1cbiAgQi51bmNhcGl0YWxpemVfYXNjaWkgKGJvcyBzKSB8PiBidHNcblxudHlwZSB0ID0gc3RyaW5nXG5cbmxldCBjb21wYXJlICh4OiB0KSAoeTogdCkgPSBQZXJ2YXNpdmVzLmNvbXBhcmUgeCB5XG5leHRlcm5hbCBlcXVhbCA6IHN0cmluZyAtPiBzdHJpbmcgLT4gYm9vbCA9IFwiY2FtbF9zdHJpbmdfZXF1YWxcIlxuXG5sZXQgc3BsaXRfb25fY2hhciBzZXAgcyA9XG4gIGxldCByID0gcmVmIFtdIGluXG4gIGxldCBqID0gcmVmIChsZW5ndGggcykgaW5cbiAgZm9yIGkgPSBsZW5ndGggcyAtIDEgZG93bnRvIDAgZG9cbiAgICBpZiB1bnNhZmVfZ2V0IHMgaSA9IHNlcCB0aGVuIGJlZ2luXG4gICAgICByIDo9IHN1YiBzIChpICsgMSkgKCFqIC0gaSAtIDEpIDo6ICFyO1xuICAgICAgaiA6PSBpXG4gICAgZW5kXG4gIGRvbmU7XG4gIHN1YiBzIDAgIWogOjogIXJcblxuKCogRGVwcmVjYXRlZCBmdW5jdGlvbnMgaW1wbGVtZW50ZWQgdmlhIG90aGVyIGRlcHJlY2F0ZWQgZnVuY3Rpb25zICopXG5bQEBAb2NhbWwud2FybmluZyBcIi0zXCJdXG5sZXQgdXBwZXJjYXNlIHMgPVxuICBCLnVwcGVyY2FzZSAoYm9zIHMpIHw+IGJ0c1xubGV0IGxvd2VyY2FzZSBzID1cbiAgQi5sb3dlcmNhc2UgKGJvcyBzKSB8PiBidHNcbmxldCBjYXBpdGFsaXplIHMgPVxuICBCLmNhcGl0YWxpemUgKGJvcyBzKSB8PiBidHNcbmxldCB1bmNhcGl0YWxpemUgcyA9XG4gIEIudW5jYXBpdGFsaXplIChib3MgcykgfD4gYnRzXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbTmF0aXZlaW50XTogcHJvY2Vzc29yLW5hdGl2ZSBpbnRlZ2VycyAqKVxuXG5leHRlcm5hbCBuZWc6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfbmVnXCJcbmV4dGVybmFsIGFkZDogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfYWRkXCJcbmV4dGVybmFsIHN1YjogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfc3ViXCJcbmV4dGVybmFsIG11bDogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfbXVsXCJcbmV4dGVybmFsIGRpdjogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfZGl2XCJcbmV4dGVybmFsIHJlbTogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfbW9kXCJcbmV4dGVybmFsIGxvZ2FuZDogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfYW5kXCJcbmV4dGVybmFsIGxvZ29yOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9vclwiXG5leHRlcm5hbCBsb2d4b3I6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X3hvclwiXG5leHRlcm5hbCBzaGlmdF9sZWZ0OiBuYXRpdmVpbnQgLT4gaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9sc2xcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHQ6IG5hdGl2ZWludCAtPiBpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2FzclwiXG5leHRlcm5hbCBzaGlmdF9yaWdodF9sb2dpY2FsOiBuYXRpdmVpbnQgLT4gaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9sc3JcIlxuZXh0ZXJuYWwgb2ZfaW50OiBpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X29mX2ludFwiXG5leHRlcm5hbCB0b19pbnQ6IG5hdGl2ZWludCAtPiBpbnQgPSBcIiVuYXRpdmVpbnRfdG9faW50XCJcbmV4dGVybmFsIG9mX2Zsb2F0IDogZmxvYXQgLT4gbmF0aXZlaW50XG4gID0gXCJjYW1sX25hdGl2ZWludF9vZl9mbG9hdFwiIFwiY2FtbF9uYXRpdmVpbnRfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0b19mbG9hdCA6IG5hdGl2ZWludCAtPiBmbG9hdFxuICA9IFwiY2FtbF9uYXRpdmVpbnRfdG9fZmxvYXRcIiBcImNhbWxfbmF0aXZlaW50X3RvX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgb2ZfaW50MzI6IGludDMyIC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9vZl9pbnQzMlwiXG5leHRlcm5hbCB0b19pbnQzMjogbmF0aXZlaW50IC0+IGludDMyID0gXCIlbmF0aXZlaW50X3RvX2ludDMyXCJcblxubGV0IHplcm8gPSAwblxubGV0IG9uZSA9IDFuXG5sZXQgbWludXNfb25lID0gLTFuXG5sZXQgc3VjYyBuID0gYWRkIG4gMW5cbmxldCBwcmVkIG4gPSBzdWIgbiAxblxubGV0IGFicyBuID0gaWYgbiA+PSAwbiB0aGVuIG4gZWxzZSBuZWcgblxubGV0IHNpemUgPSBTeXMud29yZF9zaXplXG5sZXQgbWluX2ludCA9IHNoaWZ0X2xlZnQgMW4gKHNpemUgLSAxKVxubGV0IG1heF9pbnQgPSBzdWIgbWluX2ludCAxblxubGV0IGxvZ25vdCBuID0gbG9neG9yIG4gKC0xbilcblxuZXh0ZXJuYWwgZm9ybWF0IDogc3RyaW5nIC0+IG5hdGl2ZWludCAtPiBzdHJpbmcgPSBcImNhbWxfbmF0aXZlaW50X2Zvcm1hdFwiXG5sZXQgdG9fc3RyaW5nIG4gPSBmb3JtYXQgXCIlZFwiIG5cblxuZXh0ZXJuYWwgb2Zfc3RyaW5nOiBzdHJpbmcgLT4gbmF0aXZlaW50ID0gXCJjYW1sX25hdGl2ZWludF9vZl9zdHJpbmdcIlxuXG5sZXQgb2Zfc3RyaW5nX29wdCBzID1cbiAgKCogVE9ETzogZXhwb3NlIGEgbm9uLXJhaXNpbmcgcHJpbWl0aXZlIGRpcmVjdGx5LiAqKVxuICB0cnkgU29tZSAob2Zfc3RyaW5nIHMpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxudHlwZSB0ID0gbmF0aXZlaW50XG5cbmxldCBjb21wYXJlICh4OiB0KSAoeTogdCkgPSBQZXJ2YXNpdmVzLmNvbXBhcmUgeCB5XG5sZXQgZXF1YWwgKHg6IHQpICh5OiB0KSA9IGNvbXBhcmUgeCB5ID0gMFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNZXJnaW5nIGFuZCBzb3J0aW5nICopXG5cbm9wZW4gQXJyYXlcblxubGV0IHJlYyBtZXJnZSBvcmRlciBsMSBsMiA9XG4gIG1hdGNoIGwxIHdpdGhcbiAgICBbXSAtPiBsMlxuICB8IGgxIDo6IHQxIC0+XG4gICAgICBtYXRjaCBsMiB3aXRoXG4gICAgICAgIFtdIC0+IGwxXG4gICAgICB8IGgyIDo6IHQyIC0+XG4gICAgICAgICAgaWYgb3JkZXIgaDEgaDJcbiAgICAgICAgICB0aGVuIGgxIDo6IG1lcmdlIG9yZGVyIHQxIGwyXG4gICAgICAgICAgZWxzZSBoMiA6OiBtZXJnZSBvcmRlciBsMSB0MlxuXG5sZXQgbGlzdCBvcmRlciBsID1cbiAgbGV0IHJlYyBpbml0bGlzdCA9IGZ1bmN0aW9uXG4gICAgICBbXSAtPiBbXVxuICAgIHwgW2VdIC0+IFtbZV1dXG4gICAgfCBlMTo6ZTI6OnJlc3QgLT5cbiAgICAgICAgKGlmIG9yZGVyIGUxIGUyIHRoZW4gW2UxO2UyXSBlbHNlIFtlMjtlMV0pIDo6IGluaXRsaXN0IHJlc3QgaW5cbiAgbGV0IHJlYyBtZXJnZTIgPSBmdW5jdGlvblxuICAgICAgbDE6OmwyOjpyZXN0IC0+IG1lcmdlIG9yZGVyIGwxIGwyIDo6IG1lcmdlMiByZXN0XG4gICAgfCB4IC0+IHggaW5cbiAgbGV0IHJlYyBtZXJnZWFsbCA9IGZ1bmN0aW9uXG4gICAgICBbXSAtPiBbXVxuICAgIHwgW2xdIC0+IGxcbiAgICB8IGxsaXN0IC0+IG1lcmdlYWxsIChtZXJnZTIgbGxpc3QpIGluXG4gIG1lcmdlYWxsKGluaXRsaXN0IGwpXG5cbmxldCBzd2FwIGFyciBpIGogPVxuICBsZXQgdG1wID0gdW5zYWZlX2dldCBhcnIgaSBpblxuICB1bnNhZmVfc2V0IGFyciBpICh1bnNhZmVfZ2V0IGFyciBqKTtcbiAgdW5zYWZlX3NldCBhcnIgaiB0bXBcblxuKCogVGhlcmUgaXMgYSBrbm93biBwZXJmb3JtYW5jZSBidWcgaW4gdGhlIGNvZGUgYmVsb3cuICBJZiB5b3UgZmluZFxuICAgaXQsIGRvbid0IGJvdGhlciByZXBvcnRpbmcgaXQuICBZb3UncmUgbm90IHN1cHBvc2VkIHRvIHVzZSB0aGlzXG4gICBtb2R1bGUgYW55d2F5LiAqKVxubGV0IGFycmF5IGNtcCBhcnIgPVxuICBsZXQgcmVjIHFzb3J0IGxvIGhpID1cbiAgICBpZiBoaSAtIGxvID49IDYgdGhlbiBiZWdpblxuICAgICAgbGV0IG1pZCA9IChsbyArIGhpKSBsc3IgMSBpblxuICAgICAgKCogU2VsZWN0IG1lZGlhbiB2YWx1ZSBmcm9tIGFtb25nIExPLCBNSUQsIGFuZCBISS4gUmVhcnJhbmdlXG4gICAgICAgICBMTyBhbmQgSEkgc28gdGhlIHRocmVlIHZhbHVlcyBhcmUgc29ydGVkLiBUaGlzIGxvd2VycyB0aGVcbiAgICAgICAgIHByb2JhYmlsaXR5IG9mIHBpY2tpbmcgYSBwYXRob2xvZ2ljYWwgcGl2b3QuICBJdCBhbHNvXG4gICAgICAgICBhdm9pZHMgZXh0cmEgY29tcGFyaXNvbnMgb24gaSBhbmQgaiBpbiB0aGUgdHdvIHRpZ2h0IFwid2hpbGVcIlxuICAgICAgICAgbG9vcHMgYmVsb3cuICopXG4gICAgICBpZiBjbXAgKHVuc2FmZV9nZXQgYXJyIG1pZCkgKHVuc2FmZV9nZXQgYXJyIGxvKSB0aGVuIHN3YXAgYXJyIG1pZCBsbztcbiAgICAgIGlmIGNtcCAodW5zYWZlX2dldCBhcnIgaGkpICh1bnNhZmVfZ2V0IGFyciBtaWQpIHRoZW4gYmVnaW5cbiAgICAgICAgc3dhcCBhcnIgbWlkIGhpO1xuICAgICAgICBpZiBjbXAgKHVuc2FmZV9nZXQgYXJyIG1pZCkgKHVuc2FmZV9nZXQgYXJyIGxvKSB0aGVuIHN3YXAgYXJyIG1pZCBsb1xuICAgICAgZW5kO1xuICAgICAgbGV0IHBpdm90ID0gdW5zYWZlX2dldCBhcnIgbWlkIGluXG4gICAgICBsZXQgaSA9IHJlZiAobG8gKyAxKSBhbmQgaiA9IHJlZiAoaGkgLSAxKSBpblxuICAgICAgaWYgbm90IChjbXAgcGl2b3QgKHVuc2FmZV9nZXQgYXJyIGhpKSlcbiAgICAgICAgIHx8IG5vdCAoY21wICh1bnNhZmVfZ2V0IGFyciBsbykgcGl2b3QpXG4gICAgICB0aGVuIHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IFwiU29ydC5hcnJheVwiKTtcbiAgICAgIHdoaWxlICFpIDwgIWogZG9cbiAgICAgICAgd2hpbGUgbm90IChjbXAgcGl2b3QgKHVuc2FmZV9nZXQgYXJyICFpKSkgZG8gaW5jciBpIGRvbmU7XG4gICAgICAgIHdoaWxlIG5vdCAoY21wICh1bnNhZmVfZ2V0IGFyciAhaikgcGl2b3QpIGRvIGRlY3IgaiBkb25lO1xuICAgICAgICBpZiAhaSA8ICFqIHRoZW4gc3dhcCBhcnIgIWkgIWo7XG4gICAgICAgIGluY3IgaTsgZGVjciBqXG4gICAgICBkb25lO1xuICAgICAgKCogUmVjdXJzaW9uIG9uIHNtYWxsZXIgaGFsZiwgdGFpbC1jYWxsIG9uIGxhcmdlciBoYWxmICopXG4gICAgICBpZiAhaiAtIGxvIDw9IGhpIC0gIWkgdGhlbiBiZWdpblxuICAgICAgICBxc29ydCBsbyAhajsgcXNvcnQgIWkgaGlcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIHFzb3J0ICFpIGhpOyBxc29ydCBsbyAhalxuICAgICAgZW5kXG4gICAgZW5kIGluXG4gIHFzb3J0IDAgKEFycmF5Lmxlbmd0aCBhcnIgLSAxKTtcbiAgKCogRmluaXNoIHNvcnRpbmcgYnkgaW5zZXJ0aW9uIHNvcnQgKilcbiAgZm9yIGkgPSAxIHRvIEFycmF5Lmxlbmd0aCBhcnIgLSAxIGRvXG4gICAgbGV0IHZhbF9pID0gKHVuc2FmZV9nZXQgYXJyIGkpIGluXG4gICAgaWYgbm90IChjbXAgKHVuc2FmZV9nZXQgYXJyIChpIC0gMSkpIHZhbF9pKSB0aGVuIGJlZ2luXG4gICAgICB1bnNhZmVfc2V0IGFyciBpICh1bnNhZmVfZ2V0IGFyciAoaSAtIDEpKTtcbiAgICAgIGxldCBqID0gcmVmIChpIC0gMSkgaW5cbiAgICAgIHdoaWxlICFqID49IDEgJiYgbm90IChjbXAgKHVuc2FmZV9nZXQgYXJyICghaiAtIDEpKSB2YWxfaSkgZG9cbiAgICAgICAgdW5zYWZlX3NldCBhcnIgIWogKHVuc2FmZV9nZXQgYXJyICghaiAtIDEpKTtcbiAgICAgICAgZGVjciBqXG4gICAgICBkb25lO1xuICAgICAgdW5zYWZlX3NldCBhcnIgIWogdmFsX2lcbiAgICBlbmRcbiAgZG9uZVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIGV4dGVybl9mbGFncyA9XG4gICAgTm9fc2hhcmluZ1xuICB8IENsb3N1cmVzXG4gIHwgQ29tcGF0XzMyXG4oKiBub3RlOiB0aGlzIHR5cGUgZGVmaW5pdGlvbiBpcyB1c2VkIGluICdieXRlcnVuL2RlYnVnZ2VyLmMnICopXG5cbmV4dGVybmFsIHRvX2NoYW5uZWw6IG91dF9jaGFubmVsIC0+ICdhIC0+IGV4dGVybl9mbGFncyBsaXN0IC0+IHVuaXRcbiAgICA9IFwiY2FtbF9vdXRwdXRfdmFsdWVcIlxuZXh0ZXJuYWwgdG9fYnl0ZXM6ICdhIC0+IGV4dGVybl9mbGFncyBsaXN0IC0+IGJ5dGVzXG4gICAgPSBcImNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZ1wiXG5leHRlcm5hbCB0b19zdHJpbmc6ICdhIC0+IGV4dGVybl9mbGFncyBsaXN0IC0+IHN0cmluZ1xuICAgID0gXCJjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmdcIlxuZXh0ZXJuYWwgdG9fYnVmZmVyX3Vuc2FmZTpcbiAgICAgIGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gZXh0ZXJuX2ZsYWdzIGxpc3QgLT4gaW50XG4gICAgPSBcImNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J1ZmZlclwiXG5cbmxldCB0b19idWZmZXIgYnVmZiBvZnMgbGVuIHYgZmxhZ3MgPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gQnl0ZXMubGVuZ3RoIGJ1ZmYgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIk1hcnNoYWwudG9fYnVmZmVyOiBzdWJzdHJpbmcgb3V0IG9mIGJvdW5kc1wiXG4gIGVsc2UgdG9fYnVmZmVyX3Vuc2FmZSBidWZmIG9mcyBsZW4gdiBmbGFnc1xuXG4oKiBUaGUgZnVuY3Rpb25zIGJlbG93IHVzZSBieXRlIHNlcXVlbmNlcyBhcyBpbnB1dCwgbmV2ZXIgdXNpbmcgYW55XG4gICBtdXRhdGlvbi4gSXQgbWFrZXMgc2Vuc2UgdG8gdXNlIG5vbi1tdXRhdGVkIFtieXRlc10gcmF0aGVyIHRoYW5cbiAgIFtzdHJpbmddLCBiZWNhdXNlIHdlIHJlYWxseSB3b3JrIHdpdGggc2VxdWVuY2VzIG9mIGJ5dGVzLCBub3RcbiAgIGEgdGV4dCByZXByZXNlbnRhdGlvbi5cbiopXG5cbmV4dGVybmFsIGZyb21fY2hhbm5lbDogaW5fY2hhbm5lbCAtPiAnYSA9IFwiY2FtbF9pbnB1dF92YWx1ZVwiXG5leHRlcm5hbCBmcm9tX2J5dGVzX3Vuc2FmZTogYnl0ZXMgLT4gaW50IC0+ICdhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3N0cmluZ1wiXG5leHRlcm5hbCBkYXRhX3NpemVfdW5zYWZlOiBieXRlcyAtPiBpbnQgLT4gaW50ID0gXCJjYW1sX21hcnNoYWxfZGF0YV9zaXplXCJcblxubGV0IGhlYWRlcl9zaXplID0gMjBcbmxldCBkYXRhX3NpemUgYnVmZiBvZnMgPVxuICBpZiBvZnMgPCAwIHx8IG9mcyA+IEJ5dGVzLmxlbmd0aCBidWZmIC0gaGVhZGVyX3NpemVcbiAgdGhlbiBpbnZhbGlkX2FyZyBcIk1hcnNoYWwuZGF0YV9zaXplXCJcbiAgZWxzZSBkYXRhX3NpemVfdW5zYWZlIGJ1ZmYgb2ZzXG5sZXQgdG90YWxfc2l6ZSBidWZmIG9mcyA9IGhlYWRlcl9zaXplICsgZGF0YV9zaXplIGJ1ZmYgb2ZzXG5cbmxldCBmcm9tX2J5dGVzIGJ1ZmYgb2ZzID1cbiAgaWYgb2ZzIDwgMCB8fCBvZnMgPiBCeXRlcy5sZW5ndGggYnVmZiAtIGhlYWRlcl9zaXplXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJNYXJzaGFsLmZyb21fYnl0ZXNcIlxuICBlbHNlIGJlZ2luXG4gICAgbGV0IGxlbiA9IGRhdGFfc2l6ZV91bnNhZmUgYnVmZiBvZnMgaW5cbiAgICBpZiBvZnMgPiBCeXRlcy5sZW5ndGggYnVmZiAtIChoZWFkZXJfc2l6ZSArIGxlbilcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiTWFyc2hhbC5mcm9tX2J5dGVzXCJcbiAgICBlbHNlIGZyb21fYnl0ZXNfdW5zYWZlIGJ1ZmYgb2ZzXG4gIGVuZFxuXG5sZXQgZnJvbV9zdHJpbmcgYnVmZiBvZnMgPVxuICAoKiBCeXRlcy51bnNhZmVfb2Zfc3RyaW5nIGlzIHNhZmUgaGVyZSwgYXMgdGhlIHByb2R1Y2VkIGJ5dGVcbiAgICAgc2VxdWVuY2UgaXMgbmV2ZXIgbXV0YXRlZCAqKVxuICBmcm9tX2J5dGVzIChCeXRlcy51bnNhZmVfb2Zfc3RyaW5nIGJ1ZmYpIG9mc1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBPcGVyYXRpb25zIG9uIGludGVybmFsIHJlcHJlc2VudGF0aW9ucyBvZiB2YWx1ZXMgKilcblxudHlwZSB0XG5cbmV4dGVybmFsIHJlcHIgOiAnYSAtPiB0ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgb2JqIDogdCAtPiAnYSA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIG1hZ2ljIDogJ2EgLT4gJ2IgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBpc19pbnQgOiB0IC0+IGJvb2wgPSBcIiVvYmpfaXNfaW50XCJcbmxldCBbQGlubGluZSBhbHdheXNdIGlzX2Jsb2NrIGEgPSBub3QgKGlzX2ludCBhKVxuZXh0ZXJuYWwgdGFnIDogdCAtPiBpbnQgPSBcImNhbWxfb2JqX3RhZ1wiXG5leHRlcm5hbCBzZXRfdGFnIDogdCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9vYmpfc2V0X3RhZ1wiXG5leHRlcm5hbCBzaXplIDogdCAtPiBpbnQgPSBcIiVvYmpfc2l6ZVwiXG5leHRlcm5hbCByZWFjaGFibGVfd29yZHMgOiB0IC0+IGludCA9IFwiY2FtbF9vYmpfcmVhY2hhYmxlX3dvcmRzXCJcbmV4dGVybmFsIGZpZWxkIDogdCAtPiBpbnQgLT4gdCA9IFwiJW9ial9maWVsZFwiXG5leHRlcm5hbCBzZXRfZmllbGQgOiB0IC0+IGludCAtPiB0IC0+IHVuaXQgPSBcIiVvYmpfc2V0X2ZpZWxkXCJcbmV4dGVybmFsIGZsb2F0YXJyYXlfZ2V0IDogZmxvYXRhcnJheSAtPiBpbnQgLT4gZmxvYXQgPSBcImNhbWxfZmxvYXRhcnJheV9nZXRcIlxuZXh0ZXJuYWwgZmxvYXRhcnJheV9zZXQgOlxuICAgIGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0IC0+IHVuaXQgPSBcImNhbWxfZmxvYXRhcnJheV9zZXRcIlxubGV0IFtAaW5saW5lIGFsd2F5c10gZG91YmxlX2ZpZWxkIHggaSA9IGZsb2F0YXJyYXlfZ2V0IChvYmogeCA6IGZsb2F0YXJyYXkpIGlcbmxldCBbQGlubGluZSBhbHdheXNdIHNldF9kb3VibGVfZmllbGQgeCBpIHYgPVxuICBmbG9hdGFycmF5X3NldCAob2JqIHggOiBmbG9hdGFycmF5KSBpIHZcbmV4dGVybmFsIG5ld19ibG9jayA6IGludCAtPiBpbnQgLT4gdCA9IFwiY2FtbF9vYmpfYmxvY2tcIlxuZXh0ZXJuYWwgZHVwIDogdCAtPiB0ID0gXCJjYW1sX29ial9kdXBcIlxuZXh0ZXJuYWwgdHJ1bmNhdGUgOiB0IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX29ial90cnVuY2F0ZVwiXG5leHRlcm5hbCBhZGRfb2Zmc2V0IDogdCAtPiBJbnQzMi50IC0+IHQgPSBcImNhbWxfb2JqX2FkZF9vZmZzZXRcIlxuXG5sZXQgbWFyc2hhbCAob2JqIDogdCkgPVxuICBNYXJzaGFsLnRvX2J5dGVzIG9iaiBbXVxubGV0IHVubWFyc2hhbCBzdHIgcG9zID1cbiAgKE1hcnNoYWwuZnJvbV9ieXRlcyBzdHIgcG9zLCBwb3MgKyBNYXJzaGFsLnRvdGFsX3NpemUgc3RyIHBvcylcblxubGV0IGZpcnN0X25vbl9jb25zdGFudF9jb25zdHJ1Y3Rvcl90YWcgPSAwXG5sZXQgbGFzdF9ub25fY29uc3RhbnRfY29uc3RydWN0b3JfdGFnID0gMjQ1XG5cbmxldCBsYXp5X3RhZyA9IDI0NlxubGV0IGNsb3N1cmVfdGFnID0gMjQ3XG5sZXQgb2JqZWN0X3RhZyA9IDI0OFxubGV0IGluZml4X3RhZyA9IDI0OVxubGV0IGZvcndhcmRfdGFnID0gMjUwXG5cbmxldCBub19zY2FuX3RhZyA9IDI1MVxuXG5sZXQgYWJzdHJhY3RfdGFnID0gMjUxXG5sZXQgc3RyaW5nX3RhZyA9IDI1MlxubGV0IGRvdWJsZV90YWcgPSAyNTNcbmxldCBkb3VibGVfYXJyYXlfdGFnID0gMjU0XG5sZXQgY3VzdG9tX3RhZyA9IDI1NVxubGV0IGZpbmFsX3RhZyA9IGN1c3RvbV90YWdcblxuXG5sZXQgaW50X3RhZyA9IDEwMDBcbmxldCBvdXRfb2ZfaGVhcF90YWcgPSAxMDAxXG5sZXQgdW5hbGlnbmVkX3RhZyA9IDEwMDJcblxubGV0IGV4dGVuc2lvbl9jb25zdHJ1Y3RvciB4ID1cbiAgbGV0IHggPSByZXByIHggaW5cbiAgbGV0IHNsb3QgPVxuICAgIGlmIChpc19ibG9jayB4KSAmJiAodGFnIHgpIDw+IG9iamVjdF90YWcgJiYgKHNpemUgeCkgPj0gMSB0aGVuIGZpZWxkIHggMFxuICAgIGVsc2UgeFxuICBpblxuICBsZXQgbmFtZSA9XG4gICAgaWYgKGlzX2Jsb2NrIHNsb3QpICYmICh0YWcgc2xvdCkgPSBvYmplY3RfdGFnIHRoZW4gZmllbGQgc2xvdCAwXG4gICAgZWxzZSBpbnZhbGlkX2FyZyBcIk9iai5leHRlbnNpb25fY29uc3RydWN0b3JcIlxuICBpblxuICAgIGlmICh0YWcgbmFtZSkgPSBzdHJpbmdfdGFnIHRoZW4gKG9iaiBzbG90IDogZXh0ZW5zaW9uX2NvbnN0cnVjdG9yKVxuICAgIGVsc2UgaW52YWxpZF9hcmcgXCJPYmouZXh0ZW5zaW9uX2NvbnN0cnVjdG9yXCJcblxubGV0IFtAaW5saW5lIGFsd2F5c10gZXh0ZW5zaW9uX25hbWUgKHNsb3QgOiBleHRlbnNpb25fY29uc3RydWN0b3IpID1cbiAgKG9iaiAoZmllbGQgKHJlcHIgc2xvdCkgMCkgOiBzdHJpbmcpXG5cbmxldCBbQGlubGluZSBhbHdheXNdIGV4dGVuc2lvbl9pZCAoc2xvdCA6IGV4dGVuc2lvbl9jb25zdHJ1Y3RvcikgPVxuICAob2JqIChmaWVsZCAocmVwciBzbG90KSAxKSA6IGludClcblxubW9kdWxlIEVwaGVtZXJvbiA9IHN0cnVjdFxuICB0eXBlIG9ial90ID0gdFxuXG4gIHR5cGUgdCAoKiogZXBoZW1lcm9uICopXG5cbiAgZXh0ZXJuYWwgY3JlYXRlOiBpbnQgLT4gdCA9IFwiY2FtbF9lcGhlX2NyZWF0ZVwiXG5cbiAgbGV0IGxlbmd0aCB4ID0gc2l6ZShyZXByIHgpIC0gMlxuXG4gIGV4dGVybmFsIGdldF9rZXk6IHQgLT4gaW50IC0+IG9ial90IG9wdGlvbiA9IFwiY2FtbF9lcGhlX2dldF9rZXlcIlxuICBleHRlcm5hbCBnZXRfa2V5X2NvcHk6IHQgLT4gaW50IC0+IG9ial90IG9wdGlvbiA9IFwiY2FtbF9lcGhlX2dldF9rZXlfY29weVwiXG4gIGV4dGVybmFsIHNldF9rZXk6IHQgLT4gaW50IC0+IG9ial90IC0+IHVuaXQgPSBcImNhbWxfZXBoZV9zZXRfa2V5XCJcbiAgZXh0ZXJuYWwgdW5zZXRfa2V5OiB0IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfdW5zZXRfa2V5XCJcbiAgZXh0ZXJuYWwgY2hlY2tfa2V5OiB0IC0+IGludCAtPiBib29sID0gXCJjYW1sX2VwaGVfY2hlY2tfa2V5XCJcbiAgZXh0ZXJuYWwgYmxpdF9rZXkgOiB0IC0+IGludCAtPiB0IC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgID0gXCJjYW1sX2VwaGVfYmxpdF9rZXlcIlxuXG4gIGV4dGVybmFsIGdldF9kYXRhOiB0IC0+IG9ial90IG9wdGlvbiA9IFwiY2FtbF9lcGhlX2dldF9kYXRhXCJcbiAgZXh0ZXJuYWwgZ2V0X2RhdGFfY29weTogdCAtPiBvYmpfdCBvcHRpb24gPSBcImNhbWxfZXBoZV9nZXRfZGF0YV9jb3B5XCJcbiAgZXh0ZXJuYWwgc2V0X2RhdGE6IHQgLT4gb2JqX3QgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX3NldF9kYXRhXCJcbiAgZXh0ZXJuYWwgdW5zZXRfZGF0YTogdCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfdW5zZXRfZGF0YVwiXG4gIGV4dGVybmFsIGNoZWNrX2RhdGE6IHQgLT4gYm9vbCA9IFwiY2FtbF9lcGhlX2NoZWNrX2RhdGFcIlxuICBleHRlcm5hbCBibGl0X2RhdGEgOiB0IC0+IHQgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX2JsaXRfZGF0YVwiXG5cblxuZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEFycmF5IG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgbGVuZ3RoIDogJ2EgYXJyYXkgLT4gaW50ID0gXCIlYXJyYXlfbGVuZ3RoXCJcbmV4dGVybmFsIGdldDogJ2EgYXJyYXkgLT4gaW50IC0+ICdhID0gXCIlYXJyYXlfc2FmZV9nZXRcIlxuZXh0ZXJuYWwgc2V0OiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiJWFycmF5X3NhZmVfc2V0XCJcbmV4dGVybmFsIHVuc2FmZV9nZXQ6ICdhIGFycmF5IC0+IGludCAtPiAnYSA9IFwiJWFycmF5X3Vuc2FmZV9nZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldDogJ2EgYXJyYXkgLT4gaW50IC0+ICdhIC0+IHVuaXQgPSBcIiVhcnJheV91bnNhZmVfc2V0XCJcbmV4dGVybmFsIG1ha2U6IGludCAtPiAnYSAtPiAnYSBhcnJheSA9IFwiY2FtbF9tYWtlX3ZlY3RcIlxuZXh0ZXJuYWwgY3JlYXRlOiBpbnQgLT4gJ2EgLT4gJ2EgYXJyYXkgPSBcImNhbWxfbWFrZV92ZWN0XCJcbmV4dGVybmFsIHVuc2FmZV9zdWIgOiAnYSBhcnJheSAtPiBpbnQgLT4gaW50IC0+ICdhIGFycmF5ID0gXCJjYW1sX2FycmF5X3N1YlwiXG5leHRlcm5hbCBhcHBlbmRfcHJpbSA6ICdhIGFycmF5IC0+ICdhIGFycmF5IC0+ICdhIGFycmF5ID0gXCJjYW1sX2FycmF5X2FwcGVuZFwiXG5leHRlcm5hbCBjb25jYXQgOiAnYSBhcnJheSBsaXN0IC0+ICdhIGFycmF5ID0gXCJjYW1sX2FycmF5X2NvbmNhdFwiXG5leHRlcm5hbCB1bnNhZmVfYmxpdCA6XG4gICdhIGFycmF5IC0+IGludCAtPiAnYSBhcnJheSAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfYXJyYXlfYmxpdFwiXG5leHRlcm5hbCBjcmVhdGVfZmxvYXQ6IGludCAtPiBmbG9hdCBhcnJheSA9IFwiY2FtbF9tYWtlX2Zsb2F0X3ZlY3RcIlxubGV0IG1ha2VfZmxvYXQgPSBjcmVhdGVfZmxvYXRcblxubW9kdWxlIEZsb2F0YXJyYXkgPSBzdHJ1Y3RcbiAgZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+IGZsb2F0YXJyYXkgPSBcImNhbWxfZmxvYXRhcnJheV9jcmVhdGVcIlxuICBleHRlcm5hbCBsZW5ndGggOiBmbG9hdGFycmF5IC0+IGludCA9IFwiJWZsb2F0YXJyYXlfbGVuZ3RoXCJcbiAgZXh0ZXJuYWwgZ2V0IDogZmxvYXRhcnJheSAtPiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdGFycmF5X3NhZmVfZ2V0XCJcbiAgZXh0ZXJuYWwgc2V0IDogZmxvYXRhcnJheSAtPiBpbnQgLT4gZmxvYXQgLT4gdW5pdCA9IFwiJWZsb2F0YXJyYXlfc2FmZV9zZXRcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0IDogZmxvYXRhcnJheSAtPiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdGFycmF5X3Vuc2FmZV9nZXRcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0IDogZmxvYXRhcnJheSAtPiBpbnQgLT4gZmxvYXQgLT4gdW5pdFxuICAgICAgPSBcIiVmbG9hdGFycmF5X3Vuc2FmZV9zZXRcIlxuZW5kXG5cbmxldCBpbml0IGwgZiA9XG4gIGlmIGwgPSAwIHRoZW4gW3x8XSBlbHNlXG4gIGlmIGwgPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5pbml0XCJcbiAgKCogU2VlICM2NTc1LiBXZSBjb3VsZCBhbHNvIGNoZWNrIGZvciBtYXhpbXVtIGFycmF5IHNpemUsIGJ1dCB0aGlzIGRlcGVuZHNcbiAgICAgb24gd2hldGhlciB3ZSBjcmVhdGUgYSBmbG9hdCBhcnJheSBvciBhIHJlZ3VsYXIgb25lLi4uICopXG4gIGVsc2VcbiAgIGxldCByZXMgPSBjcmVhdGUgbCAoZiAwKSBpblxuICAgZm9yIGkgPSAxIHRvIHByZWQgbCBkb1xuICAgICB1bnNhZmVfc2V0IHJlcyBpIChmIGkpXG4gICBkb25lO1xuICAgcmVzXG5cbmxldCBtYWtlX21hdHJpeCBzeCBzeSBpbml0ID1cbiAgbGV0IHJlcyA9IGNyZWF0ZSBzeCBbfHxdIGluXG4gIGZvciB4ID0gMCB0byBwcmVkIHN4IGRvXG4gICAgdW5zYWZlX3NldCByZXMgeCAoY3JlYXRlIHN5IGluaXQpXG4gIGRvbmU7XG4gIHJlc1xuXG5sZXQgY3JlYXRlX21hdHJpeCA9IG1ha2VfbWF0cml4XG5cbmxldCBjb3B5IGEgPVxuICBsZXQgbCA9IGxlbmd0aCBhIGluIGlmIGwgPSAwIHRoZW4gW3x8XSBlbHNlIHVuc2FmZV9zdWIgYSAwIGxcblxubGV0IGFwcGVuZCBhMSBhMiA9XG4gIGxldCBsMSA9IGxlbmd0aCBhMSBpblxuICBpZiBsMSA9IDAgdGhlbiBjb3B5IGEyXG4gIGVsc2UgaWYgbGVuZ3RoIGEyID0gMCB0aGVuIHVuc2FmZV9zdWIgYTEgMCBsMVxuICBlbHNlIGFwcGVuZF9wcmltIGExIGEyXG5cbmxldCBzdWIgYSBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGxlbmd0aCBhIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5zdWJcIlxuICBlbHNlIHVuc2FmZV9zdWIgYSBvZnMgbGVuXG5cbmxldCBmaWxsIGEgb2ZzIGxlbiB2ID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGxlbmd0aCBhIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5maWxsXCJcbiAgZWxzZSBmb3IgaSA9IG9mcyB0byBvZnMgKyBsZW4gLSAxIGRvIHVuc2FmZV9zZXQgYSBpIHYgZG9uZVxuXG5sZXQgYmxpdCBhMSBvZnMxIGEyIG9mczIgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBvZnMxIDwgMCB8fCBvZnMxID4gbGVuZ3RoIGExIC0gbGVuXG4gICAgICAgICAgICAgfHwgb2ZzMiA8IDAgfHwgb2ZzMiA+IGxlbmd0aCBhMiAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuYmxpdFwiXG4gIGVsc2UgdW5zYWZlX2JsaXQgYTEgb2ZzMSBhMiBvZnMyIGxlblxuXG5sZXQgaXRlciBmIGEgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYodW5zYWZlX2dldCBhIGkpIGRvbmVcblxubGV0IGl0ZXIyIGYgYSBiID1cbiAgaWYgbGVuZ3RoIGEgPD4gbGVuZ3RoIGIgdGhlblxuICAgIGludmFsaWRfYXJnIFwiQXJyYXkuaXRlcjI6IGFycmF5cyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCJcbiAgZWxzZVxuICAgIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiAodW5zYWZlX2dldCBhIGkpICh1bnNhZmVfZ2V0IGIgaSkgZG9uZVxuXG5sZXQgbWFwIGYgYSA9XG4gIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgaWYgbCA9IDAgdGhlbiBbfHxdIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsIChmKHVuc2FmZV9nZXQgYSAwKSkgaW5cbiAgICBmb3IgaSA9IDEgdG8gbCAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgciBpIChmKHVuc2FmZV9nZXQgYSBpKSlcbiAgICBkb25lO1xuICAgIHJcbiAgZW5kXG5cbmxldCBtYXAyIGYgYSBiID1cbiAgbGV0IGxhID0gbGVuZ3RoIGEgaW5cbiAgbGV0IGxiID0gbGVuZ3RoIGIgaW5cbiAgaWYgbGEgPD4gbGIgdGhlblxuICAgIGludmFsaWRfYXJnIFwiQXJyYXkubWFwMjogYXJyYXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIlxuICBlbHNlIGJlZ2luXG4gICAgaWYgbGEgPSAwIHRoZW4gW3x8XSBlbHNlIGJlZ2luXG4gICAgICBsZXQgciA9IGNyZWF0ZSBsYSAoZiAodW5zYWZlX2dldCBhIDApICh1bnNhZmVfZ2V0IGIgMCkpIGluXG4gICAgICBmb3IgaSA9IDEgdG8gbGEgLSAxIGRvXG4gICAgICAgIHVuc2FmZV9zZXQgciBpIChmICh1bnNhZmVfZ2V0IGEgaSkgKHVuc2FmZV9nZXQgYiBpKSlcbiAgICAgIGRvbmU7XG4gICAgICByXG4gICAgZW5kXG4gIGVuZFxuXG5sZXQgaXRlcmkgZiBhID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmIGkgKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbmxldCBtYXBpIGYgYSA9XG4gIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgaWYgbCA9IDAgdGhlbiBbfHxdIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsIChmIDAgKHVuc2FmZV9nZXQgYSAwKSkgaW5cbiAgICBmb3IgaSA9IDEgdG8gbCAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgciBpIChmIGkgKHVuc2FmZV9nZXQgYSBpKSlcbiAgICBkb25lO1xuICAgIHJcbiAgZW5kXG5cbmxldCB0b19saXN0IGEgPVxuICBsZXQgcmVjIHRvbGlzdCBpIHJlcyA9XG4gICAgaWYgaSA8IDAgdGhlbiByZXMgZWxzZSB0b2xpc3QgKGkgLSAxKSAodW5zYWZlX2dldCBhIGkgOjogcmVzKSBpblxuICB0b2xpc3QgKGxlbmd0aCBhIC0gMSkgW11cblxuKCogQ2Fubm90IHVzZSBMaXN0Lmxlbmd0aCBoZXJlIGJlY2F1c2UgdGhlIExpc3QgbW9kdWxlIGRlcGVuZHMgb24gQXJyYXkuICopXG5sZXQgcmVjIGxpc3RfbGVuZ3RoIGFjY3UgPSBmdW5jdGlvblxuICB8IFtdIC0+IGFjY3VcbiAgfCBfOjp0IC0+IGxpc3RfbGVuZ3RoIChzdWNjIGFjY3UpIHRcblxubGV0IG9mX2xpc3QgPSBmdW5jdGlvblxuICAgIFtdIC0+IFt8fF1cbiAgfCBoZDo6dGwgYXMgbCAtPlxuICAgICAgbGV0IGEgPSBjcmVhdGUgKGxpc3RfbGVuZ3RoIDAgbCkgaGQgaW5cbiAgICAgIGxldCByZWMgZmlsbCBpID0gZnVuY3Rpb25cbiAgICAgICAgICBbXSAtPiBhXG4gICAgICAgIHwgaGQ6OnRsIC0+IHVuc2FmZV9zZXQgYSBpIGhkOyBmaWxsIChpKzEpIHRsIGluXG4gICAgICBmaWxsIDEgdGxcblxubGV0IGZvbGRfbGVmdCBmIHggYSA9XG4gIGxldCByID0gcmVmIHggaW5cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkb1xuICAgIHIgOj0gZiAhciAodW5zYWZlX2dldCBhIGkpXG4gIGRvbmU7XG4gICFyXG5cbmxldCBmb2xkX3JpZ2h0IGYgYSB4ID1cbiAgbGV0IHIgPSByZWYgeCBpblxuICBmb3IgaSA9IGxlbmd0aCBhIC0gMSBkb3dudG8gMCBkb1xuICAgIHIgOj0gZiAodW5zYWZlX2dldCBhIGkpICFyXG4gIGRvbmU7XG4gICFyXG5cbmxldCBleGlzdHMgcCBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBhIGkpIHRoZW4gdHJ1ZVxuICAgIGVsc2UgbG9vcCAoc3VjYyBpKSBpblxuICBsb29wIDBcblxubGV0IGZvcl9hbGwgcCBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiB0cnVlXG4gICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IGEgaSkgdGhlbiBsb29wIChzdWNjIGkpXG4gICAgZWxzZSBmYWxzZSBpblxuICBsb29wIDBcblxubGV0IG1lbSB4IGEgPVxuICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgZWxzZSBpZiBjb21wYXJlICh1bnNhZmVfZ2V0IGEgaSkgeCA9IDAgdGhlbiB0cnVlXG4gICAgZWxzZSBsb29wIChzdWNjIGkpIGluXG4gIGxvb3AgMFxuXG5sZXQgbWVtcSB4IGEgPVxuICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgZWxzZSBpZiB4ID09ICh1bnNhZmVfZ2V0IGEgaSkgdGhlbiB0cnVlXG4gICAgZWxzZSBsb29wIChzdWNjIGkpIGluXG4gIGxvb3AgMFxuXG5leGNlcHRpb24gQm90dG9tIG9mIGludFxubGV0IHNvcnQgY21wIGEgPVxuICBsZXQgbWF4c29uIGwgaSA9XG4gICAgbGV0IGkzMSA9IGkraStpKzEgaW5cbiAgICBsZXQgeCA9IHJlZiBpMzEgaW5cbiAgICBpZiBpMzErMiA8IGwgdGhlbiBiZWdpblxuICAgICAgaWYgY21wIChnZXQgYSBpMzEpIChnZXQgYSAoaTMxKzEpKSA8IDAgdGhlbiB4IDo9IGkzMSsxO1xuICAgICAgaWYgY21wIChnZXQgYSAheCkgKGdldCBhIChpMzErMikpIDwgMCB0aGVuIHggOj0gaTMxKzI7XG4gICAgICAheFxuICAgIGVuZCBlbHNlXG4gICAgICBpZiBpMzErMSA8IGwgJiYgY21wIChnZXQgYSBpMzEpIChnZXQgYSAoaTMxKzEpKSA8IDBcbiAgICAgIHRoZW4gaTMxKzFcbiAgICAgIGVsc2UgaWYgaTMxIDwgbCB0aGVuIGkzMSBlbHNlIHJhaXNlIChCb3R0b20gaSlcbiAgaW5cbiAgbGV0IHJlYyB0cmlja2xlZG93biBsIGkgZSA9XG4gICAgbGV0IGogPSBtYXhzb24gbCBpIGluXG4gICAgaWYgY21wIChnZXQgYSBqKSBlID4gMCB0aGVuIGJlZ2luXG4gICAgICBzZXQgYSBpIChnZXQgYSBqKTtcbiAgICAgIHRyaWNrbGVkb3duIGwgaiBlO1xuICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICBzZXQgYSBpIGU7XG4gICAgZW5kO1xuICBpblxuICBsZXQgdHJpY2tsZSBsIGkgZSA9IHRyeSB0cmlja2xlZG93biBsIGkgZSB3aXRoIEJvdHRvbSBpIC0+IHNldCBhIGkgZSBpblxuICBsZXQgcmVjIGJ1YmJsZWRvd24gbCBpID1cbiAgICBsZXQgaiA9IG1heHNvbiBsIGkgaW5cbiAgICBzZXQgYSBpIChnZXQgYSBqKTtcbiAgICBidWJibGVkb3duIGwgalxuICBpblxuICBsZXQgYnViYmxlIGwgaSA9IHRyeSBidWJibGVkb3duIGwgaSB3aXRoIEJvdHRvbSBpIC0+IGkgaW5cbiAgbGV0IHJlYyB0cmlja2xldXAgaSBlID1cbiAgICBsZXQgZmF0aGVyID0gKGkgLSAxKSAvIDMgaW5cbiAgICBhc3NlcnQgKGkgPD4gZmF0aGVyKTtcbiAgICBpZiBjbXAgKGdldCBhIGZhdGhlcikgZSA8IDAgdGhlbiBiZWdpblxuICAgICAgc2V0IGEgaSAoZ2V0IGEgZmF0aGVyKTtcbiAgICAgIGlmIGZhdGhlciA+IDAgdGhlbiB0cmlja2xldXAgZmF0aGVyIGUgZWxzZSBzZXQgYSAwIGU7XG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgIHNldCBhIGkgZTtcbiAgICBlbmQ7XG4gIGluXG4gIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgZm9yIGkgPSAobCArIDEpIC8gMyAtIDEgZG93bnRvIDAgZG8gdHJpY2tsZSBsIGkgKGdldCBhIGkpOyBkb25lO1xuICBmb3IgaSA9IGwgLSAxIGRvd250byAyIGRvXG4gICAgbGV0IGUgPSAoZ2V0IGEgaSkgaW5cbiAgICBzZXQgYSBpIChnZXQgYSAwKTtcbiAgICB0cmlja2xldXAgKGJ1YmJsZSBpIDApIGU7XG4gIGRvbmU7XG4gIGlmIGwgPiAxIHRoZW4gKGxldCBlID0gKGdldCBhIDEpIGluIHNldCBhIDEgKGdldCBhIDApOyBzZXQgYSAwIGUpXG5cblxubGV0IGN1dG9mZiA9IDVcbmxldCBzdGFibGVfc29ydCBjbXAgYSA9XG4gIGxldCBtZXJnZSBzcmMxb2ZzIHNyYzFsZW4gc3JjMiBzcmMyb2ZzIHNyYzJsZW4gZHN0IGRzdG9mcyA9XG4gICAgbGV0IHNyYzFyID0gc3JjMW9mcyArIHNyYzFsZW4gYW5kIHNyYzJyID0gc3JjMm9mcyArIHNyYzJsZW4gaW5cbiAgICBsZXQgcmVjIGxvb3AgaTEgczEgaTIgczIgZCA9XG4gICAgICBpZiBjbXAgczEgczIgPD0gMCB0aGVuIGJlZ2luXG4gICAgICAgIHNldCBkc3QgZCBzMTtcbiAgICAgICAgbGV0IGkxID0gaTEgKyAxIGluXG4gICAgICAgIGlmIGkxIDwgc3JjMXIgdGhlblxuICAgICAgICAgIGxvb3AgaTEgKGdldCBhIGkxKSBpMiBzMiAoZCArIDEpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBibGl0IHNyYzIgaTIgZHN0IChkICsgMSkgKHNyYzJyIC0gaTIpXG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBzZXQgZHN0IGQgczI7XG4gICAgICAgIGxldCBpMiA9IGkyICsgMSBpblxuICAgICAgICBpZiBpMiA8IHNyYzJyIHRoZW5cbiAgICAgICAgICBsb29wIGkxIHMxIGkyIChnZXQgc3JjMiBpMikgKGQgKyAxKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgYmxpdCBhIGkxIGRzdCAoZCArIDEpIChzcmMxciAtIGkxKVxuICAgICAgZW5kXG4gICAgaW4gbG9vcCBzcmMxb2ZzIChnZXQgYSBzcmMxb2ZzKSBzcmMyb2ZzIChnZXQgc3JjMiBzcmMyb2ZzKSBkc3RvZnM7XG4gIGluXG4gIGxldCBpc29ydHRvIHNyY29mcyBkc3QgZHN0b2ZzIGxlbiA9XG4gICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgIGxldCBlID0gKGdldCBhIChzcmNvZnMgKyBpKSkgaW5cbiAgICAgIGxldCBqID0gcmVmIChkc3RvZnMgKyBpIC0gMSkgaW5cbiAgICAgIHdoaWxlICghaiA+PSBkc3RvZnMgJiYgY21wIChnZXQgZHN0ICFqKSBlID4gMCkgZG9cbiAgICAgICAgc2V0IGRzdCAoIWogKyAxKSAoZ2V0IGRzdCAhaik7XG4gICAgICAgIGRlY3IgajtcbiAgICAgIGRvbmU7XG4gICAgICBzZXQgZHN0ICghaiArIDEpIGU7XG4gICAgZG9uZTtcbiAgaW5cbiAgbGV0IHJlYyBzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuID1cbiAgICBpZiBsZW4gPD0gY3V0b2ZmIHRoZW4gaXNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gZWxzZSBiZWdpblxuICAgICAgbGV0IGwxID0gbGVuIC8gMiBpblxuICAgICAgbGV0IGwyID0gbGVuIC0gbDEgaW5cbiAgICAgIHNvcnR0byAoc3Jjb2ZzICsgbDEpIGRzdCAoZHN0b2ZzICsgbDEpIGwyO1xuICAgICAgc29ydHRvIHNyY29mcyBhIChzcmNvZnMgKyBsMikgbDE7XG4gICAgICBtZXJnZSAoc3Jjb2ZzICsgbDIpIGwxIGRzdCAoZHN0b2ZzICsgbDEpIGwyIGRzdCBkc3RvZnM7XG4gICAgZW5kO1xuICBpblxuICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gIGlmIGwgPD0gY3V0b2ZmIHRoZW4gaXNvcnR0byAwIGEgMCBsIGVsc2UgYmVnaW5cbiAgICBsZXQgbDEgPSBsIC8gMiBpblxuICAgIGxldCBsMiA9IGwgLSBsMSBpblxuICAgIGxldCB0ID0gbWFrZSBsMiAoZ2V0IGEgMCkgaW5cbiAgICBzb3J0dG8gbDEgdCAwIGwyO1xuICAgIHNvcnR0byAwIGEgbDIgbDE7XG4gICAgbWVyZ2UgbDIgbDEgdCAwIGwyIGEgMDtcbiAgZW5kXG5cblxubGV0IGZhc3Rfc29ydCA9IHN0YWJsZV9zb3J0XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbSW50MzJdOiAzMi1iaXQgaW50ZWdlcnMgKilcblxuZXh0ZXJuYWwgbmVnIDogaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9uZWdcIlxuZXh0ZXJuYWwgYWRkIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9hZGRcIlxuZXh0ZXJuYWwgc3ViIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9zdWJcIlxuZXh0ZXJuYWwgbXVsIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9tdWxcIlxuZXh0ZXJuYWwgZGl2IDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9kaXZcIlxuZXh0ZXJuYWwgcmVtIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9tb2RcIlxuZXh0ZXJuYWwgbG9nYW5kIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9hbmRcIlxuZXh0ZXJuYWwgbG9nb3IgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX29yXCJcbmV4dGVybmFsIGxvZ3hvciA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfeG9yXCJcbmV4dGVybmFsIHNoaWZ0X2xlZnQgOiBpbnQzMiAtPiBpbnQgLT4gaW50MzIgPSBcIiVpbnQzMl9sc2xcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHQgOiBpbnQzMiAtPiBpbnQgLT4gaW50MzIgPSBcIiVpbnQzMl9hc3JcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHRfbG9naWNhbCA6IGludDMyIC0+IGludCAtPiBpbnQzMiA9IFwiJWludDMyX2xzclwiXG5leHRlcm5hbCBvZl9pbnQgOiBpbnQgLT4gaW50MzIgPSBcIiVpbnQzMl9vZl9pbnRcIlxuZXh0ZXJuYWwgdG9faW50IDogaW50MzIgLT4gaW50ID0gXCIlaW50MzJfdG9faW50XCJcbmV4dGVybmFsIG9mX2Zsb2F0IDogZmxvYXQgLT4gaW50MzJcbiAgPSBcImNhbWxfaW50MzJfb2ZfZmxvYXRcIiBcImNhbWxfaW50MzJfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0b19mbG9hdCA6IGludDMyIC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDMyX3RvX2Zsb2F0XCIgXCJjYW1sX2ludDMyX3RvX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYml0c19vZl9mbG9hdCA6IGZsb2F0IC0+IGludDMyXG4gID0gXCJjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXRcIiBcImNhbWxfaW50MzJfYml0c19vZl9mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZsb2F0X29mX2JpdHMgOiBpbnQzMiAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzXCIgXCJjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHNfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbmxldCB6ZXJvID0gMGxcbmxldCBvbmUgPSAxbFxubGV0IG1pbnVzX29uZSA9IC0xbFxubGV0IHN1Y2MgbiA9IGFkZCBuIDFsXG5sZXQgcHJlZCBuID0gc3ViIG4gMWxcbmxldCBhYnMgbiA9IGlmIG4gPj0gMGwgdGhlbiBuIGVsc2UgbmVnIG5cbmxldCBtaW5faW50ID0gMHg4MDAwMDAwMGxcbmxldCBtYXhfaW50ID0gMHg3RkZGRkZGRmxcbmxldCBsb2dub3QgbiA9IGxvZ3hvciBuICgtMWwpXG5cbmV4dGVybmFsIGZvcm1hdCA6IHN0cmluZyAtPiBpbnQzMiAtPiBzdHJpbmcgPSBcImNhbWxfaW50MzJfZm9ybWF0XCJcbmxldCB0b19zdHJpbmcgbiA9IGZvcm1hdCBcIiVkXCIgblxuXG5leHRlcm5hbCBvZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50MzIgPSBcImNhbWxfaW50MzJfb2Zfc3RyaW5nXCJcblxubGV0IG9mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IGV4cG9zZSBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZSBkaXJlY3RseS4gKilcbiAgdHJ5IFNvbWUgKG9mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbnR5cGUgdCA9IGludDMyXG5cbmxldCBjb21wYXJlICh4OiB0KSAoeTogdCkgPSBQZXJ2YXNpdmVzLmNvbXBhcmUgeCB5XG5sZXQgZXF1YWwgKHg6IHQpICh5OiB0KSA9IGNvbXBhcmUgeCB5ID0gMFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBUaGUgcGFyc2luZyBlbmdpbmUgKilcblxub3BlbiBMZXhpbmdcblxuKCogSW50ZXJuYWwgaW50ZXJmYWNlIHRvIHRoZSBwYXJzaW5nIGVuZ2luZSAqKVxuXG50eXBlIHBhcnNlcl9lbnYgPVxuICB7IG11dGFibGUgc19zdGFjayA6IGludCBhcnJheTsgICAgICAgICgqIFN0YXRlcyAqKVxuICAgIG11dGFibGUgdl9zdGFjayA6IE9iai50IGFycmF5OyAgICAgICgqIFNlbWFudGljIGF0dHJpYnV0ZXMgKilcbiAgICBtdXRhYmxlIHN5bWJfc3RhcnRfc3RhY2sgOiBwb3NpdGlvbiBhcnJheTsgKCogU3RhcnQgcG9zaXRpb25zICopXG4gICAgbXV0YWJsZSBzeW1iX2VuZF9zdGFjayA6IHBvc2l0aW9uIGFycmF5OyAgICgqIEVuZCBwb3NpdGlvbnMgKilcbiAgICBtdXRhYmxlIHN0YWNrc2l6ZSA6IGludDsgICAgICAgICAgICAoKiBTaXplIG9mIHRoZSBzdGFja3MgKilcbiAgICBtdXRhYmxlIHN0YWNrYmFzZSA6IGludDsgICAgICAgICAgICAoKiBCYXNlIHNwIGZvciBjdXJyZW50IHBhcnNlICopXG4gICAgbXV0YWJsZSBjdXJyX2NoYXIgOiBpbnQ7ICAgICAgICAgICAgKCogTGFzdCB0b2tlbiByZWFkICopXG4gICAgbXV0YWJsZSBsdmFsIDogT2JqLnQ7ICAgICAgICAgICAgICAgKCogSXRzIHNlbWFudGljIGF0dHJpYnV0ZSAqKVxuICAgIG11dGFibGUgc3ltYl9zdGFydCA6IHBvc2l0aW9uOyAgICAgICgqIFN0YXJ0IHBvcy4gb2YgdGhlIGN1cnJlbnQgc3ltYm9sKilcbiAgICBtdXRhYmxlIHN5bWJfZW5kIDogcG9zaXRpb247ICAgICAgICAoKiBFbmQgcG9zLiBvZiB0aGUgY3VycmVudCBzeW1ib2wgKilcbiAgICBtdXRhYmxlIGFzcCA6IGludDsgICAgICAgICAgICAgICAgICAoKiBUaGUgc3RhY2sgcG9pbnRlciBmb3IgYXR0cmlidXRlcyAqKVxuICAgIG11dGFibGUgcnVsZV9sZW4gOiBpbnQ7ICAgICAgICAgICAgICgqIE51bWJlciBvZiByaHMgaXRlbXMgaW4gdGhlIHJ1bGUgKilcbiAgICBtdXRhYmxlIHJ1bGVfbnVtYmVyIDogaW50OyAgICAgICAgICAoKiBSdWxlIG51bWJlciB0byByZWR1Y2UgYnkgKilcbiAgICBtdXRhYmxlIHNwIDogaW50OyAgICAgICAgICAgICAgICAgICAoKiBTYXZlZCBzcCBmb3IgcGFyc2VfZW5naW5lICopXG4gICAgbXV0YWJsZSBzdGF0ZSA6IGludDsgICAgICAgICAgICAgICAgKCogU2F2ZWQgc3RhdGUgZm9yIHBhcnNlX2VuZ2luZSAqKVxuICAgIG11dGFibGUgZXJyZmxhZyA6IGludCB9ICAgICAgICAgICAgICgqIFNhdmVkIGVycm9yIGZsYWcgZm9yIHBhcnNlX2VuZ2luZSAqKVxuXG50eXBlIHBhcnNlX3RhYmxlcyA9XG4gIHsgYWN0aW9ucyA6IChwYXJzZXJfZW52IC0+IE9iai50KSBhcnJheTtcbiAgICB0cmFuc2xfY29uc3QgOiBpbnQgYXJyYXk7XG4gICAgdHJhbnNsX2Jsb2NrIDogaW50IGFycmF5O1xuICAgIGxocyA6IHN0cmluZztcbiAgICBsZW4gOiBzdHJpbmc7XG4gICAgZGVmcmVkIDogc3RyaW5nO1xuICAgIGRnb3RvIDogc3RyaW5nO1xuICAgIHNpbmRleCA6IHN0cmluZztcbiAgICByaW5kZXggOiBzdHJpbmc7XG4gICAgZ2luZGV4IDogc3RyaW5nO1xuICAgIHRhYmxlc2l6ZSA6IGludDtcbiAgICB0YWJsZSA6IHN0cmluZztcbiAgICBjaGVjayA6IHN0cmluZztcbiAgICBlcnJvcl9mdW5jdGlvbiA6IHN0cmluZyAtPiB1bml0O1xuICAgIG5hbWVzX2NvbnN0IDogc3RyaW5nO1xuICAgIG5hbWVzX2Jsb2NrIDogc3RyaW5nIH1cblxuZXhjZXB0aW9uIFlZZXhpdCBvZiBPYmoudFxuZXhjZXB0aW9uIFBhcnNlX2Vycm9yXG5cbnR5cGUgcGFyc2VyX2lucHV0ID1cbiAgICBTdGFydFxuICB8IFRva2VuX3JlYWRcbiAgfCBTdGFja3NfZ3Jvd25fMVxuICB8IFN0YWNrc19ncm93bl8yXG4gIHwgU2VtYW50aWNfYWN0aW9uX2NvbXB1dGVkXG4gIHwgRXJyb3JfZGV0ZWN0ZWRcblxudHlwZSBwYXJzZXJfb3V0cHV0ID1cbiAgICBSZWFkX3Rva2VuXG4gIHwgUmFpc2VfcGFyc2VfZXJyb3JcbiAgfCBHcm93X3N0YWNrc18xXG4gIHwgR3Jvd19zdGFja3NfMlxuICB8IENvbXB1dGVfc2VtYW50aWNfYWN0aW9uXG4gIHwgQ2FsbF9lcnJvcl9mdW5jdGlvblxuXG4oKiB0byBhdm9pZCB3YXJuaW5ncyAqKVxubGV0IF8gPSBbUmVhZF90b2tlbjsgUmFpc2VfcGFyc2VfZXJyb3I7IEdyb3dfc3RhY2tzXzE7IEdyb3dfc3RhY2tzXzI7XG4gICAgICAgICBDb21wdXRlX3NlbWFudGljX2FjdGlvbjsgQ2FsbF9lcnJvcl9mdW5jdGlvbl1cblxuZXh0ZXJuYWwgcGFyc2VfZW5naW5lIDpcbiAgICBwYXJzZV90YWJsZXMgLT4gcGFyc2VyX2VudiAtPiBwYXJzZXJfaW5wdXQgLT4gT2JqLnQgLT4gcGFyc2VyX291dHB1dFxuICAgID0gXCJjYW1sX3BhcnNlX2VuZ2luZVwiXG5cbmV4dGVybmFsIHNldF90cmFjZTogYm9vbCAtPiBib29sXG4gICAgPSBcImNhbWxfc2V0X3BhcnNlcl90cmFjZVwiXG5cbmxldCBlbnYgPVxuICB7IHNfc3RhY2sgPSBBcnJheS5tYWtlIDEwMCAwO1xuICAgIHZfc3RhY2sgPSBBcnJheS5tYWtlIDEwMCAoT2JqLnJlcHIgKCkpO1xuICAgIHN5bWJfc3RhcnRfc3RhY2sgPSBBcnJheS5tYWtlIDEwMCBkdW1teV9wb3M7XG4gICAgc3ltYl9lbmRfc3RhY2sgPSBBcnJheS5tYWtlIDEwMCBkdW1teV9wb3M7XG4gICAgc3RhY2tzaXplID0gMTAwO1xuICAgIHN0YWNrYmFzZSA9IDA7XG4gICAgY3Vycl9jaGFyID0gMDtcbiAgICBsdmFsID0gT2JqLnJlcHIgKCk7XG4gICAgc3ltYl9zdGFydCA9IGR1bW15X3BvcztcbiAgICBzeW1iX2VuZCA9IGR1bW15X3BvcztcbiAgICBhc3AgPSAwO1xuICAgIHJ1bGVfbGVuID0gMDtcbiAgICBydWxlX251bWJlciA9IDA7XG4gICAgc3AgPSAwO1xuICAgIHN0YXRlID0gMDtcbiAgICBlcnJmbGFnID0gMCB9XG5cbmxldCBncm93X3N0YWNrcygpID1cbiAgbGV0IG9sZHNpemUgPSBlbnYuc3RhY2tzaXplIGluXG4gIGxldCBuZXdzaXplID0gb2xkc2l6ZSAqIDIgaW5cbiAgbGV0IG5ld19zID0gQXJyYXkubWFrZSBuZXdzaXplIDBcbiAgYW5kIG5ld192ID0gQXJyYXkubWFrZSBuZXdzaXplIChPYmoucmVwciAoKSlcbiAgYW5kIG5ld19zdGFydCA9IEFycmF5Lm1ha2UgbmV3c2l6ZSBkdW1teV9wb3NcbiAgYW5kIG5ld19lbmQgPSBBcnJheS5tYWtlIG5ld3NpemUgZHVtbXlfcG9zIGluXG4gICAgQXJyYXkuYmxpdCBlbnYuc19zdGFjayAwIG5ld19zIDAgb2xkc2l6ZTtcbiAgICBlbnYuc19zdGFjayA8LSBuZXdfcztcbiAgICBBcnJheS5ibGl0IGVudi52X3N0YWNrIDAgbmV3X3YgMCBvbGRzaXplO1xuICAgIGVudi52X3N0YWNrIDwtIG5ld192O1xuICAgIEFycmF5LmJsaXQgZW52LnN5bWJfc3RhcnRfc3RhY2sgMCBuZXdfc3RhcnQgMCBvbGRzaXplO1xuICAgIGVudi5zeW1iX3N0YXJ0X3N0YWNrIDwtIG5ld19zdGFydDtcbiAgICBBcnJheS5ibGl0IGVudi5zeW1iX2VuZF9zdGFjayAwIG5ld19lbmQgMCBvbGRzaXplO1xuICAgIGVudi5zeW1iX2VuZF9zdGFjayA8LSBuZXdfZW5kO1xuICAgIGVudi5zdGFja3NpemUgPC0gbmV3c2l6ZVxuXG5sZXQgY2xlYXJfcGFyc2VyKCkgPVxuICBBcnJheS5maWxsIGVudi52X3N0YWNrIDAgZW52LnN0YWNrc2l6ZSAoT2JqLnJlcHIgKCkpO1xuICBlbnYubHZhbCA8LSBPYmoucmVwciAoKVxuXG5sZXQgY3VycmVudF9sb29rYWhlYWRfZnVuID0gcmVmIChmdW4gKF8gOiBPYmoudCkgLT4gZmFsc2UpXG5cbmxldCB5eXBhcnNlIHRhYmxlcyBzdGFydCBsZXhlciBsZXhidWYgPVxuICBsZXQgcmVjIGxvb3AgY21kIGFyZyA9XG4gICAgbWF0Y2ggcGFyc2VfZW5naW5lIHRhYmxlcyBlbnYgY21kIGFyZyB3aXRoXG4gICAgICBSZWFkX3Rva2VuIC0+XG4gICAgICAgIGxldCB0ID0gT2JqLnJlcHIobGV4ZXIgbGV4YnVmKSBpblxuICAgICAgICBlbnYuc3ltYl9zdGFydCA8LSBsZXhidWYubGV4X3N0YXJ0X3A7XG4gICAgICAgIGVudi5zeW1iX2VuZCA8LSBsZXhidWYubGV4X2N1cnJfcDtcbiAgICAgICAgbG9vcCBUb2tlbl9yZWFkIHRcbiAgICB8IFJhaXNlX3BhcnNlX2Vycm9yIC0+XG4gICAgICAgIHJhaXNlIFBhcnNlX2Vycm9yXG4gICAgfCBDb21wdXRlX3NlbWFudGljX2FjdGlvbiAtPlxuICAgICAgICBsZXQgKGFjdGlvbiwgdmFsdWUpID1cbiAgICAgICAgICB0cnlcbiAgICAgICAgICAgIChTZW1hbnRpY19hY3Rpb25fY29tcHV0ZWQsIHRhYmxlcy5hY3Rpb25zLihlbnYucnVsZV9udW1iZXIpIGVudilcbiAgICAgICAgICB3aXRoIFBhcnNlX2Vycm9yIC0+XG4gICAgICAgICAgICAoRXJyb3JfZGV0ZWN0ZWQsIE9iai5yZXByICgpKSBpblxuICAgICAgICBsb29wIGFjdGlvbiB2YWx1ZVxuICAgIHwgR3Jvd19zdGFja3NfMSAtPlxuICAgICAgICBncm93X3N0YWNrcygpOyBsb29wIFN0YWNrc19ncm93bl8xIChPYmoucmVwciAoKSlcbiAgICB8IEdyb3dfc3RhY2tzXzIgLT5cbiAgICAgICAgZ3Jvd19zdGFja3MoKTsgbG9vcCBTdGFja3NfZ3Jvd25fMiAoT2JqLnJlcHIgKCkpXG4gICAgfCBDYWxsX2Vycm9yX2Z1bmN0aW9uIC0+XG4gICAgICAgIHRhYmxlcy5lcnJvcl9mdW5jdGlvbiBcInN5bnRheCBlcnJvclwiO1xuICAgICAgICBsb29wIEVycm9yX2RldGVjdGVkIChPYmoucmVwciAoKSkgaW5cbiAgbGV0IGluaXRfYXNwID0gZW52LmFzcFxuICBhbmQgaW5pdF9zcCA9IGVudi5zcFxuICBhbmQgaW5pdF9zdGFja2Jhc2UgPSBlbnYuc3RhY2tiYXNlXG4gIGFuZCBpbml0X3N0YXRlID0gZW52LnN0YXRlXG4gIGFuZCBpbml0X2N1cnJfY2hhciA9IGVudi5jdXJyX2NoYXJcbiAgYW5kIGluaXRfbHZhbCA9IGVudi5sdmFsXG4gIGFuZCBpbml0X2VycmZsYWcgPSBlbnYuZXJyZmxhZyBpblxuICBlbnYuc3RhY2tiYXNlIDwtIGVudi5zcCArIDE7XG4gIGVudi5jdXJyX2NoYXIgPC0gc3RhcnQ7XG4gIGVudi5zeW1iX2VuZCA8LSBsZXhidWYubGV4X2N1cnJfcDtcbiAgdHJ5XG4gICAgbG9vcCBTdGFydCAoT2JqLnJlcHIgKCkpXG4gIHdpdGggZXhuIC0+XG4gICAgbGV0IGN1cnJfY2hhciA9IGVudi5jdXJyX2NoYXIgaW5cbiAgICBlbnYuYXNwIDwtIGluaXRfYXNwO1xuICAgIGVudi5zcCA8LSBpbml0X3NwO1xuICAgIGVudi5zdGFja2Jhc2UgPC0gaW5pdF9zdGFja2Jhc2U7XG4gICAgZW52LnN0YXRlIDwtIGluaXRfc3RhdGU7XG4gICAgZW52LmN1cnJfY2hhciA8LSBpbml0X2N1cnJfY2hhcjtcbiAgICBlbnYubHZhbCA8LSBpbml0X2x2YWw7XG4gICAgZW52LmVycmZsYWcgPC0gaW5pdF9lcnJmbGFnO1xuICAgIG1hdGNoIGV4biB3aXRoXG4gICAgICBZWWV4aXQgdiAtPlxuICAgICAgICBPYmoubWFnaWMgdlxuICAgIHwgXyAtPlxuICAgICAgICBjdXJyZW50X2xvb2thaGVhZF9mdW4gOj1cbiAgICAgICAgICAoZnVuIHRvayAtPlxuICAgICAgICAgICAgaWYgT2JqLmlzX2Jsb2NrIHRva1xuICAgICAgICAgICAgdGhlbiB0YWJsZXMudHJhbnNsX2Jsb2NrLihPYmoudGFnIHRvaykgPSBjdXJyX2NoYXJcbiAgICAgICAgICAgIGVsc2UgdGFibGVzLnRyYW5zbF9jb25zdC4oT2JqLm1hZ2ljIHRvaykgPSBjdXJyX2NoYXIpO1xuICAgICAgICByYWlzZSBleG5cblxubGV0IHBlZWtfdmFsIGVudiBuID1cbiAgT2JqLm1hZ2ljIGVudi52X3N0YWNrLihlbnYuYXNwIC0gbilcblxubGV0IHN5bWJvbF9zdGFydF9wb3MgKCkgPVxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA8PSAwIHRoZW4gZW52LnN5bWJfZW5kX3N0YWNrLihlbnYuYXNwKVxuICAgIGVsc2UgYmVnaW5cbiAgICAgIGxldCBzdCA9IGVudi5zeW1iX3N0YXJ0X3N0YWNrLihlbnYuYXNwIC0gaSArIDEpIGluXG4gICAgICBsZXQgZW4gPSBlbnYuc3ltYl9lbmRfc3RhY2suKGVudi5hc3AgLSBpICsgMSkgaW5cbiAgICAgIGlmIHN0IDw+IGVuIHRoZW4gc3QgZWxzZSBsb29wIChpIC0gMSlcbiAgICBlbmRcbiAgaW5cbiAgbG9vcCBlbnYucnVsZV9sZW5cblxubGV0IHN5bWJvbF9lbmRfcG9zICgpID0gZW52LnN5bWJfZW5kX3N0YWNrLihlbnYuYXNwKVxubGV0IHJoc19zdGFydF9wb3MgbiA9IGVudi5zeW1iX3N0YXJ0X3N0YWNrLihlbnYuYXNwIC0gKGVudi5ydWxlX2xlbiAtIG4pKVxubGV0IHJoc19lbmRfcG9zIG4gPSBlbnYuc3ltYl9lbmRfc3RhY2suKGVudi5hc3AgLSAoZW52LnJ1bGVfbGVuIC0gbikpXG5cbmxldCBzeW1ib2xfc3RhcnQgKCkgPSAoc3ltYm9sX3N0YXJ0X3BvcyAoKSkucG9zX2NudW1cbmxldCBzeW1ib2xfZW5kICgpID0gKHN5bWJvbF9lbmRfcG9zICgpKS5wb3NfY251bVxubGV0IHJoc19zdGFydCBuID0gKHJoc19zdGFydF9wb3MgbikucG9zX2NudW1cbmxldCByaHNfZW5kIG4gPSAocmhzX2VuZF9wb3MgbikucG9zX2NudW1cblxubGV0IGlzX2N1cnJlbnRfbG9va2FoZWFkIHRvayA9XG4gICghY3VycmVudF9sb29rYWhlYWRfZnVuKShPYmoucmVwciB0b2spXG5cbmxldCBwYXJzZV9lcnJvciAoXyA6IHN0cmluZykgPSAoKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBTZXRzIG92ZXIgb3JkZXJlZCB0eXBlcyAqKVxuXG5tb2R1bGUgdHlwZSBPcmRlcmVkVHlwZSA9XG4gIHNpZ1xuICAgIHR5cGUgdFxuICAgIHZhbCBjb21wYXJlOiB0IC0+IHQgLT4gaW50XG4gIGVuZFxuXG5tb2R1bGUgdHlwZSBTID1cbiAgc2lnXG4gICAgdHlwZSBlbHRcbiAgICB0eXBlIHRcbiAgICB2YWwgZW1wdHk6IHRcbiAgICB2YWwgaXNfZW1wdHk6IHQgLT4gYm9vbFxuICAgIHZhbCBtZW06IGVsdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgYWRkOiBlbHQgLT4gdCAtPiB0XG4gICAgdmFsIHNpbmdsZXRvbjogZWx0IC0+IHRcbiAgICB2YWwgcmVtb3ZlOiBlbHQgLT4gdCAtPiB0XG4gICAgdmFsIHVuaW9uOiB0IC0+IHQgLT4gdFxuICAgIHZhbCBpbnRlcjogdCAtPiB0IC0+IHRcbiAgICB2YWwgZGlmZjogdCAtPiB0IC0+IHRcbiAgICB2YWwgY29tcGFyZTogdCAtPiB0IC0+IGludFxuICAgIHZhbCBlcXVhbDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgc3Vic2V0OiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBpdGVyOiAoZWx0IC0+IHVuaXQpIC0+IHQgLT4gdW5pdFxuICAgIHZhbCBtYXA6IChlbHQgLT4gZWx0KSAtPiB0IC0+IHRcbiAgICB2YWwgZm9sZDogKGVsdCAtPiAnYSAtPiAnYSkgLT4gdCAtPiAnYSAtPiAnYVxuICAgIHZhbCBmb3JfYWxsOiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gYm9vbFxuICAgIHZhbCBleGlzdHM6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBib29sXG4gICAgdmFsIGZpbHRlcjogKGVsdCAtPiBib29sKSAtPiB0IC0+IHRcbiAgICB2YWwgcGFydGl0aW9uOiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gdCAqIHRcbiAgICB2YWwgY2FyZGluYWw6IHQgLT4gaW50XG4gICAgdmFsIGVsZW1lbnRzOiB0IC0+IGVsdCBsaXN0XG4gICAgdmFsIG1pbl9lbHQ6IHQgLT4gZWx0XG4gICAgdmFsIG1pbl9lbHRfb3B0OiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgbWF4X2VsdDogdCAtPiBlbHRcbiAgICB2YWwgbWF4X2VsdF9vcHQ6IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBjaG9vc2U6IHQgLT4gZWx0XG4gICAgdmFsIGNob29zZV9vcHQ6IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBzcGxpdDogZWx0IC0+IHQgLT4gdCAqIGJvb2wgKiB0XG4gICAgdmFsIGZpbmQ6IGVsdCAtPiB0IC0+IGVsdFxuICAgIHZhbCBmaW5kX29wdDogZWx0IC0+IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBmaW5kX2ZpcnN0OiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gZWx0XG4gICAgdmFsIGZpbmRfZmlyc3Rfb3B0OiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBmaW5kX2xhc3Q6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBlbHRcbiAgICB2YWwgZmluZF9sYXN0X29wdDogKGVsdCAtPiBib29sKSAtPiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgb2ZfbGlzdDogZWx0IGxpc3QgLT4gdFxuICBlbmRcblxubW9kdWxlIE1ha2UoT3JkOiBPcmRlcmVkVHlwZSkgPVxuICBzdHJ1Y3RcbiAgICB0eXBlIGVsdCA9IE9yZC50XG4gICAgdHlwZSB0ID0gRW1wdHkgfCBOb2RlIG9mIHtsOnQ7IHY6ZWx0OyByOnQ7IGg6aW50fVxuXG4gICAgKCogU2V0cyBhcmUgcmVwcmVzZW50ZWQgYnkgYmFsYW5jZWQgYmluYXJ5IHRyZWVzICh0aGUgaGVpZ2h0cyBvZiB0aGVcbiAgICAgICBjaGlsZHJlbiBkaWZmZXIgYnkgYXQgbW9zdCAyICopXG5cbiAgICBsZXQgaGVpZ2h0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gMFxuICAgICAgfCBOb2RlIHtofSAtPiBoXG5cbiAgICAoKiBDcmVhdGVzIGEgbmV3IG5vZGUgd2l0aCBsZWZ0IHNvbiBsLCB2YWx1ZSB2IGFuZCByaWdodCBzb24gci5cbiAgICAgICBXZSBtdXN0IGhhdmUgYWxsIGVsZW1lbnRzIG9mIGwgPCB2IDwgYWxsIGVsZW1lbnRzIG9mIHIuXG4gICAgICAgbCBhbmQgciBtdXN0IGJlIGJhbGFuY2VkIGFuZCB8IGhlaWdodCBsIC0gaGVpZ2h0IHIgfCA8PSAyLlxuICAgICAgIElubGluZSBleHBhbnNpb24gb2YgaGVpZ2h0IGZvciBiZXR0ZXIgc3BlZWQuICopXG5cbiAgICBsZXQgY3JlYXRlIGwgdiByID1cbiAgICAgIGxldCBobCA9IG1hdGNoIGwgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgbGV0IGhyID0gbWF0Y2ggciB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBOb2Rle2w7IHY7IHI7IGg9KGlmIGhsID49IGhyIHRoZW4gaGwgKyAxIGVsc2UgaHIgKyAxKX1cblxuICAgICgqIFNhbWUgYXMgY3JlYXRlLCBidXQgcGVyZm9ybXMgb25lIHN0ZXAgb2YgcmViYWxhbmNpbmcgaWYgbmVjZXNzYXJ5LlxuICAgICAgIEFzc3VtZXMgbCBhbmQgciBiYWxhbmNlZCBhbmQgfCBoZWlnaHQgbCAtIGhlaWdodCByIHwgPD0gMy5cbiAgICAgICBJbmxpbmUgZXhwYW5zaW9uIG9mIGNyZWF0ZSBmb3IgYmV0dGVyIHNwZWVkIGluIHRoZSBtb3N0IGZyZXF1ZW50IGNhc2VcbiAgICAgICB3aGVyZSBubyByZWJhbGFuY2luZyBpcyByZXF1aXJlZC4gKilcblxuICAgIGxldCBiYWwgbCB2IHIgPVxuICAgICAgbGV0IGhsID0gbWF0Y2ggbCB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBsZXQgaHIgPSBtYXRjaCByIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIGlmIGhsID4gaHIgKyAyIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQuYmFsXCJcbiAgICAgICAgfCBOb2Rle2w9bGw7IHY9bHY7IHI9bHJ9IC0+XG4gICAgICAgICAgICBpZiBoZWlnaHQgbGwgPj0gaGVpZ2h0IGxyIHRoZW5cbiAgICAgICAgICAgICAgY3JlYXRlIGxsIGx2IChjcmVhdGUgbHIgdiByKVxuICAgICAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBtYXRjaCBsciB3aXRoXG4gICAgICAgICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQuYmFsXCJcbiAgICAgICAgICAgICAgfCBOb2Rle2w9bHJsOyB2PWxydjsgcj1scnJ9LT5cbiAgICAgICAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGxsIGx2IGxybCkgbHJ2IChjcmVhdGUgbHJyIHYgcilcbiAgICAgICAgICAgIGVuZFxuICAgICAgZW5kIGVsc2UgaWYgaHIgPiBobCArIDIgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCByIHdpdGhcbiAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIlNldC5iYWxcIlxuICAgICAgICB8IE5vZGV7bD1ybDsgdj1ydjsgcj1ycn0gLT5cbiAgICAgICAgICAgIGlmIGhlaWdodCByciA+PSBoZWlnaHQgcmwgdGhlblxuICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHYgcmwpIHJ2IHJyXG4gICAgICAgICAgICBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIG1hdGNoIHJsIHdpdGhcbiAgICAgICAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIlNldC5iYWxcIlxuICAgICAgICAgICAgICB8IE5vZGV7bD1ybGw7IHY9cmx2OyByPXJscn0gLT5cbiAgICAgICAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGwgdiBybGwpIHJsdiAoY3JlYXRlIHJsciBydiBycilcbiAgICAgICAgICAgIGVuZFxuICAgICAgZW5kIGVsc2VcbiAgICAgICAgTm9kZXtsOyB2OyByOyBoPShpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSl9XG5cbiAgICAoKiBJbnNlcnRpb24gb2Ygb25lIGVsZW1lbnQgKilcblxuICAgIGxldCByZWMgYWRkIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb2Rle2w9RW1wdHk7IHY9eDsgcj1FbXB0eTsgaD0xfVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IGFzIHQgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gdCBlbHNlXG4gICAgICAgICAgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IGxsID0gYWRkIHggbCBpblxuICAgICAgICAgICAgaWYgbCA9PSBsbCB0aGVuIHQgZWxzZSBiYWwgbGwgdiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IHJyID0gYWRkIHggciBpblxuICAgICAgICAgICAgaWYgciA9PSByciB0aGVuIHQgZWxzZSBiYWwgbCB2IHJyXG5cbiAgICBsZXQgc2luZ2xldG9uIHggPSBOb2Rle2w9RW1wdHk7IHY9eDsgcj1FbXB0eTsgaD0xfVxuXG4gICAgKCogQmV3YXJlOiB0aG9zZSB0d28gZnVuY3Rpb25zIGFzc3VtZSB0aGF0IHRoZSBhZGRlZCB2IGlzICpzdHJpY3RseSpcbiAgICAgICBzbWFsbGVyIChvciBiaWdnZXIpIHRoYW4gYWxsIHRoZSBwcmVzZW50IGVsZW1lbnRzIGluIHRoZSB0cmVlOyBpdFxuICAgICAgIGRvZXMgbm90IHRlc3QgZm9yIGVxdWFsaXR5IHdpdGggdGhlIGN1cnJlbnQgbWluIChvciBtYXgpIGVsZW1lbnQuXG4gICAgICAgSW5kZWVkLCB0aGV5IGFyZSBvbmx5IHVzZWQgZHVyaW5nIHRoZSBcImpvaW5cIiBvcGVyYXRpb24gd2hpY2hcbiAgICAgICByZXNwZWN0cyB0aGlzIHByZWNvbmRpdGlvbi5cbiAgICAqKVxuXG4gICAgbGV0IHJlYyBhZGRfbWluX2VsZW1lbnQgeCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IHNpbmdsZXRvbiB4XG4gICAgICB8IE5vZGUge2w7IHY7IHJ9IC0+XG4gICAgICAgIGJhbCAoYWRkX21pbl9lbGVtZW50IHggbCkgdiByXG5cbiAgICBsZXQgcmVjIGFkZF9tYXhfZWxlbWVudCB4ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gc2luZ2xldG9uIHhcbiAgICAgIHwgTm9kZSB7bDsgdjsgcn0gLT5cbiAgICAgICAgYmFsIGwgdiAoYWRkX21heF9lbGVtZW50IHggcilcblxuICAgICgqIFNhbWUgYXMgY3JlYXRlIGFuZCBiYWwsIGJ1dCBubyBhc3N1bXB0aW9ucyBhcmUgbWFkZSBvbiB0aGVcbiAgICAgICByZWxhdGl2ZSBoZWlnaHRzIG9mIGwgYW5kIHIuICopXG5cbiAgICBsZXQgcmVjIGpvaW4gbCB2IHIgPVxuICAgICAgbWF0Y2ggKGwsIHIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBfKSAtPiBhZGRfbWluX2VsZW1lbnQgdiByXG4gICAgICB8IChfLCBFbXB0eSkgLT4gYWRkX21heF9lbGVtZW50IHYgbFxuICAgICAgfCAoTm9kZXtsPWxsOyB2PWx2OyByPWxyOyBoPWxofSwgTm9kZXtsPXJsOyB2PXJ2OyByPXJyOyBoPXJofSkgLT5cbiAgICAgICAgICBpZiBsaCA+IHJoICsgMiB0aGVuIGJhbCBsbCBsdiAoam9pbiBsciB2IHIpIGVsc2VcbiAgICAgICAgICBpZiByaCA+IGxoICsgMiB0aGVuIGJhbCAoam9pbiBsIHYgcmwpIHJ2IHJyIGVsc2VcbiAgICAgICAgICBjcmVhdGUgbCB2IHJcblxuICAgICgqIFNtYWxsZXN0IGFuZCBncmVhdGVzdCBlbGVtZW50IG9mIGEgc2V0ICopXG5cbiAgICBsZXQgcmVjIG1pbl9lbHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZXtsPUVtcHR5OyB2fSAtPiB2XG4gICAgICB8IE5vZGV7bH0gLT4gbWluX2VsdCBsXG5cbiAgICBsZXQgcmVjIG1pbl9lbHRfb3B0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBOb2Rle2w9RW1wdHk7IHZ9IC0+IFNvbWUgdlxuICAgICAgfCBOb2Rle2x9IC0+IG1pbl9lbHRfb3B0IGxcblxuICAgIGxldCByZWMgbWF4X2VsdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2Rle3Y7IHI9RW1wdHl9IC0+IHZcbiAgICAgIHwgTm9kZXtyfSAtPiBtYXhfZWx0IHJcblxuICAgIGxldCByZWMgbWF4X2VsdF9vcHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb25lXG4gICAgICB8IE5vZGV7djsgcj1FbXB0eX0gLT4gU29tZSB2XG4gICAgICB8IE5vZGV7cn0gLT4gbWF4X2VsdF9vcHQgclxuXG4gICAgKCogUmVtb3ZlIHRoZSBzbWFsbGVzdCBlbGVtZW50IG9mIHRoZSBnaXZlbiBzZXQgKilcblxuICAgIGxldCByZWMgcmVtb3ZlX21pbl9lbHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIlNldC5yZW1vdmVfbWluX2VsdFwiXG4gICAgICB8IE5vZGV7bD1FbXB0eTsgcn0gLT4gclxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IGJhbCAocmVtb3ZlX21pbl9lbHQgbCkgdiByXG5cbiAgICAoKiBNZXJnZSB0d28gdHJlZXMgbCBhbmQgciBpbnRvIG9uZS5cbiAgICAgICBBbGwgZWxlbWVudHMgb2YgbCBtdXN0IHByZWNlZGUgdGhlIGVsZW1lbnRzIG9mIHIuXG4gICAgICAgQXNzdW1lIHwgaGVpZ2h0IGwgLSBoZWlnaHQgciB8IDw9IDIuICopXG5cbiAgICBsZXQgbWVyZ2UgdDEgdDIgPVxuICAgICAgbWF0Y2ggKHQxLCB0Mikgd2l0aFxuICAgICAgICAoRW1wdHksIHQpIC0+IHRcbiAgICAgIHwgKHQsIEVtcHR5KSAtPiB0XG4gICAgICB8IChfLCBfKSAtPiBiYWwgdDEgKG1pbl9lbHQgdDIpIChyZW1vdmVfbWluX2VsdCB0MilcblxuICAgICgqIE1lcmdlIHR3byB0cmVlcyBsIGFuZCByIGludG8gb25lLlxuICAgICAgIEFsbCBlbGVtZW50cyBvZiBsIG11c3QgcHJlY2VkZSB0aGUgZWxlbWVudHMgb2Ygci5cbiAgICAgICBObyBhc3N1bXB0aW9uIG9uIHRoZSBoZWlnaHRzIG9mIGwgYW5kIHIuICopXG5cbiAgICBsZXQgY29uY2F0IHQxIHQyID1cbiAgICAgIG1hdGNoICh0MSwgdDIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0KSAtPiB0XG4gICAgICB8ICh0LCBFbXB0eSkgLT4gdFxuICAgICAgfCAoXywgXykgLT4gam9pbiB0MSAobWluX2VsdCB0MikgKHJlbW92ZV9taW5fZWx0IHQyKVxuXG4gICAgKCogU3BsaXR0aW5nLiAgc3BsaXQgeCBzIHJldHVybnMgYSB0cmlwbGUgKGwsIHByZXNlbnQsIHIpIHdoZXJlXG4gICAgICAgIC0gbCBpcyB0aGUgc2V0IG9mIGVsZW1lbnRzIG9mIHMgdGhhdCBhcmUgPCB4XG4gICAgICAgIC0gciBpcyB0aGUgc2V0IG9mIGVsZW1lbnRzIG9mIHMgdGhhdCBhcmUgPiB4XG4gICAgICAgIC0gcHJlc2VudCBpcyBmYWxzZSBpZiBzIGNvbnRhaW5zIG5vIGVsZW1lbnQgZXF1YWwgdG8geCxcbiAgICAgICAgICBvciB0cnVlIGlmIHMgY29udGFpbnMgYW4gZWxlbWVudCBlcXVhbCB0byB4LiAqKVxuXG4gICAgbGV0IHJlYyBzcGxpdCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICAoRW1wdHksIGZhbHNlLCBFbXB0eSlcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiAobCwgdHJ1ZSwgcilcbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCAobGwsIHByZXMsIHJsKSA9IHNwbGl0IHggbCBpbiAobGwsIHByZXMsIGpvaW4gcmwgdiByKVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCAobHIsIHByZXMsIHJyKSA9IHNwbGl0IHggciBpbiAoam9pbiBsIHYgbHIsIHByZXMsIHJyKVxuXG4gICAgKCogSW1wbGVtZW50YXRpb24gb2YgdGhlIHNldCBvcGVyYXRpb25zICopXG5cbiAgICBsZXQgZW1wdHkgPSBFbXB0eVxuXG4gICAgbGV0IGlzX2VtcHR5ID0gZnVuY3Rpb24gRW1wdHkgLT4gdHJ1ZSB8IF8gLT4gZmFsc2VcblxuICAgIGxldCByZWMgbWVtIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBmYWxzZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBjID0gMCB8fCBtZW0geCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCByZWMgcmVtb3ZlIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBFbXB0eVxuICAgICAgfCAoTm9kZXtsOyB2OyByfSBhcyB0KSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBtZXJnZSBsIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICAgIGxldCBsbCA9IHJlbW92ZSB4IGwgaW5cbiAgICAgICAgICAgICAgaWYgbCA9PSBsbCB0aGVuIHRcbiAgICAgICAgICAgICAgZWxzZSBiYWwgbGwgdiByXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCByciA9IHJlbW92ZSB4IHIgaW5cbiAgICAgICAgICAgICAgaWYgciA9PSByciB0aGVuIHRcbiAgICAgICAgICAgICAgZWxzZSBiYWwgbCB2IHJyXG5cbiAgICBsZXQgcmVjIHVuaW9uIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0MikgLT4gdDJcbiAgICAgIHwgKHQxLCBFbXB0eSkgLT4gdDFcbiAgICAgIHwgKE5vZGV7bD1sMTsgdj12MTsgcj1yMTsgaD1oMX0sIE5vZGV7bD1sMjsgdj12Mjsgcj1yMjsgaD1oMn0pIC0+XG4gICAgICAgICAgaWYgaDEgPj0gaDIgdGhlblxuICAgICAgICAgICAgaWYgaDIgPSAxIHRoZW4gYWRkIHYyIHMxIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbGV0IChsMiwgXywgcjIpID0gc3BsaXQgdjEgczIgaW5cbiAgICAgICAgICAgICAgam9pbiAodW5pb24gbDEgbDIpIHYxICh1bmlvbiByMSByMilcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGlmIGgxID0gMSB0aGVuIGFkZCB2MSBzMiBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIGxldCAobDEsIF8sIHIxKSA9IHNwbGl0IHYyIHMxIGluXG4gICAgICAgICAgICAgIGpvaW4gKHVuaW9uIGwxIGwyKSB2MiAodW5pb24gcjEgcjIpXG4gICAgICAgICAgICBlbmRcblxuICAgIGxldCByZWMgaW50ZXIgczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgICAoRW1wdHksIF8pIC0+IEVtcHR5XG4gICAgICB8IChfLCBFbXB0eSkgLT4gRW1wdHlcbiAgICAgIHwgKE5vZGV7bD1sMTsgdj12MTsgcj1yMX0sIHQyKSAtPlxuICAgICAgICAgIG1hdGNoIHNwbGl0IHYxIHQyIHdpdGhcbiAgICAgICAgICAgIChsMiwgZmFsc2UsIHIyKSAtPlxuICAgICAgICAgICAgICBjb25jYXQgKGludGVyIGwxIGwyKSAoaW50ZXIgcjEgcjIpXG4gICAgICAgICAgfCAobDIsIHRydWUsIHIyKSAtPlxuICAgICAgICAgICAgICBqb2luIChpbnRlciBsMSBsMikgdjEgKGludGVyIHIxIHIyKVxuXG4gICAgbGV0IHJlYyBkaWZmIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBfKSAtPiBFbXB0eVxuICAgICAgfCAodDEsIEVtcHR5KSAtPiB0MVxuICAgICAgfCAoTm9kZXtsPWwxOyB2PXYxOyByPXIxfSwgdDIpIC0+XG4gICAgICAgICAgbWF0Y2ggc3BsaXQgdjEgdDIgd2l0aFxuICAgICAgICAgICAgKGwyLCBmYWxzZSwgcjIpIC0+XG4gICAgICAgICAgICAgIGpvaW4gKGRpZmYgbDEgbDIpIHYxIChkaWZmIHIxIHIyKVxuICAgICAgICAgIHwgKGwyLCB0cnVlLCByMikgLT5cbiAgICAgICAgICAgICAgY29uY2F0IChkaWZmIGwxIGwyKSAoZGlmZiByMSByMilcblxuICAgIHR5cGUgZW51bWVyYXRpb24gPSBFbmQgfCBNb3JlIG9mIGVsdCAqIHQgKiBlbnVtZXJhdGlvblxuXG4gICAgbGV0IHJlYyBjb25zX2VudW0gcyBlID1cbiAgICAgIG1hdGNoIHMgd2l0aFxuICAgICAgICBFbXB0eSAtPiBlXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gY29uc19lbnVtIGwgKE1vcmUodiwgciwgZSkpXG5cbiAgICBsZXQgcmVjIGNvbXBhcmVfYXV4IGUxIGUyID1cbiAgICAgICAgbWF0Y2ggKGUxLCBlMikgd2l0aFxuICAgICAgICAoRW5kLCBFbmQpIC0+IDBcbiAgICAgIHwgKEVuZCwgXykgIC0+IC0xXG4gICAgICB8IChfLCBFbmQpIC0+IDFcbiAgICAgIHwgKE1vcmUodjEsIHIxLCBlMSksIE1vcmUodjIsIHIyLCBlMikpIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB2MSB2MiBpblxuICAgICAgICAgIGlmIGMgPD4gMFxuICAgICAgICAgIHRoZW4gY1xuICAgICAgICAgIGVsc2UgY29tcGFyZV9hdXggKGNvbnNfZW51bSByMSBlMSkgKGNvbnNfZW51bSByMiBlMilcblxuICAgIGxldCBjb21wYXJlIHMxIHMyID1cbiAgICAgIGNvbXBhcmVfYXV4IChjb25zX2VudW0gczEgRW5kKSAoY29uc19lbnVtIHMyIEVuZClcblxuICAgIGxldCBlcXVhbCBzMSBzMiA9XG4gICAgICBjb21wYXJlIHMxIHMyID0gMFxuXG4gICAgbGV0IHJlYyBzdWJzZXQgczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgICBFbXB0eSwgXyAtPlxuICAgICAgICAgIHRydWVcbiAgICAgIHwgXywgRW1wdHkgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgfCBOb2RlIHtsPWwxOyB2PXYxOyByPXIxfSwgKE5vZGUge2w9bDI7IHY9djI7IHI9cjJ9IGFzIHQyKSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgdjEgdjIgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuXG4gICAgICAgICAgICBzdWJzZXQgbDEgbDIgJiYgc3Vic2V0IHIxIHIyXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBzdWJzZXQgKE5vZGUge2w9bDE7IHY9djE7IHI9RW1wdHk7IGg9MH0pIGwyICYmIHN1YnNldCByMSB0MlxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHN1YnNldCAoTm9kZSB7bD1FbXB0eTsgdj12MTsgcj1yMTsgaD0wfSkgcjIgJiYgc3Vic2V0IGwxIHQyXG5cbiAgICBsZXQgcmVjIGl0ZXIgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+ICgpXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gaXRlciBmIGw7IGYgdjsgaXRlciBmIHJcblxuICAgIGxldCByZWMgZm9sZCBmIHMgYWNjdSA9XG4gICAgICBtYXRjaCBzIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IGZvbGQgZiByIChmIHYgKGZvbGQgZiBsIGFjY3UpKVxuXG4gICAgbGV0IHJlYyBmb3JfYWxsIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiB0cnVlXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gcCB2ICYmIGZvcl9hbGwgcCBsICYmIGZvcl9hbGwgcCByXG5cbiAgICBsZXQgcmVjIGV4aXN0cyBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gZmFsc2VcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBwIHYgfHwgZXhpc3RzIHAgbCB8fCBleGlzdHMgcCByXG5cbiAgICBsZXQgcmVjIGZpbHRlciBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgKE5vZGV7bDsgdjsgcn0pIGFzIHQgLT5cbiAgICAgICAgICAoKiBjYWxsIFtwXSBpbiB0aGUgZXhwZWN0ZWQgbGVmdC10by1yaWdodCBvcmRlciAqKVxuICAgICAgICAgIGxldCBsJyA9IGZpbHRlciBwIGwgaW5cbiAgICAgICAgICBsZXQgcHYgPSBwIHYgaW5cbiAgICAgICAgICBsZXQgcicgPSBmaWx0ZXIgcCByIGluXG4gICAgICAgICAgaWYgcHYgdGhlblxuICAgICAgICAgICAgaWYgbD09bCcgJiYgcj09cicgdGhlbiB0IGVsc2Ugam9pbiBsJyB2IHInXG4gICAgICAgICAgZWxzZSBjb25jYXQgbCcgcidcblxuICAgIGxldCByZWMgcGFydGl0aW9uIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAoRW1wdHksIEVtcHR5KVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgKCogY2FsbCBbcF0gaW4gdGhlIGV4cGVjdGVkIGxlZnQtdG8tcmlnaHQgb3JkZXIgKilcbiAgICAgICAgICBsZXQgKGx0LCBsZikgPSBwYXJ0aXRpb24gcCBsIGluXG4gICAgICAgICAgbGV0IHB2ID0gcCB2IGluXG4gICAgICAgICAgbGV0IChydCwgcmYpID0gcGFydGl0aW9uIHAgciBpblxuICAgICAgICAgIGlmIHB2XG4gICAgICAgICAgdGhlbiAoam9pbiBsdCB2IHJ0LCBjb25jYXQgbGYgcmYpXG4gICAgICAgICAgZWxzZSAoY29uY2F0IGx0IHJ0LCBqb2luIGxmIHYgcmYpXG5cbiAgICBsZXQgcmVjIGNhcmRpbmFsID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gMFxuICAgICAgfCBOb2Rle2w7IHJ9IC0+IGNhcmRpbmFsIGwgKyAxICsgY2FyZGluYWwgclxuXG4gICAgbGV0IHJlYyBlbGVtZW50c19hdXggYWNjdSA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBlbGVtZW50c19hdXggKHYgOjogZWxlbWVudHNfYXV4IGFjY3UgcikgbFxuXG4gICAgbGV0IGVsZW1lbnRzIHMgPVxuICAgICAgZWxlbWVudHNfYXV4IFtdIHNcblxuICAgIGxldCBjaG9vc2UgPSBtaW5fZWx0XG5cbiAgICBsZXQgY2hvb3NlX29wdCA9IG1pbl9lbHRfb3B0XG5cbiAgICBsZXQgcmVjIGZpbmQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIHZcbiAgICAgICAgICBlbHNlIGZpbmQgeCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9hdXggdjAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgdjBcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2IGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYwIGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9vcHRfYXV4IHYwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIFNvbWUgdjBcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdiBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdjAgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3Rfb3B0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdiBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdCBmIHJcblxuICAgIGxldCByZWMgZmluZF9sYXN0X2F1eCB2MCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICB2MFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdiBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYwIGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3QgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2IGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0X29wdF9hdXggdjAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgU29tZSB2MFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdjAgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9vcHQgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X29wdCBmIGxcblxuICAgIGxldCByZWMgZmluZF9vcHQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBTb21lIHZcbiAgICAgICAgICBlbHNlIGZpbmRfb3B0IHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgdHJ5X2pvaW4gbCB2IHIgPVxuICAgICAgKCogW2pvaW4gbCB2IHJdIGNhbiBvbmx5IGJlIGNhbGxlZCB3aGVuIChlbGVtZW50cyBvZiBsIDwgdiA8XG4gICAgICAgICBlbGVtZW50cyBvZiByKTsgdXNlIFt0cnlfam9pbiBsIHYgcl0gd2hlbiB0aGlzIHByb3BlcnR5IG1heVxuICAgICAgICAgbm90IGhvbGQsIGJ1dCB5b3UgaG9wZSBpdCBkb2VzIGhvbGQgaW4gdGhlIGNvbW1vbiBjYXNlICopXG4gICAgICBpZiAobCA9IEVtcHR5IHx8IE9yZC5jb21wYXJlIChtYXhfZWx0IGwpIHYgPCAwKVxuICAgICAgJiYgKHIgPSBFbXB0eSB8fCBPcmQuY29tcGFyZSB2IChtaW5fZWx0IHIpIDwgMClcbiAgICAgIHRoZW4gam9pbiBsIHYgclxuICAgICAgZWxzZSB1bmlvbiBsIChhZGQgdiByKVxuXG4gICAgbGV0IHJlYyBtYXAgZiA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IE5vZGV7bDsgdjsgcn0gYXMgdCAtPlxuICAgICAgICAgKCogZW5mb3JjZSBsZWZ0LXRvLXJpZ2h0IGV2YWx1YXRpb24gb3JkZXIgKilcbiAgICAgICAgIGxldCBsJyA9IG1hcCBmIGwgaW5cbiAgICAgICAgIGxldCB2JyA9IGYgdiBpblxuICAgICAgICAgbGV0IHInID0gbWFwIGYgciBpblxuICAgICAgICAgaWYgbCA9PSBsJyAmJiB2ID09IHYnICYmIHIgPT0gcicgdGhlbiB0XG4gICAgICAgICBlbHNlIHRyeV9qb2luIGwnIHYnIHInXG5cbiAgICBsZXQgb2Zfc29ydGVkX2xpc3QgbCA9XG4gICAgICBsZXQgcmVjIHN1YiBuIGwgPVxuICAgICAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICAgICAgfCAwLCBsIC0+IEVtcHR5LCBsXG4gICAgICAgIHwgMSwgeDAgOjogbCAtPiBOb2RlIHtsPUVtcHR5OyB2PXgwOyByPUVtcHR5OyBoPTF9LCBsXG4gICAgICAgIHwgMiwgeDAgOjogeDEgOjogbCAtPlxuICAgICAgICAgICAgTm9kZXtsPU5vZGV7bD1FbXB0eTsgdj14MDsgcj1FbXB0eTsgaD0xfTsgdj14MTsgcj1FbXB0eTsgaD0yfSwgbFxuICAgICAgICB8IDMsIHgwIDo6IHgxIDo6IHgyIDo6IGwgLT5cbiAgICAgICAgICAgIE5vZGV7bD1Ob2Rle2w9RW1wdHk7IHY9eDA7IHI9RW1wdHk7IGg9MX07IHY9eDE7XG4gICAgICAgICAgICAgICAgIHI9Tm9kZXtsPUVtcHR5OyB2PXgyOyByPUVtcHR5OyBoPTF9OyBoPTJ9LCBsXG4gICAgICAgIHwgbiwgbCAtPlxuICAgICAgICAgIGxldCBubCA9IG4gLyAyIGluXG4gICAgICAgICAgbGV0IGxlZnQsIGwgPSBzdWIgbmwgbCBpblxuICAgICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICAgIHwgW10gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgfCBtaWQgOjogbCAtPlxuICAgICAgICAgICAgbGV0IHJpZ2h0LCBsID0gc3ViIChuIC0gbmwgLSAxKSBsIGluXG4gICAgICAgICAgICBjcmVhdGUgbGVmdCBtaWQgcmlnaHQsIGxcbiAgICAgIGluXG4gICAgICBmc3QgKHN1YiAoTGlzdC5sZW5ndGggbCkgbClcblxuICAgIGxldCBvZl9saXN0IGwgPVxuICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICB8IFtdIC0+IGVtcHR5XG4gICAgICB8IFt4MF0gLT4gc2luZ2xldG9uIHgwXG4gICAgICB8IFt4MDsgeDFdIC0+IGFkZCB4MSAoc2luZ2xldG9uIHgwKVxuICAgICAgfCBbeDA7IHgxOyB4Ml0gLT4gYWRkIHgyIChhZGQgeDEgKHNpbmdsZXRvbiB4MCkpXG4gICAgICB8IFt4MDsgeDE7IHgyOyB4M10gLT4gYWRkIHgzIChhZGQgeDIgKGFkZCB4MSAoc2luZ2xldG9uIHgwKSkpXG4gICAgICB8IFt4MDsgeDE7IHgyOyB4MzsgeDRdIC0+IGFkZCB4NCAoYWRkIHgzIChhZGQgeDIgKGFkZCB4MSAoc2luZ2xldG9uIHgwKSkpKVxuICAgICAgfCBfIC0+IG9mX3NvcnRlZF9saXN0IChMaXN0LnNvcnRfdW5pcSBPcmQuY29tcGFyZSBsKVxuICBlbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubW9kdWxlIHR5cGUgT3JkZXJlZFR5cGUgPVxuICBzaWdcbiAgICB0eXBlIHRcbiAgICB2YWwgY29tcGFyZTogdCAtPiB0IC0+IGludFxuICBlbmRcblxubW9kdWxlIHR5cGUgUyA9XG4gIHNpZ1xuICAgIHR5cGUga2V5XG4gICAgdHlwZSArJ2EgdFxuICAgIHZhbCBlbXB0eTogJ2EgdFxuICAgIHZhbCBpc19lbXB0eTogJ2EgdCAtPiBib29sXG4gICAgdmFsIG1lbTogIGtleSAtPiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgYWRkOiBrZXkgLT4gJ2EgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIHVwZGF0ZToga2V5IC0+ICgnYSBvcHRpb24gLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgc2luZ2xldG9uOiBrZXkgLT4gJ2EgLT4gJ2EgdFxuICAgIHZhbCByZW1vdmU6IGtleSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgbWVyZ2U6XG4gICAgICAgICAgKGtleSAtPiAnYSBvcHRpb24gLT4gJ2Igb3B0aW9uIC0+ICdjIG9wdGlvbikgLT4gJ2EgdCAtPiAnYiB0IC0+ICdjIHRcbiAgICB2YWwgdW5pb246IChrZXkgLT4gJ2EgLT4gJ2EgLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBjb21wYXJlOiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSB0IC0+ICdhIHQgLT4gaW50XG4gICAgdmFsIGVxdWFsOiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgaXRlcjogKGtleSAtPiAnYSAtPiB1bml0KSAtPiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgZm9sZDogKGtleSAtPiAnYSAtPiAnYiAtPiAnYikgLT4gJ2EgdCAtPiAnYiAtPiAnYlxuICAgIHZhbCBmb3JfYWxsOiAoa2V5IC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gYm9vbFxuICAgIHZhbCBleGlzdHM6IChrZXkgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiBib29sXG4gICAgdmFsIGZpbHRlcjogKGtleSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgcGFydGl0aW9uOiAoa2V5IC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gJ2EgdCAqICdhIHRcbiAgICB2YWwgY2FyZGluYWw6ICdhIHQgLT4gaW50XG4gICAgdmFsIGJpbmRpbmdzOiAnYSB0IC0+IChrZXkgKiAnYSkgbGlzdFxuICAgIHZhbCBtaW5fYmluZGluZzogJ2EgdCAtPiAoa2V5ICogJ2EpXG4gICAgdmFsIG1pbl9iaW5kaW5nX29wdDogJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICAgIHZhbCBtYXhfYmluZGluZzogJ2EgdCAtPiAoa2V5ICogJ2EpXG4gICAgdmFsIG1heF9iaW5kaW5nX29wdDogJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICAgIHZhbCBjaG9vc2U6ICdhIHQgLT4gKGtleSAqICdhKVxuICAgIHZhbCBjaG9vc2Vfb3B0OiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIHNwbGl0OiBrZXkgLT4gJ2EgdCAtPiAnYSB0ICogJ2Egb3B0aW9uICogJ2EgdFxuICAgIHZhbCBmaW5kOiBrZXkgLT4gJ2EgdCAtPiAnYVxuICAgIHZhbCBmaW5kX29wdDoga2V5IC0+ICdhIHQgLT4gJ2Egb3B0aW9uXG4gICAgdmFsIGZpbmRfZmlyc3Q6IChrZXkgLT4gYm9vbCkgLT4gJ2EgdCAtPiBrZXkgKiAnYVxuICAgIHZhbCBmaW5kX2ZpcnN0X29wdDogKGtleSAtPiBib29sKSAtPiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIGZpbmRfbGFzdDogKGtleSAtPiBib29sKSAtPiAnYSB0IC0+IGtleSAqICdhXG4gICAgdmFsIGZpbmRfbGFzdF9vcHQ6IChrZXkgLT4gYm9vbCkgLT4gJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICAgIHZhbCBtYXA6ICgnYSAtPiAnYikgLT4gJ2EgdCAtPiAnYiB0XG4gICAgdmFsIG1hcGk6IChrZXkgLT4gJ2EgLT4gJ2IpIC0+ICdhIHQgLT4gJ2IgdFxuICBlbmRcblxubW9kdWxlIE1ha2UoT3JkOiBPcmRlcmVkVHlwZSkgPSBzdHJ1Y3RcblxuICAgIHR5cGUga2V5ID0gT3JkLnRcblxuICAgIHR5cGUgJ2EgdCA9XG4gICAgICAgIEVtcHR5XG4gICAgICB8IE5vZGUgb2Yge2w6J2EgdDsgdjprZXk7IGQ6J2E7IHI6J2EgdDsgaDppbnR9XG5cbiAgICBsZXQgaGVpZ2h0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gMFxuICAgICAgfCBOb2RlIHtofSAtPiBoXG5cbiAgICBsZXQgY3JlYXRlIGwgeCBkIHIgPVxuICAgICAgbGV0IGhsID0gaGVpZ2h0IGwgYW5kIGhyID0gaGVpZ2h0IHIgaW5cbiAgICAgIE5vZGV7bDsgdj14OyBkOyByOyBoPShpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSl9XG5cbiAgICBsZXQgc2luZ2xldG9uIHggZCA9IE5vZGV7bD1FbXB0eTsgdj14OyBkOyByPUVtcHR5OyBoPTF9XG5cbiAgICBsZXQgYmFsIGwgeCBkIHIgPVxuICAgICAgbGV0IGhsID0gbWF0Y2ggbCB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBsZXQgaHIgPSBtYXRjaCByIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIGlmIGhsID4gaHIgKyAyIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgfCBOb2Rle2w9bGw7IHY9bHY7IGQ9bGQ7IHI9bHJ9IC0+XG4gICAgICAgICAgICBpZiBoZWlnaHQgbGwgPj0gaGVpZ2h0IGxyIHRoZW5cbiAgICAgICAgICAgICAgY3JlYXRlIGxsIGx2IGxkIChjcmVhdGUgbHIgeCBkIHIpXG4gICAgICAgICAgICBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIG1hdGNoIGxyIHdpdGhcbiAgICAgICAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgICAgICAgICB8IE5vZGV7bD1scmw7IHY9bHJ2OyBkPWxyZDsgcj1scnJ9LT5cbiAgICAgICAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGxsIGx2IGxkIGxybCkgbHJ2IGxyZCAoY3JlYXRlIGxyciB4IGQgcilcbiAgICAgICAgICAgIGVuZFxuICAgICAgZW5kIGVsc2UgaWYgaHIgPiBobCArIDIgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCByIHdpdGhcbiAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgICB8IE5vZGV7bD1ybDsgdj1ydjsgZD1yZDsgcj1ycn0gLT5cbiAgICAgICAgICAgIGlmIGhlaWdodCByciA+PSBoZWlnaHQgcmwgdGhlblxuICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHggZCBybCkgcnYgcmQgcnJcbiAgICAgICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbWF0Y2ggcmwgd2l0aFxuICAgICAgICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgICAgICAgIHwgTm9kZXtsPXJsbDsgdj1ybHY7IGQ9cmxkOyByPXJscn0gLT5cbiAgICAgICAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGwgeCBkIHJsbCkgcmx2IHJsZCAoY3JlYXRlIHJsciBydiByZCBycilcbiAgICAgICAgICAgIGVuZFxuICAgICAgZW5kIGVsc2VcbiAgICAgICAgTm9kZXtsOyB2PXg7IGQ7IHI7IGg9KGlmIGhsID49IGhyIHRoZW4gaGwgKyAxIGVsc2UgaHIgKyAxKX1cblxuICAgIGxldCBlbXB0eSA9IEVtcHR5XG5cbiAgICBsZXQgaXNfZW1wdHkgPSBmdW5jdGlvbiBFbXB0eSAtPiB0cnVlIHwgXyAtPiBmYWxzZVxuXG4gICAgbGV0IHJlYyBhZGQgeCBkYXRhID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb2Rle2w9RW1wdHk7IHY9eDsgZD1kYXRhOyByPUVtcHR5OyBoPTF9XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHI7IGh9IGFzIG0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW5cbiAgICAgICAgICAgIGlmIGQgPT0gZGF0YSB0aGVuIG0gZWxzZSBOb2Rle2w7IHY9eDsgZD1kYXRhOyByOyBofVxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IGxsID0gYWRkIHggZGF0YSBsIGluXG4gICAgICAgICAgICBpZiBsID09IGxsIHRoZW4gbSBlbHNlIGJhbCBsbCB2IGQgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCByciA9IGFkZCB4IGRhdGEgciBpblxuICAgICAgICAgICAgaWYgciA9PSByciB0aGVuIG0gZWxzZSBiYWwgbCB2IGQgcnJcblxuICAgIGxldCByZWMgZmluZCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gZFxuICAgICAgICAgIGVsc2UgZmluZCB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X2F1eCB2MCBkMCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICAodjAsIGQwKVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2IGQgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdjAgZDAgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3QgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYgZCBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0IGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X29wdF9hdXggdjAgZDAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgU29tZSAodjAsIGQwKVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdiBkIGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2MCBkMCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9vcHQgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdiBkIGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0IGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3RfYXV4IHYwIGQwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgICh2MCwgZDApXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdiBkIGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdjAgZDAgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2IGQgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0IGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3Rfb3B0X2F1eCB2MCBkMCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBTb21lICh2MCwgZDApXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYgZCBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2MCBkMCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0X29wdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYgZCBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0IGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX29wdCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIFNvbWUgZFxuICAgICAgICAgIGVsc2UgZmluZF9vcHQgeCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCByZWMgbWVtIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIGZhbHNlXG4gICAgICB8IE5vZGUge2w7IHY7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBjID0gMCB8fCBtZW0geCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCByZWMgbWluX2JpbmRpbmcgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZSB7bD1FbXB0eTsgdjsgZH0gLT4gKHYsIGQpXG4gICAgICB8IE5vZGUge2x9IC0+IG1pbl9iaW5kaW5nIGxcblxuICAgIGxldCByZWMgbWluX2JpbmRpbmdfb3B0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBOb2RlIHtsPUVtcHR5OyB2OyBkfSAtPiBTb21lICh2LCBkKVxuICAgICAgfCBOb2RlIHtsfS0+IG1pbl9iaW5kaW5nX29wdCBsXG5cbiAgICBsZXQgcmVjIG1heF9iaW5kaW5nID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGUge3Y7IGQ7IHI9RW1wdHl9IC0+ICh2LCBkKVxuICAgICAgfCBOb2RlIHtyfSAtPiBtYXhfYmluZGluZyByXG5cbiAgICBsZXQgcmVjIG1heF9iaW5kaW5nX29wdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgTm9kZSB7djsgZDsgcj1FbXB0eX0gLT4gU29tZSAodiwgZClcbiAgICAgIHwgTm9kZSB7cn0gLT4gbWF4X2JpbmRpbmdfb3B0IHJcblxuICAgIGxldCByZWMgcmVtb3ZlX21pbl9iaW5kaW5nID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAucmVtb3ZlX21pbl9lbHRcIlxuICAgICAgfCBOb2RlIHtsPUVtcHR5OyByfSAtPiByXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IGJhbCAocmVtb3ZlX21pbl9iaW5kaW5nIGwpIHYgZCByXG5cbiAgICBsZXQgbWVyZ2UgdDEgdDIgPVxuICAgICAgbWF0Y2ggKHQxLCB0Mikgd2l0aFxuICAgICAgICAoRW1wdHksIHQpIC0+IHRcbiAgICAgIHwgKHQsIEVtcHR5KSAtPiB0XG4gICAgICB8IChfLCBfKSAtPlxuICAgICAgICAgIGxldCAoeCwgZCkgPSBtaW5fYmluZGluZyB0MiBpblxuICAgICAgICAgIGJhbCB0MSB4IGQgKHJlbW92ZV9taW5fYmluZGluZyB0MilcblxuICAgIGxldCByZWMgcmVtb3ZlIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIEVtcHR5XG4gICAgICB8IChOb2RlIHtsOyB2OyBkOyByfSBhcyBtKSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBtZXJnZSBsIHJcbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBsbCA9IHJlbW92ZSB4IGwgaW4gaWYgbCA9PSBsbCB0aGVuIG0gZWxzZSBiYWwgbGwgdiBkIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgcnIgPSByZW1vdmUgeCByIGluIGlmIHIgPT0gcnIgdGhlbiBtIGVsc2UgYmFsIGwgdiBkIHJyXG5cbiAgICBsZXQgcmVjIHVwZGF0ZSB4IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIGYgTm9uZSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IEVtcHR5XG4gICAgICAgICAgfCBTb21lIGRhdGEgLT4gTm9kZXtsPUVtcHR5OyB2PXg7IGQ9ZGF0YTsgcj1FbXB0eTsgaD0xfVxuICAgICAgICAgIGVuZFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByOyBofSBhcyBtIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIGJlZ2luXG4gICAgICAgICAgICBtYXRjaCBmIChTb21lIGQpIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiBtZXJnZSBsIHJcbiAgICAgICAgICAgIHwgU29tZSBkYXRhIC0+XG4gICAgICAgICAgICAgICAgaWYgZCA9PSBkYXRhIHRoZW4gbSBlbHNlIE5vZGV7bDsgdj14OyBkPWRhdGE7IHI7IGh9XG4gICAgICAgICAgZW5kIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IGxsID0gdXBkYXRlIHggZiBsIGluXG4gICAgICAgICAgICBpZiBsID09IGxsIHRoZW4gbSBlbHNlIGJhbCBsbCB2IGQgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCByciA9IHVwZGF0ZSB4IGYgciBpblxuICAgICAgICAgICAgaWYgciA9PSByciB0aGVuIG0gZWxzZSBiYWwgbCB2IGQgcnJcblxuICAgIGxldCByZWMgaXRlciBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gKClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpdGVyIGYgbDsgZiB2IGQ7IGl0ZXIgZiByXG5cbiAgICBsZXQgcmVjIG1hcCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBFbXB0eVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByOyBofSAtPlxuICAgICAgICAgIGxldCBsJyA9IG1hcCBmIGwgaW5cbiAgICAgICAgICBsZXQgZCcgPSBmIGQgaW5cbiAgICAgICAgICBsZXQgcicgPSBtYXAgZiByIGluXG4gICAgICAgICAgTm9kZXtsPWwnOyB2OyBkPWQnOyByPXInOyBofVxuXG4gICAgbGV0IHJlYyBtYXBpIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIEVtcHR5XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHI7IGh9IC0+XG4gICAgICAgICAgbGV0IGwnID0gbWFwaSBmIGwgaW5cbiAgICAgICAgICBsZXQgZCcgPSBmIHYgZCBpblxuICAgICAgICAgIGxldCByJyA9IG1hcGkgZiByIGluXG4gICAgICAgICAgTm9kZXtsPWwnOyB2OyBkPWQnOyByPXInOyBofVxuXG4gICAgbGV0IHJlYyBmb2xkIGYgbSBhY2N1ID1cbiAgICAgIG1hdGNoIG0gd2l0aFxuICAgICAgICBFbXB0eSAtPiBhY2N1XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgZm9sZCBmIHIgKGYgdiBkIChmb2xkIGYgbCBhY2N1KSlcblxuICAgIGxldCByZWMgZm9yX2FsbCBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gdHJ1ZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBwIHYgZCAmJiBmb3JfYWxsIHAgbCAmJiBmb3JfYWxsIHAgclxuXG4gICAgbGV0IHJlYyBleGlzdHMgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGZhbHNlXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IHAgdiBkIHx8IGV4aXN0cyBwIGwgfHwgZXhpc3RzIHAgclxuXG4gICAgKCogQmV3YXJlOiB0aG9zZSB0d28gZnVuY3Rpb25zIGFzc3VtZSB0aGF0IHRoZSBhZGRlZCBrIGlzICpzdHJpY3RseSpcbiAgICAgICBzbWFsbGVyIChvciBiaWdnZXIpIHRoYW4gYWxsIHRoZSBwcmVzZW50IGtleXMgaW4gdGhlIHRyZWU7IGl0XG4gICAgICAgZG9lcyBub3QgdGVzdCBmb3IgZXF1YWxpdHkgd2l0aCB0aGUgY3VycmVudCBtaW4gKG9yIG1heCkga2V5LlxuXG4gICAgICAgSW5kZWVkLCB0aGV5IGFyZSBvbmx5IHVzZWQgZHVyaW5nIHRoZSBcImpvaW5cIiBvcGVyYXRpb24gd2hpY2hcbiAgICAgICByZXNwZWN0cyB0aGlzIHByZWNvbmRpdGlvbi5cbiAgICAqKVxuXG4gICAgbGV0IHJlYyBhZGRfbWluX2JpbmRpbmcgayB4ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gc2luZ2xldG9uIGsgeFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICBiYWwgKGFkZF9taW5fYmluZGluZyBrIHggbCkgdiBkIHJcblxuICAgIGxldCByZWMgYWRkX21heF9iaW5kaW5nIGsgeCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IHNpbmdsZXRvbiBrIHhcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgYmFsIGwgdiBkIChhZGRfbWF4X2JpbmRpbmcgayB4IHIpXG5cbiAgICAoKiBTYW1lIGFzIGNyZWF0ZSBhbmQgYmFsLCBidXQgbm8gYXNzdW1wdGlvbnMgYXJlIG1hZGUgb24gdGhlXG4gICAgICAgcmVsYXRpdmUgaGVpZ2h0cyBvZiBsIGFuZCByLiAqKVxuXG4gICAgbGV0IHJlYyBqb2luIGwgdiBkIHIgPVxuICAgICAgbWF0Y2ggKGwsIHIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBfKSAtPiBhZGRfbWluX2JpbmRpbmcgdiBkIHJcbiAgICAgIHwgKF8sIEVtcHR5KSAtPiBhZGRfbWF4X2JpbmRpbmcgdiBkIGxcbiAgICAgIHwgKE5vZGV7bD1sbDsgdj1sdjsgZD1sZDsgcj1scjsgaD1saH0sIE5vZGV7bD1ybDsgdj1ydjsgZD1yZDsgcj1ycjsgaD1yaH0pIC0+XG4gICAgICAgICAgaWYgbGggPiByaCArIDIgdGhlbiBiYWwgbGwgbHYgbGQgKGpvaW4gbHIgdiBkIHIpIGVsc2VcbiAgICAgICAgICBpZiByaCA+IGxoICsgMiB0aGVuIGJhbCAoam9pbiBsIHYgZCBybCkgcnYgcmQgcnIgZWxzZVxuICAgICAgICAgIGNyZWF0ZSBsIHYgZCByXG5cbiAgICAoKiBNZXJnZSB0d28gdHJlZXMgbCBhbmQgciBpbnRvIG9uZS5cbiAgICAgICBBbGwgZWxlbWVudHMgb2YgbCBtdXN0IHByZWNlZGUgdGhlIGVsZW1lbnRzIG9mIHIuXG4gICAgICAgTm8gYXNzdW1wdGlvbiBvbiB0aGUgaGVpZ2h0cyBvZiBsIGFuZCByLiAqKVxuXG4gICAgbGV0IGNvbmNhdCB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+XG4gICAgICAgICAgbGV0ICh4LCBkKSA9IG1pbl9iaW5kaW5nIHQyIGluXG4gICAgICAgICAgam9pbiB0MSB4IGQgKHJlbW92ZV9taW5fYmluZGluZyB0MilcblxuICAgIGxldCBjb25jYXRfb3Jfam9pbiB0MSB2IGQgdDIgPVxuICAgICAgbWF0Y2ggZCB3aXRoXG4gICAgICB8IFNvbWUgZCAtPiBqb2luIHQxIHYgZCB0MlxuICAgICAgfCBOb25lIC0+IGNvbmNhdCB0MSB0MlxuXG4gICAgbGV0IHJlYyBzcGxpdCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICAoRW1wdHksIE5vbmUsIEVtcHR5KVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiAobCwgU29tZSBkLCByKVxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IChsbCwgcHJlcywgcmwpID0gc3BsaXQgeCBsIGluIChsbCwgcHJlcywgam9pbiBybCB2IGQgcilcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgKGxyLCBwcmVzLCBycikgPSBzcGxpdCB4IHIgaW4gKGpvaW4gbCB2IGQgbHIsIHByZXMsIHJyKVxuXG4gICAgbGV0IHJlYyBtZXJnZSBmIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBFbXB0eSkgLT4gRW1wdHlcbiAgICAgIHwgKE5vZGUge2w9bDE7IHY9djE7IGQ9ZDE7IHI9cjE7IGg9aDF9LCBfKSB3aGVuIGgxID49IGhlaWdodCBzMiAtPlxuICAgICAgICAgIGxldCAobDIsIGQyLCByMikgPSBzcGxpdCB2MSBzMiBpblxuICAgICAgICAgIGNvbmNhdF9vcl9qb2luIChtZXJnZSBmIGwxIGwyKSB2MSAoZiB2MSAoU29tZSBkMSkgZDIpIChtZXJnZSBmIHIxIHIyKVxuICAgICAgfCAoXywgTm9kZSB7bD1sMjsgdj12MjsgZD1kMjsgcj1yMn0pIC0+XG4gICAgICAgICAgbGV0IChsMSwgZDEsIHIxKSA9IHNwbGl0IHYyIHMxIGluXG4gICAgICAgICAgY29uY2F0X29yX2pvaW4gKG1lcmdlIGYgbDEgbDIpIHYyIChmIHYyIGQxIChTb21lIGQyKSkgKG1lcmdlIGYgcjEgcjIpXG4gICAgICB8IF8gLT5cbiAgICAgICAgICBhc3NlcnQgZmFsc2VcblxuICAgIGxldCByZWMgdW5pb24gZiBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICB8IChFbXB0eSwgcykgfCAocywgRW1wdHkpIC0+IHNcbiAgICAgIHwgKE5vZGUge2w9bDE7IHY9djE7IGQ9ZDE7IHI9cjE7IGg9aDF9LCBOb2RlIHtsPWwyOyB2PXYyOyBkPWQyOyByPXIyOyBoPWgyfSkgLT5cbiAgICAgICAgICBpZiBoMSA+PSBoMiB0aGVuXG4gICAgICAgICAgICBsZXQgKGwyLCBkMiwgcjIpID0gc3BsaXQgdjEgczIgaW5cbiAgICAgICAgICAgIGxldCBsID0gdW5pb24gZiBsMSBsMiBhbmQgciA9IHVuaW9uIGYgcjEgcjIgaW5cbiAgICAgICAgICAgIG1hdGNoIGQyIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiBqb2luIGwgdjEgZDEgclxuICAgICAgICAgICAgfCBTb21lIGQyIC0+IGNvbmNhdF9vcl9qb2luIGwgdjEgKGYgdjEgZDEgZDIpIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgKGwxLCBkMSwgcjEpID0gc3BsaXQgdjIgczEgaW5cbiAgICAgICAgICAgIGxldCBsID0gdW5pb24gZiBsMSBsMiBhbmQgciA9IHVuaW9uIGYgcjEgcjIgaW5cbiAgICAgICAgICAgIG1hdGNoIGQxIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiBqb2luIGwgdjIgZDIgclxuICAgICAgICAgICAgfCBTb21lIGQxIC0+IGNvbmNhdF9vcl9qb2luIGwgdjIgKGYgdjIgZDEgZDIpIHJcblxuICAgIGxldCByZWMgZmlsdGVyIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBFbXB0eVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSBhcyBtIC0+XG4gICAgICAgICAgKCogY2FsbCBbcF0gaW4gdGhlIGV4cGVjdGVkIGxlZnQtdG8tcmlnaHQgb3JkZXIgKilcbiAgICAgICAgICBsZXQgbCcgPSBmaWx0ZXIgcCBsIGluXG4gICAgICAgICAgbGV0IHB2ZCA9IHAgdiBkIGluXG4gICAgICAgICAgbGV0IHInID0gZmlsdGVyIHAgciBpblxuICAgICAgICAgIGlmIHB2ZCB0aGVuIGlmIGw9PWwnICYmIHI9PXInIHRoZW4gbSBlbHNlIGpvaW4gbCcgdiBkIHInXG4gICAgICAgICAgZWxzZSBjb25jYXQgbCcgcidcblxuICAgIGxldCByZWMgcGFydGl0aW9uIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAoRW1wdHksIEVtcHR5KVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgICgqIGNhbGwgW3BdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IChsdCwgbGYpID0gcGFydGl0aW9uIHAgbCBpblxuICAgICAgICAgIGxldCBwdmQgPSBwIHYgZCBpblxuICAgICAgICAgIGxldCAocnQsIHJmKSA9IHBhcnRpdGlvbiBwIHIgaW5cbiAgICAgICAgICBpZiBwdmRcbiAgICAgICAgICB0aGVuIChqb2luIGx0IHYgZCBydCwgY29uY2F0IGxmIHJmKVxuICAgICAgICAgIGVsc2UgKGNvbmNhdCBsdCBydCwgam9pbiBsZiB2IGQgcmYpXG5cbiAgICB0eXBlICdhIGVudW1lcmF0aW9uID0gRW5kIHwgTW9yZSBvZiBrZXkgKiAnYSAqICdhIHQgKiAnYSBlbnVtZXJhdGlvblxuXG4gICAgbGV0IHJlYyBjb25zX2VudW0gbSBlID1cbiAgICAgIG1hdGNoIG0gd2l0aFxuICAgICAgICBFbXB0eSAtPiBlXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IGNvbnNfZW51bSBsIChNb3JlKHYsIGQsIHIsIGUpKVxuXG4gICAgbGV0IGNvbXBhcmUgY21wIG0xIG0yID1cbiAgICAgIGxldCByZWMgY29tcGFyZV9hdXggZTEgZTIgPVxuICAgICAgICAgIG1hdGNoIChlMSwgZTIpIHdpdGhcbiAgICAgICAgICAoRW5kLCBFbmQpIC0+IDBcbiAgICAgICAgfCAoRW5kLCBfKSAgLT4gLTFcbiAgICAgICAgfCAoXywgRW5kKSAtPiAxXG4gICAgICAgIHwgKE1vcmUodjEsIGQxLCByMSwgZTEpLCBNb3JlKHYyLCBkMiwgcjIsIGUyKSkgLT5cbiAgICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgdjEgdjIgaW5cbiAgICAgICAgICAgIGlmIGMgPD4gMCB0aGVuIGMgZWxzZVxuICAgICAgICAgICAgbGV0IGMgPSBjbXAgZDEgZDIgaW5cbiAgICAgICAgICAgIGlmIGMgPD4gMCB0aGVuIGMgZWxzZVxuICAgICAgICAgICAgY29tcGFyZV9hdXggKGNvbnNfZW51bSByMSBlMSkgKGNvbnNfZW51bSByMiBlMilcbiAgICAgIGluIGNvbXBhcmVfYXV4IChjb25zX2VudW0gbTEgRW5kKSAoY29uc19lbnVtIG0yIEVuZClcblxuICAgIGxldCBlcXVhbCBjbXAgbTEgbTIgPVxuICAgICAgbGV0IHJlYyBlcXVhbF9hdXggZTEgZTIgPVxuICAgICAgICAgIG1hdGNoIChlMSwgZTIpIHdpdGhcbiAgICAgICAgICAoRW5kLCBFbmQpIC0+IHRydWVcbiAgICAgICAgfCAoRW5kLCBfKSAgLT4gZmFsc2VcbiAgICAgICAgfCAoXywgRW5kKSAtPiBmYWxzZVxuICAgICAgICB8IChNb3JlKHYxLCBkMSwgcjEsIGUxKSwgTW9yZSh2MiwgZDIsIHIyLCBlMikpIC0+XG4gICAgICAgICAgICBPcmQuY29tcGFyZSB2MSB2MiA9IDAgJiYgY21wIGQxIGQyICYmXG4gICAgICAgICAgICBlcXVhbF9hdXggKGNvbnNfZW51bSByMSBlMSkgKGNvbnNfZW51bSByMiBlMilcbiAgICAgIGluIGVxdWFsX2F1eCAoY29uc19lbnVtIG0xIEVuZCkgKGNvbnNfZW51bSBtMiBFbmQpXG5cbiAgICBsZXQgcmVjIGNhcmRpbmFsID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gMFxuICAgICAgfCBOb2RlIHtsOyByfSAtPiBjYXJkaW5hbCBsICsgMSArIGNhcmRpbmFsIHJcblxuICAgIGxldCByZWMgYmluZGluZ3NfYXV4IGFjY3UgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBhY2N1XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IGJpbmRpbmdzX2F1eCAoKHYsIGQpIDo6IGJpbmRpbmdzX2F1eCBhY2N1IHIpIGxcblxuICAgIGxldCBiaW5kaW5ncyBzID1cbiAgICAgIGJpbmRpbmdzX2F1eCBbXSBzXG5cbiAgICBsZXQgY2hvb3NlID0gbWluX2JpbmRpbmdcblxuICAgIGxldCBjaG9vc2Vfb3B0ID0gbWluX2JpbmRpbmdfb3B0XG5cbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlICdhIHQgPSB7IG11dGFibGUgYyA6ICdhIGxpc3Q7IG11dGFibGUgbGVuIDogaW50OyB9XG5cbmV4Y2VwdGlvbiBFbXB0eVxuXG5sZXQgY3JlYXRlICgpID0geyBjID0gW107IGxlbiA9IDA7IH1cblxubGV0IGNsZWFyIHMgPSBzLmMgPC0gW107IHMubGVuIDwtIDBcblxubGV0IGNvcHkgcyA9IHsgYyA9IHMuYzsgbGVuID0gcy5sZW47IH1cblxubGV0IHB1c2ggeCBzID0gcy5jIDwtIHggOjogcy5jOyBzLmxlbiA8LSBzLmxlbiArIDFcblxubGV0IHBvcCBzID1cbiAgbWF0Y2ggcy5jIHdpdGhcbiAgfCBoZDo6dGwgLT4gcy5jIDwtIHRsOyBzLmxlbiA8LSBzLmxlbiAtIDE7IGhkXG4gIHwgW10gICAgIC0+IHJhaXNlIEVtcHR5XG5cbmxldCB0b3AgcyA9XG4gIG1hdGNoIHMuYyB3aXRoXG4gIHwgaGQ6Ol8gLT4gaGRcbiAgfCBbXSAgICAgLT4gcmFpc2UgRW1wdHlcblxubGV0IGlzX2VtcHR5IHMgPSAocy5jID0gW10pXG5cbmxldCBsZW5ndGggcyA9IHMubGVuXG5cbmxldCBpdGVyIGYgcyA9IExpc3QuaXRlciBmIHMuY1xuXG5sZXQgZm9sZCBmIGFjYyBzID0gTGlzdC5mb2xkX2xlZnQgZiBhY2Mgcy5jXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgIEZyYW5jb2lzIFBvdHRpZXIsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgIEplcmVtaWUgRGltaW5vLCBKYW5lIFN0cmVldCBFdXJvcGUgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4Y2VwdGlvbiBFbXB0eVxuXG50eXBlICdhIGNlbGwgPVxuICB8IE5pbFxuICB8IENvbnMgb2YgeyBjb250ZW50OiAnYTsgbXV0YWJsZSBuZXh0OiAnYSBjZWxsIH1cblxudHlwZSAnYSB0ID0ge1xuICBtdXRhYmxlIGxlbmd0aDogaW50O1xuICBtdXRhYmxlIGZpcnN0OiAnYSBjZWxsO1xuICBtdXRhYmxlIGxhc3Q6ICdhIGNlbGxcbn1cblxubGV0IGNyZWF0ZSAoKSA9IHtcbiAgbGVuZ3RoID0gMDtcbiAgZmlyc3QgPSBOaWw7XG4gIGxhc3QgPSBOaWxcbn1cblxubGV0IGNsZWFyIHEgPVxuICBxLmxlbmd0aCA8LSAwO1xuICBxLmZpcnN0IDwtIE5pbDtcbiAgcS5sYXN0IDwtIE5pbFxuXG5sZXQgYWRkIHggcSA9XG4gIGxldCBjZWxsID0gQ29ucyB7XG4gICAgY29udGVudCA9IHg7XG4gICAgbmV4dCA9IE5pbFxuICB9IGluXG4gIG1hdGNoIHEubGFzdCB3aXRoXG4gIHwgTmlsIC0+XG4gICAgcS5sZW5ndGggPC0gMTtcbiAgICBxLmZpcnN0IDwtIGNlbGw7XG4gICAgcS5sYXN0IDwtIGNlbGxcbiAgfCBDb25zIGxhc3QgLT5cbiAgICBxLmxlbmd0aCA8LSBxLmxlbmd0aCArIDE7XG4gICAgbGFzdC5uZXh0IDwtIGNlbGw7XG4gICAgcS5sYXN0IDwtIGNlbGxcblxubGV0IHB1c2ggPVxuICBhZGRcblxubGV0IHBlZWsgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiByYWlzZSBFbXB0eVxuICB8IENvbnMgeyBjb250ZW50IH0gLT4gY29udGVudFxuXG5sZXQgdG9wID1cbiAgcGVla1xuXG5sZXQgdGFrZSBxID1cbiAgbWF0Y2ggcS5maXJzdCB3aXRoXG4gIHwgTmlsIC0+IHJhaXNlIEVtcHR5XG4gIHwgQ29ucyB7IGNvbnRlbnQ7IG5leHQgPSBOaWwgfSAtPlxuICAgIGNsZWFyIHE7XG4gICAgY29udGVudFxuICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICBxLmxlbmd0aCA8LSBxLmxlbmd0aCAtIDE7XG4gICAgcS5maXJzdCA8LSBuZXh0O1xuICAgIGNvbnRlbnRcblxubGV0IHBvcCA9XG4gIHRha2VcblxubGV0IGNvcHkgPVxuICBsZXQgcmVjIGNvcHkgcV9yZXMgcHJldiBjZWxsID1cbiAgICBtYXRjaCBjZWxsIHdpdGhcbiAgICB8IE5pbCAtPiBxX3Jlcy5sYXN0IDwtIHByZXY7IHFfcmVzXG4gICAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgICBsZXQgcmVzID0gQ29ucyB7IGNvbnRlbnQ7IG5leHQgPSBOaWwgfSBpblxuICAgICAgYmVnaW4gbWF0Y2ggcHJldiB3aXRoXG4gICAgICB8IE5pbCAtPiBxX3Jlcy5maXJzdCA8LSByZXNcbiAgICAgIHwgQ29ucyBwIC0+IHAubmV4dCA8LSByZXNcbiAgICAgIGVuZDtcbiAgICAgIGNvcHkgcV9yZXMgcmVzIG5leHRcbiAgaW5cbiAgZnVuIHEgLT4gY29weSB7IGxlbmd0aCA9IHEubGVuZ3RoOyBmaXJzdCA9IE5pbDsgbGFzdCA9IE5pbCB9IE5pbCBxLmZpcnN0XG5cbmxldCBpc19lbXB0eSBxID1cbiAgcS5sZW5ndGggPSAwXG5cbmxldCBsZW5ndGggcSA9XG4gIHEubGVuZ3RoXG5cbmxldCBpdGVyID1cbiAgbGV0IHJlYyBpdGVyIGYgY2VsbCA9XG4gICAgbWF0Y2ggY2VsbCB3aXRoXG4gICAgfCBOaWwgLT4gKClcbiAgICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICAgIGYgY29udGVudDtcbiAgICAgIGl0ZXIgZiBuZXh0XG4gIGluXG4gIGZ1biBmIHEgLT4gaXRlciBmIHEuZmlyc3RcblxubGV0IGZvbGQgPVxuICBsZXQgcmVjIGZvbGQgZiBhY2N1IGNlbGwgPVxuICAgIG1hdGNoIGNlbGwgd2l0aFxuICAgIHwgTmlsIC0+IGFjY3VcbiAgICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICAgIGxldCBhY2N1ID0gZiBhY2N1IGNvbnRlbnQgaW5cbiAgICAgIGZvbGQgZiBhY2N1IG5leHRcbiAgaW5cbiAgZnVuIGYgYWNjdSBxIC0+IGZvbGQgZiBhY2N1IHEuZmlyc3RcblxubGV0IHRyYW5zZmVyIHExIHEyID1cbiAgaWYgcTEubGVuZ3RoID4gMCB0aGVuXG4gICAgbWF0Y2ggcTIubGFzdCB3aXRoXG4gICAgfCBOaWwgLT5cbiAgICAgIHEyLmxlbmd0aCA8LSBxMS5sZW5ndGg7XG4gICAgICBxMi5maXJzdCA8LSBxMS5maXJzdDtcbiAgICAgIHEyLmxhc3QgPC0gcTEubGFzdDtcbiAgICAgIGNsZWFyIHExXG4gICAgfCBDb25zIGxhc3QgLT5cbiAgICAgIHEyLmxlbmd0aCA8LSBxMi5sZW5ndGggKyBxMS5sZW5ndGg7XG4gICAgICBsYXN0Lm5leHQgPC0gcTEuZmlyc3Q7XG4gICAgICBxMi5sYXN0IDwtIHExLmxhc3Q7XG4gICAgICBjbGVhciBxMVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBJbnRlcm5hbHMgb2YgZm9yY2luZyBsYXp5IHZhbHVlcy4gKilcblxuZXhjZXB0aW9uIFVuZGVmaW5lZFxuXG5sZXQgcmFpc2VfdW5kZWZpbmVkID0gT2JqLnJlcHIgKGZ1biAoKSAtPiByYWlzZSBVbmRlZmluZWQpXG5cbigqIEFzc3VtZSBbYmxrXSBpcyBhIGJsb2NrIHdpdGggdGFnIGxhenkgKilcbmxldCBmb3JjZV9sYXp5X2Jsb2NrIChibGsgOiAnYXJnIGxhenlfdCkgPVxuICBsZXQgY2xvc3VyZSA9IChPYmoub2JqIChPYmouZmllbGQgKE9iai5yZXByIGJsaykgMCkgOiB1bml0IC0+ICdhcmcpIGluXG4gIE9iai5zZXRfZmllbGQgKE9iai5yZXByIGJsaykgMCByYWlzZV91bmRlZmluZWQ7XG4gIHRyeVxuICAgIGxldCByZXN1bHQgPSBjbG9zdXJlICgpIGluXG4gICAgKCogZG8gc2V0X2ZpZWxkIEJFRk9SRSBzZXRfdGFnICopXG4gICAgT2JqLnNldF9maWVsZCAoT2JqLnJlcHIgYmxrKSAwIChPYmoucmVwciByZXN1bHQpO1xuICAgIE9iai5zZXRfdGFnIChPYmoucmVwciBibGspIE9iai5mb3J3YXJkX3RhZztcbiAgICByZXN1bHRcbiAgd2l0aCBlIC0+XG4gICAgT2JqLnNldF9maWVsZCAoT2JqLnJlcHIgYmxrKSAwIChPYmoucmVwciAoZnVuICgpIC0+IHJhaXNlIGUpKTtcbiAgICByYWlzZSBlXG5cblxuKCogQXNzdW1lIFtibGtdIGlzIGEgYmxvY2sgd2l0aCB0YWcgbGF6eSAqKVxubGV0IGZvcmNlX3ZhbF9sYXp5X2Jsb2NrIChibGsgOiAnYXJnIGxhenlfdCkgPVxuICBsZXQgY2xvc3VyZSA9IChPYmoub2JqIChPYmouZmllbGQgKE9iai5yZXByIGJsaykgMCkgOiB1bml0IC0+ICdhcmcpIGluXG4gIE9iai5zZXRfZmllbGQgKE9iai5yZXByIGJsaykgMCByYWlzZV91bmRlZmluZWQ7XG4gIGxldCByZXN1bHQgPSBjbG9zdXJlICgpIGluXG4gICgqIGRvIHNldF9maWVsZCBCRUZPUkUgc2V0X3RhZyAqKVxuICBPYmouc2V0X2ZpZWxkIChPYmoucmVwciBibGspIDAgKE9iai5yZXByIHJlc3VsdCk7XG4gIE9iai5zZXRfdGFnIChPYmoucmVwciBibGspIChPYmouZm9yd2FyZF90YWcpO1xuICByZXN1bHRcblxuXG4oKiBbZm9yY2VdIGlzIG5vdCB1c2VkLCBzaW5jZSBbTGF6eS5mb3JjZV0gaXMgZGVjbGFyZWQgYXMgYSBwcmltaXRpdmVcbiAgIHdob3NlIGNvZGUgaW5saW5lcyB0aGUgdGFnIHRlc3RzIG9mIGl0cyBhcmd1bWVudC4gIFRoaXMgZnVuY3Rpb24gaXNcbiAgIGhlcmUgZm9yIHRoZSBzYWtlIG9mIGNvbXBsZXRlbmVzcywgYW5kIGZvciBkZWJ1Z2dpbmcgcHVycG9zZS4gKilcblxubGV0IGZvcmNlIChsenYgOiAnYXJnIGxhenlfdCkgPVxuICBsZXQgeCA9IE9iai5yZXByIGx6diBpblxuICBsZXQgdCA9IE9iai50YWcgeCBpblxuICBpZiB0ID0gT2JqLmZvcndhcmRfdGFnIHRoZW4gKE9iai5vYmogKE9iai5maWVsZCB4IDApIDogJ2FyZykgZWxzZVxuICBpZiB0IDw+IE9iai5sYXp5X3RhZyB0aGVuIChPYmoub2JqIHggOiAnYXJnKVxuICBlbHNlIGZvcmNlX2xhenlfYmxvY2sgbHp2XG5cblxubGV0IGZvcmNlX3ZhbCAobHp2IDogJ2FyZyBsYXp5X3QpID1cbiAgbGV0IHggPSBPYmoucmVwciBsenYgaW5cbiAgbGV0IHQgPSBPYmoudGFnIHggaW5cbiAgaWYgdCA9IE9iai5mb3J3YXJkX3RhZyB0aGVuIChPYmoub2JqIChPYmouZmllbGQgeCAwKSA6ICdhcmcpIGVsc2VcbiAgaWYgdCA8PiBPYmoubGF6eV90YWcgdGhlbiAoT2JqLm9iaiB4IDogJ2FyZylcbiAgZWxzZSBmb3JjZV92YWxfbGF6eV9ibG9jayBsenZcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtMYXp5XTogZGVmZXJyZWQgY29tcHV0YXRpb25zICopXG5cblxuKCpcbiAgIFdBUk5JTkc6IHNvbWUgcHVycGxlIG1hZ2ljIGlzIGdvaW5nIG9uIGhlcmUuICBEbyBub3QgdGFrZSB0aGlzIGZpbGVcbiAgIGFzIGFuIGV4YW1wbGUgb2YgaG93IHRvIHByb2dyYW0gaW4gT0NhbWwuXG4qKVxuXG5cbigqIFdlIG1ha2UgdXNlIG9mIHR3byBzcGVjaWFsIHRhZ3MgcHJvdmlkZWQgYnkgdGhlIHJ1bnRpbWU6XG4gICBbbGF6eV90YWddIGFuZCBbZm9yd2FyZF90YWddLlxuXG4gICBBIHZhbHVlIG9mIHR5cGUgWydhIExhenkudF0gY2FuIGJlIG9uZSBvZiB0aHJlZSB0aGluZ3M6XG4gICAxLiBBIGJsb2NrIG9mIHNpemUgMSB3aXRoIHRhZyBbbGF6eV90YWddLiAgSXRzIGZpZWxkIGlzIGEgY2xvc3VyZSBvZlxuICAgICAgdHlwZSBbdW5pdCAtPiAnYV0gdGhhdCBjb21wdXRlcyB0aGUgdmFsdWUuXG4gICAyLiBBIGJsb2NrIG9mIHNpemUgMSB3aXRoIHRhZyBbZm9yd2FyZF90YWddLiAgSXRzIGZpZWxkIGlzIHRoZSB2YWx1ZVxuICAgICAgb2YgdHlwZSBbJ2FdIHRoYXQgd2FzIGNvbXB1dGVkLlxuICAgMy4gQW55dGhpbmcgZWxzZSBleGNlcHQgYSBmbG9hdC4gIFRoaXMgaGFzIHR5cGUgWydhXSBhbmQgaXMgdGhlIHZhbHVlXG4gICAgICB0aGF0IHdhcyBjb21wdXRlZC5cbiAgIEV4Y2VwdGlvbnMgYXJlIHN0b3JlZCBpbiBmb3JtYXQgKDEpLlxuICAgVGhlIEdDIHdpbGwgbWFnaWNhbGx5IGNoYW5nZSB0aGluZ3MgZnJvbSAoMikgdG8gKDMpIGFjY29yZGluZyB0byBpdHNcbiAgIGZhbmN5LlxuXG4gICBJZiBPQ2FtbCB3YXMgY29uZmlndXJlZCB3aXRoIHRoZSAtZmxhdC1mbG9hdC1hcnJheSBvcHRpb24gKHdoaWNoIGlzXG4gICBjdXJyZW50bHkgdGhlIGRlZmF1bHQpLCB0aGUgZm9sbG93aW5nIGlzIGFsc28gdHJ1ZTpcbiAgIFdlIGNhbm5vdCB1c2UgcmVwcmVzZW50YXRpb24gKDMpIGZvciBhIFtmbG9hdCBMYXp5LnRdIGJlY2F1c2VcbiAgIFtjYW1sX21ha2VfYXJyYXldIGFzc3VtZXMgdGhhdCBvbmx5IGEgW2Zsb2F0XSB2YWx1ZSBjYW4gaGF2ZSB0YWdcbiAgIFtEb3VibGVfdGFnXS5cblxuICAgV2UgaGF2ZSB0byB1c2UgdGhlIGJ1aWx0LWluIHR5cGUgY29uc3RydWN0b3IgW2xhenlfdF0gdG9cbiAgIGxldCB0aGUgY29tcGlsZXIgaW1wbGVtZW50IHRoZSBzcGVjaWFsIHR5cGluZyBhbmQgY29tcGlsYXRpb25cbiAgIHJ1bGVzIGZvciB0aGUgW2xhenldIGtleXdvcmQuXG4qKVxuXG50eXBlICdhIHQgPSAnYSBsYXp5X3RcblxuZXhjZXB0aW9uIFVuZGVmaW5lZCA9IENhbWxpbnRlcm5hbExhenkuVW5kZWZpbmVkXG5cbmV4dGVybmFsIG1ha2VfZm9yd2FyZCA6ICdhIC0+ICdhIGxhenlfdCA9IFwiY2FtbF9sYXp5X21ha2VfZm9yd2FyZFwiXG5cbmV4dGVybmFsIGZvcmNlIDogJ2EgdCAtPiAnYSA9IFwiJWxhenlfZm9yY2VcIlxuXG4oKiBsZXQgZm9yY2UgPSBmb3JjZSAqKVxuXG5sZXQgZm9yY2VfdmFsID0gQ2FtbGludGVybmFsTGF6eS5mb3JjZV92YWxcblxubGV0IGZyb21fZnVuIChmIDogdW5pdCAtPiAnYXJnKSA9XG4gIGxldCB4ID0gT2JqLm5ld19ibG9jayBPYmoubGF6eV90YWcgMSBpblxuICBPYmouc2V0X2ZpZWxkIHggMCAoT2JqLnJlcHIgZik7XG4gIChPYmoub2JqIHggOiAnYXJnIHQpXG5cblxubGV0IGZyb21fdmFsICh2IDogJ2FyZykgPVxuICBsZXQgdCA9IE9iai50YWcgKE9iai5yZXByIHYpIGluXG4gIGlmIHQgPSBPYmouZm9yd2FyZF90YWcgfHwgdCA9IE9iai5sYXp5X3RhZyB8fCB0ID0gT2JqLmRvdWJsZV90YWcgdGhlbiBiZWdpblxuICAgIG1ha2VfZm9yd2FyZCB2XG4gIGVuZCBlbHNlIGJlZ2luXG4gICAgKE9iai5tYWdpYyB2IDogJ2FyZyB0KVxuICBlbmRcblxuXG5sZXQgaXNfdmFsIChsIDogJ2FyZyB0KSA9IE9iai50YWcgKE9iai5yZXByIGwpIDw+IE9iai5sYXp5X3RhZ1xuXG5sZXQgbGF6eV9mcm9tX2Z1biA9IGZyb21fZnVuXG5cbmxldCBsYXp5X2Zyb21fdmFsID0gZnJvbV92YWxcblxubGV0IGxhenlfaXNfdmFsID0gaXNfdmFsXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgIERhbmllbCBkZSBSYXVnbGF1ZHJlLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgJ2EgdCA9ICdhIGNlbGwgb3B0aW9uXG5hbmQgJ2EgY2VsbCA9IHsgbXV0YWJsZSBjb3VudCA6IGludDsgbXV0YWJsZSBkYXRhIDogJ2EgZGF0YSB9XG5hbmQgJ2EgZGF0YSA9XG4gICAgU2VtcHR5XG4gIHwgU2NvbnMgb2YgJ2EgKiAnYSBkYXRhXG4gIHwgU2FwcCBvZiAnYSBkYXRhICogJ2EgZGF0YVxuICB8IFNsYXp5IG9mICdhIGRhdGEgTGF6eS50XG4gIHwgU2dlbiBvZiAnYSBnZW5cbiAgfCBTYnVmZmlvIDogYnVmZmlvIC0+IGNoYXIgZGF0YVxuYW5kICdhIGdlbiA9IHsgbXV0YWJsZSBjdXJyIDogJ2Egb3B0aW9uIG9wdGlvbjsgZnVuYyA6IGludCAtPiAnYSBvcHRpb24gfVxuYW5kIGJ1ZmZpbyA9XG4gIHsgaWMgOiBpbl9jaGFubmVsOyBidWZmIDogYnl0ZXM7IG11dGFibGUgbGVuIDogaW50OyBtdXRhYmxlIGluZCA6IGludCB9XG5cbmV4Y2VwdGlvbiBGYWlsdXJlXG5leGNlcHRpb24gRXJyb3Igb2Ygc3RyaW5nXG5cbmxldCBjb3VudCA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiAwXG4gIHwgU29tZSB7IGNvdW50IH0gLT4gY291bnRcbmxldCBkYXRhID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+IFNlbXB0eVxuICB8IFNvbWUgeyBkYXRhIH0gLT4gZGF0YVxuXG5sZXQgZmlsbF9idWZmIGIgPVxuICBiLmxlbiA8LSBpbnB1dCBiLmljIGIuYnVmZiAwIChCeXRlcy5sZW5ndGggYi5idWZmKTsgYi5pbmQgPC0gMFxuXG5cbmxldCByZWMgZ2V0X2RhdGEgOiB0eXBlIHYuIGludCAtPiB2IGRhdGEgLT4gdiBkYXRhID0gZnVuIGNvdW50IGQgLT4gbWF0Y2ggZCB3aXRoXG4gKCogUmV0dXJucyBlaXRoZXIgU2VtcHR5IG9yIFNjb25zKGEsIF8pIGV2ZW4gd2hlbiBkIGlzIGEgZ2VuZXJhdG9yXG4gICAgb3IgYSBidWZmZXIuIEluIHRob3NlIGNhc2VzLCB0aGUgaXRlbSBhIGlzIHNlZW4gYXMgZXh0cmFjdGVkIGZyb21cbiB0aGUgZ2VuZXJhdG9yL2J1ZmZlci5cbiBUaGUgY291bnQgcGFyYW1ldGVyIGlzIHVzZWQgZm9yIGNhbGxpbmcgYFNnZW4tZnVuY3Rpb25zJy4gICopXG4gICBTZW1wdHkgfCBTY29ucyAoXywgXykgLT4gZFxuIHwgU2FwcCAoZDEsIGQyKSAtPlxuICAgICBiZWdpbiBtYXRjaCBnZXRfZGF0YSBjb3VudCBkMSB3aXRoXG4gICAgICAgU2NvbnMgKGEsIGQxMSkgLT4gU2NvbnMgKGEsIFNhcHAgKGQxMSwgZDIpKVxuICAgICB8IFNlbXB0eSAtPiBnZXRfZGF0YSBjb3VudCBkMlxuICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgIGVuZFxuIHwgU2dlbiB7Y3VyciA9IFNvbWUgTm9uZX0gLT4gU2VtcHR5XG4gfCBTZ2VuICh7Y3VyciA9IFNvbWUoU29tZSBhKX0gYXMgZykgLT5cbiAgICAgZy5jdXJyIDwtIE5vbmU7IFNjb25zKGEsIGQpXG4gfCBTZ2VuIGcgLT5cbiAgICAgYmVnaW4gbWF0Y2ggZy5mdW5jIGNvdW50IHdpdGhcbiAgICAgICBOb25lIC0+IGcuY3VyciA8LSBTb21lKE5vbmUpOyBTZW1wdHlcbiAgICAgfCBTb21lIGEgLT4gU2NvbnMoYSwgZClcbiAgICAgICAgICgqIFdhcm5pbmc6IGFueW9uZSB1c2luZyBnIHRoaW5rcyB0aGF0IGFuIGl0ZW0gaGFzIGJlZW4gcmVhZCAqKVxuICAgICBlbmRcbiB8IFNidWZmaW8gYiAtPlxuICAgICBpZiBiLmluZCA+PSBiLmxlbiB0aGVuIGZpbGxfYnVmZiBiO1xuICAgICBpZiBiLmxlbiA9PSAwIHRoZW4gU2VtcHR5IGVsc2VcbiAgICAgICBsZXQgciA9IEJ5dGVzLnVuc2FmZV9nZXQgYi5idWZmIGIuaW5kIGluXG4gICAgICAgKCogV2FybmluZzogYW55b25lIHVzaW5nIGcgdGhpbmtzIHRoYXQgYW4gaXRlbSBoYXMgYmVlbiByZWFkICopXG4gICAgICAgYi5pbmQgPC0gc3VjYyBiLmluZDsgU2NvbnMociwgZClcbiB8IFNsYXp5IGYgLT4gZ2V0X2RhdGEgY291bnQgKExhenkuZm9yY2UgZilcblxuXG5sZXQgcmVjIHBlZWtfZGF0YSA6IHR5cGUgdi4gdiBjZWxsIC0+IHYgb3B0aW9uID0gZnVuIHMgLT5cbiAoKiBjb25zdWx0IHRoZSBmaXJzdCBpdGVtIG9mIHMgKilcbiBtYXRjaCBzLmRhdGEgd2l0aFxuICAgU2VtcHR5IC0+IE5vbmVcbiB8IFNjb25zIChhLCBfKSAtPiBTb21lIGFcbiB8IFNhcHAgKF8sIF8pIC0+XG4gICAgIGJlZ2luIG1hdGNoIGdldF9kYXRhIHMuY291bnQgcy5kYXRhIHdpdGhcbiAgICAgICBTY29ucyhhLCBfKSBhcyBkIC0+IHMuZGF0YSA8LSBkOyBTb21lIGFcbiAgICAgfCBTZW1wdHkgLT4gTm9uZVxuICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgIGVuZFxuIHwgU2xhenkgZiAtPiBzLmRhdGEgPC0gKExhenkuZm9yY2UgZik7IHBlZWtfZGF0YSBzXG4gfCBTZ2VuIHtjdXJyID0gU29tZSBhfSAtPiBhXG4gfCBTZ2VuIGcgLT4gbGV0IHggPSBnLmZ1bmMgcy5jb3VudCBpbiBnLmN1cnIgPC0gU29tZSB4OyB4XG4gfCBTYnVmZmlvIGIgLT5cbiAgICAgaWYgYi5pbmQgPj0gYi5sZW4gdGhlbiBmaWxsX2J1ZmYgYjtcbiAgICAgaWYgYi5sZW4gPT0gMCB0aGVuIGJlZ2luIHMuZGF0YSA8LSBTZW1wdHk7IE5vbmUgZW5kXG4gICAgIGVsc2UgU29tZSAoQnl0ZXMudW5zYWZlX2dldCBiLmJ1ZmYgYi5pbmQpXG5cblxubGV0IHBlZWsgPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgcyAtPiBwZWVrX2RhdGEgc1xuXG5cbmxldCByZWMganVua19kYXRhIDogdHlwZSB2LiB2IGNlbGwgLT4gdW5pdCA9IGZ1biBzIC0+XG4gIG1hdGNoIHMuZGF0YSB3aXRoXG4gICAgU2NvbnMgKF8sIGQpIC0+IHMuY291bnQgPC0gKHN1Y2Mgcy5jb3VudCk7IHMuZGF0YSA8LSBkXG4gIHwgU2dlbiAoe2N1cnIgPSBTb21lIF99IGFzIGcpIC0+IHMuY291bnQgPC0gKHN1Y2Mgcy5jb3VudCk7IGcuY3VyciA8LSBOb25lXG4gIHwgU2J1ZmZpbyBiIC0+IHMuY291bnQgPC0gKHN1Y2Mgcy5jb3VudCk7IGIuaW5kIDwtIHN1Y2MgYi5pbmRcbiAgfCBfIC0+XG4gICAgICBtYXRjaCBwZWVrX2RhdGEgcyB3aXRoXG4gICAgICAgIE5vbmUgLT4gKClcbiAgICAgIHwgU29tZSBfIC0+IGp1bmtfZGF0YSBzXG5cblxubGV0IGp1bmsgPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIGRhdGEgLT4ganVua19kYXRhIGRhdGFcblxubGV0IHJlYyBuZ2V0X2RhdGEgbiBzID1cbiAgaWYgbiA8PSAwIHRoZW4gW10sIHMuZGF0YSwgMFxuICBlbHNlXG4gICAgbWF0Y2ggcGVla19kYXRhIHMgd2l0aFxuICAgICAgU29tZSBhIC0+XG4gICAgICAgIGp1bmtfZGF0YSBzO1xuICAgICAgICBsZXQgKGFsLCBkLCBrKSA9IG5nZXRfZGF0YSAocHJlZCBuKSBzIGluIGEgOjogYWwsIFNjb25zIChhLCBkKSwgc3VjYyBrXG4gICAgfCBOb25lIC0+IFtdLCBzLmRhdGEsIDBcblxuXG5sZXQgbnBlZWtfZGF0YSBuIHMgPVxuICBsZXQgKGFsLCBkLCBsZW4pID0gbmdldF9kYXRhIG4gcyBpblxuICBzLmNvdW50IDwtIChzLmNvdW50IC0gbGVuKTtcbiAgcy5kYXRhIDwtIGQ7XG4gIGFsXG5cblxubGV0IG5wZWVrIG4gPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gW11cbiAgfCBTb21lIGQgLT4gbnBlZWtfZGF0YSBuIGRcblxubGV0IG5leHQgcyA9XG4gIG1hdGNoIHBlZWsgcyB3aXRoXG4gICAgU29tZSBhIC0+IGp1bmsgczsgYVxuICB8IE5vbmUgLT4gcmFpc2UgRmFpbHVyZVxuXG5cbmxldCBlbXB0eSBzID1cbiAgbWF0Y2ggcGVlayBzIHdpdGhcbiAgICBTb21lIF8gLT4gcmFpc2UgRmFpbHVyZVxuICB8IE5vbmUgLT4gKClcblxuXG5sZXQgaXRlciBmIHN0cm0gPVxuICBsZXQgcmVjIGRvX3JlYyAoKSA9XG4gICAgbWF0Y2ggcGVlayBzdHJtIHdpdGhcbiAgICAgIFNvbWUgYSAtPiBqdW5rIHN0cm07IGlnbm9yZShmIGEpOyBkb19yZWMgKClcbiAgICB8IE5vbmUgLT4gKClcbiAgaW5cbiAgZG9fcmVjICgpXG5cblxuKCogU3RyZWFtIGJ1aWxkaW5nIGZ1bmN0aW9ucyAqKVxuXG5sZXQgZnJvbSBmID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2dlbiB7Y3VyciA9IE5vbmU7IGZ1bmMgPSBmfX1cblxubGV0IG9mX2xpc3QgbCA9XG4gIFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IExpc3QuZm9sZF9yaWdodCAoZnVuIHggbCAtPiBTY29ucyAoeCwgbCkpIGwgU2VtcHR5fVxuXG5cbmxldCBvZl9zdHJpbmcgcyA9XG4gIGxldCBjb3VudCA9IHJlZiAwIGluXG4gIGZyb20gKGZ1biBfIC0+XG4gICAgKCogV2UgY2Fubm90IHVzZSB0aGUgaW5kZXggcGFzc2VkIGJ5IHRoZSBbZnJvbV0gZnVuY3Rpb24gZGlyZWN0bHlcbiAgICAgICBiZWNhdXNlIGl0IHJldHVybnMgdGhlIGN1cnJlbnQgc3RyZWFtIGNvdW50LCB3aXRoIGFic29sdXRlbHkgbm9cbiAgICAgICBndWFyYW50ZWUgdGhhdCBpdCB3aWxsIHN0YXJ0IGZyb20gMC4gRm9yIGV4YW1wbGUsIGluIHRoZSBjYXNlXG4gICAgICAgb2YgW1N0cmVhbS5pY29ucyAnYycgKFN0cmVhbS5mcm9tX3N0cmluZyBcImFiXCIpXSwgdGhlIGZpcnN0XG4gICAgICAgYWNjZXNzIHRvIHRoZSBzdHJpbmcgd2lsbCBiZSBtYWRlIHdpdGggY291bnQgWzFdIGFscmVhZHkuXG4gICAgKilcbiAgICBsZXQgYyA9ICFjb3VudCBpblxuICAgIGlmIGMgPCBTdHJpbmcubGVuZ3RoIHNcbiAgICB0aGVuIChpbmNyIGNvdW50OyBTb21lIHMuW2NdKVxuICAgIGVsc2UgTm9uZSlcblxuXG5sZXQgb2ZfYnl0ZXMgcyA9XG4gIGxldCBjb3VudCA9IHJlZiAwIGluXG4gIGZyb20gKGZ1biBfIC0+XG4gICAgbGV0IGMgPSAhY291bnQgaW5cbiAgICBpZiBjIDwgQnl0ZXMubGVuZ3RoIHNcbiAgICB0aGVuIChpbmNyIGNvdW50OyBTb21lIChCeXRlcy5nZXQgcyBjKSlcbiAgICBlbHNlIE5vbmUpXG5cblxubGV0IG9mX2NoYW5uZWwgaWMgPVxuICBTb21lIHtjb3VudCA9IDA7XG4gICAgICAgIGRhdGEgPSBTYnVmZmlvIHtpYyA9IGljOyBidWZmID0gQnl0ZXMuY3JlYXRlIDQwOTY7IGxlbiA9IDA7IGluZCA9IDB9fVxuXG5cbigqIFN0cmVhbSBleHByZXNzaW9ucyBidWlsZGVycyAqKVxuXG5sZXQgaWFwcCBpIHMgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTYXBwIChkYXRhIGksIGRhdGEgcyl9XG5sZXQgaWNvbnMgaSBzID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2NvbnMgKGksIGRhdGEgcyl9XG5sZXQgaXNpbmcgaSA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNjb25zIChpLCBTZW1wdHkpfVxuXG5sZXQgbGFwcCBmIHMgPVxuICBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTbGF6eSAobGF6eShTYXBwIChkYXRhIChmICgpKSwgZGF0YSBzKSkpfVxuXG5sZXQgbGNvbnMgZiBzID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2xhenkgKGxhenkoU2NvbnMgKGYgKCksIGRhdGEgcykpKX1cbmxldCBsc2luZyBmID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2xhenkgKGxhenkoU2NvbnMgKGYgKCksIFNlbXB0eSkpKX1cblxubGV0IHNlbXB0eSA9IE5vbmVcbmxldCBzbGF6eSBmID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2xhenkgKGxhenkoZGF0YSAoZiAoKSkpKX1cblxuKCogRm9yIGRlYnVnZ2luZyB1c2UgKilcblxubGV0IHJlYyBkdW1wIDogdHlwZSB2LiAodiAtPiB1bml0KSAtPiB2IHQgLT4gdW5pdCA9IGZ1biBmIHMgLT5cbiAgcHJpbnRfc3RyaW5nIFwie2NvdW50ID0gXCI7XG4gIHByaW50X2ludCAoY291bnQgcyk7XG4gIHByaW50X3N0cmluZyBcIjsgZGF0YSA9IFwiO1xuICBkdW1wX2RhdGEgZiAoZGF0YSBzKTtcbiAgcHJpbnRfc3RyaW5nIFwifVwiO1xuICBwcmludF9uZXdsaW5lICgpXG5hbmQgZHVtcF9kYXRhIDogdHlwZSB2LiAodiAtPiB1bml0KSAtPiB2IGRhdGEgLT4gdW5pdCA9IGZ1biBmIC0+XG4gIGZ1bmN0aW9uXG4gICAgU2VtcHR5IC0+IHByaW50X3N0cmluZyBcIlNlbXB0eVwiXG4gIHwgU2NvbnMgKGEsIGQpIC0+XG4gICAgICBwcmludF9zdHJpbmcgXCJTY29ucyAoXCI7XG4gICAgICBmIGE7XG4gICAgICBwcmludF9zdHJpbmcgXCIsIFwiO1xuICAgICAgZHVtcF9kYXRhIGYgZDtcbiAgICAgIHByaW50X3N0cmluZyBcIilcIlxuICB8IFNhcHAgKGQxLCBkMikgLT5cbiAgICAgIHByaW50X3N0cmluZyBcIlNhcHAgKFwiO1xuICAgICAgZHVtcF9kYXRhIGYgZDE7XG4gICAgICBwcmludF9zdHJpbmcgXCIsIFwiO1xuICAgICAgZHVtcF9kYXRhIGYgZDI7XG4gICAgICBwcmludF9zdHJpbmcgXCIpXCJcbiAgfCBTbGF6eSBfIC0+IHByaW50X3N0cmluZyBcIlNsYXp5XCJcbiAgfCBTZ2VuIF8gLT4gcHJpbnRfc3RyaW5nIFwiU2dlblwiXG4gIHwgU2J1ZmZpbyBfIC0+IHByaW50X3N0cmluZyBcIlNidWZmaW9cIlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgUGllcnJlIFdlaXMgYW5kIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5OSBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBFeHRlbnNpYmxlIGJ1ZmZlcnMgKilcblxudHlwZSB0ID1cbiB7bXV0YWJsZSBidWZmZXIgOiBieXRlcztcbiAgbXV0YWJsZSBwb3NpdGlvbiA6IGludDtcbiAgbXV0YWJsZSBsZW5ndGggOiBpbnQ7XG4gIGluaXRpYWxfYnVmZmVyIDogYnl0ZXN9XG5cbmxldCBjcmVhdGUgbiA9XG4gbGV0IG4gPSBpZiBuIDwgMSB0aGVuIDEgZWxzZSBuIGluXG4gbGV0IG4gPSBpZiBuID4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIHRoZW4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIGVsc2UgbiBpblxuIGxldCBzID0gQnl0ZXMuY3JlYXRlIG4gaW5cbiB7YnVmZmVyID0gczsgcG9zaXRpb24gPSAwOyBsZW5ndGggPSBuOyBpbml0aWFsX2J1ZmZlciA9IHN9XG5cbmxldCBjb250ZW50cyBiID0gQnl0ZXMuc3ViX3N0cmluZyBiLmJ1ZmZlciAwIGIucG9zaXRpb25cbmxldCB0b19ieXRlcyBiID0gQnl0ZXMuc3ViIGIuYnVmZmVyIDAgYi5wb3NpdGlvblxuXG5sZXQgc3ViIGIgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBiLnBvc2l0aW9uIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJCdWZmZXIuc3ViXCJcbiAgZWxzZSBCeXRlcy5zdWJfc3RyaW5nIGIuYnVmZmVyIG9mcyBsZW5cblxuXG5sZXQgYmxpdCBzcmMgc3Jjb2ZmIGRzdCBkc3RvZmYgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBzcmNvZmYgPCAwIHx8IHNyY29mZiA+IHNyYy5wb3NpdGlvbiAtIGxlblxuICAgICAgICAgICAgIHx8IGRzdG9mZiA8IDAgfHwgZHN0b2ZmID4gKEJ5dGVzLmxlbmd0aCBkc3QpIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJCdWZmZXIuYmxpdFwiXG4gIGVsc2VcbiAgICBCeXRlcy51bnNhZmVfYmxpdCBzcmMuYnVmZmVyIHNyY29mZiBkc3QgZHN0b2ZmIGxlblxuXG5cbmxldCBudGggYiBvZnMgPVxuICBpZiBvZnMgPCAwIHx8IG9mcyA+PSBiLnBvc2l0aW9uIHRoZW5cbiAgIGludmFsaWRfYXJnIFwiQnVmZmVyLm50aFwiXG4gIGVsc2UgQnl0ZXMudW5zYWZlX2dldCBiLmJ1ZmZlciBvZnNcblxuXG5sZXQgbGVuZ3RoIGIgPSBiLnBvc2l0aW9uXG5cbmxldCBjbGVhciBiID0gYi5wb3NpdGlvbiA8LSAwXG5cbmxldCByZXNldCBiID1cbiAgYi5wb3NpdGlvbiA8LSAwOyBiLmJ1ZmZlciA8LSBiLmluaXRpYWxfYnVmZmVyO1xuICBiLmxlbmd0aCA8LSBCeXRlcy5sZW5ndGggYi5idWZmZXJcblxubGV0IHJlc2l6ZSBiIG1vcmUgPVxuICBsZXQgbGVuID0gYi5sZW5ndGggaW5cbiAgbGV0IG5ld19sZW4gPSByZWYgbGVuIGluXG4gIHdoaWxlIGIucG9zaXRpb24gKyBtb3JlID4gIW5ld19sZW4gZG8gbmV3X2xlbiA6PSAyICogIW5ld19sZW4gZG9uZTtcbiAgaWYgIW5ld19sZW4gPiBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlbiBiZWdpblxuICAgIGlmIGIucG9zaXRpb24gKyBtb3JlIDw9IFN5cy5tYXhfc3RyaW5nX2xlbmd0aFxuICAgIHRoZW4gbmV3X2xlbiA6PSBTeXMubWF4X3N0cmluZ19sZW5ndGhcbiAgICBlbHNlIGZhaWx3aXRoIFwiQnVmZmVyLmFkZDogY2Fubm90IGdyb3cgYnVmZmVyXCJcbiAgZW5kO1xuICBsZXQgbmV3X2J1ZmZlciA9IEJ5dGVzLmNyZWF0ZSAhbmV3X2xlbiBpblxuICAoKiBQUiM2MTQ4OiBsZXQncyBrZWVwIHVzaW5nIFtibGl0XSByYXRoZXIgdGhhbiBbdW5zYWZlX2JsaXRdIGluXG4gICAgIHRoaXMgdHJpY2t5IGZ1bmN0aW9uIHRoYXQgaXMgc2xvdyBhbnl3YXkuICopXG4gIEJ5dGVzLmJsaXQgYi5idWZmZXIgMCBuZXdfYnVmZmVyIDAgYi5wb3NpdGlvbjtcbiAgYi5idWZmZXIgPC0gbmV3X2J1ZmZlcjtcbiAgYi5sZW5ndGggPC0gIW5ld19sZW5cblxubGV0IGFkZF9jaGFyIGIgYyA9XG4gIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gIGlmIHBvcyA+PSBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDE7XG4gIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgcG9zIGM7XG4gIGIucG9zaXRpb24gPC0gcG9zICsgMVxuXG4gbGV0IGFkZF91dGZfOF91Y2hhciBiIHUgPSBtYXRjaCBVY2hhci50b19pbnQgdSB3aXRoXG4gfCB1IHdoZW4gdSA8IDAgLT4gYXNzZXJ0IGZhbHNlXG4gfCB1IHdoZW4gdSA8PSAweDAwN0YgLT5cbiAgICAgYWRkX2NoYXIgYiAoQ2hhci51bnNhZmVfY2hyIHUpXG4gfCB1IHdoZW4gdSA8PSAweDA3RkYgLT5cbiAgICAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgICAgaWYgcG9zICsgMiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgMjtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICAgIClcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweEMwIGxvciAodSBsc3IgNikpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMSlcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweDgwIGxvciAodSBsYW5kIDB4M0YpKSk7XG4gICAgIGIucG9zaXRpb24gPC0gcG9zICsgMlxuIHwgdSB3aGVuIHUgPD0gMHhGRkZGIC0+XG4gICAgIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gICAgIGlmIHBvcyArIDMgPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDM7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyAgICApXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHhFMCBsb3IgKHUgbHNyIDEyKSkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAxKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4ODAgbG9yICgodSBsc3IgNikgbGFuZCAweDNGKSkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAyKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4ODAgbG9yICh1IGxhbmQgMHgzRikpKTtcbiAgICAgYi5wb3NpdGlvbiA8LSBwb3MgKyAzXG4gfCB1IHdoZW4gdSA8PSAweDEwRkZGRiAtPlxuICAgICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICAgICBpZiBwb3MgKyA0ID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiA0O1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgICAgKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4RjAgbG9yICh1IGxzciAxOCkpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMSlcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweDgwIGxvciAoKHUgbHNyIDEyKSBsYW5kIDB4M0YpKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDIpXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHg4MCBsb3IgKCh1IGxzciA2KSBsYW5kIDB4M0YpKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDMpXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHg4MCBsb3IgKHUgbGFuZCAweDNGKSkpO1xuICAgICBiLnBvc2l0aW9uIDwtIHBvcyArIDRcbiB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiBsZXQgYWRkX3V0Zl8xNmJlX3VjaGFyIGIgdSA9IG1hdGNoIFVjaGFyLnRvX2ludCB1IHdpdGhcbiB8IHUgd2hlbiB1IDwgMCAtPiBhc3NlcnQgZmFsc2VcbiB8IHUgd2hlbiB1IDw9IDB4RkZGRiAtPlxuICAgICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICAgICBpZiBwb3MgKyAyID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiAyO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgICAgKSAoQ2hhci51bnNhZmVfY2hyICh1IGxzciA4KSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDEpIChDaGFyLnVuc2FmZV9jaHIgKHUgbGFuZCAweEZGKSk7XG4gICAgIGIucG9zaXRpb24gPC0gcG9zICsgMlxuIHwgdSB3aGVuIHUgPD0gMHgxMEZGRkYgLT5cbiAgICAgbGV0IHUnID0gdSAtIDB4MTAwMDAgaW5cbiAgICAgbGV0IGhpID0gMHhEODAwIGxvciAodScgbHNyIDEwKSBpblxuICAgICBsZXQgbG8gPSAweERDMDAgbG9yICh1JyBsYW5kIDB4M0ZGKSBpblxuICAgICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICAgICBpZiBwb3MgKyA0ID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiA0O1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgICAgKSAoQ2hhci51bnNhZmVfY2hyIChoaSBsc3IgOCkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAxKSAoQ2hhci51bnNhZmVfY2hyIChoaSBsYW5kIDB4RkYpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMikgKENoYXIudW5zYWZlX2NociAobG8gbHNyIDgpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMykgKENoYXIudW5zYWZlX2NociAobG8gbGFuZCAweEZGKSk7XG4gICAgIGIucG9zaXRpb24gPC0gcG9zICsgNFxuIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuIGxldCBhZGRfdXRmXzE2bGVfdWNoYXIgYiB1ID0gbWF0Y2ggVWNoYXIudG9faW50IHUgd2l0aFxuIHwgdSB3aGVuIHUgPCAwIC0+IGFzc2VydCBmYWxzZVxuIHwgdSB3aGVuIHUgPD0gMHhGRkZGIC0+XG4gICAgIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gICAgIGlmIHBvcyArIDIgPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDI7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyAgICApIChDaGFyLnVuc2FmZV9jaHIgKHUgbGFuZCAweEZGKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDEpIChDaGFyLnVuc2FmZV9jaHIgKHUgbHNyIDgpKTtcbiAgICAgYi5wb3NpdGlvbiA8LSBwb3MgKyAyXG4gfCB1IHdoZW4gdSA8PSAweDEwRkZGRiAtPlxuICAgICBsZXQgdScgPSB1IC0gMHgxMDAwMCBpblxuICAgICBsZXQgaGkgPSAweEQ4MDAgbG9yICh1JyBsc3IgMTApIGluXG4gICAgIGxldCBsbyA9IDB4REMwMCBsb3IgKHUnIGxhbmQgMHgzRkYpIGluXG4gICAgIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gICAgIGlmIHBvcyArIDQgPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDQ7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyAgICApIChDaGFyLnVuc2FmZV9jaHIgKGhpIGxhbmQgMHhGRikpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAxKSAoQ2hhci51bnNhZmVfY2hyIChoaSBsc3IgOCkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAyKSAoQ2hhci51bnNhZmVfY2hyIChsbyBsYW5kIDB4RkYpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMykgKENoYXIudW5zYWZlX2NociAobG8gbHNyIDgpKTtcbiAgICAgYi5wb3NpdGlvbiA8LSBwb3MgKyA0XG4gfCBfIC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgYWRkX3N1YnN0cmluZyBiIHMgb2Zmc2V0IGxlbiA9XG4gIGlmIG9mZnNldCA8IDAgfHwgbGVuIDwgMCB8fCBvZmZzZXQgPiBTdHJpbmcubGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkJ1ZmZlci5hZGRfc3Vic3RyaW5nL2FkZF9zdWJieXRlc1wiO1xuICBsZXQgbmV3X3Bvc2l0aW9uID0gYi5wb3NpdGlvbiArIGxlbiBpblxuICBpZiBuZXdfcG9zaXRpb24gPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIGxlbjtcbiAgQnl0ZXMuYmxpdF9zdHJpbmcgcyBvZmZzZXQgYi5idWZmZXIgYi5wb3NpdGlvbiBsZW47XG4gIGIucG9zaXRpb24gPC0gbmV3X3Bvc2l0aW9uXG5cbmxldCBhZGRfc3ViYnl0ZXMgYiBzIG9mZnNldCBsZW4gPVxuICBhZGRfc3Vic3RyaW5nIGIgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcykgb2Zmc2V0IGxlblxuXG5sZXQgYWRkX3N0cmluZyBiIHMgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCBuZXdfcG9zaXRpb24gPSBiLnBvc2l0aW9uICsgbGVuIGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgbGVuO1xuICBCeXRlcy5ibGl0X3N0cmluZyBzIDAgYi5idWZmZXIgYi5wb3NpdGlvbiBsZW47XG4gIGIucG9zaXRpb24gPC0gbmV3X3Bvc2l0aW9uXG5cbmxldCBhZGRfYnl0ZXMgYiBzID0gYWRkX3N0cmluZyBiIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHMpXG5cbmxldCBhZGRfYnVmZmVyIGIgYnMgPVxuICBhZGRfc3ViYnl0ZXMgYiBicy5idWZmZXIgMCBicy5wb3NpdGlvblxuXG4oKiByZWFkIHVwIHRvIFtsZW5dIGJ5dGVzIGZyb20gW2ljXSBpbnRvIFtiXS4gKilcbmxldCByZWMgYWRkX2NoYW5uZWxfcmVjIGIgaWMgbGVuID1cbiAgaWYgbGVuID4gMCB0aGVuIChcbiAgICBsZXQgbiA9IGlucHV0IGljIGIuYnVmZmVyIGIucG9zaXRpb24gbGVuIGluXG4gICAgYi5wb3NpdGlvbiA8LSBiLnBvc2l0aW9uICsgbjtcbiAgICBpZiBuID0gMCB0aGVuIHJhaXNlIEVuZF9vZl9maWxlXG4gICAgZWxzZSBhZGRfY2hhbm5lbF9yZWMgYiBpYyAobGVuLW4pICAgKCogbiA8PSBsZW4gKilcbiAgKVxuXG5sZXQgYWRkX2NoYW5uZWwgYiBpYyBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IGxlbiA+IFN5cy5tYXhfc3RyaW5nX2xlbmd0aCB0aGVuICAgKCogUFIjNTAwNCAqKVxuICAgIGludmFsaWRfYXJnIFwiQnVmZmVyLmFkZF9jaGFubmVsXCI7XG4gIGlmIGIucG9zaXRpb24gKyBsZW4gPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIGxlbjtcbiAgYWRkX2NoYW5uZWxfcmVjIGIgaWMgbGVuXG5cbmxldCBvdXRwdXRfYnVmZmVyIG9jIGIgPVxuICBvdXRwdXQgb2MgYi5idWZmZXIgMCBiLnBvc2l0aW9uXG5cbmxldCBjbG9zaW5nID0gZnVuY3Rpb25cbiAgfCAnKCcgLT4gJyknXG4gIHwgJ3snIC0+ICd9J1xuICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbigqIG9wZW5pbmcgYW5kIGNsb3Npbmc6IG9wZW4gYW5kIGNsb3NlIGNoYXJhY3RlcnMsIHR5cGljYWxseSAoIGFuZCApXG4gICBrOiBiYWxhbmNlIG9mIG9wZW5pbmcgYW5kIGNsb3NpbmcgY2hhcnNcbiAgIHM6IHRoZSBzdHJpbmcgd2hlcmUgd2UgYXJlIHNlYXJjaGluZ1xuICAgc3RhcnQ6IHRoZSBpbmRleCB3aGVyZSB3ZSBzdGFydCB0aGUgc2VhcmNoLiAqKVxubGV0IGFkdmFuY2VfdG9fY2xvc2luZyBvcGVuaW5nIGNsb3NpbmcgayBzIHN0YXJ0ID1cbiAgbGV0IHJlYyBhZHZhbmNlIGsgaSBsaW0gPVxuICAgIGlmIGkgPj0gbGltIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgICBpZiBzLltpXSA9IG9wZW5pbmcgdGhlbiBhZHZhbmNlIChrICsgMSkgKGkgKyAxKSBsaW0gZWxzZVxuICAgIGlmIHMuW2ldID0gY2xvc2luZyB0aGVuXG4gICAgICBpZiBrID0gMCB0aGVuIGkgZWxzZSBhZHZhbmNlIChrIC0gMSkgKGkgKyAxKSBsaW1cbiAgICBlbHNlIGFkdmFuY2UgayAoaSArIDEpIGxpbSBpblxuICBhZHZhbmNlIGsgc3RhcnQgKFN0cmluZy5sZW5ndGggcylcblxubGV0IGFkdmFuY2VfdG9fbm9uX2FscGhhIHMgc3RhcnQgPVxuICBsZXQgcmVjIGFkdmFuY2UgaSBsaW0gPVxuICAgIGlmIGkgPj0gbGltIHRoZW4gbGltIGVsc2VcbiAgICBtYXRjaCBzLltpXSB3aXRoXG4gICAgfCAnYScgLi4gJ3onIHwgJ0EnIC4uICdaJyB8ICcwJyAuLiAnOScgfCAnXycgLT4gYWR2YW5jZSAoaSArIDEpIGxpbVxuICAgIHwgXyAtPiBpIGluXG4gIGFkdmFuY2Ugc3RhcnQgKFN0cmluZy5sZW5ndGggcylcblxuKCogV2UgYXJlIGp1c3QgYXQgdGhlIGJlZ2lubmluZyBvZiBhbiBpZGVudCBpbiBzLCBzdGFydGluZyBhdCBzdGFydC4gKilcbmxldCBmaW5kX2lkZW50IHMgc3RhcnQgbGltID1cbiAgaWYgc3RhcnQgPj0gbGltIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgbWF0Y2ggcy5bc3RhcnRdIHdpdGhcbiAgKCogUGFyZW50aGVzaXplZCBpZGVudCA/ICopXG4gIHwgJygnIHwgJ3snIGFzIGMgLT5cbiAgICAgbGV0IG5ld19zdGFydCA9IHN0YXJ0ICsgMSBpblxuICAgICBsZXQgc3RvcCA9IGFkdmFuY2VfdG9fY2xvc2luZyBjIChjbG9zaW5nIGMpIDAgcyBuZXdfc3RhcnQgaW5cbiAgICAgU3RyaW5nLnN1YiBzIG5ld19zdGFydCAoc3RvcCAtIHN0YXJ0IC0gMSksIHN0b3AgKyAxXG4gICgqIFJlZ3VsYXIgaWRlbnQgKilcbiAgfCBfIC0+XG4gICAgIGxldCBzdG9wID0gYWR2YW5jZV90b19ub25fYWxwaGEgcyAoc3RhcnQgKyAxKSBpblxuICAgICBTdHJpbmcuc3ViIHMgc3RhcnQgKHN0b3AgLSBzdGFydCksIHN0b3BcblxuKCogU3Vic3RpdHV0ZSAkaWRlbnQsICQoaWRlbnQpLCBvciAke2lkZW50fSBpbiBzLFxuICAgIGFjY29yZGluZyB0byB0aGUgZnVuY3Rpb24gbWFwcGluZyBmLiAqKVxubGV0IGFkZF9zdWJzdGl0dXRlIGIgZiBzID1cbiAgbGV0IGxpbSA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgcmVjIHN1YnN0IHByZXZpb3VzIGkgPVxuICAgIGlmIGkgPCBsaW0gdGhlbiBiZWdpblxuICAgICAgbWF0Y2ggcy5baV0gd2l0aFxuICAgICAgfCAnJCcgYXMgY3VycmVudCB3aGVuIHByZXZpb3VzID0gJ1xcXFwnIC0+XG4gICAgICAgICBhZGRfY2hhciBiIGN1cnJlbnQ7XG4gICAgICAgICBzdWJzdCAnICcgKGkgKyAxKVxuICAgICAgfCAnJCcgLT5cbiAgICAgICAgIGxldCBqID0gaSArIDEgaW5cbiAgICAgICAgIGxldCBpZGVudCwgbmV4dF9pID0gZmluZF9pZGVudCBzIGogbGltIGluXG4gICAgICAgICBhZGRfc3RyaW5nIGIgKGYgaWRlbnQpO1xuICAgICAgICAgc3Vic3QgJyAnIG5leHRfaVxuICAgICAgfCBjdXJyZW50IHdoZW4gcHJldmlvdXMgPT0gJ1xcXFwnIC0+XG4gICAgICAgICBhZGRfY2hhciBiICdcXFxcJztcbiAgICAgICAgIGFkZF9jaGFyIGIgY3VycmVudDtcbiAgICAgICAgIHN1YnN0ICcgJyAoaSArIDEpXG4gICAgICB8ICdcXFxcJyBhcyBjdXJyZW50IC0+XG4gICAgICAgICBzdWJzdCBjdXJyZW50IChpICsgMSlcbiAgICAgIHwgY3VycmVudCAtPlxuICAgICAgICAgYWRkX2NoYXIgYiBjdXJyZW50O1xuICAgICAgICAgc3Vic3QgY3VycmVudCAoaSArIDEpXG4gICAgZW5kIGVsc2VcbiAgICBpZiBwcmV2aW91cyA9ICdcXFxcJyB0aGVuIGFkZF9jaGFyIGIgcHJldmlvdXMgaW5cbiAgc3Vic3QgJyAnIDBcblxubGV0IHRydW5jYXRlIGIgbGVuID1cbiAgICBpZiBsZW4gPCAwIHx8IGxlbiA+IGxlbmd0aCBiIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIFwiQnVmZmVyLnRydW5jYXRlXCJcbiAgICBlbHNlXG4gICAgICBiLnBvc2l0aW9uIDwtIGxlblxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBYYXZpZXIgTGVyb3kgYW5kIFBpZXJyZSBXZWlzLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljc1xub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRcblxubGV0IGtmcHJpbnRmIGsgbyAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfcHJpbnRmIChmdW4gbyBhY2MgLT4gb3V0cHV0X2FjYyBvIGFjYzsgayBvKSBvIEVuZF9vZl9hY2MgZm10XG5sZXQga2JwcmludGYgayBiIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9wcmludGYgKGZ1biBiIGFjYyAtPiBidWZwdXRfYWNjIGIgYWNjOyBrIGIpIGIgRW5kX29mX2FjYyBmbXRcbmxldCBpa2ZwcmludGYgayBvYyAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfaXByaW50ZiBrIG9jIGZtdFxuXG5sZXQgZnByaW50ZiBvYyBmbXQgPSBrZnByaW50ZiBpZ25vcmUgb2MgZm10XG5sZXQgYnByaW50ZiBiIGZtdCA9IGticHJpbnRmIGlnbm9yZSBiIGZtdFxubGV0IGlmcHJpbnRmIG9jIGZtdCA9IGlrZnByaW50ZiBpZ25vcmUgb2MgZm10XG5sZXQgcHJpbnRmIGZtdCA9IGZwcmludGYgc3Rkb3V0IGZtdFxubGV0IGVwcmludGYgZm10ID0gZnByaW50ZiBzdGRlcnIgZm10XG5cbmxldCBrc3ByaW50ZiBrIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbGV0IGsnICgpIGFjYyA9XG4gICAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgNjQgaW5cbiAgICBzdHJwdXRfYWNjIGJ1ZiBhY2M7XG4gICAgayAoQnVmZmVyLmNvbnRlbnRzIGJ1ZikgaW5cbiAgbWFrZV9wcmludGYgaycgKCkgRW5kX29mX2FjYyBmbXRcblxubGV0IHNwcmludGYgZm10ID0ga3NwcmludGYgKGZ1biBzIC0+IHMpIGZtdFxuXG5sZXQga3ByaW50ZiA9IGtzcHJpbnRmXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUga2V5ID0gc3RyaW5nXG50eXBlIGRvYyA9IHN0cmluZ1xudHlwZSB1c2FnZV9tc2cgPSBzdHJpbmdcbnR5cGUgYW5vbl9mdW4gPSAoc3RyaW5nIC0+IHVuaXQpXG5cbnR5cGUgc3BlYyA9XG4gIHwgVW5pdCBvZiAodW5pdCAtPiB1bml0KSAgICAgKCogQ2FsbCB0aGUgZnVuY3Rpb24gd2l0aCB1bml0IGFyZ3VtZW50ICopXG4gIHwgQm9vbCBvZiAoYm9vbCAtPiB1bml0KSAgICAgKCogQ2FsbCB0aGUgZnVuY3Rpb24gd2l0aCBhIGJvb2wgYXJndW1lbnQgKilcbiAgfCBTZXQgb2YgYm9vbCByZWYgICAgICAgICAgICAoKiBTZXQgdGhlIHJlZmVyZW5jZSB0byB0cnVlICopXG4gIHwgQ2xlYXIgb2YgYm9vbCByZWYgICAgICAgICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gZmFsc2UgKilcbiAgfCBTdHJpbmcgb2YgKHN0cmluZyAtPiB1bml0KSAoKiBDYWxsIHRoZSBmdW5jdGlvbiB3aXRoIGEgc3RyaW5nIGFyZ3VtZW50ICopXG4gIHwgU2V0X3N0cmluZyBvZiBzdHJpbmcgcmVmICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gdGhlIHN0cmluZyBhcmd1bWVudCAqKVxuICB8IEludCBvZiAoaW50IC0+IHVuaXQpICAgICAgICgqIENhbGwgdGhlIGZ1bmN0aW9uIHdpdGggYW4gaW50IGFyZ3VtZW50ICopXG4gIHwgU2V0X2ludCBvZiBpbnQgcmVmICAgICAgICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gdGhlIGludCBhcmd1bWVudCAqKVxuICB8IEZsb2F0IG9mIChmbG9hdCAtPiB1bml0KSAgICgqIENhbGwgdGhlIGZ1bmN0aW9uIHdpdGggYSBmbG9hdCBhcmd1bWVudCAqKVxuICB8IFNldF9mbG9hdCBvZiBmbG9hdCByZWYgICAgICgqIFNldCB0aGUgcmVmZXJlbmNlIHRvIHRoZSBmbG9hdCBhcmd1bWVudCAqKVxuICB8IFR1cGxlIG9mIHNwZWMgbGlzdCAgICAgICAgICgqIFRha2Ugc2V2ZXJhbCBhcmd1bWVudHMgYWNjb3JkaW5nIHRvIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWMgbGlzdCAqKVxuICB8IFN5bWJvbCBvZiBzdHJpbmcgbGlzdCAqIChzdHJpbmcgLT4gdW5pdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBUYWtlIG9uZSBvZiB0aGUgc3ltYm9scyBhcyBhcmd1bWVudCBhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBzeW1ib2wuICopXG4gIHwgUmVzdCBvZiAoc3RyaW5nIC0+IHVuaXQpICAgKCogU3RvcCBpbnRlcnByZXRpbmcga2V5d29yZHMgYW5kIGNhbGwgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gd2l0aCBlYWNoIHJlbWFpbmluZyBhcmd1bWVudCAqKVxuICB8IEV4cGFuZCBvZiAoc3RyaW5nIC0+IHN0cmluZyBhcnJheSkgKCogSWYgdGhlIHJlbWFpbmluZyBhcmd1bWVudHMgdG8gcHJvY2Vzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlIG9mIHRoZSBmb3JtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbW1wiLWZvb1wiOyBcImFyZ1wiXSBAIHJlc3RdIHdoZXJlIFwiZm9vXCIgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyZWQgYXMgW0V4cGFuZCBmXSwgdGhlbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50cyBbZiBcImFyZ1wiIEAgcmVzdF0gYXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWQuIE9ubHkgYWxsb3dlZCBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3BhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljXS4gKilcblxuZXhjZXB0aW9uIEJhZCBvZiBzdHJpbmdcbmV4Y2VwdGlvbiBIZWxwIG9mIHN0cmluZ1xuXG50eXBlIGVycm9yID1cbiAgfCBVbmtub3duIG9mIHN0cmluZ1xuICB8IFdyb25nIG9mIHN0cmluZyAqIHN0cmluZyAqIHN0cmluZyAgKCogb3B0aW9uLCBhY3R1YWwsIGV4cGVjdGVkICopXG4gIHwgTWlzc2luZyBvZiBzdHJpbmdcbiAgfCBNZXNzYWdlIG9mIHN0cmluZ1xuXG5leGNlcHRpb24gU3RvcCBvZiBlcnJvciAoKiB1c2VkIGludGVybmFsbHkgKilcblxub3BlbiBQcmludGZcblxubGV0IHJlYyBhc3NvYzMgeCBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgKHkxLCB5MiwgXykgOjogXyB3aGVuIHkxID0geCAtPiB5MlxuICB8IF8gOjogdCAtPiBhc3NvYzMgeCB0XG5cblxubGV0IHNwbGl0IHMgPVxuICBsZXQgaSA9IFN0cmluZy5pbmRleCBzICc9JyBpblxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIFN0cmluZy5zdWIgcyAwIGksIFN0cmluZy5zdWIgcyAoaSsxKSAobGVuLShpKzEpKVxuXG5cbmxldCBtYWtlX3N5bWxpc3QgcHJlZml4IHNlcCBzdWZmaXggbCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IFwiPG5vbmU+XCJcbiAgfCBoOjp0IC0+IChMaXN0LmZvbGRfbGVmdCAoZnVuIHggeSAtPiB4IF4gc2VwIF4geSkgKHByZWZpeCBeIGgpIHQpIF4gc3VmZml4XG5cblxubGV0IHByaW50X3NwZWMgYnVmIChrZXksIHNwZWMsIGRvYykgPVxuICBpZiBTdHJpbmcubGVuZ3RoIGRvYyA+IDAgdGhlblxuICAgIG1hdGNoIHNwZWMgd2l0aFxuICAgIHwgU3ltYm9sIChsLCBfKSAtPlxuICAgICAgICBicHJpbnRmIGJ1ZiBcIiAgJXMgJXMlc1xcblwiIGtleSAobWFrZV9zeW1saXN0IFwie1wiIFwifFwiIFwifVwiIGwpIGRvY1xuICAgIHwgXyAtPlxuICAgICAgICBicHJpbnRmIGJ1ZiBcIiAgJXMgJXNcXG5cIiBrZXkgZG9jXG5cblxubGV0IGhlbHBfYWN0aW9uICgpID0gcmFpc2UgKFN0b3AgKFVua25vd24gXCItaGVscFwiKSlcblxubGV0IGFkZF9oZWxwIHNwZWNsaXN0ID1cbiAgbGV0IGFkZDEgPVxuICAgIHRyeSBpZ25vcmUgKGFzc29jMyBcIi1oZWxwXCIgc3BlY2xpc3QpOyBbXVxuICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgICAgICBbXCItaGVscFwiLCBVbml0IGhlbHBfYWN0aW9uLCBcIiBEaXNwbGF5IHRoaXMgbGlzdCBvZiBvcHRpb25zXCJdXG4gIGFuZCBhZGQyID1cbiAgICB0cnkgaWdub3JlIChhc3NvYzMgXCItLWhlbHBcIiBzcGVjbGlzdCk7IFtdXG4gICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgICAgICAgIFtcIi0taGVscFwiLCBVbml0IGhlbHBfYWN0aW9uLCBcIiBEaXNwbGF5IHRoaXMgbGlzdCBvZiBvcHRpb25zXCJdXG4gIGluXG4gIHNwZWNsaXN0IEAgKGFkZDEgQCBhZGQyKVxuXG5cbmxldCB1c2FnZV9iIGJ1ZiBzcGVjbGlzdCBlcnJtc2cgPVxuICBicHJpbnRmIGJ1ZiBcIiVzXFxuXCIgZXJybXNnO1xuICBMaXN0Lml0ZXIgKHByaW50X3NwZWMgYnVmKSAoYWRkX2hlbHAgc3BlY2xpc3QpXG5cblxubGV0IHVzYWdlX3N0cmluZyBzcGVjbGlzdCBlcnJtc2cgPVxuICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgMjAwIGluXG4gIHVzYWdlX2IgYiBzcGVjbGlzdCBlcnJtc2c7XG4gIEJ1ZmZlci5jb250ZW50cyBiXG5cblxubGV0IHVzYWdlIHNwZWNsaXN0IGVycm1zZyA9XG4gIGVwcmludGYgXCIlc1wiICh1c2FnZV9zdHJpbmcgc3BlY2xpc3QgZXJybXNnKVxuXG5cbmxldCBjdXJyZW50ID0gcmVmIDBcblxubGV0IGJvb2xfb2Zfc3RyaW5nX29wdCB4ID1cbiAgdHJ5IFNvbWUgKGJvb2xfb2Zfc3RyaW5nIHgpXG4gIHdpdGggSW52YWxpZF9hcmd1bWVudCBfIC0+IE5vbmVcblxubGV0IGludF9vZl9zdHJpbmdfb3B0IHggPVxuICB0cnkgU29tZSAoaW50X29mX3N0cmluZyB4KVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbmxldCBmbG9hdF9vZl9zdHJpbmdfb3B0IHggPVxuICB0cnkgU29tZSAoZmxvYXRfb2Zfc3RyaW5nIHgpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxubGV0IHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljX2F1eCBhbGxvd19leHBhbmQgY3VycmVudCBhcmd2IHNwZWNsaXN0IGFub25mdW4gZXJybXNnID1cbiAgbGV0IGluaXRwb3MgPSAhY3VycmVudCBpblxuICBsZXQgY29udmVydF9lcnJvciBlcnJvciA9XG4gICAgKCogY29udmVydCBhbiBpbnRlcm5hbCBlcnJvciB0byBhIEJhZC9IZWxwIGV4Y2VwdGlvblxuICAgICAgICpvciogYWRkIHRoZSBwcm9ncmFtIG5hbWUgYXMgYSBwcmVmaXggYW5kIHRoZSB1c2FnZSBtZXNzYWdlIGFzIGEgc3VmZml4XG4gICAgICAgdG8gYW4gdXNlci1yYWlzZWQgQmFkIGV4Y2VwdGlvbi5cbiAgICAqKVxuICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAyMDAgaW5cbiAgICBsZXQgcHJvZ25hbWUgPSBpZiBpbml0cG9zIDwgKEFycmF5Lmxlbmd0aCAhYXJndikgdGhlbiAhYXJndi4oaW5pdHBvcykgZWxzZSBcIig/KVwiIGluXG4gICAgYmVnaW4gbWF0Y2ggZXJyb3Igd2l0aFxuICAgICAgfCBVbmtub3duIFwiLWhlbHBcIiAtPiAoKVxuICAgICAgfCBVbmtub3duIFwiLS1oZWxwXCIgLT4gKClcbiAgICAgIHwgVW5rbm93biBzIC0+XG4gICAgICAgICAgYnByaW50ZiBiIFwiJXM6IHVua25vd24gb3B0aW9uICclcycuXFxuXCIgcHJvZ25hbWUgc1xuICAgICAgfCBNaXNzaW5nIHMgLT5cbiAgICAgICAgICBicHJpbnRmIGIgXCIlczogb3B0aW9uICclcycgbmVlZHMgYW4gYXJndW1lbnQuXFxuXCIgcHJvZ25hbWUgc1xuICAgICAgfCBXcm9uZyAob3B0LCBhcmcsIGV4cGVjdGVkKSAtPlxuICAgICAgICAgIGJwcmludGYgYiBcIiVzOiB3cm9uZyBhcmd1bWVudCAnJXMnOyBvcHRpb24gJyVzJyBleHBlY3RzICVzLlxcblwiXG4gICAgICAgICAgICAgICAgICBwcm9nbmFtZSBhcmcgb3B0IGV4cGVjdGVkXG4gICAgICB8IE1lc3NhZ2UgcyAtPiAoKiB1c2VyIGVycm9yIG1lc3NhZ2UgKilcbiAgICAgICAgICBicHJpbnRmIGIgXCIlczogJXMuXFxuXCIgcHJvZ25hbWUgc1xuICAgIGVuZDtcbiAgICB1c2FnZV9iIGIgIXNwZWNsaXN0IGVycm1zZztcbiAgICBpZiBlcnJvciA9IFVua25vd24gXCItaGVscFwiIHx8IGVycm9yID0gVW5rbm93biBcIi0taGVscFwiXG4gICAgdGhlbiBIZWxwIChCdWZmZXIuY29udGVudHMgYilcbiAgICBlbHNlIEJhZCAoQnVmZmVyLmNvbnRlbnRzIGIpXG4gIGluXG4gIGluY3IgY3VycmVudDtcbiAgd2hpbGUgIWN1cnJlbnQgPCAoQXJyYXkubGVuZ3RoICFhcmd2KSBkb1xuICAgIGJlZ2luIHRyeVxuICAgICAgbGV0IHMgPSAhYXJndi4oIWN1cnJlbnQpIGluXG4gICAgICBpZiBTdHJpbmcubGVuZ3RoIHMgPj0gMSAmJiBzLlswXSA9ICctJyB0aGVuIGJlZ2luXG4gICAgICAgIGxldCBhY3Rpb24sIGZvbGxvdyA9XG4gICAgICAgICAgdHJ5IGFzc29jMyBzICFzcGVjbGlzdCwgTm9uZVxuICAgICAgICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgICAgdHJ5XG4gICAgICAgICAgICBsZXQga2V5d29yZCwgYXJnID0gc3BsaXQgcyBpblxuICAgICAgICAgICAgYXNzb2MzIGtleXdvcmQgIXNwZWNsaXN0LCBTb21lIGFyZ1xuICAgICAgICAgIHdpdGggTm90X2ZvdW5kIC0+IHJhaXNlIChTdG9wIChVbmtub3duIHMpKVxuICAgICAgICBpblxuICAgICAgICBsZXQgbm9fYXJnICgpID1cbiAgICAgICAgICBtYXRjaCBmb2xsb3cgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgIHwgU29tZSBhcmcgLT4gcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwibm8gYXJndW1lbnRcIikpKSBpblxuICAgICAgICBsZXQgZ2V0X2FyZyAoKSA9XG4gICAgICAgICAgbWF0Y2ggZm9sbG93IHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgaWYgIWN1cnJlbnQgKyAxIDwgKEFycmF5Lmxlbmd0aCAhYXJndikgdGhlbiAhYXJndi4oIWN1cnJlbnQgKyAxKVxuICAgICAgICAgICAgICBlbHNlIHJhaXNlIChTdG9wIChNaXNzaW5nIHMpKVxuICAgICAgICAgIHwgU29tZSBhcmcgLT4gYXJnXG4gICAgICAgIGluXG4gICAgICAgIGxldCBjb25zdW1lX2FyZyAoKSA9XG4gICAgICAgICAgbWF0Y2ggZm9sbG93IHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gaW5jciBjdXJyZW50XG4gICAgICAgICAgfCBTb21lIF8gLT4gKClcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IHJlYyB0cmVhdF9hY3Rpb24gPSBmdW5jdGlvblxuICAgICAgICB8IFVuaXQgZiAtPiBmICgpO1xuICAgICAgICB8IEJvb2wgZiAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGJvb2xfb2Zfc3RyaW5nX29wdCBhcmcgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcImEgYm9vbGVhblwiKSkpXG4gICAgICAgICAgICB8IFNvbWUgcyAtPiBmIHNcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IFNldCByIC0+IG5vX2FyZyAoKTsgciA6PSB0cnVlO1xuICAgICAgICB8IENsZWFyIHIgLT4gbm9fYXJnICgpOyByIDo9IGZhbHNlO1xuICAgICAgICB8IFN0cmluZyBmIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgZiBhcmc7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBTeW1ib2wgKHN5bWIsIGYpIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgaWYgTGlzdC5tZW0gYXJnIHN5bWIgdGhlbiBiZWdpblxuICAgICAgICAgICAgICBmIGFyZztcbiAgICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICAgICAgICByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJvbmUgb2Y6IFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeIChtYWtlX3N5bWxpc3QgXCJcIiBcIiBcIiBcIlwiIHN5bWIpKSkpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgfCBTZXRfc3RyaW5nIHIgLT5cbiAgICAgICAgICAgIHIgOj0gZ2V0X2FyZyAoKTtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IEludCBmIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggaW50X29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhbiBpbnRlZ2VyXCIpKSlcbiAgICAgICAgICAgIHwgU29tZSB4IC0+IGYgeFxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgU2V0X2ludCByIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggaW50X29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhbiBpbnRlZ2VyXCIpKSlcbiAgICAgICAgICAgIHwgU29tZSB4IC0+IHIgOj0geFxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgRmxvYXQgZiAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGZsb2F0X29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhIGZsb2F0XCIpKSlcbiAgICAgICAgICAgIHwgU29tZSB4IC0+IGYgeFxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgU2V0X2Zsb2F0IHIgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBmbG9hdF9vZl9zdHJpbmdfb3B0IGFyZyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwiYSBmbG9hdFwiKSkpXG4gICAgICAgICAgICB8IFNvbWUgeCAtPiByIDo9IHhcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IFR1cGxlIHNwZWNzIC0+XG4gICAgICAgICAgICBMaXN0Lml0ZXIgdHJlYXRfYWN0aW9uIHNwZWNzO1xuICAgICAgICB8IFJlc3QgZiAtPlxuICAgICAgICAgICAgd2hpbGUgIWN1cnJlbnQgPCAoQXJyYXkubGVuZ3RoICFhcmd2KSAtIDEgZG9cbiAgICAgICAgICAgICAgZiAhYXJndi4oIWN1cnJlbnQgKyAxKTtcbiAgICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgICAgICBkb25lO1xuICAgICAgICB8IEV4cGFuZCBmIC0+XG4gICAgICAgICAgICBpZiBub3QgYWxsb3dfZXhwYW5kIHRoZW5cbiAgICAgICAgICAgICAgcmFpc2UgKEludmFsaWRfYXJndW1lbnQgXCJBcmcuRXhwYW5kIGlzIGlzIG9ubHkgYWxsb3dlZCB3aXRoIEFyZy5wYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pY1wiKTtcbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBsZXQgbmV3YXJnID0gZiBhcmcgaW5cbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IEFycmF5LnN1YiAhYXJndiAwICghY3VycmVudCArIDEpXG4gICAgICAgICAgICBhbmQgYWZ0ZXIgPSBBcnJheS5zdWIgIWFyZ3YgKCFjdXJyZW50ICsgMSkgKChBcnJheS5sZW5ndGggIWFyZ3YpIC0gIWN1cnJlbnQgLSAxKSBpblxuICAgICAgICAgICAgYXJndjo9IEFycmF5LmNvbmNhdCBbYmVmb3JlO25ld2FyZzthZnRlcl07XG4gICAgICAgIGluXG4gICAgICAgIHRyZWF0X2FjdGlvbiBhY3Rpb24gZW5kXG4gICAgICBlbHNlIGFub25mdW4gc1xuICAgIHdpdGggfCBCYWQgbSAtPiByYWlzZSAoY29udmVydF9lcnJvciAoTWVzc2FnZSBtKSk7XG4gICAgICAgICB8IFN0b3AgZSAtPiByYWlzZSAoY29udmVydF9lcnJvciBlKTtcbiAgICBlbmQ7XG4gICAgaW5jciBjdXJyZW50XG4gIGRvbmVcblxubGV0IHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljIGN1cnJlbnQgYXJndiBzcGVjbGlzdCBhbm9uZnVuIGVycm1zZyA9XG4gIHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljX2F1eCB0cnVlIGN1cnJlbnQgYXJndiBzcGVjbGlzdCBhbm9uZnVuIGVycm1zZ1xuXG5sZXQgcGFyc2VfYXJndl9keW5hbWljID8oY3VycmVudD1jdXJyZW50KSBhcmd2IHNwZWNsaXN0IGFub25mdW4gZXJybXNnID1cbiAgcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNfYXV4IGZhbHNlIGN1cnJlbnQgKHJlZiBhcmd2KSBzcGVjbGlzdCBhbm9uZnVuIGVycm1zZ1xuXG5cbmxldCBwYXJzZV9hcmd2ID8oY3VycmVudD1jdXJyZW50KSBhcmd2IHNwZWNsaXN0IGFub25mdW4gZXJybXNnID1cbiAgcGFyc2VfYXJndl9keW5hbWljIH5jdXJyZW50OmN1cnJlbnQgYXJndiAocmVmIHNwZWNsaXN0KSBhbm9uZnVuIGVycm1zZ1xuXG5cbmxldCBwYXJzZSBsIGYgbXNnID1cbiAgdHJ5XG4gICAgcGFyc2VfYXJndiBTeXMuYXJndiBsIGYgbXNnXG4gIHdpdGhcbiAgfCBCYWQgbXNnIC0+IGVwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAyXG4gIHwgSGVscCBtc2cgLT4gcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMFxuXG5cbmxldCBwYXJzZV9keW5hbWljIGwgZiBtc2cgPVxuICB0cnlcbiAgICBwYXJzZV9hcmd2X2R5bmFtaWMgU3lzLmFyZ3YgbCBmIG1zZ1xuICB3aXRoXG4gIHwgQmFkIG1zZyAtPiBlcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMlxuICB8IEhlbHAgbXNnIC0+IHByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDBcblxubGV0IHBhcnNlX2V4cGFuZCBsIGYgbXNnID1cbiAgdHJ5XG4gICAgbGV0IGFyZ3YgPSByZWYgU3lzLmFyZ3YgaW5cbiAgICBsZXQgc3BlYyA9IHJlZiBsIGluXG4gICAgbGV0IGN1cnJlbnQgPSByZWYgKCFjdXJyZW50KSBpblxuICAgIHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljIGN1cnJlbnQgYXJndiBzcGVjIGYgbXNnXG4gIHdpdGhcbiAgfCBCYWQgbXNnIC0+IGVwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAyXG4gIHwgSGVscCBtc2cgLT4gcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMFxuXG5cbmxldCBzZWNvbmRfd29yZCBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgcmVjIGxvb3AgbiA9XG4gICAgaWYgbiA+PSBsZW4gdGhlbiBsZW5cbiAgICBlbHNlIGlmIHMuW25dID0gJyAnIHRoZW4gbG9vcCAobisxKVxuICAgIGVsc2UgblxuICBpblxuICBtYXRjaCBTdHJpbmcuaW5kZXggcyAnXFx0JyB3aXRoXG4gIHwgbiAtPiBsb29wIChuKzEpXG4gIHwgZXhjZXB0aW9uIE5vdF9mb3VuZCAtPlxuICAgICAgYmVnaW4gbWF0Y2ggU3RyaW5nLmluZGV4IHMgJyAnIHdpdGhcbiAgICAgIHwgbiAtPiBsb29wIChuKzEpXG4gICAgICB8IGV4Y2VwdGlvbiBOb3RfZm91bmQgLT4gbGVuXG4gICAgICBlbmRcblxuXG5sZXQgbWF4X2FyZ19sZW4gY3VyIChrd2QsIHNwZWMsIGRvYykgPVxuICBtYXRjaCBzcGVjIHdpdGhcbiAgfCBTeW1ib2wgXyAtPiBtYXggY3VyIChTdHJpbmcubGVuZ3RoIGt3ZClcbiAgfCBfIC0+IG1heCBjdXIgKFN0cmluZy5sZW5ndGgga3dkICsgc2Vjb25kX3dvcmQgZG9jKVxuXG5cbmxldCByZXBsYWNlX2xlYWRpbmdfdGFiIHMgPVxuICBsZXQgc2VlbiA9IHJlZiBmYWxzZSBpblxuICBTdHJpbmcubWFwIChmdW5jdGlvbiAnXFx0JyB3aGVuIG5vdCAhc2VlbiAtPiBzZWVuIDo9IHRydWU7ICcgJyB8IGMgLT4gYykgc1xuXG5sZXQgYWRkX3BhZGRpbmcgbGVuIGtzZCA9XG4gIG1hdGNoIGtzZCB3aXRoXG4gIHwgKF8sIF8sIFwiXCIpIC0+XG4gICAgICAoKiBEbyBub3QgcGFkIHVuZG9jdW1lbnRlZCBvcHRpb25zLCBzbyB0aGF0IHRoZXkgc3RpbGwgZG9uJ3Qgc2hvdyB1cCB3aGVuXG4gICAgICAgKiBydW4gdGhyb3VnaCBbdXNhZ2VdIG9yIFtwYXJzZV0uICopXG4gICAgICBrc2RcbiAgfCAoa3dkLCAoU3ltYm9sIF8gYXMgc3BlYyksIG1zZykgLT5cbiAgICAgIGxldCBjdXRjb2wgPSBzZWNvbmRfd29yZCBtc2cgaW5cbiAgICAgIGxldCBzcGFjZXMgPSBTdHJpbmcubWFrZSAoKG1heCAwIChsZW4gLSBjdXRjb2wpKSArIDMpICcgJyBpblxuICAgICAgKGt3ZCwgc3BlYywgXCJcXG5cIiBeIHNwYWNlcyBeIHJlcGxhY2VfbGVhZGluZ190YWIgbXNnKVxuICB8IChrd2QsIHNwZWMsIG1zZykgLT5cbiAgICAgIGxldCBjdXRjb2wgPSBzZWNvbmRfd29yZCBtc2cgaW5cbiAgICAgIGxldCBrd2RfbGVuID0gU3RyaW5nLmxlbmd0aCBrd2QgaW5cbiAgICAgIGxldCBkaWZmID0gbGVuIC0ga3dkX2xlbiAtIGN1dGNvbCBpblxuICAgICAgaWYgZGlmZiA8PSAwIHRoZW5cbiAgICAgICAgKGt3ZCwgc3BlYywgcmVwbGFjZV9sZWFkaW5nX3RhYiBtc2cpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBzcGFjZXMgPSBTdHJpbmcubWFrZSBkaWZmICcgJyBpblxuICAgICAgICBsZXQgcHJlZml4ID0gU3RyaW5nLnN1YiAocmVwbGFjZV9sZWFkaW5nX3RhYiBtc2cpIDAgY3V0Y29sIGluXG4gICAgICAgIGxldCBzdWZmaXggPSBTdHJpbmcuc3ViIG1zZyBjdXRjb2wgKFN0cmluZy5sZW5ndGggbXNnIC0gY3V0Y29sKSBpblxuICAgICAgICAoa3dkLCBzcGVjLCBwcmVmaXggXiBzcGFjZXMgXiBzdWZmaXgpXG5cblxubGV0IGFsaWduID8obGltaXQ9bWF4X2ludCkgc3BlY2xpc3QgPVxuICBsZXQgY29tcGxldGVkID0gYWRkX2hlbHAgc3BlY2xpc3QgaW5cbiAgbGV0IGxlbiA9IExpc3QuZm9sZF9sZWZ0IG1heF9hcmdfbGVuIDAgY29tcGxldGVkIGluXG4gIGxldCBsZW4gPSBtaW4gbGVuIGxpbWl0IGluXG4gIExpc3QubWFwIChhZGRfcGFkZGluZyBsZW4pIGNvbXBsZXRlZFxuXG5sZXQgdHJpbV9jciBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBpZiBsZW4gPiAwICYmIFN0cmluZy5nZXQgcyAobGVuIC0gMSkgPSAnXFxyJyB0aGVuXG4gICAgU3RyaW5nLnN1YiBzIDAgKGxlbiAtIDEpXG4gIGVsc2VcbiAgICBzXG5cbmxldCByZWFkX2F1eCB0cmltIHNlcCBmaWxlID1cbiAgbGV0IGljID0gb3Blbl9pbl9iaW4gZmlsZSBpblxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAyMDAgaW5cbiAgbGV0IHdvcmRzID0gcmVmIFtdIGluXG4gIGxldCBzdGFzaCAoKSA9XG4gICAgbGV0IHdvcmQgPSAgKEJ1ZmZlci5jb250ZW50cyBidWYpIGluXG4gICAgbGV0IHdvcmQgPSBpZiB0cmltIHRoZW4gdHJpbV9jciB3b3JkIGVsc2Ugd29yZCBpblxuICAgIHdvcmRzIDo9IHdvcmQgOjogIXdvcmRzO1xuICAgIEJ1ZmZlci5jbGVhciBidWZcbiAgaW5cbiAgbGV0IHJlYyByZWFkICgpID1cbiAgICB0cnlcbiAgICAgIGxldCBjID0gaW5wdXRfY2hhciBpYyBpblxuICAgICAgaWYgYyA9IHNlcCB0aGVuIGJlZ2luXG4gICAgICAgIHN0YXNoICgpOyByZWFkICgpXG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmIGM7IHJlYWQgKClcbiAgICAgIGVuZFxuICAgIHdpdGggRW5kX29mX2ZpbGUgLT5cbiAgICAgIGlmIEJ1ZmZlci5sZW5ndGggYnVmID4gMCB0aGVuXG4gICAgICAgIHN0YXNoICgpIGluXG4gIHJlYWQgKCk7XG4gIGNsb3NlX2luIGljO1xuICBBcnJheS5vZl9saXN0IChMaXN0LnJldiAhd29yZHMpXG5cbmxldCByZWFkX2FyZyA9IHJlYWRfYXV4IHRydWUgJ1xcbidcblxubGV0IHJlYWRfYXJnMCA9IHJlYWRfYXV4IGZhbHNlICdcXHgwMCdcblxubGV0IHdyaXRlX2F1eCBzZXAgZmlsZSBhcmdzID1cbiAgbGV0IG9jID0gb3Blbl9vdXRfYmluIGZpbGUgaW5cbiAgQXJyYXkuaXRlciAoZnVuIHMgLT4gZnByaW50ZiBvYyBcIiVzJWNcIiBzIHNlcCkgYXJncztcbiAgY2xvc2Vfb3V0IG9jXG5cbmxldCB3cml0ZV9hcmcgPSB3cml0ZV9hdXggJ1xcbidcblxubGV0IHdyaXRlX2FyZzAgPSB3cml0ZV9hdXggJ1xceDAwJ1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHN0YXQgPSB7XG4gIG1pbm9yX3dvcmRzIDogZmxvYXQ7XG4gIHByb21vdGVkX3dvcmRzIDogZmxvYXQ7XG4gIG1ham9yX3dvcmRzIDogZmxvYXQ7XG4gIG1pbm9yX2NvbGxlY3Rpb25zIDogaW50O1xuICBtYWpvcl9jb2xsZWN0aW9ucyA6IGludDtcbiAgaGVhcF93b3JkcyA6IGludDtcbiAgaGVhcF9jaHVua3MgOiBpbnQ7XG4gIGxpdmVfd29yZHMgOiBpbnQ7XG4gIGxpdmVfYmxvY2tzIDogaW50O1xuICBmcmVlX3dvcmRzIDogaW50O1xuICBmcmVlX2Jsb2NrcyA6IGludDtcbiAgbGFyZ2VzdF9mcmVlIDogaW50O1xuICBmcmFnbWVudHMgOiBpbnQ7XG4gIGNvbXBhY3Rpb25zIDogaW50O1xuICB0b3BfaGVhcF93b3JkcyA6IGludDtcbiAgc3RhY2tfc2l6ZSA6IGludDtcbn1cblxudHlwZSBjb250cm9sID0ge1xuICBtdXRhYmxlIG1pbm9yX2hlYXBfc2l6ZSA6IGludDtcbiAgbXV0YWJsZSBtYWpvcl9oZWFwX2luY3JlbWVudCA6IGludDtcbiAgbXV0YWJsZSBzcGFjZV9vdmVyaGVhZCA6IGludDtcbiAgbXV0YWJsZSB2ZXJib3NlIDogaW50O1xuICBtdXRhYmxlIG1heF9vdmVyaGVhZCA6IGludDtcbiAgbXV0YWJsZSBzdGFja19saW1pdCA6IGludDtcbiAgbXV0YWJsZSBhbGxvY2F0aW9uX3BvbGljeSA6IGludDtcbiAgd2luZG93X3NpemUgOiBpbnQ7XG59XG5cbmV4dGVybmFsIHN0YXQgOiB1bml0IC0+IHN0YXQgPSBcImNhbWxfZ2Nfc3RhdFwiXG5leHRlcm5hbCBxdWlja19zdGF0IDogdW5pdCAtPiBzdGF0ID0gXCJjYW1sX2djX3F1aWNrX3N0YXRcIlxuZXh0ZXJuYWwgY291bnRlcnMgOiB1bml0IC0+IChmbG9hdCAqIGZsb2F0ICogZmxvYXQpID0gXCJjYW1sX2djX2NvdW50ZXJzXCJcbmV4dGVybmFsIG1pbm9yX3dvcmRzIDogdW5pdCAtPiAoZmxvYXQgW0B1bmJveGVkXSlcbiAgPSBcImNhbWxfZ2NfbWlub3Jfd29yZHNcIiBcImNhbWxfZ2NfbWlub3Jfd29yZHNfdW5ib3hlZFwiXG5leHRlcm5hbCBnZXQgOiB1bml0IC0+IGNvbnRyb2wgPSBcImNhbWxfZ2NfZ2V0XCJcbmV4dGVybmFsIHNldCA6IGNvbnRyb2wgLT4gdW5pdCA9IFwiY2FtbF9nY19zZXRcIlxuZXh0ZXJuYWwgbWlub3IgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfZ2NfbWlub3JcIlxuZXh0ZXJuYWwgbWFqb3Jfc2xpY2UgOiBpbnQgLT4gaW50ID0gXCJjYW1sX2djX21ham9yX3NsaWNlXCJcbmV4dGVybmFsIG1ham9yIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2djX21ham9yXCJcbmV4dGVybmFsIGZ1bGxfbWFqb3IgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfZ2NfZnVsbF9tYWpvclwiXG5leHRlcm5hbCBjb21wYWN0IDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2djX2NvbXBhY3Rpb25cIlxuZXh0ZXJuYWwgZ2V0X21pbm9yX2ZyZWUgOiB1bml0IC0+IGludCA9IFwiY2FtbF9nZXRfbWlub3JfZnJlZVwiXG5leHRlcm5hbCBnZXRfYnVja2V0IDogaW50IC0+IGludCA9IFwiY2FtbF9nZXRfbWFqb3JfYnVja2V0XCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIGdldF9jcmVkaXQgOiB1bml0IC0+IGludCA9IFwiY2FtbF9nZXRfbWFqb3JfY3JlZGl0XCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIGh1Z2VfZmFsbGJhY2tfY291bnQgOiB1bml0IC0+IGludCA9IFwiY2FtbF9nY19odWdlX2ZhbGxiYWNrX2NvdW50XCJcblxub3BlbiBQcmludGZcblxubGV0IHByaW50X3N0YXQgYyA9XG4gIGxldCBzdCA9IHN0YXQgKCkgaW5cbiAgZnByaW50ZiBjIFwibWlub3JfY29sbGVjdGlvbnM6ICVkXFxuXCIgc3QubWlub3JfY29sbGVjdGlvbnM7XG4gIGZwcmludGYgYyBcIm1ham9yX2NvbGxlY3Rpb25zOiAlZFxcblwiIHN0Lm1ham9yX2NvbGxlY3Rpb25zO1xuICBmcHJpbnRmIGMgXCJjb21wYWN0aW9uczogICAgICAgJWRcXG5cIiBzdC5jb21wYWN0aW9ucztcbiAgZnByaW50ZiBjIFwiXFxuXCI7XG4gIGxldCBsMSA9IFN0cmluZy5sZW5ndGggKHNwcmludGYgXCIlLjBmXCIgc3QubWlub3Jfd29yZHMpIGluXG4gIGZwcmludGYgYyBcIm1pbm9yX3dvcmRzOiAgICAlKi4wZlxcblwiIGwxIHN0Lm1pbm9yX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJwcm9tb3RlZF93b3JkczogJSouMGZcXG5cIiBsMSBzdC5wcm9tb3RlZF93b3JkcztcbiAgZnByaW50ZiBjIFwibWFqb3Jfd29yZHM6ICAgICUqLjBmXFxuXCIgbDEgc3QubWFqb3Jfd29yZHM7XG4gIGZwcmludGYgYyBcIlxcblwiO1xuICBsZXQgbDIgPSBTdHJpbmcubGVuZ3RoIChzcHJpbnRmIFwiJWRcIiBzdC50b3BfaGVhcF93b3JkcykgaW5cbiAgZnByaW50ZiBjIFwidG9wX2hlYXBfd29yZHM6ICUqZFxcblwiIGwyIHN0LnRvcF9oZWFwX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJoZWFwX3dvcmRzOiAgICAgJSpkXFxuXCIgbDIgc3QuaGVhcF93b3JkcztcbiAgZnByaW50ZiBjIFwibGl2ZV93b3JkczogICAgICUqZFxcblwiIGwyIHN0LmxpdmVfd29yZHM7XG4gIGZwcmludGYgYyBcImZyZWVfd29yZHM6ICAgICAlKmRcXG5cIiBsMiBzdC5mcmVlX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJsYXJnZXN0X2ZyZWU6ICAgJSpkXFxuXCIgbDIgc3QubGFyZ2VzdF9mcmVlO1xuICBmcHJpbnRmIGMgXCJmcmFnbWVudHM6ICAgICAgJSpkXFxuXCIgbDIgc3QuZnJhZ21lbnRzO1xuICBmcHJpbnRmIGMgXCJcXG5cIjtcbiAgZnByaW50ZiBjIFwibGl2ZV9ibG9ja3M6ICVkXFxuXCIgc3QubGl2ZV9ibG9ja3M7XG4gIGZwcmludGYgYyBcImZyZWVfYmxvY2tzOiAlZFxcblwiIHN0LmZyZWVfYmxvY2tzO1xuICBmcHJpbnRmIGMgXCJoZWFwX2NodW5rczogJWRcXG5cIiBzdC5oZWFwX2NodW5rc1xuXG5cbmxldCBhbGxvY2F0ZWRfYnl0ZXMgKCkgPVxuICBsZXQgKG1pLCBwcm8sIG1hKSA9IGNvdW50ZXJzICgpIGluXG4gIChtaSArLiBtYSAtLiBwcm8pICouIGZsb2F0X29mX2ludCAoU3lzLndvcmRfc2l6ZSAvIDgpXG5cblxuZXh0ZXJuYWwgZmluYWxpc2UgOiAoJ2EgLT4gdW5pdCkgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9maW5hbF9yZWdpc3RlclwiXG5leHRlcm5hbCBmaW5hbGlzZV9sYXN0IDogKHVuaXQgLT4gdW5pdCkgLT4gJ2EgLT4gdW5pdCA9XG4gIFwiY2FtbF9maW5hbF9yZWdpc3Rlcl9jYWxsZWRfd2l0aG91dF92YWx1ZVwiXG5leHRlcm5hbCBmaW5hbGlzZV9yZWxlYXNlIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2ZpbmFsX3JlbGVhc2VcIlxuXG5cbnR5cGUgYWxhcm0gPSBib29sIHJlZlxudHlwZSBhbGFybV9yZWMgPSB7YWN0aXZlIDogYWxhcm07IGYgOiB1bml0IC0+IHVuaXR9XG5cbmxldCByZWMgY2FsbF9hbGFybSBhcmVjID1cbiAgaWYgIShhcmVjLmFjdGl2ZSkgdGhlbiBiZWdpblxuICAgIGZpbmFsaXNlIGNhbGxfYWxhcm0gYXJlYztcbiAgICBhcmVjLmYgKCk7XG4gIGVuZFxuXG5cbmxldCBjcmVhdGVfYWxhcm0gZiA9XG4gIGxldCBhcmVjID0geyBhY3RpdmUgPSByZWYgdHJ1ZTsgZiA9IGYgfSBpblxuICBmaW5hbGlzZSBjYWxsX2FsYXJtIGFyZWM7XG4gIGFyZWMuYWN0aXZlXG5cblxubGV0IGRlbGV0ZV9hbGFybSBhID0gYSA6PSBmYWxzZVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNZXNzYWdlIGRpZ2VzdCAoTUQ1KSAqKVxuXG50eXBlIHQgPSBzdHJpbmdcblxubGV0IGNvbXBhcmUgPSBTdHJpbmcuY29tcGFyZVxubGV0IGVxdWFsID0gU3RyaW5nLmVxdWFsXG5cbmV4dGVybmFsIHVuc2FmZV9zdHJpbmc6IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHQgPSBcImNhbWxfbWQ1X3N0cmluZ1wiXG5leHRlcm5hbCBjaGFubmVsOiBpbl9jaGFubmVsIC0+IGludCAtPiB0ID0gXCJjYW1sX21kNV9jaGFuXCJcblxubGV0IHN0cmluZyBzdHIgPVxuICB1bnNhZmVfc3RyaW5nIHN0ciAwIChTdHJpbmcubGVuZ3RoIHN0cilcblxubGV0IGJ5dGVzIGIgPSBzdHJpbmcgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgYilcblxubGV0IHN1YnN0cmluZyBzdHIgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBTdHJpbmcubGVuZ3RoIHN0ciAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiRGlnZXN0LnN1YnN0cmluZ1wiXG4gIGVsc2UgdW5zYWZlX3N0cmluZyBzdHIgb2ZzIGxlblxuXG5sZXQgc3ViYnl0ZXMgYiBvZnMgbGVuID0gc3Vic3RyaW5nIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGIpIG9mcyBsZW5cblxubGV0IGZpbGUgZmlsZW5hbWUgPVxuICBsZXQgaWMgPSBvcGVuX2luX2JpbiBmaWxlbmFtZSBpblxuICBtYXRjaCBjaGFubmVsIGljICgtMSkgd2l0aFxuICAgIHwgZCAtPiBjbG9zZV9pbiBpYzsgZFxuICAgIHwgZXhjZXB0aW9uIGUgLT4gY2xvc2VfaW4gaWM7IHJhaXNlIGVcblxubGV0IG91dHB1dCBjaGFuIGRpZ2VzdCA9XG4gIG91dHB1dF9zdHJpbmcgY2hhbiBkaWdlc3RcblxubGV0IGlucHV0IGNoYW4gPSByZWFsbHlfaW5wdXRfc3RyaW5nIGNoYW4gMTZcblxubGV0IGNoYXJfaGV4IG4gPVxuICBDaGFyLnVuc2FmZV9jaHIgKG4gKyBpZiBuIDwgMTAgdGhlbiBDaGFyLmNvZGUgJzAnIGVsc2UgKENoYXIuY29kZSAnYScgLSAxMCkpXG5cbmxldCB0b19oZXggZCA9XG4gIGlmIFN0cmluZy5sZW5ndGggZCA8PiAxNiB0aGVuIGludmFsaWRfYXJnIFwiRGlnZXN0LnRvX2hleFwiO1xuICBsZXQgcmVzdWx0ID0gQnl0ZXMuY3JlYXRlIDMyIGluXG4gIGZvciBpID0gMCB0byAxNSBkb1xuICAgIGxldCB4ID0gQ2hhci5jb2RlIGQuW2ldIGluXG4gICAgQnl0ZXMudW5zYWZlX3NldCByZXN1bHQgKGkqMikgKGNoYXJfaGV4ICh4IGxzciA0KSk7XG4gICAgQnl0ZXMudW5zYWZlX3NldCByZXN1bHQgKGkqMisxKSAoY2hhcl9oZXggKHggbGFuZCAweDBmKSk7XG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzdWx0XG5cbmxldCBmcm9tX2hleCBzID1cbiAgaWYgU3RyaW5nLmxlbmd0aCBzIDw+IDMyIHRoZW4gaW52YWxpZF9hcmcgXCJEaWdlc3QuZnJvbV9oZXhcIjtcbiAgbGV0IGRpZ2l0IGMgPVxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgJzAnLi4nOScgLT4gQ2hhci5jb2RlIGMgLSBDaGFyLmNvZGUgJzAnXG4gICAgfCAnQScuLidGJyAtPiBDaGFyLmNvZGUgYyAtIENoYXIuY29kZSAnQScgKyAxMFxuICAgIHwgJ2EnLi4nZicgLT4gQ2hhci5jb2RlIGMgLSBDaGFyLmNvZGUgJ2EnICsgMTBcbiAgICB8IF8gLT4gcmFpc2UgKEludmFsaWRfYXJndW1lbnQgXCJEaWdlc3QuZnJvbV9oZXhcIilcbiAgaW5cbiAgbGV0IGJ5dGUgaSA9IGRpZ2l0IHMuW2ldIGxzbCA0ICsgZGlnaXQgcy5baSsxXSBpblxuICBsZXQgcmVzdWx0ID0gQnl0ZXMuY3JlYXRlIDE2IGluXG4gIGZvciBpID0gMCB0byAxNSBkb1xuICAgIEJ5dGVzLnNldCByZXN1bHQgaSAoQ2hhci5jaHIgKGJ5dGUgKDIgKiBpKSkpO1xuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc3VsdFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBQc2V1ZG8tcmFuZG9tIG51bWJlciBnZW5lcmF0b3JcbiAgIFRoaXMgaXMgYSBsYWdnZWQtRmlib25hY2NpIEYoNTUsIDI0LCArKSB3aXRoIGEgbW9kaWZpZWQgYWRkaXRpb25cbiAgIGZ1bmN0aW9uIHRvIGVuaGFuY2UgdGhlIG1peGluZyBvZiBiaXRzLlxuICAgSWYgd2UgdXNlIG5vcm1hbCBhZGRpdGlvbiwgdGhlIGxvdy1vcmRlciBiaXQgZmFpbHMgdGVzdHMgMSBhbmQgN1xuICAgb2YgdGhlIERpZWhhcmQgdGVzdCBzdWl0ZSwgYW5kIGJpdHMgMSBhbmQgMiBhbHNvIGZhaWwgdGVzdCA3LlxuICAgSWYgd2UgdXNlIG11bHRpcGxpY2F0aW9uIGFzIHN1Z2dlc3RlZCBieSBNYXJzYWdsaWEsIGl0IGRvZXNuJ3QgZmFyZVxuICAgbXVjaCBiZXR0ZXIuXG4gICBCeSBtaXhpbmcgdGhlIGJpdHMgb2Ygb25lIG9mIHRoZSBudW1iZXJzIGJlZm9yZSBhZGRpdGlvbiAoWE9SIHRoZVxuICAgNSBoaWdoLW9yZGVyIGJpdHMgaW50byB0aGUgbG93LW9yZGVyIGJpdHMpLCB3ZSBnZXQgYSBnZW5lcmF0b3IgdGhhdFxuICAgcGFzc2VzIGFsbCB0aGUgRGllaGFyZCB0ZXN0cy5cbiopXG5cbmV4dGVybmFsIHJhbmRvbV9zZWVkOiB1bml0IC0+IGludCBhcnJheSA9IFwiY2FtbF9zeXNfcmFuZG9tX3NlZWRcIlxuXG5tb2R1bGUgU3RhdGUgPSBzdHJ1Y3RcblxuICB0eXBlIHQgPSB7IHN0IDogaW50IGFycmF5OyBtdXRhYmxlIGlkeCA6IGludCB9XG5cbiAgbGV0IG5ld19zdGF0ZSAoKSA9IHsgc3QgPSBBcnJheS5tYWtlIDU1IDA7IGlkeCA9IDAgfVxuICBsZXQgYXNzaWduIHN0MSBzdDIgPVxuICAgIEFycmF5LmJsaXQgc3QyLnN0IDAgc3QxLnN0IDAgNTU7XG4gICAgc3QxLmlkeCA8LSBzdDIuaWR4XG5cblxuICBsZXQgZnVsbF9pbml0IHMgc2VlZCA9XG4gICAgbGV0IGNvbWJpbmUgYWNjdSB4ID0gRGlnZXN0LnN0cmluZyAoYWNjdSBeIHN0cmluZ19vZl9pbnQgeCkgaW5cbiAgICBsZXQgZXh0cmFjdCBkID1cbiAgICAgIENoYXIuY29kZSBkLlswXSArIChDaGFyLmNvZGUgZC5bMV0gbHNsIDgpICsgKENoYXIuY29kZSBkLlsyXSBsc2wgMTYpXG4gICAgICArIChDaGFyLmNvZGUgZC5bM10gbHNsIDI0KVxuICAgIGluXG4gICAgbGV0IHNlZWQgPSBpZiBBcnJheS5sZW5ndGggc2VlZCA9IDAgdGhlbiBbfCAwIHxdIGVsc2Ugc2VlZCBpblxuICAgIGxldCBsID0gQXJyYXkubGVuZ3RoIHNlZWQgaW5cbiAgICBmb3IgaSA9IDAgdG8gNTQgZG9cbiAgICAgIHMuc3QuKGkpIDwtIGk7XG4gICAgZG9uZTtcbiAgICBsZXQgYWNjdSA9IHJlZiBcInhcIiBpblxuICAgIGZvciBpID0gMCB0byA1NCArIG1heCA1NSBsIGRvXG4gICAgICBsZXQgaiA9IGkgbW9kIDU1IGluXG4gICAgICBsZXQgayA9IGkgbW9kIGwgaW5cbiAgICAgIGFjY3UgOj0gY29tYmluZSAhYWNjdSBzZWVkLihrKTtcbiAgICAgIHMuc3QuKGopIDwtIChzLnN0LihqKSBseG9yIGV4dHJhY3QgIWFjY3UpIGxhbmQgMHgzRkZGRkZGRjsgICgqIFBSIzU1NzUgKilcbiAgICBkb25lO1xuICAgIHMuaWR4IDwtIDBcblxuXG4gIGxldCBtYWtlIHNlZWQgPVxuICAgIGxldCByZXN1bHQgPSBuZXdfc3RhdGUgKCkgaW5cbiAgICBmdWxsX2luaXQgcmVzdWx0IHNlZWQ7XG4gICAgcmVzdWx0XG5cblxuICBsZXQgbWFrZV9zZWxmX2luaXQgKCkgPSBtYWtlIChyYW5kb21fc2VlZCAoKSlcblxuICBsZXQgY29weSBzID1cbiAgICBsZXQgcmVzdWx0ID0gbmV3X3N0YXRlICgpIGluXG4gICAgYXNzaWduIHJlc3VsdCBzO1xuICAgIHJlc3VsdFxuXG5cbiAgKCogUmV0dXJucyAzMCByYW5kb20gYml0cyBhcyBhbiBpbnRlZ2VyIDAgPD0geCA8IDEwNzM3NDE4MjQgKilcbiAgbGV0IGJpdHMgcyA9XG4gICAgcy5pZHggPC0gKHMuaWR4ICsgMSkgbW9kIDU1O1xuICAgIGxldCBjdXJ2YWwgPSBzLnN0LihzLmlkeCkgaW5cbiAgICBsZXQgbmV3dmFsID0gcy5zdC4oKHMuaWR4ICsgMjQpIG1vZCA1NSlcbiAgICAgICAgICAgICAgICAgKyAoY3VydmFsIGx4b3IgKChjdXJ2YWwgbHNyIDI1KSBsYW5kIDB4MUYpKSBpblxuICAgIGxldCBuZXd2YWwzMCA9IG5ld3ZhbCBsYW5kIDB4M0ZGRkZGRkYgaW4gICgqIFBSIzU1NzUgKilcbiAgICBzLnN0LihzLmlkeCkgPC0gbmV3dmFsMzA7XG4gICAgbmV3dmFsMzBcblxuXG4gIGxldCByZWMgaW50YXV4IHMgbiA9XG4gICAgbGV0IHIgPSBiaXRzIHMgaW5cbiAgICBsZXQgdiA9IHIgbW9kIG4gaW5cbiAgICBpZiByIC0gdiA+IDB4M0ZGRkZGRkYgLSBuICsgMSB0aGVuIGludGF1eCBzIG4gZWxzZSB2XG5cbiAgbGV0IGludCBzIGJvdW5kID1cbiAgICBpZiBib3VuZCA+IDB4M0ZGRkZGRkYgfHwgYm91bmQgPD0gMFxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJSYW5kb20uaW50XCJcbiAgICBlbHNlIGludGF1eCBzIGJvdW5kXG5cblxuICBsZXQgcmVjIGludDMyYXV4IHMgbiA9XG4gICAgbGV0IGIxID0gSW50MzIub2ZfaW50IChiaXRzIHMpIGluXG4gICAgbGV0IGIyID0gSW50MzIuc2hpZnRfbGVmdCAoSW50MzIub2ZfaW50IChiaXRzIHMgbGFuZCAxKSkgMzAgaW5cbiAgICBsZXQgciA9IEludDMyLmxvZ29yIGIxIGIyIGluXG4gICAgbGV0IHYgPSBJbnQzMi5yZW0gciBuIGluXG4gICAgaWYgSW50MzIuc3ViIHIgdiA+IEludDMyLmFkZCAoSW50MzIuc3ViIEludDMyLm1heF9pbnQgbikgMWxcbiAgICB0aGVuIGludDMyYXV4IHMgblxuICAgIGVsc2UgdlxuXG4gIGxldCBpbnQzMiBzIGJvdW5kID1cbiAgICBpZiBib3VuZCA8PSAwbFxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJSYW5kb20uaW50MzJcIlxuICAgIGVsc2UgaW50MzJhdXggcyBib3VuZFxuXG5cbiAgbGV0IHJlYyBpbnQ2NGF1eCBzIG4gPVxuICAgIGxldCBiMSA9IEludDY0Lm9mX2ludCAoYml0cyBzKSBpblxuICAgIGxldCBiMiA9IEludDY0LnNoaWZ0X2xlZnQgKEludDY0Lm9mX2ludCAoYml0cyBzKSkgMzAgaW5cbiAgICBsZXQgYjMgPSBJbnQ2NC5zaGlmdF9sZWZ0IChJbnQ2NC5vZl9pbnQgKGJpdHMgcyBsYW5kIDcpKSA2MCBpblxuICAgIGxldCByID0gSW50NjQubG9nb3IgYjEgKEludDY0LmxvZ29yIGIyIGIzKSBpblxuICAgIGxldCB2ID0gSW50NjQucmVtIHIgbiBpblxuICAgIGlmIEludDY0LnN1YiByIHYgPiBJbnQ2NC5hZGQgKEludDY0LnN1YiBJbnQ2NC5tYXhfaW50IG4pIDFMXG4gICAgdGhlbiBpbnQ2NGF1eCBzIG5cbiAgICBlbHNlIHZcblxuICBsZXQgaW50NjQgcyBib3VuZCA9XG4gICAgaWYgYm91bmQgPD0gMExcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiUmFuZG9tLmludDY0XCJcbiAgICBlbHNlIGludDY0YXV4IHMgYm91bmRcblxuXG4gIGxldCBuYXRpdmVpbnQgPVxuICAgIGlmIE5hdGl2ZWludC5zaXplID0gMzJcbiAgICB0aGVuIGZ1biBzIGJvdW5kIC0+IE5hdGl2ZWludC5vZl9pbnQzMiAoaW50MzIgcyAoTmF0aXZlaW50LnRvX2ludDMyIGJvdW5kKSlcbiAgICBlbHNlIGZ1biBzIGJvdW5kIC0+IEludDY0LnRvX25hdGl2ZWludCAoaW50NjQgcyAoSW50NjQub2ZfbmF0aXZlaW50IGJvdW5kKSlcblxuXG4gICgqIFJldHVybnMgYSBmbG9hdCAwIDw9IHggPD0gMSB3aXRoIGF0IG1vc3QgNjAgYml0cyBvZiBwcmVjaXNpb24uICopXG4gIGxldCByYXdmbG9hdCBzID1cbiAgICBsZXQgc2NhbGUgPSAxMDczNzQxODI0LjAgICgqIDJeMzAgKilcbiAgICBhbmQgcjEgPSBQZXJ2YXNpdmVzLmZsb2F0IChiaXRzIHMpXG4gICAgYW5kIHIyID0gUGVydmFzaXZlcy5mbG9hdCAoYml0cyBzKVxuICAgIGluIChyMSAvLiBzY2FsZSArLiByMikgLy4gc2NhbGVcblxuXG4gIGxldCBmbG9hdCBzIGJvdW5kID0gcmF3ZmxvYXQgcyAqLiBib3VuZFxuXG4gIGxldCBib29sIHMgPSAoYml0cyBzIGxhbmQgMSA9IDApXG5cbmVuZFxuXG4oKiBUaGlzIGlzIHRoZSBzdGF0ZSB5b3UgZ2V0IHdpdGggW2luaXQgMjcxODI4MThdIGFuZCB0aGVuIGFwcGx5aW5nXG4gICB0aGUgXCJsYW5kIDB4M0ZGRkZGRkZcIiBmaWx0ZXIgdG8gdGhlbS4gIFNlZSAjNTU3NSwgIzU3OTMsICM1OTc3LiAqKVxubGV0IGRlZmF1bHQgPSB7XG4gIFN0YXRlLnN0ID0gW3xcbiAgICAgIDB4M2FlMjUyMmI7IDB4MWQ4ZDQ2MzQ7IDB4MTViNGZhZDA7IDB4MThiMTRhY2U7IDB4MTJmOGEzYzQ7IDB4M2IwODZjNDc7XG4gICAgICAweDE2ZDQ2N2Q2OyAweDEwMWQ5MWM3OyAweDMyMWRmMTc3OyAweDAxNzZjMTkzOyAweDFmZjcyYmYxOyAweDFlODg5MTA5O1xuICAgICAgMHgwYjQ2NGIxODsgMHgyYjg2Yjk3YzsgMHgwODkxZGE0ODsgMHgwMzEzNzQ2MzsgMHgwODVhYzVhMTsgMHgxNWQ2MWYyZjtcbiAgICAgIDB4M2JjZWQzNTk7IDB4MjljMWMxMzI7IDB4M2E4Njc2NmU7IDB4MzY2ZDhjODY7IDB4MWY1YjYyMjI7IDB4M2NlMWI1OWY7XG4gICAgICAweDJlYmY3OGUxOyAweDI3Y2QxYjg2OyAweDI1OGYzZGMzOyAweDM4OWE4MTk0OyAweDAyZTRjNDRjOyAweDE4YzQzZjdkO1xuICAgICAgMHgwZjZlNTM0ZjsgMHgxZTdkZjM1OTsgMHgwNTVkMGI3ZTsgMHgxMGU4NGU3ZTsgMHgxMjYxOThlNDsgMHgwZTc3MjJjYjtcbiAgICAgIDB4MWNiZWRlMjg7IDB4MzM5MWI5NjQ7IDB4M2Q0MGU5MmE7IDB4MGM1OTkzM2Q7IDB4MGI4Y2QwYjc7IDB4MjRlZmZmMWM7XG4gICAgICAweDI4MDNmZGFhOyAweDA4ZWJjNzJlOyAweDBmNTIyZTMyOyAweDA1Mzk4ZWRjOyAweDIxNDRhMDRjOyAweDBhZWYzY2JkO1xuICAgICAgMHgwMWFkNDcxOTsgMHgzNWI5M2NkNjsgMHgyYTU1OWQ0ZjsgMHgxZTZmZDc2ODsgMHgyNmUyN2YzNjsgMHgxODZmMThjMztcbiAgICAgIDB4MmZiZjk2N2E7XG4gICAgfF07XG4gIFN0YXRlLmlkeCA9IDA7XG59XG5cbmxldCBiaXRzICgpID0gU3RhdGUuYml0cyBkZWZhdWx0XG5sZXQgaW50IGJvdW5kID0gU3RhdGUuaW50IGRlZmF1bHQgYm91bmRcbmxldCBpbnQzMiBib3VuZCA9IFN0YXRlLmludDMyIGRlZmF1bHQgYm91bmRcbmxldCBuYXRpdmVpbnQgYm91bmQgPSBTdGF0ZS5uYXRpdmVpbnQgZGVmYXVsdCBib3VuZFxubGV0IGludDY0IGJvdW5kID0gU3RhdGUuaW50NjQgZGVmYXVsdCBib3VuZFxubGV0IGZsb2F0IHNjYWxlID0gU3RhdGUuZmxvYXQgZGVmYXVsdCBzY2FsZVxubGV0IGJvb2wgKCkgPSBTdGF0ZS5ib29sIGRlZmF1bHRcblxubGV0IGZ1bGxfaW5pdCBzZWVkID0gU3RhdGUuZnVsbF9pbml0IGRlZmF1bHQgc2VlZFxubGV0IGluaXQgc2VlZCA9IFN0YXRlLmZ1bGxfaW5pdCBkZWZhdWx0IFt8IHNlZWQgfF1cbmxldCBzZWxmX2luaXQgKCkgPSBmdWxsX2luaXQgKHJhbmRvbV9zZWVkKCkpXG5cbigqIE1hbmlwdWxhdGluZyB0aGUgY3VycmVudCBzdGF0ZS4gKilcblxubGV0IGdldF9zdGF0ZSAoKSA9IFN0YXRlLmNvcHkgZGVmYXVsdFxubGV0IHNldF9zdGF0ZSBzID0gU3RhdGUuYXNzaWduIGRlZmF1bHQgc1xuXG4oKioqKioqKioqKioqKioqKioqKipcblxuKCogVGVzdCBmdW5jdGlvbnMuICBOb3QgaW5jbHVkZWQgaW4gdGhlIGxpYnJhcnkuXG4gICBUaGUgW2NoaXNxdWFyZV0gZnVuY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCB3aXRoIG4gPiAxMHIuXG4gICBJdCByZXR1cm5zIGEgdHJpcGxlIChsb3csIGFjdHVhbCwgaGlnaCkuXG4gICBJZiBsb3cgPD0gYWN0dWFsIDw9IGhpZ2gsIHRoZSBbZ10gZnVuY3Rpb24gcGFzc2VkIHRoZSB0ZXN0LFxuICAgb3RoZXJ3aXNlIGl0IGZhaWxlZC5cblxuICBTb21lIHJlc3VsdHM6XG5cbmluaXQgMjcxODI4MTg7IGNoaXNxdWFyZSBpbnQgMTAwMDAwIDEwMDBcbmluaXQgMjcxODI4MTg7IGNoaXNxdWFyZSBpbnQgMTAwMDAwIDEwMFxuaW5pdCAyNzE4MjgxODsgY2hpc3F1YXJlIGludCAxMDAwMDAgNTAwMFxuaW5pdCAyNzE4MjgxODsgY2hpc3F1YXJlIGludCAxMDAwMDAwIDEwMDBcbmluaXQgMjcxODI4MTg7IGNoaXNxdWFyZSBpbnQgMTAwMDAwIDEwMjRcbmluaXQgMjk5NzkyNjQzOyBjaGlzcXVhcmUgaW50IDEwMDAwMCAxMDI0XG5pbml0IDE0MTQyMTM2OyBjaGlzcXVhcmUgaW50IDEwMDAwMCAxMDI0XG5pbml0IDI3MTgyODE4OyBpbml0X2RpZmYgMTAyNDsgY2hpc3F1YXJlIGRpZmYgMTAwMDAwIDEwMjRcbmluaXQgMjcxODI4MTg7IGluaXRfZGlmZiAxMDA7IGNoaXNxdWFyZSBkaWZmIDEwMDAwMCAxMDBcbmluaXQgMjcxODI4MTg7IGluaXRfZGlmZjIgMTAyNDsgY2hpc3F1YXJlIGRpZmYyIDEwMDAwMCAxMDI0XG5pbml0IDI3MTgyODE4OyBpbml0X2RpZmYyIDEwMDsgY2hpc3F1YXJlIGRpZmYyIDEwMDAwMCAxMDBcbmluaXQgMTQxNDIxMzY7IGluaXRfZGlmZjIgMTAwOyBjaGlzcXVhcmUgZGlmZjIgMTAwMDAwIDEwMFxuaW5pdCAyOTk3OTI2NDM7IGluaXRfZGlmZjIgMTAwOyBjaGlzcXVhcmUgZGlmZjIgMTAwMDAwIDEwMFxuLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5MzYuNzU0NDQ2Nzk2NjMyNDY1LCA5OTcuNSwgMTA2My4yNDU1NTMyMDMzNjc1NClcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg4MC4sIDg5Ljc0MDAwMDAwMDAwNTIzODcsIDEyMC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoNDg1OC41Nzg2NDM3NjI2OSwgNTA0NS41LCA1MTQxLjQyMTM1NjIzNzMxKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID1cbig5MzYuNzU0NDQ2Nzk2NjMyNDY1LCA5NDQuODA1OTk5OTk5OTgyMzA1LCAxMDYzLjI0NTU1MzIwMzM2NzU0KVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDk2MC4sIDEwMTkuMTk3NDQwMDAwMDAzNTUsIDEwODguKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDk2MC4sIDEwNTkuMzE3NzYwMDAwMDA1MzYsIDEwODguKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDk2MC4sIDEwMzkuOTg0NjM5OTk5OTk1MTIsIDEwODguKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDk2MC4sIDEwNTQuMzgyMDc5OTk5OTk1NzcsIDEwODguKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDgwLiwgOTAuMDk2MDAwMDAwMDA1LCAxMjAuKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDk2MC4sIDEwNzYuNzg3MjAwMDAwMDA2MTIsIDEwODguKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDgwLiwgODUuMTc2MDAwMDAwMDA2NzUyMSwgMTIwLilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg4MC4sIDg1LjIxNjAwMDAwMDAwMDM0OTIsIDEyMC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoODAuLCA4MC42MjIwMDAwMDAwMDMwMjY4LCAxMjAuKVxuXG4qKVxuXG4oKiBSZXR1cm4gdGhlIHN1bSBvZiB0aGUgc3F1YXJlcyBvZiB2W2kwLGkxWyAqKVxubGV0IHJlYyBzdW1zcSB2IGkwIGkxID1cbiAgaWYgaTAgPj0gaTEgdGhlbiAwLjBcbiAgZWxzZSBpZiBpMSA9IGkwICsgMSB0aGVuIFBlcnZhc2l2ZXMuZmxvYXQgdi4oaTApICouIFBlcnZhc2l2ZXMuZmxvYXQgdi4oaTApXG4gIGVsc2Ugc3Vtc3EgdiBpMCAoKGkwK2kxKS8yKSArLiBzdW1zcSB2ICgoaTAraTEpLzIpIGkxXG5cblxubGV0IGNoaXNxdWFyZSBnIG4gciA9XG4gIGlmIG4gPD0gMTAgKiByIHRoZW4gaW52YWxpZF9hcmcgXCJjaGlzcXVhcmVcIjtcbiAgbGV0IGYgPSBBcnJheS5tYWtlIHIgMCBpblxuICBmb3IgaSA9IDEgdG8gbiBkb1xuICAgIGxldCB0ID0gZyByIGluXG4gICAgZi4odCkgPC0gZi4odCkgKyAxXG4gIGRvbmU7XG4gIGxldCB0ID0gc3Vtc3EgZiAwIHJcbiAgYW5kIHIgPSBQZXJ2YXNpdmVzLmZsb2F0IHJcbiAgYW5kIG4gPSBQZXJ2YXNpdmVzLmZsb2F0IG4gaW5cbiAgbGV0IHNyID0gMi4wICouIHNxcnQgciBpblxuICAociAtLiBzciwgICAociAqLiB0IC8uIG4pIC0uIG4sICAgciArLiBzcilcblxuXG4oKiBUaGlzIGlzIHRvIHRlc3QgZm9yIGxpbmVhciBkZXBlbmRlbmNpZXMgYmV0d2VlbiBzdWNjZXNzaXZlIHJhbmRvbSBudW1iZXJzLlxuKilcbmxldCBzdCA9IHJlZiAwXG5sZXQgaW5pdF9kaWZmIHIgPSBzdCA6PSBpbnQgclxubGV0IGRpZmYgciA9XG4gIGxldCB4MSA9ICFzdFxuICBhbmQgeDIgPSBpbnQgclxuICBpblxuICBzdCA6PSB4MjtcbiAgaWYgeDEgPj0geDIgdGhlblxuICAgIHgxIC0geDJcbiAgZWxzZVxuICAgIHIgKyB4MSAtIHgyXG5cblxubGV0IHN0MSA9IHJlZiAwXG5hbmQgc3QyID0gcmVmIDBcblxuXG4oKiBUaGlzIGlzIHRvIHRlc3QgZm9yIHF1YWRyYXRpYyBkZXBlbmRlbmNpZXMgYmV0d2VlbiBzdWNjZXNzaXZlIHJhbmRvbVxuICAgbnVtYmVycy5cbiopXG5sZXQgaW5pdF9kaWZmMiByID0gc3QxIDo9IGludCByOyBzdDIgOj0gaW50IHJcbmxldCBkaWZmMiByID1cbiAgbGV0IHgxID0gIXN0MVxuICBhbmQgeDIgPSAhc3QyXG4gIGFuZCB4MyA9IGludCByXG4gIGluXG4gIHN0MSA6PSB4MjtcbiAgc3QyIDo9IHgzO1xuICAoeDMgLSB4MiAtIHgyICsgeDEgKyAyKnIpIG1vZCByXG5cblxuKioqKioqKioqKioqKioqKioqKiopXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEhhc2ggdGFibGVzICopXG5cbmV4dGVybmFsIHNlZWRlZF9oYXNoX3BhcmFtIDpcbiAgaW50IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gaW50ID0gXCJjYW1sX2hhc2hcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgb2xkX2hhc2hfcGFyYW0gOlxuICBpbnQgLT4gaW50IC0+ICdhIC0+IGludCA9IFwiY2FtbF9oYXNoX3VuaXZfcGFyYW1cIiBbQEBub2FsbG9jXVxuXG5sZXQgaGFzaCB4ID0gc2VlZGVkX2hhc2hfcGFyYW0gMTAgMTAwIDAgeFxubGV0IGhhc2hfcGFyYW0gbjEgbjIgeCA9IHNlZWRlZF9oYXNoX3BhcmFtIG4xIG4yIDAgeFxubGV0IHNlZWRlZF9oYXNoIHNlZWQgeCA9IHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCBzZWVkIHhcblxuKCogV2UgZG8gZHluYW1pYyBoYXNoaW5nLCBhbmQgcmVzaXplIHRoZSB0YWJsZSBhbmQgcmVoYXNoIHRoZSBlbGVtZW50c1xuICAgd2hlbiBidWNrZXRzIGJlY29tZSB0b28gbG9uZy4gKilcblxudHlwZSAoJ2EsICdiKSB0ID1cbiAgeyBtdXRhYmxlIHNpemU6IGludDsgICAgICAgICAgICAgICAgICAgICAgICAoKiBudW1iZXIgb2YgZW50cmllcyAqKVxuICAgIG11dGFibGUgZGF0YTogKCdhLCAnYikgYnVja2V0bGlzdCBhcnJheTsgICgqIHRoZSBidWNrZXRzICopXG4gICAgbXV0YWJsZSBzZWVkOiBpbnQ7ICAgICAgICAgICAgICAgICAgICAgICAgKCogZm9yIHJhbmRvbWl6YXRpb24gKilcbiAgICBtdXRhYmxlIGluaXRpYWxfc2l6ZTogaW50OyAgICAgICAgICAgICAgICAoKiBpbml0aWFsIGFycmF5IHNpemUgKilcbiAgfVxuXG5hbmQgKCdhLCAnYikgYnVja2V0bGlzdCA9XG4gICAgRW1wdHlcbiAgfCBDb25zIG9mIHsgbXV0YWJsZSBrZXk6ICdhO1xuICAgICAgICAgICAgICBtdXRhYmxlIGRhdGE6ICdiO1xuICAgICAgICAgICAgICBtdXRhYmxlIG5leHQ6ICgnYSwgJ2IpIGJ1Y2tldGxpc3QgfVxuXG4oKiBUaGUgc2lnbiBvZiBpbml0aWFsX3NpemUgZW5jb2RlcyB0aGUgZmFjdCB0aGF0IGEgdHJhdmVyc2FsIGlzXG4gICBvbmdvaW5nIG9yIG5vdC5cblxuICAgVGhpcyBkaXNhYmxlcyB0aGUgZWZmaWNpZW50IGluIHBsYWNlIGltcGxlbWVudGF0aW9uIG9mIHJlc2l6aW5nLlxuKilcblxubGV0IG9uZ29pbmdfdHJhdmVyc2FsIGggPVxuICBPYmouc2l6ZSAoT2JqLnJlcHIgaCkgPCA0ICgqIGNvbXBhdGliaWxpdHkgd2l0aCBvbGQgaGFzaCB0YWJsZXMgKilcbiAgfHwgaC5pbml0aWFsX3NpemUgPCAwXG5cbmxldCBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGggPVxuICBoLmluaXRpYWxfc2l6ZSA8LSAtIGguaW5pdGlhbF9zaXplXG5cbigqIFRvIHBpY2sgcmFuZG9tIHNlZWRzIGlmIHJlcXVlc3RlZCAqKVxuXG5sZXQgcmFuZG9taXplZF9kZWZhdWx0ID1cbiAgbGV0IHBhcmFtcyA9XG4gICAgdHJ5IFN5cy5nZXRlbnYgXCJPQ0FNTFJVTlBBUkFNXCIgd2l0aCBOb3RfZm91bmQgLT5cbiAgICB0cnkgU3lzLmdldGVudiBcIkNBTUxSVU5QQVJBTVwiIHdpdGggTm90X2ZvdW5kIC0+IFwiXCIgaW5cbiAgU3RyaW5nLmNvbnRhaW5zIHBhcmFtcyAnUidcblxubGV0IHJhbmRvbWl6ZWQgPSByZWYgcmFuZG9taXplZF9kZWZhdWx0XG5cbmxldCByYW5kb21pemUgKCkgPSByYW5kb21pemVkIDo9IHRydWVcbmxldCBpc19yYW5kb21pemVkICgpID0gIXJhbmRvbWl6ZWRcblxubGV0IHBybmcgPSBsYXp5IChSYW5kb20uU3RhdGUubWFrZV9zZWxmX2luaXQoKSlcblxuKCogQ3JlYXRpbmcgYSBmcmVzaCwgZW1wdHkgdGFibGUgKilcblxubGV0IHJlYyBwb3dlcl8yX2Fib3ZlIHggbiA9XG4gIGlmIHggPj0gbiB0aGVuIHhcbiAgZWxzZSBpZiB4ICogMiA+IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIHRoZW4geFxuICBlbHNlIHBvd2VyXzJfYWJvdmUgKHggKiAyKSBuXG5cbmxldCBjcmVhdGUgPyhyYW5kb20gPSAhcmFuZG9taXplZCkgaW5pdGlhbF9zaXplID1cbiAgbGV0IHMgPSBwb3dlcl8yX2Fib3ZlIDE2IGluaXRpYWxfc2l6ZSBpblxuICBsZXQgc2VlZCA9IGlmIHJhbmRvbSB0aGVuIFJhbmRvbS5TdGF0ZS5iaXRzIChMYXp5LmZvcmNlIHBybmcpIGVsc2UgMCBpblxuICB7IGluaXRpYWxfc2l6ZSA9IHM7IHNpemUgPSAwOyBzZWVkID0gc2VlZDsgZGF0YSA9IEFycmF5Lm1ha2UgcyBFbXB0eSB9XG5cbmxldCBjbGVhciBoID1cbiAgaC5zaXplIDwtIDA7XG4gIGxldCBsZW4gPSBBcnJheS5sZW5ndGggaC5kYXRhIGluXG4gIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgaC5kYXRhLihpKSA8LSBFbXB0eVxuICBkb25lXG5cbmxldCByZXNldCBoID1cbiAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBoLmRhdGEgaW5cbiAgaWYgT2JqLnNpemUgKE9iai5yZXByIGgpIDwgNCAoKiBjb21wYXRpYmlsaXR5IHdpdGggb2xkIGhhc2ggdGFibGVzICopXG4gICAgfHwgbGVuID0gYWJzIGguaW5pdGlhbF9zaXplIHRoZW5cbiAgICBjbGVhciBoXG4gIGVsc2UgYmVnaW5cbiAgICBoLnNpemUgPC0gMDtcbiAgICBoLmRhdGEgPC0gQXJyYXkubWFrZSAoYWJzIGguaW5pdGlhbF9zaXplKSBFbXB0eVxuICBlbmRcblxubGV0IGNvcHlfYnVja2V0bGlzdCA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gRW1wdHlcbiAgfCBDb25zIHtrZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICBsZXQgcmVjIGxvb3AgcHJlYyA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT4gKClcbiAgICAgICAgfCBDb25zIHtrZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgICAgICBsZXQgciA9IENvbnMge2tleTsgZGF0YTsgbmV4dH0gaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIHByZWMgd2l0aFxuICAgICAgICAgICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICAgIHwgQ29ucyBwcmVjIC0+ICBwcmVjLm5leHQgPC0gclxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgbG9vcCByIG5leHRcbiAgICAgIGluXG4gICAgICBsZXQgciA9IENvbnMge2tleTsgZGF0YTsgbmV4dH0gaW5cbiAgICAgIGxvb3AgciBuZXh0O1xuICAgICAgclxuXG5sZXQgY29weSBoID0geyBoIHdpdGggZGF0YSA9IEFycmF5Lm1hcCBjb3B5X2J1Y2tldGxpc3QgaC5kYXRhIH1cblxubGV0IGxlbmd0aCBoID0gaC5zaXplXG5cbmxldCByZXNpemUgaW5kZXhmdW4gaCA9XG4gIGxldCBvZGF0YSA9IGguZGF0YSBpblxuICBsZXQgb3NpemUgPSBBcnJheS5sZW5ndGggb2RhdGEgaW5cbiAgbGV0IG5zaXplID0gb3NpemUgKiAyIGluXG4gIGlmIG5zaXplIDwgU3lzLm1heF9hcnJheV9sZW5ndGggdGhlbiBiZWdpblxuICAgIGxldCBuZGF0YSA9IEFycmF5Lm1ha2UgbnNpemUgRW1wdHkgaW5cbiAgICBsZXQgbmRhdGFfdGFpbCA9IEFycmF5Lm1ha2UgbnNpemUgRW1wdHkgaW5cbiAgICBsZXQgaW5wbGFjZSA9IG5vdCAob25nb2luZ190cmF2ZXJzYWwgaCkgaW5cbiAgICBoLmRhdGEgPC0gbmRhdGE7ICAgICAgICAgICgqIHNvIHRoYXQgaW5kZXhmdW4gc2VlcyB0aGUgbmV3IGJ1Y2tldCBjb3VudCAqKVxuICAgIGxldCByZWMgaW5zZXJ0X2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+ICgpXG4gICAgICB8IENvbnMge2tleTsgZGF0YTsgbmV4dH0gYXMgY2VsbCAtPlxuICAgICAgICAgIGxldCBjZWxsID1cbiAgICAgICAgICAgIGlmIGlucGxhY2UgdGhlbiBjZWxsXG4gICAgICAgICAgICBlbHNlIENvbnMge2tleTsgZGF0YTsgbmV4dCA9IEVtcHR5fVxuICAgICAgICAgIGluXG4gICAgICAgICAgbGV0IG5pZHggPSBpbmRleGZ1biBoIGtleSBpblxuICAgICAgICAgIGJlZ2luIG1hdGNoIG5kYXRhX3RhaWwuKG5pZHgpIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IG5kYXRhLihuaWR4KSA8LSBjZWxsO1xuICAgICAgICAgIHwgQ29ucyB0YWlsIC0+IHRhaWwubmV4dCA8LSBjZWxsO1xuICAgICAgICAgIGVuZDtcbiAgICAgICAgICBuZGF0YV90YWlsLihuaWR4KSA8LSBjZWxsO1xuICAgICAgICAgIGluc2VydF9idWNrZXQgbmV4dFxuICAgIGluXG4gICAgZm9yIGkgPSAwIHRvIG9zaXplIC0gMSBkb1xuICAgICAgaW5zZXJ0X2J1Y2tldCBvZGF0YS4oaSlcbiAgICBkb25lO1xuICAgIGlmIGlucGxhY2UgdGhlblxuICAgICAgZm9yIGkgPSAwIHRvIG5zaXplIC0gMSBkb1xuICAgICAgICBtYXRjaCBuZGF0YV90YWlsLihpKSB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gKClcbiAgICAgICAgfCBDb25zIHRhaWwgLT4gdGFpbC5uZXh0IDwtIEVtcHR5XG4gICAgICBkb25lO1xuICBlbmRcblxubGV0IGtleV9pbmRleCBoIGtleSA9XG4gICgqIGNvbXBhdGliaWxpdHkgd2l0aCBvbGQgaGFzaCB0YWJsZXMgKilcbiAgaWYgT2JqLnNpemUgKE9iai5yZXByIGgpID49IDNcbiAgdGhlbiAoc2VlZGVkX2hhc2hfcGFyYW0gMTAgMTAwIGguc2VlZCBrZXkpIGxhbmQgKEFycmF5Lmxlbmd0aCBoLmRhdGEgLSAxKVxuICBlbHNlIChvbGRfaGFzaF9wYXJhbSAxMCAxMDAga2V5KSBtb2QgKEFycmF5Lmxlbmd0aCBoLmRhdGEpXG5cbmxldCBhZGQgaCBrZXkgZGF0YSA9XG4gIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gIGxldCBidWNrZXQgPSBDb25ze2tleTsgZGF0YTsgbmV4dD1oLmRhdGEuKGkpfSBpblxuICBoLmRhdGEuKGkpIDwtIGJ1Y2tldDtcbiAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUga2V5X2luZGV4IGhcblxubGV0IHJlYyByZW1vdmVfYnVja2V0IGggaSBrZXkgcHJlYyA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgICgpXG4gIHwgKENvbnMge2tleT1rOyBuZXh0fSkgYXMgYyAtPlxuICAgICAgaWYgY29tcGFyZSBrIGtleSA9IDBcbiAgICAgIHRoZW4gYmVnaW5cbiAgICAgICAgaC5zaXplIDwtIGguc2l6ZSAtIDE7XG4gICAgICAgIG1hdGNoIHByZWMgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGguZGF0YS4oaSkgPC0gbmV4dFxuICAgICAgICB8IENvbnMgYyAtPiBjLm5leHQgPC0gbmV4dFxuICAgICAgZW5kXG4gICAgICBlbHNlIHJlbW92ZV9idWNrZXQgaCBpIGtleSBjIG5leHRcblxubGV0IHJlbW92ZSBoIGtleSA9XG4gIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gIHJlbW92ZV9idWNrZXQgaCBpIGtleSBFbXB0eSBoLmRhdGEuKGkpXG5cbmxldCByZWMgZmluZF9yZWMga2V5ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsgPSAwIHRoZW4gZGF0YSBlbHNlIGZpbmRfcmVjIGtleSBuZXh0XG5cbmxldCBmaW5kIGgga2V5ID1cbiAgbWF0Y2ggaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpIHdpdGhcbiAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCBDb25ze2tleT1rMTsgZGF0YT1kMTsgbmV4dD1uZXh0MX0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsxID0gMCB0aGVuIGQxIGVsc2VcbiAgICAgIG1hdGNoIG5leHQxIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IENvbnN7a2V5PWsyOyBkYXRhPWQyOyBuZXh0PW5leHQyfSAtPlxuICAgICAgICAgIGlmIGNvbXBhcmUga2V5IGsyID0gMCB0aGVuIGQyIGVsc2VcbiAgICAgICAgICBtYXRjaCBuZXh0MiB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgICAgICB8IENvbnN7a2V5PWszOyBkYXRhPWQzOyBuZXh0PW5leHQzfSAtPlxuICAgICAgICAgICAgICBpZiBjb21wYXJlIGtleSBrMyA9IDAgdGhlbiBkMyBlbHNlIGZpbmRfcmVjIGtleSBuZXh0M1xuXG5sZXQgcmVjIGZpbmRfcmVjX29wdCBrZXkgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICBOb25lXG4gIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsgPSAwIHRoZW4gU29tZSBkYXRhIGVsc2UgZmluZF9yZWNfb3B0IGtleSBuZXh0XG5cbmxldCBmaW5kX29wdCBoIGtleSA9XG4gIG1hdGNoIGguZGF0YS4oa2V5X2luZGV4IGgga2V5KSB3aXRoXG4gIHwgRW1wdHkgLT4gTm9uZVxuICB8IENvbnN7a2V5PWsxOyBkYXRhPWQxOyBuZXh0PW5leHQxfSAtPlxuICAgICAgaWYgY29tcGFyZSBrZXkgazEgPSAwIHRoZW4gU29tZSBkMSBlbHNlXG4gICAgICBtYXRjaCBuZXh0MSB3aXRoXG4gICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgQ29uc3trZXk9azI7IGRhdGE9ZDI7IG5leHQ9bmV4dDJ9IC0+XG4gICAgICAgICAgaWYgY29tcGFyZSBrZXkgazIgPSAwIHRoZW4gU29tZSBkMiBlbHNlXG4gICAgICAgICAgbWF0Y2ggbmV4dDIgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgICAgICAgIHwgQ29uc3trZXk9azM7IGRhdGE9ZDM7IG5leHQ9bmV4dDN9IC0+XG4gICAgICAgICAgICAgIGlmIGNvbXBhcmUga2V5IGszID0gMCB0aGVuIFNvbWUgZDMgZWxzZSBmaW5kX3JlY19vcHQga2V5IG5leHQzXG5cbmxldCBmaW5kX2FsbCBoIGtleSA9XG4gIGxldCByZWMgZmluZF9pbl9idWNrZXQgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICBbXVxuICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICBpZiBjb21wYXJlIGsga2V5ID0gMFxuICAgICAgdGhlbiBkYXRhIDo6IGZpbmRfaW5fYnVja2V0IG5leHRcbiAgICAgIGVsc2UgZmluZF9pbl9idWNrZXQgbmV4dCBpblxuICBmaW5kX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSlcblxubGV0IHJlYyByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIHRydWVcbiAgfCBDb25zICh7a2V5PWs7IG5leHR9IGFzIHNsb3QpIC0+XG4gICAgICBpZiBjb21wYXJlIGsga2V5ID0gMFxuICAgICAgdGhlbiAoc2xvdC5rZXkgPC0ga2V5OyBzbG90LmRhdGEgPC0gZGF0YTsgZmFsc2UpXG4gICAgICBlbHNlIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhIG5leHRcblxubGV0IHJlcGxhY2UgaCBrZXkgZGF0YSA9XG4gIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gIGxldCBsID0gaC5kYXRhLihpKSBpblxuICBpZiByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSBsIHRoZW4gYmVnaW5cbiAgICBoLmRhdGEuKGkpIDwtIENvbnN7a2V5OyBkYXRhOyBuZXh0PWx9O1xuICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUga2V5X2luZGV4IGhcbiAgZW5kXG5cbmxldCBtZW0gaCBrZXkgPVxuICBsZXQgcmVjIG1lbV9pbl9idWNrZXQgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICBmYWxzZVxuICB8IENvbnN7a2V5PWs7IG5leHR9IC0+XG4gICAgICBjb21wYXJlIGsga2V5ID0gMCB8fCBtZW1faW5fYnVja2V0IG5leHQgaW5cbiAgbWVtX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSlcblxubGV0IGl0ZXIgZiBoID1cbiAgbGV0IHJlYyBkb19idWNrZXQgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT5cbiAgICAgICAgKClcbiAgICB8IENvbnN7a2V5OyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICBmIGtleSBkYXRhOyBkb19idWNrZXQgbmV4dCBpblxuICBsZXQgb2xkX3RyYXYgPSBvbmdvaW5nX3RyYXZlcnNhbCBoIGluXG4gIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgdHJ5XG4gICAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICBkb19idWNrZXQgZC4oaSlcbiAgICBkb25lO1xuICAgIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgd2l0aCBleG4gd2hlbiBub3Qgb2xkX3RyYXYgLT5cbiAgICBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gICAgcmFpc2UgZXhuXG5cbmxldCByZWMgZmlsdGVyX21hcF9pbnBsYWNlX2J1Y2tldCBmIGggaSBwcmVjID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgYmVnaW4gbWF0Y2ggcHJlYyB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGguZGF0YS4oaSkgPC0gRW1wdHlcbiAgICAgIHwgQ29ucyBjIC0+IGMubmV4dCA8LSBFbXB0eVxuICAgICAgZW5kXG4gIHwgKENvbnMgKHtrZXk7IGRhdGE7IG5leHR9IGFzIGMpKSBhcyBzbG90IC0+XG4gICAgICBiZWdpbiBtYXRjaCBmIGtleSBkYXRhIHdpdGhcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICAgIGZpbHRlcl9tYXBfaW5wbGFjZV9idWNrZXQgZiBoIGkgcHJlYyBuZXh0XG4gICAgICB8IFNvbWUgZGF0YSAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIHByZWMgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gaC5kYXRhLihpKSA8LSBzbG90XG4gICAgICAgICAgfCBDb25zIGMgLT4gYy5uZXh0IDwtIHNsb3RcbiAgICAgICAgICBlbmQ7XG4gICAgICAgICAgYy5kYXRhIDwtIGRhdGE7XG4gICAgICAgICAgZmlsdGVyX21hcF9pbnBsYWNlX2J1Y2tldCBmIGggaSBzbG90IG5leHRcbiAgICAgIGVuZFxuXG5sZXQgZmlsdGVyX21hcF9pbnBsYWNlIGYgaCA9XG4gIGxldCBkID0gaC5kYXRhIGluXG4gIGxldCBvbGRfdHJhdiA9IG9uZ29pbmdfdHJhdmVyc2FsIGggaW5cbiAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICB0cnlcbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICBmaWx0ZXJfbWFwX2lucGxhY2VfYnVja2V0IGYgaCBpIEVtcHR5IGguZGF0YS4oaSlcbiAgICBkb25lXG4gIHdpdGggZXhuIHdoZW4gbm90IG9sZF90cmF2IC0+XG4gICAgZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICAgIHJhaXNlIGV4blxuXG5sZXQgZm9sZCBmIGggaW5pdCA9XG4gIGxldCByZWMgZG9fYnVja2V0IGIgYWNjdSA9XG4gICAgbWF0Y2ggYiB3aXRoXG4gICAgICBFbXB0eSAtPlxuICAgICAgICBhY2N1XG4gICAgfCBDb25ze2tleTsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgZG9fYnVja2V0IG5leHQgKGYga2V5IGRhdGEgYWNjdSkgaW5cbiAgbGV0IG9sZF90cmF2ID0gb25nb2luZ190cmF2ZXJzYWwgaCBpblxuICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gIHRyeVxuICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgbGV0IGFjY3UgPSByZWYgaW5pdCBpblxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgIGFjY3UgOj0gZG9fYnVja2V0IGQuKGkpICFhY2N1XG4gICAgZG9uZTtcbiAgICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gICAgIWFjY3VcbiAgd2l0aCBleG4gd2hlbiBub3Qgb2xkX3RyYXYgLT5cbiAgICBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gICAgcmFpc2UgZXhuXG5cbnR5cGUgc3RhdGlzdGljcyA9IHtcbiAgbnVtX2JpbmRpbmdzOiBpbnQ7XG4gIG51bV9idWNrZXRzOiBpbnQ7XG4gIG1heF9idWNrZXRfbGVuZ3RoOiBpbnQ7XG4gIGJ1Y2tldF9oaXN0b2dyYW06IGludCBhcnJheVxufVxuXG5sZXQgcmVjIGJ1Y2tldF9sZW5ndGggYWNjdSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gYWNjdVxuICB8IENvbnN7bmV4dH0gLT4gYnVja2V0X2xlbmd0aCAoYWNjdSArIDEpIG5leHRcblxubGV0IHN0YXRzIGggPVxuICBsZXQgbWJsID1cbiAgICBBcnJheS5mb2xkX2xlZnQgKGZ1biBtIGIgLT4gbWF4IG0gKGJ1Y2tldF9sZW5ndGggMCBiKSkgMCBoLmRhdGEgaW5cbiAgbGV0IGhpc3RvID0gQXJyYXkubWFrZSAobWJsICsgMSkgMCBpblxuICBBcnJheS5pdGVyXG4gICAgKGZ1biBiIC0+XG4gICAgICBsZXQgbCA9IGJ1Y2tldF9sZW5ndGggMCBiIGluXG4gICAgICBoaXN0by4obCkgPC0gaGlzdG8uKGwpICsgMSlcbiAgICBoLmRhdGE7XG4gIHsgbnVtX2JpbmRpbmdzID0gaC5zaXplO1xuICAgIG51bV9idWNrZXRzID0gQXJyYXkubGVuZ3RoIGguZGF0YTtcbiAgICBtYXhfYnVja2V0X2xlbmd0aCA9IG1ibDtcbiAgICBidWNrZXRfaGlzdG9ncmFtID0gaGlzdG8gfVxuXG4oKiBGdW5jdG9yaWFsIGludGVyZmFjZSAqKVxuXG5tb2R1bGUgdHlwZSBIYXNoZWRUeXBlID1cbiAgc2lnXG4gICAgdHlwZSB0XG4gICAgdmFsIGVxdWFsOiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBoYXNoOiB0IC0+IGludFxuICBlbmRcblxubW9kdWxlIHR5cGUgU2VlZGVkSGFzaGVkVHlwZSA9XG4gIHNpZ1xuICAgIHR5cGUgdFxuICAgIHZhbCBlcXVhbDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgaGFzaDogaW50IC0+IHQgLT4gaW50XG4gIGVuZFxuXG5tb2R1bGUgdHlwZSBTID1cbiAgc2lnXG4gICAgdHlwZSBrZXlcbiAgICB0eXBlICdhIHRcbiAgICB2YWwgY3JlYXRlOiBpbnQgLT4gJ2EgdFxuICAgIHZhbCBjbGVhciA6ICdhIHQgLT4gdW5pdFxuICAgIHZhbCByZXNldCA6ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBjb3B5OiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgYWRkOiAnYSB0IC0+IGtleSAtPiAnYSAtPiB1bml0XG4gICAgdmFsIHJlbW92ZTogJ2EgdCAtPiBrZXkgLT4gdW5pdFxuICAgIHZhbCBmaW5kOiAnYSB0IC0+IGtleSAtPiAnYVxuICAgIHZhbCBmaW5kX29wdDogJ2EgdCAtPiBrZXkgLT4gJ2Egb3B0aW9uXG4gICAgdmFsIGZpbmRfYWxsOiAnYSB0IC0+IGtleSAtPiAnYSBsaXN0XG4gICAgdmFsIHJlcGxhY2UgOiAnYSB0IC0+IGtleSAtPiAnYSAtPiB1bml0XG4gICAgdmFsIG1lbSA6ICdhIHQgLT4ga2V5IC0+IGJvb2xcbiAgICB2YWwgaXRlcjogKGtleSAtPiAnYSAtPiB1bml0KSAtPiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgZmlsdGVyX21hcF9pbnBsYWNlOiAoa2V5IC0+ICdhIC0+ICdhIG9wdGlvbikgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZvbGQ6IChrZXkgLT4gJ2EgLT4gJ2IgLT4gJ2IpIC0+ICdhIHQgLT4gJ2IgLT4gJ2JcbiAgICB2YWwgbGVuZ3RoOiAnYSB0IC0+IGludFxuICAgIHZhbCBzdGF0czogJ2EgdCAtPiBzdGF0aXN0aWNzXG4gIGVuZFxuXG5tb2R1bGUgdHlwZSBTZWVkZWRTID1cbiAgc2lnXG4gICAgdHlwZSBrZXlcbiAgICB0eXBlICdhIHRcbiAgICB2YWwgY3JlYXRlIDogP3JhbmRvbTpib29sIC0+IGludCAtPiAnYSB0XG4gICAgdmFsIGNsZWFyIDogJ2EgdCAtPiB1bml0XG4gICAgdmFsIHJlc2V0IDogJ2EgdCAtPiB1bml0XG4gICAgdmFsIGNvcHkgOiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgYWRkIDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCByZW1vdmUgOiAnYSB0IC0+IGtleSAtPiB1bml0XG4gICAgdmFsIGZpbmQgOiAnYSB0IC0+IGtleSAtPiAnYVxuICAgIHZhbCBmaW5kX29wdDogJ2EgdCAtPiBrZXkgLT4gJ2Egb3B0aW9uXG4gICAgdmFsIGZpbmRfYWxsIDogJ2EgdCAtPiBrZXkgLT4gJ2EgbGlzdFxuICAgIHZhbCByZXBsYWNlIDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCBtZW0gOiAnYSB0IC0+IGtleSAtPiBib29sXG4gICAgdmFsIGl0ZXIgOiAoa2V5IC0+ICdhIC0+IHVuaXQpIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmaWx0ZXJfbWFwX2lucGxhY2U6IChrZXkgLT4gJ2EgLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgZm9sZCA6IChrZXkgLT4gJ2EgLT4gJ2IgLT4gJ2IpIC0+ICdhIHQgLT4gJ2IgLT4gJ2JcbiAgICB2YWwgbGVuZ3RoIDogJ2EgdCAtPiBpbnRcbiAgICB2YWwgc3RhdHM6ICdhIHQgLT4gc3RhdGlzdGljc1xuICBlbmRcblxubW9kdWxlIE1ha2VTZWVkZWQoSDogU2VlZGVkSGFzaGVkVHlwZSk6IChTZWVkZWRTIHdpdGggdHlwZSBrZXkgPSBILnQpID1cbiAgc3RydWN0XG4gICAgdHlwZSBrZXkgPSBILnRcbiAgICB0eXBlICdhIGhhc2h0YmwgPSAoa2V5LCAnYSkgdFxuICAgIHR5cGUgJ2EgdCA9ICdhIGhhc2h0YmxcbiAgICBsZXQgY3JlYXRlID0gY3JlYXRlXG4gICAgbGV0IGNsZWFyID0gY2xlYXJcbiAgICBsZXQgcmVzZXQgPSByZXNldFxuICAgIGxldCBjb3B5ID0gY29weVxuXG4gICAgbGV0IGtleV9pbmRleCBoIGtleSA9XG4gICAgICAoSC5oYXNoIGguc2VlZCBrZXkpIGxhbmQgKEFycmF5Lmxlbmd0aCBoLmRhdGEgLSAxKVxuXG4gICAgbGV0IGFkZCBoIGtleSBkYXRhID1cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gICAgICBsZXQgYnVja2V0ID0gQ29uc3trZXk7IGRhdGE7IG5leHQ9aC5kYXRhLihpKX0gaW5cbiAgICAgIGguZGF0YS4oaSkgPC0gYnVja2V0O1xuICAgICAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gICAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGtleV9pbmRleCBoXG5cbiAgICBsZXQgcmVjIHJlbW92ZV9idWNrZXQgaCBpIGtleSBwcmVjID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICAoKVxuICAgICAgfCAoQ29ucyB7a2V5PWs7IG5leHR9KSBhcyBjIC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrIGtleVxuICAgICAgICAgIHRoZW4gYmVnaW5cbiAgICAgICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICAgICAgbWF0Y2ggcHJlYyB3aXRoXG4gICAgICAgICAgICB8IEVtcHR5IC0+IGguZGF0YS4oaSkgPC0gbmV4dFxuICAgICAgICAgICAgfCBDb25zIGMgLT4gYy5uZXh0IDwtIG5leHRcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlIHJlbW92ZV9idWNrZXQgaCBpIGtleSBjIG5leHRcblxuICAgIGxldCByZW1vdmUgaCBrZXkgPVxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBrZXkgaW5cbiAgICAgIHJlbW92ZV9idWNrZXQgaCBpIGtleSBFbXB0eSBoLmRhdGEuKGkpXG5cbiAgICBsZXQgcmVjIGZpbmRfcmVjIGtleSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrZXkgayB0aGVuIGRhdGEgZWxzZSBmaW5kX3JlYyBrZXkgbmV4dFxuXG4gICAgbGV0IGZpbmQgaCBrZXkgPVxuICAgICAgbWF0Y2ggaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IENvbnN7a2V5PWsxOyBkYXRhPWQxOyBuZXh0PW5leHQxfSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsxIHRoZW4gZDEgZWxzZVxuICAgICAgICAgIG1hdGNoIG5leHQxIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgICAgIHwgQ29uc3trZXk9azI7IGRhdGE9ZDI7IG5leHQ9bmV4dDJ9IC0+XG4gICAgICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsyIHRoZW4gZDIgZWxzZVxuICAgICAgICAgICAgICBtYXRjaCBuZXh0MiB3aXRoXG4gICAgICAgICAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgICAgICAgIHwgQ29uc3trZXk9azM7IGRhdGE9ZDM7IG5leHQ9bmV4dDN9IC0+XG4gICAgICAgICAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMyB0aGVuIGQzIGVsc2UgZmluZF9yZWMga2V5IG5leHQzXG5cbiAgICBsZXQgcmVjIGZpbmRfcmVjX29wdCBrZXkgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGtleSBrIHRoZW4gU29tZSBkYXRhIGVsc2UgZmluZF9yZWNfb3B0IGtleSBuZXh0XG5cbiAgICBsZXQgZmluZF9vcHQgaCBrZXkgPVxuICAgICAgbWF0Y2ggaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBDb25ze2tleT1rMTsgZGF0YT1kMTsgbmV4dD1uZXh0MX0gLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMSB0aGVuIFNvbWUgZDEgZWxzZVxuICAgICAgICAgIG1hdGNoIG5leHQxIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgICAgICB8IENvbnN7a2V5PWsyOyBkYXRhPWQyOyBuZXh0PW5leHQyfSAtPlxuICAgICAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMiB0aGVuIFNvbWUgZDIgZWxzZVxuICAgICAgICAgICAgICBtYXRjaCBuZXh0MiB3aXRoXG4gICAgICAgICAgICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgICAgICAgICAgICB8IENvbnN7a2V5PWszOyBkYXRhPWQzOyBuZXh0PW5leHQzfSAtPlxuICAgICAgICAgICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazMgdGhlbiBTb21lIGQzIGVsc2UgZmluZF9yZWNfb3B0IGtleSBuZXh0M1xuXG4gICAgbGV0IGZpbmRfYWxsIGgga2V5ID1cbiAgICAgIGxldCByZWMgZmluZF9pbl9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIFtdXG4gICAgICB8IENvbnN7a2V5PWs7IGRhdGE9ZDsgbmV4dH0gLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGsga2V5XG4gICAgICAgICAgdGhlbiBkIDo6IGZpbmRfaW5fYnVja2V0IG5leHRcbiAgICAgICAgICBlbHNlIGZpbmRfaW5fYnVja2V0IG5leHQgaW5cbiAgICAgIGZpbmRfaW5fYnVja2V0IGguZGF0YS4oa2V5X2luZGV4IGgga2V5KVxuXG4gICAgbGV0IHJlYyByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgdHJ1ZVxuICAgICAgfCBDb25zICh7a2V5PWs7IG5leHR9IGFzIHNsb3QpIC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrIGtleVxuICAgICAgICAgIHRoZW4gKHNsb3Qua2V5IDwtIGtleTsgc2xvdC5kYXRhIDwtIGRhdGE7IGZhbHNlKVxuICAgICAgICAgIGVsc2UgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgbmV4dFxuXG4gICAgbGV0IHJlcGxhY2UgaCBrZXkgZGF0YSA9XG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICAgICAgbGV0IGwgPSBoLmRhdGEuKGkpIGluXG4gICAgICBpZiByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSBsIHRoZW4gYmVnaW5cbiAgICAgICAgaC5kYXRhLihpKSA8LSBDb25ze2tleTsgZGF0YTsgbmV4dD1sfTtcbiAgICAgICAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gICAgICAgIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUga2V5X2luZGV4IGhcbiAgICAgIGVuZFxuXG4gICAgbGV0IG1lbSBoIGtleSA9XG4gICAgICBsZXQgcmVjIG1lbV9pbl9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIGZhbHNlXG4gICAgICB8IENvbnN7a2V5PWs7IG5leHR9IC0+XG4gICAgICAgICAgSC5lcXVhbCBrIGtleSB8fCBtZW1faW5fYnVja2V0IG5leHQgaW5cbiAgICAgIG1lbV9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpXG5cbiAgICBsZXQgaXRlciA9IGl0ZXJcbiAgICBsZXQgZmlsdGVyX21hcF9pbnBsYWNlID0gZmlsdGVyX21hcF9pbnBsYWNlXG4gICAgbGV0IGZvbGQgPSBmb2xkXG4gICAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuICAgIGxldCBzdGF0cyA9IHN0YXRzXG4gIGVuZFxuXG5tb2R1bGUgTWFrZShIOiBIYXNoZWRUeXBlKTogKFMgd2l0aCB0eXBlIGtleSA9IEgudCkgPVxuICBzdHJ1Y3RcbiAgICBpbmNsdWRlIE1ha2VTZWVkZWQoc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IEgudFxuICAgICAgICBsZXQgZXF1YWwgPSBILmVxdWFsXG4gICAgICAgIGxldCBoYXNoIChfc2VlZDogaW50KSB4ID0gSC5oYXNoIHhcbiAgICAgIGVuZClcbiAgICBsZXQgY3JlYXRlIHN6ID0gY3JlYXRlIH5yYW5kb206ZmFsc2Ugc3pcbiAgZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqKiBXZWFrIGFycmF5IG9wZXJhdGlvbnMgKilcblxudHlwZSAnYSB0XG5cbmV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiAnYSB0ID0gXCJjYW1sX3dlYWtfY3JlYXRlXCJcblxuKCoqIG51bWJlciBvZiBhZGRpdGlvbmFsIHZhbHVlcyBpbiBhIHdlYWsgcG9pbnRlciAqKVxubGV0IGFkZGl0aW9uYWxfdmFsdWVzID0gMlxuXG5sZXQgbGVuZ3RoIHggPSBPYmouc2l6ZShPYmoucmVwciB4KSAtIGFkZGl0aW9uYWxfdmFsdWVzXG5cbmV4dGVybmFsIHNldCA6ICdhIHQgLT4gaW50IC0+ICdhIG9wdGlvbiAtPiB1bml0ID0gXCJjYW1sX3dlYWtfc2V0XCJcbmV4dGVybmFsIGdldCA6ICdhIHQgLT4gaW50IC0+ICdhIG9wdGlvbiA9IFwiY2FtbF93ZWFrX2dldFwiXG5leHRlcm5hbCBnZXRfY29weSA6ICdhIHQgLT4gaW50IC0+ICdhIG9wdGlvbiA9IFwiY2FtbF93ZWFrX2dldF9jb3B5XCJcbmV4dGVybmFsIGNoZWNrIDogJ2EgdCAtPiBpbnQgLT4gYm9vbCA9IFwiY2FtbF93ZWFrX2NoZWNrXCJcbmV4dGVybmFsIGJsaXQgOiAnYSB0IC0+IGludCAtPiAnYSB0IC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF93ZWFrX2JsaXRcIlxuKCogYmxpdDogc3JjIHNyY29mZiBkc3QgZHN0b2ZmIGxlbiAqKVxuXG5sZXQgZmlsbCBhciBvZnMgbGVuIHggPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzICsgbGVuID4gbGVuZ3RoIGFyXG4gIHRoZW4gcmFpc2UgKEludmFsaWRfYXJndW1lbnQgXCJXZWFrLmZpbGxcIilcbiAgZWxzZSBiZWdpblxuICAgIGZvciBpID0gb2ZzIHRvIChvZnMgKyBsZW4gLSAxKSBkb1xuICAgICAgc2V0IGFyIGkgeFxuICAgIGRvbmVcbiAgZW5kXG5cblxuKCoqIFdlYWsgaGFzaCB0YWJsZXMgKilcblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICB0eXBlIGRhdGFcbiAgdHlwZSB0XG4gIHZhbCBjcmVhdGUgOiBpbnQgLT4gdFxuICB2YWwgY2xlYXIgOiB0IC0+IHVuaXRcbiAgdmFsIG1lcmdlIDogdCAtPiBkYXRhIC0+IGRhdGFcbiAgdmFsIGFkZCA6IHQgLT4gZGF0YSAtPiB1bml0XG4gIHZhbCByZW1vdmUgOiB0IC0+IGRhdGEgLT4gdW5pdFxuICB2YWwgZmluZCA6IHQgLT4gZGF0YSAtPiBkYXRhXG4gIHZhbCBmaW5kX29wdCA6IHQgLT4gZGF0YSAtPiBkYXRhIG9wdGlvblxuICB2YWwgZmluZF9hbGwgOiB0IC0+IGRhdGEgLT4gZGF0YSBsaXN0XG4gIHZhbCBtZW0gOiB0IC0+IGRhdGEgLT4gYm9vbFxuICB2YWwgaXRlciA6IChkYXRhIC0+IHVuaXQpIC0+IHQgLT4gdW5pdFxuICB2YWwgZm9sZCA6IChkYXRhIC0+ICdhIC0+ICdhKSAtPiB0IC0+ICdhIC0+ICdhXG4gIHZhbCBjb3VudCA6IHQgLT4gaW50XG4gIHZhbCBzdGF0cyA6IHQgLT4gaW50ICogaW50ICogaW50ICogaW50ICogaW50ICogaW50XG5lbmRcblxubW9kdWxlIE1ha2UgKEggOiBIYXNodGJsLkhhc2hlZFR5cGUpIDogKFMgd2l0aCB0eXBlIGRhdGEgPSBILnQpID0gc3RydWN0XG5cbiAgdHlwZSAnYSB3ZWFrX3QgPSAnYSB0XG4gIGxldCB3ZWFrX2NyZWF0ZSA9IGNyZWF0ZVxuICBsZXQgZW1wdHlidWNrZXQgPSB3ZWFrX2NyZWF0ZSAwXG5cbiAgdHlwZSBkYXRhID0gSC50XG5cbiAgdHlwZSB0ID0ge1xuICAgIG11dGFibGUgdGFibGUgOiBkYXRhIHdlYWtfdCBhcnJheTtcbiAgICBtdXRhYmxlIGhhc2hlcyA6IGludCBhcnJheSBhcnJheTtcbiAgICBtdXRhYmxlIGxpbWl0IDogaW50OyAgICAgICAgICAgICAgICgqIGJ1Y2tldCBzaXplIGxpbWl0ICopXG4gICAgbXV0YWJsZSBvdmVyc2l6ZSA6IGludDsgICAgICAgICAgICAoKiBudW1iZXIgb2Ygb3ZlcnNpemUgYnVja2V0cyAqKVxuICAgIG11dGFibGUgcm92ZXIgOiBpbnQ7ICAgICAgICAgICAgICAgKCogZm9yIGludGVybmFsIGJvb2trZWVwaW5nICopXG4gIH1cblxuICBsZXQgZ2V0X2luZGV4IHQgaCA9IChoIGxhbmQgbWF4X2ludCkgbW9kIChBcnJheS5sZW5ndGggdC50YWJsZSlcblxuICBsZXQgbGltaXQgPSA3XG4gIGxldCBvdmVyX2xpbWl0ID0gMlxuXG4gIGxldCBjcmVhdGUgc3ogPVxuICAgIGxldCBzeiA9IGlmIHN6IDwgNyB0aGVuIDcgZWxzZSBzeiBpblxuICAgIGxldCBzeiA9IGlmIHN6ID4gU3lzLm1heF9hcnJheV9sZW5ndGggdGhlbiBTeXMubWF4X2FycmF5X2xlbmd0aCBlbHNlIHN6IGluXG4gICAge1xuICAgICAgdGFibGUgPSBBcnJheS5tYWtlIHN6IGVtcHR5YnVja2V0O1xuICAgICAgaGFzaGVzID0gQXJyYXkubWFrZSBzeiBbfCB8XTtcbiAgICAgIGxpbWl0ID0gbGltaXQ7XG4gICAgICBvdmVyc2l6ZSA9IDA7XG4gICAgICByb3ZlciA9IDA7XG4gICAgfVxuXG4gIGxldCBjbGVhciB0ID1cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIHQudGFibGUgLSAxIGRvXG4gICAgICB0LnRhYmxlLihpKSA8LSBlbXB0eWJ1Y2tldDtcbiAgICAgIHQuaGFzaGVzLihpKSA8LSBbfCB8XTtcbiAgICBkb25lO1xuICAgIHQubGltaXQgPC0gbGltaXQ7XG4gICAgdC5vdmVyc2l6ZSA8LSAwXG5cblxuICBsZXQgZm9sZCBmIHQgaW5pdCA9XG4gICAgbGV0IHJlYyBmb2xkX2J1Y2tldCBpIGIgYWNjdSA9XG4gICAgICBpZiBpID49IGxlbmd0aCBiIHRoZW4gYWNjdSBlbHNlXG4gICAgICBtYXRjaCBnZXQgYiBpIHdpdGhcbiAgICAgIHwgU29tZSB2IC0+IGZvbGRfYnVja2V0IChpKzEpIGIgKGYgdiBhY2N1KVxuICAgICAgfCBOb25lIC0+IGZvbGRfYnVja2V0IChpKzEpIGIgYWNjdVxuICAgIGluXG4gICAgQXJyYXkuZm9sZF9yaWdodCAoZm9sZF9idWNrZXQgMCkgdC50YWJsZSBpbml0XG5cblxuICBsZXQgaXRlciBmIHQgPVxuICAgIGxldCByZWMgaXRlcl9idWNrZXQgaSBiID1cbiAgICAgIGlmIGkgPj0gbGVuZ3RoIGIgdGhlbiAoKSBlbHNlXG4gICAgICBtYXRjaCBnZXQgYiBpIHdpdGhcbiAgICAgIHwgU29tZSB2IC0+IGYgdjsgaXRlcl9idWNrZXQgKGkrMSkgYlxuICAgICAgfCBOb25lIC0+IGl0ZXJfYnVja2V0IChpKzEpIGJcbiAgICBpblxuICAgIEFycmF5Lml0ZXIgKGl0ZXJfYnVja2V0IDApIHQudGFibGVcblxuXG4gIGxldCBpdGVyX3dlYWsgZiB0ID1cbiAgICBsZXQgcmVjIGl0ZXJfYnVja2V0IGkgaiBiID1cbiAgICAgIGlmIGkgPj0gbGVuZ3RoIGIgdGhlbiAoKSBlbHNlXG4gICAgICBtYXRjaCBjaGVjayBiIGkgd2l0aFxuICAgICAgfCB0cnVlIC0+IGYgYiB0Lmhhc2hlcy4oaikgaTsgaXRlcl9idWNrZXQgKGkrMSkgaiBiXG4gICAgICB8IGZhbHNlIC0+IGl0ZXJfYnVja2V0IChpKzEpIGogYlxuICAgIGluXG4gICAgQXJyYXkuaXRlcmkgKGl0ZXJfYnVja2V0IDApIHQudGFibGVcblxuXG4gIGxldCByZWMgY291bnRfYnVja2V0IGkgYiBhY2N1ID1cbiAgICBpZiBpID49IGxlbmd0aCBiIHRoZW4gYWNjdSBlbHNlXG4gICAgY291bnRfYnVja2V0IChpKzEpIGIgKGFjY3UgKyAoaWYgY2hlY2sgYiBpIHRoZW4gMSBlbHNlIDApKVxuXG5cbiAgbGV0IGNvdW50IHQgPVxuICAgIEFycmF5LmZvbGRfcmlnaHQgKGNvdW50X2J1Y2tldCAwKSB0LnRhYmxlIDBcblxuXG4gIGxldCBuZXh0X3N6IG4gPSBtaW4gKDMgKiBuIC8gMiArIDMpIFN5cy5tYXhfYXJyYXlfbGVuZ3RoXG4gIGxldCBwcmV2X3N6IG4gPSAoKG4gLSAzKSAqIDIgKyAyKSAvIDNcblxuICBsZXQgdGVzdF9zaHJpbmtfYnVja2V0IHQgPVxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLih0LnJvdmVyKSBpblxuICAgIGxldCBoYnVja2V0ID0gdC5oYXNoZXMuKHQucm92ZXIpIGluXG4gICAgbGV0IGxlbiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcHJldl9sZW4gPSBwcmV2X3N6IGxlbiBpblxuICAgIGxldCBsaXZlID0gY291bnRfYnVja2V0IDAgYnVja2V0IDAgaW5cbiAgICBpZiBsaXZlIDw9IHByZXZfbGVuIHRoZW4gYmVnaW5cbiAgICAgIGxldCByZWMgbG9vcCBpIGogPVxuICAgICAgICBpZiBqID49IHByZXZfbGVuIHRoZW4gYmVnaW5cbiAgICAgICAgICBpZiBjaGVjayBidWNrZXQgaSB0aGVuIGxvb3AgKGkgKyAxKSBqXG4gICAgICAgICAgZWxzZSBpZiBjaGVjayBidWNrZXQgaiB0aGVuIGJlZ2luXG4gICAgICAgICAgICBibGl0IGJ1Y2tldCBqIGJ1Y2tldCBpIDE7XG4gICAgICAgICAgICBoYnVja2V0LihpKSA8LSBoYnVja2V0LihqKTtcbiAgICAgICAgICAgIGxvb3AgKGkgKyAxKSAoaiAtIDEpO1xuICAgICAgICAgIGVuZCBlbHNlIGxvb3AgaSAoaiAtIDEpO1xuICAgICAgICBlbmQ7XG4gICAgICBpblxuICAgICAgbG9vcCAwIChsZW5ndGggYnVja2V0IC0gMSk7XG4gICAgICBpZiBwcmV2X2xlbiA9IDAgdGhlbiBiZWdpblxuICAgICAgICB0LnRhYmxlLih0LnJvdmVyKSA8LSBlbXB0eWJ1Y2tldDtcbiAgICAgICAgdC5oYXNoZXMuKHQucm92ZXIpIDwtIFt8IHxdO1xuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgT2JqLnRydW5jYXRlIChPYmoucmVwciBidWNrZXQpIChwcmV2X2xlbiArIGFkZGl0aW9uYWxfdmFsdWVzKTtcbiAgICAgICAgT2JqLnRydW5jYXRlIChPYmoucmVwciBoYnVja2V0KSBwcmV2X2xlbjtcbiAgICAgIGVuZDtcbiAgICAgIGlmIGxlbiA+IHQubGltaXQgJiYgcHJldl9sZW4gPD0gdC5saW1pdCB0aGVuIHQub3ZlcnNpemUgPC0gdC5vdmVyc2l6ZSAtIDE7XG4gICAgZW5kO1xuICAgIHQucm92ZXIgPC0gKHQucm92ZXIgKyAxKSBtb2QgKEFycmF5Lmxlbmd0aCB0LnRhYmxlKVxuXG5cbiAgbGV0IHJlYyByZXNpemUgdCA9XG4gICAgbGV0IG9sZGxlbiA9IEFycmF5Lmxlbmd0aCB0LnRhYmxlIGluXG4gICAgbGV0IG5ld2xlbiA9IG5leHRfc3ogb2xkbGVuIGluXG4gICAgaWYgbmV3bGVuID4gb2xkbGVuIHRoZW4gYmVnaW5cbiAgICAgIGxldCBuZXd0ID0gY3JlYXRlIG5ld2xlbiBpblxuICAgICAgbGV0IGFkZF93ZWFrIG9iIG9oIG9pID1cbiAgICAgICAgbGV0IHNldHRlciBuYiBuaSBfID0gYmxpdCBvYiBvaSBuYiBuaSAxIGluXG4gICAgICAgIGxldCBoID0gb2guKG9pKSBpblxuICAgICAgICBhZGRfYXV4IG5ld3Qgc2V0dGVyIE5vbmUgaCAoZ2V0X2luZGV4IG5ld3QgaCk7XG4gICAgICBpblxuICAgICAgaXRlcl93ZWFrIGFkZF93ZWFrIHQ7XG4gICAgICB0LnRhYmxlIDwtIG5ld3QudGFibGU7XG4gICAgICB0Lmhhc2hlcyA8LSBuZXd0Lmhhc2hlcztcbiAgICAgIHQubGltaXQgPC0gbmV3dC5saW1pdDtcbiAgICAgIHQub3ZlcnNpemUgPC0gbmV3dC5vdmVyc2l6ZTtcbiAgICAgIHQucm92ZXIgPC0gdC5yb3ZlciBtb2QgQXJyYXkubGVuZ3RoIG5ld3QudGFibGU7XG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgIHQubGltaXQgPC0gbWF4X2ludDsgICAgICAgICAgICAgKCogbWF4aW11bSBzaXplIGFscmVhZHkgcmVhY2hlZCAqKVxuICAgICAgdC5vdmVyc2l6ZSA8LSAwO1xuICAgIGVuZFxuXG4gIGFuZCBhZGRfYXV4IHQgc2V0dGVyIGQgaCBpbmRleCA9XG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPj0gc3ogdGhlbiBiZWdpblxuICAgICAgICBsZXQgbmV3c3ogPVxuICAgICAgICAgIG1pbiAoMyAqIHN6IC8gMiArIDMpIChTeXMubWF4X2FycmF5X2xlbmd0aCAtIGFkZGl0aW9uYWxfdmFsdWVzKVxuICAgICAgICBpblxuICAgICAgICBpZiBuZXdzeiA8PSBzeiB0aGVuIGZhaWx3aXRoIFwiV2Vhay5NYWtlOiBoYXNoIGJ1Y2tldCBjYW5ub3QgZ3JvdyBtb3JlXCI7XG4gICAgICAgIGxldCBuZXdidWNrZXQgPSB3ZWFrX2NyZWF0ZSBuZXdzeiBpblxuICAgICAgICBsZXQgbmV3aGFzaGVzID0gQXJyYXkubWFrZSBuZXdzeiAwIGluXG4gICAgICAgIGJsaXQgYnVja2V0IDAgbmV3YnVja2V0IDAgc3o7XG4gICAgICAgIEFycmF5LmJsaXQgaGFzaGVzIDAgbmV3aGFzaGVzIDAgc3o7XG4gICAgICAgIHNldHRlciBuZXdidWNrZXQgc3ogZDtcbiAgICAgICAgbmV3aGFzaGVzLihzeikgPC0gaDtcbiAgICAgICAgdC50YWJsZS4oaW5kZXgpIDwtIG5ld2J1Y2tldDtcbiAgICAgICAgdC5oYXNoZXMuKGluZGV4KSA8LSBuZXdoYXNoZXM7XG4gICAgICAgIGlmIHN6IDw9IHQubGltaXQgJiYgbmV3c3ogPiB0LmxpbWl0IHRoZW4gYmVnaW5cbiAgICAgICAgICB0Lm92ZXJzaXplIDwtIHQub3ZlcnNpemUgKyAxO1xuICAgICAgICAgIGZvciBfaSA9IDAgdG8gb3Zlcl9saW1pdCBkbyB0ZXN0X3Nocmlua19idWNrZXQgdCBkb25lO1xuICAgICAgICBlbmQ7XG4gICAgICAgIGlmIHQub3ZlcnNpemUgPiBBcnJheS5sZW5ndGggdC50YWJsZSAvIG92ZXJfbGltaXQgdGhlbiByZXNpemUgdDtcbiAgICAgIGVuZCBlbHNlIGlmIGNoZWNrIGJ1Y2tldCBpIHRoZW4gYmVnaW5cbiAgICAgICAgbG9vcCAoaSArIDEpXG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBzZXR0ZXIgYnVja2V0IGkgZDtcbiAgICAgICAgaGFzaGVzLihpKSA8LSBoO1xuICAgICAgZW5kO1xuICAgIGluXG4gICAgbG9vcCAwXG5cblxuICBsZXQgYWRkIHQgZCA9XG4gICAgbGV0IGggPSBILmhhc2ggZCBpblxuICAgIGFkZF9hdXggdCBzZXQgKFNvbWUgZCkgaCAoZ2V0X2luZGV4IHQgaClcblxuXG4gIGxldCBmaW5kX29yIHQgZCBpZm5vdGZvdW5kID1cbiAgICBsZXQgaCA9IEguaGFzaCBkIGluXG4gICAgbGV0IGluZGV4ID0gZ2V0X2luZGV4IHQgaCBpblxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLihpbmRleCkgaW5cbiAgICBsZXQgaGFzaGVzID0gdC5oYXNoZXMuKGluZGV4KSBpblxuICAgIGxldCBzeiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID49IHN6IHRoZW4gaWZub3Rmb3VuZCBoIGluZGV4XG4gICAgICBlbHNlIGlmIGggPSBoYXNoZXMuKGkpIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggZ2V0X2NvcHkgYnVja2V0IGkgd2l0aFxuICAgICAgICB8IFNvbWUgdiB3aGVuIEguZXF1YWwgdiBkXG4gICAgICAgICAgIC0+IGJlZ2luIG1hdGNoIGdldCBidWNrZXQgaSB3aXRoXG4gICAgICAgICAgICAgIHwgU29tZSB2IC0+IHZcbiAgICAgICAgICAgICAgfCBOb25lIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgfCBfIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgZW5kIGVsc2UgbG9vcCAoaSArIDEpXG4gICAgaW5cbiAgICBsb29wIDBcblxuXG4gIGxldCBtZXJnZSB0IGQgPVxuICAgIGZpbmRfb3IgdCBkIChmdW4gaCBpbmRleCAtPiBhZGRfYXV4IHQgc2V0IChTb21lIGQpIGggaW5kZXg7IGQpXG5cblxuICBsZXQgZmluZCB0IGQgPSBmaW5kX29yIHQgZCAoZnVuIF9oIF9pbmRleCAtPiByYWlzZSBOb3RfZm91bmQpXG5cbiAgbGV0IGZpbmRfb3B0IHQgZCA9XG4gICAgbGV0IGggPSBILmhhc2ggZCBpblxuICAgIGxldCBpbmRleCA9IGdldF9pbmRleCB0IGggaW5cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4oaW5kZXgpIGluXG4gICAgbGV0IGhhc2hlcyA9IHQuaGFzaGVzLihpbmRleCkgaW5cbiAgICBsZXQgc3ogPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA+PSBzeiB0aGVuIE5vbmVcbiAgICAgIGVsc2UgaWYgaCA9IGhhc2hlcy4oaSkgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBnZXRfY29weSBidWNrZXQgaSB3aXRoXG4gICAgICAgIHwgU29tZSB2IHdoZW4gSC5lcXVhbCB2IGRcbiAgICAgICAgICAgLT4gYmVnaW4gbWF0Y2ggZ2V0IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgICAgICAgfCBTb21lIF8gYXMgdiAtPiB2XG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBsb29wIChpICsgMSlcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgXyAtPiBsb29wIChpICsgMSlcbiAgICAgIGVuZCBlbHNlIGxvb3AgKGkgKyAxKVxuICAgIGluXG4gICAgbG9vcCAwXG5cblxuICBsZXQgZmluZF9zaGFkb3cgdCBkIGlmZm91bmQgaWZub3Rmb3VuZCA9XG4gICAgbGV0IGggPSBILmhhc2ggZCBpblxuICAgIGxldCBpbmRleCA9IGdldF9pbmRleCB0IGggaW5cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4oaW5kZXgpIGluXG4gICAgbGV0IGhhc2hlcyA9IHQuaGFzaGVzLihpbmRleCkgaW5cbiAgICBsZXQgc3ogPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA+PSBzeiB0aGVuIGlmbm90Zm91bmRcbiAgICAgIGVsc2UgaWYgaCA9IGhhc2hlcy4oaSkgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBnZXRfY29weSBidWNrZXQgaSB3aXRoXG4gICAgICAgIHwgU29tZSB2IHdoZW4gSC5lcXVhbCB2IGQgLT4gaWZmb3VuZCBidWNrZXQgaVxuICAgICAgICB8IF8gLT4gbG9vcCAoaSArIDEpXG4gICAgICBlbmQgZWxzZSBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3AgMFxuXG5cbiAgbGV0IHJlbW92ZSB0IGQgPSBmaW5kX3NoYWRvdyB0IGQgKGZ1biB3IGkgLT4gc2V0IHcgaSBOb25lKSAoKVxuXG5cbiAgbGV0IG1lbSB0IGQgPSBmaW5kX3NoYWRvdyB0IGQgKGZ1biBfdyBfaSAtPiB0cnVlKSBmYWxzZVxuXG5cbiAgbGV0IGZpbmRfYWxsIHQgZCA9XG4gICAgbGV0IGggPSBILmhhc2ggZCBpblxuICAgIGxldCBpbmRleCA9IGdldF9pbmRleCB0IGggaW5cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4oaW5kZXgpIGluXG4gICAgbGV0IGhhc2hlcyA9IHQuaGFzaGVzLihpbmRleCkgaW5cbiAgICBsZXQgc3ogPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHJlYyBsb29wIGkgYWNjdSA9XG4gICAgICBpZiBpID49IHN6IHRoZW4gYWNjdVxuICAgICAgZWxzZSBpZiBoID0gaGFzaGVzLihpKSB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGdldF9jb3B5IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgfCBTb21lIHYgd2hlbiBILmVxdWFsIHYgZFxuICAgICAgICAgICAtPiBiZWdpbiBtYXRjaCBnZXQgYnVja2V0IGkgd2l0aFxuICAgICAgICAgICAgICB8IFNvbWUgdiAtPiBsb29wIChpICsgMSkgKHYgOjogYWNjdSlcbiAgICAgICAgICAgICAgfCBOb25lIC0+IGxvb3AgKGkgKyAxKSBhY2N1XG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICB8IF8gLT4gbG9vcCAoaSArIDEpIGFjY3VcbiAgICAgIGVuZCBlbHNlIGxvb3AgKGkgKyAxKSBhY2N1XG4gICAgaW5cbiAgICBsb29wIDAgW11cblxuXG4gIGxldCBzdGF0cyB0ID1cbiAgICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIHQudGFibGUgaW5cbiAgICBsZXQgbGVucyA9IEFycmF5Lm1hcCBsZW5ndGggdC50YWJsZSBpblxuICAgIEFycmF5LnNvcnQgY29tcGFyZSBsZW5zO1xuICAgIGxldCB0b3RsZW4gPSBBcnJheS5mb2xkX2xlZnQgKCArICkgMCBsZW5zIGluXG4gICAgKGxlbiwgY291bnQgdCwgdG90bGVuLCBsZW5zLigwKSwgbGVucy4obGVuLzIpLCBsZW5zLihsZW4tMSkpXG5cblxuZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBQaWVycmUgV2VpcywgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEEgcHJldHR5LXByaW50aW5nIGZhY2lsaXR5IGFuZCBkZWZpbml0aW9uIG9mIGZvcm1hdHRlcnMgZm9yICdwYXJhbGxlbCdcbiAgIChpLmUuIHVucmVsYXRlZCBvciBpbmRlcGVuZGVudCkgcHJldHR5LXByaW50aW5nIG9uIG11bHRpcGxlIG91dCBjaGFubmVscy4gKilcblxuKCpcbiAgIFRoZSBwcmV0dHktcHJpbnRpbmcgZW5naW5lIGludGVybmFsIGRhdGEgc3RydWN0dXJlcy5cbiopXG5cbigqIEEgZGV2b3RlZCB0eXBlIGZvciBzaXplcyB0byBhdm9pZCBjb25mdXNpb25cbiAgIGJldHdlZW4gc2l6ZXMgYW5kIG1lcmUgaW50ZWdlcnMuICopXG50eXBlIHNpemVcblxuZXh0ZXJuYWwgc2l6ZV9vZl9pbnQgOiBpbnQgLT4gc2l6ZSA9IFwiJWlkZW50aXR5XCJcblxuZXh0ZXJuYWwgaW50X29mX3NpemUgOiBzaXplIC0+IGludCA9IFwiJWlkZW50aXR5XCJcblxuXG4oKiBUaGUgcHJldHR5LXByaW50aW5nIGJveGVzIGRlZmluaXRpb246XG4gICBhIHByZXR0eS1wcmludGluZyBib3ggaXMgZWl0aGVyXG4gICAtIGhib3g6IGhvcml6b250YWwgYm94IChubyBsaW5lIHNwbGl0dGluZylcbiAgIC0gdmJveDogdmVydGljYWwgYm94IChldmVyeSBicmVhayBoaW50IHNwbGl0cyB0aGUgbGluZSlcbiAgIC0gaHZib3g6IGhvcml6b250YWwvdmVydGljYWwgYm94XG4gICAgICh0aGUgYm94IGJlaGF2ZXMgYXMgYW4gaG9yaXpvbnRhbCBib3ggaWYgaXQgZml0cyBvblxuICAgICAgdGhlIGN1cnJlbnQgbGluZSwgb3RoZXJ3aXNlIHRoZSBib3ggYmVoYXZlcyBhcyBhIHZlcnRpY2FsIGJveClcbiAgIC0gaG92Ym94OiBob3Jpem9udGFsIG9yIHZlcnRpY2FsIGNvbXBhY3RpbmcgYm94XG4gICAgICh0aGUgYm94IGlzIGNvbXBhY3RpbmcgbWF0ZXJpYWwsIHByaW50aW5nIGFzIG11Y2ggbWF0ZXJpYWwgYXMgcG9zc2libGVcbiAgICAgIG9uIGV2ZXJ5IGxpbmVzKVxuICAgLSBib3g6IGhvcml6b250YWwgb3IgdmVydGljYWwgY29tcGFjdGluZyBib3ggd2l0aCBlbmhhbmNlZCBib3ggc3RydWN0dXJlXG4gICAgICh0aGUgYm94IGJlaGF2ZXMgYXMgYW4gaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBib3ggYnV0IGJyZWFrIGhpbnRzIHNwbGl0XG4gICAgICB0aGUgbGluZSBpZiBzcGxpdHRpbmcgd291bGQgbW92ZSB0byB0aGUgbGVmdClcbiopXG50eXBlIGJveF90eXBlID0gQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmJsb2NrX3R5cGUgPVxuICB8IFBwX2hib3ggfCBQcF92Ym94IHwgUHBfaHZib3ggfCBQcF9ob3Zib3ggfCBQcF9ib3ggfCBQcF9maXRzXG5cblxuKCogVGhlIHByZXR0eS1wcmludGluZyB0b2tlbnMgZGVmaW5pdGlvbjpcbiAgIGFyZSBlaXRoZXIgdGV4dCB0byBwcmludCBvciBwcmV0dHkgcHJpbnRpbmdcbiAgIGVsZW1lbnRzIHRoYXQgZHJpdmUgaW5kZW50YXRpb24gYW5kIGxpbmUgc3BsaXR0aW5nLiAqKVxudHlwZSBwcF90b2tlbiA9XG4gIHwgUHBfdGV4dCBvZiBzdHJpbmcgICAgICAgICAgKCogbm9ybWFsIHRleHQgKilcbiAgfCBQcF9icmVhayBvZiBpbnQgKiBpbnQgICAgICAoKiBjb21wbGV0ZSBicmVhayAqKVxuICB8IFBwX3RicmVhayBvZiBpbnQgKiBpbnQgICAgICgqIGdvIHRvIG5leHQgdGFidWxhdGlvbiAqKVxuICB8IFBwX3N0YWIgICAgICAgICAgICAgICAgICAgICgqIHNldCBhIHRhYnVsYXRpb24gKilcbiAgfCBQcF9iZWdpbiBvZiBpbnQgKiBib3hfdHlwZSAoKiBiZWdpbm5pbmcgb2YgYSBib3ggKilcbiAgfCBQcF9lbmQgICAgICAgICAgICAgICAgICAgICAoKiBlbmQgb2YgYSBib3ggKilcbiAgfCBQcF90YmVnaW4gb2YgdGJveCAgICAgICAgICAoKiBiZWdpbm5pbmcgb2YgYSB0YWJ1bGF0aW9uIGJveCAqKVxuICB8IFBwX3RlbmQgICAgICAgICAgICAgICAgICAgICgqIGVuZCBvZiBhIHRhYnVsYXRpb24gYm94ICopXG4gIHwgUHBfbmV3bGluZSAgICAgICAgICAgICAgICAgKCogdG8gZm9yY2UgYSBuZXdsaW5lIGluc2lkZSBhIGJveCAqKVxuICB8IFBwX2lmX25ld2xpbmUgICAgICAgICAgICAgICgqIHRvIGRvIHNvbWV0aGluZyBvbmx5IGlmIHRoaXMgdmVyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgaGFzIGJlZW4gYnJva2VuICopXG4gIHwgUHBfb3Blbl90YWcgb2YgdGFnICAgICAgICAgKCogb3BlbmluZyBhIHRhZyBuYW1lICopXG4gIHwgUHBfY2xvc2VfdGFnICAgICAgICAgICAgICAgKCogY2xvc2luZyB0aGUgbW9zdCByZWNlbnRseSBvcGVuIHRhZyAqKVxuXG5hbmQgdGFnID0gc3RyaW5nXG5cbmFuZCB0Ym94ID0gUHBfdGJveCBvZiBpbnQgbGlzdCByZWYgICgqIFRhYnVsYXRpb24gYm94ICopXG5cblxuKCogVGhlIHByZXR0eS1wcmludGVyIHF1ZXVlIGRlZmluaXRpb246XG4gICBwcmV0dHktcHJpbnRpbmcgbWF0ZXJpYWwgaXMgbm90IHdyaXR0ZW4gaW4gdGhlIG91dHB1dCBhcyBzb29uIGFzIGVtaXR0ZWQ7XG4gICBpbnN0ZWFkLCB0aGUgbWF0ZXJpYWwgaXMgc2ltcGx5IHJlY29yZGVkIGluIHRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSxcbiAgIHVudGlsIHRoZSBlbmNsb3NpbmcgYm94IGhhcyBhIGtub3duIGNvbXB1dGVkIHNpemUgYW5kIHByb3BlciBzcGxpdHRpbmdcbiAgIGRlY2lzaW9ucyBjYW4gYmUgbWFkZS5cblxuICAgVG8gZGVmaW5lIHRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSwgd2UgZmlyc3QgZGVmaW5lIHBvbHltb3JwaGljIHF1ZXVlcyxcbiAgIHRoZW4gcHJldHR5LXByaW50ZXIgcXVldWUgZWxlbWVudHMuXG4qKVxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgcXVldWU6IHBvbHltb3JwaGljIHF1ZXVlIGRlZmluaXRpb24uICopXG50eXBlICdhIHF1ZXVlX2VsZW0gPVxuICB8IE5pbFxuICB8IENvbnMgb2Yge1xuICAgICAgaGVhZCA6ICdhO1xuICAgICAgbXV0YWJsZSB0YWlsIDogJ2EgcXVldWVfZWxlbTtcbiAgICB9XG5cblxudHlwZSAnYSBxdWV1ZSA9IHtcbiAgbXV0YWJsZSBpbnNlcnQgOiAnYSBxdWV1ZV9lbGVtO1xuICBtdXRhYmxlIGJvZHkgOiAnYSBxdWV1ZV9lbGVtO1xufVxuXG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZTogcXVldWUgZWxlbWVudCBkZWZpbml0aW9uLlxuICAgVGhlIHByZXR0eS1wcmludGVyIHF1ZXVlIGNvbnRhaW5zIGZvcm1hdHRpbmcgZWxlbWVudHMgdG8gYmUgcHJpbnRlZC5cbiAgIEVhY2ggZm9ybWF0dGluZyBlbGVtZW50IGlzIGEgdHVwbGUgKHNpemUsIHRva2VuLCBsZW5ndGgpLCB3aGVyZVxuICAgLSBsZW5ndGggaXMgdGhlIGRlY2xhcmVkIGxlbmd0aCBvZiB0aGUgdG9rZW4sXG4gICAtIHNpemUgaXMgZWZmZWN0aXZlIHNpemUgb2YgdGhlIHRva2VuIHdoZW4gaXQgaXMgcHJpbnRlZFxuICAgICAoc2l6ZSBpcyBzZXQgd2hlbiB0aGUgc2l6ZSBvZiB0aGUgYm94IGlzIGtub3duLCBzbyB0aGF0IHNpemUgb2YgYnJlYWtcbiAgICAgIGhpbnRzIGFyZSBkZWZpbml0aXZlKS4gKilcbnR5cGUgcHBfcXVldWVfZWxlbSA9IHtcbiAgbXV0YWJsZSBlbGVtX3NpemUgOiBzaXplO1xuICB0b2tlbiA6IHBwX3Rva2VuO1xuICBsZW5ndGggOiBpbnQ7XG59XG5cblxuKCogVGhlIHByZXR0eS1wcmludGVyIHF1ZXVlIGRlZmluaXRpb24uICopXG50eXBlIHBwX3F1ZXVlID0gcHBfcXVldWVfZWxlbSBxdWV1ZVxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgc2Nhbm5pbmcgc3RhY2suICopXG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBzY2FubmluZyBzdGFjazogc2Nhbm5pbmcgZWxlbWVudCBkZWZpbml0aW9uLlxuICAgRWFjaCBlbGVtZW50IGlzIChsZWZ0X3RvdGFsLCBxdWV1ZSBlbGVtZW50KSB3aGVyZSBsZWZ0X3RvdGFsXG4gICBpcyB0aGUgdmFsdWUgb2YgcHBfbGVmdF90b3RhbCB3aGVuIHRoZSBlbGVtZW50IGhhcyBiZWVuIGVucXVldWVkLiAqKVxudHlwZSBwcF9zY2FuX2VsZW0gPSBTY2FuX2VsZW0gb2YgaW50ICogcHBfcXVldWVfZWxlbVxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgc2Nhbm5pbmcgc3RhY2sgZGVmaW5pdGlvbi4gKilcbnR5cGUgcHBfc2Nhbl9zdGFjayA9IHBwX3NjYW5fZWxlbSBsaXN0XG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBmb3JtYXR0aW5nIHN0YWNrOlxuICAgdGhlIGZvcm1hdHRpbmcgc3RhY2sgY29udGFpbnMgdGhlIGRlc2NyaXB0aW9uIG9mIGFsbCB0aGUgY3VycmVudGx5IGFjdGl2ZVxuICAgYm94ZXM7IHRoZSBwcmV0dHktcHJpbnRlciBmb3JtYXR0aW5nIHN0YWNrIGlzIHVzZWQgdG8gc3BsaXQgdGhlIGxpbmVzXG4gICB3aGlsZSBwcmludGluZyB0b2tlbnMuICopXG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBmb3JtYXR0aW5nIHN0YWNrOiBmb3JtYXR0aW5nIHN0YWNrIGVsZW1lbnQgZGVmaW5pdGlvbi5cbiAgIEVhY2ggc3RhY2sgZWxlbWVudCBkZXNjcmliZXMgYSBwcmV0dHktcHJpbnRpbmcgYm94LiAqKVxudHlwZSBwcF9mb3JtYXRfZWxlbSA9IEZvcm1hdF9lbGVtIG9mIGJveF90eXBlICogaW50XG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBmb3JtYXR0aW5nIHN0YWNrIGRlZmluaXRpb24uICopXG50eXBlIHBwX2Zvcm1hdF9zdGFjayA9IHBwX2Zvcm1hdF9lbGVtIGxpc3RcblxuKCogVGhlIHByZXR0eS1wcmludGVyIHNlbWFudGljcyB0YWcgc3RhY2sgZGVmaW5pdGlvbi4gKilcbnR5cGUgcHBfdGFnX3N0YWNrID0gdGFnIGxpc3RcblxuKCogVGhlIGZvcm1hdHRlciBkZWZpbml0aW9uLlxuICAgRWFjaCBmb3JtYXR0ZXIgdmFsdWUgaXMgYSBwcmV0dHktcHJpbnRlciBpbnN0YW5jZSB3aXRoIGFsbCBpdHNcbiAgIG1hY2hpbmVyeS4gKilcbnR5cGUgZm9ybWF0dGVyID0ge1xuICAoKiBUaGUgdmFyaW91cyBzdGFja3MuICopXG4gIG11dGFibGUgcHBfc2Nhbl9zdGFjayA6IHBwX3NjYW5fc3RhY2s7XG4gIG11dGFibGUgcHBfZm9ybWF0X3N0YWNrIDogcHBfZm9ybWF0X3N0YWNrO1xuICBtdXRhYmxlIHBwX3Rib3hfc3RhY2sgOiB0Ym94IGxpc3Q7XG4gIG11dGFibGUgcHBfdGFnX3N0YWNrIDogcHBfdGFnX3N0YWNrO1xuICBtdXRhYmxlIHBwX21hcmtfc3RhY2sgOiBwcF90YWdfc3RhY2s7XG4gICgqIFZhbHVlIG9mIHJpZ2h0IG1hcmdpbi4gKilcbiAgbXV0YWJsZSBwcF9tYXJnaW4gOiBpbnQ7XG4gICgqIE1pbmltYWwgc3BhY2UgbGVmdCBiZWZvcmUgbWFyZ2luLCB3aGVuIG9wZW5pbmcgYSBib3guICopXG4gIG11dGFibGUgcHBfbWluX3NwYWNlX2xlZnQgOiBpbnQ7XG4gICgqIE1heGltdW0gdmFsdWUgb2YgaW5kZW50YXRpb246XG4gICAgIG5vIGJveCBjYW4gYmUgb3BlbmVkIGZ1cnRoZXIuICopXG4gIG11dGFibGUgcHBfbWF4X2luZGVudCA6IGludDtcbiAgKCogU3BhY2UgcmVtYWluaW5nIG9uIHRoZSBjdXJyZW50IGxpbmUuICopXG4gIG11dGFibGUgcHBfc3BhY2VfbGVmdCA6IGludDtcbiAgKCogQ3VycmVudCB2YWx1ZSBvZiBpbmRlbnRhdGlvbi4gKilcbiAgbXV0YWJsZSBwcF9jdXJyZW50X2luZGVudCA6IGludDtcbiAgKCogVHJ1ZSB3aGVuIHRoZSBsaW5lIGhhcyBiZWVuIGJyb2tlbiBieSB0aGUgcHJldHR5LXByaW50ZXIuICopXG4gIG11dGFibGUgcHBfaXNfbmV3X2xpbmUgOiBib29sO1xuICAoKiBUb3RhbCB3aWR0aCBvZiB0b2tlbnMgYWxyZWFkeSBwcmludGVkLiAqKVxuICBtdXRhYmxlIHBwX2xlZnRfdG90YWwgOiBpbnQ7XG4gICgqIFRvdGFsIHdpZHRoIG9mIHRva2VucyBldmVyIHB1dCBpbiBxdWV1ZS4gKilcbiAgbXV0YWJsZSBwcF9yaWdodF90b3RhbCA6IGludDtcbiAgKCogQ3VycmVudCBudW1iZXIgb2Ygb3BlbiBib3hlcy4gKilcbiAgbXV0YWJsZSBwcF9jdXJyX2RlcHRoIDogaW50O1xuICAoKiBNYXhpbXVtIG51bWJlciBvZiBib3hlcyB3aGljaCBjYW4gYmUgc2ltdWx0YW5lb3VzbHkgb3Blbi4gKilcbiAgbXV0YWJsZSBwcF9tYXhfYm94ZXMgOiBpbnQ7XG4gICgqIEVsbGlwc2lzIHN0cmluZy4gKilcbiAgbXV0YWJsZSBwcF9lbGxpcHNpcyA6IHN0cmluZztcbiAgKCogT3V0cHV0IGZ1bmN0aW9uLiAqKVxuICBtdXRhYmxlIHBwX291dF9zdHJpbmcgOiBzdHJpbmcgLT4gaW50IC0+IGludCAtPiB1bml0O1xuICAoKiBGbHVzaGluZyBmdW5jdGlvbi4gKilcbiAgbXV0YWJsZSBwcF9vdXRfZmx1c2ggOiB1bml0IC0+IHVuaXQ7XG4gICgqIE91dHB1dCBvZiBuZXcgbGluZXMuICopXG4gIG11dGFibGUgcHBfb3V0X25ld2xpbmUgOiB1bml0IC0+IHVuaXQ7XG4gICgqIE91dHB1dCBvZiBicmVhayBoaW50cyBzcGFjZXMuICopXG4gIG11dGFibGUgcHBfb3V0X3NwYWNlcyA6IGludCAtPiB1bml0O1xuICAoKiBPdXRwdXQgb2YgaW5kZW50YXRpb24gb2YgbmV3IGxpbmVzLiAqKVxuICBtdXRhYmxlIHBwX291dF9pbmRlbnQgOiBpbnQgLT4gdW5pdDtcbiAgKCogQXJlIHRhZ3MgcHJpbnRlZCA/ICopXG4gIG11dGFibGUgcHBfcHJpbnRfdGFncyA6IGJvb2w7XG4gICgqIEFyZSB0YWdzIG1hcmtlZCA/ICopXG4gIG11dGFibGUgcHBfbWFya190YWdzIDogYm9vbDtcbiAgKCogRmluZCBvcGVuaW5nIGFuZCBjbG9zaW5nIG1hcmtlcnMgb2YgdGFncy4gKilcbiAgbXV0YWJsZSBwcF9tYXJrX29wZW5fdGFnIDogdGFnIC0+IHN0cmluZztcbiAgbXV0YWJsZSBwcF9tYXJrX2Nsb3NlX3RhZyA6IHRhZyAtPiBzdHJpbmc7XG4gIG11dGFibGUgcHBfcHJpbnRfb3Blbl90YWcgOiB0YWcgLT4gdW5pdDtcbiAgbXV0YWJsZSBwcF9wcmludF9jbG9zZV90YWcgOiB0YWcgLT4gdW5pdDtcbiAgKCogVGhlIHByZXR0eS1wcmludGVyIHF1ZXVlLiAqKVxuICBtdXRhYmxlIHBwX3F1ZXVlIDogcHBfcXVldWU7XG59XG5cblxuKCogVGhlIGZvcm1hdHRlciBzcGVjaWZpYyB0YWcgaGFuZGxpbmcgZnVuY3Rpb25zLiAqKVxudHlwZSBmb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyA9IHtcbiAgbWFya19vcGVuX3RhZyA6IHRhZyAtPiBzdHJpbmc7XG4gIG1hcmtfY2xvc2VfdGFnIDogdGFnIC0+IHN0cmluZztcbiAgcHJpbnRfb3Blbl90YWcgOiB0YWcgLT4gdW5pdDtcbiAgcHJpbnRfY2xvc2VfdGFnIDogdGFnIC0+IHVuaXQ7XG59XG5cblxuKCogVGhlIGZvcm1hdHRlciBmdW5jdGlvbnMgdG8gb3V0cHV0IG1hdGVyaWFsLiAqKVxudHlwZSBmb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyA9IHtcbiAgb3V0X3N0cmluZyA6IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHVuaXQ7XG4gIG91dF9mbHVzaCA6IHVuaXQgLT4gdW5pdDtcbiAgb3V0X25ld2xpbmUgOiB1bml0IC0+IHVuaXQ7XG4gIG91dF9zcGFjZXMgOiBpbnQgLT4gdW5pdDtcbiAgb3V0X2luZGVudCA6IGludCAtPiB1bml0O1xufVxuXG5cbigqXG5cbiAgQXV4aWxpYXJpZXMgYW5kIGJhc2ljIGZ1bmN0aW9ucy5cblxuKilcblxuKCogUXVldWVzIGF1eGlsaWFyaWVzLiAqKVxuXG5sZXQgbWFrZV9xdWV1ZSAoKSA9IHsgaW5zZXJ0ID0gTmlsOyBib2R5ID0gTmlsOyB9XG5cbmxldCBjbGVhcl9xdWV1ZSBxID0gcS5pbnNlcnQgPC0gTmlsOyBxLmJvZHkgPC0gTmlsXG5cbmxldCBhZGRfcXVldWUgeCBxID1cbiAgbGV0IGMgPSBDb25zIHsgaGVhZCA9IHg7IHRhaWwgPSBOaWw7IH0gaW5cbiAgbWF0Y2ggcSB3aXRoXG4gIHwgeyBpbnNlcnQgPSBDb25zIGNlbGw7IGJvZHkgPSBfOyB9IC0+XG4gICAgcS5pbnNlcnQgPC0gYzsgY2VsbC50YWlsIDwtIGNcbiAgKCogSW52YXJpYW50OiB3aGVuIGluc2VydCBpcyBOaWwgYm9keSBzaG91bGQgYmUgTmlsLiAqKVxuICB8IHsgaW5zZXJ0ID0gTmlsOyBib2R5ID0gXzsgfSAtPlxuICAgIHEuaW5zZXJ0IDwtIGM7IHEuYm9keSA8LSBjXG5cblxuZXhjZXB0aW9uIEVtcHR5X3F1ZXVlXG5cbmxldCBwZWVrX3F1ZXVlID0gZnVuY3Rpb25cbiAgfCB7IGJvZHkgPSBDb25zIHsgaGVhZCA9IHg7IHRhaWwgPSBfOyB9OyBfIH0gLT4geFxuICB8IHsgYm9keSA9IE5pbDsgaW5zZXJ0ID0gXzsgfSAtPiByYWlzZSBFbXB0eV9xdWV1ZVxuXG5cbmxldCB0YWtlX3F1ZXVlID0gZnVuY3Rpb25cbiAgfCB7IGJvZHkgPSBDb25zIHsgaGVhZCA9IHg7IHRhaWwgPSB0bDsgfTsgXyB9IGFzIHEgLT5cbiAgICBxLmJvZHkgPC0gdGw7XG4gICAgaWYgdGwgPSBOaWwgdGhlbiBxLmluc2VydCA8LSBOaWw7ICgqIE1haW50YWluIHRoZSBpbnZhcmlhbnQuICopXG4gICAgeFxuICB8IHsgYm9keSA9IE5pbDsgaW5zZXJ0ID0gXzsgfSAtPiByYWlzZSBFbXB0eV9xdWV1ZVxuXG5cbigqIEVudGVyIGEgdG9rZW4gaW4gdGhlIHByZXR0eS1wcmludGVyIHF1ZXVlLiAqKVxubGV0IHBwX2VucXVldWUgc3RhdGUgKHsgbGVuZ3RoID0gbGVuOyBffSBhcyB0b2tlbikgPVxuICBzdGF0ZS5wcF9yaWdodF90b3RhbCA8LSBzdGF0ZS5wcF9yaWdodF90b3RhbCArIGxlbjtcbiAgYWRkX3F1ZXVlIHRva2VuIHN0YXRlLnBwX3F1ZXVlXG5cblxubGV0IHBwX2NsZWFyX3F1ZXVlIHN0YXRlID1cbiAgc3RhdGUucHBfbGVmdF90b3RhbCA8LSAxOyBzdGF0ZS5wcF9yaWdodF90b3RhbCA8LSAxO1xuICBjbGVhcl9xdWV1ZSBzdGF0ZS5wcF9xdWV1ZVxuXG5cbigqIFBwX2luZmluaXR5OiBsYXJnZSB2YWx1ZSBmb3IgZGVmYXVsdCB0b2tlbnMgc2l6ZS5cblxuICAgUHBfaW5maW5pdHkgaXMgZG9jdW1lbnRlZCBhcyBiZWluZyBncmVhdGVyIHRoYW4gMWUxMDsgdG8gYXZvaWRcbiAgIGNvbmZ1c2lvbiBhYm91dCB0aGUgd29yZCAnZ3JlYXRlcicsIHdlIGNob29zZSBwcF9pbmZpbml0eSBncmVhdGVyXG4gICB0aGFuIDFlMTAgKyAxOyBmb3IgY29ycmVjdCBoYW5kbGluZyBvZiB0ZXN0cyBpbiB0aGUgYWxnb3JpdGhtLFxuICAgcHBfaW5maW5pdHkgbXVzdCBiZSBldmVuIG9uZSBtb3JlIHRoYW4gMWUxMCArIDE7IGxldCdzIHN0YW5kIG9uIHRoZVxuICAgc2FmZSBzaWRlIGJ5IGNob29zaW5nIDEuZTEwKzEwLlxuXG4gICBQcF9pbmZpbml0eSBjb3VsZCBwcm9iYWJseSBiZSAxMDczNzQxODIzIHRoYXQgaXMgMl4zMCAtIDEsIHRoYXQgaXNcbiAgIHRoZSBtaW5pbWFsIHVwcGVyIGJvdW5kIGZvciBpbnRlZ2Vyczsgbm93IHRoYXQgbWF4X2ludCBpcyBkZWZpbmVkLFxuICAgdGhpcyBsaW1pdCBjb3VsZCBhbHNvIGJlIGRlZmluZWQgYXMgbWF4X2ludCAtIDEuXG5cbiAgIEhvd2V2ZXIsIGJlZm9yZSBzZXR0aW5nIHBwX2luZmluaXR5IHRvIHNvbWV0aGluZyBhcm91bmQgbWF4X2ludCwgd2VcbiAgIG11c3QgY2FyZWZ1bGx5IGRvdWJsZS1jaGVjayBhbGwgdGhlIGludGVnZXIgYXJpdGhtZXRpYyBvcGVyYXRpb25zXG4gICB0aGF0IGludm9sdmUgcHBfaW5maW5pdHksIHNpbmNlIGFueSBvdmVyZmxvdyB3b3VsZCB3cmVjayBoYXZvYyB0aGVcbiAgIHByZXR0eS1wcmludGluZyBhbGdvcml0aG0ncyBpbnZhcmlhbnRzLiBHaXZlbiB0aGF0IHRoaXMgYXJpdGhtZXRpY1xuICAgY29ycmVjdG5lc3MgY2hlY2sgaXMgZGlmZmljdWx0IGFuZCBlcnJvciBwcm9uZSBhbmQgZ2l2ZW4gdGhhdCAxZTEwXG4gICArIDEgaXMgaW4gcHJhY3RpY2UgbGFyZ2UgZW5vdWdoLCB0aGVyZSBpcyBubyBuZWVkIHRvIGF0dGVtcHQgdG8gc2V0XG4gICBwcF9pbmZpbml0eSB0byB0aGUgdGhlb3JldGljYWxseSBtYXhpbXVtIGxpbWl0LiBJdCBpcyBub3Qgd29ydGggdGhlXG4gICBidXJkZW4gISAqKVxubGV0IHBwX2luZmluaXR5ID0gMTAwMDAwMDAxMFxuXG4oKiBPdXRwdXQgZnVuY3Rpb25zIGZvciB0aGUgZm9ybWF0dGVyLiAqKVxubGV0IHBwX291dHB1dF9zdHJpbmcgc3RhdGUgcyA9IHN0YXRlLnBwX291dF9zdHJpbmcgcyAwIChTdHJpbmcubGVuZ3RoIHMpXG5hbmQgcHBfb3V0cHV0X25ld2xpbmUgc3RhdGUgPSBzdGF0ZS5wcF9vdXRfbmV3bGluZSAoKVxuYW5kIHBwX291dHB1dF9zcGFjZXMgc3RhdGUgbiA9IHN0YXRlLnBwX291dF9zcGFjZXMgblxuYW5kIHBwX291dHB1dF9pbmRlbnQgc3RhdGUgbiA9IHN0YXRlLnBwX291dF9pbmRlbnQgblxuXG4oKiBUbyBmb3JtYXQgYSBicmVhaywgaW5kZW50aW5nIGEgbmV3IGxpbmUuICopXG5sZXQgYnJlYWtfbmV3X2xpbmUgc3RhdGUgb2Zmc2V0IHdpZHRoID1cbiAgcHBfb3V0cHV0X25ld2xpbmUgc3RhdGU7XG4gIHN0YXRlLnBwX2lzX25ld19saW5lIDwtIHRydWU7XG4gIGxldCBpbmRlbnQgPSBzdGF0ZS5wcF9tYXJnaW4gLSB3aWR0aCArIG9mZnNldCBpblxuICAoKiBEb24ndCBpbmRlbnQgbW9yZSB0aGFuIHBwX21heF9pbmRlbnQuICopXG4gIGxldCByZWFsX2luZGVudCA9IG1pbiBzdGF0ZS5wcF9tYXhfaW5kZW50IGluZGVudCBpblxuICBzdGF0ZS5wcF9jdXJyZW50X2luZGVudCA8LSByZWFsX2luZGVudDtcbiAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9jdXJyZW50X2luZGVudDtcbiAgcHBfb3V0cHV0X2luZGVudCBzdGF0ZSBzdGF0ZS5wcF9jdXJyZW50X2luZGVudFxuXG5cbigqIFRvIGZvcmNlIGEgbGluZSBicmVhayBpbnNpZGUgYSBib3g6IG5vIG9mZnNldCBpcyBhZGRlZC4gKilcbmxldCBicmVha19saW5lIHN0YXRlIHdpZHRoID0gYnJlYWtfbmV3X2xpbmUgc3RhdGUgMCB3aWR0aFxuXG4oKiBUbyBmb3JtYXQgYSBicmVhayB0aGF0IGZpdHMgb24gdGhlIGN1cnJlbnQgbGluZS4gKilcbmxldCBicmVha19zYW1lX2xpbmUgc3RhdGUgd2lkdGggPVxuICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX3NwYWNlX2xlZnQgLSB3aWR0aDtcbiAgcHBfb3V0cHV0X3NwYWNlcyBzdGF0ZSB3aWR0aFxuXG5cbigqIFRvIGluZGVudCBubyBtb3JlIHRoYW4gcHBfbWF4X2luZGVudCwgaWYgb25lIHRyaWVzIHRvIG9wZW4gYSBib3hcbiAgIGJleW9uZCBwcF9tYXhfaW5kZW50LCB0aGVuIHRoZSBib3ggaXMgcmVqZWN0ZWQgb24gdGhlIGxlZnRcbiAgIGJ5IHNpbXVsYXRpbmcgYSBicmVhay4gKilcbmxldCBwcF9mb3JjZV9icmVha19saW5lIHN0YXRlID1cbiAgbWF0Y2ggc3RhdGUucHBfZm9ybWF0X3N0YWNrIHdpdGhcbiAgfCBGb3JtYXRfZWxlbSAoYmxfdHksIHdpZHRoKSA6OiBfIC0+XG4gICAgaWYgd2lkdGggPiBzdGF0ZS5wcF9zcGFjZV9sZWZ0IHRoZW5cbiAgICAgIChtYXRjaCBibF90eSB3aXRoXG4gICAgICAgfCBQcF9maXRzIC0+ICgpIHwgUHBfaGJveCAtPiAoKVxuICAgICAgIHwgUHBfdmJveCB8IFBwX2h2Ym94IHwgUHBfaG92Ym94IHwgUHBfYm94IC0+XG4gICAgICAgICBicmVha19saW5lIHN0YXRlIHdpZHRoKVxuICB8IFtdIC0+IHBwX291dHB1dF9uZXdsaW5lIHN0YXRlXG5cblxuKCogVG8gc2tpcCBhIHRva2VuLCBpZiB0aGUgcHJldmlvdXMgbGluZSBoYXMgYmVlbiBicm9rZW4uICopXG5sZXQgcHBfc2tpcF90b2tlbiBzdGF0ZSA9XG4gICgqIFdoZW4gY2FsbGluZyBwcF9za2lwX3Rva2VuIHRoZSBxdWV1ZSBjYW5ub3QgYmUgZW1wdHkuICopXG4gIG1hdGNoIHRha2VfcXVldWUgc3RhdGUucHBfcXVldWUgd2l0aFxuICB8IHsgZWxlbV9zaXplID0gc2l6ZTsgbGVuZ3RoID0gbGVuOyB0b2tlbiA9IF87IH0gLT5cbiAgICBzdGF0ZS5wcF9sZWZ0X3RvdGFsIDwtIHN0YXRlLnBwX2xlZnRfdG90YWwgLSBsZW47XG4gICAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9zcGFjZV9sZWZ0ICsgaW50X29mX3NpemUgc2l6ZVxuXG5cbigqXG5cbiAgVGhlIG1haW4gcHJldHR5IHByaW50aW5nIGZ1bmN0aW9ucy5cblxuKilcblxuKCogRm9ybWF0dGluZyBhIHRva2VuIHdpdGggYSBnaXZlbiBzaXplLiAqKVxubGV0IGZvcm1hdF9wcF90b2tlbiBzdGF0ZSBzaXplID0gZnVuY3Rpb25cblxuICB8IFBwX3RleHQgcyAtPlxuICAgIHN0YXRlLnBwX3NwYWNlX2xlZnQgPC0gc3RhdGUucHBfc3BhY2VfbGVmdCAtIHNpemU7XG4gICAgcHBfb3V0cHV0X3N0cmluZyBzdGF0ZSBzO1xuICAgIHN0YXRlLnBwX2lzX25ld19saW5lIDwtIGZhbHNlXG5cbiAgfCBQcF9iZWdpbiAob2ZmLCB0eSkgLT5cbiAgICBsZXQgaW5zZXJ0aW9uX3BvaW50ID0gc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfc3BhY2VfbGVmdCBpblxuICAgIGlmIGluc2VydGlvbl9wb2ludCA+IHN0YXRlLnBwX21heF9pbmRlbnQgdGhlblxuICAgICAgKCogY2FuIG5vdCBvcGVuIGEgYm94IHJpZ2h0IHRoZXJlLiAqKVxuICAgICAgYmVnaW4gcHBfZm9yY2VfYnJlYWtfbGluZSBzdGF0ZSBlbmQ7XG4gICAgbGV0IG9mZnNldCA9IHN0YXRlLnBwX3NwYWNlX2xlZnQgLSBvZmYgaW5cbiAgICBsZXQgYmxfdHlwZSA9XG4gICAgICBiZWdpbiBtYXRjaCB0eSB3aXRoXG4gICAgICB8IFBwX3Zib3ggLT4gUHBfdmJveFxuICAgICAgfCBQcF9oYm94IHwgUHBfaHZib3ggfCBQcF9ob3Zib3ggfCBQcF9ib3ggfCBQcF9maXRzIC0+XG4gICAgICAgIGlmIHNpemUgPiBzdGF0ZS5wcF9zcGFjZV9sZWZ0IHRoZW4gdHkgZWxzZSBQcF9maXRzXG4gICAgICBlbmQgaW5cbiAgICBzdGF0ZS5wcF9mb3JtYXRfc3RhY2sgPC1cbiAgICAgIEZvcm1hdF9lbGVtIChibF90eXBlLCBvZmZzZXQpIDo6IHN0YXRlLnBwX2Zvcm1hdF9zdGFja1xuXG4gIHwgUHBfZW5kIC0+XG4gICAgYmVnaW4gbWF0Y2ggc3RhdGUucHBfZm9ybWF0X3N0YWNrIHdpdGhcbiAgICB8IF8gOjogbHMgLT4gc3RhdGUucHBfZm9ybWF0X3N0YWNrIDwtIGxzXG4gICAgfCBbXSAtPiAoKSAoKiBObyBtb3JlIGJveCB0byBjbG9zZS4gKilcbiAgICBlbmRcblxuICB8IFBwX3RiZWdpbiAoUHBfdGJveCBfIGFzIHRib3gpIC0+XG4gICAgc3RhdGUucHBfdGJveF9zdGFjayA8LSB0Ym94IDo6IHN0YXRlLnBwX3Rib3hfc3RhY2tcblxuICB8IFBwX3RlbmQgLT5cbiAgICBiZWdpbiBtYXRjaCBzdGF0ZS5wcF90Ym94X3N0YWNrIHdpdGhcbiAgICB8IF8gOjogbHMgLT4gc3RhdGUucHBfdGJveF9zdGFjayA8LSBsc1xuICAgIHwgW10gLT4gKCkgKCogTm8gbW9yZSB0YWJ1bGF0aW9uIGJveCB0byBjbG9zZS4gKilcbiAgICBlbmRcblxuICB8IFBwX3N0YWIgLT5cbiAgICBiZWdpbiBtYXRjaCBzdGF0ZS5wcF90Ym94X3N0YWNrIHdpdGhcbiAgICB8IFBwX3Rib3ggdGFicyA6OiBfIC0+XG4gICAgICBsZXQgcmVjIGFkZF90YWIgbiA9IGZ1bmN0aW9uXG4gICAgICAgIHwgW10gLT4gW25dXG4gICAgICAgIHwgeCA6OiBsIGFzIGxzIC0+IGlmIG4gPCB4IHRoZW4gbiA6OiBscyBlbHNlIHggOjogYWRkX3RhYiBuIGwgaW5cbiAgICAgIHRhYnMgOj0gYWRkX3RhYiAoc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfc3BhY2VfbGVmdCkgIXRhYnNcbiAgICB8IFtdIC0+ICgpICgqIE5vIG9wZW4gdGFidWxhdGlvbiBib3guICopXG4gICAgZW5kXG5cbiAgfCBQcF90YnJlYWsgKG4sIG9mZikgLT5cbiAgICBsZXQgaW5zZXJ0aW9uX3BvaW50ID0gc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfc3BhY2VfbGVmdCBpblxuICAgIGJlZ2luIG1hdGNoIHN0YXRlLnBwX3Rib3hfc3RhY2sgd2l0aFxuICAgIHwgUHBfdGJveCB0YWJzIDo6IF8gLT5cbiAgICAgIGxldCByZWMgZmluZCBuID0gZnVuY3Rpb25cbiAgICAgICAgfCB4IDo6IGwgLT4gaWYgeCA+PSBuIHRoZW4geCBlbHNlIGZpbmQgbiBsXG4gICAgICAgIHwgW10gLT4gcmFpc2UgTm90X2ZvdW5kIGluXG4gICAgICBsZXQgdGFiID1cbiAgICAgICAgbWF0Y2ggIXRhYnMgd2l0aFxuICAgICAgICB8IHggOjogXyAtPlxuICAgICAgICAgIGJlZ2luXG4gICAgICAgICAgICB0cnkgZmluZCBpbnNlcnRpb25fcG9pbnQgIXRhYnMgd2l0aFxuICAgICAgICAgICAgfCBOb3RfZm91bmQgLT4geFxuICAgICAgICAgIGVuZFxuICAgICAgICB8IF8gLT4gaW5zZXJ0aW9uX3BvaW50IGluXG4gICAgICBsZXQgb2Zmc2V0ID0gdGFiIC0gaW5zZXJ0aW9uX3BvaW50IGluXG4gICAgICBpZiBvZmZzZXQgPj0gMFxuICAgICAgdGhlbiBicmVha19zYW1lX2xpbmUgc3RhdGUgKG9mZnNldCArIG4pXG4gICAgICBlbHNlIGJyZWFrX25ld19saW5lIHN0YXRlICh0YWIgKyBvZmYpIHN0YXRlLnBwX21hcmdpblxuICAgIHwgW10gLT4gKCkgKCogTm8gb3BlbiB0YWJ1bGF0aW9uIGJveC4gKilcbiAgICBlbmRcblxuICB8IFBwX25ld2xpbmUgLT5cbiAgICBiZWdpbiBtYXRjaCBzdGF0ZS5wcF9mb3JtYXRfc3RhY2sgd2l0aFxuICAgIHwgRm9ybWF0X2VsZW0gKF8sIHdpZHRoKSA6OiBfIC0+IGJyZWFrX2xpbmUgc3RhdGUgd2lkdGhcbiAgICB8IFtdIC0+IHBwX291dHB1dF9uZXdsaW5lIHN0YXRlICgqIE5vIG9wZW4gYm94LiAqKVxuICAgIGVuZFxuXG4gIHwgUHBfaWZfbmV3bGluZSAtPlxuICAgIGlmIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50ICE9IHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX3NwYWNlX2xlZnRcbiAgICB0aGVuIHBwX3NraXBfdG9rZW4gc3RhdGVcblxuICB8IFBwX2JyZWFrIChuLCBvZmYpIC0+XG4gICAgYmVnaW4gbWF0Y2ggc3RhdGUucHBfZm9ybWF0X3N0YWNrIHdpdGhcbiAgICB8IEZvcm1hdF9lbGVtICh0eSwgd2lkdGgpIDo6IF8gLT5cbiAgICAgIGJlZ2luIG1hdGNoIHR5IHdpdGhcbiAgICAgIHwgUHBfaG92Ym94IC0+XG4gICAgICAgIGlmIHNpemUgPiBzdGF0ZS5wcF9zcGFjZV9sZWZ0XG4gICAgICAgIHRoZW4gYnJlYWtfbmV3X2xpbmUgc3RhdGUgb2ZmIHdpZHRoXG4gICAgICAgIGVsc2UgYnJlYWtfc2FtZV9saW5lIHN0YXRlIG5cbiAgICAgIHwgUHBfYm94IC0+XG4gICAgICAgICgqIEhhdmUgdGhlIGxpbmUganVzdCBiZWVuIGJyb2tlbiBoZXJlID8gKilcbiAgICAgICAgaWYgc3RhdGUucHBfaXNfbmV3X2xpbmUgdGhlbiBicmVha19zYW1lX2xpbmUgc3RhdGUgbiBlbHNlXG4gICAgICAgIGlmIHNpemUgPiBzdGF0ZS5wcF9zcGFjZV9sZWZ0XG4gICAgICAgICB0aGVuIGJyZWFrX25ld19saW5lIHN0YXRlIG9mZiB3aWR0aCBlbHNlXG4gICAgICAgICgqIGJyZWFrIHRoZSBsaW5lIGhlcmUgbGVhZHMgdG8gbmV3IGluZGVudGF0aW9uID8gKilcbiAgICAgICAgaWYgc3RhdGUucHBfY3VycmVudF9pbmRlbnQgPiBzdGF0ZS5wcF9tYXJnaW4gLSB3aWR0aCArIG9mZlxuICAgICAgICB0aGVuIGJyZWFrX25ld19saW5lIHN0YXRlIG9mZiB3aWR0aFxuICAgICAgICBlbHNlIGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBuXG4gICAgICB8IFBwX2h2Ym94IC0+IGJyZWFrX25ld19saW5lIHN0YXRlIG9mZiB3aWR0aFxuICAgICAgfCBQcF9maXRzIC0+IGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBuXG4gICAgICB8IFBwX3Zib3ggLT4gYnJlYWtfbmV3X2xpbmUgc3RhdGUgb2ZmIHdpZHRoXG4gICAgICB8IFBwX2hib3ggLT4gYnJlYWtfc2FtZV9saW5lIHN0YXRlIG5cbiAgICAgIGVuZFxuICAgIHwgW10gLT4gKCkgKCogTm8gb3BlbiBib3guICopXG4gICAgZW5kXG5cbiAgIHwgUHBfb3Blbl90YWcgdGFnX25hbWUgLT5cbiAgICAgbGV0IG1hcmtlciA9IHN0YXRlLnBwX21hcmtfb3Blbl90YWcgdGFnX25hbWUgaW5cbiAgICAgcHBfb3V0cHV0X3N0cmluZyBzdGF0ZSBtYXJrZXI7XG4gICAgIHN0YXRlLnBwX21hcmtfc3RhY2sgPC0gdGFnX25hbWUgOjogc3RhdGUucHBfbWFya19zdGFja1xuXG4gICB8IFBwX2Nsb3NlX3RhZyAtPlxuICAgICBiZWdpbiBtYXRjaCBzdGF0ZS5wcF9tYXJrX3N0YWNrIHdpdGhcbiAgICAgfCB0YWdfbmFtZSA6OiB0YWdzIC0+XG4gICAgICAgbGV0IG1hcmtlciA9IHN0YXRlLnBwX21hcmtfY2xvc2VfdGFnIHRhZ19uYW1lIGluXG4gICAgICAgcHBfb3V0cHV0X3N0cmluZyBzdGF0ZSBtYXJrZXI7XG4gICAgICAgc3RhdGUucHBfbWFya19zdGFjayA8LSB0YWdzXG4gICAgIHwgW10gLT4gKCkgKCogTm8gbW9yZSB0YWcgdG8gY2xvc2UuICopXG4gICAgIGVuZFxuXG5cbigqIFByaW50IGlmIHRva2VuIHNpemUgaXMga25vd24gZWxzZSBwcmludGluZyBpcyBkZWxheWVkLlxuICAgU2l6ZSBpcyBrbm93biB3aGVuIG5vdCBuZWdhdGl2ZS5cbiAgIFByaW50aW5nIGlzIGRlbGF5ZWQgd2hlbiB0aGUgdGV4dCB3YWl0aW5nIGluIHRoZSBxdWV1ZSByZXF1aXJlc1xuICAgbW9yZSByb29tIHRvIGZvcm1hdCB0aGFuIGV4aXN0cyBvbiB0aGUgY3VycmVudCBsaW5lLlxuXG4gICBOb3RlOiBbYWR2YW5jZV9sb29wXSBtdXN0IGJlIHRhaWwgcmVjdXJzaXZlIHRvIHByZXZlbnQgc3RhY2sgb3ZlcmZsb3dzLiAqKVxubGV0IHJlYyBhZHZhbmNlX2xvb3Agc3RhdGUgPVxuICBtYXRjaCBwZWVrX3F1ZXVlIHN0YXRlLnBwX3F1ZXVlIHdpdGhcbiAgfCB7ZWxlbV9zaXplID0gc2l6ZTsgdG9rZW4gPSB0b2s7IGxlbmd0aCA9IGxlbn0gLT5cbiAgICBsZXQgc2l6ZSA9IGludF9vZl9zaXplIHNpemUgaW5cbiAgICBpZiBub3RcbiAgICAgICAgIChzaXplIDwgMCAmJlxuICAgICAgICAgIChzdGF0ZS5wcF9yaWdodF90b3RhbCAtIHN0YXRlLnBwX2xlZnRfdG90YWwgPCBzdGF0ZS5wcF9zcGFjZV9sZWZ0KSlcbiAgICB0aGVuIGJlZ2luXG4gICAgICBpZ25vcmUgKHRha2VfcXVldWUgc3RhdGUucHBfcXVldWUpO1xuICAgICAgZm9ybWF0X3BwX3Rva2VuIHN0YXRlIChpZiBzaXplIDwgMCB0aGVuIHBwX2luZmluaXR5IGVsc2Ugc2l6ZSkgdG9rO1xuICAgICAgc3RhdGUucHBfbGVmdF90b3RhbCA8LSBsZW4gKyBzdGF0ZS5wcF9sZWZ0X3RvdGFsO1xuICAgICAgYWR2YW5jZV9sb29wIHN0YXRlXG4gICAgZW5kXG5cblxubGV0IGFkdmFuY2VfbGVmdCBzdGF0ZSA9XG4gIHRyeSBhZHZhbmNlX2xvb3Agc3RhdGUgd2l0aFxuICB8IEVtcHR5X3F1ZXVlIC0+ICgpXG5cblxuKCogVG8gZW5xdWV1ZSBhIHRva2VuIDogdHJ5IHRvIGFkdmFuY2UuICopXG5sZXQgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIHRvayA9IHBwX2VucXVldWUgc3RhdGUgdG9rOyBhZHZhbmNlX2xlZnQgc3RhdGVcblxuKCogQnVpbGRpbmcgcHJldHR5LXByaW50ZXIgcXVldWUgZWxlbWVudHMuICopXG5sZXQgbWFrZV9xdWV1ZV9lbGVtIHNpemUgdG9rIGxlbiA9XG4gIHsgZWxlbV9zaXplID0gc2l6ZTsgdG9rZW4gPSB0b2s7IGxlbmd0aCA9IGxlbjsgfVxuXG5cbigqIFRvIGVucXVldWUgc3RyaW5ncy4gKilcbmxldCBlbnF1ZXVlX3N0cmluZ19hcyBzdGF0ZSBzaXplIHMgPVxuICBsZXQgbGVuID0gaW50X29mX3NpemUgc2l6ZSBpblxuICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgKG1ha2VfcXVldWVfZWxlbSBzaXplIChQcF90ZXh0IHMpIGxlbilcblxuXG5sZXQgZW5xdWV1ZV9zdHJpbmcgc3RhdGUgcyA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgZW5xdWV1ZV9zdHJpbmdfYXMgc3RhdGUgKHNpemVfb2ZfaW50IGxlbikgc1xuXG5cbigqIFJvdXRpbmVzIGZvciBzY2FuIHN0YWNrXG4gICBkZXRlcm1pbmUgc2l6ZSBvZiBib3hlcy4gKilcblxuKCogVGhlIHNjYW5fc3RhY2sgaXMgbmV2ZXIgZW1wdHkuICopXG5sZXQgc2Nhbl9zdGFja19ib3R0b20gPVxuICBsZXQgcV9lbGVtID0gbWFrZV9xdWV1ZV9lbGVtIChzaXplX29mX2ludCAoLTEpKSAoUHBfdGV4dCBcIlwiKSAwIGluXG4gIFtTY2FuX2VsZW0gKC0xLCBxX2VsZW0pXVxuXG5cbigqIENsZWFyaW5nIHRoZSBwcmV0dHktcHJpbnRlciBzY2FubmluZyBzdGFjay4gKilcbmxldCBjbGVhcl9zY2FuX3N0YWNrIHN0YXRlID0gc3RhdGUucHBfc2Nhbl9zdGFjayA8LSBzY2FuX3N0YWNrX2JvdHRvbVxuXG4oKiBTZXR0aW5nIHRoZSBzaXplIG9mIGJveGVzIG9uIHNjYW4gc3RhY2s6XG4gICBpZiB0eSA9IHRydWUgdGhlbiBzaXplIG9mIGJyZWFrIGlzIHNldCBlbHNlIHNpemUgb2YgYm94IGlzIHNldDtcbiAgIGluIGVhY2ggY2FzZSBwcF9zY2FuX3N0YWNrIGlzIHBvcHBlZC5cblxuICAgTm90ZTpcbiAgIFBhdHRlcm4gbWF0Y2hpbmcgb24gc2NhbiBzdGFjayBpcyBleGhhdXN0aXZlLCBzaW5jZSBzY2FuX3N0YWNrIGlzIG5ldmVyXG4gICBlbXB0eS5cbiAgIFBhdHRlcm4gbWF0Y2hpbmcgb24gdG9rZW4gaW4gc2NhbiBzdGFjayBpcyBhbHNvIGV4aGF1c3RpdmUsXG4gICBzaW5jZSBzY2FuX3B1c2ggaXMgdXNlZCBvbiBicmVha3MgYW5kIG9wZW5pbmcgb2YgYm94ZXMuICopXG5sZXQgc2V0X3NpemUgc3RhdGUgdHkgPVxuICBtYXRjaCBzdGF0ZS5wcF9zY2FuX3N0YWNrIHdpdGhcbiAgfCBTY2FuX2VsZW1cbiAgICAgIChsZWZ0X3RvdCxcbiAgICAgICAoeyBlbGVtX3NpemUgPSBzaXplOyB0b2tlbiA9IHRvazsgbGVuZ3RoID0gXzsgfSBhcyBxdWV1ZV9lbGVtKSkgOjogdCAtPlxuICAgIGxldCBzaXplID0gaW50X29mX3NpemUgc2l6ZSBpblxuICAgICgqIHRlc3QgaWYgc2NhbiBzdGFjayBjb250YWlucyBhbnkgZGF0YSB0aGF0IGlzIG5vdCBvYnNvbGV0ZS4gKilcbiAgICBpZiBsZWZ0X3RvdCA8IHN0YXRlLnBwX2xlZnRfdG90YWwgdGhlbiBjbGVhcl9zY2FuX3N0YWNrIHN0YXRlIGVsc2VcbiAgICAgIGJlZ2luIG1hdGNoIHRvayB3aXRoXG4gICAgICB8IFBwX2JyZWFrIChfLCBfKSB8IFBwX3RicmVhayAoXywgXykgLT5cbiAgICAgICAgaWYgdHkgdGhlblxuICAgICAgICBiZWdpblxuICAgICAgICAgIHF1ZXVlX2VsZW0uZWxlbV9zaXplIDwtIHNpemVfb2ZfaW50IChzdGF0ZS5wcF9yaWdodF90b3RhbCArIHNpemUpO1xuICAgICAgICAgIHN0YXRlLnBwX3NjYW5fc3RhY2sgPC0gdFxuICAgICAgICBlbmRcbiAgICAgIHwgUHBfYmVnaW4gKF8sIF8pIC0+XG4gICAgICAgIGlmIG5vdCB0eSB0aGVuXG4gICAgICAgIGJlZ2luXG4gICAgICAgICAgcXVldWVfZWxlbS5lbGVtX3NpemUgPC0gc2l6ZV9vZl9pbnQgKHN0YXRlLnBwX3JpZ2h0X3RvdGFsICsgc2l6ZSk7XG4gICAgICAgICAgc3RhdGUucHBfc2Nhbl9zdGFjayA8LSB0XG4gICAgICAgIGVuZFxuICAgICAgfCBQcF90ZXh0IF8gfCBQcF9zdGFiIHwgUHBfdGJlZ2luIF8gfCBQcF90ZW5kIHwgUHBfZW5kXG4gICAgICB8IFBwX25ld2xpbmUgfCBQcF9pZl9uZXdsaW5lXG4gICAgICB8IFBwX29wZW5fdGFnIF8gfCBQcF9jbG9zZV90YWcgLT5cbiAgICAgICAgKCkgKCogc2Nhbl9wdXNoIGlzIG9ubHkgdXNlZCBmb3IgYnJlYWtzIGFuZCBib3hlcy4gKilcbiAgICAgIGVuZFxuICB8IFtdIC0+ICgpICgqIHNjYW5fc3RhY2sgaXMgbmV2ZXIgZW1wdHkuICopXG5cblxuKCogUHVzaCBhIHRva2VuIG9uIHByZXR0eS1wcmludGVyIHNjYW5uaW5nIHN0YWNrLlxuICAgSWYgYiBpcyB0cnVlIHNldF9zaXplIGlzIGNhbGxlZC4gKilcbmxldCBzY2FuX3B1c2ggc3RhdGUgYiB0b2sgPVxuICBwcF9lbnF1ZXVlIHN0YXRlIHRvaztcbiAgaWYgYiB0aGVuIHNldF9zaXplIHN0YXRlIHRydWU7XG4gIHN0YXRlLnBwX3NjYW5fc3RhY2sgPC1cbiAgICBTY2FuX2VsZW0gKHN0YXRlLnBwX3JpZ2h0X3RvdGFsLCB0b2spIDo6IHN0YXRlLnBwX3NjYW5fc3RhY2tcblxuXG4oKiBUbyBvcGVuIGEgbmV3IGJveCA6XG4gICB0aGUgdXNlciBtYXkgc2V0IHRoZSBkZXB0aCBib3VuZCBwcF9tYXhfYm94ZXNcbiAgIGFueSB0ZXh0IG5lc3RlZCBkZWVwZXIgaXMgcHJpbnRlZCBhcyB0aGUgZWxsaXBzaXMgc3RyaW5nLiAqKVxubGV0IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgYnJfdHkgPVxuICBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwtIHN0YXRlLnBwX2N1cnJfZGVwdGggKyAxO1xuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBsZXQgZWxlbSA9XG4gICAgICBtYWtlX3F1ZXVlX2VsZW1cbiAgICAgICAgKHNpemVfb2ZfaW50ICgtIHN0YXRlLnBwX3JpZ2h0X3RvdGFsKSlcbiAgICAgICAgKFBwX2JlZ2luIChpbmRlbnQsIGJyX3R5KSlcbiAgICAgICAgMCBpblxuICAgIHNjYW5fcHVzaCBzdGF0ZSBmYWxzZSBlbGVtIGVsc2VcbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA9IHN0YXRlLnBwX21heF9ib3hlc1xuICB0aGVuIGVucXVldWVfc3RyaW5nIHN0YXRlIHN0YXRlLnBwX2VsbGlwc2lzXG5cblxuKCogVGhlIGJveCB3aGljaCBpcyBhbHdheXMgb3Blbi4gKilcbmxldCBwcF9vcGVuX3N5c19ib3ggc3RhdGUgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgMCBQcF9ob3Zib3hcblxuKCogQ2xvc2UgYSBib3gsIHNldHRpbmcgc2l6ZXMgb2YgaXRzIHN1YiBib3hlcy4gKilcbmxldCBwcF9jbG9zZV9ib3ggc3RhdGUgKCkgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoID4gMSB0aGVuXG4gIGJlZ2luXG4gICAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgYmVnaW5cbiAgICAgIHBwX2VucXVldWUgc3RhdGVcbiAgICAgICAgeyBlbGVtX3NpemUgPSBzaXplX29mX2ludCAwOyB0b2tlbiA9IFBwX2VuZDsgbGVuZ3RoID0gMDsgfTtcbiAgICAgIHNldF9zaXplIHN0YXRlIHRydWU7IHNldF9zaXplIHN0YXRlIGZhbHNlXG4gICAgZW5kO1xuICAgIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gc3RhdGUucHBfY3Vycl9kZXB0aCAtIDE7XG4gIGVuZFxuXG5cbigqIE9wZW4gYSB0YWcsIHB1c2hpbmcgaXQgb24gdGhlIHRhZyBzdGFjay4gKilcbmxldCBwcF9vcGVuX3RhZyBzdGF0ZSB0YWdfbmFtZSA9XG4gIGlmIHN0YXRlLnBwX3ByaW50X3RhZ3MgdGhlblxuICBiZWdpblxuICAgIHN0YXRlLnBwX3RhZ19zdGFjayA8LSB0YWdfbmFtZSA6OiBzdGF0ZS5wcF90YWdfc3RhY2s7XG4gICAgc3RhdGUucHBfcHJpbnRfb3Blbl90YWcgdGFnX25hbWVcbiAgZW5kO1xuICBpZiBzdGF0ZS5wcF9tYXJrX3RhZ3MgdGhlblxuICAgIHBwX2VucXVldWUgc3RhdGUge1xuICAgICAgZWxlbV9zaXplID0gc2l6ZV9vZl9pbnQgMDtcbiAgICAgIHRva2VuID0gUHBfb3Blbl90YWcgdGFnX25hbWU7XG4gICAgICBsZW5ndGggPSAwO1xuICAgIH1cblxuXG4oKiBDbG9zZSBhIHRhZywgcG9wcGluZyBpdCBmcm9tIHRoZSB0YWcgc3RhY2suICopXG5sZXQgcHBfY2xvc2VfdGFnIHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfbWFya190YWdzIHRoZW5cbiAgICBwcF9lbnF1ZXVlIHN0YXRlIHtcbiAgICAgIGVsZW1fc2l6ZSA9IHNpemVfb2ZfaW50IDA7XG4gICAgICB0b2tlbiA9IFBwX2Nsb3NlX3RhZztcbiAgICAgIGxlbmd0aCA9IDA7XG4gICAgfTtcbiAgaWYgc3RhdGUucHBfcHJpbnRfdGFncyB0aGVuXG4gIGJlZ2luXG4gICAgbWF0Y2ggc3RhdGUucHBfdGFnX3N0YWNrIHdpdGhcbiAgICB8IHRhZ19uYW1lIDo6IHRhZ3MgLT5cbiAgICAgIHN0YXRlLnBwX3ByaW50X2Nsb3NlX3RhZyB0YWdfbmFtZTtcbiAgICAgIHN0YXRlLnBwX3RhZ19zdGFjayA8LSB0YWdzXG4gICAgfCBfIC0+ICgpICgqIE5vIG1vcmUgdGFnIHRvIGNsb3NlLiAqKVxuICBlbmRcblxuXG5sZXQgcHBfc2V0X3ByaW50X3RhZ3Mgc3RhdGUgYiA9IHN0YXRlLnBwX3ByaW50X3RhZ3MgPC0gYlxubGV0IHBwX3NldF9tYXJrX3RhZ3Mgc3RhdGUgYiA9IHN0YXRlLnBwX21hcmtfdGFncyA8LSBiXG5sZXQgcHBfZ2V0X3ByaW50X3RhZ3Mgc3RhdGUgKCkgPSBzdGF0ZS5wcF9wcmludF90YWdzXG5sZXQgcHBfZ2V0X21hcmtfdGFncyBzdGF0ZSAoKSA9IHN0YXRlLnBwX21hcmtfdGFnc1xubGV0IHBwX3NldF90YWdzIHN0YXRlIGIgPVxuICBwcF9zZXRfcHJpbnRfdGFncyBzdGF0ZSBiOyBwcF9zZXRfbWFya190YWdzIHN0YXRlIGJcblxuXG4oKiBIYW5kbGluZyB0YWcgaGFuZGxpbmcgZnVuY3Rpb25zOiBnZXQvc2V0IGZ1bmN0aW9ucy4gKilcbmxldCBwcF9nZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgc3RhdGUgKCkgPSB7XG4gIG1hcmtfb3Blbl90YWcgPSBzdGF0ZS5wcF9tYXJrX29wZW5fdGFnO1xuICBtYXJrX2Nsb3NlX3RhZyA9IHN0YXRlLnBwX21hcmtfY2xvc2VfdGFnO1xuICBwcmludF9vcGVuX3RhZyA9IHN0YXRlLnBwX3ByaW50X29wZW5fdGFnO1xuICBwcmludF9jbG9zZV90YWcgPSBzdGF0ZS5wcF9wcmludF9jbG9zZV90YWc7XG59XG5cblxubGV0IHBwX3NldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyBzdGF0ZSB7XG4gICAgIG1hcmtfb3Blbl90YWcgPSBtb3Q7XG4gICAgIG1hcmtfY2xvc2VfdGFnID0gbWN0O1xuICAgICBwcmludF9vcGVuX3RhZyA9IHBvdDtcbiAgICAgcHJpbnRfY2xvc2VfdGFnID0gcGN0O1xuICB9ID1cbiAgc3RhdGUucHBfbWFya19vcGVuX3RhZyA8LSBtb3Q7XG4gIHN0YXRlLnBwX21hcmtfY2xvc2VfdGFnIDwtIG1jdDtcbiAgc3RhdGUucHBfcHJpbnRfb3Blbl90YWcgPC0gcG90O1xuICBzdGF0ZS5wcF9wcmludF9jbG9zZV90YWcgPC0gcGN0XG5cblxuKCogSW5pdGlhbGl6ZSBwcmV0dHktcHJpbnRlci4gKilcbmxldCBwcF9yaW5pdCBzdGF0ZSA9XG4gIHBwX2NsZWFyX3F1ZXVlIHN0YXRlO1xuICBjbGVhcl9zY2FuX3N0YWNrIHN0YXRlO1xuICBzdGF0ZS5wcF9mb3JtYXRfc3RhY2sgPC0gW107XG4gIHN0YXRlLnBwX3Rib3hfc3RhY2sgPC0gW107XG4gIHN0YXRlLnBwX3RhZ19zdGFjayA8LSBbXTtcbiAgc3RhdGUucHBfbWFya19zdGFjayA8LSBbXTtcbiAgc3RhdGUucHBfY3VycmVudF9pbmRlbnQgPC0gMDtcbiAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSAwO1xuICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX21hcmdpbjtcbiAgcHBfb3Blbl9zeXNfYm94IHN0YXRlXG5cbmxldCBjbGVhcl90YWdfc3RhY2sgc3RhdGUgPVxuICBMaXN0Lml0ZXJcbiAgICAoZnVuIF8gLT4gcHBfY2xvc2VfdGFnIHN0YXRlICgpKVxuICAgIHN0YXRlLnBwX3RhZ19zdGFja1xuXG5cbigqIEZsdXNoaW5nIHByZXR0eS1wcmludGVyIHF1ZXVlLiAqKVxubGV0IHBwX2ZsdXNoX3F1ZXVlIHN0YXRlIGIgPVxuICBjbGVhcl90YWdfc3RhY2sgc3RhdGU7XG4gIHdoaWxlIHN0YXRlLnBwX2N1cnJfZGVwdGggPiAxIGRvXG4gICAgcHBfY2xvc2VfYm94IHN0YXRlICgpXG4gIGRvbmU7XG4gIHN0YXRlLnBwX3JpZ2h0X3RvdGFsIDwtIHBwX2luZmluaXR5O1xuICBhZHZhbmNlX2xlZnQgc3RhdGU7XG4gIGlmIGIgdGhlbiBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZTtcbiAgcHBfcmluaXQgc3RhdGVcblxuKCpcblxuICBQcm9jZWR1cmVzIHRvIGZvcm1hdCB2YWx1ZXMgYW5kIHVzZSBib3hlcy5cblxuKilcblxuKCogVG8gZm9ybWF0IGEgc3RyaW5nLiAqKVxubGV0IHBwX3ByaW50X2FzX3NpemUgc3RhdGUgc2l6ZSBzID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlc1xuICB0aGVuIGVucXVldWVfc3RyaW5nX2FzIHN0YXRlIHNpemUgc1xuXG5cbmxldCBwcF9wcmludF9hcyBzdGF0ZSBpc2l6ZSBzID1cbiAgcHBfcHJpbnRfYXNfc2l6ZSBzdGF0ZSAoc2l6ZV9vZl9pbnQgaXNpemUpIHNcblxuXG5sZXQgcHBfcHJpbnRfc3RyaW5nIHN0YXRlIHMgPVxuICBwcF9wcmludF9hcyBzdGF0ZSAoU3RyaW5nLmxlbmd0aCBzKSBzXG5cblxuKCogVG8gZm9ybWF0IGFuIGludGVnZXIuICopXG5sZXQgcHBfcHJpbnRfaW50IHN0YXRlIGkgPSBwcF9wcmludF9zdHJpbmcgc3RhdGUgKHN0cmluZ19vZl9pbnQgaSlcblxuKCogVG8gZm9ybWF0IGEgZmxvYXQuICopXG5sZXQgcHBfcHJpbnRfZmxvYXQgc3RhdGUgZiA9IHBwX3ByaW50X3N0cmluZyBzdGF0ZSAoc3RyaW5nX29mX2Zsb2F0IGYpXG5cbigqIFRvIGZvcm1hdCBhIGJvb2xlYW4uICopXG5sZXQgcHBfcHJpbnRfYm9vbCBzdGF0ZSBiID0gcHBfcHJpbnRfc3RyaW5nIHN0YXRlIChzdHJpbmdfb2ZfYm9vbCBiKVxuXG4oKiBUbyBmb3JtYXQgYSBjaGFyLiAqKVxubGV0IHBwX3ByaW50X2NoYXIgc3RhdGUgYyA9XG4gIHBwX3ByaW50X2FzIHN0YXRlIDEgKFN0cmluZy5tYWtlIDEgYylcblxuXG4oKiBPcGVuaW5nIGJveGVzLiAqKVxubGV0IHBwX29wZW5faGJveCBzdGF0ZSAoKSA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSAwIFBwX2hib3hcbmFuZCBwcF9vcGVuX3Zib3ggc3RhdGUgaW5kZW50ID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIGluZGVudCBQcF92Ym94XG5cbmFuZCBwcF9vcGVuX2h2Ym94IHN0YXRlIGluZGVudCA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgUHBfaHZib3hcbmFuZCBwcF9vcGVuX2hvdmJveCBzdGF0ZSBpbmRlbnQgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IFBwX2hvdmJveFxuYW5kIHBwX29wZW5fYm94IHN0YXRlIGluZGVudCA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgUHBfYm94XG5cblxuKCogUHJpbnRpbmcgcXVldWVkIHRleHQuXG5cbiAgIFtwcF9wcmludF9mbHVzaF0gcHJpbnRzIGFsbCBwZW5kaW5nIGl0ZW1zIGluIHRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBhbmRcbiAgIHRoZW4gZmx1c2hlcyB0aGUgbG93IGxldmVsIG91dHB1dCBkZXZpY2Ugb2YgdGhlIGZvcm1hdHRlciB0byBhY3R1YWxseVxuICAgZGlzcGxheSBwcmludGluZyBtYXRlcmlhbC5cblxuICAgW3BwX3ByaW50X25ld2xpbmVdIGJlaGF2ZXMgYXMgW3BwX3ByaW50X2ZsdXNoXSBhZnRlciBwcmludGluZyBhbiBhZGRpdGlvbmFsXG4gICBuZXcgbGluZS4gKilcbmxldCBwcF9wcmludF9uZXdsaW5lIHN0YXRlICgpID1cbiAgcHBfZmx1c2hfcXVldWUgc3RhdGUgdHJ1ZTsgc3RhdGUucHBfb3V0X2ZsdXNoICgpXG5hbmQgcHBfcHJpbnRfZmx1c2ggc3RhdGUgKCkgPVxuICBwcF9mbHVzaF9xdWV1ZSBzdGF0ZSBmYWxzZTsgc3RhdGUucHBfb3V0X2ZsdXNoICgpXG5cblxuKCogVG8gZ2V0IGEgbmV3bGluZSB3aGVuIG9uZSBkb2VzIG5vdCB3YW50IHRvIGNsb3NlIHRoZSBjdXJyZW50IGJveC4gKilcbmxldCBwcF9mb3JjZV9uZXdsaW5lIHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIChtYWtlX3F1ZXVlX2VsZW0gKHNpemVfb2ZfaW50IDApIFBwX25ld2xpbmUgMClcblxuXG4oKiBUbyBmb3JtYXQgc29tZXRoaW5nLCBvbmx5IGluIGNhc2UgdGhlIGxpbmUgaGFzIGp1c3QgYmVlbiBicm9rZW4uICopXG5sZXQgcHBfcHJpbnRfaWZfbmV3bGluZSBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZSAobWFrZV9xdWV1ZV9lbGVtIChzaXplX29mX2ludCAwKSBQcF9pZl9uZXdsaW5lIDApXG5cblxuKCogUHJpbnRpbmcgYnJlYWsgaGludHM6XG4gICBBIGJyZWFrIGhpbnQgaW5kaWNhdGVzIHdoZXJlIGEgYm94IG1heSBiZSBicm9rZW4uXG4gICBJZiBsaW5lIGlzIGJyb2tlbiB0aGVuIG9mZnNldCBpcyBhZGRlZCB0byB0aGUgaW5kZW50YXRpb24gb2YgdGhlIGN1cnJlbnRcbiAgIGJveCBlbHNlICh0aGUgdmFsdWUgb2YpIHdpZHRoIGJsYW5rcyBhcmUgcHJpbnRlZC4gKilcbmxldCBwcF9wcmludF9icmVhayBzdGF0ZSB3aWR0aCBvZmZzZXQgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBsZXQgZWxlbSA9XG4gICAgICBtYWtlX3F1ZXVlX2VsZW1cbiAgICAgICAgKHNpemVfb2ZfaW50ICgtIHN0YXRlLnBwX3JpZ2h0X3RvdGFsKSlcbiAgICAgICAgKFBwX2JyZWFrICh3aWR0aCwgb2Zmc2V0KSlcbiAgICAgICAgd2lkdGggaW5cbiAgICBzY2FuX3B1c2ggc3RhdGUgdHJ1ZSBlbGVtXG5cblxuKCogUHJpbnQgYSBzcGFjZSA6XG4gICBhIHNwYWNlIGlzIGEgYnJlYWsgaGludCB0aGF0IHByaW50cyBhIHNpbmdsZSBzcGFjZSBpZiB0aGUgYnJlYWsgZG9lcyBub3RcbiAgIHNwbGl0IHRoZSBsaW5lO1xuICAgYSBjdXQgaXMgYSBicmVhayBoaW50IHRoYXQgcHJpbnRzIG5vdGhpbmcgaWYgdGhlIGJyZWFrIGRvZXMgbm90IHNwbGl0IHRoZVxuICAgbGluZS4gKilcbmxldCBwcF9wcmludF9zcGFjZSBzdGF0ZSAoKSA9IHBwX3ByaW50X2JyZWFrIHN0YXRlIDEgMFxuYW5kIHBwX3ByaW50X2N1dCBzdGF0ZSAoKSA9IHBwX3ByaW50X2JyZWFrIHN0YXRlIDAgMFxuXG5cbigqIFRhYnVsYXRpb24gYm94ZXMuICopXG5sZXQgcHBfb3Blbl90Ym94IHN0YXRlICgpID1cbiAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSBzdGF0ZS5wcF9jdXJyX2RlcHRoICsgMTtcbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgbGV0IGVsZW0gPVxuICAgICAgbWFrZV9xdWV1ZV9lbGVtIChzaXplX29mX2ludCAwKSAoUHBfdGJlZ2luIChQcF90Ym94IChyZWYgW10pKSkgMCBpblxuICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZSBlbGVtXG5cblxuKCogQ2xvc2UgYSB0YWJ1bGF0aW9uIGJveC4gKilcbmxldCBwcF9jbG9zZV90Ym94IHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA+IDEgdGhlblxuICBiZWdpblxuICAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgIGxldCBlbGVtID0gbWFrZV9xdWV1ZV9lbGVtIChzaXplX29mX2ludCAwKSBQcF90ZW5kIDAgaW5cbiAgICAgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIGVsZW07XG4gICAgIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gc3RhdGUucHBfY3Vycl9kZXB0aCAtIDFcbiAgZW5kXG5cblxuKCogUHJpbnQgYSB0YWJ1bGF0aW9uIGJyZWFrLiAqKVxubGV0IHBwX3ByaW50X3RicmVhayBzdGF0ZSB3aWR0aCBvZmZzZXQgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBsZXQgZWxlbSA9XG4gICAgICBtYWtlX3F1ZXVlX2VsZW1cbiAgICAgICAgKHNpemVfb2ZfaW50ICgtIHN0YXRlLnBwX3JpZ2h0X3RvdGFsKSlcbiAgICAgICAgKFBwX3RicmVhayAod2lkdGgsIG9mZnNldCkpXG4gICAgICAgIHdpZHRoIGluXG4gICAgc2Nhbl9wdXNoIHN0YXRlIHRydWUgZWxlbVxuXG5cbmxldCBwcF9wcmludF90YWIgc3RhdGUgKCkgPSBwcF9wcmludF90YnJlYWsgc3RhdGUgMCAwXG5cbmxldCBwcF9zZXRfdGFiIHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgbGV0IGVsZW0gPVxuICAgICAgbWFrZV9xdWV1ZV9lbGVtIChzaXplX29mX2ludCAwKSBQcF9zdGFiIDAgaW5cbiAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgZWxlbVxuXG5cbigqXG5cbiAgUHJvY2VkdXJlcyB0byBjb250cm9sIHRoZSBwcmV0dHktcHJpbnRlcnNcblxuKilcblxuKCogU2V0X21heF9ib3hlcy4gKilcbmxldCBwcF9zZXRfbWF4X2JveGVzIHN0YXRlIG4gPSBpZiBuID4gMSB0aGVuIHN0YXRlLnBwX21heF9ib3hlcyA8LSBuXG5cbigqIFRvIGtub3cgdGhlIGN1cnJlbnQgbWF4aW11bSBudW1iZXIgb2YgYm94ZXMgYWxsb3dlZC4gKilcbmxldCBwcF9nZXRfbWF4X2JveGVzIHN0YXRlICgpID0gc3RhdGUucHBfbWF4X2JveGVzXG5cbmxldCBwcF9vdmVyX21heF9ib3hlcyBzdGF0ZSAoKSA9IHN0YXRlLnBwX2N1cnJfZGVwdGggPSBzdGF0ZS5wcF9tYXhfYm94ZXNcblxuKCogRWxsaXBzaXMuICopXG5sZXQgcHBfc2V0X2VsbGlwc2lzX3RleHQgc3RhdGUgcyA9IHN0YXRlLnBwX2VsbGlwc2lzIDwtIHNcbmFuZCBwcF9nZXRfZWxsaXBzaXNfdGV4dCBzdGF0ZSAoKSA9IHN0YXRlLnBwX2VsbGlwc2lzXG5cblxuKCogVG8gc2V0IHRoZSBtYXJnaW4gb2YgcHJldHR5LXByaW50ZXIuICopXG5sZXQgcHBfbGltaXQgbiA9XG4gIGlmIG4gPCBwcF9pbmZpbml0eSB0aGVuIG4gZWxzZSBwcmVkIHBwX2luZmluaXR5XG5cblxuKCogSW50ZXJuYWwgcHJldHR5LXByaW50ZXIgZnVuY3Rpb25zLiAqKVxubGV0IHBwX3NldF9taW5fc3BhY2VfbGVmdCBzdGF0ZSBuID1cbiAgaWYgbiA+PSAxIHRoZW5cbiAgICBsZXQgbiA9IHBwX2xpbWl0IG4gaW5cbiAgICBzdGF0ZS5wcF9taW5fc3BhY2VfbGVmdCA8LSBuO1xuICAgIHN0YXRlLnBwX21heF9pbmRlbnQgPC0gc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfbWluX3NwYWNlX2xlZnQ7XG4gICAgcHBfcmluaXQgc3RhdGVcblxuXG4oKiBJbml0aWFsbHksIHdlIGhhdmUgOlxuICAgcHBfbWF4X2luZGVudCA9IHBwX21hcmdpbiAtIHBwX21pbl9zcGFjZV9sZWZ0LCBhbmRcbiAgIHBwX3NwYWNlX2xlZnQgPSBwcF9tYXJnaW4uICopXG5sZXQgcHBfc2V0X21heF9pbmRlbnQgc3RhdGUgbiA9XG4gIHBwX3NldF9taW5fc3BhY2VfbGVmdCBzdGF0ZSAoc3RhdGUucHBfbWFyZ2luIC0gbilcblxuXG5sZXQgcHBfZ2V0X21heF9pbmRlbnQgc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXhfaW5kZW50XG5cbmxldCBwcF9zZXRfbWFyZ2luIHN0YXRlIG4gPVxuICBpZiBuID49IDEgdGhlblxuICAgIGxldCBuID0gcHBfbGltaXQgbiBpblxuICAgIHN0YXRlLnBwX21hcmdpbiA8LSBuO1xuICAgIGxldCBuZXdfbWF4X2luZGVudCA9XG4gICAgICAoKiBUcnkgdG8gbWFpbnRhaW4gbWF4X2luZGVudCB0byBpdHMgYWN0dWFsIHZhbHVlLiAqKVxuICAgICAgaWYgc3RhdGUucHBfbWF4X2luZGVudCA8PSBzdGF0ZS5wcF9tYXJnaW5cbiAgICAgIHRoZW4gc3RhdGUucHBfbWF4X2luZGVudCBlbHNlXG4gICAgICAoKiBJZiBwb3NzaWJsZSBtYWludGFpbiBwcF9taW5fc3BhY2VfbGVmdCB0byBpdHMgYWN0dWFsIHZhbHVlLFxuICAgICAgICAgaWYgdGhpcyBsZWFkcyB0byBhIHRvbyBzbWFsbCBtYXhfaW5kZW50LCB0YWtlIGhhbGYgb2YgdGhlXG4gICAgICAgICBuZXcgbWFyZ2luLCBpZiBpdCBpcyBncmVhdGVyIHRoYW4gMS4gKilcbiAgICAgICBtYXggKG1heCAoc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfbWluX3NwYWNlX2xlZnQpXG4gICAgICAgICAgICAgICAgKHN0YXRlLnBwX21hcmdpbiAvIDIpKSAxIGluXG4gICAgKCogUmVidWlsZCBpbnZhcmlhbnRzLiAqKVxuICAgIHBwX3NldF9tYXhfaW5kZW50IHN0YXRlIG5ld19tYXhfaW5kZW50XG5cblxubGV0IHBwX2dldF9tYXJnaW4gc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXJnaW5cblxuKCogU2V0dGluZyBhIGZvcm1hdHRlciBiYXNpYyBvdXRwdXQgZnVuY3Rpb25zLiAqKVxubGV0IHBwX3NldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyBzdGF0ZSB7XG4gICAgICBvdXRfc3RyaW5nID0gZjtcbiAgICAgIG91dF9mbHVzaCA9IGc7XG4gICAgICBvdXRfbmV3bGluZSA9IGg7XG4gICAgICBvdXRfc3BhY2VzID0gaTtcbiAgICAgIG91dF9pbmRlbnQgPSBqO1xuICAgIH0gPVxuICBzdGF0ZS5wcF9vdXRfc3RyaW5nIDwtIGY7XG4gIHN0YXRlLnBwX291dF9mbHVzaCA8LSBnO1xuICBzdGF0ZS5wcF9vdXRfbmV3bGluZSA8LSBoO1xuICBzdGF0ZS5wcF9vdXRfc3BhY2VzIDwtIGk7XG4gIHN0YXRlLnBwX291dF9pbmRlbnQgPC0galxuXG5sZXQgcHBfZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIHN0YXRlICgpID0ge1xuICBvdXRfc3RyaW5nID0gc3RhdGUucHBfb3V0X3N0cmluZztcbiAgb3V0X2ZsdXNoID0gc3RhdGUucHBfb3V0X2ZsdXNoO1xuICBvdXRfbmV3bGluZSA9IHN0YXRlLnBwX291dF9uZXdsaW5lO1xuICBvdXRfc3BhY2VzID0gc3RhdGUucHBfb3V0X3NwYWNlcztcbiAgb3V0X2luZGVudCA9IHN0YXRlLnBwX291dF9pbmRlbnQ7XG59XG5cblxuKCogU2V0dGluZyBhIGZvcm1hdHRlciBiYXNpYyBzdHJpbmcgb3V0cHV0IGFuZCBmbHVzaCBmdW5jdGlvbnMuICopXG5sZXQgcHBfc2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlIGYgZyA9XG4gIHN0YXRlLnBwX291dF9zdHJpbmcgPC0gZjsgc3RhdGUucHBfb3V0X2ZsdXNoIDwtIGdcblxubGV0IHBwX2dldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGF0ZSAoKSA9XG4gIChzdGF0ZS5wcF9vdXRfc3RyaW5nLCBzdGF0ZS5wcF9vdXRfZmx1c2gpXG5cblxuKCogVGhlIGRlZmF1bHQgZnVuY3Rpb24gdG8gb3V0cHV0IG5ldyBsaW5lcy4gKilcbmxldCBkaXNwbGF5X25ld2xpbmUgc3RhdGUgKCkgPSBzdGF0ZS5wcF9vdXRfc3RyaW5nIFwiXFxuXCIgMCAgMVxuXG4oKiBUaGUgZGVmYXVsdCBmdW5jdGlvbiB0byBvdXRwdXQgc3BhY2VzLiAqKVxubGV0IGJsYW5rX2xpbmUgPSBTdHJpbmcubWFrZSA4MCAnICdcbmxldCByZWMgZGlzcGxheV9ibGFua3Mgc3RhdGUgbiA9XG4gIGlmIG4gPiAwIHRoZW5cbiAgaWYgbiA8PSA4MCB0aGVuIHN0YXRlLnBwX291dF9zdHJpbmcgYmxhbmtfbGluZSAwIG4gZWxzZVxuICBiZWdpblxuICAgIHN0YXRlLnBwX291dF9zdHJpbmcgYmxhbmtfbGluZSAwIDgwO1xuICAgIGRpc3BsYXlfYmxhbmtzIHN0YXRlIChuIC0gODApXG4gIGVuZFxuXG5cbigqIFRoZSBkZWZhdWx0IGZ1bmN0aW9uIHRvIG91dHB1dCBpbmRlbnRhdGlvbiBvZiBuZXcgbGluZXMuICopXG5sZXQgZGlzcGxheV9pbmRlbnQgPSBkaXNwbGF5X2JsYW5rc1xuXG4oKiBTZXR0aW5nIGEgZm9ybWF0dGVyIGJhc2ljIG91dHB1dCBmdW5jdGlvbnMgYXMgcHJpbnRpbmcgdG8gYSBnaXZlblxuICAgW1BlcnZhc2l2ZS5vdXRfY2hhbm5lbF0gdmFsdWUuICopXG5sZXQgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfY2hhbm5lbCBzdGF0ZSBvYyA9XG4gIHN0YXRlLnBwX291dF9zdHJpbmcgPC0gb3V0cHV0X3N1YnN0cmluZyBvYztcbiAgc3RhdGUucHBfb3V0X2ZsdXNoIDwtIChmdW4gKCkgLT4gZmx1c2ggb2MpO1xuICBzdGF0ZS5wcF9vdXRfbmV3bGluZSA8LSBkaXNwbGF5X25ld2xpbmUgc3RhdGU7XG4gIHN0YXRlLnBwX291dF9zcGFjZXMgPC0gZGlzcGxheV9ibGFua3Mgc3RhdGU7XG4gIHN0YXRlLnBwX291dF9pbmRlbnQgPC0gZGlzcGxheV9pbmRlbnQgc3RhdGVcblxuKCpcblxuICBEZWZpbmluZyBzcGVjaWZpYyBmb3JtYXR0ZXJzXG5cbiopXG5cbmxldCBkZWZhdWx0X3BwX21hcmtfb3Blbl90YWcgcyA9IFwiPFwiIF4gcyBeIFwiPlwiXG5sZXQgZGVmYXVsdF9wcF9tYXJrX2Nsb3NlX3RhZyBzID0gXCI8L1wiIF4gcyBeIFwiPlwiXG5cbmxldCBkZWZhdWx0X3BwX3ByaW50X29wZW5fdGFnID0gaWdub3JlXG5sZXQgZGVmYXVsdF9wcF9wcmludF9jbG9zZV90YWcgPSBpZ25vcmVcblxuKCogQnVpbGRpbmcgYSBmb3JtYXR0ZXIgZ2l2ZW4gaXRzIGJhc2ljIG91dHB1dCBmdW5jdGlvbnMuXG4gICBPdGhlciBmaWVsZHMgZ2V0IHJlYXNvbmFibGUgZGVmYXVsdCB2YWx1ZXMuICopXG5sZXQgcHBfbWFrZV9mb3JtYXR0ZXIgZiBnIGggaSBqID1cbiAgKCogVGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIGZvcm1hdHRlciBjb250YWlucyBhIGR1bW15IGJveC4gKilcbiAgbGV0IHBwX3F1ZXVlID0gbWFrZV9xdWV1ZSAoKSBpblxuICBsZXQgc3lzX3RvayA9XG4gICAgbWFrZV9xdWV1ZV9lbGVtIChzaXplX29mX2ludCAoLTEpKSAoUHBfYmVnaW4gKDAsIFBwX2hvdmJveCkpIDAgaW5cbiAgYWRkX3F1ZXVlIHN5c190b2sgcHBfcXVldWU7XG4gIGxldCBzeXNfc2Nhbl9zdGFjayA9XG4gICAgU2Nhbl9lbGVtICgxLCBzeXNfdG9rKSA6OiBzY2FuX3N0YWNrX2JvdHRvbSBpblxuICBsZXQgcHBfbWFyZ2luID0gNzhcbiAgYW5kIHBwX21pbl9zcGFjZV9sZWZ0ID0gMTAgaW5cbiAge1xuICAgIHBwX3NjYW5fc3RhY2sgPSBzeXNfc2Nhbl9zdGFjaztcbiAgICBwcF9mb3JtYXRfc3RhY2sgPSBbXTtcbiAgICBwcF90Ym94X3N0YWNrID0gW107XG4gICAgcHBfdGFnX3N0YWNrID0gW107XG4gICAgcHBfbWFya19zdGFjayA9IFtdO1xuICAgIHBwX21hcmdpbiA9IHBwX21hcmdpbjtcbiAgICBwcF9taW5fc3BhY2VfbGVmdCA9IHBwX21pbl9zcGFjZV9sZWZ0O1xuICAgIHBwX21heF9pbmRlbnQgPSBwcF9tYXJnaW4gLSBwcF9taW5fc3BhY2VfbGVmdDtcbiAgICBwcF9zcGFjZV9sZWZ0ID0gcHBfbWFyZ2luO1xuICAgIHBwX2N1cnJlbnRfaW5kZW50ID0gMDtcbiAgICBwcF9pc19uZXdfbGluZSA9IHRydWU7XG4gICAgcHBfbGVmdF90b3RhbCA9IDE7XG4gICAgcHBfcmlnaHRfdG90YWwgPSAxO1xuICAgIHBwX2N1cnJfZGVwdGggPSAxO1xuICAgIHBwX21heF9ib3hlcyA9IG1heF9pbnQ7XG4gICAgcHBfZWxsaXBzaXMgPSBcIi5cIjtcbiAgICBwcF9vdXRfc3RyaW5nID0gZjtcbiAgICBwcF9vdXRfZmx1c2ggPSBnO1xuICAgIHBwX291dF9uZXdsaW5lID0gaDtcbiAgICBwcF9vdXRfc3BhY2VzID0gaTtcbiAgICBwcF9vdXRfaW5kZW50ID0gajtcbiAgICBwcF9wcmludF90YWdzID0gZmFsc2U7XG4gICAgcHBfbWFya190YWdzID0gZmFsc2U7XG4gICAgcHBfbWFya19vcGVuX3RhZyA9IGRlZmF1bHRfcHBfbWFya19vcGVuX3RhZztcbiAgICBwcF9tYXJrX2Nsb3NlX3RhZyA9IGRlZmF1bHRfcHBfbWFya19jbG9zZV90YWc7XG4gICAgcHBfcHJpbnRfb3Blbl90YWcgPSBkZWZhdWx0X3BwX3ByaW50X29wZW5fdGFnO1xuICAgIHBwX3ByaW50X2Nsb3NlX3RhZyA9IGRlZmF1bHRfcHBfcHJpbnRfY2xvc2VfdGFnO1xuICAgIHBwX3F1ZXVlID0gcHBfcXVldWU7XG4gIH1cblxuXG4oKiBCdWlsZCBhIGZvcm1hdHRlciBvdXQgb2YgaXRzIG91dCBmdW5jdGlvbnMuICopXG5sZXQgZm9ybWF0dGVyX29mX291dF9mdW5jdGlvbnMgb3V0X2Z1bnMgPVxuICBwcF9tYWtlX2Zvcm1hdHRlclxuICAgIG91dF9mdW5zLm91dF9zdHJpbmdcbiAgICBvdXRfZnVucy5vdXRfZmx1c2hcbiAgICBvdXRfZnVucy5vdXRfbmV3bGluZVxuICAgIG91dF9mdW5zLm91dF9zcGFjZXNcbiAgICBvdXRfZnVucy5vdXRfaW5kZW50XG5cblxuKCogTWFrZSBhIGZvcm1hdHRlciB3aXRoIGRlZmF1bHQgZnVuY3Rpb25zIHRvIG91dHB1dCBzcGFjZXMsXG4gIGluZGVudGF0aW9uLCBhbmQgbmV3IGxpbmVzLiAqKVxubGV0IG1ha2VfZm9ybWF0dGVyIG91dHB1dCBmbHVzaCA9XG4gIGxldCBwcGYgPSBwcF9tYWtlX2Zvcm1hdHRlciBvdXRwdXQgZmx1c2ggaWdub3JlIGlnbm9yZSBpZ25vcmUgaW5cbiAgcHBmLnBwX291dF9uZXdsaW5lIDwtIGRpc3BsYXlfbmV3bGluZSBwcGY7XG4gIHBwZi5wcF9vdXRfc3BhY2VzIDwtIGRpc3BsYXlfYmxhbmtzIHBwZjtcbiAgcHBmLnBwX291dF9pbmRlbnQgPC0gZGlzcGxheV9pbmRlbnQgcHBmO1xuICBwcGZcblxuXG4oKiBNYWtlIGEgZm9ybWF0dGVyIHdyaXRpbmcgdG8gYSBnaXZlbiBbUGVydmFzaXZlLm91dF9jaGFubmVsXSB2YWx1ZS4gKilcbmxldCBmb3JtYXR0ZXJfb2Zfb3V0X2NoYW5uZWwgb2MgPVxuICBtYWtlX2Zvcm1hdHRlciAob3V0cHV0X3N1YnN0cmluZyBvYykgKGZ1biAoKSAtPiBmbHVzaCBvYylcblxuXG4oKiBNYWtlIGEgZm9ybWF0dGVyIHdyaXRpbmcgdG8gYSBnaXZlbiBbQnVmZmVyLnRdIHZhbHVlLiAqKVxubGV0IGZvcm1hdHRlcl9vZl9idWZmZXIgYiA9XG4gIG1ha2VfZm9ybWF0dGVyIChCdWZmZXIuYWRkX3N1YnN0cmluZyBiKSBpZ25vcmVcblxuXG4oKiBBbGxvY2F0aW5nIGJ1ZmZlciBmb3IgcHJldHR5LXByaW50aW5nIHB1cnBvc2VzLlxuICAgRGVmYXVsdCBidWZmZXIgc2l6ZSBpcyBwcF9idWZmZXJfc2l6ZSBvciA1MTIuXG4qKVxubGV0IHBwX2J1ZmZlcl9zaXplID0gNTEyXG5sZXQgcHBfbWFrZV9idWZmZXIgKCkgPSBCdWZmZXIuY3JlYXRlIHBwX2J1ZmZlcl9zaXplXG5cbigqIFRoZSBzdGFuZGFyZCAoc2hhcmVkKSBidWZmZXIuICopXG5sZXQgc3RkYnVmID0gcHBfbWFrZV9idWZmZXIgKClcblxuKCogUHJlZGVmaW5lZCBmb3JtYXR0ZXJzIHN0YW5kYXJkIGZvcm1hdHRlciB0byBwcmludFxuICAgdG8gW1BlcnZhc2l2ZXMuc3Rkb3V0XSwgW1BlcnZhc2l2ZXMuc3RkZXJyXSwgYW5kIHshc3RkYnVmfS4gKilcbmxldCBzdGRfZm9ybWF0dGVyID0gZm9ybWF0dGVyX29mX291dF9jaGFubmVsIFBlcnZhc2l2ZXMuc3Rkb3V0XG5hbmQgZXJyX2Zvcm1hdHRlciA9IGZvcm1hdHRlcl9vZl9vdXRfY2hhbm5lbCBQZXJ2YXNpdmVzLnN0ZGVyclxuYW5kIHN0cl9mb3JtYXR0ZXIgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIHN0ZGJ1ZlxuXG5cbigqIFtmbHVzaF9idWZmZXJfZm9ybWF0dGVyIGJ1ZiBwcGZdIGZsdXNoZXMgZm9ybWF0dGVyIFtwcGZdLFxuICAgdGhlbiByZXR1cm5zIHRoZSBjb250ZW50cyBvZiBidWZmZXIgW2J1Zl0gdGhhdCBpcyByZXNldC5cbiAgIEZvcm1hdHRlciBbcHBmXSBpcyBzdXBwb3NlZCB0byBwcmludCB0byBidWZmZXIgW2J1Zl0sIG90aGVyd2lzZSB0aGlzXG4gICBmdW5jdGlvbiBpcyBub3QgcmVhbGx5IHVzZWZ1bC4gKilcbmxldCBmbHVzaF9idWZmZXJfZm9ybWF0dGVyIGJ1ZiBwcGYgPVxuICBwcF9mbHVzaF9xdWV1ZSBwcGYgZmFsc2U7XG4gIGxldCBzID0gQnVmZmVyLmNvbnRlbnRzIGJ1ZiBpblxuICBCdWZmZXIucmVzZXQgYnVmO1xuICBzXG5cblxuKCogRmx1c2ggW3N0cl9mb3JtYXR0ZXJdIGFuZCBnZXQgdGhlIGNvbnRlbnRzIG9mIFtzdGRidWZdLiAqKVxubGV0IGZsdXNoX3N0cl9mb3JtYXR0ZXIgKCkgPSBmbHVzaF9idWZmZXJfZm9ybWF0dGVyIHN0ZGJ1ZiBzdHJfZm9ybWF0dGVyXG5cbigqXG4gIFN5bWJvbGljIHByZXR0eS1wcmludGluZ1xuKilcblxuKCpcbiAgU3ltYm9saWMgcHJldHR5LXByaW50aW5nIGlzIHByZXR0eS1wcmludGluZyB3aXRoIG5vIGxvdyBsZXZlbCBvdXRwdXQuXG5cbiAgV2hlbiB1c2luZyBhIHN5bWJvbGljIGZvcm1hdHRlciwgYWxsIHJlZ3VsYXIgcHJldHR5LXByaW50aW5nIGFjdGl2aXRpZXNcbiAgb2NjdXIgYnV0IG91dHB1dCBtYXRlcmlhbCBpcyBzeW1ib2xpYyBhbmQgc3RvcmVkIGluIGEgYnVmZmVyIG9mIG91dHB1dFxuICBpdGVtcy4gQXQgdGhlIGVuZCBvZiBwcmV0dHktcHJpbnRpbmcsIGZsdXNoaW5nIHRoZSBvdXRwdXQgYnVmZmVyIGFsbG93c1xuICBwb3N0LXByb2Nlc3Npbmcgb2Ygc3ltYm9saWMgb3V0cHV0IGJlZm9yZSBsb3cgbGV2ZWwgb3V0cHV0IG9wZXJhdGlvbnMuXG4qKVxuXG50eXBlIHN5bWJvbGljX291dHB1dF9pdGVtID1cbiAgfCBPdXRwdXRfZmx1c2hcbiAgfCBPdXRwdXRfbmV3bGluZVxuICB8IE91dHB1dF9zdHJpbmcgb2Ygc3RyaW5nXG4gIHwgT3V0cHV0X3NwYWNlcyBvZiBpbnRcbiAgfCBPdXRwdXRfaW5kZW50IG9mIGludFxuXG50eXBlIHN5bWJvbGljX291dHB1dF9idWZmZXIgPSB7XG4gIG11dGFibGUgc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzIDogc3ltYm9saWNfb3V0cHV0X2l0ZW0gbGlzdDtcbn1cblxubGV0IG1ha2Vfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciAoKSA9XG4gIHsgc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzID0gW10gfVxuXG5sZXQgY2xlYXJfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgPVxuICBzb2Iuc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzIDwtIFtdXG5cbmxldCBnZXRfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgPVxuICBMaXN0LnJldiBzb2Iuc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzXG5cbmxldCBmbHVzaF9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIHNvYiA9XG4gIGxldCBpdGVtcyA9IGdldF9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIHNvYiBpblxuICBjbGVhcl9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIHNvYjtcbiAgaXRlbXNcblxubGV0IGFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSBzb2IgaXRlbSA9XG4gIHNvYi5zeW1ib2xpY19vdXRwdXRfY29udGVudHMgPC0gaXRlbSA6OiBzb2Iuc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzXG5cbmxldCBmb3JtYXR0ZXJfb2Zfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgPVxuICBsZXQgc3ltYm9saWNfZmx1c2ggc29iICgpID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIE91dHB1dF9mbHVzaFxuICBhbmQgc3ltYm9saWNfbmV3bGluZSBzb2IgKCkgPVxuICAgIGFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSBzb2IgT3V0cHV0X25ld2xpbmVcbiAgYW5kIHN5bWJvbGljX3N0cmluZyBzb2IgcyBpIG4gPVxuICAgIGFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSBzb2IgKE91dHB1dF9zdHJpbmcgKFN0cmluZy5zdWIgcyBpIG4pKVxuICBhbmQgc3ltYm9saWNfc3BhY2VzIHNvYiBuID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIChPdXRwdXRfc3BhY2VzIG4pXG4gIGFuZCBzeW1ib2xpY19pbmRlbnQgc29iIG4gPVxuICAgIGFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSBzb2IgKE91dHB1dF9pbmRlbnQgbikgaW5cblxuICBsZXQgZiA9IHN5bWJvbGljX3N0cmluZyBzb2JcbiAgYW5kIGcgPSBzeW1ib2xpY19mbHVzaCBzb2JcbiAgYW5kIGggPSBzeW1ib2xpY19uZXdsaW5lIHNvYlxuICBhbmQgaSA9IHN5bWJvbGljX3NwYWNlcyBzb2JcbiAgYW5kIGogPSBzeW1ib2xpY19pbmRlbnQgc29iIGluXG4gIHBwX21ha2VfZm9ybWF0dGVyIGYgZyBoIGkgalxuXG4oKlxuXG4gIEJhc2ljIGZ1bmN0aW9ucyBvbiB0aGUgJ3N0YW5kYXJkJyBmb3JtYXR0ZXJcbiAgKHRoZSBmb3JtYXR0ZXIgdGhhdCBwcmludHMgdG8gW1BlcnZhc2l2ZXMuc3Rkb3V0XSkuXG5cbiopXG5cbmxldCBvcGVuX2hib3ggPSBwcF9vcGVuX2hib3ggc3RkX2Zvcm1hdHRlclxuYW5kIG9wZW5fdmJveCA9IHBwX29wZW5fdmJveCBzdGRfZm9ybWF0dGVyXG5hbmQgb3Blbl9odmJveCA9IHBwX29wZW5faHZib3ggc3RkX2Zvcm1hdHRlclxuYW5kIG9wZW5faG92Ym94ID0gcHBfb3Blbl9ob3Zib3ggc3RkX2Zvcm1hdHRlclxuYW5kIG9wZW5fYm94ID0gcHBfb3Blbl9ib3ggc3RkX2Zvcm1hdHRlclxuYW5kIGNsb3NlX2JveCA9IHBwX2Nsb3NlX2JveCBzdGRfZm9ybWF0dGVyXG5hbmQgb3Blbl90YWcgPSBwcF9vcGVuX3RhZyBzdGRfZm9ybWF0dGVyXG5hbmQgY2xvc2VfdGFnID0gcHBfY2xvc2VfdGFnIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9hcyA9IHBwX3ByaW50X2FzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9zdHJpbmcgPSBwcF9wcmludF9zdHJpbmcgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2ludCA9IHBwX3ByaW50X2ludCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfZmxvYXQgPSBwcF9wcmludF9mbG9hdCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfY2hhciA9IHBwX3ByaW50X2NoYXIgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2Jvb2wgPSBwcF9wcmludF9ib29sIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9icmVhayA9IHBwX3ByaW50X2JyZWFrIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9jdXQgPSBwcF9wcmludF9jdXQgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X3NwYWNlID0gcHBfcHJpbnRfc3BhY2Ugc3RkX2Zvcm1hdHRlclxuYW5kIGZvcmNlX25ld2xpbmUgPSBwcF9mb3JjZV9uZXdsaW5lIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9mbHVzaCA9IHBwX3ByaW50X2ZsdXNoIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9uZXdsaW5lID0gcHBfcHJpbnRfbmV3bGluZSBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfaWZfbmV3bGluZSA9IHBwX3ByaW50X2lmX25ld2xpbmUgc3RkX2Zvcm1hdHRlclxuXG5hbmQgb3Blbl90Ym94ID0gcHBfb3Blbl90Ym94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBjbG9zZV90Ym94ID0gcHBfY2xvc2VfdGJveCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfdGJyZWFrID0gcHBfcHJpbnRfdGJyZWFrIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF90YWIgPSBwcF9zZXRfdGFiIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF90YWIgPSBwcF9wcmludF90YWIgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X21hcmdpbiA9IHBwX3NldF9tYXJnaW4gc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9tYXJnaW4gPSBwcF9nZXRfbWFyZ2luIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9tYXhfaW5kZW50ID0gcHBfc2V0X21heF9pbmRlbnQgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9tYXhfaW5kZW50ID0gcHBfZ2V0X21heF9pbmRlbnQgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X21heF9ib3hlcyA9IHBwX3NldF9tYXhfYm94ZXMgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9tYXhfYm94ZXMgPSBwcF9nZXRfbWF4X2JveGVzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBvdmVyX21heF9ib3hlcyA9IHBwX292ZXJfbWF4X2JveGVzIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9lbGxpcHNpc190ZXh0ID0gcHBfc2V0X2VsbGlwc2lzX3RleHQgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9lbGxpcHNpc190ZXh0ID0gcHBfZ2V0X2VsbGlwc2lzX3RleHQgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X2Zvcm1hdHRlcl9vdXRfY2hhbm5lbCA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfb3V0X2NoYW5uZWwgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgPVxuICBwcF9nZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgPVxuICBwcF9nZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgPVxuICBwcF9nZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuYW5kIHNldF9wcmludF90YWdzID1cbiAgcHBfc2V0X3ByaW50X3RhZ3Mgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9wcmludF90YWdzID1cbiAgcHBfZ2V0X3ByaW50X3RhZ3Mgc3RkX2Zvcm1hdHRlclxuYW5kIHNldF9tYXJrX3RhZ3MgPVxuICBwcF9zZXRfbWFya190YWdzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfbWFya190YWdzID1cbiAgcHBfZ2V0X21hcmtfdGFncyBzdGRfZm9ybWF0dGVyXG5hbmQgc2V0X3RhZ3MgPVxuICBwcF9zZXRfdGFncyBzdGRfZm9ybWF0dGVyXG5cblxuKCogQ29udmVuaWVuY2UgZnVuY3Rpb25zICopXG5cbigqIFRvIGZvcm1hdCBhIGxpc3QgKilcbmxldCByZWMgcHBfcHJpbnRfbGlzdCA/KHBwX3NlcCA9IHBwX3ByaW50X2N1dCkgcHBfdiBwcGYgPSBmdW5jdGlvblxuICB8IFtdIC0+ICgpXG4gIHwgW3ZdIC0+IHBwX3YgcHBmIHZcbiAgfCB2IDo6IHZzIC0+XG4gICAgcHBfdiBwcGYgdjtcbiAgICBwcF9zZXAgcHBmICgpO1xuICAgIHBwX3ByaW50X2xpc3QgfnBwX3NlcCBwcF92IHBwZiB2c1xuXG4oKiBUbyBmb3JtYXQgZnJlZS1mbG93aW5nIHRleHQgKilcbmxldCBwcF9wcmludF90ZXh0IHBwZiBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgbGVmdCA9IHJlZiAwIGluXG4gIGxldCByaWdodCA9IHJlZiAwIGluXG4gIGxldCBmbHVzaCAoKSA9XG4gICAgcHBfcHJpbnRfc3RyaW5nIHBwZiAoU3RyaW5nLnN1YiBzICFsZWZ0ICghcmlnaHQgLSAhbGVmdCkpO1xuICAgIGluY3IgcmlnaHQ7IGxlZnQgOj0gIXJpZ2h0O1xuICBpblxuICB3aGlsZSAoIXJpZ2h0IDw+IGxlbikgZG9cbiAgICBtYXRjaCBzLlshcmlnaHRdIHdpdGhcbiAgICAgIHwgJ1xcbicgLT5cbiAgICAgICAgZmx1c2ggKCk7XG4gICAgICAgIHBwX2ZvcmNlX25ld2xpbmUgcHBmICgpXG4gICAgICB8ICcgJyAtPlxuICAgICAgICBmbHVzaCAoKTsgcHBfcHJpbnRfc3BhY2UgcHBmICgpXG4gICAgICAoKiB0aGVyZSBpcyBubyBzcGVjaWZpYyBzdXBwb3J0IGZvciAnXFx0J1xuICAgICAgICAgYXMgaXQgaXMgdW5jbGVhciB3aGF0IGEgcmlnaHQgc2VtYW50aWNzIHdvdWxkIGJlICopXG4gICAgICB8IF8gLT4gaW5jciByaWdodFxuICBkb25lO1xuICBpZiAhbGVmdCA8PiBsZW4gdGhlbiBmbHVzaCAoKVxuXG4gKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5sZXQgY29tcHV0ZV90YWcgb3V0cHV0IHRhZ19hY2MgPVxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAxNiBpblxuICBsZXQgcHBmID0gZm9ybWF0dGVyX29mX2J1ZmZlciBidWYgaW5cbiAgb3V0cHV0IHBwZiB0YWdfYWNjO1xuICBwcF9wcmludF9mbHVzaCBwcGYgKCk7XG4gIGxldCBsZW4gPSBCdWZmZXIubGVuZ3RoIGJ1ZiBpblxuICBpZiBsZW4gPCAyIHRoZW4gQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuICBlbHNlIEJ1ZmZlci5zdWIgYnVmIDEgKGxlbiAtIDIpXG5cbiAoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICBEZWZpbmluZyBjb250aW51YXRpb25zIHRvIGJlIHBhc3NlZCBhcyBhcmd1bWVudHMgb2ZcbiAgQ2FtbGludGVybmFsRm9ybWF0Lm1ha2VfcHJpbnRmLlxuXG4gICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljc1xub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRcblxuKCogSW50ZXJwcmV0IGEgZm9ybWF0dGluZyBlbnRpdHkgb24gYSBmb3JtYXR0ZXIuICopXG5sZXQgb3V0cHV0X2Zvcm1hdHRpbmdfbGl0IHBwZiBmbXRpbmdfbGl0ID0gbWF0Y2ggZm10aW5nX2xpdCB3aXRoXG4gIHwgQ2xvc2VfYm94ICAgICAgICAgICAgICAgICAtPiBwcF9jbG9zZV9ib3ggcHBmICgpXG4gIHwgQ2xvc2VfdGFnICAgICAgICAgICAgICAgICAtPiBwcF9jbG9zZV90YWcgcHBmICgpXG4gIHwgQnJlYWsgKF8sIHdpZHRoLCBvZmZzZXQpICAtPiBwcF9wcmludF9icmVhayBwcGYgd2lkdGggb2Zmc2V0XG4gIHwgRkZsdXNoICAgICAgICAgICAgICAgICAgICAtPiBwcF9wcmludF9mbHVzaCBwcGYgKClcbiAgfCBGb3JjZV9uZXdsaW5lICAgICAgICAgICAgIC0+IHBwX2ZvcmNlX25ld2xpbmUgcHBmICgpXG4gIHwgRmx1c2hfbmV3bGluZSAgICAgICAgICAgICAtPiBwcF9wcmludF9uZXdsaW5lIHBwZiAoKVxuICB8IE1hZ2ljX3NpemUgKF8sIF8pICAgICAgICAgLT4gKClcbiAgfCBFc2NhcGVkX2F0ICAgICAgICAgICAgICAgIC0+IHBwX3ByaW50X2NoYXIgcHBmICdAJ1xuICB8IEVzY2FwZWRfcGVyY2VudCAgICAgICAgICAgLT4gcHBfcHJpbnRfY2hhciBwcGYgJyUnXG4gIHwgU2Nhbl9pbmRpYyBjICAgICAgICAgICAgICAtPiBwcF9wcmludF9jaGFyIHBwZiAnQCc7IHBwX3ByaW50X2NoYXIgcHBmIGNcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhbiBvdXRwdXRfc3RyZWFtLiAqKVxuKCogRGlmZmVyIGZyb20gUHJpbnRmLm91dHB1dF9hY2MgYnkgdGhlIGludGVycHJldGF0aW9uIG9mIGZvcm1hdHRpbmcuICopXG4oKiBVc2VkIGFzIGEgY29udGludWF0aW9uIG9mIENhbWxpbnRlcm5hbEZvcm1hdC5tYWtlX3ByaW50Zi4gKilcbmxldCByZWMgb3V0cHV0X2FjYyBwcGYgYWNjID0gbWF0Y2ggYWNjIHdpdGhcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIHMpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoc2l6ZV9vZl9pbnQgc2l6ZSkgcztcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgYykgLT5cbiAgICBvdXRwdXRfYWNjIHBwZiBwO1xuICAgIHBwX3ByaW50X2FzX3NpemUgcHBmIChzaXplX29mX2ludCBzaXplKSAoU3RyaW5nLm1ha2UgMSBjKTtcbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgKHAsIGYpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBvdXRwdXRfZm9ybWF0dGluZ19saXQgcHBmIGY7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl90YWcgYWNjJykgLT5cbiAgICBvdXRwdXRfYWNjIHBwZiBwO1xuICAgIHBwX29wZW5fdGFnIHBwZiAoY29tcHV0ZV90YWcgb3V0cHV0X2FjYyBhY2MnKVxuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fYm94IGFjYycpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBsZXQgKGluZGVudCwgYnR5KSA9IG9wZW5fYm94X29mX3N0cmluZyAoY29tcHV0ZV90YWcgb3V0cHV0X2FjYyBhY2MnKSBpblxuICAgIHBwX29wZW5fYm94X2dlbiBwcGYgaW5kZW50IGJ0eVxuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gb3V0cHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfc3RyaW5nIHBwZiBzO1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IG91dHB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X2NoYXIgcHBmIGM7XG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IG91dHB1dF9hY2MgcHBmIHA7IGYgcHBmO1xuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBvdXRwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9mbHVzaCBwcGYgKCk7XG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IG91dHB1dF9hY2MgcHBmIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhIGJ1ZmZlci4gKilcbigqIERpZmZlciBmcm9tIFByaW50Zi5idWZwdXRfYWNjIGJ5IHRoZSBpbnRlcnByZXRhdGlvbiBvZiBmb3JtYXR0aW5nLiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBDYW1saW50ZXJuYWxGb3JtYXQubWFrZV9wcmludGYuICopXG5sZXQgcmVjIHN0cnB1dF9hY2MgcHBmIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBzKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKHNpemVfb2ZfaW50IHNpemUpIHM7XG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoc2l6ZV9vZl9pbnQgc2l6ZSkgKFN0cmluZy5tYWtlIDEgYyk7XG4gIHwgQWNjX2RlbGF5IChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgZikgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIHBwX3ByaW50X2FzX3NpemUgcHBmIChzaXplX29mX2ludCBzaXplKSAoZiAoKSk7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgb3V0cHV0X2Zvcm1hdHRpbmdfbGl0IHBwZiBmO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBwcF9vcGVuX3RhZyBwcGYgKGNvbXB1dGVfdGFnIHN0cnB1dF9hY2MgYWNjJylcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX2JveCBhY2MnKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgbGV0IChpbmRlbnQsIGJ0eSkgPSBvcGVuX2JveF9vZl9zdHJpbmcgKGNvbXB1dGVfdGFnIHN0cnB1dF9hY2MgYWNjJykgaW5cbiAgICBwcF9vcGVuX2JveF9nZW4gcHBmIGluZGVudCBidHlcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKHAsIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChwLCBzKSAgIC0+IHN0cnB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X3N0cmluZyBwcGYgcztcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChwLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKHAsIGMpICAgICAtPiBzdHJwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9jaGFyIHBwZiBjO1xuICB8IEFjY19kZWxheSAocCwgZikgICAgICAgICAtPiBzdHJwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9zdHJpbmcgcHBmIChmICgpKTtcbiAgfCBBY2NfZmx1c2ggcCAgICAgICAgICAgICAgLT4gc3RycHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfZmx1c2ggcHBmICgpO1xuICB8IEFjY19pbnZhbGlkX2FyZyAocCwgbXNnKSAtPiBzdHJwdXRfYWNjIHBwZiBwOyBpbnZhbGlkX2FyZyBtc2c7XG4gIHwgRW5kX29mX2FjYyAgICAgICAgICAgICAgIC0+ICgpXG5cbigqXG5cbiAgRGVmaW5pbmcgW2ZwcmludGZdIGFuZCB2YXJpb3VzIGZsYXZvcnMgb2YgW2ZwcmludGZdLlxuXG4qKVxuXG5sZXQga2ZwcmludGYgayBwcGYgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX3ByaW50ZlxuICAgIChmdW4gcHBmIGFjYyAtPiBvdXRwdXRfYWNjIHBwZiBhY2M7IGsgcHBmKVxuICAgIHBwZiBFbmRfb2ZfYWNjIGZtdFxuXG5hbmQgaWtmcHJpbnRmIGsgcHBmIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9pcHJpbnRmIGsgcHBmIGZtdFxuXG5sZXQgZnByaW50ZiBwcGYgPSBrZnByaW50ZiBpZ25vcmUgcHBmXG5sZXQgaWZwcmludGYgcHBmID0gaWtmcHJpbnRmIGlnbm9yZSBwcGZcbmxldCBwcmludGYgZm10ID0gZnByaW50ZiBzdGRfZm9ybWF0dGVyIGZtdFxubGV0IGVwcmludGYgZm10ID0gZnByaW50ZiBlcnJfZm9ybWF0dGVyIGZtdFxuXG5sZXQga3NwcmludGYgayAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIGxldCBiID0gcHBfbWFrZV9idWZmZXIgKCkgaW5cbiAgbGV0IHBwZiA9IGZvcm1hdHRlcl9vZl9idWZmZXIgYiBpblxuICBsZXQgayAoKSBhY2MgPVxuICAgIHN0cnB1dF9hY2MgcHBmIGFjYztcbiAgICBrIChmbHVzaF9idWZmZXJfZm9ybWF0dGVyIGIgcHBmKSBpblxuICBtYWtlX3ByaW50ZiBrICgpIEVuZF9vZl9hY2MgZm10XG5cblxubGV0IHNwcmludGYgZm10ID0ga3NwcmludGYgKGZ1biBzIC0+IHMpIGZtdFxuXG5sZXQga2FzcHJpbnRmIGsgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBsZXQgYiA9IHBwX21ha2VfYnVmZmVyICgpIGluXG4gIGxldCBwcGYgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGIgaW5cbiAgbGV0IGsgcHBmIGFjYyA9XG4gICAgb3V0cHV0X2FjYyBwcGYgYWNjO1xuICAgIGsgKGZsdXNoX2J1ZmZlcl9mb3JtYXR0ZXIgYiBwcGYpIGluXG4gIG1ha2VfcHJpbnRmIGsgcHBmIEVuZF9vZl9hY2MgZm10XG5cblxubGV0IGFzcHJpbnRmIGZtdCA9IGthc3ByaW50ZiAoZnVuIHMgLT4gcykgZm10XG5cbigqIE91dHB1dCBldmVyeXRoaW5nIGxlZnQgaW4gdGhlIHByZXR0eSBwcmludGVyIHF1ZXVlIGF0IGVuZCBvZiBleGVjdXRpb24uICopXG5sZXQgKCkgPSBhdF9leGl0IHByaW50X2ZsdXNoXG5cblxuKCpcblxuICBEZXByZWNhdGVkIHN0dWZmLlxuXG4qKVxuXG4oKiBEZXByZWNhdGVkIDogc3Vic3VtZWQgYnkgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zICopXG5sZXQgcHBfc2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGF0ZVxuICAgIH5vdXQ6ZiB+Zmx1c2g6ZyB+bmV3bGluZTpoIH5zcGFjZXM6aSA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGF0ZSBmIGc7XG4gIHN0YXRlLnBwX291dF9uZXdsaW5lIDwtIGg7XG4gIHN0YXRlLnBwX291dF9zcGFjZXMgPC0gaVxuXG4oKiBEZXByZWNhdGVkIDogc3Vic3VtZWQgYnkgcHBfZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zICopXG5sZXQgcHBfZ2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGF0ZSAoKSA9XG4gIChzdGF0ZS5wcF9vdXRfc3RyaW5nLCBzdGF0ZS5wcF9vdXRfZmx1c2gsXG4gICBzdGF0ZS5wcF9vdXRfbmV3bGluZSwgc3RhdGUucHBfb3V0X3NwYWNlcylcblxuXG4oKiBEZXByZWNhdGVkIDogc3Vic3VtZWQgYnkgc2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zICopXG5sZXQgc2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyA9XG4gIHBwX3NldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuXG5cbigqIERlcHJlY2F0ZWQgOiBzdWJzdW1lZCBieSBnZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgKilcbmxldCBnZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zID1cbiAgcHBfZ2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5cblxuKCogRGVwcmVjYXRlZCA6IGVycm9yIHByb25lIGZ1bmN0aW9uLCBkbyBub3QgdXNlIGl0LlxuICAgVGhpcyBmdW5jdGlvbiBpcyBuZWl0aGVyIGNvbXBvc2l0aW9uYWwgbm9yIGluY3JlbWVudGFsLCBzaW5jZSBpdCBmbHVzaGVzXG4gICB0aGUgcHJldHR5LXByaW50ZXIgcXVldWUgYXQgZWFjaCBjYWxsLlxuICAgVG8gZ2V0IHRoZSBzYW1lIGZ1bmN0aW9uYWxpdHksIGRlZmluZSBhIGZvcm1hdHRlciBvZiB5b3VyIG93biB3cml0aW5nIHRvXG4gICB0aGUgYnVmZmVyIGFyZ3VtZW50LCBhcyBpblxuICAgbGV0IHBwZiA9IGZvcm1hdHRlcl9vZl9idWZmZXIgYlxuICAgdGhlbiB1c2UgeyFmcHJpbnRmIHBwZn0gYXMgdXN1YWwuICopXG5sZXQgYnByaW50ZiBiIChGb3JtYXQgKGZtdCwgXykgOiAoJ2EsIGZvcm1hdHRlciwgdW5pdCkgZm9ybWF0KSA9XG4gIGxldCBrIHBwZiBhY2MgPSBvdXRwdXRfYWNjIHBwZiBhY2M7IHBwX2ZsdXNoX3F1ZXVlIHBwZiBmYWxzZSBpblxuICBtYWtlX3ByaW50ZiBrIChmb3JtYXR0ZXJfb2ZfYnVmZmVyIGIpIEVuZF9vZl9hY2MgZm10XG5cblxuKCogRGVwcmVjYXRlZCA6IGFsaWFzIGZvciBrc3ByaW50Zi4gKilcbmxldCBrcHJpbnRmID0ga3NwcmludGZcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFBpZXJyZSBXZWlzLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMDIgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3Ncbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0XG5cbigqIGFsaWFzIHRvIGF2b2lkIHdhcm5pbmcgZm9yIGFtYmlndWl0eSBiZXR3ZWVuXG4gICBQZXJ2YXNpdmVzLmZvcm1hdDZcbiAgIGFuZCBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuZm9ybWF0NlxuXG4gICAodGhlIGZvcm1lciBpcyBpbiBmYWN0IGFuIGFsaWFzIGZvciB0aGUgbGF0dGVyLFxuICAgIGJ1dCB0aGUgYW1iaWd1aXR5IHdhcm5pbmcgZG9lc24ndCBjYXJlKVxuKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgPVxuICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgUGVydmFzaXZlcy5mb3JtYXQ2XG5cblxuKCogVGhlIHJ1bi10aW1lIGxpYnJhcnkgZm9yIHNjYW5uZXJzLiAqKVxuXG4oKiBTY2FubmluZyBidWZmZXJzLiAqKVxubW9kdWxlIHR5cGUgU0NBTk5JTkcgPSBzaWdcblxuICB0eXBlIGluX2NoYW5uZWxcblxuICB0eXBlIHNjYW5idWYgPSBpbl9jaGFubmVsXG5cbiAgdHlwZSBmaWxlX25hbWUgPSBzdHJpbmdcblxuICB2YWwgc3RkaW4gOiBpbl9jaGFubmVsXG4gICgqIFRoZSBzY2FubmluZyBidWZmZXIgcmVhZGluZyBmcm9tIFtQZXJ2YXNpdmVzLnN0ZGluXS5cbiAgICAgW3N0ZGliXSBpcyBlcXVpdmFsZW50IHRvIFtTY2FubmluZy5mcm9tX2NoYW5uZWwgUGVydmFzaXZlcy5zdGRpbl0uICopXG5cbiAgdmFsIHN0ZGliIDogaW5fY2hhbm5lbFxuICAoKiBBbiBhbGlhcyBmb3IgW1NjYW5mLnN0ZGluXSwgdGhlIHNjYW5uaW5nIGJ1ZmZlciByZWFkaW5nIGZyb21cbiAgICAgW1BlcnZhc2l2ZXMuc3RkaW5dLiAqKVxuXG4gIHZhbCBuZXh0X2NoYXIgOiBzY2FuYnVmIC0+IGNoYXJcbiAgKCogW1NjYW5uaW5nLm5leHRfY2hhciBpYl0gYWR2YW5jZSB0aGUgc2Nhbm5pbmcgYnVmZmVyIGZvclxuICAgICBvbmUgY2hhcmFjdGVyLlxuICAgICBJZiBubyBtb3JlIGNoYXJhY3RlciBjYW4gYmUgcmVhZCwgc2V0cyBhIGVuZCBvZiBmaWxlIGNvbmRpdGlvbiBhbmRcbiAgICAgcmV0dXJucyAnXFwwMDAnLiAqKVxuXG4gIHZhbCBpbnZhbGlkYXRlX2N1cnJlbnRfY2hhciA6IHNjYW5idWYgLT4gdW5pdFxuICAoKiBbU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWJdIG1hcmsgdGhlIGN1cnJlbnRfY2hhciBhcyBhbHJlYWR5XG4gICAgIHNjYW5uZWQuICopXG5cbiAgdmFsIHBlZWtfY2hhciA6IHNjYW5idWYgLT4gY2hhclxuICAoKiBbU2Nhbm5pbmcucGVla19jaGFyIGliXSByZXR1cm5zIHRoZSBjdXJyZW50IGNoYXIgYXZhaWxhYmxlIGluXG4gICAgIHRoZSBidWZmZXIgb3IgcmVhZHMgb25lIGlmIG5lY2Vzc2FyeSAod2hlbiB0aGUgY3VycmVudCBjaGFyYWN0ZXIgaXNcbiAgICAgYWxyZWFkeSBzY2FubmVkKS5cbiAgICAgSWYgbm8gY2hhcmFjdGVyIGNhbiBiZSByZWFkLCBzZXRzIGFuIGVuZCBvZiBmaWxlIGNvbmRpdGlvbiBhbmRcbiAgICAgcmV0dXJucyAnXFwwMDAnLiAqKVxuXG4gIHZhbCBjaGVja2VkX3BlZWtfY2hhciA6IHNjYW5idWYgLT4gY2hhclxuICAoKiBTYW1lIGFzIFtTY2FubmluZy5wZWVrX2NoYXJdIGFib3ZlIGJ1dCBhbHdheXMgcmV0dXJucyBhIHZhbGlkIGNoYXIgb3JcbiAgICAgZmFpbHM6IGluc3RlYWQgb2YgcmV0dXJuaW5nIGEgbnVsbCBjaGFyIHdoZW4gdGhlIHJlYWRpbmcgbWV0aG9kIG9mIHRoZVxuICAgICBpbnB1dCBidWZmZXIgaGFzIHJlYWNoZWQgYW4gZW5kIG9mIGZpbGUsIHRoZSBmdW5jdGlvbiByYWlzZXMgZXhjZXB0aW9uXG4gICAgIFtFbmRfb2ZfZmlsZV0uICopXG5cbiAgdmFsIHN0b3JlX2NoYXIgOiBpbnQgLT4gc2NhbmJ1ZiAtPiBjaGFyIC0+IGludFxuICAoKiBbU2Nhbm5pbmcuc3RvcmVfY2hhciBsaW0gaWIgY10gYWRkcyBbY10gdG8gdGhlIHRva2VuIGJ1ZmZlclxuICAgICBvZiB0aGUgc2Nhbm5pbmcgYnVmZmVyIFtpYl0uIEl0IGFsc28gYWR2YW5jZXMgdGhlIHNjYW5uaW5nIGJ1ZmZlciBmb3JcbiAgICAgb25lIGNoYXJhY3RlciBhbmQgcmV0dXJucyBbbGltIC0gMV0sIGluZGljYXRpbmcgdGhlIG5ldyBsaW1pdCBmb3IgdGhlXG4gICAgIGxlbmd0aCBvZiB0aGUgY3VycmVudCB0b2tlbi4gKilcblxuICB2YWwgc2tpcF9jaGFyIDogaW50IC0+IHNjYW5idWYgLT4gaW50XG4gICgqIFtTY2FubmluZy5za2lwX2NoYXIgbGltIGliXSBpZ25vcmVzIHRoZSBjdXJyZW50IGNoYXJhY3Rlci4gKilcblxuICB2YWwgaWdub3JlX2NoYXIgOiBpbnQgLT4gc2NhbmJ1ZiAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLmlnbm9yZV9jaGFyIGliIGxpbV0gaWdub3JlcyB0aGUgY3VycmVudCBjaGFyYWN0ZXIgYW5kXG4gICAgIGRlY3JlbWVudHMgdGhlIGxpbWl0LiAqKVxuXG4gIHZhbCB0b2tlbiA6IHNjYW5idWYgLT4gc3RyaW5nXG4gICgqIFtTY2FubmluZy50b2tlbiBpYl0gcmV0dXJucyB0aGUgc3RyaW5nIHN0b3JlZCBpbnRvIHRoZSB0b2tlblxuICAgICBidWZmZXIgb2YgdGhlIHNjYW5uaW5nIGJ1ZmZlcjogaXQgcmV0dXJucyB0aGUgdG9rZW4gbWF0Y2hlZCBieSB0aGVcbiAgICAgZm9ybWF0LiAqKVxuXG4gIHZhbCByZXNldF90b2tlbiA6IHNjYW5idWYgLT4gdW5pdFxuICAoKiBbU2Nhbm5pbmcucmVzZXRfdG9rZW4gaWJdIHJlc2V0cyB0aGUgdG9rZW4gYnVmZmVyIG9mXG4gICAgIHRoZSBnaXZlbiBzY2FubmluZyBidWZmZXIuICopXG5cbiAgdmFsIGNoYXJfY291bnQgOiBzY2FuYnVmIC0+IGludFxuICAoKiBbU2Nhbm5pbmcuY2hhcl9jb3VudCBpYl0gcmV0dXJucyB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnNcbiAgICAgcmVhZCBzbyBmYXIgZnJvbSB0aGUgZ2l2ZW4gYnVmZmVyLiAqKVxuXG4gIHZhbCBsaW5lX2NvdW50IDogc2NhbmJ1ZiAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLmxpbmVfY291bnQgaWJdIHJldHVybnMgdGhlIG51bWJlciBvZiBuZXcgbGluZVxuICAgICBjaGFyYWN0ZXJzIHJlYWQgc28gZmFyIGZyb20gdGhlIGdpdmVuIGJ1ZmZlci4gKilcblxuICB2YWwgdG9rZW5fY291bnQgOiBzY2FuYnVmIC0+IGludFxuICAoKiBbU2Nhbm5pbmcudG9rZW5fY291bnQgaWJdIHJldHVybnMgdGhlIG51bWJlciBvZiB0b2tlbnMgcmVhZFxuICAgICBzbyBmYXIgZnJvbSBbaWJdLiAqKVxuXG4gIHZhbCBlb2YgOiBzY2FuYnVmIC0+IGJvb2xcbiAgKCogW1NjYW5uaW5nLmVvZiBpYl0gcmV0dXJucyB0aGUgZW5kIG9mIGlucHV0IGNvbmRpdGlvblxuICAgICBvZiB0aGUgZ2l2ZW4gYnVmZmVyLiAqKVxuXG4gIHZhbCBlbmRfb2ZfaW5wdXQgOiBzY2FuYnVmIC0+IGJvb2xcbiAgKCogW1NjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYl0gdGVzdHMgdGhlIGVuZCBvZiBpbnB1dCBjb25kaXRpb25cbiAgICAgb2YgdGhlIGdpdmVuIGJ1ZmZlciAoaWYgbm8gY2hhciBoYXMgZXZlciBiZWVuIHJlYWQsIGFuIGF0dGVtcHQgdG9cbiAgICAgcmVhZCBvbmUgaXMgcGVyZm9ybWVkKS4gKilcblxuICB2YWwgYmVnaW5uaW5nX29mX2lucHV0IDogc2NhbmJ1ZiAtPiBib29sXG4gICgqIFtTY2FubmluZy5iZWdpbm5pbmdfb2ZfaW5wdXQgaWJdIHRlc3RzIHRoZSBiZWdpbm5pbmcgb2YgaW5wdXRcbiAgICAgY29uZGl0aW9uIG9mIHRoZSBnaXZlbiBidWZmZXIuICopXG5cbiAgdmFsIG5hbWVfb2ZfaW5wdXQgOiBzY2FuYnVmIC0+IHN0cmluZ1xuICAoKiBbU2Nhbm5pbmcubmFtZV9vZl9pbnB1dCBpYl0gcmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgY2hhcmFjdGVyXG4gICAgIHNvdXJjZSBmb3IgaW5wdXQgYnVmZmVyIFtpYl0uICopXG5cbiAgdmFsIG9wZW5faW4gOiBmaWxlX25hbWUgLT4gaW5fY2hhbm5lbFxuICB2YWwgb3Blbl9pbl9iaW4gOiBmaWxlX25hbWUgLT4gaW5fY2hhbm5lbFxuICB2YWwgZnJvbV9maWxlIDogZmlsZV9uYW1lIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fZmlsZV9iaW4gOiBmaWxlX25hbWUgLT4gaW5fY2hhbm5lbFxuICB2YWwgZnJvbV9zdHJpbmcgOiBzdHJpbmcgLT4gaW5fY2hhbm5lbFxuICB2YWwgZnJvbV9mdW5jdGlvbiA6ICh1bml0IC0+IGNoYXIpIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fY2hhbm5lbCA6IFBlcnZhc2l2ZXMuaW5fY2hhbm5lbCAtPiBpbl9jaGFubmVsXG5cbiAgdmFsIGNsb3NlX2luIDogaW5fY2hhbm5lbCAtPiB1bml0XG5cbiAgdmFsIG1lbW9fZnJvbV9jaGFubmVsIDogUGVydmFzaXZlcy5pbl9jaGFubmVsIC0+IGluX2NoYW5uZWxcbiAgKCogT2Jzb2xldGUuICopXG5cbmVuZFxuXG5cbm1vZHVsZSBTY2FubmluZyA6IFNDQU5OSU5HID0gc3RydWN0XG5cbiAgKCogVGhlIHJ1bi10aW1lIGxpYnJhcnkgZm9yIHNjYW5mLiAqKVxuXG4gIHR5cGUgZmlsZV9uYW1lID0gc3RyaW5nXG5cbiAgdHlwZSBpbl9jaGFubmVsX25hbWUgPVxuICAgIHwgRnJvbV9jaGFubmVsIG9mIFBlcnZhc2l2ZXMuaW5fY2hhbm5lbFxuICAgIHwgRnJvbV9maWxlIG9mIGZpbGVfbmFtZSAqIFBlcnZhc2l2ZXMuaW5fY2hhbm5lbFxuICAgIHwgRnJvbV9mdW5jdGlvblxuICAgIHwgRnJvbV9zdHJpbmdcblxuXG4gIHR5cGUgaW5fY2hhbm5lbCA9IHtcbiAgICBtdXRhYmxlIGljX2VvZiA6IGJvb2w7XG4gICAgbXV0YWJsZSBpY19jdXJyZW50X2NoYXIgOiBjaGFyO1xuICAgIG11dGFibGUgaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkIDogYm9vbDtcbiAgICBtdXRhYmxlIGljX2NoYXJfY291bnQgOiBpbnQ7XG4gICAgbXV0YWJsZSBpY19saW5lX2NvdW50IDogaW50O1xuICAgIG11dGFibGUgaWNfdG9rZW5fY291bnQgOiBpbnQ7XG4gICAgbXV0YWJsZSBpY19nZXRfbmV4dF9jaGFyIDogdW5pdCAtPiBjaGFyO1xuICAgIGljX3Rva2VuX2J1ZmZlciA6IEJ1ZmZlci50O1xuICAgIGljX2lucHV0X25hbWUgOiBpbl9jaGFubmVsX25hbWU7XG4gIH1cblxuXG4gIHR5cGUgc2NhbmJ1ZiA9IGluX2NoYW5uZWxcblxuICBsZXQgbnVsbF9jaGFyID0gJ1xcMDAwJ1xuXG4gICgqIFJlYWRzIGEgbmV3IGNoYXJhY3RlciBmcm9tIGlucHV0IGJ1ZmZlci5cbiAgICAgTmV4dF9jaGFyIG5ldmVyIGZhaWxzLCBldmVuIGluIGNhc2Ugb2YgZW5kIG9mIGlucHV0OlxuICAgICBpdCB0aGVuIHNpbXBseSBzZXRzIHRoZSBlbmQgb2YgZmlsZSBjb25kaXRpb24uICopXG4gIGxldCBuZXh0X2NoYXIgaWIgPVxuICAgIHRyeVxuICAgICAgbGV0IGMgPSBpYi5pY19nZXRfbmV4dF9jaGFyICgpIGluXG4gICAgICBpYi5pY19jdXJyZW50X2NoYXIgPC0gYztcbiAgICAgIGliLmljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA8LSB0cnVlO1xuICAgICAgaWIuaWNfY2hhcl9jb3VudCA8LSBzdWNjIGliLmljX2NoYXJfY291bnQ7XG4gICAgICBpZiBjID0gJ1xcbicgdGhlbiBpYi5pY19saW5lX2NvdW50IDwtIHN1Y2MgaWIuaWNfbGluZV9jb3VudDtcbiAgICAgIGMgd2l0aFxuICAgIHwgRW5kX29mX2ZpbGUgLT5cbiAgICAgIGxldCBjID0gbnVsbF9jaGFyIGluXG4gICAgICBpYi5pY19jdXJyZW50X2NoYXIgPC0gYztcbiAgICAgIGliLmljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA8LSBmYWxzZTtcbiAgICAgIGliLmljX2VvZiA8LSB0cnVlO1xuICAgICAgY1xuXG5cbiAgbGV0IHBlZWtfY2hhciBpYiA9XG4gICAgaWYgaWIuaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkXG4gICAgdGhlbiBpYi5pY19jdXJyZW50X2NoYXJcbiAgICBlbHNlIG5leHRfY2hhciBpYlxuXG5cbiAgKCogUmV0dXJucyBhIHZhbGlkIGN1cnJlbnQgY2hhciBmb3IgdGhlIGlucHV0IGJ1ZmZlci4gSW4gcGFydGljdWxhclxuICAgICBubyBpcnJlbGV2YW50IG51bGwgY2hhcmFjdGVyIChhcyBzZXQgYnkgW25leHRfY2hhcl0gaW4gY2FzZSBvZiBlbmRcbiAgICAgb2YgaW5wdXQpIGlzIHJldHVybmVkLCBzaW5jZSBbRW5kX29mX2ZpbGVdIGlzIHJhaXNlZCB3aGVuXG4gICAgIFtuZXh0X2NoYXJdIHNldHMgdGhlIGVuZCBvZiBmaWxlIGNvbmRpdGlvbiB3aGlsZSB0cnlpbmcgdG8gcmVhZCBhXG4gICAgIG5ldyBjaGFyYWN0ZXIuICopXG4gIGxldCBjaGVja2VkX3BlZWtfY2hhciBpYiA9XG4gICAgbGV0IGMgPSBwZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBpYi5pY19lb2YgdGhlbiByYWlzZSBFbmRfb2ZfZmlsZTtcbiAgICBjXG5cblxuICBsZXQgZW5kX29mX2lucHV0IGliID1cbiAgICBpZ25vcmUgKHBlZWtfY2hhciBpYik7XG4gICAgaWIuaWNfZW9mXG5cblxuICBsZXQgZW9mIGliID0gaWIuaWNfZW9mXG5cbiAgbGV0IGJlZ2lubmluZ19vZl9pbnB1dCBpYiA9IGliLmljX2NoYXJfY291bnQgPSAwXG5cbiAgbGV0IG5hbWVfb2ZfaW5wdXQgaWIgPVxuICAgIG1hdGNoIGliLmljX2lucHV0X25hbWUgd2l0aFxuICAgIHwgRnJvbV9jaGFubmVsIF9pYyAtPiBcInVubmFtZWQgUGVydmFzaXZlcyBpbnB1dCBjaGFubmVsXCJcbiAgICB8IEZyb21fZmlsZSAoZm5hbWUsIF9pYykgLT4gZm5hbWVcbiAgICB8IEZyb21fZnVuY3Rpb24gLT4gXCJ1bm5hbWVkIGZ1bmN0aW9uXCJcbiAgICB8IEZyb21fc3RyaW5nIC0+IFwidW5uYW1lZCBjaGFyYWN0ZXIgc3RyaW5nXCJcblxuXG4gIGxldCBjaGFyX2NvdW50IGliID1cbiAgICBpZiBpYi5pY19jdXJyZW50X2NoYXJfaXNfdmFsaWRcbiAgICB0aGVuIGliLmljX2NoYXJfY291bnQgLSAxXG4gICAgZWxzZSBpYi5pY19jaGFyX2NvdW50XG5cblxuICBsZXQgbGluZV9jb3VudCBpYiA9IGliLmljX2xpbmVfY291bnRcblxuICBsZXQgcmVzZXRfdG9rZW4gaWIgPSBCdWZmZXIucmVzZXQgaWIuaWNfdG9rZW5fYnVmZmVyXG5cbiAgbGV0IGludmFsaWRhdGVfY3VycmVudF9jaGFyIGliID0gaWIuaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkIDwtIGZhbHNlXG5cbiAgbGV0IHRva2VuIGliID1cbiAgICBsZXQgdG9rZW5fYnVmZmVyID0gaWIuaWNfdG9rZW5fYnVmZmVyIGluXG4gICAgbGV0IHRvayA9IEJ1ZmZlci5jb250ZW50cyB0b2tlbl9idWZmZXIgaW5cbiAgICBCdWZmZXIuY2xlYXIgdG9rZW5fYnVmZmVyO1xuICAgIGliLmljX3Rva2VuX2NvdW50IDwtIHN1Y2MgaWIuaWNfdG9rZW5fY291bnQ7XG4gICAgdG9rXG5cblxuICBsZXQgdG9rZW5fY291bnQgaWIgPSBpYi5pY190b2tlbl9jb3VudFxuXG4gIGxldCBza2lwX2NoYXIgd2lkdGggaWIgPVxuICAgIGludmFsaWRhdGVfY3VycmVudF9jaGFyIGliO1xuICAgIHdpZHRoXG5cblxuICBsZXQgaWdub3JlX2NoYXIgd2lkdGggaWIgPSBza2lwX2NoYXIgKHdpZHRoIC0gMSkgaWJcblxuICBsZXQgc3RvcmVfY2hhciB3aWR0aCBpYiBjID1cbiAgICBCdWZmZXIuYWRkX2NoYXIgaWIuaWNfdG9rZW5fYnVmZmVyIGM7XG4gICAgaWdub3JlX2NoYXIgd2lkdGggaWJcblxuXG4gIGxldCBkZWZhdWx0X3Rva2VuX2J1ZmZlcl9zaXplID0gMTAyNFxuXG4gIGxldCBjcmVhdGUgaW5hbWUgbmV4dCA9IHtcbiAgICBpY19lb2YgPSBmYWxzZTtcbiAgICBpY19jdXJyZW50X2NoYXIgPSBudWxsX2NoYXI7XG4gICAgaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkID0gZmFsc2U7XG4gICAgaWNfY2hhcl9jb3VudCA9IDA7XG4gICAgaWNfbGluZV9jb3VudCA9IDA7XG4gICAgaWNfdG9rZW5fY291bnQgPSAwO1xuICAgIGljX2dldF9uZXh0X2NoYXIgPSBuZXh0O1xuICAgIGljX3Rva2VuX2J1ZmZlciA9IEJ1ZmZlci5jcmVhdGUgZGVmYXVsdF90b2tlbl9idWZmZXJfc2l6ZTtcbiAgICBpY19pbnB1dF9uYW1lID0gaW5hbWU7XG4gIH1cblxuXG4gIGxldCBmcm9tX3N0cmluZyBzID1cbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICAgIGxldCBuZXh0ICgpID1cbiAgICAgIGlmICFpID49IGxlbiB0aGVuIHJhaXNlIEVuZF9vZl9maWxlIGVsc2VcbiAgICAgIGxldCBjID0gcy5bIWldIGluXG4gICAgICBpbmNyIGk7XG4gICAgICBjIGluXG4gICAgY3JlYXRlIEZyb21fc3RyaW5nIG5leHRcblxuXG4gIGxldCBmcm9tX2Z1bmN0aW9uID0gY3JlYXRlIEZyb21fZnVuY3Rpb25cblxuICAoKiBTY2FubmluZyBmcm9tIGFuIGlucHV0IGNoYW5uZWwuICopXG5cbiAgKCogUG9zaXRpb24gb2YgdGhlIHByb2JsZW06XG5cbiAgICAgV2UgY2Fubm90IHByZXZlbnQgdGhlIHNjYW5uaW5nIG1lY2hhbmlzbSB0byB1c2Ugb25lIGxvb2thaGVhZCBjaGFyYWN0ZXIsXG4gICAgIGlmIG5lZWRlZCBieSB0aGUgc2VtYW50aWNzIG9mIHRoZSBmb3JtYXQgc3RyaW5nIHNwZWNpZmljYXRpb25zIChlLmcuIGFcbiAgICAgdHJhaWxpbmcgJ3NraXAgc3BhY2UnIHNwZWNpZmljYXRpb24gaW4gdGhlIGZvcm1hdCBzdHJpbmcpOyBpbiB0aGlzIGNhc2UsXG4gICAgIHRoZSBtYW5kYXRvcnkgbG9va2FoZWFkIGNoYXJhY3RlciBpcyBpbmRlZWQgcmVhZCBmcm9tIHRoZSBpbnB1dCBhbmQgbm90XG4gICAgIHVzZWQgdG8gcmV0dXJuIHRoZSB0b2tlbiByZWFkLiBJdCBpcyB0aHVzIG1hbmRhdG9yeSB0byBiZSBhYmxlIHRvIHN0b3JlXG4gICAgIGFuIHVudXNlZCBsb29rYWhlYWQgY2hhcmFjdGVyIHNvbWV3aGVyZSB0byBnZXQgaXQgYXMgdGhlIGZpcnN0IGNoYXJhY3RlclxuICAgICBvZiB0aGUgbmV4dCBzY2FuLlxuXG4gICAgIFRvIGNpcmN1bXZlbnQgdGhpcyBwcm9ibGVtLCBhbGwgdGhlIHNjYW5uaW5nIGZ1bmN0aW9ucyBnZXQgYSBsb3cgbGV2ZWxcbiAgICAgaW5wdXQgYnVmZmVyIGFyZ3VtZW50IHdoZXJlIHRoZXkgc3RvcmUgdGhlIGxvb2thaGVhZCBjaGFyYWN0ZXIgd2hlblxuICAgICBuZWVkZWQ7IGFkZGl0aW9uYWxseSwgdGhlIGlucHV0IGJ1ZmZlciBpcyB0aGUgb25seSBzb3VyY2Ugb2YgY2hhcmFjdGVyIG9mXG4gICAgIGEgc2Nhbm5lci4gVGhlIFtzY2FuYnVmXSBpbnB1dCBidWZmZXJzIGFyZSBkZWZpbmVkIGluIG1vZHVsZSB7IVNjYW5uaW5nfS5cblxuICAgICBOb3cgd2UgdW5kZXJzdGFuZCB0aGF0IGl0IGlzIGV4dHJlbWVseSBpbXBvcnRhbnQgdGhhdCByZWxhdGVkIGFuZFxuICAgICBzdWNjZXNzaXZlIGNhbGxzIHRvIHNjYW5uZXJzIGluZGVlZCByZWFkIGZyb20gdGhlIHNhbWUgaW5wdXQgYnVmZmVyLlxuICAgICBJbiBlZmZlY3QsIGlmIGEgc2Nhbm5lciBbc2NhbjFdIGlzIHJlYWRpbmcgZnJvbSBbaWIxXSBhbmQgc3RvcmVzIGFuXG4gICAgIHVudXNlZCBsb29rYWhlYWQgY2hhcmFjdGVyIFtjMV0gaW50byBpdHMgaW5wdXQgYnVmZmVyIFtpYjFdLCB0aGVuXG4gICAgIGFub3RoZXIgc2Nhbm5lciBbc2NhbjJdIG5vdCByZWFkaW5nIGZyb20gdGhlIHNhbWUgYnVmZmVyIFtpYjFdIHdpbGwgbWlzc1xuICAgICB0aGUgY2hhcmFjdGVyIFtjMV0sIHNlZW1pbmdseSB2YW5pc2hlZCBpbiB0aGUgYWlyIGZyb20gdGhlIHBvaW50IG9mIHZpZXdcbiAgICAgb2YgW3NjYW4yXS5cblxuICAgICBUaGlzIG1lY2hhbmlzbSB3b3JrcyBwZXJmZWN0bHkgdG8gcmVhZCBmcm9tIHN0cmluZ3MsIGZyb20gZmlsZXMsIGFuZCBmcm9tXG4gICAgIGZ1bmN0aW9ucywgc2luY2UgaW4gdGhvc2UgY2FzZXMsIGFsbG9jYXRpbmcgdHdvIGJ1ZmZlcnMgcmVhZGluZyBmcm9tIHRoZVxuICAgICBzYW1lIHNvdXJjZSBpcyB1bm5hdHVyYWwuXG5cbiAgICAgU3RpbGwsIHRoZXJlIGlzIGEgZGlmZmljdWx0eSBpbiB0aGUgY2FzZSBvZiBzY2FubmluZyBmcm9tIGFuIGlucHV0XG4gICAgIGNoYW5uZWwuIEluIGVmZmVjdCwgd2hlbiBzY2FubmluZyBmcm9tIGFuIGlucHV0IGNoYW5uZWwgW2ljXSwgdGhpcyBjaGFubmVsXG4gICAgIG1heSBub3QgaGF2ZSBiZWVuIGFsbG9jYXRlZCBmcm9tIHdpdGhpbiB0aGlzIGxpYnJhcnkuIEhlbmNlLCBpdCBtYXkgYmVcbiAgICAgc2hhcmVkICh0d28gZnVuY3Rpb25zIG9mIHRoZSB1c2VyJ3MgcHJvZ3JhbSBtYXkgc3VjY2Vzc2l2ZWx5IHJlYWQgZnJvbVxuICAgICBbaWNdKS4gVGhpcyBpcyBoaWdobHkgZXJyb3IgcHJvbmUgc2luY2UsIG9uZSBvZiB0aGUgZnVuY3Rpb24gbWF5IHNlZWsgdGhlXG4gICAgIGlucHV0IGNoYW5uZWwsIHdoaWxlIHRoZSBvdGhlciBmdW5jdGlvbiBoYXMgc3RpbGwgYW4gdW51c2VkIGxvb2thaGVhZFxuICAgICBjaGFyYWN0ZXIgaW4gaXRzIGlucHV0IGJ1ZmZlci4gSW4gY29uY2x1c2lvbiwgeW91IHNob3VsZCBuZXZlciBtaXggZGlyZWN0XG4gICAgIGxvdyBsZXZlbCByZWFkaW5nIGFuZCBoaWdoIGxldmVsIHNjYW5uaW5nIGZyb20gdGhlIHNhbWUgaW5wdXQgY2hhbm5lbC5cblxuICAqKVxuXG4gICgqIFBlcmZvcm0gYnVmZmVyaXplZCBpbnB1dCB0byBpbXByb3ZlIGVmZmljaWVuY3kuICopXG4gIGxldCBmaWxlX2J1ZmZlcl9zaXplID0gcmVmIDEwMjRcblxuICAoKiBUaGUgc2Nhbm5lciBjbG9zZXMgdGhlIGlucHV0IGNoYW5uZWwgYXQgZW5kIG9mIGlucHV0LiAqKVxuICBsZXQgc2Nhbl9jbG9zZV9hdF9lbmQgaWMgPSBQZXJ2YXNpdmVzLmNsb3NlX2luIGljOyByYWlzZSBFbmRfb2ZfZmlsZVxuXG4gICgqIFRoZSBzY2FubmVyIGRvZXMgbm90IGNsb3NlIHRoZSBpbnB1dCBjaGFubmVsIGF0IGVuZCBvZiBpbnB1dDpcbiAgICAgaXQganVzdCByYWlzZXMgW0VuZF9vZl9maWxlXS4gKilcbiAgbGV0IHNjYW5fcmFpc2VfYXRfZW5kIF9pYyA9IHJhaXNlIEVuZF9vZl9maWxlXG5cbiAgbGV0IGZyb21faWMgc2Nhbl9jbG9zZV9pYyBpbmFtZSBpYyA9XG4gICAgbGV0IGxlbiA9ICFmaWxlX2J1ZmZlcl9zaXplIGluXG4gICAgbGV0IGJ1ZiA9IEJ5dGVzLmNyZWF0ZSBsZW4gaW5cbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgbGV0IGxpbSA9IHJlZiAwIGluXG4gICAgbGV0IGVvZiA9IHJlZiBmYWxzZSBpblxuICAgIGxldCBuZXh0ICgpID1cbiAgICAgIGlmICFpIDwgIWxpbSB0aGVuIGJlZ2luIGxldCBjID0gQnl0ZXMuZ2V0IGJ1ZiAhaSBpbiBpbmNyIGk7IGMgZW5kIGVsc2VcbiAgICAgIGlmICFlb2YgdGhlbiByYWlzZSBFbmRfb2ZfZmlsZSBlbHNlIGJlZ2luXG4gICAgICAgIGxpbSA6PSBpbnB1dCBpYyBidWYgMCBsZW47XG4gICAgICAgIGlmICFsaW0gPSAwIHRoZW4gYmVnaW4gZW9mIDo9IHRydWU7IHNjYW5fY2xvc2VfaWMgaWMgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgICBpIDo9IDE7XG4gICAgICAgICAgQnl0ZXMuZ2V0IGJ1ZiAwXG4gICAgICAgIGVuZFxuICAgICAgZW5kIGluXG4gICAgY3JlYXRlIGluYW1lIG5leHRcblxuXG4gIGxldCBmcm9tX2ljX2Nsb3NlX2F0X2VuZCA9IGZyb21faWMgc2Nhbl9jbG9zZV9hdF9lbmRcbiAgbGV0IGZyb21faWNfcmFpc2VfYXRfZW5kID0gZnJvbV9pYyBzY2FuX3JhaXNlX2F0X2VuZFxuXG4gICgqIFRoZSBzY2FubmluZyBidWZmZXIgcmVhZGluZyBmcm9tIFtQZXJ2YXNpdmVzLnN0ZGluXS5cbiAgICAgT25lIGNvdWxkIHRyeSB0byBkZWZpbmUgW3N0ZGliXSBhcyBhIHNjYW5uaW5nIGJ1ZmZlciByZWFkaW5nIGEgY2hhcmFjdGVyXG4gICAgIGF0IGEgdGltZSAobm8gYnVmZmVyaXphdGlvbiBhdCBhbGwpLCBidXQgdW5mb3J0dW5hdGVseSB0aGUgdG9wLWxldmVsXG4gICAgIGludGVyYWN0aW9uIHdvdWxkIGJlIHdyb25nLiBUaGlzIGlzIGR1ZSB0byBzb21lIGtpbmQgb2ZcbiAgICAgJ3JhY2UgY29uZGl0aW9uJyB3aGVuIHJlYWRpbmcgZnJvbSBbUGVydmFzaXZlcy5zdGRpbl0sXG4gICAgIHNpbmNlIHRoZSBpbnRlcmFjdGl2ZSBjb21waWxlciBhbmQgW1NjYW5mLnNjYW5mXSB3aWxsIHNpbXVsdGFuZW91c2x5XG4gICAgIHJlYWQgdGhlIG1hdGVyaWFsIHRoZXkgbmVlZCBmcm9tIFtQZXJ2YXNpdmVzLnN0ZGluXTsgdGhlbiwgY29uZnVzaW9uXG4gICAgIHdpbGwgcmVzdWx0IGZyb20gd2hhdCBzaG91bGQgYmUgcmVhZCBieSB0aGUgdG9wLWxldmVsIGFuZCB3aGF0IHNob3VsZCBiZVxuICAgICByZWFkIGJ5IFtTY2FuZi5zY2FuZl0uXG4gICAgIFRoaXMgaXMgZXZlbiBtb3JlIGNvbXBsaWNhdGVkIGJ5IHRoZSBvbmUgY2hhcmFjdGVyIGxvb2thaGVhZCB0aGF0XG4gICAgIFtTY2FuZi5zY2FuZl0gaXMgc29tZXRpbWVzIG9ibGlnZWQgdG8gbWFpbnRhaW46IHRoZSBsb29rYWhlYWQgY2hhcmFjdGVyXG4gICAgIHdpbGwgYmUgYXZhaWxhYmxlIGZvciB0aGUgbmV4dCBbU2NhbmYuc2NhbmZdIGVudHJ5LCBzZWVtaW5nbHkgY29taW5nIGZyb21cbiAgICAgbm93aGVyZS5cbiAgICAgQWxzbyBubyBbRW5kX29mX2ZpbGVdIGlzIHJhaXNlZCB3aGVuIHJlYWRpbmcgZnJvbSBzdGRpbjogaWYgbm90IGVub3VnaFxuICAgICBjaGFyYWN0ZXJzIGhhdmUgYmVlbiByZWFkLCB3ZSBzaW1wbHkgYXNrIHRvIHJlYWQgbW9yZS4gKilcbiAgbGV0IHN0ZGluID1cbiAgICBmcm9tX2ljIHNjYW5fcmFpc2VfYXRfZW5kXG4gICAgICAoRnJvbV9maWxlIChcIi1cIiwgUGVydmFzaXZlcy5zdGRpbikpIFBlcnZhc2l2ZXMuc3RkaW5cblxuXG4gIGxldCBzdGRpYiA9IHN0ZGluXG5cbiAgbGV0IG9wZW5faW5fZmlsZSBvcGVuX2luIGZuYW1lID1cbiAgICBtYXRjaCBmbmFtZSB3aXRoXG4gICAgfCBcIi1cIiAtPiBzdGRpblxuICAgIHwgZm5hbWUgLT5cbiAgICAgIGxldCBpYyA9IG9wZW5faW4gZm5hbWUgaW5cbiAgICAgIGZyb21faWNfY2xvc2VfYXRfZW5kIChGcm9tX2ZpbGUgKGZuYW1lLCBpYykpIGljXG5cblxuICBsZXQgb3Blbl9pbiA9IG9wZW5faW5fZmlsZSBQZXJ2YXNpdmVzLm9wZW5faW5cbiAgbGV0IG9wZW5faW5fYmluID0gb3Blbl9pbl9maWxlIFBlcnZhc2l2ZXMub3Blbl9pbl9iaW5cblxuICBsZXQgZnJvbV9maWxlID0gb3Blbl9pblxuICBsZXQgZnJvbV9maWxlX2JpbiA9IG9wZW5faW5fYmluXG5cbiAgbGV0IGZyb21fY2hhbm5lbCBpYyA9XG4gICAgZnJvbV9pY19yYWlzZV9hdF9lbmQgKEZyb21fY2hhbm5lbCBpYykgaWNcblxuXG4gIGxldCBjbG9zZV9pbiBpYiA9XG4gICAgbWF0Y2ggaWIuaWNfaW5wdXRfbmFtZSB3aXRoXG4gICAgfCBGcm9tX2NoYW5uZWwgaWMgLT5cbiAgICAgIFBlcnZhc2l2ZXMuY2xvc2VfaW4gaWNcbiAgICB8IEZyb21fZmlsZSAoX2ZuYW1lLCBpYykgLT4gUGVydmFzaXZlcy5jbG9zZV9pbiBpY1xuICAgIHwgRnJvbV9mdW5jdGlvbiB8IEZyb21fc3RyaW5nIC0+ICgpXG5cblxuICAoKlxuICAgICBPYnNvbGV0ZTogYSBtZW1vIFtmcm9tX2NoYW5uZWxdIHZlcnNpb24gdG8gYnVpbGQgYSBbU2Nhbm5pbmcuaW5fY2hhbm5lbF1cbiAgICAgc2Nhbm5pbmcgYnVmZmVyIG91dCBvZiBhIFtQZXJ2YXNpdmVzLmluX2NoYW5uZWxdLlxuICAgICBUaGlzIGZ1bmN0aW9uIHdhcyB1c2VkIHRvIHRyeSB0byBwcmVzZXJ2ZSB0aGUgc2Nhbm5pbmdcbiAgICAgc2VtYW50aWNzIGZvciB0aGUgKG5vdyBvYnNvbGV0ZSkgZnVuY3Rpb24gW2ZzY2FuZl0uXG4gICAgIEdpdmVuIHRoYXQgYWxsIHNjYW5uZXIgbXVzdCByZWFkIGZyb20gYSBbU2Nhbm5pbmcuaW5fY2hhbm5lbF0gc2Nhbm5pbmdcbiAgICAgYnVmZmVyLCBbZnNjYW5mXSBtdXN0IHJlYWQgZnJvbSBvbmUhXG4gICAgIE1vcmUgcHJlY2lzZWx5LCBnaXZlbiBbaWNdLCBhbGwgc3VjY2Vzc2l2ZSBjYWxscyBbZnNjYW5mIGljXSBtdXN0IHJlYWRcbiAgICAgZnJvbSB0aGUgc2FtZSBzY2FubmluZyBidWZmZXIuXG4gICAgIFRoaXMgb2JsaWdlZCB0aGlzIGxpYnJhcnkgdG8gYWxsb2NhdGVkIHNjYW5uaW5nIGJ1ZmZlcnMgdGhhdCB3ZXJlXG4gICAgIG5vdCBwcm9wZXJseSBnYXJiYWdlIGNvbGxlY3RhYmxlLCBoZW5jZSBsZWFkaW5nIHRvIG1lbW9yeSBsZWFrcy5cbiAgICAgSWYgeW91IG5lZWQgdG8gcmVhZCBmcm9tIGEgW1BlcnZhc2l2ZXMuaW5fY2hhbm5lbF0gaW5wdXQgY2hhbm5lbFxuICAgICBbaWNdLCBzaW1wbHkgZGVmaW5lIGEgW1NjYW5uaW5nLmluX2NoYW5uZWxdIGZvcm1hdHRlZCBpbnB1dCBjaGFubmVsIGFzIGluXG4gICAgIFtsZXQgaWIgPSBTY2FubmluZy5mcm9tX2NoYW5uZWwgaWNdLCB0aGVuIHVzZSBbU2NhbmYuYnNjYW5mIGliXSBhcyB1c3VhbC5cbiAgKilcbiAgbGV0IG1lbW9fZnJvbV9pYyA9XG4gICAgbGV0IG1lbW8gPSByZWYgW10gaW5cbiAgICAoZnVuIHNjYW5fY2xvc2VfaWMgaWMgLT5cbiAgICAgdHJ5IExpc3QuYXNzcSBpYyAhbWVtbyB3aXRoXG4gICAgIHwgTm90X2ZvdW5kIC0+XG4gICAgICAgbGV0IGliID1cbiAgICAgICAgIGZyb21faWMgc2Nhbl9jbG9zZV9pYyAoRnJvbV9jaGFubmVsIGljKSBpYyBpblxuICAgICAgIG1lbW8gOj0gKGljLCBpYikgOjogIW1lbW87XG4gICAgICAgaWIpXG5cblxuICAoKiBPYnNvbGV0ZTogc2VlIHshbWVtb19mcm9tX2ljfSBhYm92ZS4gKilcbiAgbGV0IG1lbW9fZnJvbV9jaGFubmVsID0gbWVtb19mcm9tX2ljIHNjYW5fcmFpc2VfYXRfZW5kXG5cbmVuZFxuXG5cbigqIEZvcm1hdHRlZCBpbnB1dCBmdW5jdGlvbnMuICopXG5cbnR5cGUgKCdhLCAnYiwgJ2MsICdkKSBzY2FubmVyID1cbiAgICAgKCdhLCBTY2FubmluZy5pbl9jaGFubmVsLCAnYiwgJ2MsICdhIC0+ICdkLCAnZCkgZm9ybWF0NiAtPiAnY1xuXG5cbigqIFJlcG9ydGluZyBlcnJvcnMuICopXG5leGNlcHRpb24gU2Nhbl9mYWlsdXJlIG9mIHN0cmluZ1xuXG5sZXQgYmFkX2lucHV0IHMgPSByYWlzZSAoU2Nhbl9mYWlsdXJlIHMpXG5cbmxldCBiYWRfaW5wdXRfZXNjYXBlIGMgPVxuICBiYWRfaW5wdXQgKFByaW50Zi5zcHJpbnRmIFwiaWxsZWdhbCBlc2NhcGUgY2hhcmFjdGVyICVDXCIgYylcblxuXG5sZXQgYmFkX3Rva2VuX2xlbmd0aCBtZXNzYWdlID1cbiAgYmFkX2lucHV0XG4gICAgKFByaW50Zi5zcHJpbnRmXG4gICAgICAgXCJzY2FubmluZyBvZiAlcyBmYWlsZWQ6IFxcXG4gICAgICAgIHRoZSBzcGVjaWZpZWQgbGVuZ3RoIHdhcyB0b28gc2hvcnQgZm9yIHRva2VuXCJcbiAgICAgICBtZXNzYWdlKVxuXG5cbmxldCBiYWRfZW5kX29mX2lucHV0IG1lc3NhZ2UgPVxuICBiYWRfaW5wdXRcbiAgICAoUHJpbnRmLnNwcmludGZcbiAgICAgICBcInNjYW5uaW5nIG9mICVzIGZhaWxlZDogXFxcbiAgICAgICAgcHJlbWF0dXJlIGVuZCBvZiBmaWxlIG9jY3VycmVkIGJlZm9yZSBlbmQgb2YgdG9rZW5cIlxuICAgICAgIG1lc3NhZ2UpXG5cblxubGV0IGJhZF9mbG9hdCAoKSA9XG4gIGJhZF9pbnB1dCBcIm5vIGRvdCBvciBleHBvbmVudCBwYXJ0IGZvdW5kIGluIGZsb2F0IHRva2VuXCJcblxuXG5sZXQgYmFkX2hleF9mbG9hdCAoKSA9XG4gIGJhZF9pbnB1dCBcIm5vdCBhIHZhbGlkIGZsb2F0IGluIGhleGFkZWNpbWFsIG5vdGF0aW9uXCJcblxuXG5sZXQgY2hhcmFjdGVyX21pc21hdGNoX2VyciBjIGNpID1cbiAgUHJpbnRmLnNwcmludGYgXCJsb29raW5nIGZvciAlQywgZm91bmQgJUNcIiBjIGNpXG5cblxubGV0IGNoYXJhY3Rlcl9taXNtYXRjaCBjIGNpID1cbiAgYmFkX2lucHV0IChjaGFyYWN0ZXJfbWlzbWF0Y2hfZXJyIGMgY2kpXG5cblxubGV0IHJlYyBza2lwX3doaXRlcyBpYiA9XG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIG5vdCAoU2Nhbm5pbmcuZW9mIGliKSB0aGVuIGJlZ2luXG4gICAgbWF0Y2ggYyB3aXRoXG4gICAgfCAnICcgfCAnXFx0JyB8ICdcXG4nIHwgJ1xccicgLT5cbiAgICAgIFNjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliOyBza2lwX3doaXRlcyBpYlxuICAgIHwgXyAtPiAoKVxuICBlbmRcblxuXG4oKiBDaGVja2luZyB0aGF0IFtjXSBpcyBpbmRlZWQgaW4gdGhlIGlucHV0LCB0aGVuIHNraXBzIGl0LlxuICAgSW4gdGhpcyBjYXNlLCB0aGUgY2hhcmFjdGVyIFtjXSBoYXMgYmVlbiBleHBsaWNpdGx5IHNwZWNpZmllZCBpbiB0aGVcbiAgIGZvcm1hdCBhcyBiZWluZyBtYW5kYXRvcnkgaW4gdGhlIGlucHV0OyBoZW5jZSB3ZSBzaG91bGQgZmFpbCB3aXRoXG4gICBbRW5kX29mX2ZpbGVdIGluIGNhc2Ugb2YgZW5kX29mX2lucHV0LlxuICAgKFJlbWVtYmVyIHRoYXQgW1NjYW5fZmFpbHVyZV0gaXMgcmFpc2VkIG9ubHkgd2hlbiAod2UgY2FuIHByb3ZlIGJ5XG4gICBldmlkZW5jZSkgdGhhdCB0aGUgaW5wdXQgZG9lcyBub3QgbWF0Y2ggdGhlIGZvcm1hdCBzdHJpbmcgZ2l2ZW4uIFdlIG11c3RcbiAgIHRodXMgZGlmZmVyZW50aWF0ZSBbRW5kX29mX2ZpbGVdIGFzIGFuIGVycm9yIGR1ZSB0byBsYWNrIG9mIGlucHV0LCBhbmRcbiAgIFtTY2FuX2ZhaWx1cmVdIHdoaWNoIGlzIGR1ZSB0byBwcm92YWJseSB3cm9uZyBpbnB1dC4gSSBhbSBub3Qgc3VyZSB0aGlzIGlzXG4gICB3b3J0aCB0aGUgYnVyZGVuOiBpdCBpcyBjb21wbGV4IGFuZCBzb21laG93IHN1YmxpbWluYWw7IHNob3VsZCBiZSBjbGVhcmVyXG4gICB0byBmYWlsIHdpdGggU2Nhbl9mYWlsdXJlIFwiTm90IGVub3VnaCBpbnB1dCB0byBjb21wbGV0ZSBzY2FubmluZ1wiISlcblxuICAgVGhhdCdzIHdoeSwgd2FpdGluZyBmb3IgYSBiZXR0ZXIgc29sdXRpb24sIHdlIHVzZSBjaGVja2VkX3BlZWtfY2hhciBoZXJlLlxuICAgV2UgYXJlIGFsc28gY2FyZWZ1bCB0byB0cmVhdCBcIlxcclxcblwiIGluIHRoZSBpbnB1dCBhcyBhbiBlbmQgb2YgbGluZSBtYXJrZXI6XG4gICBpdCBhbHdheXMgbWF0Y2hlcyBhICdcXG4nIHNwZWNpZmljYXRpb24gaW4gdGhlIGlucHV0IGZvcm1hdCBzdHJpbmcuICopXG5sZXQgcmVjIGNoZWNrX2NoYXIgaWIgYyA9XG4gIG1hdGNoIGMgd2l0aFxuICB8ICcgJyAtPiBza2lwX3doaXRlcyBpYlxuICB8ICdcXG4nIC0+IGNoZWNrX25ld2xpbmUgaWJcbiAgfCBjIC0+IGNoZWNrX3RoaXNfY2hhciBpYiBjXG5cbmFuZCBjaGVja190aGlzX2NoYXIgaWIgYyA9XG4gIGxldCBjaSA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIGlmIGNpID0gYyB0aGVuIFNjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliIGVsc2VcbiAgY2hhcmFjdGVyX21pc21hdGNoIGMgY2lcblxuYW5kIGNoZWNrX25ld2xpbmUgaWIgPVxuICBsZXQgY2kgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBtYXRjaCBjaSB3aXRoXG4gIHwgJ1xcbicgLT4gU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWJcbiAgfCAnXFxyJyAtPiBTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYjsgY2hlY2tfdGhpc19jaGFyIGliICdcXG4nXG4gIHwgXyAtPiBjaGFyYWN0ZXJfbWlzbWF0Y2ggJ1xcbicgY2lcblxuXG4oKiBFeHRyYWN0aW5nIHRva2VucyBmcm9tIHRoZSBvdXRwdXQgdG9rZW4gYnVmZmVyLiAqKVxuXG5sZXQgdG9rZW5fY2hhciBpYiA9IChTY2FubmluZy50b2tlbiBpYikuWzBdXG5cbmxldCB0b2tlbl9zdHJpbmcgPSBTY2FubmluZy50b2tlblxuXG5sZXQgdG9rZW5fYm9vbCBpYiA9XG4gIG1hdGNoIFNjYW5uaW5nLnRva2VuIGliIHdpdGhcbiAgfCBcInRydWVcIiAtPiB0cnVlXG4gIHwgXCJmYWxzZVwiIC0+IGZhbHNlXG4gIHwgcyAtPiBiYWRfaW5wdXQgKFByaW50Zi5zcHJpbnRmIFwiaW52YWxpZCBib29sZWFuICclcydcIiBzKVxuXG5cbigqIFRoZSB0eXBlIG9mIGludGVnZXIgY29udmVyc2lvbnMuICopXG50eXBlIGludGVnZXJfY29udmVyc2lvbiA9XG4gIHwgQl9jb252ZXJzaW9uICgqIFVuc2lnbmVkIGJpbmFyeSBjb252ZXJzaW9uICopXG4gIHwgRF9jb252ZXJzaW9uICgqIFNpZ25lZCBkZWNpbWFsIGNvbnZlcnNpb24gKilcbiAgfCBJX2NvbnZlcnNpb24gKCogU2lnbmVkIGludGVnZXIgY29udmVyc2lvbiAqKVxuICB8IE9fY29udmVyc2lvbiAoKiBVbnNpZ25lZCBvY3RhbCBjb252ZXJzaW9uICopXG4gIHwgVV9jb252ZXJzaW9uICgqIFVuc2lnbmVkIGRlY2ltYWwgY29udmVyc2lvbiAqKVxuICB8IFhfY29udmVyc2lvbiAoKiBVbnNpZ25lZCBoZXhhZGVjaW1hbCBjb252ZXJzaW9uICopXG5cblxubGV0IGludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyID0gZnVuY3Rpb25cbiAgfCAnYicgLT4gQl9jb252ZXJzaW9uXG4gIHwgJ2QnIC0+IERfY29udmVyc2lvblxuICB8ICdpJyAtPiBJX2NvbnZlcnNpb25cbiAgfCAnbycgLT4gT19jb252ZXJzaW9uXG4gIHwgJ3UnIC0+IFVfY29udmVyc2lvblxuICB8ICd4JyB8ICdYJyAtPiBYX2NvbnZlcnNpb25cbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG5cbigqIEV4dHJhY3QgYW4gaW50ZWdlciBsaXRlcmFsIHRva2VuLlxuICAgU2luY2UgdGhlIGZ1bmN0aW9ucyBQZXJ2YXNpdmVzLippbnQqX29mX3N0cmluZyBkbyBub3QgYWNjZXB0IGEgbGVhZGluZyArLFxuICAgd2Ugc2tpcCBpdCBpZiBuZWNlc3NhcnkuICopXG5sZXQgdG9rZW5faW50X2xpdGVyYWwgY29udiBpYiA9XG4gIGxldCB0b2sgPVxuICAgIG1hdGNoIGNvbnYgd2l0aFxuICAgIHwgRF9jb252ZXJzaW9uIHwgSV9jb252ZXJzaW9uIC0+IFNjYW5uaW5nLnRva2VuIGliXG4gICAgfCBVX2NvbnZlcnNpb24gLT4gXCIwdVwiIF4gU2Nhbm5pbmcudG9rZW4gaWJcbiAgICB8IE9fY29udmVyc2lvbiAtPiBcIjBvXCIgXiBTY2FubmluZy50b2tlbiBpYlxuICAgIHwgWF9jb252ZXJzaW9uIC0+IFwiMHhcIiBeIFNjYW5uaW5nLnRva2VuIGliXG4gICAgfCBCX2NvbnZlcnNpb24gLT4gXCIwYlwiIF4gU2Nhbm5pbmcudG9rZW4gaWIgaW5cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHRvayBpblxuICBpZiBsID0gMCB8fCB0b2suWzBdIDw+ICcrJyB0aGVuIHRvayBlbHNlIFN0cmluZy5zdWIgdG9rIDEgKGwgLSAxKVxuXG5cbigqIEFsbCB0aGUgZnVuY3Rpb25zIHRoYXQgY29udmVydCBhIHN0cmluZyB0byBhIG51bWJlciByYWlzZSB0aGUgZXhjZXB0aW9uXG4gICBGYWlsdXJlIHdoZW4gdGhlIGNvbnZlcnNpb24gaXMgbm90IHBvc3NpYmxlLlxuICAgVGhpcyBleGNlcHRpb24gaXMgdGhlbiB0cmFwcGVkIGluIFtrc2NhbmZdLiAqKVxubGV0IHRva2VuX2ludCBjb252IGliID0gaW50X29mX3N0cmluZyAodG9rZW5faW50X2xpdGVyYWwgY29udiBpYilcblxubGV0IHRva2VuX2Zsb2F0IGliID0gZmxvYXRfb2Zfc3RyaW5nIChTY2FubmluZy50b2tlbiBpYilcblxuKCogVG8gc2NhbiBuYXRpdmUgaW50cywgaW50MzIgYW5kIGludDY0IGludGVnZXJzLlxuICAgV2UgY2Fubm90IGFjY2VzcyB0byBjb252ZXJzaW9ucyB0by9mcm9tIHN0cmluZ3MgZm9yIHRob3NlIHR5cGVzLFxuICAgTmF0aXZlaW50Lm9mX3N0cmluZywgSW50MzIub2Zfc3RyaW5nLCBhbmQgSW50NjQub2Zfc3RyaW5nLFxuICAgc2luY2UgdGhvc2UgbW9kdWxlcyBhcmUgbm90IGF2YWlsYWJsZSB0byBbU2NhbmZdLlxuICAgSG93ZXZlciwgd2UgY2FuIGJpbmQgYW5kIHVzZSB0aGUgY29ycmVzcG9uZGluZyBwcmltaXRpdmVzIHRoYXQgYXJlXG4gICBhdmFpbGFibGUgaW4gdGhlIHJ1bnRpbWUuICopXG5leHRlcm5hbCBuYXRpdmVpbnRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IG5hdGl2ZWludFxuICA9IFwiY2FtbF9uYXRpdmVpbnRfb2Zfc3RyaW5nXCJcblxuZXh0ZXJuYWwgaW50MzJfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludDMyXG4gID0gXCJjYW1sX2ludDMyX29mX3N0cmluZ1wiXG5cbmV4dGVybmFsIGludDY0X29mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQ2NFxuICA9IFwiY2FtbF9pbnQ2NF9vZl9zdHJpbmdcIlxuXG5cbmxldCB0b2tlbl9uYXRpdmVpbnQgY29udiBpYiA9IG5hdGl2ZWludF9vZl9zdHJpbmcgKHRva2VuX2ludF9saXRlcmFsIGNvbnYgaWIpXG5sZXQgdG9rZW5faW50MzIgY29udiBpYiA9IGludDMyX29mX3N0cmluZyAodG9rZW5faW50X2xpdGVyYWwgY29udiBpYilcbmxldCB0b2tlbl9pbnQ2NCBjb252IGliID0gaW50NjRfb2Zfc3RyaW5nICh0b2tlbl9pbnRfbGl0ZXJhbCBjb252IGliKVxuXG4oKiBTY2FubmluZyBudW1iZXJzLiAqKVxuXG4oKiBEaWdpdHMgc2Nhbm5pbmcgZnVuY3Rpb25zIHN1cHBvc2UgdGhhdCBvbmUgY2hhcmFjdGVyIGhhcyBiZWVuIGNoZWNrZWQgYW5kXG4gICBpcyBhdmFpbGFibGUsIHNpbmNlIHRoZXkgcmV0dXJuIGF0IGVuZCBvZiBmaWxlIHdpdGggdGhlIGN1cnJlbnRseSBmb3VuZFxuICAgdG9rZW4gc2VsZWN0ZWQuXG5cbiAgIFB1dCBpdCBpbiBhbm90aGVyIHdheSwgdGhlIGRpZ2l0cyBzY2FubmluZyBmdW5jdGlvbnMgc2NhbiBmb3IgYSBwb3NzaWJseVxuICAgZW1wdHkgc2VxdWVuY2Ugb2YgZGlnaXRzLCAoaGVuY2UsIGEgc3VjY2Vzc2Z1bCBzY2FubmluZyBmcm9tIG9uZSBvZiB0aG9zZVxuICAgZnVuY3Rpb25zIGRvZXMgbm90IGltcGx5IHRoYXQgdGhlIHRva2VuIGlzIGEgd2VsbC1mb3JtZWQgbnVtYmVyOiB0byBnZXQgYVxuICAgdHJ1ZSBudW1iZXIsIGl0IGlzIG1hbmRhdG9yeSB0byBjaGVjayB0aGF0IGF0IGxlYXN0IG9uZSB2YWxpZCBkaWdpdCBpc1xuICAgYXZhaWxhYmxlIGJlZm9yZSBjYWxsaW5nIG9uZSBvZiB0aGUgZGlnaXQgc2Nhbm5pbmcgZnVuY3Rpb25zKS4gKilcblxuKCogVGhlIGRlY2ltYWwgY2FzZSBpcyB0cmVhdGVkIGVzcGVjaWFsbHkgZm9yIG9wdGltaXphdGlvbiBwdXJwb3Nlcy4gKilcbmxldCByZWMgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJzAnIC4uICc5JyBhcyBjIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWJcbiAgfCAnXycgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYiBpblxuICAgIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliXG4gIHwgXyAtPiB3aWR0aFxuXG5cbmxldCBzY2FuX2RlY2ltYWxfZGlnaXRfcGx1cyB3aWR0aCBpYiA9XG4gIGlmIHdpZHRoID0gMCB0aGVuIGJhZF90b2tlbl9sZW5ndGggXCJkZWNpbWFsIGRpZ2l0c1wiIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBtYXRjaCBjIHdpdGhcbiAgfCAnMCcgLi4gJzknIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWJcbiAgfCBjIC0+XG4gICAgYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcImNoYXJhY3RlciAlQyBpcyBub3QgYSBkZWNpbWFsIGRpZ2l0XCIgYylcblxuXG4oKiBUbyBzY2FuIG51bWJlcnMgZnJvbSBvdGhlciBiYXNlcywgd2UgdXNlIGEgcHJlZGljYXRlIGFyZ3VtZW50IHRvXG4gICBzY2FuIGRpZ2l0cy4gKilcbmxldCBzY2FuX2RpZ2l0X3N0YXIgZGlnaXRwIHdpZHRoIGliID1cbiAgbGV0IHJlYyBzY2FuX2RpZ2l0cyB3aWR0aCBpYiA9XG4gICAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICAgIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGggZWxzZVxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgYyB3aGVuIGRpZ2l0cCBjIC0+XG4gICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgIHNjYW5fZGlnaXRzIHdpZHRoIGliXG4gICAgfCAnXycgLT5cbiAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliIGluXG4gICAgICBzY2FuX2RpZ2l0cyB3aWR0aCBpYlxuICAgIHwgXyAtPiB3aWR0aCBpblxuICBzY2FuX2RpZ2l0cyB3aWR0aCBpYlxuXG5cbmxldCBzY2FuX2RpZ2l0X3BsdXMgYmFzaXMgZGlnaXRwIHdpZHRoIGliID1cbiAgKCogRW5zdXJlIHdlIGhhdmUgZ290IGVub3VnaCB3aWR0aCBsZWZ0LFxuICAgICBhbmQgcmVhZCBhdCBsZWFzdCBvbmUgZGlnaXQuICopXG4gIGlmIHdpZHRoID0gMCB0aGVuIGJhZF90b2tlbl9sZW5ndGggXCJkaWdpdHNcIiBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgaWYgZGlnaXRwIGMgdGhlblxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIHNjYW5fZGlnaXRfc3RhciBkaWdpdHAgd2lkdGggaWJcbiAgZWxzZVxuICAgIGJhZF9pbnB1dCAoUHJpbnRmLnNwcmludGYgXCJjaGFyYWN0ZXIgJUMgaXMgbm90IGEgdmFsaWQgJXMgZGlnaXRcIiBjIGJhc2lzKVxuXG5cbmxldCBpc19iaW5hcnlfZGlnaXQgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnMScgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxuXG5sZXQgc2Nhbl9iaW5hcnlfaW50ID0gc2Nhbl9kaWdpdF9wbHVzIFwiYmluYXJ5XCIgaXNfYmluYXJ5X2RpZ2l0XG5cbmxldCBpc19vY3RhbF9kaWdpdCA9IGZ1bmN0aW9uXG4gIHwgJzAnIC4uICc3JyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuXG5cbmxldCBzY2FuX29jdGFsX2ludCA9IHNjYW5fZGlnaXRfcGx1cyBcIm9jdGFsXCIgaXNfb2N0YWxfZGlnaXRcblxubGV0IGlzX2hleGFfZGlnaXQgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnOScgfCAnYScgLi4gJ2YnIHwgJ0EnIC4uICdGJyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuXG5cbmxldCBzY2FuX2hleGFkZWNpbWFsX2ludCA9IHNjYW5fZGlnaXRfcGx1cyBcImhleGFkZWNpbWFsXCIgaXNfaGV4YV9kaWdpdFxuXG4oKiBTY2FuIGEgZGVjaW1hbCBpbnRlZ2VyLiAqKVxubGV0IHNjYW5fdW5zaWduZWRfZGVjaW1hbF9pbnQgPSBzY2FuX2RlY2ltYWxfZGlnaXRfcGx1c1xuXG5sZXQgc2Nhbl9zaWduIHdpZHRoIGliID1cbiAgbGV0IGMgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBtYXRjaCBjIHdpdGhcbiAgfCAnKycgLT4gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjXG4gIHwgJy0nIC0+IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgY1xuICB8IF8gLT4gd2lkdGhcblxuXG5sZXQgc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYiA9XG4gIGxldCB3aWR0aCA9IHNjYW5fc2lnbiB3aWR0aCBpYiBpblxuICBzY2FuX3Vuc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG5cblxuKCogU2NhbiBhbiB1bnNpZ25lZCBpbnRlZ2VyIHRoYXQgY291bGQgYmUgZ2l2ZW4gaW4gYW55IChjb21tb24pIGJhc2lzLlxuICAgSWYgZGlnaXRzIGFyZSBwcmVmaXhlZCBieSBvbmUgb2YgMHgsIDBYLCAwbywgb3IgMGIsIHRoZSBudW1iZXIgaXNcbiAgIGFzc3VtZWQgdG8gYmUgd3JpdHRlbiByZXNwZWN0aXZlbHkgaW4gaGV4YWRlY2ltYWwsIGhleGFkZWNpbWFsLFxuICAgb2N0YWwsIG9yIGJpbmFyeS4gKilcbmxldCBzY2FuX3Vuc2lnbmVkX2ludCB3aWR0aCBpYiA9XG4gIG1hdGNoIFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIHdpdGhcbiAgfCAnMCcgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICBiZWdpbiBtYXRjaCBjIHdpdGhcbiAgICB8ICd4JyB8ICdYJyAtPiBzY2FuX2hleGFkZWNpbWFsX2ludCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpYlxuICAgIHwgJ28nIC0+IHNjYW5fb2N0YWxfaW50IChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGliXG4gICAgfCAnYicgLT4gc2Nhbl9iaW5hcnlfaW50IChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGliXG4gICAgfCBfIC0+IHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliIGVuZFxuICB8IF8gLT4gc2Nhbl91bnNpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuXG5cbmxldCBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2ludCB3aWR0aCBpYiA9XG4gIGxldCB3aWR0aCA9IHNjYW5fc2lnbiB3aWR0aCBpYiBpblxuICBzY2FuX3Vuc2lnbmVkX2ludCB3aWR0aCBpYlxuXG5cbmxldCBzY2FuX2ludF9jb252ZXJzaW9uIGNvbnYgd2lkdGggaWIgPVxuICBtYXRjaCBjb252IHdpdGhcbiAgfCBCX2NvbnZlcnNpb24gLT4gc2Nhbl9iaW5hcnlfaW50IHdpZHRoIGliXG4gIHwgRF9jb252ZXJzaW9uIC0+IHNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcbiAgfCBJX2NvbnZlcnNpb24gLT4gc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9pbnQgd2lkdGggaWJcbiAgfCBPX2NvbnZlcnNpb24gLT4gc2Nhbl9vY3RhbF9pbnQgd2lkdGggaWJcbiAgfCBVX2NvbnZlcnNpb24gLT4gc2Nhbl91bnNpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuICB8IFhfY29udmVyc2lvbiAtPiBzY2FuX2hleGFkZWNpbWFsX2ludCB3aWR0aCBpYlxuXG5cbigqIFNjYW5uaW5nIGZsb2F0aW5nIHBvaW50IG51bWJlcnMuICopXG5cbigqIEZyYWN0aW9uYWwgcGFydCBpcyBvcHRpb25hbCBhbmQgY2FuIGJlIHJlZHVjZWQgdG8gMCBkaWdpdHMuICopXG5sZXQgc2Nhbl9mcmFjdGlvbmFsX3BhcnQgd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJzAnIC4uICc5JyBhcyBjIC0+XG4gICAgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaWJcbiAgfCBfIC0+IHdpZHRoXG5cblxuKCogRXhwIHBhcnQgaXMgb3B0aW9uYWwgYW5kIGNhbiBiZSByZWR1Y2VkIHRvIDAgZGlnaXRzLiAqKVxubGV0IHNjYW5fZXhwb25lbnRfcGFydCB3aWR0aCBpYiA9XG4gIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGggZWxzZVxuICBtYXRjaCBjIHdpdGhcbiAgfCAnZScgfCAnRScgYXMgYyAtPlxuICAgIHNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaWJcbiAgfCBfIC0+IHdpZHRoXG5cblxuKCogU2NhbiB0aGUgaW50ZWdlciBwYXJ0IG9mIGEgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLCAobm90IHVzaW5nIHRoZVxuICAgT0NhbWwgbGV4aWNhbCBjb252ZW50aW9uIHNpbmNlIHRoZSBpbnRlZ2VyIHBhcnQgY2FuIGJlIGVtcHR5KTpcbiAgIGFuIG9wdGlvbmFsIHNpZ24sIGZvbGxvd2VkIGJ5IGEgcG9zc2libHkgZW1wdHkgc2VxdWVuY2Ugb2YgZGVjaW1hbFxuICAgZGlnaXRzIChlLmcuIC0uMSkuICopXG5sZXQgc2Nhbl9pbnRlZ2VyX3BhcnQgd2lkdGggaWIgPVxuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWJcblxuXG4oKlxuICAgRm9yIHRoZSB0aW1lIGJlaW5nIHdlIGhhdmUgKGFzIGZvdW5kIGluIHNjYW5mLm1saSk6XG4gICB0aGUgZmllbGQgd2lkdGggaXMgY29tcG9zZWQgb2YgYW4gb3B0aW9uYWwgaW50ZWdlciBsaXRlcmFsXG4gICBpbmRpY2F0aW5nIHRoZSBtYXhpbWFsIHdpZHRoIG9mIHRoZSB0b2tlbiB0byByZWFkLlxuICAgVW5mb3J0dW5hdGVseSwgdGhlIHR5cGUtY2hlY2tlciBsZXQgdGhlIHVzZXIgd3JpdGUgYW4gb3B0aW9uYWwgcHJlY2lzaW9uLFxuICAgc2luY2UgdGhpcyBpcyB2YWxpZCBmb3IgcHJpbnRmIGZvcm1hdCBzdHJpbmdzLlxuXG4gICBUaHVzLCB0aGUgbmV4dCBzdGVwIGZvciBTY2FuZiBpcyB0byBzdXBwb3J0IGEgZnVsbCB3aWR0aCBhbmQgcHJlY2lzaW9uXG4gICBpbmRpY2F0aW9uLCBtb3JlIG9yIGxlc3Mgc2ltaWxhciB0byB0aGUgb25lIGZvciBwcmludGYsIHBvc3NpYmx5IGV4dGVuZGVkXG4gICB0byB0aGUgc3BlY2lmaWNhdGlvbiBvZiBhIFttYXgsIG1pbl0gcmFuZ2UgZm9yIHRoZSB3aWR0aCBvZiB0aGUgdG9rZW4gcmVhZFxuICAgZm9yIHN0cmluZ3MuIFNvbWV0aGluZyBsaWtlIHRoZSBmb2xsb3dpbmcgc3BlYyBmb3Igc2NhbmYubWxpOlxuXG4gICBUaGUgb3B0aW9uYWwgW3dpZHRoXSBpcyBhbiBpbnRlZ2VyIGluZGljYXRpbmcgdGhlIG1heGltYWxcbiAgIHdpZHRoIG9mIHRoZSB0b2tlbiByZWFkLiBGb3IgaW5zdGFuY2UsIFslNmRdIHJlYWRzIGFuIGludGVnZXIsXG4gICBoYXZpbmcgYXQgbW9zdCA2IGNoYXJhY3RlcnMuXG5cbiAgIFRoZSBvcHRpb25hbCBbcHJlY2lzaW9uXSBpcyBhIGRvdCBbLl0gZm9sbG93ZWQgYnkgYW4gaW50ZWdlcjpcblxuICAgLSBpbiB0aGUgZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGNvbnZlcnNpb25zIChbJWZdLCBbJWVdLCBbJWddLCBbJUZdLCBbJUVdLFxuICAgYW5kIFslRl0gY29udmVyc2lvbnMsIHRoZSBbcHJlY2lzaW9uXSBpbmRpY2F0ZXMgdGhlIG1heGltdW0gbnVtYmVyIG9mXG4gICBkaWdpdHMgdGhhdCBtYXkgZm9sbG93IHRoZSBkZWNpbWFsIHBvaW50LiBGb3IgaW5zdGFuY2UsIFslLjRmXSByZWFkcyBhXG4gICBbZmxvYXRdIHdpdGggYXQgbW9zdCA0IGZyYWN0aW9uYWwgZGlnaXRzLFxuXG4gICAtIGluIHRoZSBzdHJpbmcgY29udmVyc2lvbnMgKFslc10sIFslU10sIFslXFxbIHJhbmdlIFxcXV0pLCBhbmQgaW4gdGhlXG4gICBpbnRlZ2VyIG51bWJlciBjb252ZXJzaW9ucyAoWyVpXSwgWyVkXSwgWyV1XSwgWyV4XSwgWyVvXSwgYW5kIHRoZWlyXG4gICBbaW50MzJdLCBbaW50NjRdLCBhbmQgW25hdGl2ZV9pbnRdIGNvcnJlc3BvbmRlbnQpLCB0aGUgW3ByZWNpc2lvbl1cbiAgIGluZGljYXRlcyB0aGUgcmVxdWlyZWQgbWluaW11bSB3aWR0aCBvZiB0aGUgdG9rZW4gcmVhZCxcblxuICAgLSBvbiBhbGwgb3RoZXIgY29udmVyc2lvbnMsIHRoZSB3aWR0aCBhbmQgcHJlY2lzaW9uIHNwZWNpZnkgdGhlIFttYXgsIG1pbl1cbiAgIHJhbmdlIGZvciB0aGUgd2lkdGggb2YgdGhlIHRva2VuIHJlYWQuXG4qKVxubGV0IHNjYW5fZmxvYXQgd2lkdGggcHJlY2lzaW9uIGliID1cbiAgbGV0IHdpZHRoID0gc2Nhbl9pbnRlZ2VyX3BhcnQgd2lkdGggaWIgaW5cbiAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGgsIHByZWNpc2lvbiBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoLCBwcmVjaXNpb24gZWxzZVxuICBtYXRjaCBjIHdpdGhcbiAgfCAnLicgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBsZXQgcHJlY2lzaW9uID0gbWluIHdpZHRoIHByZWNpc2lvbiBpblxuICAgIGxldCB3aWR0aCA9IHdpZHRoIC0gKHByZWNpc2lvbiAtIHNjYW5fZnJhY3Rpb25hbF9wYXJ0IHByZWNpc2lvbiBpYikgaW5cbiAgICBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWIsIHByZWNpc2lvblxuICB8IF8gLT5cbiAgICBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWIsIHByZWNpc2lvblxuXG5cbmxldCBjaGVja19jYXNlX2luc2Vuc2l0aXZlX3N0cmluZyB3aWR0aCBpYiBlcnJvciBzdHIgPVxuICBsZXQgbG93ZXJjYXNlIGMgPVxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgJ0EnIC4uICdaJyAtPlxuICAgICAgY2hhcl9vZl9pbnQgKGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnQScgKyBpbnRfb2ZfY2hhciAnYScpXG4gICAgfCBfIC0+IGMgaW5cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIGxldCB3aWR0aCA9IHJlZiB3aWR0aCBpblxuICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgaWYgbG93ZXJjYXNlIGMgPD4gbG93ZXJjYXNlIHN0ci5baV0gdGhlbiBlcnJvciAoKTtcbiAgICBpZiAhd2lkdGggPSAwIHRoZW4gZXJyb3IgKCk7XG4gICAgd2lkdGggOj0gU2Nhbm5pbmcuc3RvcmVfY2hhciAhd2lkdGggaWIgYztcbiAgZG9uZTtcbiAgIXdpZHRoXG5cblxubGV0IHNjYW5faGV4X2Zsb2F0IHdpZHRoIHByZWNpc2lvbiBpYiA9XG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gIHwgJzAnIGFzIGMgLT4gKFxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICAgIGxldCB3aWR0aCA9IGNoZWNrX2Nhc2VfaW5zZW5zaXRpdmVfc3RyaW5nIHdpZHRoIGliIGJhZF9oZXhfZmxvYXQgXCJ4XCIgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgbGV0IHdpZHRoID0gbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgfCAnLicgfCAncCcgfCAnUCcgLT4gd2lkdGhcbiAgICAgICAgfCBfIC0+IHNjYW5faGV4YWRlY2ltYWxfaW50IHdpZHRoIGliIGluXG4gICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICBsZXQgd2lkdGggPSBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICAgIHwgJy4nIGFzIGMgLT4gKFxuICAgICAgICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICAgICAgICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICAgICAgICB8ICdwJyB8ICdQJyAtPiB3aWR0aFxuICAgICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgICBsZXQgcHJlY2lzaW9uID0gbWluIHdpZHRoIHByZWNpc2lvbiBpblxuICAgICAgICAgICAgICAgIHdpZHRoIC0gKHByZWNpc2lvbiAtIHNjYW5faGV4YWRlY2ltYWxfaW50IHByZWNpc2lvbiBpYilcbiAgICAgICAgICApXG4gICAgICAgICAgfCBfIC0+IHdpZHRoIGluXG4gICAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICAgICAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgICB8ICdwJyB8ICdQJyBhcyBjIC0+XG4gICAgICAgICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgICAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICAgICAgICAgICAgc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuICAgICAgICAgIHwgXyAtPiB3aWR0aFxuICApXG4gIHwgJ24nIHwgJ04nIGFzIGMgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICBjaGVja19jYXNlX2luc2Vuc2l0aXZlX3N0cmluZyB3aWR0aCBpYiBiYWRfaGV4X2Zsb2F0IFwiYW5cIlxuICB8ICdpJyB8ICdJJyBhcyBjIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gICAgY2hlY2tfY2FzZV9pbnNlbnNpdGl2ZV9zdHJpbmcgd2lkdGggaWIgYmFkX2hleF9mbG9hdCBcIm5maW5pdHlcIlxuICB8IF8gLT4gYmFkX2hleF9mbG9hdCAoKVxuXG5cbmxldCBzY2FuX2NhbWxfZmxvYXRfcmVzdCB3aWR0aCBwcmVjaXNpb24gaWIgPVxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICBsZXQgd2lkdGggPSBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYiBpblxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBtYXRjaCBjIHdpdGhcbiAgfCAnLicgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAoKiBUaGUgZWZmZWN0aXZlIHdpZHRoIGF2YWlsYWJsZSBmb3Igc2Nhbm5pbmcgdGhlIGZyYWN0aW9uYWwgcGFydCBpc1xuICAgICAgIHRoZSBtaW5pbXVtIG9mIGRlY2xhcmVkIHByZWNpc2lvbiBhbmQgd2lkdGggbGVmdC4gKilcbiAgICBsZXQgcHJlY2lzaW9uID0gbWluIHdpZHRoIHByZWNpc2lvbiBpblxuICAgICgqIEFmdGVyIHNjYW5uaW5nIHRoZSBmcmFjdGlvbmFsIHBhcnQgd2l0aCBbcHJlY2lzaW9uXSBwcm92aXNpb25hbCB3aWR0aCxcbiAgICAgICBbd2lkdGhfcHJlY2lzaW9uXSBpcyBsZWZ0LiAqKVxuICAgIGxldCB3aWR0aF9wcmVjaXNpb24gPSBzY2FuX2ZyYWN0aW9uYWxfcGFydCBwcmVjaXNpb24gaWIgaW5cbiAgICAoKiBIZW5jZSwgc2Nhbm5pbmcgdGhlIGZyYWN0aW9uYWwgcGFydCB0b29rIGV4YWN0bHlcbiAgICAgICBbcHJlY2lzaW9uIC0gd2lkdGhfcHJlY2lzaW9uXSBjaGFycy4gKilcbiAgICBsZXQgZnJhY193aWR0aCA9IHByZWNpc2lvbiAtIHdpZHRoX3ByZWNpc2lvbiBpblxuICAgICgqIEFuZCBuZXcgcHJvdmlzaW9uYWwgd2lkdGggaXMgW3dpZHRoIC0gd2lkdGhfcHJlY2lzaW9uLiAqKVxuICAgIGxldCB3aWR0aCA9IHdpZHRoIC0gZnJhY193aWR0aCBpblxuICAgIHNjYW5fZXhwb25lbnRfcGFydCB3aWR0aCBpYlxuICB8ICdlJyB8ICdFJyAtPlxuICAgIHNjYW5fZXhwb25lbnRfcGFydCB3aWR0aCBpYlxuICB8IF8gLT4gYmFkX2Zsb2F0ICgpXG5cblxubGV0IHNjYW5fY2FtbF9mbG9hdCB3aWR0aCBwcmVjaXNpb24gaWIgPVxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgfCAnMCcgYXMgYyAtPiAoXG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgIHwgJ3gnIHwgJ1gnIGFzIGMgLT4gKFxuICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICAgICAgbGV0IHdpZHRoID0gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgd2lkdGggaWIgaW5cbiAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gICAgICBsZXQgd2lkdGggPSBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICB8ICcuJyBhcyBjIC0+IChcbiAgICAgICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICAgICAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgICAgIHwgJ3AnIHwgJ1AnIC0+IHdpZHRoXG4gICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgbGV0IHByZWNpc2lvbiA9IG1pbiB3aWR0aCBwcmVjaXNpb24gaW5cbiAgICAgICAgICAgICAgd2lkdGggLSAocHJlY2lzaW9uIC0gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgcHJlY2lzaW9uIGliKVxuICAgICAgICApXG4gICAgICAgIHwgJ3AnIHwgJ1AnIC0+IHdpZHRoXG4gICAgICAgIHwgXyAtPiBiYWRfZmxvYXQgKCkgaW5cbiAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICAgIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgIHwgJ3AnIHwgJ1AnIGFzIGMgLT5cbiAgICAgICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICAgICAgICBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG4gICAgICAgIHwgXyAtPiB3aWR0aFxuICAgIClcbiAgICB8IF8gLT5cbiAgICAgIHNjYW5fY2FtbF9mbG9hdF9yZXN0IHdpZHRoIHByZWNpc2lvbiBpYlxuICApXG4gIHwgJzEnIC4uICc5JyBhcyBjIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgICBzY2FuX2NhbWxfZmxvYXRfcmVzdCB3aWR0aCBwcmVjaXNpb24gaWJcbigqIFNwZWNpYWwgY2FzZSBvZiBuYW4gYW5kIGluZmluaXR5OlxuICB8ICdpJyAtPlxuICB8ICduJyAtPlxuKilcbiAgfCBfIC0+IGJhZF9mbG9hdCAoKVxuXG5cbigqIFNjYW4gYSByZWd1bGFyIHN0cmluZzpcbiAgIHN0b3BzIHdoZW4gZW5jb3VudGVyaW5nIGEgc3BhY2UsIGlmIG5vIHNjYW5uaW5nIGluZGljYXRpb24gaGFzIGJlZW4gZ2l2ZW47XG4gICBvdGhlcndpc2UsIHN0b3BzIHdoZW4gZW5jb3VudGVyaW5nIHRoZSBjaGFyYWN0ZXJzIGluIHRoZSBzY2FubmluZ1xuICAgaW5kaWNhdGlvbiBbc3RwXS5cbiAgIEl0IGFsc28gc3RvcHMgYXQgZW5kIG9mIGZpbGUgb3Igd2hlbiB0aGUgbWF4aW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyBoYXNcbiAgIGJlZW4gcmVhZC4gKilcbmxldCBzY2FuX3N0cmluZyBzdHAgd2lkdGggaWIgPVxuICBsZXQgcmVjIGxvb3Agd2lkdGggPVxuICAgIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgIG1hdGNoIHN0cCB3aXRoXG4gICAgICB8IFNvbWUgYycgd2hlbiBjID0gYycgLT4gU2Nhbm5pbmcuc2tpcF9jaGFyIHdpZHRoIGliXG4gICAgICB8IFNvbWUgXyAtPiBsb29wIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgbWF0Y2ggYyB3aXRoXG4gICAgICAgIHwgJyAnIHwgJ1xcdCcgfCAnXFxuJyB8ICdcXHInIC0+IHdpZHRoXG4gICAgICAgIHwgXyAtPiBsb29wIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGluXG4gIGxvb3Agd2lkdGhcblxuXG4oKiBTY2FuIGEgY2hhcjogcGVlayBzdHJpY3RseSBvbmUgY2hhcmFjdGVyIGluIHRoZSBpbnB1dCwgd2hhdHNvZXZlci4gKilcbmxldCBzY2FuX2NoYXIgd2lkdGggaWIgPVxuICAoKiBUaGUgY2FzZSB3aWR0aCA9IDAgY291bGQgbm90IGhhcHBlbiBoZXJlLCBzaW5jZSBpdCBpcyB0ZXN0ZWQgYmVmb3JlXG4gICAgIGNhbGxpbmcgc2Nhbl9jaGFyLCBpbiB0aGUgbWFpbiBzY2FubmluZyBmdW5jdGlvbi5cbiAgICBpZiB3aWR0aCA9IDAgdGhlbiBiYWRfdG9rZW5fbGVuZ3RoIFwiYSBjaGFyYWN0ZXJcIiBlbHNlICopXG4gIFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgKFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliKVxuXG5cbmxldCBjaGFyX2Zvcl9iYWNrc2xhc2ggPSBmdW5jdGlvblxuICB8ICduJyAtPiAnXFwwMTAnXG4gIHwgJ3InIC0+ICdcXDAxMydcbiAgfCAnYicgLT4gJ1xcMDA4J1xuICB8ICd0JyAtPiAnXFwwMDknXG4gIHwgYyAtPiBjXG5cblxuKCogVGhlIGludGVnZXIgdmFsdWUgY29ycmVzcG9uZGluZyB0byB0aGUgZmFjaWFsIHZhbHVlIG9mIGEgdmFsaWRcbiAgIGRlY2ltYWwgZGlnaXQgY2hhcmFjdGVyLiAqKVxubGV0IGRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjID0gaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICcwJ1xuXG5sZXQgY2hhcl9mb3JfZGVjaW1hbF9jb2RlIGMwIGMxIGMyID1cbiAgbGV0IGMgPVxuICAgIDEwMCAqIGRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMCArXG4gICAgIDEwICogZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMxICtcbiAgICAgICAgICBkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYzIgaW5cbiAgaWYgYyA8IDAgfHwgYyA+IDI1NSB0aGVuXG4gICAgYmFkX2lucHV0XG4gICAgICAoUHJpbnRmLnNwcmludGZcbiAgICAgICAgIFwiYmFkIGNoYXJhY3RlciBkZWNpbWFsIGVuY29kaW5nIFxcXFwlYyVjJWNcIiBjMCBjMSBjMikgZWxzZVxuICBjaGFyX29mX2ludCBjXG5cblxuKCogVGhlIGludGVnZXIgdmFsdWUgY29ycmVzcG9uZGluZyB0byB0aGUgZmFjaWFsIHZhbHVlIG9mIGEgdmFsaWRcbiAgIGhleGFkZWNpbWFsIGRpZ2l0IGNoYXJhY3Rlci4gKilcbmxldCBoZXhhZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMgPVxuICBsZXQgZCA9IGludF9vZl9jaGFyIGMgaW5cbiAgKCogQ291bGQgYWxzbyBiZTpcbiAgICBpZiBkIDw9IGludF9vZl9jaGFyICc5JyB0aGVuIGQgLSBpbnRfb2ZfY2hhciAnMCcgZWxzZVxuICAgIGlmIGQgPD0gaW50X29mX2NoYXIgJ0YnIHRoZW4gMTAgKyBkIC0gaW50X29mX2NoYXIgJ0EnIGVsc2VcbiAgICBpZiBkIDw9IGludF9vZl9jaGFyICdmJyB0aGVuIDEwICsgZCAtIGludF9vZl9jaGFyICdhJyBlbHNlIGFzc2VydCBmYWxzZVxuICAqKVxuICBpZiBkID49IGludF9vZl9jaGFyICdhJyB0aGVuXG4gICAgZCAtIDg3ICgqIDEwICsgaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICdhJyAqKSBlbHNlXG4gIGlmIGQgPj0gaW50X29mX2NoYXIgJ0EnIHRoZW5cbiAgICBkIC0gNTUgICgqIDEwICsgaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICdBJyAqKSBlbHNlXG4gICAgZCAtIGludF9vZl9jaGFyICcwJ1xuXG5cbmxldCBjaGFyX2Zvcl9oZXhhZGVjaW1hbF9jb2RlIGMxIGMyID1cbiAgbGV0IGMgPVxuICAgIDE2ICogaGV4YWRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMSArXG4gICAgICAgICBoZXhhZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMyIGluXG4gIGlmIGMgPCAwIHx8IGMgPiAyNTUgdGhlblxuICAgIGJhZF9pbnB1dFxuICAgICAgKFByaW50Zi5zcHJpbnRmIFwiYmFkIGNoYXJhY3RlciBoZXhhZGVjaW1hbCBlbmNvZGluZyBcXFxcJWMlY1wiIGMxIGMyKSBlbHNlXG4gIGNoYXJfb2ZfaW50IGNcblxuXG4oKiBDYWxsZWQgaW4gcGFydGljdWxhciB3aGVuIGVuY291bnRlcmluZyAnXFxcXCcgYXMgc3RhcnRlciBvZiBhIGNoYXIuXG4gICBTdG9wcyBiZWZvcmUgdGhlIGNvcnJlc3BvbmRpbmcgJ1xcJycuICopXG5sZXQgY2hlY2tfbmV4dF9jaGFyIG1lc3NhZ2Ugd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiBiYWRfdG9rZW5fbGVuZ3RoIG1lc3NhZ2UgZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiBiYWRfZW5kX29mX2lucHV0IG1lc3NhZ2UgZWxzZVxuICBjXG5cblxubGV0IGNoZWNrX25leHRfY2hhcl9mb3JfY2hhciA9IGNoZWNrX25leHRfY2hhciBcImEgQ2hhclwiXG5sZXQgY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmcgPSBjaGVja19uZXh0X2NoYXIgXCJhIFN0cmluZ1wiXG5cbmxldCBzY2FuX2JhY2tzbGFzaF9jaGFyIHdpZHRoIGliID1cbiAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9jaGFyIHdpZHRoIGliIHdpdGhcbiAgfCAnXFxcXCcgfCAnXFwnJyB8ICdcXFwiJyB8ICduJyB8ICd0JyB8ICdiJyB8ICdyJyBhcyBjIC0+XG4gICAgU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiAoY2hhcl9mb3JfYmFja3NsYXNoIGMpXG4gIHwgJzAnIC4uICc5JyBhcyBjIC0+XG4gICAgbGV0IGdldF9kaWdpdCAoKSA9XG4gICAgICBsZXQgYyA9IFNjYW5uaW5nLm5leHRfY2hhciBpYiBpblxuICAgICAgbWF0Y2ggYyB3aXRoXG4gICAgICB8ICcwJyAuLiAnOScgYXMgYyAtPiBjXG4gICAgICB8IGMgLT4gYmFkX2lucHV0X2VzY2FwZSBjIGluXG4gICAgbGV0IGMwID0gYyBpblxuICAgIGxldCBjMSA9IGdldF9kaWdpdCAoKSBpblxuICAgIGxldCBjMiA9IGdldF9kaWdpdCAoKSBpblxuICAgIFNjYW5uaW5nLnN0b3JlX2NoYXIgKHdpZHRoIC0gMikgaWIgKGNoYXJfZm9yX2RlY2ltYWxfY29kZSBjMCBjMSBjMilcbiAgfCAneCcgLT5cbiAgICBsZXQgZ2V0X2RpZ2l0ICgpID1cbiAgICAgIGxldCBjID0gU2Nhbm5pbmcubmV4dF9jaGFyIGliIGluXG4gICAgICBtYXRjaCBjIHdpdGhcbiAgICAgIHwgJzAnIC4uICc5JyB8ICdBJyAuLiAnRicgfCAnYScgLi4gJ2YnIGFzIGMgLT4gY1xuICAgICAgfCBjIC0+IGJhZF9pbnB1dF9lc2NhcGUgYyBpblxuICAgIGxldCBjMSA9IGdldF9kaWdpdCAoKSBpblxuICAgIGxldCBjMiA9IGdldF9kaWdpdCAoKSBpblxuICAgIFNjYW5uaW5nLnN0b3JlX2NoYXIgKHdpZHRoIC0gMikgaWIgKGNoYXJfZm9yX2hleGFkZWNpbWFsX2NvZGUgYzEgYzIpXG4gIHwgYyAtPlxuICAgIGJhZF9pbnB1dF9lc2NhcGUgY1xuXG5cbigqIFNjYW4gYSBjaGFyYWN0ZXIgKGFuIE9DYW1sIHRva2VuKS4gKilcbmxldCBzY2FuX2NhbWxfY2hhciB3aWR0aCBpYiA9XG5cbiAgbGV0IHJlYyBmaW5kX3N0YXJ0IHdpZHRoID1cbiAgICBtYXRjaCBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiB3aXRoXG4gICAgfCAnXFwnJyAtPiBmaW5kX2NoYXIgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgYyAtPiBjaGFyYWN0ZXJfbWlzbWF0Y2ggJ1xcJycgY1xuXG4gIGFuZCBmaW5kX2NoYXIgd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3JfY2hhciB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFxcXCcgLT5cbiAgICAgIGZpbmRfc3RvcCAoc2Nhbl9iYWNrc2xhc2hfY2hhciAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpIGliKVxuICAgIHwgYyAtPlxuICAgICAgZmluZF9zdG9wIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpXG5cbiAgYW5kIGZpbmRfc3RvcCB3aWR0aCA9XG4gICAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9jaGFyIHdpZHRoIGliIHdpdGhcbiAgICB8ICdcXCcnIC0+IFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliXG4gICAgfCBjIC0+IGNoYXJhY3Rlcl9taXNtYXRjaCAnXFwnJyBjIGluXG5cbiAgZmluZF9zdGFydCB3aWR0aFxuXG5cbigqIFNjYW4gYSBkZWxpbWl0ZWQgc3RyaW5nIChhbiBPQ2FtbCB0b2tlbikuICopXG5sZXQgc2Nhbl9jYW1sX3N0cmluZyB3aWR0aCBpYiA9XG5cbiAgbGV0IHJlYyBmaW5kX3N0YXJ0IHdpZHRoID1cbiAgICBtYXRjaCBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiB3aXRoXG4gICAgfCAnXFxcIicgLT4gZmluZF9zdG9wIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IGMgLT4gY2hhcmFjdGVyX21pc21hdGNoICdcXFwiJyBjXG5cbiAgYW5kIGZpbmRfc3RvcCB3aWR0aCA9XG4gICAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmcgd2lkdGggaWIgd2l0aFxuICAgIHwgJ1xcXCInIC0+IFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliXG4gICAgfCAnXFxcXCcgLT4gc2Nhbl9iYWNrc2xhc2ggKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgYyAtPiBmaW5kX3N0b3AgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYylcblxuICBhbmQgc2Nhbl9iYWNrc2xhc2ggd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nIHdpZHRoIGliIHdpdGhcbiAgICB8ICdcXHInIC0+IHNraXBfbmV3bGluZSAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCAnXFxuJyAtPiBza2lwX3NwYWNlcyAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBfIC0+IGZpbmRfc3RvcCAoc2Nhbl9iYWNrc2xhc2hfY2hhciB3aWR0aCBpYilcblxuICBhbmQgc2tpcF9uZXdsaW5lIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFxuJyAtPiBza2lwX3NwYWNlcyAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBfIC0+IGZpbmRfc3RvcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiAnXFxyJylcblxuICBhbmQgc2tpcF9zcGFjZXMgd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nIHdpZHRoIGliIHdpdGhcbiAgICB8ICcgJyAtPiBza2lwX3NwYWNlcyAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBfIC0+IGZpbmRfc3RvcCB3aWR0aCBpblxuXG4gIGZpbmRfc3RhcnQgd2lkdGhcblxuXG4oKiBTY2FuIGEgYm9vbGVhbiAoYW4gT0NhbWwgdG9rZW4pLiAqKVxubGV0IHNjYW5fYm9vbCBpYiA9XG4gIGxldCBjID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgbGV0IG0gPVxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgJ3QnIC0+IDRcbiAgICB8ICdmJyAtPiA1XG4gICAgfCBjIC0+XG4gICAgICBiYWRfaW5wdXRcbiAgICAgICAgKFByaW50Zi5zcHJpbnRmIFwidGhlIGNoYXJhY3RlciAlQyBjYW5ub3Qgc3RhcnQgYSBib29sZWFuXCIgYykgaW5cbiAgc2Nhbl9zdHJpbmcgTm9uZSBtIGliXG5cblxuKCogU2NhbiBhIHN0cmluZyBjb250YWluaW5nIGVsZW1lbnRzIGluIGNoYXJfc2V0IGFuZCB0ZXJtaW5hdGVkIGJ5IHNjYW5faW5kaWNcbiAgIGlmIHByb3ZpZGVkLiAqKVxubGV0IHNjYW5fY2hhcnNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgc2Nhbl9pbmRpYyB3aWR0aCBpYiA9XG4gIGxldCByZWMgc2Nhbl9jaGFycyBpIHN0cCA9XG4gICAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBpID4gMCAmJiBub3QgKFNjYW5uaW5nLmVvZiBpYikgJiZcbiAgICAgICBpc19pbl9jaGFyX3NldCBjaGFyX3NldCBjICYmXG4gICAgICAgaW50X29mX2NoYXIgYyA8PiBzdHAgdGhlblxuICAgICAgbGV0IF8gPSBTY2FubmluZy5zdG9yZV9jaGFyIG1heF9pbnQgaWIgYyBpblxuICAgICAgc2Nhbl9jaGFycyAoaSAtIDEpIHN0cCBpblxuICBtYXRjaCBzY2FuX2luZGljIHdpdGhcbiAgfCBOb25lIC0+IHNjYW5fY2hhcnMgd2lkdGggKC0xKTtcbiAgfCBTb21lIGMgLT5cbiAgICBzY2FuX2NoYXJzIHdpZHRoIChpbnRfb2ZfY2hhciBjKTtcbiAgICBpZiBub3QgKFNjYW5uaW5nLmVvZiBpYikgdGhlblxuICAgICAgbGV0IGNpID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgICBpZiBjID0gY2lcbiAgICAgIHRoZW4gU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWJcbiAgICAgIGVsc2UgY2hhcmFjdGVyX21pc21hdGNoIGMgY2lcblxuXG4oKiBUaGUgZ2xvYmFsIGVycm9yIHJlcG9ydCBmdW5jdGlvbiBmb3IgW1NjYW5mXS4gKilcbmxldCBzY2FuZl9iYWRfaW5wdXQgaWIgPSBmdW5jdGlvblxuICB8IFNjYW5fZmFpbHVyZSBzIHwgRmFpbHVyZSBzIC0+XG4gICAgbGV0IGkgPSBTY2FubmluZy5jaGFyX2NvdW50IGliIGluXG4gICAgYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcInNjYW5mOiBiYWQgaW5wdXQgYXQgY2hhciBudW1iZXIgJWk6ICVzXCIgaSBzKVxuICB8IHggLT4gcmFpc2UgeFxuXG5cbigqIEdldCB0aGUgY29udGVudCBvZiBhIGNvdW50ZXIgZnJvbSBhbiBpbnB1dCBidWZmZXIuICopXG5sZXQgZ2V0X2NvdW50ZXIgaWIgY291bnRlciA9XG4gIG1hdGNoIGNvdW50ZXIgd2l0aFxuICB8IExpbmVfY291bnRlciAtPiBTY2FubmluZy5saW5lX2NvdW50IGliXG4gIHwgQ2hhcl9jb3VudGVyIC0+IFNjYW5uaW5nLmNoYXJfY291bnQgaWJcbiAgfCBUb2tlbl9jb3VudGVyIC0+IFNjYW5uaW5nLnRva2VuX2NvdW50IGliXG5cblxuKCogQ29tcHV0ZSB0aGUgd2lkdGggb2YgYSBwYWRkaW5nIG9wdGlvbiAoc2VlIFwiJTQye1wiIGFuZCBcIiUxMjMoXCIpLiAqKVxubGV0IHdpZHRoX29mX3BhZF9vcHQgcGFkX29wdCA9IG1hdGNoIHBhZF9vcHQgd2l0aFxuICB8IE5vbmUgLT4gbWF4X2ludFxuICB8IFNvbWUgd2lkdGggLT4gd2lkdGhcblxuXG5sZXQgc3RvcHBlcl9vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmcgPVxuICBpZiBmbXRpbmcgPSBFc2NhcGVkX3BlcmNlbnQgdGhlbiAnJScsIFwiXCIgZWxzZVxuICAgIGxldCBzdHIgPSBzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nIGluXG4gICAgbGV0IHN0cCA9IHN0ci5bMV0gaW5cbiAgICBsZXQgc3ViX3N0ciA9IFN0cmluZy5zdWIgc3RyIDIgKFN0cmluZy5sZW5ndGggc3RyIC0gMikgaW5cbiAgICBzdHAsIHN1Yl9zdHJcblxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogUmVhZGVyIG1hbmFnZW1lbnQgKilcblxuKCogQSBjYWxsIHRvIHRha2VfZm9ybWF0X3JlYWRlcnMgb24gYSBmb3JtYXQgaXMgZXZhbHVhdGVkIGludG8gZnVuY3Rpb25zXG4gICB0YWtpbmcgcmVhZGVycyBhcyBhcmd1bWVudHMgYW5kIGFnZ3JlZ2F0ZSB0aGVtIGludG8gYW4gaGV0ZXJvZ2VuZW91cyBsaXN0ICopXG4oKiBXaGVuIGFsbCByZWFkZXJzIGFyZSB0YWtlbiwgZmluYWxseSBwYXNzIHRoZSBsaXN0IG9mIHRoZSByZWFkZXJzIHRvIHRoZVxuICAgY29udGludWF0aW9uIGsuICopXG5sZXQgcmVjIHRha2VfZm9ybWF0X3JlYWRlcnMgOiB0eXBlIGEgYyBkIGUgZiAuXG4gICAgKChkLCBlKSBoZXRlcl9saXN0IC0+IGUpIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICBkID1cbmZ1biBrIGZtdCAtPiBtYXRjaCBmbXQgd2l0aFxuICB8IFJlYWRlciBmbXRfcmVzdCAtPlxuICAgIGZ1biByZWFkZXIgLT5cbiAgICAgIGxldCBuZXdfayByZWFkZXJzX3Jlc3QgPSBrIChDb25zIChyZWFkZXIsIHJlYWRlcnNfcmVzdCkpIGluXG4gICAgICB0YWtlX2Zvcm1hdF9yZWFkZXJzIG5ld19rIGZtdF9yZXN0XG4gIHwgQ2hhciByZXN0ICAgICAgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBDYW1sX2NoYXIgcmVzdCAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IFN0cmluZyAoXywgcmVzdCkgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQ2FtbF9zdHJpbmcgKF8sIHJlc3QpICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBJbnQgKF8sIF8sIF8sIHJlc3QpICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEludDMyIChfLCBfLCBfLCByZXN0KSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgTmF0aXZlaW50IChfLCBfLCBfLCByZXN0KSAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBJbnQ2NCAoXywgXywgXywgcmVzdCkgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEZsb2F0IChfLCBfLCBfLCByZXN0KSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQm9vbCAoXywgcmVzdCkgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBBbHBoYSByZXN0ICAgICAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IFRoZXRhIHJlc3QgICAgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgRmx1c2ggcmVzdCAgICAgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBTdHJpbmdfbGl0ZXJhbCAoXywgcmVzdCkgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IENoYXJfbGl0ZXJhbCAoXywgcmVzdCkgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQ3VzdG9tIChfLCBfLCByZXN0KSAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcblxuICB8IFNjYW5fY2hhcl9zZXQgKF8sIF8sIHJlc3QpICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgU2Nhbl9nZXRfY291bnRlciAoXywgcmVzdCkgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBTY2FuX25leHRfY2hhciByZXN0ICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuXG4gIHwgRm9ybWF0dGluZ19saXQgKF8sIHJlc3QpICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10LCBfKSksIHJlc3QpIC0+XG4gICAgICB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgKGNvbmNhdF9mbXQgZm10IHJlc3QpXG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdCwgXykpLCByZXN0KSAtPlxuICAgICAgdGFrZV9mb3JtYXRfcmVhZGVycyBrIChjb25jYXRfZm10IGZtdCByZXN0KVxuXG4gIHwgRm9ybWF0X2FyZyAoXywgXywgcmVzdCkgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBGb3JtYXRfc3Vic3QgKF8sIGZtdHR5LCByZXN0KSAgICAtPlxuICAgICB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgKGVyYXNlX3JlbCAoc3ltbSBmbXR0eSkpIHJlc3RcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpICAgICAgICAtPiB0YWtlX2lnbm9yZWRfZm9ybWF0X3JlYWRlcnMgayBpZ24gcmVzdFxuXG4gIHwgRW5kX29mX2Zvcm1hdCAgICAgICAgICAgICAgICAgICAgLT4gayBOaWxcblxuKCogVGFrZSByZWFkZXJzIGFzc29jaWF0ZWQgdG8gYW4gZm10dHkgY29taW5nIGZyb20gYSBGb3JtYXRfc3Vic3QgXCIlKC4uLiUpXCIuICopXG5hbmQgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyA6IHR5cGUgeCB5IGEgYyBkIGUgZiAuXG4gICAgKChkLCBlKSBoZXRlcl9saXN0IC0+IGUpIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCB4LCB5KSBmbXR0eSAtPlxuICAgICAgKHksIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIHgsIGUsIGYpIGZtdCAtPiBkID1cbmZ1biBrIGZtdHR5IGZtdCAtPiBtYXRjaCBmbXR0eSB3aXRoXG4gIHwgUmVhZGVyX3R5IGZtdF9yZXN0IC0+XG4gICAgZnVuIHJlYWRlciAtPlxuICAgICAgbGV0IG5ld19rIHJlYWRlcnNfcmVzdCA9IGsgKENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSkgaW5cbiAgICAgIHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgbmV3X2sgZm10X3Jlc3QgZm10XG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgZm10X3Jlc3QgLT5cbiAgICBmdW4gcmVhZGVyIC0+XG4gICAgICBsZXQgbmV3X2sgcmVhZGVyc19yZXN0ID0gayAoQ29ucyAocmVhZGVyLCByZWFkZXJzX3Jlc3QpKSBpblxuICAgICAgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBuZXdfayBmbXRfcmVzdCBmbXRcbiAgfCBDaGFyX3R5IHJlc3QgICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgU3RyaW5nX3R5IHJlc3QgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEludF90eSByZXN0ICAgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBJbnQzMl90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEludDY0X3R5IHJlc3QgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBGbG9hdF90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgQm9vbF90eSByZXN0ICAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEFscGhhX3R5IHJlc3QgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBUaGV0YV90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgQW55X3R5IHJlc3QgICAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEZvcm1hdF9hcmdfdHkgKF8sIHJlc3QpICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBFbmRfb2ZfZm10dHkgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgbGV0IHR5ID0gdHJhbnMgKHN5bW0gdHkxKSB0eTIgaW5cbiAgICB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgKGNvbmNhdF9mbXR0eSB0eSByZXN0KSBmbXRcblxuKCogVGFrZSByZWFkZXJzIGFzc29jaWF0ZWQgdG8gYW4gaWdub3JlZCBwYXJhbWV0ZXIuICopXG5hbmQgdGFrZV9pZ25vcmVkX2Zvcm1hdF9yZWFkZXJzIDogdHlwZSB4IHkgYSBjIGQgZSBmIC5cbiAgICAoKGQsIGUpIGhldGVyX2xpc3QgLT4gZSkgLT4gKGEsIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIGQsIHgsIHkpIGlnbm9yZWQgLT5cbiAgICAgICh5LCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCB4LCBlLCBmKSBmbXQgLT4gZCA9XG5mdW4gayBpZ24gZm10IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9yZWFkZXIgLT5cbiAgICBmdW4gcmVhZGVyIC0+XG4gICAgICBsZXQgbmV3X2sgcmVhZGVyc19yZXN0ID0gayAoQ29ucyAocmVhZGVyLCByZWFkZXJzX3Jlc3QpKSBpblxuICAgICAgdGFrZV9mb3JtYXRfcmVhZGVycyBuZXdfayBmbXRcbiAgfCBJZ25vcmVkX2NoYXIgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX3N0cmluZyBfICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIF8gICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2ludCAoXywgXykgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2ludDMyIChfLCBfKSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX25hdGl2ZWludCAoXywgXykgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2ludDY0IChfLCBfKSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2Zsb2F0IChfLCBfKSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2Jvb2wgXyAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgXyAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAoXywgZm10dHkpIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayBmbXR0eSBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgXyAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgXyAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogR2VuZXJpYyBzY2FubmluZyAqKVxuXG4oKiBNYWtlIGEgZ2VuZXJpYyBzY2FubmluZyBmdW5jdGlvbi4gKilcbigqIFNjYW4gYSBzdHJlYW0gYWNjb3JkaW5nIHRvIGEgZm9ybWF0IGFuZCByZWFkZXJzIG9idGFpbmVkIGJ5XG4gICB0YWtlX2Zvcm1hdF9yZWFkZXJzLCBhbmQgYWdncmVnYXRlIHNjYW5uZWQgdmFsdWVzIGludG8gYW5cbiAgIGhldGVyb2dlbmVvdXMgbGlzdC4gKilcbigqIFJldHVybiB0aGUgaGV0ZXJvZ2VuZW91cyBsaXN0IG9mIHNjYW5uZWQgdmFsdWVzLiAqKVxubGV0IHJlYyBtYWtlX3NjYW5mIDogdHlwZSBhIGMgZCBlIGYuXG4gICAgU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgICAoZCwgZSkgaGV0ZXJfbGlzdCAtPiAoYSwgZikgaGV0ZXJfbGlzdCA9XG5mdW4gaWIgZm10IHJlYWRlcnMgLT4gbWF0Y2ggZm10IHdpdGhcbiAgfCBDaGFyIHJlc3QgLT5cbiAgICBsZXQgXyA9IHNjYW5fY2hhciAwIGliIGluXG4gICAgbGV0IGMgPSB0b2tlbl9jaGFyIGliIGluXG4gICAgQ29ucyAoYywgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG4gIHwgQ2FtbF9jaGFyIHJlc3QgLT5cbiAgICBsZXQgXyA9IHNjYW5fY2FtbF9jaGFyIDAgaWIgaW5cbiAgICBsZXQgYyA9IHRva2VuX2NoYXIgaWIgaW5cbiAgICBDb25zIChjLCBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVycylcblxuICB8IFN0cmluZyAocGFkLCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkpIC0+XG4gICAgbGV0IHN0cCwgc3RyID0gc3RvcHBlcl9vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fc3RyaW5nIChTb21lIHN0cCkgd2lkdGggaWIgaW5cbiAgICBsZXQgc3RyX3Jlc3QgPSBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHN0cl9yZXN0IHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuIHRva2VuX3N0cmluZ1xuICB8IFN0cmluZyAocGFkLCBGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSkgLT5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9zdHJpbmcgKFNvbWUgJ3snKSB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIChjb25jYXRfZm10IGZtdCcgcmVzdCkgcmVhZGVycyBwYWQgTm9fcHJlY2lzaW9uIHNjYW5cbiAgICAgICAgICAgICAgICAgICB0b2tlbl9zdHJpbmdcbiAgfCBTdHJpbmcgKHBhZCwgRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkpIC0+XG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fc3RyaW5nIChTb21lICdbJykgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuXG4gICAgICAgICAgICAgICAgICAgdG9rZW5fc3RyaW5nXG4gIHwgU3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fc3RyaW5nIE5vbmUgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuIHRva2VuX3N0cmluZ1xuXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9jYW1sX3N0cmluZyB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgTm9fcHJlY2lzaW9uIHNjYW4gdG9rZW5fc3RyaW5nXG4gIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCBjID0gaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpIGluXG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5faW50X2NvbnZlcnNpb24gYyB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuICh0b2tlbl9pbnQgYylcbiAgfCBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgYyA9IGludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyIChjaGFyX29mX2ljb252IGljb252KSBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX2ludF9jb252ZXJzaW9uIGMgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2NhbiAodG9rZW5faW50MzIgYylcbiAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IGMgPSBpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciAoY2hhcl9vZl9pY29udiBpY29udikgaW5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9pbnRfY29udmVyc2lvbiBjIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW4gKHRva2VuX25hdGl2ZWludCBjKVxuICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCBjID0gaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpIGluXG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5faW50X2NvbnZlcnNpb24gYyB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuICh0b2tlbl9pbnQ2NCBjKVxuICB8IEZsb2F0IChGbG9hdF9GLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW5fY2FtbF9mbG9hdCB0b2tlbl9mbG9hdFxuICB8IEZsb2F0ICgoRmxvYXRfZiB8IEZsb2F0X3BmIHwgRmxvYXRfc2YgfCBGbG9hdF9lIHwgRmxvYXRfcGUgfCBGbG9hdF9zZVxuICAgICAgICAgICAgICAgfCBGbG9hdF9FIHwgRmxvYXRfcEUgfCBGbG9hdF9zRSB8IEZsb2F0X2cgfCBGbG9hdF9wZyB8IEZsb2F0X3NnXG4gICAgICAgICAgICAgICB8IEZsb2F0X0cgfCBGbG9hdF9wRyB8IEZsb2F0X3NHKSwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuX2Zsb2F0IHRva2VuX2Zsb2F0XG4gIHwgRmxvYXQgKChGbG9hdF9oIHwgRmxvYXRfcGggfCBGbG9hdF9zaCB8IEZsb2F0X0ggfCBGbG9hdF9wSCB8IEZsb2F0X3NIKSxcbiAgICAgICAgICAgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuX2hleF9mbG9hdCB0b2tlbl9mbG9hdFxuICB8IEJvb2wgKHBhZCwgcmVzdCkgLT5cbiAgICBsZXQgc2NhbiBfIF8gaWIgPSBzY2FuX2Jvb2wgaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuIHRva2VuX2Jvb2xcbiAgfCBBbHBoYSBfIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiVhXFxcIlwiXG4gIHwgVGhldGEgXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIldFxcXCJcIlxuICB8IEN1c3RvbSBfIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiU/XFxcIiAoY3VzdG9tIGNvbnZlcnRlcilcIlxuICB8IFJlYWRlciBmbXRfcmVzdCAtPlxuICAgIGJlZ2luIG1hdGNoIHJlYWRlcnMgd2l0aFxuICAgIHwgQ29ucyAocmVhZGVyLCByZWFkZXJzX3Jlc3QpIC0+XG4gICAgICAgIGxldCB4ID0gcmVhZGVyIGliIGluXG4gICAgICAgIENvbnMgKHgsIG1ha2Vfc2NhbmYgaWIgZm10X3Jlc3QgcmVhZGVyc19yZXN0KVxuICAgIHwgTmlsIC0+XG4gICAgICAgIGludmFsaWRfYXJnIFwic2NhbmY6IG1pc3NpbmcgcmVhZGVyXCJcbiAgICBlbmRcbiAgfCBGbHVzaCByZXN0IC0+XG4gICAgaWYgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnNcbiAgICBlbHNlIGJhZF9pbnB1dCBcImVuZCBvZiBpbnB1dCBub3QgZm91bmRcIlxuXG4gIHwgU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgLT5cbiAgICBTdHJpbmcuaXRlciAoY2hlY2tfY2hhciBpYikgc3RyO1xuICAgIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzXG4gIHwgQ2hhcl9saXRlcmFsIChjaHIsIHJlc3QpIC0+XG4gICAgY2hlY2tfY2hhciBpYiBjaHI7XG4gICAgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnNcblxuICB8IEZvcm1hdF9hcmcgKHBhZF9vcHQsIGZtdHR5LCByZXN0KSAtPlxuICAgIGxldCBfID0gc2Nhbl9jYW1sX3N0cmluZyAod2lkdGhfb2ZfcGFkX29wdCBwYWRfb3B0KSBpYiBpblxuICAgIGxldCBzID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgbGV0IGZtdCA9XG4gICAgICB0cnkgZm9ybWF0X29mX3N0cmluZ19mbXR0eSBzIGZtdHR5XG4gICAgICB3aXRoIEZhaWx1cmUgbXNnIC0+IGJhZF9pbnB1dCBtc2dcbiAgICBpblxuICAgIENvbnMgKGZtdCwgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG4gIHwgRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBmbXR0eSwgcmVzdCkgLT5cbiAgICBsZXQgXyA9IHNjYW5fY2FtbF9zdHJpbmcgKHdpZHRoX29mX3BhZF9vcHQgcGFkX29wdCkgaWIgaW5cbiAgICBsZXQgcyA9IHRva2VuX3N0cmluZyBpYiBpblxuICAgIGxldCBmbXQsIGZtdCcgPVxuICAgICAgdHJ5XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdCA9IGZtdF9lYmJfb2Zfc3RyaW5nIHMgaW5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10JyA9IGZtdF9lYmJfb2Zfc3RyaW5nIHMgaW5cbiAgICAgICAgKCogVE9ETzogZmluZCBhIHdheSB0byBhdm9pZCByZXBhcnNpbmcgdHdpY2UgKilcblxuICAgICAgICAoKiBUT0RPOiB0aGVzZSB0eXBlLWNoZWNrcyBiZWxvdyAqY2FuKiBmYWlsIGJlY2F1c2Ugb2YgdHlwZVxuICAgICAgICAgICBhbWJpZ3VpdHkgaW4gcHJlc2VuY2Ugb2YgaWdub3JlZC1yZWFkZXJzOiBcIiVfciVkXCIgYW5kIFwiJWQlX3JcIlxuICAgICAgICAgICBhcmUgdHlwZWQgaW4gdGhlIHNhbWUgd2F5LlxuXG4gICAgICAgICAgICMgU2NhbmYuc3NjYW5mIFwiXFxcIiVfciVkXFxcIjNcIiBcIiUoJWQlX3IlKVwiIGlnbm9yZVxuICAgICAgICAgICAgIChmdW4gZm10IG4gLT4gc3RyaW5nX29mX2Zvcm1hdCBmbXQsIG4pXG4gICAgICAgICAgIEV4Y2VwdGlvbjogQ2FtbGludGVybmFsRm9ybWF0LlR5cGVfbWlzbWF0Y2guXG5cbiAgICAgICAgICAgV2Ugc2hvdWxkIHByb3Blcmx5IGNhdGNoIHRoaXMgZXhjZXB0aW9uLlxuICAgICAgICAqKVxuICAgICAgICB0eXBlX2Zvcm1hdCBmbXQgKGVyYXNlX3JlbCBmbXR0eSksXG4gICAgICAgIHR5cGVfZm9ybWF0IGZtdCcgKGVyYXNlX3JlbCAoc3ltbSBmbXR0eSkpXG4gICAgICB3aXRoIEZhaWx1cmUgbXNnIC0+IGJhZF9pbnB1dCBtc2dcbiAgICBpblxuICAgIENvbnMgKEZvcm1hdCAoZm10LCBzKSxcbiAgICAgICAgICBtYWtlX3NjYW5mIGliIChjb25jYXRfZm10IGZtdCcgcmVzdCkgcmVhZGVycylcblxuICB8IFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCByZXN0KSkgLT5cbiAgICBsZXQgc3RwLCBzdHIgPSBzdG9wcGVyX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQgaW5cbiAgICBsZXQgd2lkdGggPSB3aWR0aF9vZl9wYWRfb3B0IHdpZHRoX29wdCBpblxuICAgIHNjYW5fY2hhcnNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgKFNvbWUgc3RwKSB3aWR0aCBpYjtcbiAgICBsZXQgcyA9IHRva2VuX3N0cmluZyBpYiBpblxuICAgIGxldCBzdHJfcmVzdCA9IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIGluXG4gICAgQ29ucyAocywgbWFrZV9zY2FuZiBpYiBzdHJfcmVzdCByZWFkZXJzKVxuICB8IFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIHJlc3QpIC0+XG4gICAgbGV0IHdpZHRoID0gd2lkdGhfb2ZfcGFkX29wdCB3aWR0aF9vcHQgaW5cbiAgICBzY2FuX2NoYXJzX2luX2NoYXJfc2V0IGNoYXJfc2V0IE5vbmUgd2lkdGggaWI7XG4gICAgbGV0IHMgPSB0b2tlbl9zdHJpbmcgaWIgaW5cbiAgICBDb25zIChzLCBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVycylcbiAgfCBTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCByZXN0KSAtPlxuICAgIGxldCBjb3VudCA9IGdldF9jb3VudGVyIGliIGNvdW50ZXIgaW5cbiAgICBDb25zIChjb3VudCwgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG4gIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAtPlxuICAgIGxldCBjID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgICBDb25zIChjLCBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVycylcblxuICB8IEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgcmVzdCkgLT5cbiAgICBTdHJpbmcuaXRlciAoY2hlY2tfY2hhciBpYikgKHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmb3JtYXR0aW5nX2xpdCk7XG4gICAgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnNcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgIGNoZWNrX2NoYXIgaWIgJ0AnOyBjaGVja19jaGFyIGliICd7JztcbiAgICBtYWtlX3NjYW5mIGliIChjb25jYXRfZm10IGZtdCcgcmVzdCkgcmVhZGVyc1xuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgY2hlY2tfY2hhciBpYiAnQCc7IGNoZWNrX2NoYXIgaWIgJ1snO1xuICAgIG1ha2Vfc2NhbmYgaWIgKGNvbmNhdF9mbXQgZm10JyByZXN0KSByZWFkZXJzXG5cbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpIC0+XG4gICAgbGV0IFBhcmFtX2Zvcm1hdF9FQkIgZm10JyA9IHBhcmFtX2Zvcm1hdF9vZl9pZ25vcmVkX2Zvcm1hdCBpZ24gcmVzdCBpblxuICAgIGJlZ2luIG1hdGNoIG1ha2Vfc2NhbmYgaWIgZm10JyByZWFkZXJzIHdpdGhcbiAgICB8IENvbnMgKF8sIGFyZ19yZXN0KSAtPiBhcmdfcmVzdFxuICAgIHwgTmlsIC0+IGFzc2VydCBmYWxzZVxuICAgIGVuZFxuXG4gIHwgRW5kX29mX2Zvcm1hdCAtPlxuICAgIE5pbFxuXG4oKiBDYXNlIGFuYWx5c2lzIG9uIHBhZGRpbmcgYW5kIHByZWNpc2lvbi4gKilcbigqIFJlamVjdCBmb3JtYXRzIGNvbnRhaW5pbmcgXCIlKlwiIG9yIFwiJS4qXCIuICopXG4oKiBQYXNzIHBhZGRpbmcgYW5kIHByZWNpc2lvbiB0byB0aGUgZ2VuZXJpYyBzY2FubmVyIGBzY2FuJy4gKilcbmFuZCBwYWRfcHJlY19zY2FuZiA6IHR5cGUgYSBjIGQgZSBmIHggeSB6IHQgLlxuICAgIFNjYW5uaW5nLmluX2NoYW5uZWwgLT4gKGEsIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgICAgKGQsIGUpIGhldGVyX2xpc3QgLT4gKHgsIHkpIHBhZGRpbmcgLT4gKHksIHogLT4gYSkgcHJlY2lzaW9uIC0+XG4gICAgICAoaW50IC0+IGludCAtPiBTY2FubmluZy5pbl9jaGFubmVsIC0+IHQpIC0+XG4gICAgICAoU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiB6KSAtPlxuICAgICAgKHgsIGYpIGhldGVyX2xpc3QgPVxuZnVuIGliIGZtdCByZWFkZXJzIHBhZCBwcmVjIHNjYW4gdG9rZW4gLT4gbWF0Y2ggcGFkLCBwcmVjIHdpdGhcbiAgfCBOb19wYWRkaW5nLCBOb19wcmVjaXNpb24gLT5cbiAgICBsZXQgXyA9IHNjYW4gbWF4X2ludCBtYXhfaW50IGliIGluXG4gICAgbGV0IHggPSB0b2tlbiBpYiBpblxuICAgIENvbnMgKHgsIG1ha2Vfc2NhbmYgaWIgZm10IHJlYWRlcnMpXG4gIHwgTm9fcGFkZGluZywgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgbGV0IF8gPSBzY2FuIG1heF9pbnQgcCBpYiBpblxuICAgIGxldCB4ID0gdG9rZW4gaWIgaW5cbiAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdCByZWFkZXJzKVxuICB8IExpdF9wYWRkaW5nICgoUmlnaHQgfCBaZXJvcyksIHcpLCBOb19wcmVjaXNpb24gLT5cbiAgICBsZXQgXyA9IHNjYW4gdyBtYXhfaW50IGliIGluXG4gICAgbGV0IHggPSB0b2tlbiBpYiBpblxuICAgIENvbnMgKHgsIG1ha2Vfc2NhbmYgaWIgZm10IHJlYWRlcnMpXG4gIHwgTGl0X3BhZGRpbmcgKChSaWdodCB8IFplcm9zKSwgdyksIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGxldCBfID0gc2NhbiB3IHAgaWIgaW5cbiAgICBsZXQgeCA9IHRva2VuIGliIGluXG4gICAgQ29ucyAoeCwgbWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycylcbiAgfCBMaXRfcGFkZGluZyAoTGVmdCwgXyksIF8gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJS1cXFwiXCJcbiAgfCBMaXRfcGFkZGluZyAoKFJpZ2h0IHwgWmVyb3MpLCBfKSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlKlxcXCJcIlxuICB8IEFyZ19wYWRkaW5nIF8sIF8gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJSpcXFwiXCJcbiAgfCBOb19wYWRkaW5nLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiUqXFxcIlwiXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAoKiBEZWZpbmluZyBbc2NhbmZdIGFuZCB2YXJpb3VzIGZsYXZvcnMgb2YgW3NjYW5mXSAqKVxuXG50eXBlICdhIGtzY2FuZl9yZXN1bHQgPSBBcmdzIG9mICdhIHwgRXhjIG9mIGV4blxuXG5sZXQga3NjYW5mIGliIGVmIChGb3JtYXQgKGZtdCwgc3RyKSkgPVxuICBsZXQgcmVjIGFwcGx5IDogdHlwZSBhIGIgLiBhIC0+IChhLCBiKSBoZXRlcl9saXN0IC0+IGIgPVxuICAgIGZ1biBmIGFyZ3MgLT4gbWF0Y2ggYXJncyB3aXRoXG4gICAgfCBDb25zICh4LCByKSAtPiBhcHBseSAoZiB4KSByXG4gICAgfCBOaWwgLT4gZlxuICBpblxuICBsZXQgayByZWFkZXJzIGYgPVxuICAgIFNjYW5uaW5nLnJlc2V0X3Rva2VuIGliO1xuICAgIG1hdGNoIHRyeSBBcmdzIChtYWtlX3NjYW5mIGliIGZtdCByZWFkZXJzKSB3aXRoXG4gICAgICB8IChTY2FuX2ZhaWx1cmUgXyB8IEZhaWx1cmUgXyB8IEVuZF9vZl9maWxlKSBhcyBleGMgLT4gRXhjIGV4Y1xuICAgICAgfCBJbnZhbGlkX2FyZ3VtZW50IG1zZyAtPlxuICAgICAgICBpbnZhbGlkX2FyZyAobXNnIF4gXCIgaW4gZm9ybWF0IFxcXCJcIiBeIFN0cmluZy5lc2NhcGVkIHN0ciBeIFwiXFxcIlwiKVxuICAgIHdpdGhcbiAgICAgIHwgQXJncyBhcmdzIC0+IGFwcGx5IGYgYXJnc1xuICAgICAgfCBFeGMgZXhjIC0+IGVmIGliIGV4Y1xuICBpblxuICB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG5cbigqKiopXG5cbmxldCBrYnNjYW5mID0ga3NjYW5mXG5sZXQgYnNjYW5mIGliIGZtdCA9IGtic2NhbmYgaWIgc2NhbmZfYmFkX2lucHV0IGZtdFxuXG5sZXQga3NzY2FuZiBzIGVmIGZtdCA9IGtic2NhbmYgKFNjYW5uaW5nLmZyb21fc3RyaW5nIHMpIGVmIGZtdFxubGV0IHNzY2FuZiBzIGZtdCA9IGtic2NhbmYgKFNjYW5uaW5nLmZyb21fc3RyaW5nIHMpIHNjYW5mX2JhZF9pbnB1dCBmbXRcblxubGV0IHNjYW5mIGZtdCA9IGtzY2FuZiBTY2FubmluZy5zdGRpYiBzY2FuZl9iYWRfaW5wdXQgZm10XG5cbigqKiopXG5cbigqIFNjYW5uaW5nIGZvcm1hdCBzdHJpbmdzLiAqKVxubGV0IGJzY2FuZl9mb3JtYXQgOlxuICBTY2FubmluZy5pbl9jaGFubmVsIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+XG4gICgoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPiAnZykgLT4gJ2cgPVxuICBmdW4gaWIgZm9ybWF0IGYgLT5cbiAgICBsZXQgXyA9IHNjYW5fY2FtbF9zdHJpbmcgbWF4X2ludCBpYiBpblxuICAgIGxldCBzdHIgPSB0b2tlbl9zdHJpbmcgaWIgaW5cbiAgICBsZXQgZm10JyA9XG4gICAgICB0cnkgZm9ybWF0X29mX3N0cmluZ19mb3JtYXQgc3RyIGZvcm1hdFxuICAgICAgd2l0aCBGYWlsdXJlIG1zZyAtPiBiYWRfaW5wdXQgbXNnIGluXG4gICAgZiBmbXQnXG5cblxubGV0IHNzY2FuZl9mb3JtYXQgOlxuICBzdHJpbmcgLT4gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT5cbiAgKCgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+ICdnKSAtPiAnZyA9XG4gIGZ1biBzIGZvcm1hdCBmIC0+IGJzY2FuZl9mb3JtYXQgKFNjYW5uaW5nLmZyb21fc3RyaW5nIHMpIGZvcm1hdCBmXG5cblxubGV0IHN0cmluZ190b19TdHJpbmcgcyA9XG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAobCArIDIpIGluXG4gIEJ1ZmZlci5hZGRfY2hhciBiICdcXFwiJztcbiAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgbGV0IGMgPSBzLltpXSBpblxuICAgIGlmIGMgPSAnXFxcIicgdGhlbiBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcXCc7XG4gICAgQnVmZmVyLmFkZF9jaGFyIGIgYztcbiAgZG9uZTtcbiAgQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXCInO1xuICBCdWZmZXIuY29udGVudHMgYlxuXG5cbmxldCBmb3JtYXRfZnJvbV9zdHJpbmcgcyBmbXQgPVxuICBzc2NhbmZfZm9ybWF0IChzdHJpbmdfdG9fU3RyaW5nIHMpIGZtdCAoZnVuIHggLT4geClcblxuXG5sZXQgdW5lc2NhcGVkIHMgPVxuICBzc2NhbmYgKFwiXFxcIlwiIF4gcyBeIFwiXFxcIlwiKSBcIiVTJSFcIiAoZnVuIHggLT4geClcblxuXG4oKiBEZXByZWNhdGVkICopXG5sZXQga2ZzY2FuZiBpYyBlZiBmbXQgPSBrYnNjYW5mIChTY2FubmluZy5tZW1vX2Zyb21fY2hhbm5lbCBpYykgZWYgZm10XG5sZXQgZnNjYW5mIGljIGZtdCA9IGtzY2FuZiAoU2Nhbm5pbmcubWVtb19mcm9tX2NoYW5uZWwgaWMpIHNjYW5mX2JhZF9pbnB1dCBmbXRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogUmVnaXN0ZXJpbmcgT0NhbWwgdmFsdWVzIHdpdGggdGhlIEMgcnVudGltZSBmb3IgbGF0ZXIgY2FsbGJhY2tzICopXG5cbmV4dGVybmFsIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIDogc3RyaW5nIC0+IE9iai50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlXCJcblxubGV0IHJlZ2lzdGVyIG5hbWUgdiA9XG4gIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIG5hbWUgKE9iai5yZXByIHYpXG5cbmxldCByZWdpc3Rlcl9leGNlcHRpb24gbmFtZSAoZXhuIDogZXhuKSA9XG4gIGxldCBleG4gPSBPYmoucmVwciBleG4gaW5cbiAgbGV0IHNsb3QgPSBpZiBPYmoudGFnIGV4biA9IE9iai5vYmplY3RfdGFnIHRoZW4gZXhuIGVsc2UgT2JqLmZpZWxkIGV4biAwIGluXG4gIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIG5hbWUgc2xvdFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgSmVyb21lIFZvdWlsbG9uLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAwMiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIE9ialxuXG4oKioqKiBPYmplY3QgcmVwcmVzZW50YXRpb24gKioqKilcblxuZXh0ZXJuYWwgc2V0X2lkOiAnYSAtPiAnYSA9IFwiY2FtbF9zZXRfb29faWRcIiBbQEBub2FsbG9jXVxuXG4oKioqKiBPYmplY3QgY29weSAqKioqKVxuXG5sZXQgY29weSBvID1cbiAgbGV0IG8gPSAoT2JqLm9iaiAoT2JqLmR1cCAoT2JqLnJlcHIgbykpKSBpblxuICBzZXRfaWQgb1xuXG4oKioqKiBDb21wcmVzc2lvbiBvcHRpb25zICoqKiopXG4oKiBQYXJhbWV0ZXJzICopXG50eXBlIHBhcmFtcyA9IHtcbiAgICBtdXRhYmxlIGNvbXBhY3RfdGFibGUgOiBib29sO1xuICAgIG11dGFibGUgY29weV9wYXJlbnQgOiBib29sO1xuICAgIG11dGFibGUgY2xlYW5fd2hlbl9jb3B5aW5nIDogYm9vbDtcbiAgICBtdXRhYmxlIHJldHJ5X2NvdW50IDogaW50O1xuICAgIG11dGFibGUgYnVja2V0X3NtYWxsX3NpemUgOiBpbnRcbiAgfVxuXG5sZXQgcGFyYW1zID0ge1xuICBjb21wYWN0X3RhYmxlID0gdHJ1ZTtcbiAgY29weV9wYXJlbnQgPSB0cnVlO1xuICBjbGVhbl93aGVuX2NvcHlpbmcgPSB0cnVlO1xuICByZXRyeV9jb3VudCA9IDM7XG4gIGJ1Y2tldF9zbWFsbF9zaXplID0gMTZcbn1cblxuKCoqKiogUGFyYW1ldGVycyAqKioqKVxuXG5sZXQgaW5pdGlhbF9vYmplY3Rfc2l6ZSA9IDJcblxuKCoqKiogSXRlbXMgKioqKilcblxudHlwZSBpdGVtID0gRHVtbXlBIHwgRHVtbXlCIHwgRHVtbXlDIG9mIGludFxubGV0IF8gPSBbRHVtbXlBOyBEdW1teUI7IER1bW15QyAwXSAoKiB0byBhdm9pZCB3YXJuaW5ncyAqKVxuXG5sZXQgZHVtbXlfaXRlbSA9IChtYWdpYyAoKSA6IGl0ZW0pXG5cbigqKioqIFR5cGVzICoqKiopXG5cbnR5cGUgdGFnXG50eXBlIGxhYmVsID0gaW50XG50eXBlIGNsb3N1cmUgPSBpdGVtXG50eXBlIHQgPSBEdW1teUEgfCBEdW1teUIgfCBEdW1teUMgb2YgaW50XG5sZXQgXyA9IFtEdW1teUE7IER1bW15QjsgRHVtbXlDIDBdICgqIHRvIGF2b2lkIHdhcm5pbmdzICopXG5cbnR5cGUgb2JqID0gdCBhcnJheVxuZXh0ZXJuYWwgcmV0IDogKG9iaiAtPiAnYSkgLT4gY2xvc3VyZSA9IFwiJWlkZW50aXR5XCJcblxuKCoqKiogTGFiZWxzICoqKiopXG5cbmxldCBwdWJsaWNfbWV0aG9kX2xhYmVsIHMgOiB0YWcgPVxuICBsZXQgYWNjdSA9IHJlZiAwIGluXG4gIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHMgLSAxIGRvXG4gICAgYWNjdSA6PSAyMjMgKiAhYWNjdSArIENoYXIuY29kZSBzLltpXVxuICBkb25lO1xuICAoKiByZWR1Y2UgdG8gMzEgYml0cyAqKVxuICBhY2N1IDo9ICFhY2N1IGxhbmQgKDEgbHNsIDMxIC0gMSk7XG4gICgqIG1ha2UgaXQgc2lnbmVkIGZvciA2NCBiaXRzIGFyY2hpdGVjdHVyZXMgKilcbiAgbGV0IHRhZyA9IGlmICFhY2N1ID4gMHgzRkZGRkZGRiB0aGVuICFhY2N1IC0gKDEgbHNsIDMxKSBlbHNlICFhY2N1IGluXG4gICgqIFByaW50Zi5lcHJpbnRmIFwiJXMgPSAlZFxcblwiIHMgdGFnOyBmbHVzaCBzdGRlcnI7ICopXG4gIG1hZ2ljIHRhZ1xuXG4oKioqKiBTcGFyc2UgYXJyYXkgKioqKilcblxubW9kdWxlIFZhcnMgPVxuICBNYXAuTWFrZShzdHJ1Y3QgdHlwZSB0ID0gc3RyaW5nIGxldCBjb21wYXJlICh4OnQpIHkgPSBjb21wYXJlIHggeSBlbmQpXG50eXBlIHZhcnMgPSBpbnQgVmFycy50XG5cbm1vZHVsZSBNZXRocyA9XG4gIE1hcC5NYWtlKHN0cnVjdCB0eXBlIHQgPSBzdHJpbmcgbGV0IGNvbXBhcmUgKHg6dCkgeSA9IGNvbXBhcmUgeCB5IGVuZClcbnR5cGUgbWV0aHMgPSBsYWJlbCBNZXRocy50XG5tb2R1bGUgTGFicyA9XG4gIE1hcC5NYWtlKHN0cnVjdCB0eXBlIHQgPSBsYWJlbCBsZXQgY29tcGFyZSAoeDp0KSB5ID0gY29tcGFyZSB4IHkgZW5kKVxudHlwZSBsYWJzID0gYm9vbCBMYWJzLnRcblxuKCogVGhlIGNvbXBpbGVyIGFzc3VtZXMgdGhhdCB0aGUgZmlyc3QgZmllbGQgb2YgdGhpcyBzdHJ1Y3R1cmUgaXMgW3NpemVdLiAqKVxudHlwZSB0YWJsZSA9XG4geyBtdXRhYmxlIHNpemU6IGludDtcbiAgIG11dGFibGUgbWV0aG9kczogY2xvc3VyZSBhcnJheTtcbiAgIG11dGFibGUgbWV0aG9kc19ieV9uYW1lOiBtZXRocztcbiAgIG11dGFibGUgbWV0aG9kc19ieV9sYWJlbDogbGFicztcbiAgIG11dGFibGUgcHJldmlvdXNfc3RhdGVzOlxuICAgICAobWV0aHMgKiBsYWJzICogKGxhYmVsICogaXRlbSkgbGlzdCAqIHZhcnMgKlxuICAgICAgbGFiZWwgbGlzdCAqIHN0cmluZyBsaXN0KSBsaXN0O1xuICAgbXV0YWJsZSBoaWRkZW5fbWV0aHM6IChsYWJlbCAqIGl0ZW0pIGxpc3Q7XG4gICBtdXRhYmxlIHZhcnM6IHZhcnM7XG4gICBtdXRhYmxlIGluaXRpYWxpemVyczogKG9iaiAtPiB1bml0KSBsaXN0IH1cblxubGV0IGR1bW15X3RhYmxlID1cbiAgeyBtZXRob2RzID0gW3wgZHVtbXlfaXRlbSB8XTtcbiAgICBtZXRob2RzX2J5X25hbWUgPSBNZXRocy5lbXB0eTtcbiAgICBtZXRob2RzX2J5X2xhYmVsID0gTGFicy5lbXB0eTtcbiAgICBwcmV2aW91c19zdGF0ZXMgPSBbXTtcbiAgICBoaWRkZW5fbWV0aHMgPSBbXTtcbiAgICB2YXJzID0gVmFycy5lbXB0eTtcbiAgICBpbml0aWFsaXplcnMgPSBbXTtcbiAgICBzaXplID0gMCB9XG5cbmxldCB0YWJsZV9jb3VudCA9IHJlZiAwXG5cbigqIGR1bW15X21ldCBzaG91bGQgYmUgYSBwb2ludGVyLCBzbyB1c2UgYW4gYXRvbSAqKVxubGV0IGR1bW15X21ldCA6IGl0ZW0gPSBvYmogKE9iai5uZXdfYmxvY2sgMCAwKVxuKCogaWYgZGVidWdnaW5nIGlzIG5lZWRlZCwgdGhpcyBjb3VsZCBiZSBhIGdvb2QgaWRlYTogKilcbigqIGxldCBkdW1teV9tZXQgKCkgPSBmYWlsd2l0aCBcIlVuZGVmaW5lZCBtZXRob2RcIiAqKVxuXG5sZXQgcmVjIGZpdF9zaXplIG4gPVxuICBpZiBuIDw9IDIgdGhlbiBuIGVsc2VcbiAgZml0X3NpemUgKChuKzEpLzIpICogMlxuXG5sZXQgbmV3X3RhYmxlIHB1Yl9sYWJlbHMgPVxuICBpbmNyIHRhYmxlX2NvdW50O1xuICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIHB1Yl9sYWJlbHMgaW5cbiAgbGV0IG1ldGhvZHMgPSBBcnJheS5tYWtlIChsZW4qMisyKSBkdW1teV9tZXQgaW5cbiAgbWV0aG9kcy4oMCkgPC0gbWFnaWMgbGVuO1xuICBtZXRob2RzLigxKSA8LSBtYWdpYyAoZml0X3NpemUgbGVuICogU3lzLndvcmRfc2l6ZSAvIDggLSAxKTtcbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG8gbWV0aG9kcy4oaSoyKzMpIDwtIG1hZ2ljIHB1Yl9sYWJlbHMuKGkpIGRvbmU7XG4gIHsgbWV0aG9kcyA9IG1ldGhvZHM7XG4gICAgbWV0aG9kc19ieV9uYW1lID0gTWV0aHMuZW1wdHk7XG4gICAgbWV0aG9kc19ieV9sYWJlbCA9IExhYnMuZW1wdHk7XG4gICAgcHJldmlvdXNfc3RhdGVzID0gW107XG4gICAgaGlkZGVuX21ldGhzID0gW107XG4gICAgdmFycyA9IFZhcnMuZW1wdHk7XG4gICAgaW5pdGlhbGl6ZXJzID0gW107XG4gICAgc2l6ZSA9IGluaXRpYWxfb2JqZWN0X3NpemUgfVxuXG5sZXQgcmVzaXplIGFycmF5IG5ld19zaXplID1cbiAgbGV0IG9sZF9zaXplID0gQXJyYXkubGVuZ3RoIGFycmF5Lm1ldGhvZHMgaW5cbiAgaWYgbmV3X3NpemUgPiBvbGRfc2l6ZSB0aGVuIGJlZ2luXG4gICAgbGV0IG5ld19idWNrID0gQXJyYXkubWFrZSBuZXdfc2l6ZSBkdW1teV9tZXQgaW5cbiAgICBBcnJheS5ibGl0IGFycmF5Lm1ldGhvZHMgMCBuZXdfYnVjayAwIG9sZF9zaXplO1xuICAgIGFycmF5Lm1ldGhvZHMgPC0gbmV3X2J1Y2tcbiBlbmRcblxubGV0IHB1dCBhcnJheSBsYWJlbCBlbGVtZW50ID1cbiAgcmVzaXplIGFycmF5IChsYWJlbCArIDEpO1xuICBhcnJheS5tZXRob2RzLihsYWJlbCkgPC0gZWxlbWVudFxuXG4oKioqKiBDbGFzc2VzICoqKiopXG5cbmxldCBtZXRob2RfY291bnQgPSByZWYgMFxubGV0IGluc3RfdmFyX2NvdW50ID0gcmVmIDBcblxuKCogdHlwZSB0ICopXG50eXBlIG1ldGggPSBpdGVtXG5cbmxldCBuZXdfbWV0aG9kIHRhYmxlID1cbiAgbGV0IGluZGV4ID0gQXJyYXkubGVuZ3RoIHRhYmxlLm1ldGhvZHMgaW5cbiAgcmVzaXplIHRhYmxlIChpbmRleCArIDEpO1xuICBpbmRleFxuXG5sZXQgZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSBuYW1lID1cbiAgdHJ5XG4gICAgTWV0aHMuZmluZCBuYW1lIHRhYmxlLm1ldGhvZHNfYnlfbmFtZVxuICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgIGxldCBsYWJlbCA9IG5ld19tZXRob2QgdGFibGUgaW5cbiAgICB0YWJsZS5tZXRob2RzX2J5X25hbWUgPC0gTWV0aHMuYWRkIG5hbWUgbGFiZWwgdGFibGUubWV0aG9kc19ieV9uYW1lO1xuICAgIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgPC0gTGFicy5hZGQgbGFiZWwgdHJ1ZSB0YWJsZS5tZXRob2RzX2J5X2xhYmVsO1xuICAgIGxhYmVsXG5cbmxldCBnZXRfbWV0aG9kX2xhYmVscyB0YWJsZSBuYW1lcyA9XG4gIEFycmF5Lm1hcCAoZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSkgbmFtZXNcblxubGV0IHNldF9tZXRob2QgdGFibGUgbGFiZWwgZWxlbWVudCA9XG4gIGluY3IgbWV0aG9kX2NvdW50O1xuICBpZiBMYWJzLmZpbmQgbGFiZWwgdGFibGUubWV0aG9kc19ieV9sYWJlbCB0aGVuXG4gICAgcHV0IHRhYmxlIGxhYmVsIGVsZW1lbnRcbiAgZWxzZVxuICAgIHRhYmxlLmhpZGRlbl9tZXRocyA8LSAobGFiZWwsIGVsZW1lbnQpIDo6IHRhYmxlLmhpZGRlbl9tZXRoc1xuXG5sZXQgZ2V0X21ldGhvZCB0YWJsZSBsYWJlbCA9XG4gIHRyeSBMaXN0LmFzc29jIGxhYmVsIHRhYmxlLmhpZGRlbl9tZXRoc1xuICB3aXRoIE5vdF9mb3VuZCAtPiB0YWJsZS5tZXRob2RzLihsYWJlbClcblxubGV0IHRvX2xpc3QgYXJyID1cbiAgaWYgYXJyID09IG1hZ2ljIDAgdGhlbiBbXSBlbHNlIEFycmF5LnRvX2xpc3QgYXJyXG5cbmxldCBuYXJyb3cgdGFibGUgdmFycyB2aXJ0X21ldGhzIGNvbmNyX21ldGhzID1cbiAgbGV0IHZhcnMgPSB0b19saXN0IHZhcnNcbiAgYW5kIHZpcnRfbWV0aHMgPSB0b19saXN0IHZpcnRfbWV0aHNcbiAgYW5kIGNvbmNyX21ldGhzID0gdG9fbGlzdCBjb25jcl9tZXRocyBpblxuICBsZXQgdmlydF9tZXRoX2xhYnMgPSBMaXN0Lm1hcCAoZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSkgdmlydF9tZXRocyBpblxuICBsZXQgY29uY3JfbWV0aF9sYWJzID0gTGlzdC5tYXAgKGdldF9tZXRob2RfbGFiZWwgdGFibGUpIGNvbmNyX21ldGhzIGluXG4gIHRhYmxlLnByZXZpb3VzX3N0YXRlcyA8LVxuICAgICAodGFibGUubWV0aG9kc19ieV9uYW1lLCB0YWJsZS5tZXRob2RzX2J5X2xhYmVsLCB0YWJsZS5oaWRkZW5fbWV0aHMsXG4gICAgICB0YWJsZS52YXJzLCB2aXJ0X21ldGhfbGFicywgdmFycylcbiAgICAgOjogdGFibGUucHJldmlvdXNfc3RhdGVzO1xuICB0YWJsZS52YXJzIDwtXG4gICAgVmFycy5mb2xkXG4gICAgICAoZnVuIGxhYiBpbmZvIHR2YXJzIC0+XG4gICAgICAgIGlmIExpc3QubWVtIGxhYiB2YXJzIHRoZW4gVmFycy5hZGQgbGFiIGluZm8gdHZhcnMgZWxzZSB0dmFycylcbiAgICAgIHRhYmxlLnZhcnMgVmFycy5lbXB0eTtcbiAgbGV0IGJ5X25hbWUgPSByZWYgTWV0aHMuZW1wdHkgaW5cbiAgbGV0IGJ5X2xhYmVsID0gcmVmIExhYnMuZW1wdHkgaW5cbiAgTGlzdC5pdGVyMlxuICAgIChmdW4gbWV0IGxhYmVsIC0+XG4gICAgICAgYnlfbmFtZSA6PSBNZXRocy5hZGQgbWV0IGxhYmVsICFieV9uYW1lO1xuICAgICAgIGJ5X2xhYmVsIDo9XG4gICAgICAgICAgTGFicy5hZGQgbGFiZWxcbiAgICAgICAgICAgICh0cnkgTGFicy5maW5kIGxhYmVsIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgd2l0aCBOb3RfZm91bmQgLT4gdHJ1ZSlcbiAgICAgICAgICAgICFieV9sYWJlbClcbiAgICBjb25jcl9tZXRocyBjb25jcl9tZXRoX2xhYnM7XG4gIExpc3QuaXRlcjJcbiAgICAoZnVuIG1ldCBsYWJlbCAtPlxuICAgICAgIGJ5X25hbWUgOj0gTWV0aHMuYWRkIG1ldCBsYWJlbCAhYnlfbmFtZTtcbiAgICAgICBieV9sYWJlbCA6PSBMYWJzLmFkZCBsYWJlbCBmYWxzZSAhYnlfbGFiZWwpXG4gICAgdmlydF9tZXRocyB2aXJ0X21ldGhfbGFicztcbiAgdGFibGUubWV0aG9kc19ieV9uYW1lIDwtICFieV9uYW1lO1xuICB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIDwtICFieV9sYWJlbDtcbiAgdGFibGUuaGlkZGVuX21ldGhzIDwtXG4gICAgIExpc3QuZm9sZF9yaWdodFxuICAgICAgIChmdW4gKChsYWIsIF8pIGFzIG1ldCkgaG0gLT5cbiAgICAgICAgICBpZiBMaXN0Lm1lbSBsYWIgdmlydF9tZXRoX2xhYnMgdGhlbiBobSBlbHNlIG1ldDo6aG0pXG4gICAgICAgdGFibGUuaGlkZGVuX21ldGhzXG4gICAgICAgW11cblxubGV0IHdpZGVuIHRhYmxlID1cbiAgbGV0IChieV9uYW1lLCBieV9sYWJlbCwgc2F2ZWRfaGlkZGVuX21ldGhzLCBzYXZlZF92YXJzLCB2aXJ0X21ldGhzLCB2YXJzKSA9XG4gICAgTGlzdC5oZCB0YWJsZS5wcmV2aW91c19zdGF0ZXNcbiAgaW5cbiAgdGFibGUucHJldmlvdXNfc3RhdGVzIDwtIExpc3QudGwgdGFibGUucHJldmlvdXNfc3RhdGVzO1xuICB0YWJsZS52YXJzIDwtXG4gICAgIExpc3QuZm9sZF9sZWZ0XG4gICAgICAgKGZ1biBzIHYgLT4gVmFycy5hZGQgdiAoVmFycy5maW5kIHYgdGFibGUudmFycykgcylcbiAgICAgICBzYXZlZF92YXJzIHZhcnM7XG4gIHRhYmxlLm1ldGhvZHNfYnlfbmFtZSA8LSBieV9uYW1lO1xuICB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIDwtIGJ5X2xhYmVsO1xuICB0YWJsZS5oaWRkZW5fbWV0aHMgPC1cbiAgICAgTGlzdC5mb2xkX3JpZ2h0XG4gICAgICAgKGZ1biAoKGxhYiwgXykgYXMgbWV0KSBobSAtPlxuICAgICAgICAgIGlmIExpc3QubWVtIGxhYiB2aXJ0X21ldGhzIHRoZW4gaG0gZWxzZSBtZXQ6OmhtKVxuICAgICAgIHRhYmxlLmhpZGRlbl9tZXRoc1xuICAgICAgIHNhdmVkX2hpZGRlbl9tZXRoc1xuXG5sZXQgbmV3X3Nsb3QgdGFibGUgPVxuICBsZXQgaW5kZXggPSB0YWJsZS5zaXplIGluXG4gIHRhYmxlLnNpemUgPC0gaW5kZXggKyAxO1xuICBpbmRleFxuXG5sZXQgbmV3X3ZhcmlhYmxlIHRhYmxlIG5hbWUgPVxuICB0cnkgVmFycy5maW5kIG5hbWUgdGFibGUudmFyc1xuICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgIGxldCBpbmRleCA9IG5ld19zbG90IHRhYmxlIGluXG4gICAgaWYgbmFtZSA8PiBcIlwiIHRoZW4gdGFibGUudmFycyA8LSBWYXJzLmFkZCBuYW1lIGluZGV4IHRhYmxlLnZhcnM7XG4gICAgaW5kZXhcblxubGV0IHRvX2FycmF5IGFyciA9XG4gIGlmIGFyciA9IE9iai5tYWdpYyAwIHRoZW4gW3x8XSBlbHNlIGFyclxuXG5sZXQgbmV3X21ldGhvZHNfdmFyaWFibGVzIHRhYmxlIG1ldGhzIHZhbHMgPVxuICBsZXQgbWV0aHMgPSB0b19hcnJheSBtZXRocyBpblxuICBsZXQgbm1ldGhzID0gQXJyYXkubGVuZ3RoIG1ldGhzIGFuZCBudmFscyA9IEFycmF5Lmxlbmd0aCB2YWxzIGluXG4gIGxldCByZXMgPSBBcnJheS5tYWtlIChubWV0aHMgKyBudmFscykgMCBpblxuICBmb3IgaSA9IDAgdG8gbm1ldGhzIC0gMSBkb1xuICAgIHJlcy4oaSkgPC0gZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSBtZXRocy4oaSlcbiAgZG9uZTtcbiAgZm9yIGkgPSAwIHRvIG52YWxzIC0gMSBkb1xuICAgIHJlcy4oaStubWV0aHMpIDwtIG5ld192YXJpYWJsZSB0YWJsZSB2YWxzLihpKVxuICBkb25lO1xuICByZXNcblxubGV0IGdldF92YXJpYWJsZSB0YWJsZSBuYW1lID1cbiAgdHJ5IFZhcnMuZmluZCBuYW1lIHRhYmxlLnZhcnMgd2l0aCBOb3RfZm91bmQgLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCBnZXRfdmFyaWFibGVzIHRhYmxlIG5hbWVzID1cbiAgQXJyYXkubWFwIChnZXRfdmFyaWFibGUgdGFibGUpIG5hbWVzXG5cbmxldCBhZGRfaW5pdGlhbGl6ZXIgdGFibGUgZiA9XG4gIHRhYmxlLmluaXRpYWxpemVycyA8LSBmOjp0YWJsZS5pbml0aWFsaXplcnNcblxuKCpcbm1vZHVsZSBLZXlzID1cbiAgTWFwLk1ha2Uoc3RydWN0IHR5cGUgdCA9IHRhZyBhcnJheSBsZXQgY29tcGFyZSAoeDp0KSB5ID0gY29tcGFyZSB4IHkgZW5kKVxubGV0IGtleV9tYXAgPSByZWYgS2V5cy5lbXB0eVxubGV0IGdldF9rZXkgdGFncyA6IGl0ZW0gPVxuICB0cnkgbWFnaWMgKEtleXMuZmluZCB0YWdzICFrZXlfbWFwIDogdGFnIGFycmF5KVxuICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgIGtleV9tYXAgOj0gS2V5cy5hZGQgdGFncyB0YWdzICFrZXlfbWFwO1xuICAgIG1hZ2ljIHRhZ3NcbiopXG5cbmxldCBjcmVhdGVfdGFibGUgcHVibGljX21ldGhvZHMgPVxuICBpZiBwdWJsaWNfbWV0aG9kcyA9PSBtYWdpYyAwIHRoZW4gbmV3X3RhYmxlIFt8fF0gZWxzZVxuICAoKiBbcHVibGljX21ldGhvZHNdIG11c3QgYmUgaW4gYXNjZW5kaW5nIG9yZGVyIGZvciBieXRlY29kZSAqKVxuICBsZXQgdGFncyA9IEFycmF5Lm1hcCBwdWJsaWNfbWV0aG9kX2xhYmVsIHB1YmxpY19tZXRob2RzIGluXG4gIGxldCB0YWJsZSA9IG5ld190YWJsZSB0YWdzIGluXG4gIEFycmF5Lml0ZXJpXG4gICAgKGZ1biBpIG1ldCAtPlxuICAgICAgbGV0IGxhYiA9IGkqMisyIGluXG4gICAgICB0YWJsZS5tZXRob2RzX2J5X25hbWUgIDwtIE1ldGhzLmFkZCBtZXQgbGFiIHRhYmxlLm1ldGhvZHNfYnlfbmFtZTtcbiAgICAgIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgPC0gTGFicy5hZGQgbGFiIHRydWUgdGFibGUubWV0aG9kc19ieV9sYWJlbClcbiAgICBwdWJsaWNfbWV0aG9kcztcbiAgdGFibGVcblxubGV0IGluaXRfY2xhc3MgdGFibGUgPVxuICBpbnN0X3Zhcl9jb3VudCA6PSAhaW5zdF92YXJfY291bnQgKyB0YWJsZS5zaXplIC0gMTtcbiAgdGFibGUuaW5pdGlhbGl6ZXJzIDwtIExpc3QucmV2IHRhYmxlLmluaXRpYWxpemVycztcbiAgcmVzaXplIHRhYmxlICgzICsgbWFnaWMgdGFibGUubWV0aG9kcy4oMSkgKiAxNiAvIFN5cy53b3JkX3NpemUpXG5cbmxldCBpbmhlcml0cyBjbGEgdmFscyB2aXJ0X21ldGhzIGNvbmNyX21ldGhzIChfLCBzdXBlciwgXywgZW52KSB0b3AgPVxuICBuYXJyb3cgY2xhIHZhbHMgdmlydF9tZXRocyBjb25jcl9tZXRocztcbiAgbGV0IGluaXQgPVxuICAgIGlmIHRvcCB0aGVuIHN1cGVyIGNsYSBlbnYgZWxzZSBPYmoucmVwciAoc3VwZXIgY2xhKSBpblxuICB3aWRlbiBjbGE7XG4gIEFycmF5LmNvbmNhdFxuICAgIFtbfCByZXByIGluaXQgfF07XG4gICAgIG1hZ2ljIChBcnJheS5tYXAgKGdldF92YXJpYWJsZSBjbGEpICh0b19hcnJheSB2YWxzKSA6IGludCBhcnJheSk7XG4gICAgIEFycmF5Lm1hcFxuICAgICAgIChmdW4gbm0gLT4gcmVwciAoZ2V0X21ldGhvZCBjbGEgKGdldF9tZXRob2RfbGFiZWwgY2xhIG5tKSA6IGNsb3N1cmUpKVxuICAgICAgICh0b19hcnJheSBjb25jcl9tZXRocykgXVxuXG5sZXQgbWFrZV9jbGFzcyBwdWJfbWV0aHMgY2xhc3NfaW5pdCA9XG4gIGxldCB0YWJsZSA9IGNyZWF0ZV90YWJsZSBwdWJfbWV0aHMgaW5cbiAgbGV0IGVudl9pbml0ID0gY2xhc3NfaW5pdCB0YWJsZSBpblxuICBpbml0X2NsYXNzIHRhYmxlO1xuICAoZW52X2luaXQgKE9iai5yZXByIDApLCBjbGFzc19pbml0LCBlbnZfaW5pdCwgT2JqLnJlcHIgMClcblxudHlwZSBpbml0X3RhYmxlID0geyBtdXRhYmxlIGVudl9pbml0OiB0OyBtdXRhYmxlIGNsYXNzX2luaXQ6IHRhYmxlIC0+IHQgfVxuXG5sZXQgbWFrZV9jbGFzc19zdG9yZSBwdWJfbWV0aHMgY2xhc3NfaW5pdCBpbml0X3RhYmxlID1cbiAgbGV0IHRhYmxlID0gY3JlYXRlX3RhYmxlIHB1Yl9tZXRocyBpblxuICBsZXQgZW52X2luaXQgPSBjbGFzc19pbml0IHRhYmxlIGluXG4gIGluaXRfY2xhc3MgdGFibGU7XG4gIGluaXRfdGFibGUuY2xhc3NfaW5pdCA8LSBjbGFzc19pbml0O1xuICBpbml0X3RhYmxlLmVudl9pbml0IDwtIGVudl9pbml0XG5cbmxldCBkdW1teV9jbGFzcyBsb2MgPVxuICBsZXQgdW5kZWYgPSBmdW4gXyAtPiByYWlzZSAoVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGUgbG9jKSBpblxuICAoT2JqLm1hZ2ljIHVuZGVmLCB1bmRlZiwgdW5kZWYsIE9iai5yZXByIDApXG5cbigqKioqIE9iamVjdHMgKioqKilcblxubGV0IGNyZWF0ZV9vYmplY3QgdGFibGUgPVxuICAoKiBYWFggQXBwZWwgZGUgW29ial9ibG9ja10gfCBDYWxsIHRvIFtvYmpfYmxvY2tdICAqKVxuICBsZXQgb2JqID0gT2JqLm5ld19ibG9jayBPYmoub2JqZWN0X3RhZyB0YWJsZS5zaXplIGluXG4gICgqIFhYWCBBcHBlbCBkZSBbY2FtbF9tb2RpZnldIHwgQ2FsbCB0byBbY2FtbF9tb2RpZnldICopXG4gIE9iai5zZXRfZmllbGQgb2JqIDAgKE9iai5yZXByIHRhYmxlLm1ldGhvZHMpO1xuICBPYmoub2JqIChzZXRfaWQgb2JqKVxuXG5sZXQgY3JlYXRlX29iamVjdF9vcHQgb2JqXzAgdGFibGUgPVxuICBpZiAoT2JqLm1hZ2ljIG9ial8wIDogYm9vbCkgdGhlbiBvYmpfMCBlbHNlIGJlZ2luXG4gICAgKCogWFhYIEFwcGVsIGRlIFtvYmpfYmxvY2tdIHwgQ2FsbCB0byBbb2JqX2Jsb2NrXSAgKilcbiAgICBsZXQgb2JqID0gT2JqLm5ld19ibG9jayBPYmoub2JqZWN0X3RhZyB0YWJsZS5zaXplIGluXG4gICAgKCogWFhYIEFwcGVsIGRlIFtjYW1sX21vZGlmeV0gfCBDYWxsIHRvIFtjYW1sX21vZGlmeV0gKilcbiAgICBPYmouc2V0X2ZpZWxkIG9iaiAwIChPYmoucmVwciB0YWJsZS5tZXRob2RzKTtcbiAgICBPYmoub2JqIChzZXRfaWQgb2JqKVxuICBlbmRcblxubGV0IHJlYyBpdGVyX2Ygb2JqID1cbiAgZnVuY3Rpb25cbiAgICBbXSAgIC0+ICgpXG4gIHwgZjo6bCAtPiBmIG9iajsgaXRlcl9mIG9iaiBsXG5cbmxldCBydW5faW5pdGlhbGl6ZXJzIG9iaiB0YWJsZSA9XG4gIGxldCBpbml0cyA9IHRhYmxlLmluaXRpYWxpemVycyBpblxuICBpZiBpbml0cyA8PiBbXSB0aGVuXG4gICAgaXRlcl9mIG9iaiBpbml0c1xuXG5sZXQgcnVuX2luaXRpYWxpemVyc19vcHQgb2JqXzAgb2JqIHRhYmxlID1cbiAgaWYgKE9iai5tYWdpYyBvYmpfMCA6IGJvb2wpIHRoZW4gb2JqIGVsc2UgYmVnaW5cbiAgICBsZXQgaW5pdHMgPSB0YWJsZS5pbml0aWFsaXplcnMgaW5cbiAgICBpZiBpbml0cyA8PiBbXSB0aGVuIGl0ZXJfZiBvYmogaW5pdHM7XG4gICAgb2JqXG4gIGVuZFxuXG5sZXQgY3JlYXRlX29iamVjdF9hbmRfcnVuX2luaXRpYWxpemVycyBvYmpfMCB0YWJsZSA9XG4gIGlmIChPYmoubWFnaWMgb2JqXzAgOiBib29sKSB0aGVuIG9ial8wIGVsc2UgYmVnaW5cbiAgICBsZXQgb2JqID0gY3JlYXRlX29iamVjdCB0YWJsZSBpblxuICAgIHJ1bl9pbml0aWFsaXplcnMgb2JqIHRhYmxlO1xuICAgIG9ialxuICBlbmRcblxuKCogRXF1aXZhbGVudCBwcmltaXRpdmUgYmVsb3dcbmxldCBzZW5kc2VsZiBvYmogbGFiID1cbiAgKG1hZ2ljIG9iaiA6IChvYmogLT4gdCkgYXJyYXkgYXJyYXkpLigwKS4obGFiKSBvYmpcbiopXG5leHRlcm5hbCBzZW5kIDogb2JqIC0+IHRhZyAtPiAnYSA9IFwiJXNlbmRcIlxuZXh0ZXJuYWwgc2VuZGNhY2hlIDogb2JqIC0+IHRhZyAtPiB0IC0+IGludCAtPiAnYSA9IFwiJXNlbmRjYWNoZVwiXG5leHRlcm5hbCBzZW5kc2VsZiA6IG9iaiAtPiBsYWJlbCAtPiAnYSA9IFwiJXNlbmRzZWxmXCJcbmV4dGVybmFsIGdldF9wdWJsaWNfbWV0aG9kIDogb2JqIC0+IHRhZyAtPiBjbG9zdXJlXG4gICAgPSBcImNhbWxfZ2V0X3B1YmxpY19tZXRob2RcIiBbQEBub2FsbG9jXVxuXG4oKioqKiB0YWJsZSBjb2xsZWN0aW9uIGFjY2VzcyAqKioqKVxuXG50eXBlIHRhYmxlcyA9XG4gIHwgRW1wdHlcbiAgfCBDb25zIG9mIHtrZXkgOiBjbG9zdXJlOyBtdXRhYmxlIGRhdGE6IHRhYmxlczsgbXV0YWJsZSBuZXh0OiB0YWJsZXN9XG5cbmxldCBzZXRfZGF0YSB0YWJsZXMgdiA9IG1hdGNoIHRhYmxlcyB3aXRoXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLmRhdGEgPC0gdlxubGV0IHNldF9uZXh0IHRhYmxlcyB2ID0gbWF0Y2ggdGFibGVzIHdpdGhcbiAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgfCBDb25zIHRhYmxlcyAtPiB0YWJsZXMubmV4dCA8LSB2XG5sZXQgZ2V0X2tleSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLmtleVxubGV0IGdldF9kYXRhID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgfCBDb25zIHRhYmxlcyAtPiB0YWJsZXMuZGF0YVxubGV0IGdldF9uZXh0ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgfCBDb25zIHRhYmxlcyAtPiB0YWJsZXMubmV4dFxuXG5sZXQgYnVpbGRfcGF0aCBuIGtleXMgdGFibGVzID1cbiAgbGV0IHJlcyA9IENvbnMge2tleSA9IE9iai5tYWdpYyAwOyBkYXRhID0gRW1wdHk7IG5leHQgPSBFbXB0eX0gaW5cbiAgbGV0IHIgPSByZWYgcmVzIGluXG4gIGZvciBpID0gMCB0byBuIGRvXG4gICAgciA6PSBDb25zIHtrZXkgPSBrZXlzLihpKTsgZGF0YSA9ICFyOyBuZXh0ID0gRW1wdHl9XG4gIGRvbmU7XG4gIHNldF9kYXRhIHRhYmxlcyAhcjtcbiAgcmVzXG5cbmxldCByZWMgbG9va3VwX2tleXMgaSBrZXlzIHRhYmxlcyA9XG4gIGlmIGkgPCAwIHRoZW4gdGFibGVzIGVsc2VcbiAgbGV0IGtleSA9IGtleXMuKGkpIGluXG4gIGxldCByZWMgbG9va3VwX2tleSAodGFibGVzOnRhYmxlcykgPVxuICAgIGlmIGdldF9rZXkgdGFibGVzID09IGtleSB0aGVuXG4gICAgICBtYXRjaCBnZXRfZGF0YSB0YWJsZXMgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIHwgQ29ucyBfIGFzIHRhYmxlc19kYXRhIC0+XG4gICAgICAgICAgbG9va3VwX2tleXMgKGktMSkga2V5cyB0YWJsZXNfZGF0YVxuICAgIGVsc2VcbiAgICAgIG1hdGNoIGdldF9uZXh0IHRhYmxlcyB3aXRoXG4gICAgICB8IENvbnMgXyBhcyBuZXh0IC0+IGxvb2t1cF9rZXkgbmV4dFxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIGxldCBuZXh0IDogdGFibGVzID0gQ29ucyB7a2V5OyBkYXRhID0gRW1wdHk7IG5leHQgPSBFbXB0eX0gaW5cbiAgICAgICAgICBzZXRfbmV4dCB0YWJsZXMgbmV4dDtcbiAgICAgICAgICBidWlsZF9wYXRoIChpLTEpIGtleXMgbmV4dFxuICBpblxuICBsb29rdXBfa2V5IHRhYmxlc1xuXG5sZXQgbG9va3VwX3RhYmxlcyByb290IGtleXMgPVxuICBtYXRjaCBnZXRfZGF0YSByb290IHdpdGhcbiAgfCBDb25zIF8gYXMgcm9vdF9kYXRhIC0+XG4gICAgbG9va3VwX2tleXMgKEFycmF5Lmxlbmd0aCBrZXlzIC0gMSkga2V5cyByb290X2RhdGFcbiAgfCBFbXB0eSAtPlxuICAgIGJ1aWxkX3BhdGggKEFycmF5Lmxlbmd0aCBrZXlzIC0gMSkga2V5cyByb290XG5cbigqKioqIGJ1aWx0aW4gbWV0aG9kcyAqKioqKVxuXG5sZXQgZ2V0X2NvbnN0IHggPSByZXQgKGZ1biBfb2JqIC0+IHgpXG5sZXQgZ2V0X3ZhciBuICAgPSByZXQgKGZ1biBvYmogLT4gQXJyYXkudW5zYWZlX2dldCBvYmogbilcbmxldCBnZXRfZW52IGUgbiA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pXG5sZXQgZ2V0X21ldGggbiAgPSByZXQgKGZ1biBvYmogLT4gc2VuZHNlbGYgb2JqIG4pXG5sZXQgc2V0X3ZhciBuICAgPSByZXQgKGZ1biBvYmogeCAtPiBBcnJheS51bnNhZmVfc2V0IG9iaiBuIHgpXG5sZXQgYXBwX2NvbnN0IGYgeCA9IHJldCAoZnVuIF9vYmogLT4gZiB4KVxubGV0IGFwcF92YXIgZiBuICAgPSByZXQgKGZ1biBvYmogLT4gZiAoQXJyYXkudW5zYWZlX2dldCBvYmogbikpXG5sZXQgYXBwX2VudiBmIGUgbiA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIGYgKEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pKVxubGV0IGFwcF9tZXRoIGYgbiAgPSByZXQgKGZ1biBvYmogLT4gZiAoc2VuZHNlbGYgb2JqIG4pKVxubGV0IGFwcF9jb25zdF9jb25zdCBmIHggeSA9IHJldCAoZnVuIF9vYmogLT4gZiB4IHkpXG5sZXQgYXBwX2NvbnN0X3ZhciBmIHggbiAgID0gcmV0IChmdW4gb2JqIC0+IGYgeCAoQXJyYXkudW5zYWZlX2dldCBvYmogbikpXG5sZXQgYXBwX2NvbnN0X21ldGggZiB4IG4gPSByZXQgKGZ1biBvYmogLT4gZiB4IChzZW5kc2VsZiBvYmogbikpXG5sZXQgYXBwX3Zhcl9jb25zdCBmIG4geCA9IHJldCAoZnVuIG9iaiAtPiBmIChBcnJheS51bnNhZmVfZ2V0IG9iaiBuKSB4KVxubGV0IGFwcF9tZXRoX2NvbnN0IGYgbiB4ID0gcmV0IChmdW4gb2JqIC0+IGYgKHNlbmRzZWxmIG9iaiBuKSB4KVxubGV0IGFwcF9jb25zdF9lbnYgZiB4IGUgbiA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIGYgeCAoQXJyYXkudW5zYWZlX2dldCAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbikpXG5sZXQgYXBwX2Vudl9jb25zdCBmIGUgbiB4ID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgZiAoQXJyYXkudW5zYWZlX2dldCAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbikgeClcbmxldCBtZXRoX2FwcF9jb25zdCBuIHggPSByZXQgKGZ1biBvYmogLT4gKHNlbmRzZWxmIG9iaiBuIDogXyAtPiBfKSB4KVxubGV0IG1ldGhfYXBwX3ZhciBuIG0gPVxuICByZXQgKGZ1biBvYmogLT4gKHNlbmRzZWxmIG9iaiBuIDogXyAtPiBfKSAoQXJyYXkudW5zYWZlX2dldCBvYmogbSkpXG5sZXQgbWV0aF9hcHBfZW52IG4gZSBtID1cbiAgcmV0IChmdW4gb2JqIC0+IChzZW5kc2VsZiBvYmogbiA6IF8gLT4gXylcbiAgICAgIChBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBtKSlcbmxldCBtZXRoX2FwcF9tZXRoIG4gbSA9XG4gIHJldCAoZnVuIG9iaiAtPiAoc2VuZHNlbGYgb2JqIG4gOiBfIC0+IF8pIChzZW5kc2VsZiBvYmogbSkpXG5sZXQgc2VuZF9jb25zdCBtIHggYyA9XG4gIHJldCAoZnVuIG9iaiAtPiBzZW5kY2FjaGUgeCBtIChBcnJheS51bnNhZmVfZ2V0IG9iaiAwKSBjKVxubGV0IHNlbmRfdmFyIG0gbiBjID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgc2VuZGNhY2hlIChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pIDogb2JqKSBtXG4gICAgICAoQXJyYXkudW5zYWZlX2dldCBvYmogMCkgYylcbmxldCBzZW5kX2VudiBtIGUgbiBjID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgc2VuZGNhY2hlXG4gICAgICAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0XG4gICAgICAgICAgICAgICAgICAgIChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKSA6IG9iailcbiAgICAgIG0gKEFycmF5LnVuc2FmZV9nZXQgb2JqIDApIGMpXG5sZXQgc2VuZF9tZXRoIG0gbiBjID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgc2VuZGNhY2hlIChzZW5kc2VsZiBvYmogbikgbSAoQXJyYXkudW5zYWZlX2dldCBvYmogMCkgYylcbmxldCBuZXdfY2FjaGUgdGFibGUgPVxuICBsZXQgbiA9IG5ld19tZXRob2QgdGFibGUgaW5cbiAgbGV0IG4gPVxuICAgIGlmIG4gbW9kIDIgPSAwIHx8IG4gPiAyICsgbWFnaWMgdGFibGUubWV0aG9kcy4oMSkgKiAxNiAvIFN5cy53b3JkX3NpemVcbiAgICB0aGVuIG4gZWxzZSBuZXdfbWV0aG9kIHRhYmxlXG4gIGluXG4gIHRhYmxlLm1ldGhvZHMuKG4pIDwtIE9iai5tYWdpYyAwO1xuICBuXG5cbnR5cGUgaW1wbCA9XG4gICAgR2V0Q29uc3RcbiAgfCBHZXRWYXJcbiAgfCBHZXRFbnZcbiAgfCBHZXRNZXRoXG4gIHwgU2V0VmFyXG4gIHwgQXBwQ29uc3RcbiAgfCBBcHBWYXJcbiAgfCBBcHBFbnZcbiAgfCBBcHBNZXRoXG4gIHwgQXBwQ29uc3RDb25zdFxuICB8IEFwcENvbnN0VmFyXG4gIHwgQXBwQ29uc3RFbnZcbiAgfCBBcHBDb25zdE1ldGhcbiAgfCBBcHBWYXJDb25zdFxuICB8IEFwcEVudkNvbnN0XG4gIHwgQXBwTWV0aENvbnN0XG4gIHwgTWV0aEFwcENvbnN0XG4gIHwgTWV0aEFwcFZhclxuICB8IE1ldGhBcHBFbnZcbiAgfCBNZXRoQXBwTWV0aFxuICB8IFNlbmRDb25zdFxuICB8IFNlbmRWYXJcbiAgfCBTZW5kRW52XG4gIHwgU2VuZE1ldGhcbiAgfCBDbG9zdXJlIG9mIGNsb3N1cmVcblxubGV0IG1ldGhvZF9pbXBsIHRhYmxlIGkgYXJyID1cbiAgbGV0IG5leHQgKCkgPSBpbmNyIGk7IG1hZ2ljIGFyci4oIWkpIGluXG4gIG1hdGNoIG5leHQoKSB3aXRoXG4gICAgR2V0Q29uc3QgLT4gbGV0IHggOiB0ID0gbmV4dCgpIGluIGdldF9jb25zdCB4XG4gIHwgR2V0VmFyICAgLT4gbGV0IG4gPSBuZXh0KCkgaW4gZ2V0X3ZhciBuXG4gIHwgR2V0RW52ICAgLT4gbGV0IGUgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW4gZ2V0X2VudiBlIG5cbiAgfCBHZXRNZXRoICAtPiBsZXQgbiA9IG5leHQoKSBpbiBnZXRfbWV0aCBuXG4gIHwgU2V0VmFyICAgLT4gbGV0IG4gPSBuZXh0KCkgaW4gc2V0X3ZhciBuXG4gIHwgQXBwQ29uc3QgLT4gbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gYXBwX2NvbnN0IGYgeFxuICB8IEFwcFZhciAgIC0+IGxldCBmID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCAoKSBpbiBhcHBfdmFyIGYgblxuICB8IEFwcEVudiAgIC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiAgbGV0IGUgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9lbnYgZiBlIG5cbiAgfCBBcHBNZXRoICAtPiBsZXQgZiA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQgKCkgaW4gYXBwX21ldGggZiBuXG4gIHwgQXBwQ29uc3RDb25zdCAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbGV0IHkgPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9jb25zdF9jb25zdCBmIHggeVxuICB8IEFwcENvbnN0VmFyIC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpblxuICAgICAgYXBwX2NvbnN0X3ZhciBmIHggblxuICB8IEFwcENvbnN0RW52IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBsZXQgZSA9IG5leHQgKCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9jb25zdF9lbnYgZiB4IGUgblxuICB8IEFwcENvbnN0TWV0aCAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9jb25zdF9tZXRoIGYgeCBuXG4gIHwgQXBwVmFyQ29uc3QgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluXG4gICAgICBhcHBfdmFyX2NvbnN0IGYgbiB4XG4gIHwgQXBwRW52Q29uc3QgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCBlID0gbmV4dCAoKSBpbiBsZXQgbiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpblxuICAgICAgYXBwX2Vudl9jb25zdCBmIGUgbiB4XG4gIHwgQXBwTWV0aENvbnN0IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpblxuICAgICAgYXBwX21ldGhfY29uc3QgZiBuIHhcbiAgfCBNZXRoQXBwQ29uc3QgLT5cbiAgICAgIGxldCBuID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIG1ldGhfYXBwX2NvbnN0IG4geFxuICB8IE1ldGhBcHBWYXIgLT5cbiAgICAgIGxldCBuID0gbmV4dCgpIGluIGxldCBtID0gbmV4dCgpIGluIG1ldGhfYXBwX3ZhciBuIG1cbiAgfCBNZXRoQXBwRW52IC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgZSA9IG5leHQoKSBpbiBsZXQgbSA9IG5leHQoKSBpblxuICAgICAgbWV0aF9hcHBfZW52IG4gZSBtXG4gIHwgTWV0aEFwcE1ldGggLT5cbiAgICAgIGxldCBuID0gbmV4dCgpIGluIGxldCBtID0gbmV4dCgpIGluIG1ldGhfYXBwX21ldGggbiBtXG4gIHwgU2VuZENvbnN0IC0+XG4gICAgICBsZXQgbSA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBzZW5kX2NvbnN0IG0geCAobmV3X2NhY2hlIHRhYmxlKVxuICB8IFNlbmRWYXIgLT5cbiAgICAgIGxldCBtID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCAoKSBpbiBzZW5kX3ZhciBtIG4gKG5ld19jYWNoZSB0YWJsZSlcbiAgfCBTZW5kRW52IC0+XG4gICAgICBsZXQgbSA9IG5leHQoKSBpbiBsZXQgZSA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpblxuICAgICAgc2VuZF9lbnYgbSBlIG4gKG5ld19jYWNoZSB0YWJsZSlcbiAgfCBTZW5kTWV0aCAtPlxuICAgICAgbGV0IG0gPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0ICgpIGluIHNlbmRfbWV0aCBtIG4gKG5ld19jYWNoZSB0YWJsZSlcbiAgfCBDbG9zdXJlIF8gYXMgY2xvIC0+IG1hZ2ljIGNsb1xuXG5sZXQgc2V0X21ldGhvZHMgdGFibGUgbWV0aG9kcyA9XG4gIGxldCBsZW4gPSBBcnJheS5sZW5ndGggbWV0aG9kcyBpbiBsZXQgaSA9IHJlZiAwIGluXG4gIHdoaWxlICFpIDwgbGVuIGRvXG4gICAgbGV0IGxhYmVsID0gbWV0aG9kcy4oIWkpIGluIGxldCBjbG8gPSBtZXRob2RfaW1wbCB0YWJsZSBpIG1ldGhvZHMgaW5cbiAgICBzZXRfbWV0aG9kIHRhYmxlIGxhYmVsIGNsbztcbiAgICBpbmNyIGlcbiAgZG9uZVxuXG4oKioqKiBTdGF0aXN0aWNzICoqKiopXG5cbnR5cGUgc3RhdHMgPVxuICB7IGNsYXNzZXM6IGludDsgbWV0aG9kczogaW50OyBpbnN0X3ZhcnM6IGludDsgfVxuXG5sZXQgc3RhdHMgKCkgPVxuICB7IGNsYXNzZXMgPSAhdGFibGVfY291bnQ7XG4gICAgbWV0aG9kcyA9ICFtZXRob2RfY291bnQ7IGluc3RfdmFycyA9ICFpbnN0X3Zhcl9jb3VudDsgfVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHRva2VuID1cbiAgICBLd2Qgb2Ygc3RyaW5nXG4gIHwgSWRlbnQgb2Ygc3RyaW5nXG4gIHwgSW50IG9mIGludFxuICB8IEZsb2F0IG9mIGZsb2F0XG4gIHwgU3RyaW5nIG9mIHN0cmluZ1xuICB8IENoYXIgb2YgY2hhclxuXG4oKiBUaGUgc3RyaW5nIGJ1ZmZlcmluZyBtYWNoaW5lcnkgKilcblxubGV0IGluaXRpYWxfYnVmZmVyID0gQnl0ZXMuY3JlYXRlIDMyXG5cbmxldCBidWZmZXIgPSByZWYgaW5pdGlhbF9idWZmZXJcbmxldCBidWZwb3MgPSByZWYgMFxuXG5sZXQgcmVzZXRfYnVmZmVyICgpID0gYnVmZmVyIDo9IGluaXRpYWxfYnVmZmVyOyBidWZwb3MgOj0gMFxuXG5sZXQgc3RvcmUgYyA9XG4gIGlmICFidWZwb3MgPj0gQnl0ZXMubGVuZ3RoICFidWZmZXIgdGhlbiBiZWdpblxuICAgIGxldCBuZXdidWZmZXIgPSBCeXRlcy5jcmVhdGUgKDIgKiAhYnVmcG9zKSBpblxuICAgIEJ5dGVzLmJsaXQgIWJ1ZmZlciAwIG5ld2J1ZmZlciAwICFidWZwb3M7XG4gICAgYnVmZmVyIDo9IG5ld2J1ZmZlclxuICBlbmQ7XG4gIEJ5dGVzLnNldCAhYnVmZmVyICFidWZwb3MgYztcbiAgaW5jciBidWZwb3NcblxubGV0IGdldF9zdHJpbmcgKCkgPVxuICBsZXQgcyA9IEJ5dGVzLnN1Yl9zdHJpbmcgIWJ1ZmZlciAwICFidWZwb3MgaW4gYnVmZmVyIDo9IGluaXRpYWxfYnVmZmVyOyBzXG5cbigqIFRoZSBsZXhlciAqKVxuXG5sZXQgbWFrZV9sZXhlciBrZXl3b3JkcyA9XG4gIGxldCBrd2RfdGFibGUgPSBIYXNodGJsLmNyZWF0ZSAxNyBpblxuICBMaXN0Lml0ZXIgKGZ1biBzIC0+IEhhc2h0YmwuYWRkIGt3ZF90YWJsZSBzIChLd2QgcykpIGtleXdvcmRzO1xuICBsZXQgaWRlbnRfb3Jfa2V5d29yZCBpZCA9XG4gICAgdHJ5IEhhc2h0YmwuZmluZCBrd2RfdGFibGUgaWQgd2l0aFxuICAgICAgTm90X2ZvdW5kIC0+IElkZW50IGlkXG4gIGFuZCBrZXl3b3JkX29yX2Vycm9yIGMgPVxuICAgIGxldCBzID0gU3RyaW5nLm1ha2UgMSBjIGluXG4gICAgdHJ5IEhhc2h0YmwuZmluZCBrd2RfdGFibGUgcyB3aXRoXG4gICAgICBOb3RfZm91bmQgLT4gcmFpc2UgKFN0cmVhbS5FcnJvciAoXCJJbGxlZ2FsIGNoYXJhY3RlciBcIiBeIHMpKVxuICBpblxuICBsZXQgcmVjIG5leHRfdG9rZW4gKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJyAnIHwgJ1xcMDEwJyB8ICdcXDAxMycgfCAnXFwwMDknIHwgJ1xcMDI2JyB8ICdcXDAxMicpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbmV4dF90b2tlbiBzdHJtX19cbiAgICB8IFNvbWUgKCdBJy4uJ1onIHwgJ2EnLi4neicgfCAnXycgfCAnXFwxOTInLi4nXFwyNTUnIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IHMgPSBzdHJtX18gaW4gcmVzZXRfYnVmZmVyICgpOyBzdG9yZSBjOyBpZGVudCBzXG4gICAgfCBTb21lXG4gICAgICAgICgnIScgfCAnJScgfCAnJicgfCAnJCcgfCAnIycgfCAnKycgfCAnLycgfCAnOicgfCAnPCcgfCAnPScgfCAnPicgfFxuICAgICAgICAgJz8nIHwgJ0AnIHwgJ1xcXFwnIHwgJ34nIHwgJ14nIHwgJ3wnIHwgJyonIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IHMgPSBzdHJtX18gaW4gcmVzZXRfYnVmZmVyICgpOyBzdG9yZSBjOyBpZGVudDIgc1xuICAgIHwgU29tZSAoJzAnLi4nOScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgcyA9IHN0cm1fXyBpbiByZXNldF9idWZmZXIgKCk7IHN0b3JlIGM7IG51bWJlciBzXG4gICAgfCBTb21lICdcXCcnIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IGMgPVxuICAgICAgICAgIHRyeSBjaGFyIHN0cm1fXyB3aXRoXG4gICAgICAgICAgICBTdHJlYW0uRmFpbHVyZSAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGluXG4gICAgICAgIGJlZ2luIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICAgICAgU29tZSAnXFwnJyAtPiBTdHJlYW0uanVuayBzdHJtX187IFNvbWUgKENoYXIgYylcbiAgICAgICAgfCBfIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgXCJcIilcbiAgICAgICAgZW5kXG4gICAgfCBTb21lICdcXFwiJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHJlc2V0X2J1ZmZlciAoKTsgU29tZSAoU3RyaW5nIChzdHJpbmcgcykpXG4gICAgfCBTb21lICctJyAtPiBTdHJlYW0uanVuayBzdHJtX187IG5lZ19udW1iZXIgc3RybV9fXG4gICAgfCBTb21lICcoJyAtPiBTdHJlYW0uanVuayBzdHJtX187IG1heWJlX2NvbW1lbnQgc3RybV9fXG4gICAgfCBTb21lIGMgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBTb21lIChrZXl3b3JkX29yX2Vycm9yIGMpXG4gICAgfCBfIC0+IE5vbmVcbiAgYW5kIGlkZW50IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWVcbiAgICAgICAgKCdBJy4uJ1onIHwgJ2EnLi4neicgfCAnXFwxOTInLi4nXFwyNTUnIHwgJzAnLi4nOScgfCAnXycgfCAnXFwnJyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IGlkZW50IHNcbiAgICB8IF8gLT4gU29tZSAoaWRlbnRfb3Jfa2V5d29yZCAoZ2V0X3N0cmluZyAoKSkpXG4gIGFuZCBpZGVudDIgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZVxuICAgICAgICAoJyEnIHwgJyUnIHwgJyYnIHwgJyQnIHwgJyMnIHwgJysnIHwgJy0nIHwgJy8nIHwgJzonIHwgJzwnIHwgJz0nIHxcbiAgICAgICAgICc+JyB8ICc/JyB8ICdAJyB8ICdcXFxcJyB8ICd+JyB8ICdeJyB8ICd8JyB8ICcqJyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IGlkZW50MiBzXG4gICAgfCBfIC0+IFNvbWUgKGlkZW50X29yX2tleXdvcmQgKGdldF9zdHJpbmcgKCkpKVxuICBhbmQgbmVnX251bWJlciAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICgnMCcuLic5JyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHJlc2V0X2J1ZmZlciAoKTsgc3RvcmUgJy0nOyBzdG9yZSBjOyBudW1iZXIgc1xuICAgIHwgXyAtPiBsZXQgcyA9IHN0cm1fXyBpbiByZXNldF9idWZmZXIgKCk7IHN0b3JlICctJzsgaWRlbnQyIHNcbiAgYW5kIG51bWJlciAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICgnMCcuLic5JyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IG51bWJlciBzXG4gICAgfCBTb21lICcuJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlICcuJzsgZGVjaW1hbF9wYXJ0IHNcbiAgICB8IFNvbWUgKCdlJyB8ICdFJykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSAnRSc7IGV4cG9uZW50X3BhcnQgc1xuICAgIHwgXyAtPiBTb21lIChJbnQgKGludF9vZl9zdHJpbmcgKGdldF9zdHJpbmcgKCkpKSlcbiAgYW5kIGRlY2ltYWxfcGFydCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICgnMCcuLic5JyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IGRlY2ltYWxfcGFydCBzXG4gICAgfCBTb21lICgnZScgfCAnRScpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgJ0UnOyBleHBvbmVudF9wYXJ0IHNcbiAgICB8IF8gLT4gU29tZSAoRmxvYXQgKGZsb2F0X29mX3N0cmluZyAoZ2V0X3N0cmluZyAoKSkpKVxuICBhbmQgZXhwb25lbnRfcGFydCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICgnKycgfCAnLScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBlbmRfZXhwb25lbnRfcGFydCBzXG4gICAgfCBfIC0+IGVuZF9leHBvbmVudF9wYXJ0IHN0cm1fX1xuICBhbmQgZW5kX2V4cG9uZW50X3BhcnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJzAnLi4nOScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBlbmRfZXhwb25lbnRfcGFydCBzXG4gICAgfCBfIC0+IFNvbWUgKEZsb2F0IChmbG9hdF9vZl9zdHJpbmcgKGdldF9zdHJpbmcgKCkpKSlcbiAgYW5kIHN0cmluZyAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICdcXFwiJyAtPiBTdHJlYW0uanVuayBzdHJtX187IGdldF9zdHJpbmcgKClcbiAgICB8IFNvbWUgJ1xcXFwnIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IGMgPVxuICAgICAgICAgIHRyeSBlc2NhcGUgc3RybV9fIHdpdGhcbiAgICAgICAgICAgIFN0cmVhbS5GYWlsdXJlIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgXCJcIilcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgc3RyaW5nIHNcbiAgICB8IFNvbWUgYyAtPiBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IHN0cmluZyBzXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGFuZCBjaGFyIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJ1xcXFwnIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgYmVnaW4gdHJ5IGVzY2FwZSBzdHJtX18gd2l0aFxuICAgICAgICAgIFN0cmVhbS5GYWlsdXJlIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgXCJcIilcbiAgICAgICAgZW5kXG4gICAgfCBTb21lIGMgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBjXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGFuZCBlc2NhcGUgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnbicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyAnXFxuJ1xuICAgIHwgU29tZSAncicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyAnXFxyJ1xuICAgIHwgU29tZSAndCcgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyAnXFx0J1xuICAgIHwgU29tZSAoJzAnLi4nOScgYXMgYzEpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgYmVnaW4gbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgICAgICBTb21lICgnMCcuLic5JyBhcyBjMikgLT5cbiAgICAgICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICAgICAgICAgIFNvbWUgKCcwJy4uJzknIGFzIGMzKSAtPlxuICAgICAgICAgICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgICAgICAgICBDaGFyLmNoclxuICAgICAgICAgICAgICAgICAgKChDaGFyLmNvZGUgYzEgLSA0OCkgKiAxMDAgKyAoQ2hhci5jb2RlIGMyIC0gNDgpICogMTAgK1xuICAgICAgICAgICAgICAgICAgICAgKENoYXIuY29kZSBjMyAtIDQ4KSlcbiAgICAgICAgICAgIHwgXyAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgfCBfIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgXCJcIilcbiAgICAgICAgZW5kXG4gICAgfCBTb21lIGMgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBjXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGFuZCBtYXliZV9jb21tZW50IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJyonIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gY29tbWVudCBzOyBuZXh0X3Rva2VuIHNcbiAgICB8IF8gLT4gU29tZSAoa2V5d29yZF9vcl9lcnJvciAnKCcpXG4gIGFuZCBjb21tZW50IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJygnIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgbWF5YmVfbmVzdGVkX2NvbW1lbnQgc3RybV9fXG4gICAgfCBTb21lICcqJyAtPiBTdHJlYW0uanVuayBzdHJtX187IG1heWJlX2VuZF9jb21tZW50IHN0cm1fX1xuICAgIHwgU29tZSBfIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgY29tbWVudCBzdHJtX19cbiAgICB8IF8gLT4gcmFpc2UgU3RyZWFtLkZhaWx1cmVcbiAgYW5kIG1heWJlX25lc3RlZF9jb21tZW50IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJyonIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gY29tbWVudCBzOyBjb21tZW50IHNcbiAgICB8IFNvbWUgXyAtPiBTdHJlYW0uanVuayBzdHJtX187IGNvbW1lbnQgc3RybV9fXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGFuZCBtYXliZV9lbmRfY29tbWVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICcpJyAtPiBTdHJlYW0uanVuayBzdHJtX187ICgpXG4gICAgfCBTb21lICcqJyAtPiBTdHJlYW0uanVuayBzdHJtX187IG1heWJlX2VuZF9jb21tZW50IHN0cm1fX1xuICAgIHwgU29tZSBfIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgY29tbWVudCBzdHJtX19cbiAgICB8IF8gLT4gcmFpc2UgU3RyZWFtLkZhaWx1cmVcbiAgaW5cbiAgZnVuIGlucHV0IC0+IFN0cmVhbS5mcm9tIChmdW4gX2NvdW50IC0+IG5leHRfdG9rZW4gaW5wdXQpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm1vZHVsZSB0eXBlIFNlZWRlZFMgPSBzaWdcbiAgaW5jbHVkZSBIYXNodGJsLlNlZWRlZFNcbiAgdmFsIGNsZWFuOiAnYSB0IC0+IHVuaXRcbiAgdmFsIHN0YXRzX2FsaXZlOiAnYSB0IC0+IEhhc2h0Ymwuc3RhdGlzdGljc1xuICAgICgqKiBzYW1lIGFzIHshc3RhdHN9IGJ1dCBvbmx5IGNvdW50IHRoZSBhbGl2ZSBiaW5kaW5ncyAqKVxuZW5kXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgaW5jbHVkZSBIYXNodGJsLlNcbiAgdmFsIGNsZWFuOiAnYSB0IC0+IHVuaXRcbiAgdmFsIHN0YXRzX2FsaXZlOiAnYSB0IC0+IEhhc2h0Ymwuc3RhdGlzdGljc1xuICAgICgqKiBzYW1lIGFzIHshc3RhdHN9IGJ1dCBvbmx5IGNvdW50IHRoZSBhbGl2ZSBiaW5kaW5ncyAqKVxuZW5kXG5cbm1vZHVsZSBHZW5IYXNoVGFibGUgPSBzdHJ1Y3RcblxuICB0eXBlIGVxdWFsID1cbiAgfCBFVHJ1ZSB8IEVGYWxzZVxuICB8IEVEZWFkICgqKiB0aGUgZ2FyYmFnZSBjb2xsZWN0b3IgcmVjbGFpbWVkIHRoZSBkYXRhICopXG5cbiAgbW9kdWxlIE1ha2VTZWVkZWQoSDogc2lnXG4gICAgdHlwZSB0XG4gICAgdHlwZSAnYSBjb250YWluZXJcbiAgICB2YWwgY3JlYXRlOiB0IC0+ICdhIC0+ICdhIGNvbnRhaW5lclxuICAgIHZhbCBoYXNoOiBpbnQgLT4gdCAtPiBpbnRcbiAgICB2YWwgZXF1YWw6ICdhIGNvbnRhaW5lciAtPiB0IC0+IGVxdWFsXG4gICAgdmFsIGdldF9kYXRhOiAnYSBjb250YWluZXIgLT4gJ2Egb3B0aW9uXG4gICAgdmFsIGdldF9rZXk6ICdhIGNvbnRhaW5lciAtPiB0IG9wdGlvblxuICAgIHZhbCBzZXRfa2V5X2RhdGE6ICdhIGNvbnRhaW5lciAtPiB0IC0+ICdhIC0+IHVuaXRcbiAgICB2YWwgY2hlY2tfa2V5OiAnYSBjb250YWluZXIgLT4gYm9vbFxuICBlbmQpIDogU2VlZGVkUyB3aXRoIHR5cGUga2V5ID0gSC50XG4gID0gc3RydWN0XG5cbiAgICB0eXBlICdhIHQgPVxuICAgICAgeyBtdXRhYmxlIHNpemU6IGludDsgICAgICAgICAgICAgICAgICAoKiBudW1iZXIgb2YgZW50cmllcyAqKVxuICAgICAgICBtdXRhYmxlIGRhdGE6ICdhIGJ1Y2tldGxpc3QgYXJyYXk7ICAoKiB0aGUgYnVja2V0cyAqKVxuICAgICAgICBtdXRhYmxlIHNlZWQ6IGludDsgICAgICAgICAgICAgICAgICAoKiBmb3IgcmFuZG9taXphdGlvbiAqKVxuICAgICAgICBpbml0aWFsX3NpemU6IGludDsgICAgICAgICAgICAgICAgICAoKiBpbml0aWFsIGFycmF5IHNpemUgKilcbiAgICAgIH1cblxuICAgIGFuZCAnYSBidWNrZXRsaXN0ID1cbiAgICB8IEVtcHR5XG4gICAgfCBDb25zIG9mIGludCAoKiBoYXNoIG9mIHRoZSBrZXkgKikgKiAnYSBILmNvbnRhaW5lciAqICdhIGJ1Y2tldGxpc3RcblxuICAgICgqKiB0aGUgaGFzaCBvZiB0aGUga2V5IGlzIGtlcHQgaW4gb3JkZXIgdG8gdGVzdCB0aGUgZXF1YWxpdHkgb2YgdGhlIGhhc2hcbiAgICAgIGJlZm9yZSB0aGUga2V5LiBTYW1lIHJlYXNvbiBhcyBmb3IgV2Vhay5NYWtlICopXG5cbiAgICB0eXBlIGtleSA9IEgudFxuXG4gICAgbGV0IHJlYyBwb3dlcl8yX2Fib3ZlIHggbiA9XG4gICAgICBpZiB4ID49IG4gdGhlbiB4XG4gICAgICBlbHNlIGlmIHggKiAyID4gU3lzLm1heF9hcnJheV9sZW5ndGggdGhlbiB4XG4gICAgICBlbHNlIHBvd2VyXzJfYWJvdmUgKHggKiAyKSBuXG5cbiAgICBsZXQgcHJuZyA9IGxhenkgKFJhbmRvbS5TdGF0ZS5tYWtlX3NlbGZfaW5pdCgpKVxuXG4gICAgbGV0IGNyZWF0ZSA/KHJhbmRvbSA9IChIYXNodGJsLmlzX3JhbmRvbWl6ZWQgKCkpKSBpbml0aWFsX3NpemUgPVxuICAgICAgbGV0IHMgPSBwb3dlcl8yX2Fib3ZlIDE2IGluaXRpYWxfc2l6ZSBpblxuICAgICAgbGV0IHNlZWQgPSBpZiByYW5kb20gdGhlbiBSYW5kb20uU3RhdGUuYml0cyAoTGF6eS5mb3JjZSBwcm5nKSBlbHNlIDAgaW5cbiAgICAgIHsgaW5pdGlhbF9zaXplID0gczsgc2l6ZSA9IDA7IHNlZWQgPSBzZWVkOyBkYXRhID0gQXJyYXkubWFrZSBzIEVtcHR5IH1cblxuICAgIGxldCBjbGVhciBoID1cbiAgICAgIGguc2l6ZSA8LSAwO1xuICAgICAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBoLmRhdGEgaW5cbiAgICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICAgIGguZGF0YS4oaSkgPC0gRW1wdHlcbiAgICAgIGRvbmVcblxuICAgIGxldCByZXNldCBoID1cbiAgICAgIGxldCBsZW4gPSBBcnJheS5sZW5ndGggaC5kYXRhIGluXG4gICAgICBpZiBsZW4gPSBoLmluaXRpYWxfc2l6ZSB0aGVuXG4gICAgICAgIGNsZWFyIGhcbiAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgaC5zaXplIDwtIDA7XG4gICAgICAgIGguZGF0YSA8LSBBcnJheS5tYWtlIGguaW5pdGlhbF9zaXplIEVtcHR5XG4gICAgICBlbmRcblxuICAgIGxldCBjb3B5IGggPSB7IGggd2l0aCBkYXRhID0gQXJyYXkuY29weSBoLmRhdGEgfVxuXG4gICAgbGV0IGtleV9pbmRleCBoIGhrZXkgPVxuICAgICAgaGtleSBsYW5kIChBcnJheS5sZW5ndGggaC5kYXRhIC0gMSlcblxuICAgIGxldCBjbGVhbiBoID1cbiAgICAgIGxldCByZWMgZG9fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgICAgRW1wdHlcbiAgICAgICAgfCBDb25zKF8sIGMsIHJlc3QpIHdoZW4gbm90IChILmNoZWNrX2tleSBjKSAtPlxuICAgICAgICAgICAgaC5zaXplIDwtIGguc2l6ZSAtIDE7XG4gICAgICAgICAgICBkb19idWNrZXQgcmVzdFxuICAgICAgICB8IENvbnMoaGtleSwgYywgcmVzdCkgLT5cbiAgICAgICAgICAgIENvbnMoaGtleSwgYywgZG9fYnVja2V0IHJlc3QpXG4gICAgICBpblxuICAgICAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgICAgZC4oaSkgPC0gZG9fYnVja2V0IGQuKGkpXG4gICAgICBkb25lXG5cbiAgICAoKiogcmVzaXplIGlzIHRoZSBvbmx5IGZ1bmN0aW9uIHRvIGRvIHRoZSBhY3R1YWwgY2xlYW5pbmcgb2YgZGVhZCBrZXlzXG4gICAgICAgIChyZW1vdmUgZG9lcyBpdCBqdXN0IGJlY2F1c2UgaXQgY291bGQpLlxuXG4gICAgICAgIFRoZSBnb2FsIGlzIHRvOlxuXG4gICAgICAgIC0gbm90IHJlc2l6ZSBpbmZpbml0ZWx5IHdoZW4gdGhlIGFjdHVhbCBudW1iZXIgb2YgYWxpdmUga2V5cyBpc1xuICAgICAgICBib3VuZGVkIGJ1dCBrZXlzIGFyZSBjb250aW51b3VzbHkgYWRkZWQuIFRoYXQgd291bGQgaGFwcGVuIGlmXG4gICAgICAgIHRoaXMgZnVuY3Rpb24gYWx3YXlzIHJlc2l6ZS5cbiAgICAgICAgLSBub3QgY2FsbCB0aGlzIGZ1bmN0aW9uIGFmdGVyIGVhY2ggYWRkaXRpb24sIHRoYXQgd291bGQgaGFwcGVuIGlmIHRoaXNcbiAgICAgICAgZnVuY3Rpb24gZG9uJ3QgcmVzaXplIGV2ZW4gd2hlbiBvbmx5IG9uZSBrZXkgaXMgZGVhZC5cblxuICAgICAgICBTbyB0aGUgYWxnb3JpdGhtOlxuICAgICAgICAtIGNsZWFuIHRoZSBrZXlzIGJlZm9yZSByZXNpemluZ1xuICAgICAgICAtIGlmIHRoZSBudW1iZXIgb2YgcmVtYWluaW5nIGtleXMgaXMgbGVzcyB0aGFuIGhhbGYgdGhlIHNpemUgb2YgdGhlXG4gICAgICAgIGFycmF5LCBkb24ndCByZXNpemUuXG4gICAgICAgIC0gaWYgaXQgaXMgbW9yZSwgcmVzaXplLlxuXG4gICAgICAgIFRoZSBzZWNvbmQgcHJvYmxlbSByZW1haW5zIGlmIHRoZSB0YWJsZSByZWFjaGVzIHshU3lzLm1heF9hcnJheV9sZW5ndGh9LlxuXG4gICAgKilcbiAgICBsZXQgcmVzaXplIGggPVxuICAgICAgbGV0IG9kYXRhID0gaC5kYXRhIGluXG4gICAgICBsZXQgb3NpemUgPSBBcnJheS5sZW5ndGggb2RhdGEgaW5cbiAgICAgIGxldCBuc2l6ZSA9IG9zaXplICogMiBpblxuICAgICAgY2xlYW4gaDtcbiAgICAgIGlmIG5zaXplIDwgU3lzLm1heF9hcnJheV9sZW5ndGggJiYgaC5zaXplID49IG9zaXplIGxzciAxIHRoZW4gYmVnaW5cbiAgICAgICAgbGV0IG5kYXRhID0gQXJyYXkubWFrZSBuc2l6ZSBFbXB0eSBpblxuICAgICAgICBoLmRhdGEgPC0gbmRhdGE7ICAgICAgICgqIHNvIHRoYXQga2V5X2luZGV4IHNlZXMgdGhlIG5ldyBidWNrZXQgY291bnQgKilcbiAgICAgICAgbGV0IHJlYyBpbnNlcnRfYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgICAgICAgIEVtcHR5IC0+ICgpXG4gICAgICAgICAgfCBDb25zKGhrZXksIGRhdGEsIHJlc3QpIC0+XG4gICAgICAgICAgICAgIGluc2VydF9idWNrZXQgcmVzdDsgKCogcHJlc2VydmUgb3JpZ2luYWwgb3JkZXIgb2YgZWxlbWVudHMgKilcbiAgICAgICAgICAgICAgbGV0IG5pZHggPSBrZXlfaW5kZXggaCBoa2V5IGluXG4gICAgICAgICAgICAgIG5kYXRhLihuaWR4KSA8LSBDb25zKGhrZXksIGRhdGEsIG5kYXRhLihuaWR4KSkgaW5cbiAgICAgICAgZm9yIGkgPSAwIHRvIG9zaXplIC0gMSBkb1xuICAgICAgICAgIGluc2VydF9idWNrZXQgb2RhdGEuKGkpXG4gICAgICAgIGRvbmVcbiAgICAgIGVuZFxuXG4gICAgbGV0IGFkZCBoIGtleSBpbmZvID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGggaGtleSBpblxuICAgICAgbGV0IGNvbnRhaW5lciA9IEguY3JlYXRlIGtleSBpbmZvIGluXG4gICAgICBsZXQgYnVja2V0ID0gQ29ucyhoa2V5LCBjb250YWluZXIsIGguZGF0YS4oaSkpIGluXG4gICAgICBoLmRhdGEuKGkpIDwtIGJ1Y2tldDtcbiAgICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgICAgaWYgaC5zaXplID4gQXJyYXkubGVuZ3RoIGguZGF0YSBsc2wgMSB0aGVuIHJlc2l6ZSBoXG5cbiAgICBsZXQgcmVtb3ZlIGgga2V5ID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgIGxldCByZWMgcmVtb3ZlX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT4gRW1wdHlcbiAgICAgICAgfCBDb25zKGhrLCBjLCBuZXh0KSB3aGVuIGhrZXkgPSBoayAtPlxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgICB8IEVUcnVlIC0+IGguc2l6ZSA8LSBoLnNpemUgLSAxOyBuZXh0XG4gICAgICAgICAgICB8IEVGYWxzZSAtPiBDb25zKGhrLCBjLCByZW1vdmVfYnVja2V0IG5leHQpXG4gICAgICAgICAgICB8IEVEZWFkIC0+XG4gICAgICAgICAgICAgICAgKCogVGhlIGRlYWQga2V5IGlzIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC4gSXQgaXMgYWNjZXB0YWJsZVxuICAgICAgICAgICAgICAgICAgICBmb3IgdGhpcyBmdW5jdGlvbiBzaW5jZSBpdCBhbHJlYWR5IHJlbW92ZXMgYSBiaW5kaW5nICopXG4gICAgICAgICAgICAgICAgaC5zaXplIDwtIGguc2l6ZSAtIDE7XG4gICAgICAgICAgICAgICAgcmVtb3ZlX2J1Y2tldCBuZXh0XG4gICAgICAgICAgICBlbmRcbiAgICAgICAgfCBDb25zKGhrLGMsbmV4dCkgLT4gQ29ucyhoaywgYywgcmVtb3ZlX2J1Y2tldCBuZXh0KSBpblxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBoa2V5IGluXG4gICAgICBoLmRhdGEuKGkpIDwtIHJlbW92ZV9idWNrZXQgaC5kYXRhLihpKVxuXG4gICAgKCoqIHshZmluZH0gZG9uJ3QgcmVtb3ZlIGRlYWQga2V5cyBiZWNhdXNlIGl0IHdvdWxkIGJlIHN1cnByaXNpbmcgZm9yXG4gICAgICAgIHRoZSB1c2VyIHRoYXQgYSByZWFkLW9ubHkgZnVuY3Rpb24gbXV0YXRlcyB0aGUgc3RhdGUgKGVnLiBjb25jdXJyZW50XG4gICAgICAgIGFjY2VzcykuIFNhbWUgZm9yIHshaXRlcn0sIHshZm9sZH0sIHshbWVtfS5cbiAgICAqKVxuICAgIGxldCByZWMgZmluZF9yZWMga2V5IGhrZXkgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBDb25zKGhrLCBjLCByZXN0KSB3aGVuIGhrZXkgPSBoayAgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICB8IEVUcnVlIC0+XG4gICAgICAgICAgICAgIGJlZ2luIG1hdGNoIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgICAgKCogVGhpcyBjYXNlIGlzIG5vdCBpbXBvc3NpYmxlIGJlY2F1c2UgdGhlIGdjIGNhbiBydW4gYmV0d2VlblxuICAgICAgICAgICAgICAgICAgICAgIEguZXF1YWwgYW5kIEguZ2V0X2RhdGEgKilcbiAgICAgICAgICAgICAgICAgIGZpbmRfcmVjIGtleSBoa2V5IHJlc3RcbiAgICAgICAgICAgICAgfCBTb21lIGQgLT4gZFxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICB8IEVGYWxzZSAtPiBmaW5kX3JlYyBrZXkgaGtleSByZXN0XG4gICAgICAgICAgfCBFRGVhZCAtPlxuICAgICAgICAgICAgICBmaW5kX3JlYyBrZXkgaGtleSByZXN0XG4gICAgICAgICAgZW5kXG4gICAgICB8IENvbnMoXywgXywgcmVzdCkgLT5cbiAgICAgICAgICBmaW5kX3JlYyBrZXkgaGtleSByZXN0XG5cbiAgICBsZXQgZmluZCBoIGtleSA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICAoKiBUT0RPIGlubGluZSAzIGl0ZXJhdGlvbnMgKilcbiAgICAgIGZpbmRfcmVjIGtleSBoa2V5IChoLmRhdGEuKGtleV9pbmRleCBoIGhrZXkpKVxuXG4gICAgbGV0IHJlYyBmaW5kX3JlY19vcHQga2V5IGhrZXkgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgQ29ucyhoaywgYywgcmVzdCkgd2hlbiBoa2V5ID0gaGsgIC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgfCBFVHJ1ZSAtPlxuICAgICAgICAgICAgICBiZWdpbiBtYXRjaCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgICgqIFRoaXMgY2FzZSBpcyBub3QgaW1wb3NzaWJsZSBiZWNhdXNlIHRoZSBnYyBjYW4gcnVuIGJldHdlZW5cbiAgICAgICAgICAgICAgICAgICAgICBILmVxdWFsIGFuZCBILmdldF9kYXRhICopXG4gICAgICAgICAgICAgICAgICBmaW5kX3JlY19vcHQga2V5IGhrZXkgcmVzdFxuICAgICAgICAgICAgICB8IFNvbWUgXyBhcyBkIC0+IGRcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgfCBFRmFsc2UgLT4gZmluZF9yZWNfb3B0IGtleSBoa2V5IHJlc3RcbiAgICAgICAgICB8IEVEZWFkIC0+XG4gICAgICAgICAgICAgIGZpbmRfcmVjX29wdCBrZXkgaGtleSByZXN0XG4gICAgICAgICAgZW5kXG4gICAgICB8IENvbnMoXywgXywgcmVzdCkgLT5cbiAgICAgICAgICBmaW5kX3JlY19vcHQga2V5IGhrZXkgcmVzdFxuXG4gICAgbGV0IGZpbmRfb3B0IGgga2V5ID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgICgqIFRPRE8gaW5saW5lIDMgaXRlcmF0aW9ucyAqKVxuICAgICAgZmluZF9yZWNfb3B0IGtleSBoa2V5IChoLmRhdGEuKGtleV9pbmRleCBoIGhrZXkpKVxuXG4gICAgbGV0IGZpbmRfYWxsIGgga2V5ID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgIGxldCByZWMgZmluZF9pbl9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBbXVxuICAgICAgfCBDb25zKGhrLCBjLCByZXN0KSB3aGVuIGhrZXkgPSBoayAgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICB8IEVUcnVlIC0+IGJlZ2luIG1hdGNoIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgICAgZmluZF9pbl9idWNrZXQgcmVzdFxuICAgICAgICAgICAgICB8IFNvbWUgZCAtPiBkOjpmaW5kX2luX2J1Y2tldCByZXN0XG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICB8IEVGYWxzZSAtPiBmaW5kX2luX2J1Y2tldCByZXN0XG4gICAgICAgICAgfCBFRGVhZCAtPlxuICAgICAgICAgICAgICBmaW5kX2luX2J1Y2tldCByZXN0XG4gICAgICAgICAgZW5kXG4gICAgICB8IENvbnMoXywgXywgcmVzdCkgLT5cbiAgICAgICAgICBmaW5kX2luX2J1Y2tldCByZXN0IGluXG4gICAgICBmaW5kX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGhrZXkpXG5cblxuICAgIGxldCByZXBsYWNlIGgga2V5IGluZm8gPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgbGV0IHJlYyByZXBsYWNlX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgIHwgQ29ucyhoaywgYywgbmV4dCkgd2hlbiBoa2V5ID0gaGsgLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgICAgfCBFVHJ1ZSAtPiBILnNldF9rZXlfZGF0YSBjIGtleSBpbmZvXG4gICAgICAgICAgICB8IEVGYWxzZSB8IEVEZWFkIC0+IHJlcGxhY2VfYnVja2V0IG5leHRcbiAgICAgICAgICAgIGVuZFxuICAgICAgICB8IENvbnMoXyxfLG5leHQpIC0+IHJlcGxhY2VfYnVja2V0IG5leHRcbiAgICAgIGluXG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGhrZXkgaW5cbiAgICAgIGxldCBsID0gaC5kYXRhLihpKSBpblxuICAgICAgdHJ5XG4gICAgICAgIHJlcGxhY2VfYnVja2V0IGxcbiAgICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgIGxldCBjb250YWluZXIgPSBILmNyZWF0ZSBrZXkgaW5mbyBpblxuICAgICAgICBoLmRhdGEuKGkpIDwtIENvbnMoaGtleSwgY29udGFpbmVyLCBsKTtcbiAgICAgICAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gICAgICAgIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUgaFxuXG4gICAgbGV0IG1lbSBoIGtleSA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICBsZXQgcmVjIG1lbV9pbl9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIGZhbHNlXG4gICAgICB8IENvbnMoaGssIGMsIHJlc3QpIHdoZW4gaGsgPSBoa2V5IC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgfCBFVHJ1ZSAtPiB0cnVlXG4gICAgICAgICAgfCBFRmFsc2UgfCBFRGVhZCAtPiBtZW1faW5fYnVja2V0IHJlc3RcbiAgICAgICAgICBlbmRcbiAgICAgIHwgQ29ucyhfaGssIF9jLCByZXN0KSAtPiBtZW1faW5fYnVja2V0IHJlc3QgaW5cbiAgICAgIG1lbV9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBoa2V5KVxuXG4gICAgbGV0IGl0ZXIgZiBoID1cbiAgICAgIGxldCByZWMgZG9fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgICAgKClcbiAgICAgICAgfCBDb25zKF8sIGMsIHJlc3QpIC0+XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBILmdldF9rZXkgYywgSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSwgXyB8IF8sIE5vbmUgLT4gKClcbiAgICAgICAgICAgIHwgU29tZSBrLCBTb21lIGQgLT4gZiBrIGRcbiAgICAgICAgICAgIGVuZDsgZG9fYnVja2V0IHJlc3QgaW5cbiAgICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICAgIGRvX2J1Y2tldCBkLihpKVxuICAgICAgZG9uZVxuXG4gICAgbGV0IGZvbGQgZiBoIGluaXQgPVxuICAgICAgbGV0IHJlYyBkb19idWNrZXQgYiBhY2N1ID1cbiAgICAgICAgbWF0Y2ggYiB3aXRoXG4gICAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICAgIGFjY3VcbiAgICAgICAgfCBDb25zKF8sIGMsIHJlc3QpIC0+XG4gICAgICAgICAgICBsZXQgYWNjdSA9IGJlZ2luIG1hdGNoIEguZ2V0X2tleSBjLCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUsIF8gfCBfLCBOb25lIC0+IGFjY3VcbiAgICAgICAgICAgICAgfCBTb21lIGssIFNvbWUgZCAtPiBmIGsgZCBhY2N1XG4gICAgICAgICAgICBlbmQgaW5cbiAgICAgICAgICAgIGRvX2J1Y2tldCByZXN0IGFjY3UgIGluXG4gICAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgICAgbGV0IGFjY3UgPSByZWYgaW5pdCBpblxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgICBhY2N1IDo9IGRvX2J1Y2tldCBkLihpKSAhYWNjdVxuICAgICAgZG9uZTtcbiAgICAgICFhY2N1XG5cbiAgICBsZXQgZmlsdGVyX21hcF9pbnBsYWNlIGYgaCA9XG4gICAgICBsZXQgcmVjIGRvX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICAgIEVtcHR5XG4gICAgICAgIHwgQ29ucyhoaywgYywgcmVzdCkgLT5cbiAgICAgICAgICAgIG1hdGNoIEguZ2V0X2tleSBjLCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgfCBOb25lLCBfIHwgXywgTm9uZSAtPlxuICAgICAgICAgICAgICAgIGRvX2J1Y2tldCByZXN0XG4gICAgICAgICAgICB8IFNvbWUgaywgU29tZSBkIC0+XG4gICAgICAgICAgICAgICAgbWF0Y2ggZiBrIGQgd2l0aFxuICAgICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgICAgICBkb19idWNrZXQgcmVzdFxuICAgICAgICAgICAgICAgIHwgU29tZSBuZXdfZCAtPlxuICAgICAgICAgICAgICAgICAgICBILnNldF9rZXlfZGF0YSBjIGsgbmV3X2Q7XG4gICAgICAgICAgICAgICAgICAgIENvbnMoaGssIGMsIGRvX2J1Y2tldCByZXN0KVxuICAgICAgaW5cbiAgICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICAgIGQuKGkpIDwtIGRvX2J1Y2tldCBkLihpKVxuICAgICAgZG9uZVxuXG4gICAgbGV0IGxlbmd0aCBoID0gaC5zaXplXG5cbiAgICBsZXQgcmVjIGJ1Y2tldF9sZW5ndGggYWNjdSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgQ29ucyhfLCBfLCByZXN0KSAtPiBidWNrZXRfbGVuZ3RoIChhY2N1ICsgMSkgcmVzdFxuXG4gICAgbGV0IHN0YXRzIGggPVxuICAgICAgbGV0IG1ibCA9XG4gICAgICAgIEFycmF5LmZvbGRfbGVmdCAoZnVuIG0gYiAtPiBtYXggbSAoYnVja2V0X2xlbmd0aCAwIGIpKSAwIGguZGF0YSBpblxuICAgICAgbGV0IGhpc3RvID0gQXJyYXkubWFrZSAobWJsICsgMSkgMCBpblxuICAgICAgQXJyYXkuaXRlclxuICAgICAgICAoZnVuIGIgLT5cbiAgICAgICAgICAgbGV0IGwgPSBidWNrZXRfbGVuZ3RoIDAgYiBpblxuICAgICAgICAgICBoaXN0by4obCkgPC0gaGlzdG8uKGwpICsgMSlcbiAgICAgICAgaC5kYXRhO1xuICAgICAgeyBIYXNodGJsLm51bV9iaW5kaW5ncyA9IGguc2l6ZTtcbiAgICAgICAgbnVtX2J1Y2tldHMgPSBBcnJheS5sZW5ndGggaC5kYXRhO1xuICAgICAgICBtYXhfYnVja2V0X2xlbmd0aCA9IG1ibDtcbiAgICAgICAgYnVja2V0X2hpc3RvZ3JhbSA9IGhpc3RvIH1cblxuICAgIGxldCByZWMgYnVja2V0X2xlbmd0aF9hbGl2ZSBhY2N1ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBDb25zKF8sIGMsIHJlc3QpIHdoZW4gSC5jaGVja19rZXkgYyAtPlxuICAgICAgICAgIGJ1Y2tldF9sZW5ndGhfYWxpdmUgKGFjY3UgKyAxKSByZXN0XG4gICAgICB8IENvbnMoXywgXywgcmVzdCkgLT4gYnVja2V0X2xlbmd0aF9hbGl2ZSBhY2N1IHJlc3RcblxuICAgIGxldCBzdGF0c19hbGl2ZSBoID1cbiAgICAgIGxldCBzaXplID0gcmVmIDAgaW5cbiAgICAgIGxldCBtYmwgPVxuICAgICAgICBBcnJheS5mb2xkX2xlZnQgKGZ1biBtIGIgLT4gbWF4IG0gKGJ1Y2tldF9sZW5ndGhfYWxpdmUgMCBiKSkgMCBoLmRhdGEgaW5cbiAgICAgIGxldCBoaXN0byA9IEFycmF5Lm1ha2UgKG1ibCArIDEpIDAgaW5cbiAgICAgIEFycmF5Lml0ZXJcbiAgICAgICAgKGZ1biBiIC0+XG4gICAgICAgICAgIGxldCBsID0gYnVja2V0X2xlbmd0aF9hbGl2ZSAwIGIgaW5cbiAgICAgICAgICAgc2l6ZSA6PSAhc2l6ZSArIGw7XG4gICAgICAgICAgIGhpc3RvLihsKSA8LSBoaXN0by4obCkgKyAxKVxuICAgICAgICBoLmRhdGE7XG4gICAgICB7IEhhc2h0YmwubnVtX2JpbmRpbmdzID0gIXNpemU7XG4gICAgICAgIG51bV9idWNrZXRzID0gQXJyYXkubGVuZ3RoIGguZGF0YTtcbiAgICAgICAgbWF4X2J1Y2tldF9sZW5ndGggPSBtYmw7XG4gICAgICAgIGJ1Y2tldF9oaXN0b2dyYW0gPSBoaXN0byB9XG5cblxuICBlbmRcbmVuZFxuXG5tb2R1bGUgT2JqRXBoID0gT2JqLkVwaGVtZXJvblxuXG5sZXQgX29ial9vcHQgOiBPYmoudCBvcHRpb24gLT4gJ2Egb3B0aW9uID0gZnVuIHggLT5cbiAgbWF0Y2ggeCB3aXRoXG4gIHwgTm9uZSAtPiB4XG4gIHwgU29tZSB2IC0+IFNvbWUgKE9iai5vYmogdilcblxuKCoqIFRoZSBwcmV2aW91cyBmdW5jdGlvbiBpcyB0eXBlZCBzbyB0aGlzIG9uZSBpcyBhbHNvIGNvcnJlY3QgKilcbmxldCBvYmpfb3B0IDogT2JqLnQgb3B0aW9uIC0+ICdhIG9wdGlvbiA9IGZ1biB4IC0+IE9iai5tYWdpYyB4XG5cblxubW9kdWxlIEsxID0gc3RydWN0XG4gIHR5cGUgKCdrLCdkKSB0ID0gT2JqRXBoLnRcblxuICBsZXQgY3JlYXRlICgpIDogKCdrLCdkKSB0ID0gT2JqRXBoLmNyZWF0ZSAxXG5cbiAgbGV0IGdldF9rZXkgKHQ6KCdrLCdkKSB0KSA6ICdrIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfa2V5IHQgMClcbiAgbGV0IGdldF9rZXlfY29weSAodDooJ2ssJ2QpIHQpIDogJ2sgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9rZXlfY29weSB0IDApXG4gIGxldCBzZXRfa2V5ICh0OignaywnZCkgdCkgKGs6J2spIDogdW5pdCA9IE9iakVwaC5zZXRfa2V5IHQgMCAoT2JqLnJlcHIgaylcbiAgbGV0IHVuc2V0X2tleSAodDooJ2ssJ2QpIHQpIDogdW5pdCA9IE9iakVwaC51bnNldF9rZXkgdCAwXG4gIGxldCBjaGVja19rZXkgKHQ6KCdrLCdkKSB0KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfa2V5IHQgMFxuXG4gIGxldCBibGl0X2tleSAodDE6KCdrLCdkKSB0KSAodDI6KCdrLCdkKSB0KTogdW5pdCA9XG4gICAgT2JqRXBoLmJsaXRfa2V5IHQxIDAgdDIgMCAxXG5cbiAgbGV0IGdldF9kYXRhICh0OignaywnZCkgdCkgOiAnZCBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2RhdGEgdClcbiAgbGV0IGdldF9kYXRhX2NvcHkgKHQ6KCdrLCdkKSB0KSA6ICdkIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfZGF0YV9jb3B5IHQpXG4gIGxldCBzZXRfZGF0YSAodDooJ2ssJ2QpIHQpIChkOidkKSA6IHVuaXQgPSBPYmpFcGguc2V0X2RhdGEgdCAoT2JqLnJlcHIgZClcbiAgbGV0IHVuc2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfZGF0YSB0XG4gIGxldCBjaGVja19kYXRhICh0OignaywnZCkgdCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2RhdGEgdFxuICBsZXQgYmxpdF9kYXRhICh0MTooXywnZCkgdCkgKHQyOihfLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGguYmxpdF9kYXRhIHQxIHQyXG5cbiAgbW9kdWxlIE1ha2VTZWVkZWQgKEg6SGFzaHRibC5TZWVkZWRIYXNoZWRUeXBlKSA9XG4gICAgR2VuSGFzaFRhYmxlLk1ha2VTZWVkZWQoc3RydWN0XG4gICAgICB0eXBlICdhIGNvbnRhaW5lciA9IChILnQsJ2EpIHRcbiAgICAgIHR5cGUgdCA9IEgudFxuICAgICAgbGV0IGNyZWF0ZSBrIGQgPVxuICAgICAgICBsZXQgYyA9IGNyZWF0ZSAoKSBpblxuICAgICAgICBzZXRfZGF0YSBjIGQ7XG4gICAgICAgIHNldF9rZXkgYyBrO1xuICAgICAgICBjXG4gICAgICBsZXQgaGFzaCA9IEguaGFzaFxuICAgICAgbGV0IGVxdWFsIGMgayA9XG4gICAgICAgICgqIHshZ2V0X2tleV9jb3B5fSBpcyBub3QgdXNlZCBiZWNhdXNlIHRoZSBlcXVhbGl0eSBvZiB0aGUgdXNlciBjYW4gYmVcbiAgICAgICAgICAgIHRoZSBwaHlzaWNhbCBlcXVhbGl0eSAqKVxuICAgICAgICBtYXRjaCBnZXRfa2V5IGMgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gR2VuSGFzaFRhYmxlLkVEZWFkXG4gICAgICAgIHwgU29tZSBrJyAtPlxuICAgICAgICAgICAgaWYgSC5lcXVhbCBrIGsnIHRoZW4gR2VuSGFzaFRhYmxlLkVUcnVlIGVsc2UgR2VuSGFzaFRhYmxlLkVGYWxzZVxuICAgICAgbGV0IGdldF9kYXRhID0gZ2V0X2RhdGFcbiAgICAgIGxldCBnZXRfa2V5ID0gZ2V0X2tleVxuICAgICAgbGV0IHNldF9rZXlfZGF0YSBjIGsgZCA9XG4gICAgICAgIHVuc2V0X2RhdGEgYztcbiAgICAgICAgc2V0X2tleSBjIGs7XG4gICAgICAgIHNldF9kYXRhIGMgZFxuICAgICAgbGV0IGNoZWNrX2tleSA9IGNoZWNrX2tleVxuICAgIGVuZClcblxuICBtb2R1bGUgTWFrZShIOiBIYXNodGJsLkhhc2hlZFR5cGUpOiAoUyB3aXRoIHR5cGUga2V5ID0gSC50KSA9XG4gIHN0cnVjdFxuICAgIGluY2x1ZGUgTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gSC50XG4gICAgICAgIGxldCBlcXVhbCA9IEguZXF1YWxcbiAgICAgICAgbGV0IGhhc2ggKF9zZWVkOiBpbnQpIHggPSBILmhhc2ggeFxuICAgICAgZW5kKVxuICAgIGxldCBjcmVhdGUgc3ogPSBjcmVhdGUgfnJhbmRvbTpmYWxzZSBzelxuICBlbmRcblxuZW5kXG5cbm1vZHVsZSBLMiA9IHN0cnVjdFxuICB0eXBlICgnazEsICdrMiwgJ2QpIHQgPSBPYmpFcGgudFxuXG4gIGxldCBjcmVhdGUgKCkgOiAoJ2sxLCdrMiwnZCkgdCA9IE9iakVwaC5jcmVhdGUgMlxuXG4gIGxldCBnZXRfa2V5MSAodDooJ2sxLCdrMiwnZCkgdCkgOiAnazEgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9rZXkgdCAwKVxuICBsZXQgZ2V0X2tleTFfY29weSAodDooJ2sxLCdrMiwnZCkgdCkgOiAnazEgb3B0aW9uID1cbiAgICBvYmpfb3B0IChPYmpFcGguZ2V0X2tleV9jb3B5IHQgMClcbiAgbGV0IHNldF9rZXkxICh0OignazEsJ2syLCdkKSB0KSAoazonazEpIDogdW5pdCA9XG4gICAgT2JqRXBoLnNldF9rZXkgdCAwIChPYmoucmVwciBrKVxuICBsZXQgdW5zZXRfa2V5MSAodDooJ2sxLCdrMiwnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2tleSB0IDBcbiAgbGV0IGNoZWNrX2tleTEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19rZXkgdCAwXG5cbiAgbGV0IGdldF9rZXkyICh0OignazEsJ2syLCdkKSB0KSA6ICdrMiBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2tleSB0IDEpXG4gIGxldCBnZXRfa2V5Ml9jb3B5ICh0OignazEsJ2syLCdkKSB0KSA6ICdrMiBvcHRpb24gPVxuICAgIG9ial9vcHQgKE9iakVwaC5nZXRfa2V5X2NvcHkgdCAxKVxuICBsZXQgc2V0X2tleTIgKHQ6KCdrMSwnazIsJ2QpIHQpIChrOidrMikgOiB1bml0ID1cbiAgICBPYmpFcGguc2V0X2tleSB0IDEgKE9iai5yZXByIGspXG4gIGxldCB1bnNldF9rZXkyICh0OignazEsJ2syLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfa2V5IHQgMVxuICBsZXQgY2hlY2tfa2V5MiAodDooJ2sxLCdrMiwnZCkgdCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2tleSB0IDFcblxuXG4gIGxldCBibGl0X2tleTEgKHQxOignazEsXyxfKSB0KSAodDI6KCdrMSxfLF8pIHQpIDogdW5pdCA9XG4gICAgT2JqRXBoLmJsaXRfa2V5IHQxIDAgdDIgMCAxXG4gIGxldCBibGl0X2tleTIgKHQxOihfLCdrMixfKSB0KSAodDI6KF8sJ2syLF8pIHQpIDogdW5pdCA9XG4gICAgT2JqRXBoLmJsaXRfa2V5IHQxIDEgdDIgMSAxXG4gIGxldCBibGl0X2tleTEyICh0MTooJ2sxLCdrMixfKSB0KSAodDI6KCdrMSwnazIsXykgdCkgOiB1bml0ID1cbiAgICBPYmpFcGguYmxpdF9rZXkgdDEgMCB0MiAwIDJcblxuICBsZXQgZ2V0X2RhdGEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogJ2Qgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhIHQpXG4gIGxldCBnZXRfZGF0YV9jb3B5ICh0OignazEsJ2syLCdkKSB0KSA6ICdkIG9wdGlvbiA9XG4gICAgb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhX2NvcHkgdClcbiAgbGV0IHNldF9kYXRhICh0OignazEsJ2syLCdkKSB0KSAoZDonZCkgOiB1bml0ID1cbiAgICBPYmpFcGguc2V0X2RhdGEgdCAoT2JqLnJlcHIgZClcbiAgbGV0IHVuc2V0X2RhdGEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogdW5pdCA9IE9iakVwaC51bnNldF9kYXRhIHRcbiAgbGV0IGNoZWNrX2RhdGEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19kYXRhIHRcbiAgbGV0IGJsaXRfZGF0YSAodDE6KF8sXywnZCkgdCkgKHQyOihfLF8sJ2QpIHQpIDogdW5pdCA9IE9iakVwaC5ibGl0X2RhdGEgdDEgdDJcblxuICBtb2R1bGUgTWFrZVNlZWRlZFxuICAgICAgKEgxOkhhc2h0YmwuU2VlZGVkSGFzaGVkVHlwZSlcbiAgICAgIChIMjpIYXNodGJsLlNlZWRlZEhhc2hlZFR5cGUpID1cbiAgICBHZW5IYXNoVGFibGUuTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgY29udGFpbmVyID0gKEgxLnQsSDIudCwnYSkgdFxuICAgICAgdHlwZSB0ID0gSDEudCAqIEgyLnRcbiAgICAgIGxldCBjcmVhdGUgKGsxLGsyKSBkID1cbiAgICAgICAgbGV0IGMgPSBjcmVhdGUgKCkgaW5cbiAgICAgICAgc2V0X2RhdGEgYyBkO1xuICAgICAgICBzZXRfa2V5MSBjIGsxOyBzZXRfa2V5MiBjIGsyO1xuICAgICAgICBjXG4gICAgICBsZXQgaGFzaCBzZWVkIChrMSxrMikgPVxuICAgICAgICBIMS5oYXNoIHNlZWQgazEgKyBIMi5oYXNoIHNlZWQgazIgKiA2NTU5OVxuICAgICAgbGV0IGVxdWFsIGMgKGsxLGsyKSA9XG4gICAgICAgIG1hdGNoIGdldF9rZXkxIGMsIGdldF9rZXkyIGMgd2l0aFxuICAgICAgICB8IE5vbmUsIF8gfCBfICwgTm9uZSAtPiBHZW5IYXNoVGFibGUuRURlYWRcbiAgICAgICAgfCBTb21lIGsxJywgU29tZSBrMicgLT5cbiAgICAgICAgICAgIGlmIEgxLmVxdWFsIGsxIGsxJyAmJiBIMi5lcXVhbCBrMiBrMidcbiAgICAgICAgICAgIHRoZW4gR2VuSGFzaFRhYmxlLkVUcnVlIGVsc2UgR2VuSGFzaFRhYmxlLkVGYWxzZVxuICAgICAgbGV0IGdldF9kYXRhID0gZ2V0X2RhdGFcbiAgICAgIGxldCBnZXRfa2V5IGMgPVxuICAgICAgICBtYXRjaCBnZXRfa2V5MSBjLCBnZXRfa2V5MiBjIHdpdGhcbiAgICAgICAgfCBOb25lLCBfIHwgXyAsIE5vbmUgLT4gTm9uZVxuICAgICAgICB8IFNvbWUgazEnLCBTb21lIGsyJyAtPiBTb21lIChrMScsIGsyJylcbiAgICAgIGxldCBzZXRfa2V5X2RhdGEgYyAoazEsazIpIGQgPVxuICAgICAgICB1bnNldF9kYXRhIGM7XG4gICAgICAgIHNldF9rZXkxIGMgazE7IHNldF9rZXkyIGMgazI7XG4gICAgICAgIHNldF9kYXRhIGMgZFxuICAgICAgbGV0IGNoZWNrX2tleSBjID0gY2hlY2tfa2V5MSBjICYmIGNoZWNrX2tleTIgY1xuICAgIGVuZClcblxuICBtb2R1bGUgTWFrZShIMTogSGFzaHRibC5IYXNoZWRUeXBlKShIMjogSGFzaHRibC5IYXNoZWRUeXBlKTpcbiAgICAoUyB3aXRoIHR5cGUga2V5ID0gSDEudCAqIEgyLnQpID1cbiAgc3RydWN0XG4gICAgaW5jbHVkZSBNYWtlU2VlZGVkXG4gICAgICAgIChzdHJ1Y3RcbiAgICAgICAgICB0eXBlIHQgPSBIMS50XG4gICAgICAgICAgbGV0IGVxdWFsID0gSDEuZXF1YWxcbiAgICAgICAgICBsZXQgaGFzaCAoX3NlZWQ6IGludCkgeCA9IEgxLmhhc2ggeFxuICAgICAgICBlbmQpXG4gICAgICAgIChzdHJ1Y3RcbiAgICAgICAgICB0eXBlIHQgPSBIMi50XG4gICAgICAgICAgbGV0IGVxdWFsID0gSDIuZXF1YWxcbiAgICAgICAgICBsZXQgaGFzaCAoX3NlZWQ6IGludCkgeCA9IEgyLmhhc2ggeFxuICAgICAgICBlbmQpXG4gICAgbGV0IGNyZWF0ZSBzeiA9IGNyZWF0ZSB+cmFuZG9tOmZhbHNlIHN6XG4gIGVuZFxuXG5lbmRcblxubW9kdWxlIEtuID0gc3RydWN0XG4gIHR5cGUgKCdrLCdkKSB0ID0gT2JqRXBoLnRcblxuICBsZXQgY3JlYXRlIG4gOiAoJ2ssJ2QpIHQgPSBPYmpFcGguY3JlYXRlIG5cbiAgbGV0IGxlbmd0aCAoazooJ2ssJ2QpIHQpIDogaW50ID0gT2JqRXBoLmxlbmd0aCBrXG5cbiAgbGV0IGdldF9rZXkgKHQ6KCdrLCdkKSB0KSAobjppbnQpIDogJ2sgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9rZXkgdCBuKVxuICBsZXQgZ2V0X2tleV9jb3B5ICh0OignaywnZCkgdCkgKG46aW50KSA6ICdrIG9wdGlvbiA9XG4gICAgb2JqX29wdCAoT2JqRXBoLmdldF9rZXlfY29weSB0IG4pXG4gIGxldCBzZXRfa2V5ICh0OignaywnZCkgdCkgKG46aW50KSAoazonaykgOiB1bml0ID1cbiAgICBPYmpFcGguc2V0X2tleSB0IG4gKE9iai5yZXByIGspXG4gIGxldCB1bnNldF9rZXkgKHQ6KCdrLCdkKSB0KSAobjppbnQpIDogdW5pdCA9IE9iakVwaC51bnNldF9rZXkgdCBuXG4gIGxldCBjaGVja19rZXkgKHQ6KCdrLCdkKSB0KSAobjppbnQpIDogYm9vbCA9IE9iakVwaC5jaGVja19rZXkgdCBuXG5cbiAgbGV0IGJsaXRfa2V5ICh0MTooJ2ssJ2QpIHQpIChvMTppbnQpICh0MjooJ2ssJ2QpIHQpIChvMjppbnQpIChsOmludCkgOiB1bml0ID1cbiAgICBPYmpFcGguYmxpdF9rZXkgdDEgbzEgdDIgbzIgbFxuXG4gIGxldCBnZXRfZGF0YSAodDooJ2ssJ2QpIHQpIDogJ2Qgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhIHQpXG4gIGxldCBnZXRfZGF0YV9jb3B5ICh0OignaywnZCkgdCkgOiAnZCBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2RhdGFfY29weSB0KVxuICBsZXQgc2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSAoZDonZCkgOiB1bml0ID0gT2JqRXBoLnNldF9kYXRhIHQgKE9iai5yZXByIGQpXG4gIGxldCB1bnNldF9kYXRhICh0OignaywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2RhdGEgdFxuICBsZXQgY2hlY2tfZGF0YSAodDooJ2ssJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19kYXRhIHRcbiAgbGV0IGJsaXRfZGF0YSAodDE6KF8sJ2QpIHQpICh0MjooXywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLmJsaXRfZGF0YSB0MSB0MlxuXG4gIG1vZHVsZSBNYWtlU2VlZGVkIChIOkhhc2h0YmwuU2VlZGVkSGFzaGVkVHlwZSkgPVxuICAgIEdlbkhhc2hUYWJsZS5NYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgdHlwZSAnYSBjb250YWluZXIgPSAoSC50LCdhKSB0XG4gICAgICB0eXBlIHQgPSBILnQgYXJyYXlcbiAgICAgIGxldCBjcmVhdGUgayBkID1cbiAgICAgICAgbGV0IGMgPSBjcmVhdGUgKEFycmF5Lmxlbmd0aCBrKSBpblxuICAgICAgICBzZXRfZGF0YSBjIGQ7XG4gICAgICAgIGZvciBpPTAgdG8gQXJyYXkubGVuZ3RoIGsgLTEgZG9cbiAgICAgICAgICBzZXRfa2V5IGMgaSBrLihpKTtcbiAgICAgICAgZG9uZTtcbiAgICAgICAgY1xuICAgICAgbGV0IGhhc2ggc2VlZCBrID1cbiAgICAgICAgbGV0IGggPSByZWYgMCBpblxuICAgICAgICBmb3IgaT0wIHRvIEFycmF5Lmxlbmd0aCBrIC0xIGRvXG4gICAgICAgICAgaCA6PSBILmhhc2ggc2VlZCBrLihpKSAqIDY1NTk5ICsgIWg7XG4gICAgICAgIGRvbmU7XG4gICAgICAgICFoXG4gICAgICBsZXQgZXF1YWwgYyBrID1cbiAgICAgICAgbGV0IGxlbiAgPSBBcnJheS5sZW5ndGggayBpblxuICAgICAgICBsZXQgbGVuJyA9IGxlbmd0aCBjIGluXG4gICAgICAgIGlmIGxlbiAhPSBsZW4nIHRoZW4gR2VuSGFzaFRhYmxlLkVGYWxzZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbGV0IHJlYyBlcXVhbF9hcnJheSBrIGMgaSA9XG4gICAgICAgICAgICBpZiBpIDwgMCB0aGVuIEdlbkhhc2hUYWJsZS5FVHJ1ZVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBtYXRjaCBnZXRfa2V5IGMgaSB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBHZW5IYXNoVGFibGUuRURlYWRcbiAgICAgICAgICAgICAgfCBTb21lIGtpIC0+XG4gICAgICAgICAgICAgICAgICBpZiBILmVxdWFsIGsuKGkpIGtpXG4gICAgICAgICAgICAgICAgICB0aGVuIGVxdWFsX2FycmF5IGsgYyAoaS0xKVxuICAgICAgICAgICAgICAgICAgZWxzZSBHZW5IYXNoVGFibGUuRUZhbHNlXG4gICAgICAgICAgaW5cbiAgICAgICAgICBlcXVhbF9hcnJheSBrIGMgKGxlbi0xKVxuICAgICAgbGV0IGdldF9kYXRhID0gZ2V0X2RhdGFcbiAgICAgIGxldCBnZXRfa2V5IGMgPVxuICAgICAgICBsZXQgbGVuID0gbGVuZ3RoIGMgaW5cbiAgICAgICAgaWYgbGVuID0gMCB0aGVuIFNvbWUgW3x8XVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbWF0Y2ggZ2V0X2tleSBjIDAgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICAgICAgfCBTb21lIGswIC0+XG4gICAgICAgICAgICAgIGxldCByZWMgZmlsbCBhIGkgPVxuICAgICAgICAgICAgICAgIGlmIGkgPCAxIHRoZW4gU29tZSBhXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgbWF0Y2ggZ2V0X2tleSBjIGkgd2l0aFxuICAgICAgICAgICAgICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgICAgICAgICAgICAgIHwgU29tZSBraSAtPlxuICAgICAgICAgICAgICAgICAgICAgIGEuKGkpIDwtIGtpO1xuICAgICAgICAgICAgICAgICAgICAgIGZpbGwgYSAoaS0xKVxuICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICBsZXQgYSA9IEFycmF5Lm1ha2UgbGVuIGswIGluXG4gICAgICAgICAgICAgIGZpbGwgYSAobGVuLTEpXG4gICAgICBsZXQgc2V0X2tleV9kYXRhIGMgayBkID1cbiAgICAgICAgdW5zZXRfZGF0YSBjO1xuICAgICAgICBmb3IgaT0wIHRvIEFycmF5Lmxlbmd0aCBrIC0xIGRvXG4gICAgICAgICAgc2V0X2tleSBjIGkgay4oaSk7XG4gICAgICAgIGRvbmU7XG4gICAgICAgIHNldF9kYXRhIGMgZFxuICAgICAgbGV0IGNoZWNrX2tleSBjID1cbiAgICAgICAgbGV0IHJlYyBjaGVjayBjIGkgPVxuICAgICAgICAgIGkgPCAwIHx8IChjaGVja19rZXkgYyBpICYmIGNoZWNrIGMgKGktMSkpIGluXG4gICAgICAgIGNoZWNrIGMgKGxlbmd0aCBjIC0gMSlcbiAgICBlbmQpXG5cbiAgbW9kdWxlIE1ha2UoSDogSGFzaHRibC5IYXNoZWRUeXBlKTogKFMgd2l0aCB0eXBlIGtleSA9IEgudCBhcnJheSkgPVxuICBzdHJ1Y3RcbiAgICBpbmNsdWRlIE1ha2VTZWVkZWQoc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IEgudFxuICAgICAgICBsZXQgZXF1YWwgPSBILmVxdWFsXG4gICAgICAgIGxldCBoYXNoIChfc2VlZDogaW50KSB4ID0gSC5oYXNoIHhcbiAgICAgIGVuZClcbiAgICBsZXQgY3JlYXRlIHN6ID0gY3JlYXRlIH5yYW5kb206ZmFsc2Ugc3pcbiAgZW5kXG5lbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICBNYXJrIFNoaW53ZWxsIGFuZCBMZW8gV2hpdGUsIEphbmUgU3RyZWV0IEV1cm9wZSAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTUtLTIwMTYgSmFuZSBTdHJlZXQgR3JvdXAgTExDICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuZXh0ZXJuYWwgc3BhY2V0aW1lX2VuYWJsZWQgOiB1bml0IC0+IGJvb2xcbiAgPSBcImNhbWxfc3BhY2V0aW1lX2VuYWJsZWRcIiBbQEBub2FsbG9jXVxuXG5sZXQgZW5hYmxlZCA9IHNwYWNldGltZV9lbmFibGVkICgpXG5cbmxldCBpZl9zcGFjZXRpbWVfZW5hYmxlZCBmID1cbiAgaWYgZW5hYmxlZCB0aGVuIGYgKCkgZWxzZSAoKVxuXG5tb2R1bGUgU2VyaWVzID0gc3RydWN0XG4gIHR5cGUgdCA9IHtcbiAgICBjaGFubmVsIDogb3V0X2NoYW5uZWw7XG4gICAgbXV0YWJsZSBjbG9zZWQgOiBib29sO1xuICB9XG5cbiAgZXh0ZXJuYWwgd3JpdGVfbWFnaWNfbnVtYmVyIDogb3V0X2NoYW5uZWwgLT4gdW5pdFxuICAgID0gXCJjYW1sX3NwYWNldGltZV9vbmx5X3dvcmtzX2Zvcl9uYXRpdmVfY29kZVwiXG4gICAgICBcImNhbWxfc3BhY2V0aW1lX3dyaXRlX21hZ2ljX251bWJlclwiXG5cbiAgZXh0ZXJuYWwgcmVnaXN0ZXJfY2hhbm5lbF9mb3Jfc3BhY2V0aW1lIDogb3V0X2NoYW5uZWwgLT4gdW5pdFxuICAgID0gXCJjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZVwiXG5cbiAgbGV0IGNyZWF0ZSB+cGF0aCA9XG4gICAgaWYgc3BhY2V0aW1lX2VuYWJsZWQgKCkgdGhlbiBiZWdpblxuICAgICAgbGV0IGNoYW5uZWwgPSBvcGVuX291dCBwYXRoIGluXG4gICAgICByZWdpc3Rlcl9jaGFubmVsX2Zvcl9zcGFjZXRpbWUgY2hhbm5lbDtcbiAgICAgIGxldCB0ID1cbiAgICAgICAgeyBjaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgICBjbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgaW5cbiAgICAgIHdyaXRlX21hZ2ljX251bWJlciB0LmNoYW5uZWw7XG4gICAgICB0XG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgIHsgY2hhbm5lbCA9IHN0ZG91dDsgICgqIGFyYml0cmFyeSB2YWx1ZSAqKVxuICAgICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIGVuZFxuXG4gIGV4dGVybmFsIHNhdmVfZXZlbnQgOiA/dGltZTpmbG9hdCAtPiBvdXRfY2hhbm5lbCAtPiBldmVudF9uYW1lOnN0cmluZyAtPiB1bml0XG4gICAgPSBcImNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlXCJcbiAgICAgIFwiY2FtbF9zcGFjZXRpbWVfc2F2ZV9ldmVudFwiXG5cbiAgbGV0IHNhdmVfZXZlbnQgP3RpbWUgdCB+ZXZlbnRfbmFtZSA9XG4gICAgaWZfc3BhY2V0aW1lX2VuYWJsZWQgKGZ1biAoKSAtPlxuICAgICAgc2F2ZV9ldmVudCA/dGltZSB0LmNoYW5uZWwgfmV2ZW50X25hbWUpXG5cbiAgZXh0ZXJuYWwgc2F2ZV90cmllIDogP3RpbWU6ZmxvYXQgLT4gb3V0X2NoYW5uZWwgLT4gdW5pdFxuICAgID0gXCJjYW1sX3NwYWNldGltZV9vbmx5X3dvcmtzX2Zvcl9uYXRpdmVfY29kZVwiXG4gICAgICBcImNhbWxfc3BhY2V0aW1lX3NhdmVfdHJpZVwiXG5cbiAgbGV0IHNhdmVfYW5kX2Nsb3NlID90aW1lIHQgPVxuICAgIGlmX3NwYWNldGltZV9lbmFibGVkIChmdW4gKCkgLT5cbiAgICAgIGlmIHQuY2xvc2VkIHRoZW4gZmFpbHdpdGggXCJTZXJpZXMgaXMgY2xvc2VkXCI7XG4gICAgICBzYXZlX3RyaWUgP3RpbWUgdC5jaGFubmVsO1xuICAgICAgY2xvc2Vfb3V0IHQuY2hhbm5lbDtcbiAgICAgIHQuY2xvc2VkIDwtIHRydWUpXG5lbmRcblxubW9kdWxlIFNuYXBzaG90ID0gc3RydWN0XG4gIGV4dGVybmFsIHRha2UgOiA/dGltZTpmbG9hdCAtPiBvdXRfY2hhbm5lbCAtPiB1bml0XG4gICAgPSBcImNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlXCJcbiAgICAgIFwiY2FtbF9zcGFjZXRpbWVfdGFrZV9zbmFwc2hvdFwiXG5cbiAgbGV0IHRha2UgP3RpbWUgeyBTZXJpZXMuY2xvc2VkOyBjaGFubmVsIH0gPVxuICAgIGlmX3NwYWNldGltZV9lbmFibGVkIChmdW4gKCkgLT5cbiAgICAgIGlmIGNsb3NlZCB0aGVuIGZhaWx3aXRoIFwiU2VyaWVzIGlzIGNsb3NlZFwiO1xuICAgICAgR2MubWlub3IgKCk7XG4gICAgICB0YWtlID90aW1lIGNoYW5uZWwpXG5lbmRcblxuZXh0ZXJuYWwgc2F2ZV9ldmVudF9mb3JfYXV0b21hdGljX3NuYXBzaG90cyA6IGV2ZW50X25hbWU6c3RyaW5nIC0+IHVuaXRcbiAgPSBcImNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlXCJcbiAgICBcImNhbWxfc3BhY2V0aW1lX3NhdmVfZXZlbnRfZm9yX2F1dG9tYXRpY19zbmFwc2hvdHNcIlxuXG5sZXQgc2F2ZV9ldmVudF9mb3JfYXV0b21hdGljX3NuYXBzaG90cyB+ZXZlbnRfbmFtZSA9XG4gIGlmX3NwYWNldGltZV9lbmFibGVkIChmdW4gKCkgLT5cbiAgICBzYXZlX2V2ZW50X2Zvcl9hdXRvbWF0aWNfc25hcHNob3RzIH5ldmVudF9uYW1lKVxuIiwib3BlbiBMZXhpbmdcbigqIEF1dGhvcjogU3RldmUgWmRhbmNld2ljICopXG5cbnR5cGUgcG9zID0gaW50ICogaW50ICAgICgqIExpbmUgbnVtYmVyIGFuZCBjb2x1bW4gKilcbnR5cGUgdCA9IHN0cmluZyAqIHBvcyAqIHBvc1xuXG5sZXQgbGluZV9vZl9wb3MgKGwsXykgPSBsXG5sZXQgY29sX29mX3BvcyAoXyxjKSA9IGNcbmxldCBta19wb3MgbGluZSBjb2wgPSAobGluZSwgY29sKVxuXG5sZXQgZmlsZV9vZl9yYW5nZSAoZixfLF8pID0gZlxubGV0IHN0YXJ0X29mX3JhbmdlIChfLHMsXykgPSBzXG5sZXQgZW5kX29mX3JhbmdlIChfLF8sZSkgPSBlXG5sZXQgbWtfcmFuZ2UgZiBzIGUgPSAoZixzLGUpXG5sZXQgdmFsaWRfcG9zIChsLGMpID0gbCA+PSAwICYmIGMgPj0wXG5cbmxldCBtZXJnZV9yYW5nZSAoKGYsczEsZTEpIGFzIHIxKSAoKGYnLHMyLGUyKSBhcyByMikgPVxuICBpZiBmIDw+IGYnIHRoZW4gZmFpbHdpdGggQEAgUHJpbnRmLnNwcmludGYgXCJtZXJnZV9yYW5nZSBjYWxsZWQgb24gZGlmZmVyZW50IGZpbGVzOiAlcyBhbmQgJXNcIiBmIGYnXG4gIGVsc2VcbiAgaWYgbm90ICh2YWxpZF9wb3MgczEpIHRoZW4gcjIgZWxzZVxuICBpZiBub3QgKHZhbGlkX3BvcyBzMikgdGhlbiByMSBlbHNlXG4gIG1rX3JhbmdlIGYgKG1pbiBzMSBzMikgKG1heCBlMSBlMilcblxubGV0IHN0cmluZ19vZl9yYW5nZSAoZiwoc2wsc2MpLChlbCxlYykpID1cbiAgUHJpbnRmLnNwcmludGYgXCIlczpbJWQuJWQtJWQuJWRdXCIgZiBzbCBzYyBlbCBlY1xuXG5sZXQgbWxfc3RyaW5nX29mX3JhbmdlIChmLChzbCxzYyksKGVsLGVjKSkgPVxuICBQcmludGYuc3ByaW50ZiBcIihcXFwiJXNcXFwiLCAoJWQsICVkKSwgKCVkLCAlZCkpXCIgZiBzbCBzYyBlbCBlY1xuXG5sZXQgbm9yYW5nZSA9IChcIl9faW50ZXJuYWxcIiwgKDAsMCksICgwLDApKVxuXG4oKiBDcmVhdGVzIGEgUmFuZ2UucG9zIGZyb20gdGhlIExleGluZy5wb3NpdGlvbiBkYXRhICopXG5sZXQgcG9zX29mX2xleHBvcyAocDpwb3NpdGlvbikgOiBwb3MgPVxuICBta19wb3MgKHAucG9zX2xudW0pIChwLnBvc19jbnVtIC0gcC5wb3NfYm9sKVxuXG5sZXQgbWtfbGV4X3JhbmdlIChwMTpwb3NpdGlvbikgKHAyOnBvc2l0aW9uKSA6IHQgPVxuICBta19yYW5nZSBwMS5wb3NfZm5hbWUgKHBvc19vZl9sZXhwb3MgcDEpIChwb3Nfb2ZfbGV4cG9zIHAyKVxuXG4oKiBFeHBvc2UgdGhlIGxleGVyIHN0YXRlIGFzIGEgUmFuZ2UudCB2YWx1ZSAqKVxubGV0IGxleF9yYW5nZSBsZXhidWYgOiB0ID0gXG4gIG1rX2xleF9yYW5nZSAobGV4ZW1lX3N0YXJ0X3AgbGV4YnVmKSAobGV4ZW1lX2VuZF9wIGxleGJ1ZilcbiAgICBcbiIsIlxudHlwZSAnYSBub2RlID0geyBlbHQgOiAnYTsgbG9jIDogUmFuZ2UudCB9XG5cbigqKiB2YWwgbm9fbG9jIDogJ2ExIC0+ICdhMSBub2RlICoqKVxuXG5sZXQgbm9fbG9jIHggPVxuICB7IGVsdCA9IHg7IGxvYyA9IFJhbmdlLm5vcmFuZ2UgfVxuXG50eXBlIGlkID0gc3RyaW5nXG5cbnR5cGUgdHkgPVxufCBUQm9vbFxufCBUSW50XG58IFRSZWYgb2YgcnR5XG5hbmQgcnR5ID1cbnwgUlN0cmluZ1xufCBSQXJyYXkgb2YgdHlcbnwgUkZ1biBvZiB0eSBsaXN0ICogcmV0X3R5XG5hbmQgcmV0X3R5ID1cbnwgUmV0Vm9pZFxufCBSZXRWYWwgb2YgdHlcblxudHlwZSB1bm9wID1cbnwgTmVnXG58IExvZ25vdFxufCBCaXRub3RcblxudHlwZSBiaW5vcCA9XG58IEFkZFxufCBTdWJcbnwgTXVsXG58IEVxXG58IE5lcVxufCBMdFxufCBMdGVcbnwgR3RcbnwgR3RlXG58IEFuZFxufCBPclxufCBJQW5kXG58IElPclxufCBTaGxcbnwgU2hyXG58IFNhclxuXG50eXBlIGV4cCA9XG58IENOdWxsIG9mIHJ0eVxufCBDQm9vbCBvZiBib29sXG58IENJbnQgb2YgaW50NjRcbnwgQ1N0ciBvZiBzdHJpbmdcbnwgQ0FyciBvZiB0eSAqIGV4cCBub2RlIGxpc3RcbnwgTmV3QXJyIG9mIHR5ICogZXhwIG5vZGVcbnwgSWQgb2YgaWRcbnwgSW5kZXggb2YgZXhwIG5vZGUgKiBleHAgbm9kZVxufCBDYWxsIG9mIGV4cCBub2RlICogZXhwIG5vZGUgbGlzdFxufCBCb3Agb2YgYmlub3AgKiBleHAgbm9kZSAqIGV4cCBub2RlXG58IFVvcCBvZiB1bm9wICogZXhwIG5vZGVcblxudHlwZSBjZmllbGQgPSBpZCAqIGV4cCBub2RlXG5cbnR5cGUgdmRlY2wgPSBpZCAqIGV4cCBub2RlXG5cbnR5cGUgc3RtdCA9XG58IEFzc24gb2YgZXhwIG5vZGUgKiBleHAgbm9kZVxufCBEZWNsIG9mIHZkZWNsXG58IFJldCBvZiBleHAgbm9kZSBvcHRpb25cbnwgU0NhbGwgb2YgZXhwIG5vZGUgKiBleHAgbm9kZSBsaXN0XG58IElmIG9mIGV4cCBub2RlICogc3RtdCBub2RlIGxpc3QgKiBzdG10IG5vZGUgbGlzdFxufCBGb3Igb2YgdmRlY2wgbGlzdCAqIGV4cCBub2RlIG9wdGlvbiAqIHN0bXQgbm9kZSBvcHRpb24gKiBzdG10IG5vZGUgbGlzdFxufCBXaGlsZSBvZiBleHAgbm9kZSAqIHN0bXQgbm9kZSBsaXN0XG5cbnR5cGUgYmxvY2sgPSBzdG10IG5vZGUgbGlzdFxuXG50eXBlIGdkZWNsID0geyBuYW1lIDogaWQ7IGluaXQgOiBleHAgbm9kZSB9XG5cbnR5cGUgZmRlY2wgPSB7IGZydHlwIDogcmV0X3R5OyBmbmFtZSA6IGlkOyBhcmdzIDogKHR5ICogaWQpIGxpc3Q7IGJvZHkgOiBibG9jayB9XG5cbnR5cGUgZmllbGQgPSB7IGZpZWxkTmFtZSA6IGlkOyBmdHlwIDogdHkgfVxuXG50eXBlIGRlY2wgPVxufCBHdmRlY2wgb2YgZ2RlY2wgbm9kZVxufCBHZmRlY2wgb2YgZmRlY2wgbm9kZVxuXG50eXBlIHByb2cgPSBkZWNsIGxpc3RcbiIsIlxuKCogVGhpcyBnZW5lcmF0ZWQgY29kZSByZXF1aXJlcyB0aGUgZm9sbG93aW5nIHZlcnNpb24gb2YgTWVuaGlyTGliOiAqKVxuXG5sZXQgKCkgPVxuICBNZW5oaXJMaWIuU3RhdGljVmVyc2lvbi5yZXF1aXJlXzIwMjAwMjExXG5cbm1vZHVsZSBNZW5oaXJCYXNpY3MgPSBzdHJ1Y3RcbiAgXG4gIGV4Y2VwdGlvbiBFcnJvclxuICBcbiAgdHlwZSB0b2tlbiA9IFxuICAgIHwgV0hJTEVcbiAgICB8IFZBUlxuICAgIHwgVFZPSURcbiAgICB8IFRTVFJJTkdcbiAgICB8IFRSVUVcbiAgICB8IFRJTlRcbiAgICB8IFRJTERFXG4gICAgfCBUQk9PTFxuICAgIHwgU1RSSU5HIG9mIChcbiMgMTMgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgIChzdHJpbmcpXG4jIDI0IFwiaHcwMy9wYXJzZXIubWxcIlxuICApXG4gICAgfCBTVEFSXG4gICAgfCBTSFJcbiAgICB8IFNITFxuICAgIHwgU0VNSVxuICAgIHwgU0FSXG4gICAgfCBSUEFSRU5cbiAgICB8IFJFVFVSTlxuICAgIHwgUkJSQUNLRVRcbiAgICB8IFJCUkFDRVxuICAgIHwgUExVU1xuICAgIHwgT1JcbiAgICB8IE5VTExcbiAgICB8IE5FV1xuICAgIHwgTkVRXG4gICAgfCBMVEVcbiAgICB8IExUXG4gICAgfCBMUEFSRU5cbiAgICB8IExCUkFDS0VUXG4gICAgfCBMQlJBQ0VcbiAgICB8IElPUlxuICAgIHwgSU5UIG9mIChcbiMgMTEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgIChpbnQ2NClcbiMgNDkgXCJodzAzL3BhcnNlci5tbFwiXG4gIClcbiAgICB8IElGXG4gICAgfCBJREVOVCBvZiAoXG4jIDE0IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyA1NSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgKVxuICAgIHwgSUFORFxuICAgIHwgR1RFXG4gICAgfCBHVFxuICAgIHwgR0xPQkFMXG4gICAgfCBGT1JcbiAgICB8IEZBTFNFXG4gICAgfCBFUUVRXG4gICAgfCBFUVxuICAgIHwgRU9GXG4gICAgfCBFTFNFXG4gICAgfCBEQVNIXG4gICAgfCBDT01NQVxuICAgIHwgQkFOR1xuICAgIHwgQU5EXG4gIFxuZW5kXG5cbmluY2x1ZGUgTWVuaGlyQmFzaWNzXG5cbmxldCBfZVJSID1cbiAgTWVuaGlyQmFzaWNzLkVycm9yXG5cbiMgMSBcImh3MDMvcGFyc2VyLm1seVwiXG4gIFxub3BlbiBBc3RcblxubGV0IGxvYyAoc3RhcnRwb3M6TGV4aW5nLnBvc2l0aW9uKSAoZW5kcG9zOkxleGluZy5wb3NpdGlvbikgKGVsdDonYSkgOiAnYSBub2RlID1cbiAgeyBlbHQgOyBsb2M9UmFuZ2UubWtfbGV4X3JhbmdlIHN0YXJ0cG9zIGVuZHBvcyB9XG5cblxuIyA4NyBcImh3MDMvcGFyc2VyLm1sXCJcblxubW9kdWxlIFRhYmxlcyA9IHN0cnVjdFxuICBcbiAgaW5jbHVkZSBNZW5oaXJCYXNpY3NcbiAgXG4gIGxldCB0b2tlbjJ0ZXJtaW5hbCA6IHRva2VuIC0+IGludCA9XG4gICAgZnVuIF90b2sgLT5cbiAgICAgIG1hdGNoIF90b2sgd2l0aFxuICAgICAgfCBBTkQgLT5cbiAgICAgICAgICA0NlxuICAgICAgfCBCQU5HIC0+XG4gICAgICAgICAgNDVcbiAgICAgIHwgQ09NTUEgLT5cbiAgICAgICAgICA0NFxuICAgICAgfCBEQVNIIC0+XG4gICAgICAgICAgNDNcbiAgICAgIHwgRUxTRSAtPlxuICAgICAgICAgIDQyXG4gICAgICB8IEVPRiAtPlxuICAgICAgICAgIDQxXG4gICAgICB8IEVRIC0+XG4gICAgICAgICAgNDBcbiAgICAgIHwgRVFFUSAtPlxuICAgICAgICAgIDM5XG4gICAgICB8IEZBTFNFIC0+XG4gICAgICAgICAgMzhcbiAgICAgIHwgRk9SIC0+XG4gICAgICAgICAgMzdcbiAgICAgIHwgR0xPQkFMIC0+XG4gICAgICAgICAgMzZcbiAgICAgIHwgR1QgLT5cbiAgICAgICAgICAzNVxuICAgICAgfCBHVEUgLT5cbiAgICAgICAgICAzNFxuICAgICAgfCBJQU5EIC0+XG4gICAgICAgICAgMzNcbiAgICAgIHwgSURFTlQgXyAtPlxuICAgICAgICAgIDMyXG4gICAgICB8IElGIC0+XG4gICAgICAgICAgMzFcbiAgICAgIHwgSU5UIF8gLT5cbiAgICAgICAgICAzMFxuICAgICAgfCBJT1IgLT5cbiAgICAgICAgICAyOVxuICAgICAgfCBMQlJBQ0UgLT5cbiAgICAgICAgICAyOFxuICAgICAgfCBMQlJBQ0tFVCAtPlxuICAgICAgICAgIDI3XG4gICAgICB8IExQQVJFTiAtPlxuICAgICAgICAgIDI2XG4gICAgICB8IExUIC0+XG4gICAgICAgICAgMjVcbiAgICAgIHwgTFRFIC0+XG4gICAgICAgICAgMjRcbiAgICAgIHwgTkVRIC0+XG4gICAgICAgICAgMjNcbiAgICAgIHwgTkVXIC0+XG4gICAgICAgICAgMjJcbiAgICAgIHwgTlVMTCAtPlxuICAgICAgICAgIDIxXG4gICAgICB8IE9SIC0+XG4gICAgICAgICAgMjBcbiAgICAgIHwgUExVUyAtPlxuICAgICAgICAgIDE5XG4gICAgICB8IFJCUkFDRSAtPlxuICAgICAgICAgIDE4XG4gICAgICB8IFJCUkFDS0VUIC0+XG4gICAgICAgICAgMTdcbiAgICAgIHwgUkVUVVJOIC0+XG4gICAgICAgICAgMTZcbiAgICAgIHwgUlBBUkVOIC0+XG4gICAgICAgICAgMTVcbiAgICAgIHwgU0FSIC0+XG4gICAgICAgICAgMTRcbiAgICAgIHwgU0VNSSAtPlxuICAgICAgICAgIDEzXG4gICAgICB8IFNITCAtPlxuICAgICAgICAgIDEyXG4gICAgICB8IFNIUiAtPlxuICAgICAgICAgIDExXG4gICAgICB8IFNUQVIgLT5cbiAgICAgICAgICAxMFxuICAgICAgfCBTVFJJTkcgXyAtPlxuICAgICAgICAgIDlcbiAgICAgIHwgVEJPT0wgLT5cbiAgICAgICAgICA4XG4gICAgICB8IFRJTERFIC0+XG4gICAgICAgICAgN1xuICAgICAgfCBUSU5UIC0+XG4gICAgICAgICAgNlxuICAgICAgfCBUUlVFIC0+XG4gICAgICAgICAgNVxuICAgICAgfCBUU1RSSU5HIC0+XG4gICAgICAgICAgNFxuICAgICAgfCBUVk9JRCAtPlxuICAgICAgICAgIDNcbiAgICAgIHwgVkFSIC0+XG4gICAgICAgICAgMlxuICAgICAgfCBXSElMRSAtPlxuICAgICAgICAgIDFcbiAgXG4gIGFuZCBlcnJvcl90ZXJtaW5hbCA9XG4gICAgMFxuICBcbiAgYW5kIHRva2VuMnZhbHVlIDogdG9rZW4gLT4gT2JqLnQgPVxuICAgIGZ1biBfdG9rIC0+XG4gICAgICBtYXRjaCBfdG9rIHdpdGhcbiAgICAgIHwgQU5EIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgQkFORyAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IENPTU1BIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgREFTSCAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IEVMU0UgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBFT0YgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBFUSAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IEVRRVEgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBGQUxTRSAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IEZPUiAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IEdMT0JBTCAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IEdUIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgR1RFIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgSUFORCAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IElERU5UIF92IC0+XG4gICAgICAgICAgT2JqLnJlcHIgX3ZcbiAgICAgIHwgSUYgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBJTlQgX3YgLT5cbiAgICAgICAgICBPYmoucmVwciBfdlxuICAgICAgfCBJT1IgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBMQlJBQ0UgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBMQlJBQ0tFVCAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IExQQVJFTiAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IExUIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgTFRFIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgTkVRIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgTkVXIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgTlVMTCAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IE9SIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgUExVUyAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IFJCUkFDRSAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IFJCUkFDS0VUIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgUkVUVVJOIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgUlBBUkVOIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgU0FSIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgU0VNSSAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IFNITCAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IFNIUiAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IFNUQVIgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBTVFJJTkcgX3YgLT5cbiAgICAgICAgICBPYmoucmVwciBfdlxuICAgICAgfCBUQk9PTCAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IFRJTERFIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgVElOVCAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IFRSVUUgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBUU1RSSU5HIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgVFZPSUQgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBWQVIgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBXSElMRSAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gIFxuICBhbmQgZGVmYXVsdF9yZWR1Y3Rpb24gPVxuICAgICg4LCBcIlxcMDAwXFwwMDBcXDAxNVxcMDE3WFxcMDAwWVxcMDE0XFwwMDBaXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcclxcMDEyXFwwMThcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMTZcXDAwMFxcMDAwPVxcMDAwXFwwMjBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAxOVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMEZcXDAwMFxcMDAwKlxcMDAwXFwwMjFcXDAwMFxcMDIyXFwwMDBcXDAwMVxcMDAwLVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFtcXDAwMFxcMDAwSkFcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwU1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBRXFwwMDBSXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMTFcXG41XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwME1cXDAwMFxcMDAwVFZcXDAwMFxcMDAwXFwwMDBOUFxcMDAwXFwwMDBcXDAwMFxcMDAwT1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMExDXVxcMDAwO1xcMDAwXFwwMDVcXDAwN1xcMDAwXFwwMDBcXDAwMFxcMDAwMDIvXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMC4zXFwwMDBcXDAwMFxcMDAwMT9cXDAwMDRcXDAwMFxcMDAwSFxcMDAwXFwwMDZcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxiXFwwMDJcXDAwMERcXDAwMDlcXDAwMFxcMDAzXFwwMDBXXCIpXG4gIFxuICBhbmQgZXJyb3IgPVxuICAgICg0NywgXCJcXDAxNVxcMTkyXFwwMDJcXFwiXFwxMzBcXDAyMFxcMDAwXFwwMDBcXGIgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMVxcMjQ4XFwwMDBEUEJcXDEyOFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXG5cXDEyOFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwQFxcMDAwXFwwMDB+XFwwMDJcXDAxN1xcMDIwXFwwMTZcXDE2MFxcMDAwXFwwMDBcXDAwMVxcMTI4XFwwMDBcXDAwMVxcMjQ4XFwwMDREUEJcXDEzMVxcMjQwXFwwMDBcXDEzNlxcMTYwXFwxMzNcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDA/XFwwMDBcXGJcXDEzOFxcYlB+XFwwMDBcXDAxN1xcMDIwXFwwMTZcXDE2MFxcMDAwXFwwMDBcXDAwMVxcMDAwXFwwMDBcXDAwMFxcMDAwXFxiXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAxXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDA/eVxcMjQ0cVpcXDAzMVxcMTMwXFwwMDRFXFwwMDQoXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXGJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA3Zz5cXDE0MiNDXFwyNDBcXDAwMFxcMTM2XFwxNjBcXDEzM1xcMDAwXFwwMzFcXDE4OFxcMjUwOFxcMTczXFwwMTVcXDE5MlxcMDAyXFxcIlxcMTMwXFwwMjBcXDAwMHRcXDE3OVxcMjMyXFwyMjYkP1xcMDAwXFxiXFwxMzhcXGJQXFwwMDFcXDI1MVxcMjA3XFwxNjNcXDEzOFxcMjA4XFwyNTJcXDAwMFxcXCIoIUBcXDAwN1xcMjM5PlxcMTQyK0NcXDI0MFxcMDAwXFwxMzZcXDE2MFxcMTMzXFwwMDBcXDAzMVxcMTg4XFwyNTA4XFwxNzNcXDAxNVxcMTkyXFwwMDJcXFwiXFwxMzBcXDAyMFxcMDAwflxcMjQzXFwyMzJcXDIyNlxcMTgwP1xcMDAwXFxiXFwxMzhcXGJQXFwwMDFcXDI1MVxcMjA3XFwxNjNcXDEzOFxcMjA4XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAxXFwyNDhcXDAwMERQQlxcMTI4XFwwMTVcXDIyMn1cXDAyOFZcXDEzNVxcMjI0XFwwMDFcXDAxN0FcXG5cXDAwMD95XFwyNDRxWlxcMDMxXFwxMjhcXDAwNEVcXDAwNChcXDAwMFxcMjUzXFwyMzFcXDIwOVxcMTk3aH5cXDAwMFxcMDE3XFwwMjBcXDAxNlxcMTYwXFwwMDNcXDI0N1xcMTU5R1xcMDIxXFwxNjFcXDI0OFxcMDAwRFBCXFwxMjhcXDAxNVxcMjIyfVxcMDI4VlxcMTM1XFwyMjRcXDAwMVxcMDE3QVxcblxcMDAwP3lcXDI0NHFaXFwwMzFcXDEyOFxcMDA0RVxcMDA0KFxcMDAwXFwyNTNcXDIzMVxcMjA5XFwxOTdoflxcMDAwXFwwMTdcXDAyMFxcMDE2XFwxNjBcXDAwM1xcMjQ3XFwxNTlHXFwwMjFcXDE2MVxcMjQ4XFwwMDBEUEJcXDEyOFxcMDE1XFwyMjJ9XFwwMjhWXFwxMzVcXDIyNFxcMDAxXFwwMTdBXFxuXFwwMDA/eVxcMjQ0cVpcXDAzMVxcMTI4XFwwMDRFXFwwMDQoXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDFcXDI1MVxcMjA3XFwxNjNcXDEzOFxcMjA4XFwwMDNcXDE3N1xcMTU5R1xcMDE3IFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxiXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDA6WVxcMjQ0cVxcMDE4XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDI1M1xcMjMxXFwyMDlcXDE5N2hcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwM1xcMTYxXFwxNTlHXFwwMjEgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA2XFwxNjBcXDAwMFxcMDAwXFwwMDJcXDAxNlxcMDAwXFwwMDBcXDAwMFxcMDAwQFxcMDAwXFwwMDBcXDAwMFxcMDAwIFxcMDAwXFwwMDBcXDAyMVxcMDAyXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBCXFwwMDBcXDAwMFxcMDAwXFwwMDJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwIFxcMDAwXFwwMDBcXDAwMVxcMDAyXFwxNjBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMEBcXDAwMFxcMDA2XFwyNTJcXG5cXFwiOGFAXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAzXFwyNDBcXDAwMFxcMTM2XFwxNjBcXDEzM1xcMDAwXFwwMjlcXDE0MFxcMjUwOFxcMTM3XFwwMDBcXDAwMFxcMDAwXFxiXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAyXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMjUyXFwwMDBcXFwiKCFAXFwwMDdcXDE5NT5cXDE0MiNDXFwyNDFcXDAwMFxcMTM2XFwxNjBcXDEzM1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwPlxcMDI1XFwyNDRxXFwwMThcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDEyOFxcMDAwXFwwMDB+XFwwMDBcXDAxN1xcMDIwXFwwMTZcXDE2MFxcMDAzXFwxNzdcXDE1OUdcXDAxNyBcXDAwMFxcMDAwXFwwMDFcXDAwMFxcMDAwXFwwMjdcXDI0MGhcXDEzNlxcMjI1XFwxNTdcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMTI4XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMVxcMjA4XFwyMDdcXDE2M1xcMTQwXFwxNDRcXDAwMFxcMDAwXFwwMDJcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMTI4XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDdcXDIyNlxcMDAxXFwwMTdBXFxuXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyMjNcXDEzMVxcMDA0R1xcMDEyKFxcMDAwXFwwMTZcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMTZcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwxMjhcXDAzMVxcMTI4XFwwMDRFXFwwMDQoXFwwMDBcXDI0OGdcXDIwOVxcMTk2SFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA3Qz5cXDE0MlxcXCJDXFwyNDBAXFwxMzZcXDE2MFxcMTMzXFwwMDBcXDAwMFxcMTI4XFwwMDBcXDAwMFxcMDAwXFwwMDA+XFwwMjVcXDI0NHFcXDAxOFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMD9cXDAwMFxcYlxcMTM4XFxiUFxcMDAxXFwyMTBcXDIwN1xcMTYzXFwxMzZcXDE0NFxcMDAzXFwxNjFcXDE1OUdcXDAyNSBcXDAwN1xcMTk1PlxcMTQyXFxcIkBcXDAwMVxcMDAwXFwwMDBcXDAwMFxcMDAyXFwwMTZcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAzflxcMDA1XFwwMTdcXDAyODBcXDE2MFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMTI4XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAxXFwwMDA7XFwwMDBcXGJcXGJcXGJcXDAwMFxcMDAwXFwwMDAgXFwxMjhcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA1QFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMTZcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMTI4XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwYFxcMDAwXFwwMDB2XFwwMDFcXDAxNlxcMDE2XFwwMTZcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDE2XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDFcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDFcXDAwM1xcMTc2XFwwMDBcXDEyOFxcMTI4XFwxMjhcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBCXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMVxcMDAwXFwwMDBcXDAwMFxcMTY4XFwwMTZcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAyXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDEyOFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMjEyXFwwMDBcXDAwMFxcMDAwQlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcclxcMjQ4XFwwMTZEcFxcMTk0XFwxMjhcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMCBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcIilcbiAgXG4gIGFuZCBzdGFydCA9XG4gICAgM1xuICBcbiAgYW5kIGFjdGlvbiA9XG4gICAgKCgxNiwgXCJcXGJcXDE0MFxcMDAwXFwwMzFcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXGJcXDE0MFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAyOFxcMDAwXFwwMDBcXDAwMCFcXGJcXDE0MFxcMDAwXFwwMDNcXGJcXDE0MFxcYlxcMTQwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxiXFwxNDBcXGJcXDE0MFxcMDAwKlxcMDAwZFxcMDAwLFxcMDAwXFwwMDBcXDAwMFxcMDIxXFxiXFwxNDBcXDAwMFxcMDAwXFwwMDByXFwwMDBcXDAwMFxcMDA1XFwxOTZcXGJcXDE0MFxcMDAwNlxcYlxcMTQwXFwwMDVcXDE5NlxcYlxcMTQwXFwwMDBcXDEyOFxcYlxcMTQwXFwwMDBcXDIwMlxcYlxcMTQwXFwwMDFcXDAyMFxcYlxcMTQwXFwwMDFeXFxiXFwxNDBcXDAwMVxcMTY4XFwwMDBcXDAwMFxcYlxcMTQwXFwwMDFcXDI0MlxcYlxcMTQwXFwwMDI8XFxiXFwxNDBcXDAwMlxcMTM0XFxiXFwxNDBcXDAwMlxcMjA4XFxiXFwxNDBcXDAwM1xcMDI2XFxiXFwxNDBcXDAwM2RcXGJcXDE0MFxcMDAzXFwxNzRcXGJcXDE0MFxcMDAzXFwyNDhcXGJcXDE0MFxcMDA0QlxcYlxcMTQwXFwwMDRcXDE0MFxcYlxcMTQwXFwwMDBcXDAwMFxcMDA0XFwyMTRcXDAwNlxcMDE0XFwwMDBcXDAwMFxcMDAwXFwxNDhcXDAwMFxcMDAwXFwwMDZcXDAxNFxcMDAwXFwwMDBcXDAwNSBcXDAwMFxcMDAwXFwwMDVcXDE5NlxcMDAwXFwwMDBcXDAwNWRcXDAwMFxcMTI4XFwwMDBcXDE0OFxcMDA1ZFxcMDAwXFwwMDZcXDAwMFxcMTcwXFwwMDBcXDAwMFxcMDAwXFwwMjZcXDAwMFxcMDI4XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDE3OFxcMDAwNlxcMDA2alxcMDAwXFwxNjZcXGJcXDE0MFxcMDA2XFwxNzhcXDAwMDZcXDAwMFxcMDAwXFwwMDBcXDE3MFxcMDAwXFwxNjRcXGJcXDE0MFxcMDA2XFwwMTRcXGJcXDE0MFxcMDAwXFwwMDBcXDAwNVxcMTk2XFwwMDBcXDAwMFxcMDAwXFwxOTRcXGJcXDE0MFxcMDA2XFwyMzhcXDAwMDZcXDAwNXxcXDAwMDZcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNypcXDAwMFxcMjA2XFwwMDAmXFwwMDBcXDIzNlxcYlxcMjI0XFwwMDBcXDIzOFxcMDA2alxcMDAwXFwyNDBcXDAwMFxcMDAwXFwwMDBcXDI0NFxcMDAwNlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDE5NlxcYlxcMTQwXFwwMDZcXDE3OFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxiNlxcYlxcMTQwXFwwMDBcXDI0OFxcMDA3dFxcMDAwXFwwMDBcXGJcXDE0MFxcMDA2XFwxNzhcXDAwN1xcMTc2XFwwMDdcXDI1MFxcMDAwZFxcMDAwJlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA2alxcMDAwXFwwMDBcXDAwMFxcMjQ2XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMjIyXFwwMDBcXDIxMlxcYnZcXDAwMExcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDI4XFwwMDBcXDI1NFxcMDAxXFwwMjhcXDAwMHRcXGJcXDIzNlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDFcXG5cXDAwMSpcXDAwMFxcMTQ4XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMSxcXDAwMFxcMDAwXFwwMDB8XFxidlxcMDAwXFwwMDBcXDAwMThcXDAwMFxcMDAwXFwwMDBKXFwwMDEgXFwwMDVkXFwwMDE+XFwwMDA2XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMVxcMDEyXFwwMDBcXDAwMFxcMDA1ZFxcMDAwXFwwMDBcXDAwNmpcXDAwMFxcMDAwXFwwMDFcXDAxNFxcMDAwXFwwMDBcIiksICgxNiwgXCJcXDAwMFxcMTU3XFwwMDBcXDE1N1xcMDAwXFwxNTdcXDAwMFxcMTU3XFwwMDBcXDE1N1xcMDAwXFwxNTdcXDAwMFxcblxcMDAwXFwxNTdcXDAwMFxcMTU3XFwwMDBcXDE1N1xcMDAwXFwxNTdcXDAwMC5cXDAwMWVcXDAwMFxcMTU3XFwwMDBcXDE1N1xcMDAwXFwxNTdcXDAwMGZcXDAwMFxcMTMwXFwwMDAmXFwwMDBcXDE1N1xcMDAwXFwwMThcXDAwMVxcMTM4XFwwMDBcXDAyNlxcMDAwXFwxNTdcXDAwMFxcMTU3XFwwMDBcXDE1N1xcMDAxaVxcMDAwNlxcMDAxIVxcMDAwXFwxNTdcXDAwMU5cXDAwMFxcMTU3XFwwMDFcXDAwNVxcMDAwXFwxNTdcXDAwMFxcMTU3XFwwMDFWXFwwMDBcXDE1N1xcMDAwYVxcMDAwYVxcMDAwYVxcMDAwYVxcMDAwYVxcMDAwYVxcMDAwXlxcMDAwYVxcMDAwYVxcMDAwYVxcMDAwYVxcMDAwVlxcMDAxaVxcMDAwYVxcMDAwYVxcMDAwYVxcMDAwZlxcMDAwXFwxMzBcXDAwMXJcXDAwMGFcXDAwMVpcXDAwMVxcMTcwXFwwMDJyXFwwMDBhXFwwMDBhXFwwMDBhXFwwMDEpXFwwMDFOXFwwMDFlXFwwMDBhXFwwMDBaXFwwMDBhXFwwMDJcXDIwNlxcMDAwYVxcMDAwYVxcMDAwclxcMDAwYVxcMDAwelxcMDAwXFwxNDVcXDAwMFxcMTQ1XFwwMDBcXDE0NVxcMDAwXFwxNDVcXDAwMFxcMTQ1XFwwMDFcXDAyNVxcMDAwXFwxNDVcXDAwMFxcMTQ1XFwwMDBcXDE0NlxcMDAwXFwxNDVcXDAwMWlcXDAwMlxcMTQyXFwwMDBcXDE0NVxcMDAwXFwxNDVcXDAwMFxcMTQ1XFwwMDBmXFwwMDBcXDEzMFxcMDAxXFwwMzBcXDAwMFxcMTQ1XFwwMDI+XFwwMDJcXDE2NlxcMDAxQlxcMDAwXFwxNDVcXDAwMFxcMTQ1XFwwMDBcXDE0NVxcMDAxRlxcMDAxaVxcMDAxUlxcMDAwXFwxNDVcXDAwMW5cXDAwMFxcMTQ1XFwwMDJcXDE4NlxcMDAwXFwxNTRcXDAwMFxcMTQ1XFwwMDF6XFwwMDBcXDE0NVxcMDAwelxcMDAwWVxcMDAwWVxcMDAwWVxcMDAwWVxcMDAwWVxcMDAxXFwxNDJcXDAwMFlcXDAwMFlcXDAwMFlcXDAwMFlcXDAwMVxcMTQ2XFwwMDFcXDE3NFxcMDAwWVxcMDAwWVxcMDAwWVxcMDAwZlxcMDAwXFwxMzBcXDAwMVxcMjE0XFwwMDBZXFwwMDFcXDIyMlxcMDAxXFwyMzBcXDAwMVxcMjM4XFwwMDBZXFwwMDBZXFwwMDBZXFwwMDFcXDI0NlxcMDAyXFwwMDZcXDAwMlxcXCJcXDAwMFlcXDAwMlpcXDAwMFlcXDAwMmZcXDAwMFlcXDAwMFlcXDAwMmpcXDAwMFlcXDAwMHpcXDAwMF1cXDAwMF1cXDAwMF1cXDAwMF1cXDAwMF1cXDAwMlxcMTM0XFwwMDBdXFwwMDBdXFwwMDBdXFwwMDBdXFwwMDJcXDEzOFxcMDAyXFwxNThcXDAwMF1cXDAwMF1cXDAwMF1cXDAwMGZcXDAwMFxcMTMwXFwwMDJcXDE2MlxcMDAwXVxcMDAyXFwxNzhcXDAwMlxcMTk4XFwwMDJcXDIxMFxcMDAwXVxcMDAwXVxcMDAwXVxcMDAyXFwyMThcXDAwMlxcMjM1XFwwMDNcXDAwM1xcMDAwXVxcMDAwXFwwMDBcXDAwMF1cXDAwMFxcMDAwXFwwMDBdXFwwMDBdXFwwMDBcXDAwMFxcMDAwXVxcMDAwelxcMDAwXFwxNDFcXDAwMFxcMTQxXFwwMDBcXDE0MVxcMDAwXFwxNDFcXDAwMFxcMTQxXFwwMDBcXDAwMFxcMDAwXFwxNDFcXDAwMFxcMTQxXFwwMDBcXDE0NlxcMDAwXFwxNDFcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwxNDFcXDAwMFxcMTQxXFwwMDBcXDE0MVxcMDAwZlxcMDAwXFwxMzBcXDAwMFxcMDAwXFwwMDBcXDE0MVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwxNDFcXDAwMFxcMTQxXFwwMDBcXDE0MVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwxNDFcXDAwMFxcMDAwXFwwMDBcXDE0MVxcMDAwXFwwMDBcXDAwMFxcMTU0XFwwMDBcXDE0MVxcMDAwXFwwMDBcXDAwMFxcMTQxXFwwMDB6XFwwMDBcXDE0OVxcMDAwXFwxNDlcXDAwMFxcMTQ5XFwwMDBcXDE0OVxcMDAwXFwxNDlcXDAwMFxcMDAwXFwwMDBcXDE0OVxcMDAwXFwxNDlcXDAwMFxcMTQ2XFwwMDBcXDE0OVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDE0OVxcMDAwXFwxNDlcXDAwMFxcMTQ5XFwwMDBmXFwwMDBcXDEzMFxcMDAwXFwwMDBcXDAwMFxcMTQ5XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDE0OVxcMDAwXFwxNDlcXDAwMFxcMTQ5XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDE0OVxcMDAwXFwwMDBcXDAwMFxcMTQ5XFwwMDBcXDAwMFxcMDAwXFwxNTRcXDAwMFxcMTQ5XFwwMDBcXDAwMFxcMDAwXFwxNDlcXDAwMHpcXDAwMFxcMTM4XFwwMDBcXDE2MlxcMDAwXFwxMjlcXDAwMFxcMTcwXFwwMDBcXDEyOVxcMDAwXFwwMDBcXDAwMFxcMTI5XFwwMDBcXDEyOVxcMDAwXFwxNDZcXDAwMFxcMTI5XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMTkwXFwwMDBcXDE5OFxcMDAwXFwyMDZcXDAwMGZcXDAwMFxcMTMwXFwwMDBcXDAwMFxcMDAwXFwxMjlcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMTI5XFwwMDBcXDIxNFxcMDAwXFwyMjJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMjMwXFwwMDBcXDAwMFxcMDAwXFwxMjlcXDAwMFxcMDAwXFwwMDBcXDE1NFxcMDAwXFwxMjlcXDAwMFxcMDAwXFwwMDBcXDIzOFxcMDAwelxcMDAwXFwxMzhcXDAwMFxcMTYyXFwwMDBpXFwwMDBcXDE3MFxcMDAwaVxcMDAwXFwwMDBcXDAwMGlcXDAwMGlcXDAwMFxcMTQ2XFwwMDBpXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMGlcXDAwMFxcMTk4XFwwMDBcXDIwNlxcMDAwZlxcMDAwXFwxMzBcXDAwMFxcMDAwXFwwMDBpXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBpXFwwMDBcXDIxNFxcMDAwXFwyMjJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMGlcXDAwMFxcMDAwXFwwMDBpXFwwMDBcXDAwMFxcMDAwXFwxNTRcXDAwMGlcXDAwMFxcMDAwXFwwMDBpXFwwMDB6XFwwMDBcXDEzOFxcMDAwXFwxNjJcXDAwMHFcXDAwMFxcMTcwXFwwMDBxXFwwMDBcXDAwMFxcMDAwcVxcMDAwcVxcMDAwXFwxNDZcXDAwMHFcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwcVxcMDAwcVxcMDAwcVxcMDAwZlxcMDAwXFwxMzBcXDAwMFxcMDAwXFwwMDBxXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBxXFwwMDBxXFwwMDBxXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBxXFwwMDBcXDAwMFxcMDAwcVxcMDAwXFwwMDBcXDAwMFxcMTU0XFwwMDBxXFwwMDBcXDAwMFxcMDAwcVxcMDAwelxcMDAwXFwxMzhcXDAwMFxcMTYyXFwwMDBtXFwwMDBcXDE3MFxcMDAwbVxcMDAwXFwwMDBcXDAwMG1cXDAwMG1cXDAwMFxcMTQ2XFwwMDBtXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMG1cXDAwMG1cXDAwMG1cXDAwMGZcXDAwMFxcMTMwXFwwMDBcXDAwMFxcMDAwbVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwbVxcMDAwbVxcMDAwbVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwbVxcMDAwXFwwMDBcXDAwMG1cXDAwMFxcMDAwXFwwMDBcXDE1NFxcMDAwbVxcMDAwXFwwMDBcXDAwMG1cXDAwMHpcXDAwMFxcMTM4XFwwMDBcXDE2MlxcMDAweVxcMDAwXFwxNzBcXDAwMHlcXDAwMFxcMDAwXFwwMDB5XFwwMDB5XFwwMDBcXDE0NlxcMDAweVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDB5XFwwMDB5XFwwMDB5XFwwMDBmXFwwMDBcXDEzMFxcMDAwXFwwMDBcXDAwMHlcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMHlcXDAwMHlcXDAwMHlcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMHlcXDAwMFxcMDAwXFwwMDB5XFwwMDBcXDAwMFxcMDAwXFwxNTRcXDAwMHlcXDAwMFxcMDAwXFwwMDB5XFwwMDB6XFwwMDBcXDEzOFxcMDAwXFwxNjJcXDAwMHVcXDAwMFxcMTcwXFwwMDB1XFwwMDBcXDAwMFxcMDAwdVxcMDAwdVxcMDAwXFwxNDZcXDAwMHVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwdVxcMDAwdVxcMDAwdVxcMDAwZlxcMDAwXFwxMzBcXDAwMFxcMDAwXFwwMDB1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDB1XFwwMDB1XFwwMDB1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDB1XFwwMDBcXDAwMFxcMDAwdVxcMDAwXFwwMDBcXDAwMFxcMTU0XFwwMDB1XFwwMDBcXDAwMFxcMDAwdVxcMDAwelxcMDAwXFwxMzhcXDAwMFxcMTYyXFwwMDBlXFwwMDBcXDE3MFxcMDAwZVxcMDAwXFwwMDBcXDAwMGVcXDAwMGVcXDAwMFxcMTQ2XFwwMDBlXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMGVcXDAwMFxcMTk4XFwwMDBcXDIwNlxcMDAwZlxcMDAwXFwxMzBcXDAwMFxcMDAwXFwwMDBlXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBlXFwwMDBcXDIxNFxcMDAwXFwyMjJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMGVcXDAwMFxcMDAwXFwwMDBlXFwwMDBcXDAwMFxcMDAwXFwxNTRcXDAwMGVcXDAwMFxcMDAwXFwwMDBlXFwwMDB6XFwwMDBcXDEzOFxcMDAwXFwxNjJcXDAwMH1cXDAwMFxcMTcwXFwwMDB9XFwwMDBcXDAwMFxcMDAwfVxcMDAwfVxcMDAwXFwxNDZcXDAwMH1cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwxOTBcXDAwMFxcMTk4XFwwMDBcXDIwNlxcMDAwZlxcMDAwXFwxMzBcXDAwMFxcMDAwXFwwMDB9XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDB9XFwwMDBcXDIxNFxcMDAwXFwyMjJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMjMwXFwwMDBcXDAwMFxcMDAwfVxcMDAwXFwwMDBcXDAwMFxcMTU0XFwwMDB9XFwwMDBcXDAwMFxcMDAwfVxcMDAwelxcMDAwXFwxMzhcXDAwMFxcMTYyXFwwMDBcXDEzN1xcMDAwXFwxNzBcXDAwMFxcMTM3XFwwMDBcXDAwMFxcMDAwXFwxMzdcXDAwMFxcMTM3XFwwMDBcXDE0NlxcMDAwXFwxODJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwxOTBcXDAwMFxcMTk4XFwwMDBcXDIwNlxcMDAwZlxcMDAwXFwxMzBcXDAwMFxcMDAwXFwwMDBcXDEzN1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyNTRcXDAwMFxcMjE0XFwwMDBcXDIyMlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyMzBcXDAwMFxcMDAwXFwwMDBcXDEzN1xcMDAwXFwwMDBcXDAwMFxcMTU0XFwwMDBcXDEzN1xcMDAwXFwwMDBcXDAwMFxcMjM4XFwwMDB6XFwwMDBcXDEzOFxcMDAwXFwxNjJcXDAwMFxcMTMzXFwwMDBcXDE3MFxcMDAwXFwxMzNcXDAwMFxcMDAwXFwwMDBcXDEzM1xcMDAwXFwxMzNcXDAwMFxcMTQ2XFwwMDBcXDE4MlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDE5MFxcMDAwXFwxOThcXDAwMFxcMjA2XFwwMDBmXFwwMDBcXDEzMFxcMDAwXFwwMDBcXDAwMFxcMTMzXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDEzM1xcMDAwXFwyMTRcXDAwMFxcMjIyXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDIzMFxcMDAwXFwwMDBcXDAwMFxcMTMzXFwwMDBcXDAwMFxcMDAwXFwxNTRcXDAwMFxcMTMzXFwwMDBcXDAwMFxcMDAwXFwyMzhcXDAwMHpcXDAwMFxcMTUzXFwwMDBcXDE1M1xcMDAwXFwxNTNcXDAwMFxcMTUzXFwwMDBcXDE1M1xcMDAwXFwwMDBcXDAwMFxcMTUzXFwwMDBcXDE1M1xcMDAwXFwxNTNcXDAwMFxcMTUzXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMTUzXFwwMDBcXDE1M1xcMDAwXFwxNTNcXDAwMGZcXDAwMFxcMTMwXFwwMDBcXDAwMFxcMDAwXFwxNTNcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMTUzXFwwMDBcXDE1M1xcMDAwXFwxNTNcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMTUzXFwwMDBcXDAwMFxcMDAwXFwxNTNcXDAwMFxcMDAwXFwwMDBcXDE1M1xcMDAwXFwxNTNcXDAwMFxcMDAwXFwwMDBcXDE1M1xcMDAwXFwxNjFcXDAwMFxcMTYxXFwwMDBcXDE2MVxcMDAwXFwxNjFcXDAwMFxcMTYxXFwwMDBcXDE2MVxcMDAwXFwwMDBcXDAwMFxcMTYxXFwwMDBcXDE2MVxcMDAwXFwxNjFcXDAwMFxcMTYxXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMTYxXFwwMDBcXDE2MVxcMDAwXFwxNjFcXDAwMGZcXDAwMFxcMTMwXFwwMDBcXDAwMFxcMDAwXFwxNjFcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMTYxXFwwMDBcXDE2MVxcMDAwXFwxNjFcXDAwMFxcMDAwXFwwMDE+XFwwMDAmXFwwMDBcXDE2MVxcMDAwXFwwMThcXDAwMFxcMTYxXFwwMDBcXDAyNlxcMDAwXFwxNjFcXDAwMFxcMTYxXFwwMDBcXDAwMFxcMDAwXFwxNjFcXDAwMCFcXDAwMCFcXDAwMFxcMjUzXFwwMDAhXFwwMDAhXFwwMDAhXFwwMDAhXFwwMDAhXFwwMDAhXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMCFcXDAwMCFcXDAwMFxcMDAwXFwwMDAhXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDAhXFwwMDBcXDAwMFxcMDAyYlxcMDAwXFwwMDBcXDAwMCFcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyMjFcXDAwMCFcXDAwMCFcXDAwMCFcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDAhXFwwMDAhXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMCFcXDAwMVxcMTkwXFwwMDAhXFwwMDBcXDAwMFxcMDAwIVxcMDAwelxcMDAwXFwxMzhcXDAwMFxcMTYyXFwwMDFcXDE2NlxcMDAwXFwxNzBcXDAwMVxcMDE3XFwwMDBcXDAwMFxcMDAwXFwxNzhcXDAwMVxcMDE3XFwwMDBcXDE0NlxcMDAwXFwxODJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwxOTBcXDAwMFxcMTk4XFwwMDBcXDIwNlxcMDAwZlxcMDAwXFwxMzBcXDAwMFxcMDAwXFwwMDBcXDI0NlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyNTRcXDAwMFxcMjE0XFwwMDBcXDIyMlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyMzBcXDAwMFxcMDAwXFwwMDE3XFwwMDBcXDAwMFxcMDAwXFwxNTRcXDAwMVxcMDA2XFwwMDBcXDAwMFxcMDAwXFwyMzhcXDAwMHpcXDAwMFxcMTM4XFwwMDBcXDE2MlxcMDAxbVxcMDAwXFwxNzBcXDAwMVxcMDIyXFwwMDBcXDAwMFxcMDAxJlxcMDAwXFwwMDBcXDAwMFxcMTQ2XFwwMDBcXDE4MlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDE5MFxcMDAwXFwxOThcXDAwMFxcMjA2XFwwMDBmXFwwMDBcXDEzMFxcMDAwXFwwMDBcXDAwMFxcMjQ2XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDI1NFxcMDAwXFwyMTRcXDAwMFxcMjIyXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDIzMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwxNTRcXDAwMW1cXDAwMFxcMDAwXFwwMDBcXDIzOFxcMDAxdlxcMDAxXFwxMzhcXDAwMFxcMDAwXFwwMDBcXDAwNlxcMDAwXFwwMTRcXDAwMFxcMDE4XFwwMDBcXDAyMlxcMDAwXFwwMjZcXDAwMFxcMDMwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMVFcXDAwMVxcMTU0XFwwMDBcXDAwMFxcMDAwXFwyMjlcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXCJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMDpcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMD5cXDAwMVxcMTcwXFwwMDFcXDIwNlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMVxcMjEwXFwwMDBGXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwSlxcMDAwXFwwMDBcXDAwME5cXDAwMHpcXDAwMFxcMTM4XFwwMDBcXDE2MlxcMDAyXFwwMTRcXDAwMFxcMTcwXFwwMDFcXDEzMFxcMDAwXFwwMDBcXDAwMjJcXDAwMFxcMDAwXFwwMDBcXDE0NlxcMDAwXFwxODJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwxOTBcXDAwMFxcMTk4XFwwMDBcXDIwNlxcMDAwZlxcMDAwXFwxMzBcXDAwMFxcMDAwXFwwMDBcXDI0NlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyNTRcXDAwMFxcMjE0XFwwMDBcXDIyMlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyMzBcXDAwMHpcXDAwMFxcMTM4XFwwMDBcXDE2MlxcMDAwXFwxNTRcXDAwMFxcMTcwXFwwMDFcXDE4MlxcMDAwXFwyMzhcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwxNDZcXDAwMFxcMTgyXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMTkwXFwwMDBcXDE5OFxcMDAwXFwyMDZcXDAwMGZcXDAwMFxcMTMwXFwwMDBcXDAwMFxcMDAwXFwyNDZcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMjU0XFwwMDBcXDIxNFxcMDAwXFwyMjJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMjMwXFwwMDAtXFwwMDAtXFwwMDAtXFwwMDBcXDE1NFxcMDAwLVxcMDAwXFwwMDBcXDAwMFxcMjM4XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMC1cXDAwMC1cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwLVxcMDAwLVxcMDAwLVxcMDAwLVxcMDAwLVxcMDAwXFwwMDBcXDAwMC1cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMC1cXDAwMC1cXDAwMC1cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMC1cXDAwMFxcMjEzXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMC1cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwLVxcMDAwTVxcMDAwTVxcMDAwTVxcMDAyJlxcMDAwTVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwME1cXDAwME1cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwTVxcMDAwTVxcMDAwTVxcMDAwTVxcMDAwTVxcMDAwXFwwMDBcXDAwME1cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwME1cXDAwME1cXDAwME1cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwME1cXDAwMElcXDAwMElcXDAwMElcXDAwME1cXDAwMElcXDAwMFxcMDAwXFwwMDBNXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMElcXDAwMElcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwSVxcMDAwSVxcMDAwSVxcMDAwSVxcMDAwSVxcMDAwXFwwMDBcXDAwMElcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMElcXDAwMElcXDAwMElcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMElcXDAwMFxcMjE3XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMElcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwSVxcMDAwelxcMDAwXFwxMzhcXDAwMFxcMTYyXFwwMDBcXDE3M1xcMDAwXFwxNzBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDE0NlxcMDAwXFwxODJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwxOTBcXDAwMFxcMTk4XFwwMDBcXDIwNlxcMDAwZlxcMDAwXFwxMzBcXDAwMFxcMDAwXFwwMDBcXDI0NlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyNTRcXDAwMFxcMjE0XFwwMDBcXDIyMlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyMzBcXDAwMHpcXDAwMFxcMTM4XFwwMDBcXDE2MlxcMDAwXFwxNTRcXDAwMFxcMTcwXFwwMDBcXDAwMFxcMDAwXFwyMzhcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwxNDZcXDAwMFxcMTgyXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMTkwXFwwMDBcXDE5OFxcMDAwXFwyMDZcXDAwMlxcMDI2XFwwMDIqXFwwMDBcXDAwMFxcMDAwXFwyNDZcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMjU0XFwwMDBcXDIxNFxcMDAwXFwyMjJcXDAwMm5cXDAwMnZcXDAwMFxcMDE4XFwwMDBcXDIzMFxcMDAwXFwwMjZcXDAwMnpcXDAwMFxcMDAwXFwwMDBcXDE1NFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDIzOFxcMDAwXFwwMDZcXDAwMFxcMDE0XFwwMDBcXDAxOFxcMDAwXFwwMjJcXDAwMFxcMDI2XFwwMDBcXDAzMFxcMDAwXFwwMDBcXDAwMn5cXDAwMFxcMDAwXFwwMDFcXDE1OFxcMDAwXFwwMDBcXDAwMFxcMjM3XFwwMDBcXDAwMFxcMDAwMlxcMDAwXFwyMzdcXDAwMlxcMTQ2XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXCJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMDpcXDAwMlxcMTUwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMD5cXDAwMFxcMDAwXFwwMDBCXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMEZcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBKXFwwMDBcXDAwMFxcMDAwTlxcMDAwXFwwMDZcXDAwMFxcMDE0XFwwMDBcXDAxOFxcMDAwXFwwMjJcXDAwMFxcMDI2XFwwMDBcXDAzMFxcMDAyblxcMDAydlxcMDAwXFwwMThcXDAwMFxcMTY5XFwwMDBcXDAyNlxcMDAyelxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcIlxcMDAwXFwwMDBcXDAwMFxcMjQ1XFwwMDBcXDAwMFxcMDAwOlxcMDAwXFwwMDBcXDAwMn5cXDAwMFxcMDAwXFwwMDA+XFwwMDBcXDAwMFxcMDAwQlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAyXFwxNDZcXDAwMFxcMDAwXFwwMDBGXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwSlxcMDAyXFwxNTBcXDAwME5cIikpXG4gIFxuICBhbmQgbGhzID1cbiAgICAoOCwgXCJcXDAwMlxcMDAxXFwwMDBcXDAyOVxcMDI4XFwwMjdcXDAyN1xcMDI3XFwwMjZcXDAyNlxcMDI2XFwwMjVcXDAyNVxcMDI1XFwwMjVcXDAyNVxcMDI1XFwwMjVcXDAyNVxcMDI1XFwwMjVcXDAyNVxcMDI1XFwwMjVcXDAyNVxcMDI1XFwwMjVcXDAyNVxcMDI1XFwwMjVcXDAyNVxcMDI1XFwwMjVcXDAyNVxcMDI1XFwwMjVcXDAyNVxcMDI1XFwwMjVcXDAyNVxcMDI1XFwwMjVcXDAyNFxcMDI0XFwwMjNcXDAyMlxcMDIyXFwwMjJcXDAyMlxcMDIyXFwwMjJcXDAyMlxcMDIxXFwwMjBcXDAyMFxcMDE5XFwwMTlcXDAxOFxcMDE4XFwwMTdcXDAxN1xcMDE2XFwwMTZcXDAxNVxcMDE1XFwwMTRcXDAxNFxcclxcMDEyXFwwMTJcXDAxMVxcMDExXFxuXFxuXFx0XFx0XFxiXFxiXFxiXFxiXFxiXFxiXFxiXFxiXFwwMDdcXDAwN1xcMDA2XFwwMDVcXDAwNVxcMDA1XFwwMDVcXDAwNFxcMDAzXCIpXG4gIFxuICBhbmQgZ290byA9XG4gICAgKCgxNiwgXCJcXDAwMGpcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAxMlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBSXFwwMDBcXDAwMFxcMDAwNlxcMDAwXFwxMzJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMTM2XFwwMDBcXDEzOFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDA4XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwxNTRcXDAwMFxcMDAwXFwwMDBcXDE1NlxcMDAwXFwwMDBcXDAwMFxcMTYwXFwwMDBcXDAwMFxcMDAwXFwxNjhcXDAwMFxcMDAwXFwwMDBcXDE3MFxcMDAwXFwwMDBcXDAwMFxcMTgwXFwwMDBcXDAwMFxcMDAwXFwxODJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwxODRcXDAwMFxcMDAwXFwwMDBcXDE4OFxcMDAwXFwwMDBcXDAwMFxcMTkwXFwwMDBcXDAwMFxcMDAwXFwxOTJcXDAwMFxcMDAwXFwwMDBcXDE5OFxcMDAwXFwwMDBcXDAwMFxcMjAyXFwwMDBcXDAwMFxcMDAwXFwyMDRcXDAwMFxcMDAwXFwwMDBcXDIwNlxcMDAwXFwwMDBcXDAwMFxcMjEyXFwwMDBcXDAwMFxcMDAwXFwyMTRcXDAwMFxcMDAwXFwwMDB+XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBIXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcblxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMjE2XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMzFcXDAwMFxcdFxcMDAwXFwwMDBcXDAwMFxcMjE4XFwwMDBcXDAwMFxcMDAwXFwwMTRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMjM0XFwwMDBcXDAwMFxcMDAwXFwyMzZcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDI0MFxcMDAwXFwwMDBcXDAwMFxcMDE2XFwwMDBcXDAyMlxcMDAwXFwyMTZcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXlxcMDAwXFwwMDBcXDAwMG5cXDAwMFxcMDAwXFwwMDBcXDAwNVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMjBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMjUwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwaFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAxXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDFcXDAwNlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxiXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDFcXGJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDFcXG5cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFZcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDE1MlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDByXFwwMDBcXDAwMFxcMDAwXFwyMjJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDEzMFxcMDAwXFwwMDBcXDAwMCxcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcIiksICg4LCBcIntcXDAyMXtcXDAyMVxcMTQ4fVxcMTI4XFwwMTF7XFwwMjFTXFwwMjFcXDE0OFxcMTUyXFwxNTBZXFwxMjlcXDEzM1xcMTI5XFwxMzNaXFwxMzRcXDE0OVxcMTM0XFwxMjlcXDEzM3tcXDAyMVxcMTkxXFwxMzRcXDE5MktcXDAyMVxcMDIxW2Jvc1xcMTI3XFwwMjdcXDAyN1xcMTc5XFwxMjlcXDEzM0dcXDAyOFxcMDIxXFwxMzRcXDE2N1xcMTg1d1xcMTQzXFwwMzBcXDAzMFxcMTcxXFwxODZcXDE0NlxcMDIxXFwwMjFcXDE3MlxcMDIxXFwxNDdTXFwxODhcXDAyN1xcMTc0SVlcXDAyMVxcMTM2XFwxNzlcXDAyMVpcXDAyMVxcMDIxQ0xcXDAzME15XFwxNDJcXDE2N1xcMDIxXFwwMjFcXDE4OVxcMDIxXFwxODJcXDE3NlxcMDMwXFwwMjFcXDAyMUVcXDE4OERcXDAyNVxcMDIxXFwwMjFcXDAyMVxcMTc0XFwwMjFcXDAyMVxcMDIxIFxcXCJcXDAyMSRcXDAyMVxcMDIxXFwwMjEmKFxcMDIxXFwwMjFTXFwwMjEqLC9YMTM1XFwwMjFcXDAyMTdcXDAyMTk7PXFcXDAyMT9BXFwwMjFgXFwxNDNyXFwxNjdcXDE2MVxcMTg0XFwxNDVcXDAwMGZpXFwwMDBtXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDEzMVxcMDAwXFwwMDBcXDE0MFxcMTc3XCIpKVxuICBcbiAgYW5kIHNlbWFudGljX2FjdGlvbiA9XG4gICAgW3xcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB4cztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3hzXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeHNfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IHhzIDogJ3R2X2xvcHRpb25fc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQ09NTUFfcGFpcl90eV9JREVOVF9fXyA9IE9iai5tYWdpYyB4cyBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfeHNfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc194c18gaW5cbiAgICAgICAgbGV0IF92IDogJ3R2X2FyZ2xpc3QgPSBsZXQgbCA9IFxuIyAyMzIgXCI8c3RhbmRhcmQubWx5PlwiXG4gICAgKCB4cyApXG4jIDMyNCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIFxuIyAxMDMgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIGwgKVxuIyAzMjkgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzM7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fM187XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18zXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHN0bXRzO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19zdG10c187XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3Nfc3RtdHNfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF8zIDogdW5pdCA9IE9iai5tYWdpYyBfMyBpblxuICAgICAgICBsZXQgc3RtdHMgOiAndHZfbGlzdF9zdG10XyA9IE9iai5tYWdpYyBzdG10cyBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX18zXyBpblxuICAgICAgICBsZXQgX3YgOiAoXG4jIDgzIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuYmxvY2spXG4jIDM2OCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IFxuIyAyMDMgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIHN0bXRzIClcbiMgMzcyIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF81O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzVfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fNV87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBpbml0O1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19pbml0XztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19pbml0XztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8zO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18zXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18zXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IG5hbWU7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19uYW1lXztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfbmFtZV87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfNSA6IHVuaXQgPSBPYmoubWFnaWMgXzUgaW5cbiAgICAgICAgbGV0IGluaXQgOiAndHZfZ2V4cCA9IE9iai5tYWdpYyBpbml0IGluXG4gICAgICAgIGxldCBfMyA6IHVuaXQgPSBPYmoubWFnaWMgXzMgaW5cbiAgICAgICAgbGV0IG5hbWUgOiAoXG4jIDE0IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyA0MjAgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgbmFtZSBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX181XyBpblxuICAgICAgICBsZXQgX3YgOiAndHZfZGVjbCA9IGxldCBfZW5kcG9zID0gX2VuZHBvc19fNV8gaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgXG4jIDk4IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAoIEd2ZGVjbCAobG9jIF9zdGFydHBvcyBfZW5kcG9zIHsgbmFtZTsgaW5pdCB9KSApXG4jIDQzMSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBib2R5O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfYm9keV87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2JvZHlfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzU7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX181XztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fNV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBhcmdzO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2FyZ3NfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfYXJnc187XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18zXztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzNfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZm5hbWU7XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2ZuYW1lXztcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19mbmFtZV87XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgYm9keSA6IChcbiMgODMgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5ibG9jaylcbiMgNDgyIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGJvZHkgaW5cbiAgICAgICAgbGV0IF81IDogdW5pdCA9IE9iai5tYWdpYyBfNSBpblxuICAgICAgICBsZXQgYXJncyA6ICd0dl9hcmdsaXN0ID0gT2JqLm1hZ2ljIGFyZ3MgaW5cbiAgICAgICAgbGV0IF8zIDogdW5pdCA9IE9iai5tYWdpYyBfMyBpblxuICAgICAgICBsZXQgZm5hbWUgOiAoXG4jIDE0IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyA0OTAgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgZm5hbWUgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19ib2R5XyBpblxuICAgICAgICBsZXQgX3YgOiAndHZfZGVjbCA9IGxldCBmcnR5cCA9IFxuIyAxMTIgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAoIFJldFZvaWQgKVxuIyA0OTkgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zX2ZydHlwXyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2JvZHlfIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfZnJ0eXBfIGluXG4gICAgICAgIFxuIyAxMDAgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICggR2ZkZWNsIChsb2MgX3N0YXJ0cG9zIF9lbmRwb3MgeyBmcnR5cDsgZm5hbWU7IGFyZ3M7IGJvZHkgfSkgKVxuIyA1MDcgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gYm9keTtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2JvZHlfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19ib2R5XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF81O1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fNV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzVfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gYXJncztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19hcmdzXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2FyZ3NfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzM7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fM187XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18zXztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGZuYW1lO1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19mbmFtZV87XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZm5hbWVfO1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB0O1xuICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3RfO1xuICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfdF87XG4gICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IGJvZHkgOiAoXG4jIDgzIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuYmxvY2spXG4jIDU1OCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBib2R5IGluXG4gICAgICAgIGxldCBfNSA6IHVuaXQgPSBPYmoubWFnaWMgXzUgaW5cbiAgICAgICAgbGV0IGFyZ3MgOiAndHZfYXJnbGlzdCA9IE9iai5tYWdpYyBhcmdzIGluXG4gICAgICAgIGxldCBfMyA6IHVuaXQgPSBPYmoubWFnaWMgXzMgaW5cbiAgICAgICAgbGV0IGZuYW1lIDogKFxuIyAxNCBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgKHN0cmluZylcbiMgNTY2IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGZuYW1lIGluXG4gICAgICAgIGxldCB0IDogKFxuIyA4NCBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LnR5KVxuIyA1NzEgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgdCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfdF8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2JvZHlfIGluXG4gICAgICAgIGxldCBfdiA6ICd0dl9kZWNsID0gbGV0IGZydHlwID0gXG4jIDExMyBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICggUmV0VmFsIHQgKVxuIyA1NzkgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zX2ZydHlwXyA9IF9zdGFydHBvc190XyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfYm9keV8gaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19mcnR5cF8gaW5cbiAgICAgICAgXG4jIDEwMCBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgKCBHZmRlY2wgKGxvYyBfc3RhcnRwb3MgX2VuZHBvcyB7IGZydHlwOyBmbmFtZTsgYXJnczsgYm9keSB9KSApXG4jIDU4NyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQgX21lbmhpcl9zID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLmN1cnJlbnQgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9zdGFydHBvcyBpblxuICAgICAgICBsZXQgX3YgOiAndHZfZWxzZV9zdG10ID0gXG4jIDIxMCBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgKCBbXSApXG4jIDYwNSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBiO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfYl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2JfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgYiA6IChcbiMgODMgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5ibG9jaylcbiMgNjMyIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGIgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19iXyBpblxuICAgICAgICBsZXQgX3YgOiAndHZfZWxzZV9zdG10ID0gXG4jIDIxMSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgKCBiIClcbiMgNjQxIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGlmcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2lmc187XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2lmc187XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBpZnMgOiAndHZfaWZfc3RtdCA9IE9iai5tYWdpYyBpZnMgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19pZnNfIGluXG4gICAgICAgIGxldCBfdiA6ICd0dl9lbHNlX3N0bXQgPSBcbiMgMjEyIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAoIFsgaWZzIF0gKVxuIyA2NzMgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBpZDtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2lkXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfaWRfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IGlkIDogKFxuIyAxNCBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgKHN0cmluZylcbiMgNjk0IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGlkIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19pZF8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2lkXyBpblxuICAgICAgICBsZXQgX3YgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyA3MDIgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfaWRfIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfaWRfIGluXG4gICAgICAgIFxuIyAxNTcgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKCBsb2MgX3N0YXJ0cG9zIF9lbmRwb3MgQEAgSWQgaWQgKVxuIyA3MDggXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBpO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfaV87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2lfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IGkgOiAoXG4jIDExIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAoaW50NjQpXG4jIDcyOSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBpIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19pXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfaV8gaW5cbiAgICAgICAgbGV0IF92IDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgNzM3IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2lfIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfaV8gaW5cbiAgICAgICAgXG4jIDE1OCBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAoIGxvYyBfc3RhcnRwb3MgX2VuZHBvcyBAQCBDSW50IGkgKVxuIyA3NDMgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBzO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3Nfc187XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3NfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IHMgOiAoXG4jIDEzIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyA3NjQgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgcyBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3Nfc18gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3NfIGluXG4gICAgICAgIGxldCBfdiA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDc3MiBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IGxldCBfZW5kcG9zID0gX2VuZHBvc19zXyBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3NfIGluXG4gICAgICAgIFxuIyAxNTkgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKCBsb2MgX3N0YXJ0cG9zIF9lbmRwb3MgQEAgQ1N0ciBzIClcbiMgNzc4IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8yO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfMiA6IHVuaXQgPSBPYmoubWFnaWMgXzIgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fMl8gaW5cbiAgICAgICAgbGV0IF92IDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgODEwIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gbGV0IHQgPSBcbiMgMTE2IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICggUlN0cmluZyApXG4jIDgxNCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3NfdF8gPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fMl8gaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc190XyBpblxuICAgICAgICBcbiMgMTYwIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCBsb2MgX3N0YXJ0cG9zIF9lbmRwb3MgQEAgQ051bGwgdCApXG4jIDgyMiBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18yXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzM7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18zXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fM187XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMl9pbmxpbmVkMTtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMl9pbmxpbmVkMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMl9pbmxpbmVkMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHQ7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc190XztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfdF87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgXzIgOiB1bml0ID0gT2JqLm1hZ2ljIF8yIGluXG4gICAgICAgIGxldCBfMyA6IHVuaXQgPSBPYmoubWFnaWMgXzMgaW5cbiAgICAgICAgbGV0IF8yX2lubGluZWQxIDogdW5pdCA9IE9iai5tYWdpYyBfMl9pbmxpbmVkMSBpblxuICAgICAgICBsZXQgdCA6IChcbiMgODQgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC50eSlcbiMgODY0IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIHQgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3RfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fMl8gaW5cbiAgICAgICAgbGV0IF92IDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgODcyIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gbGV0IHQgPVxuICAgICAgICAgIGxldCBfMiA9IF8yX2lubGluZWQxIGluXG4gICAgICAgICAgXG4jIDExNyBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoIFJBcnJheSB0IClcbiMgODc4IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgIFxuICAgICAgICBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzJfIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfdF8gaW5cbiAgICAgICAgXG4jIDE2MCBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICggbG9jIF9zdGFydHBvcyBfZW5kcG9zIEBAIENOdWxsIHQgKVxuIyA4ODYgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF92IDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgOTExIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gbGV0IF9lbmRwb3MgPSBfZW5kcG9zX18xXyBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBcbiMgMTYxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICggbG9jIF9zdGFydHBvcyBfZW5kcG9zIEBAIENCb29sIHRydWUgKVxuIyA5MTcgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF92IDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgOTQyIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gbGV0IF9lbmRwb3MgPSBfZW5kcG9zX18xXyBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBcbiMgMTYyIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAoIGxvYyBfc3RhcnRwb3MgX2VuZHBvcyBAQCBDQm9vbCBmYWxzZSApXG4jIDk0OCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfNDtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX180XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzRfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gaTtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfaV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfaV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMjtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMl87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMl87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGU7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19lXztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZV87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgXzQgOiB1bml0ID0gT2JqLm1hZ2ljIF80IGluXG4gICAgICAgIGxldCBpIDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgOTg4IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGkgaW5cbiAgICAgICAgbGV0IF8yIDogdW5pdCA9IE9iai5tYWdpYyBfMiBpblxuICAgICAgICBsZXQgZSA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDk5NCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBlIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19lXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzRfIGluXG4gICAgICAgIGxldCBfdiA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDEwMDIgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzRfIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfZV8gaW5cbiAgICAgICAgXG4jIDE2NCBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAoIGxvYyBfc3RhcnRwb3MgX2VuZHBvcyBAQCBJbmRleCAoZSwgaSkgKVxuIyAxMDA4IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF80O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzRfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fNF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB4cztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfeHNfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3hzXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8yO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18yXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18yXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZTtcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2VfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19lXztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfNCA6IHVuaXQgPSBPYmoubWFnaWMgXzQgaW5cbiAgICAgICAgbGV0IHhzIDogJ3R2X2xvcHRpb25fc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQ09NTUFfZXhwX18gPSBPYmoubWFnaWMgeHMgaW5cbiAgICAgICAgbGV0IF8yIDogdW5pdCA9IE9iai5tYWdpYyBfMiBpblxuICAgICAgICBsZXQgZSA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDEwNTAgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgZSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfZV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX180XyBpblxuICAgICAgICBsZXQgX3YgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAxMDU4IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gbGV0IGVzID0gXG4jIDIzMiBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIHhzIClcbiMgMTA2MiBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fNF8gaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19lXyBpblxuICAgICAgICBcbiMgMTY2IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICggbG9jIF9zdGFydHBvcyBfZW5kcG9zIEBAIENhbGwgKGUsZXMpIClcbiMgMTA2OSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfNztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX183XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzdfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0geHM7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3hzXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc194c187XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfNTtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fNV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fNV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfNDtcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX180XztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzRfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzM7XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18zXztcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fM187XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB0O1xuICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3RfO1xuICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfdF87XG4gICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgXzcgOiB1bml0ID0gT2JqLm1hZ2ljIF83IGluXG4gICAgICAgIGxldCB4cyA6ICd0dl9sb3B0aW9uX3NlcGFyYXRlZF9ub25lbXB0eV9saXN0X0NPTU1BX2V4cF9fID0gT2JqLm1hZ2ljIHhzIGluXG4gICAgICAgIGxldCBfNSA6IHVuaXQgPSBPYmoubWFnaWMgXzUgaW5cbiAgICAgICAgbGV0IF80IDogdW5pdCA9IE9iai5tYWdpYyBfNCBpblxuICAgICAgICBsZXQgXzMgOiB1bml0ID0gT2JqLm1hZ2ljIF8zIGluXG4gICAgICAgIGxldCB0IDogKFxuIyA4NCBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LnR5KVxuIyAxMTMxIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIHQgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fN18gaW5cbiAgICAgICAgbGV0IF92IDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMTE0MCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IGxldCBlcyA9IFxuIyAyMzIgXCI8c3RhbmRhcmQubWx5PlwiXG4gICAgKCB4cyApXG4jIDExNDQgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzdfIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIFxuIyAxNjggXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKCBsb2MgX3N0YXJ0cG9zIF9lbmRwb3MgQEAgQ0Fycih0LCBlcykgKVxuIyAxMTUxIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF81O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzVfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fNV87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBlO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19lXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19lXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8zO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18zXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18zXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHQ7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc190XztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfdF87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfNSA6IHVuaXQgPSBPYmoubWFnaWMgXzUgaW5cbiAgICAgICAgbGV0IGUgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAxMTk3IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGUgaW5cbiAgICAgICAgbGV0IF8zIDogdW5pdCA9IE9iai5tYWdpYyBfMyBpblxuICAgICAgICBsZXQgdCA6IChcbiMgODQgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC50eSlcbiMgMTIwMyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyB0IGluXG4gICAgICAgIGxldCBfMSA6IHVuaXQgPSBPYmoubWFnaWMgXzEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzVfIGluXG4gICAgICAgIGxldCBfdiA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDEyMTIgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzVfIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIFxuIyAxNzAgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKCBsb2MgX3N0YXJ0cG9zIF9lbmRwb3MgQEAgTmV3QXJyKHQsIGUpIClcbiMgMTIxOCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBlMjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2UyXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZTJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGUxO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2UxXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2UxXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgZTIgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAxMjUxIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGUyIGluXG4gICAgICAgIGxldCBfMSA6IHVuaXQgPSBPYmoubWFnaWMgXzEgaW5cbiAgICAgICAgbGV0IGUxIDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMTI1NyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBlMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfZTFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19lMl8gaW5cbiAgICAgICAgbGV0IF92IDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMTI2NSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IGxldCBiID0gXG4jIDEyMCBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICggQWRkIClcbiMgMTI2OSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19lMl8gaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19lMV8gaW5cbiAgICAgICAgXG4jIDE3MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAoIGxvYyBfc3RhcnRwb3MgX2VuZHBvcyBAQCBCb3AgKGIsIGUxLCBlMikgKVxuIyAxMjc2IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGUyO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZTJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19lMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZTE7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZTFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZTFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBlMiA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDEzMDkgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgZTIgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgZTEgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAxMzE1IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGUxIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19lMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2UyXyBpblxuICAgICAgICBsZXQgX3YgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAxMzIzIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gbGV0IGIgPSBcbiMgMTIxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgKCBTdWIgKVxuIyAxMzI3IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2UyXyBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2UxXyBpblxuICAgICAgICBcbiMgMTcxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICggbG9jIF9zdGFydHBvcyBfZW5kcG9zIEBAIEJvcCAoYiwgZTEsIGUyKSApXG4jIDEzMzQgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZTI7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19lMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2UyXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBlMTtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19lMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19lMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IGUyIDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMTM2NyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBlMiBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBlMSA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDEzNzMgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgZTEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2UxXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfZTJfIGluXG4gICAgICAgIGxldCBfdiA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDEzODEgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBsZXQgYiA9IFxuIyAxMjIgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAoIE11bCApXG4jIDEzODUgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfZTJfIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfZTFfIGluXG4gICAgICAgIFxuIyAxNzEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKCBsb2MgX3N0YXJ0cG9zIF9lbmRwb3MgQEAgQm9wIChiLCBlMSwgZTIpIClcbiMgMTM5MiBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBlMjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2UyXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZTJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGUxO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2UxXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2UxXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgZTIgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAxNDI1IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGUyIGluXG4gICAgICAgIGxldCBfMSA6IHVuaXQgPSBPYmoubWFnaWMgXzEgaW5cbiAgICAgICAgbGV0IGUxIDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMTQzMSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBlMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfZTFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19lMl8gaW5cbiAgICAgICAgbGV0IF92IDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMTQzOSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IGxldCBiID0gXG4jIDEyMyBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICggRXEgKVxuIyAxNDQzIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2UyXyBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2UxXyBpblxuICAgICAgICBcbiMgMTcxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICggbG9jIF9zdGFydHBvcyBfZW5kcG9zIEBAIEJvcCAoYiwgZTEsIGUyKSApXG4jIDE0NTAgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZTI7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19lMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2UyXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBlMTtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19lMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19lMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IGUyIDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMTQ4MyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBlMiBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBlMSA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDE0ODkgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgZTEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2UxXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfZTJfIGluXG4gICAgICAgIGxldCBfdiA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDE0OTcgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBsZXQgYiA9IFxuIyAxMjQgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICggTmVxIClcbiMgMTUwMSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19lMl8gaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19lMV8gaW5cbiAgICAgICAgXG4jIDE3MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAoIGxvYyBfc3RhcnRwb3MgX2VuZHBvcyBAQCBCb3AgKGIsIGUxLCBlMikgKVxuIyAxNTA4IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGUyO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZTJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19lMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZTE7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZTFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZTFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBlMiA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDE1NDEgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgZTIgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgZTEgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAxNTQ3IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGUxIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19lMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2UyXyBpblxuICAgICAgICBsZXQgX3YgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAxNTU1IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gbGV0IGIgPSBcbiMgMTI1IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICggTHQgKVxuIyAxNTU5IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2UyXyBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2UxXyBpblxuICAgICAgICBcbiMgMTcxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICggbG9jIF9zdGFydHBvcyBfZW5kcG9zIEBAIEJvcCAoYiwgZTEsIGUyKSApXG4jIDE1NjYgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZTI7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19lMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2UyXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBlMTtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19lMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19lMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IGUyIDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMTU5OSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBlMiBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBlMSA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDE2MDUgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgZTEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2UxXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfZTJfIGluXG4gICAgICAgIGxldCBfdiA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDE2MTMgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBsZXQgYiA9IFxuIyAxMjYgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICggTHRlIClcbiMgMTYxNyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19lMl8gaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19lMV8gaW5cbiAgICAgICAgXG4jIDE3MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAoIGxvYyBfc3RhcnRwb3MgX2VuZHBvcyBAQCBCb3AgKGIsIGUxLCBlMikgKVxuIyAxNjI0IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGUyO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZTJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19lMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZTE7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZTFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZTFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBlMiA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDE2NTcgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgZTIgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgZTEgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAxNjYzIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGUxIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19lMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2UyXyBpblxuICAgICAgICBsZXQgX3YgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAxNjcxIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gbGV0IGIgPSBcbiMgMTI3IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICggR3QgKVxuIyAxNjc1IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2UyXyBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2UxXyBpblxuICAgICAgICBcbiMgMTcxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICggbG9jIF9zdGFydHBvcyBfZW5kcG9zIEBAIEJvcCAoYiwgZTEsIGUyKSApXG4jIDE2ODIgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZTI7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19lMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2UyXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBlMTtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19lMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19lMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IGUyIDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMTcxNSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBlMiBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBlMSA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDE3MjEgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgZTEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2UxXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfZTJfIGluXG4gICAgICAgIGxldCBfdiA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDE3MjkgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBsZXQgYiA9IFxuIyAxMjggXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICggR3RlIClcbiMgMTczMyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19lMl8gaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19lMV8gaW5cbiAgICAgICAgXG4jIDE3MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAoIGxvYyBfc3RhcnRwb3MgX2VuZHBvcyBAQCBCb3AgKGIsIGUxLCBlMikgKVxuIyAxNzQwIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGUyO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZTJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19lMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZTE7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZTFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZTFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBlMiA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDE3NzMgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgZTIgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgZTEgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAxNzc5IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGUxIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19lMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2UyXyBpblxuICAgICAgICBsZXQgX3YgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAxNzg3IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gbGV0IGIgPSBcbiMgMTI5IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAoIEFuZCApXG4jIDE3OTEgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfZTJfIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfZTFfIGluXG4gICAgICAgIFxuIyAxNzEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKCBsb2MgX3N0YXJ0cG9zIF9lbmRwb3MgQEAgQm9wIChiLCBlMSwgZTIpIClcbiMgMTc5OCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBlMjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2UyXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZTJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGUxO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2UxXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2UxXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgZTIgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAxODMxIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGUyIGluXG4gICAgICAgIGxldCBfMSA6IHVuaXQgPSBPYmoubWFnaWMgXzEgaW5cbiAgICAgICAgbGV0IGUxIDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMTgzNyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBlMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfZTFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19lMl8gaW5cbiAgICAgICAgbGV0IF92IDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMTg0NSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IGxldCBiID0gXG4jIDEzMCBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAoIE9yIClcbiMgMTg0OSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19lMl8gaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19lMV8gaW5cbiAgICAgICAgXG4jIDE3MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAoIGxvYyBfc3RhcnRwb3MgX2VuZHBvcyBAQCBCb3AgKGIsIGUxLCBlMikgKVxuIyAxODU2IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGUyO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZTJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19lMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZTE7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZTFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZTFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBlMiA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDE4ODkgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgZTIgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgZTEgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAxODk1IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGUxIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19lMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2UyXyBpblxuICAgICAgICBsZXQgX3YgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAxOTAzIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gbGV0IGIgPSBcbiMgMTMxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgKCBJQW5kIClcbiMgMTkwNyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19lMl8gaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19lMV8gaW5cbiAgICAgICAgXG4jIDE3MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAoIGxvYyBfc3RhcnRwb3MgX2VuZHBvcyBAQCBCb3AgKGIsIGUxLCBlMikgKVxuIyAxOTE0IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGUyO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZTJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19lMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZTE7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZTFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZTFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBlMiA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDE5NDcgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgZTIgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgZTEgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAxOTUzIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGUxIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19lMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2UyXyBpblxuICAgICAgICBsZXQgX3YgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAxOTYxIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gbGV0IGIgPSBcbiMgMTMyIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAoIElPciApXG4jIDE5NjUgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfZTJfIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfZTFfIGluXG4gICAgICAgIFxuIyAxNzEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKCBsb2MgX3N0YXJ0cG9zIF9lbmRwb3MgQEAgQm9wIChiLCBlMSwgZTIpIClcbiMgMTk3MiBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBlMjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2UyXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZTJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGUxO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2UxXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2UxXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgZTIgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAyMDA1IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGUyIGluXG4gICAgICAgIGxldCBfMSA6IHVuaXQgPSBPYmoubWFnaWMgXzEgaW5cbiAgICAgICAgbGV0IGUxIDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMjAxMSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBlMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfZTFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19lMl8gaW5cbiAgICAgICAgbGV0IF92IDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMjAxOSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IGxldCBiID0gXG4jIDEzMyBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICggU2hsIClcbiMgMjAyMyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19lMl8gaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19lMV8gaW5cbiAgICAgICAgXG4jIDE3MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAoIGxvYyBfc3RhcnRwb3MgX2VuZHBvcyBAQCBCb3AgKGIsIGUxLCBlMikgKVxuIyAyMDMwIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGUyO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZTJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19lMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZTE7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZTFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZTFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBlMiA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDIwNjMgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgZTIgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgZTEgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAyMDY5IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGUxIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19lMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2UyXyBpblxuICAgICAgICBsZXQgX3YgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAyMDc3IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gbGV0IGIgPSBcbiMgMTM0IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgKCBTaHIgKVxuIyAyMDgxIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2UyXyBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2UxXyBpblxuICAgICAgICBcbiMgMTcxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICggbG9jIF9zdGFydHBvcyBfZW5kcG9zIEBAIEJvcCAoYiwgZTEsIGUyKSApXG4jIDIwODggXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZTI7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19lMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2UyXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBlMTtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19lMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19lMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IGUyIDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMjEyMSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBlMiBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBlMSA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDIxMjcgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgZTEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2UxXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfZTJfIGluXG4gICAgICAgIGxldCBfdiA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDIxMzUgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBsZXQgYiA9IFxuIyAxMzUgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAoIFNhciApXG4jIDIxMzkgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfZTJfIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfZTFfIGluXG4gICAgICAgIFxuIyAxNzEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKCBsb2MgX3N0YXJ0cG9zIF9lbmRwb3MgQEAgQm9wIChiLCBlMSwgZTIpIClcbiMgMjE0NiBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBlO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZV87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2VfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgZSA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDIxNzMgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgZSBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2VfIGluXG4gICAgICAgIGxldCBfdiA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDIxODIgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBsZXQgdSA9IFxuIyAxMzggXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICggTmVnIClcbiMgMjE4NiBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3NfdV8gPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19lXyBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3VfIGluXG4gICAgICAgIFxuIyAxNzIgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKCBsb2MgX3N0YXJ0cG9zIF9lbmRwb3MgQEAgVW9wICh1LCBlKSApXG4jIDIxOTQgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZTtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2VfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19lXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IGUgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAyMjIxIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGUgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19lXyBpblxuICAgICAgICBsZXQgX3YgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAyMjMwIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gbGV0IHUgPSBcbiMgMTM5IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAoIExvZ25vdCApXG4jIDIyMzQgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zX3VfID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfZV8gaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc191XyBpblxuICAgICAgICBcbiMgMTcyIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICggbG9jIF9zdGFydHBvcyBfZW5kcG9zIEBAIFVvcCAodSwgZSkgKVxuIyAyMjQyIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGU7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19lXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZV87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBlIDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMjI2OSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBlIGluXG4gICAgICAgIGxldCBfMSA6IHVuaXQgPSBPYmoubWFnaWMgXzEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfZV8gaW5cbiAgICAgICAgbGV0IF92IDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMjI3OCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IGxldCB1ID0gXG4jIDE0MCBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgKCBCaXRub3QgKVxuIyAyMjgyIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvc191XyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2VfIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfdV8gaW5cbiAgICAgICAgXG4jIDE3MiBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAoIGxvYyBfc3RhcnRwb3MgX2VuZHBvcyBAQCBVb3AgKHUsIGUpIClcbiMgMjI5MCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18zXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzNfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZTtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgXzMgOiB1bml0ID0gT2JqLm1hZ2ljIF8zIGluXG4gICAgICAgIGxldCBlIDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMjMyNCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBlIGluXG4gICAgICAgIGxldCBfMSA6IHVuaXQgPSBPYmoubWFnaWMgXzEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzNfIGluXG4gICAgICAgIGxldCBfdiA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDIzMzMgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBcbiMgMTczIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICggZSApXG4jIDIzMzcgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfcyA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5jdXJyZW50IGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfc3RhcnRwb3MgaW5cbiAgICAgICAgbGV0IF92IDogJ3R2X2V4cF9vcHQgPSBcbiMgMTgyIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAoIE5vbmUgKVxuIyAyMzU1IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZTtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2VfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19lXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBlIDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMjM3NiBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBlIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19lXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfZV8gaW5cbiAgICAgICAgbGV0IF92IDogJ3R2X2V4cF9vcHQgPSBcbiMgMTgzIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAoIFNvbWUgZSApXG4jIDIzODQgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzI7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18yXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZTtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF8yIDogdW5pdCA9IE9iai5tYWdpYyBfMiBpblxuICAgICAgICBsZXQgZSA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDI0MTIgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgZSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfZV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX18yXyBpblxuICAgICAgICBsZXQgX3YgOiAoXG4jIDc3IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAyNDIwIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gXG4jIDg4IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgKCBlIClcbiMgMjQyNCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGk7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19pXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfaV87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgaSA6IChcbiMgMTEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgIChpbnQ2NClcbiMgMjQ0NSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBpIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19pXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfaV8gaW5cbiAgICAgICAgbGV0IF92IDogJ3R2X2dleHAgPSBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfaV8gaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19pXyBpblxuICAgICAgICBcbiMgMTQzIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICggbG9jIF9zdGFydHBvcyBfZW5kcG9zIEBAIENJbnQgaSApXG4jIDI0NTUgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBzO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3Nfc187XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3NfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IHMgOiAoXG4jIDEzIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAyNDc2IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIHMgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3NfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19zXyBpblxuICAgICAgICBsZXQgX3YgOiAndHZfZ2V4cCA9IGxldCBfZW5kcG9zID0gX2VuZHBvc19zXyBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3NfIGluXG4gICAgICAgIFxuIyAxNDQgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgKCBsb2MgX3N0YXJ0cG9zIF9lbmRwb3MgQEAgQ1N0ciBzIClcbiMgMjQ4NiBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18yXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgXzIgOiB1bml0ID0gT2JqLm1hZ2ljIF8yIGluXG4gICAgICAgIGxldCBfMSA6IHVuaXQgPSBPYmoubWFnaWMgXzEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzJfIGluXG4gICAgICAgIGxldCBfdiA6ICd0dl9nZXhwID0gbGV0IHQgPSBcbiMgMTE2IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICggUlN0cmluZyApXG4jIDI1MTggXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zX3RfID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzJfIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfdF8gaW5cbiAgICAgICAgXG4jIDE0NSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICggbG9jIF9zdGFydHBvcyBfZW5kcG9zIEBAIENOdWxsIHQgKVxuIyAyNTI2IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8yO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzNfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18zXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8yX2lubGluZWQxO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18yX2lubGluZWQxXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18yX2lubGluZWQxXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gdDtcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3RfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc190XztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfMiA6IHVuaXQgPSBPYmoubWFnaWMgXzIgaW5cbiAgICAgICAgbGV0IF8zIDogdW5pdCA9IE9iai5tYWdpYyBfMyBpblxuICAgICAgICBsZXQgXzJfaW5saW5lZDEgOiB1bml0ID0gT2JqLm1hZ2ljIF8yX2lubGluZWQxIGluXG4gICAgICAgIGxldCB0IDogKFxuIyA4NCBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LnR5KVxuIyAyNTY4IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIHQgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3RfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fMl8gaW5cbiAgICAgICAgbGV0IF92IDogJ3R2X2dleHAgPSBsZXQgdCA9XG4gICAgICAgICAgbGV0IF8yID0gXzJfaW5saW5lZDEgaW5cbiAgICAgICAgICBcbiMgMTE3IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICggUkFycmF5IHQgKVxuIyAyNTc4IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgIFxuICAgICAgICBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzJfIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfdF8gaW5cbiAgICAgICAgXG4jIDE0NSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICggbG9jIF9zdGFydHBvcyBfZW5kcG9zIEBAIENOdWxsIHQgKVxuIyAyNTg2IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfMSA6IHVuaXQgPSBPYmoubWFnaWMgXzEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfdiA6ICd0dl9nZXhwID0gbGV0IF9lbmRwb3MgPSBfZW5kcG9zX18xXyBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBcbiMgMTQ2IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgIChsb2MgX3N0YXJ0cG9zIF9lbmRwb3MgQEAgQ0Jvb2wgdHJ1ZSApXG4jIDI2MTMgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF92IDogJ3R2X2dleHAgPSBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIFxuIyAxNDcgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgIChsb2MgX3N0YXJ0cG9zIF9lbmRwb3MgQEAgQ0Jvb2wgZmFsc2UgKVxuIyAyNjQwIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF83O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzdfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fN187XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB4cztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfeHNfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3hzXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF81O1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX181XztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX181XztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF80O1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzRfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fNF87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMztcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzNfO1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18zXztcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHQ7XG4gICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfdF87XG4gICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc190XztcbiAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfNyA6IHVuaXQgPSBPYmoubWFnaWMgXzcgaW5cbiAgICAgICAgbGV0IHhzIDogJ3R2X2xvcHRpb25fc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQ09NTUFfZ2V4cF9fID0gT2JqLm1hZ2ljIHhzIGluXG4gICAgICAgIGxldCBfNSA6IHVuaXQgPSBPYmoubWFnaWMgXzUgaW5cbiAgICAgICAgbGV0IF80IDogdW5pdCA9IE9iai5tYWdpYyBfNCBpblxuICAgICAgICBsZXQgXzMgOiB1bml0ID0gT2JqLm1hZ2ljIF8zIGluXG4gICAgICAgIGxldCB0IDogKFxuIyA4NCBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LnR5KVxuIyAyNzAyIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIHQgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fN18gaW5cbiAgICAgICAgbGV0IF92IDogJ3R2X2dleHAgPSBsZXQgZXMgPSBcbiMgMjMyIFwiPHN0YW5kYXJkLm1seT5cIlxuICAgICggeHMgKVxuIyAyNzExIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX183XyBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBcbiMgMTQ5IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAoIGxvYyBfc3RhcnRwb3MgX2VuZHBvcyBAQCBDQXJyKHQsIGVzKSApXG4jIDI3MTggXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gYjI7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19iMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2IyXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGIxO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19iMV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfYjFfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzQ7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzRfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzRfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZTtcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2VfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19lXztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8yO1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMl87XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzJfO1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IGIyIDogJ3R2X2Vsc2Vfc3RtdCA9IE9iai5tYWdpYyBiMiBpblxuICAgICAgICBsZXQgYjEgOiAoXG4jIDgzIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuYmxvY2spXG4jIDI3NzAgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgYjEgaW5cbiAgICAgICAgbGV0IF80IDogdW5pdCA9IE9iai5tYWdpYyBfNCBpblxuICAgICAgICBsZXQgZSA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDI3NzYgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgZSBpblxuICAgICAgICBsZXQgXzIgOiB1bml0ID0gT2JqLm1hZ2ljIF8yIGluXG4gICAgICAgIGxldCBfMSA6IHVuaXQgPSBPYmoubWFnaWMgXzEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfYjJfIGluXG4gICAgICAgIGxldCBfdiA6ICd0dl9pZl9zdG10ID0gbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2IyXyBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBcbiMgMjA3IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAoIGxvYyBfc3RhcnRwb3MgX2VuZHBvcyBAQCBJZihlLGIxLGIyKSApXG4jIDI3ODggXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBpZDtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2lkXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfaWRfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IGlkIDogKFxuIyAxNCBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgKHN0cmluZylcbiMgMjgwOSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBpZCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfaWRfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19pZF8gaW5cbiAgICAgICAgbGV0IF92IDogJ3R2X2xocyA9IGxldCBfZW5kcG9zID0gX2VuZHBvc19pZF8gaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19pZF8gaW5cbiAgICAgICAgXG4jIDE1MiBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAoIGxvYyBfc3RhcnRwb3MgX2VuZHBvcyBAQCBJZCBpZCApXG4jIDI4MTkgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzQ7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fNF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX180XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGk7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2lfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2lfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzI7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzJfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzJfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBlO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZV87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2VfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF80IDogdW5pdCA9IE9iai5tYWdpYyBfNCBpblxuICAgICAgICBsZXQgaSA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDI4NTkgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgaSBpblxuICAgICAgICBsZXQgXzIgOiB1bml0ID0gT2JqLm1hZ2ljIF8yIGluXG4gICAgICAgIGxldCBlIDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMjg2NSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBlIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19lXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzRfIGluXG4gICAgICAgIGxldCBfdiA6ICd0dl9saHMgPSBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzRfIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfZV8gaW5cbiAgICAgICAgXG4jIDE1NCBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAoIGxvYyBfc3RhcnRwb3MgX2VuZHBvcyBAQCBJbmRleCAoZSwgaSkgKVxuIyAyODc1IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCBfbWVuaGlyX3MgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuY3VycmVudCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX3N0YXJ0cG9zIGluXG4gICAgICAgIGxldCBfdiA6ICd0dl9saXN0X2RlY2xfID0gXG4jIDIxMSBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIFtdIClcbiMgMjg5MyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB4cztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3hzXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeHNfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB4O1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc194XztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc194XztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgeHMgOiAndHZfbGlzdF9kZWNsXyA9IE9iai5tYWdpYyB4cyBpblxuICAgICAgICBsZXQgeCA6ICd0dl9kZWNsID0gT2JqLm1hZ2ljIHggaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3hfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc194c18gaW5cbiAgICAgICAgbGV0IF92IDogJ3R2X2xpc3RfZGVjbF8gPSBcbiMgMjEzIFwiPHN0YW5kYXJkLm1seT5cIlxuICAgICggeCA6OiB4cyApXG4jIDI5MjUgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfcyA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5jdXJyZW50IGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfc3RhcnRwb3MgaW5cbiAgICAgICAgbGV0IF92IDogJ3R2X2xpc3Rfc3RtdF8gPSBcbiMgMjExIFwiPHN0YW5kYXJkLm1seT5cIlxuICAgICggW10gKVxuIyAyOTQzIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHhzO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfeHNfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc194c187XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHg7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3hfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3hfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCB4cyA6ICd0dl9saXN0X3N0bXRfID0gT2JqLm1hZ2ljIHhzIGluXG4gICAgICAgIGxldCB4IDogKFxuIyA4MiBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LnN0bXQgQXN0Lm5vZGUpXG4jIDI5NzEgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgeCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfeF8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3hzXyBpblxuICAgICAgICBsZXQgX3YgOiAndHZfbGlzdF9zdG10XyA9IFxuIyAyMTMgXCI8c3RhbmRhcmQubWx5PlwiXG4gICAgKCB4IDo6IHhzIClcbiMgMjk3OSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQgX21lbmhpcl9zID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLmN1cnJlbnQgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9zdGFydHBvcyBpblxuICAgICAgICBsZXQgX3YgOiAndHZfbG9wdGlvbl9zZXBhcmF0ZWRfbm9uZW1wdHlfbGlzdF9DT01NQV9leHBfXyA9IFxuIyAxNDIgXCI8c3RhbmRhcmQubWx5PlwiXG4gICAgKCBbXSApXG4jIDI5OTcgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB4O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfeF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3hfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IHggOiAndHZfc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQ09NTUFfZXhwXyA9IE9iai5tYWdpYyB4IGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc194XyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfeF8gaW5cbiAgICAgICAgbGV0IF92IDogJ3R2X2xvcHRpb25fc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQ09NTUFfZXhwX18gPSBcbiMgMTQ0IFwiPHN0YW5kYXJkLm1seT5cIlxuICAgICggeCApXG4jIDMwMjIgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfcyA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5jdXJyZW50IGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfc3RhcnRwb3MgaW5cbiAgICAgICAgbGV0IF92IDogJ3R2X2xvcHRpb25fc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQ09NTUFfZ2V4cF9fID0gXG4jIDE0MiBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIFtdIClcbiMgMzA0MCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHg7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc194XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgeCA6ICd0dl9zZXBhcmF0ZWRfbm9uZW1wdHlfbGlzdF9DT01NQV9nZXhwXyA9IE9iai5tYWdpYyB4IGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc194XyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfeF8gaW5cbiAgICAgICAgbGV0IF92IDogJ3R2X2xvcHRpb25fc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQ09NTUFfZ2V4cF9fID0gXG4jIDE0NCBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIHggKVxuIyAzMDY1IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCBfbWVuaGlyX3MgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuY3VycmVudCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX3N0YXJ0cG9zIGluXG4gICAgICAgIGxldCBfdiA6ICd0dl9sb3B0aW9uX3NlcGFyYXRlZF9ub25lbXB0eV9saXN0X0NPTU1BX3BhaXJfdHlfSURFTlRfX18gPSBcbiMgMTQyIFwiPHN0YW5kYXJkLm1seT5cIlxuICAgICggW10gKVxuIyAzMDgzIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0geDtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3hfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc194XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCB4IDogJ3R2X3NlcGFyYXRlZF9ub25lbXB0eV9saXN0X0NPTU1BX3BhaXJfdHlfSURFTlRfXyA9IE9iai5tYWdpYyB4IGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc194XyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfeF8gaW5cbiAgICAgICAgbGV0IF92IDogJ3R2X2xvcHRpb25fc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQ09NTUFfcGFpcl90eV9JREVOVF9fXyA9IFxuIyAxNDQgXCI8c3RhbmRhcmQubWx5PlwiXG4gICAgKCB4IClcbiMgMzEwOCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQgX21lbmhpcl9zID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLmN1cnJlbnQgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9zdGFydHBvcyBpblxuICAgICAgICBsZXQgX3YgOiAndHZfbG9wdGlvbl9zZXBhcmF0ZWRfbm9uZW1wdHlfbGlzdF9DT01NQV92ZGVjbF9fID0gXG4jIDE0MiBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIFtdIClcbiMgMzEyNiBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHg7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc194XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgeCA6ICd0dl9zZXBhcmF0ZWRfbm9uZW1wdHlfbGlzdF9DT01NQV92ZGVjbF8gPSBPYmoubWFnaWMgeCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfeF8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3hfIGluXG4gICAgICAgIGxldCBfdiA6ICd0dl9sb3B0aW9uX3NlcGFyYXRlZF9ub25lbXB0eV9saXN0X0NPTU1BX3ZkZWNsX18gPSBcbiMgMTQ0IFwiPHN0YW5kYXJkLm1seT5cIlxuICAgICggeCApXG4jIDMxNTEgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzI7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18yXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gcDtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfcF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfcF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF8yIDogdW5pdCA9IE9iai5tYWdpYyBfMiBpblxuICAgICAgICBsZXQgcCA6ICd0dl9saXN0X2RlY2xfID0gT2JqLm1hZ2ljIHAgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3BfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fMl8gaW5cbiAgICAgICAgbGV0IF92IDogKFxuIyA4MCBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LnByb2cpXG4jIDMxODMgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBcbiMgOTQgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICggcCApXG4jIDMxODcgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB4O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfeF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3hfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IHggOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAzMjA4IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIHggaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3hfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc194XyBpblxuICAgICAgICBsZXQgX3YgOiAndHZfc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQ09NTUFfZXhwXyA9IFxuIyAyNDEgXCI8c3RhbmRhcmQubWx5PlwiXG4gICAgKCBbIHggXSApXG4jIDMyMTYgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0geHM7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc194c187XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3hzXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8yO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMl87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzJfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB4O1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3hfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeF87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IHhzIDogJ3R2X3NlcGFyYXRlZF9ub25lbXB0eV9saXN0X0NPTU1BX2V4cF8gPSBPYmoubWFnaWMgeHMgaW5cbiAgICAgICAgbGV0IF8yIDogdW5pdCA9IE9iai5tYWdpYyBfMiBpblxuICAgICAgICBsZXQgeCA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDMyNTEgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgeCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfeF8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3hzXyBpblxuICAgICAgICBsZXQgX3YgOiAndHZfc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQ09NTUFfZXhwXyA9IFxuIyAyNDMgXCI8c3RhbmRhcmQubWx5PlwiXG4gICAgKCB4IDo6IHhzIClcbiMgMzI1OSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHg7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc194XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgeCA6ICd0dl9nZXhwID0gT2JqLm1hZ2ljIHggaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3hfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc194XyBpblxuICAgICAgICBsZXQgX3YgOiAndHZfc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQ09NTUFfZ2V4cF8gPSBcbiMgMjQxIFwiPHN0YW5kYXJkLm1seT5cIlxuICAgICggWyB4IF0gKVxuIyAzMjg0IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHhzO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfeHNfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc194c187XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMjtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzJfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18yXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0geDtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc194XztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3hfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCB4cyA6ICd0dl9zZXBhcmF0ZWRfbm9uZW1wdHlfbGlzdF9DT01NQV9nZXhwXyA9IE9iai5tYWdpYyB4cyBpblxuICAgICAgICBsZXQgXzIgOiB1bml0ID0gT2JqLm1hZ2ljIF8yIGluXG4gICAgICAgIGxldCB4IDogJ3R2X2dleHAgPSBPYmoubWFnaWMgeCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfeF8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3hzXyBpblxuICAgICAgICBsZXQgX3YgOiAndHZfc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQ09NTUFfZ2V4cF8gPSBcbiMgMjQzIFwiPHN0YW5kYXJkLm1seT5cIlxuICAgICggeCA6OiB4cyApXG4jIDMzMjMgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0geTtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3lfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc195XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0geDtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfeF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IHkgOiAoXG4jIDE0IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAzMzUwIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIHkgaW5cbiAgICAgICAgbGV0IHggOiAoXG4jIDg0IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QudHkpXG4jIDMzNTUgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgeCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfeF8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3lfIGluXG4gICAgICAgIGxldCBfdiA6ICd0dl9zZXBhcmF0ZWRfbm9uZW1wdHlfbGlzdF9DT01NQV9wYWlyX3R5X0lERU5UX18gPSBsZXQgeCA9IFxuIyAxNjcgXCI8c3RhbmRhcmQubWx5PlwiXG4gICAgKCAoeCwgeSkgKVxuIyAzMzYzIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgXG4jIDI0MSBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIFsgeCBdIClcbiMgMzM2OCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB4cztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3hzXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeHNfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzI7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18yXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMl87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB5O1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3lfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHg7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc194XztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeF87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgeHMgOiAndHZfc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQ09NTUFfcGFpcl90eV9JREVOVF9fID0gT2JqLm1hZ2ljIHhzIGluXG4gICAgICAgIGxldCBfMiA6IHVuaXQgPSBPYmoubWFnaWMgXzIgaW5cbiAgICAgICAgbGV0IHkgOiAoXG4jIDE0IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAzNDA5IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIHkgaW5cbiAgICAgICAgbGV0IHggOiAoXG4jIDg0IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QudHkpXG4jIDM0MTQgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgeCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfeF8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3hzXyBpblxuICAgICAgICBsZXQgX3YgOiAndHZfc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQ09NTUFfcGFpcl90eV9JREVOVF9fID0gbGV0IHggPSBcbiMgMTY3IFwiPHN0YW5kYXJkLm1seT5cIlxuICAgICggKHgsIHkpIClcbiMgMzQyMiBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIFxuIyAyNDMgXCI8c3RhbmRhcmQubWx5PlwiXG4gICAgKCB4IDo6IHhzIClcbiMgMzQyNyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHg7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc194XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgeCA6ICd0dl92ZGVjbCA9IE9iai5tYWdpYyB4IGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc194XyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfeF8gaW5cbiAgICAgICAgbGV0IF92IDogJ3R2X3NlcGFyYXRlZF9ub25lbXB0eV9saXN0X0NPTU1BX3ZkZWNsXyA9IFxuIyAyNDEgXCI8c3RhbmRhcmQubWx5PlwiXG4gICAgKCBbIHggXSApXG4jIDM0NTIgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0geHM7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc194c187XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3hzXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8yO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMl87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzJfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB4O1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3hfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeF87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IHhzIDogJ3R2X3NlcGFyYXRlZF9ub25lbXB0eV9saXN0X0NPTU1BX3ZkZWNsXyA9IE9iai5tYWdpYyB4cyBpblxuICAgICAgICBsZXQgXzIgOiB1bml0ID0gT2JqLm1hZ2ljIF8yIGluXG4gICAgICAgIGxldCB4IDogJ3R2X3ZkZWNsID0gT2JqLm1hZ2ljIHggaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3hfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc194c18gaW5cbiAgICAgICAgbGV0IF92IDogJ3R2X3NlcGFyYXRlZF9ub25lbXB0eV9saXN0X0NPTU1BX3ZkZWNsXyA9IFxuIyAyNDMgXCI8c3RhbmRhcmQubWx5PlwiXG4gICAgKCB4IDo6IHhzIClcbiMgMzQ5MSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18yXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBkO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19kXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19kXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgXzIgOiB1bml0ID0gT2JqLm1hZ2ljIF8yIGluXG4gICAgICAgIGxldCBkIDogJ3R2X3ZkZWNsID0gT2JqLm1hZ2ljIGQgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2RfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fMl8gaW5cbiAgICAgICAgbGV0IF92IDogKFxuIyA4MiBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LnN0bXQgQXN0Lm5vZGUpXG4jIDM1MjMgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzJfIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfZF8gaW5cbiAgICAgICAgXG4jIDE5MCBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAoIGxvYyBfc3RhcnRwb3MgX2VuZHBvcyBAQCBEZWNsKGQpIClcbiMgMzUyOSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfNDtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX180XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzRfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZTtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMjtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMl87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMl87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHA7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19wXztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfcF87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgXzQgOiB1bml0ID0gT2JqLm1hZ2ljIF80IGluXG4gICAgICAgIGxldCBlIDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMzU2OSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBlIGluXG4gICAgICAgIGxldCBfMiA6IHVuaXQgPSBPYmoubWFnaWMgXzIgaW5cbiAgICAgICAgbGV0IHAgOiAndHZfbGhzID0gT2JqLm1hZ2ljIHAgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3BfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fNF8gaW5cbiAgICAgICAgbGV0IF92IDogKFxuIyA4MiBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LnN0bXQgQXN0Lm5vZGUpXG4jIDM1NzkgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzRfIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfcF8gaW5cbiAgICAgICAgXG4jIDE5MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAoIGxvYyBfc3RhcnRwb3MgX2VuZHBvcyBAQCBBc3NuKHAsZSkgKVxuIyAzNTg1IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF81O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzVfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fNV87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfNDtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzRfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX180XztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHhzO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3hzXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3hzXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8yO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzJfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMl87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGU7XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2VfO1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2VfO1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfNSA6IHVuaXQgPSBPYmoubWFnaWMgXzUgaW5cbiAgICAgICAgbGV0IF80IDogdW5pdCA9IE9iai5tYWdpYyBfNCBpblxuICAgICAgICBsZXQgeHMgOiAndHZfbG9wdGlvbl9zZXBhcmF0ZWRfbm9uZW1wdHlfbGlzdF9DT01NQV9leHBfXyA9IE9iai5tYWdpYyB4cyBpblxuICAgICAgICBsZXQgXzIgOiB1bml0ID0gT2JqLm1hZ2ljIF8yIGluXG4gICAgICAgIGxldCBlIDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMzYzNCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBlIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19lXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzVfIGluXG4gICAgICAgIGxldCBfdiA6IChcbiMgODIgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5zdG10IEFzdC5ub2RlKVxuIyAzNjQyIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gbGV0IGVzID0gXG4jIDIzMiBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIHhzIClcbiMgMzY0NiBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fNV8gaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19lXyBpblxuICAgICAgICBcbiMgMTkzIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICggbG9jIF9zdGFydHBvcyBfZW5kcG9zIEBAIFNDYWxsIChlLCBlcykgKVxuIyAzNjUzIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gaWZzO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfaWZzXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfaWZzXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBpZnMgOiAndHZfaWZfc3RtdCA9IE9iai5tYWdpYyBpZnMgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2lmc18gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2lmc18gaW5cbiAgICAgICAgbGV0IF92IDogKFxuIyA4MiBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LnN0bXQgQXN0Lm5vZGUpXG4jIDM2NzggXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBcbiMgMTk0IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICggaWZzIClcbiMgMzY4MiBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18yXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgXzIgOiB1bml0ID0gT2JqLm1hZ2ljIF8yIGluXG4gICAgICAgIGxldCBfMSA6IHVuaXQgPSBPYmoubWFnaWMgXzEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzJfIGluXG4gICAgICAgIGxldCBfdiA6IChcbiMgODIgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5zdG10IEFzdC5ub2RlKVxuIyAzNzE0IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gbGV0IF9lbmRwb3MgPSBfZW5kcG9zX18yXyBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBcbiMgMTk1IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICggbG9jIF9zdGFydHBvcyBfZW5kcG9zIEBAIFJldChOb25lKSApXG4jIDM3MjAgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzM7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fM187XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18zXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGU7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2VfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2VfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF8zIDogdW5pdCA9IE9iai5tYWdpYyBfMyBpblxuICAgICAgICBsZXQgZSA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDM3NTQgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgZSBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX18zXyBpblxuICAgICAgICBsZXQgX3YgOiAoXG4jIDgyIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3Quc3RtdCBBc3Qubm9kZSlcbiMgMzc2MyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IGxldCBfZW5kcG9zID0gX2VuZHBvc19fM18gaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgXG4jIDE5NiBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAoIGxvYyBfc3RhcnRwb3MgX2VuZHBvcyBAQCBSZXQoU29tZSBlKSApXG4jIDM3NjkgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gYjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2JfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19iXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF80O1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fNF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzRfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZTtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19lXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2VfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzI7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMl87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18yXztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IGIgOiAoXG4jIDgzIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuYmxvY2spXG4jIDM4MTQgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgYiBpblxuICAgICAgICBsZXQgXzQgOiB1bml0ID0gT2JqLm1hZ2ljIF80IGluXG4gICAgICAgIGxldCBlIDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMzgyMCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBlIGluXG4gICAgICAgIGxldCBfMiA6IHVuaXQgPSBPYmoubWFnaWMgXzIgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19iXyBpblxuICAgICAgICBsZXQgX3YgOiAoXG4jIDgyIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3Quc3RtdCBBc3Qubm9kZSlcbiMgMzgzMCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IGxldCBfZW5kcG9zID0gX2VuZHBvc19iXyBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBcbiMgMTk4IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICggbG9jIF9zdGFydHBvcyBfZW5kcG9zIEBAIFdoaWxlKGUsIGIpIClcbiMgMzgzNiBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBiO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfYl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2JfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzg7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX184XztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fOF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBzO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3NfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3Nfc187XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfNjtcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX182XztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzZfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZTtcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZV87XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZV87XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfNDtcbiAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fNF87XG4gICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fNF87XG4gICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBkcztcbiAgICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2RzXztcbiAgICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZHNfO1xuICAgICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzI7XG4gICAgICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18yXztcbiAgICAgICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMl87XG4gICAgICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgYiA6IChcbiMgODMgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5ibG9jaylcbiMgMzkwNSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBiIGluXG4gICAgICAgIGxldCBfOCA6IHVuaXQgPSBPYmoubWFnaWMgXzggaW5cbiAgICAgICAgbGV0IHMgOiAndHZfc3RtdF9vcHQgPSBPYmoubWFnaWMgcyBpblxuICAgICAgICBsZXQgXzYgOiB1bml0ID0gT2JqLm1hZ2ljIF82IGluXG4gICAgICAgIGxldCBlIDogJ3R2X2V4cF9vcHQgPSBPYmoubWFnaWMgZSBpblxuICAgICAgICBsZXQgXzQgOiB1bml0ID0gT2JqLm1hZ2ljIF80IGluXG4gICAgICAgIGxldCBkcyA6ICd0dl92ZGVjbHMgPSBPYmoubWFnaWMgZHMgaW5cbiAgICAgICAgbGV0IF8yIDogdW5pdCA9IE9iai5tYWdpYyBfMiBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2JfIGluXG4gICAgICAgIGxldCBfdiA6IChcbiMgODIgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5zdG10IEFzdC5ub2RlKVxuIyAzOTIxIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2JfIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIFxuIyAyMDAgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKCBsb2MgX3N0YXJ0cG9zIF9lbmRwb3MgQEAgRm9yKGRzLCBlLCBzLCBiKSApXG4jIDM5MjcgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfcyA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5jdXJyZW50IGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfc3RhcnRwb3MgaW5cbiAgICAgICAgbGV0IF92IDogJ3R2X3N0bXRfb3B0ID0gXG4jIDE4NiBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgKCBOb25lIClcbiMgMzk0NSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHM7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19zXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3Nfc187XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgcyA6IChcbiMgODIgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5zdG10IEFzdC5ub2RlKVxuIyAzOTY2IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIHMgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3NfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19zXyBpblxuICAgICAgICBsZXQgX3YgOiAndHZfc3RtdF9vcHQgPSBcbiMgMTg3IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgKCBTb21lIHMgKVxuIyAzOTc0IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8yO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHM7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3NfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3NfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfMiA6IHVuaXQgPSBPYmoubWFnaWMgXzIgaW5cbiAgICAgICAgbGV0IHMgOiAoXG4jIDgyIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3Quc3RtdCBBc3Qubm9kZSlcbiMgNDAwMiBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBzIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19zXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzJfIGluXG4gICAgICAgIGxldCBfdiA6IChcbiMgNzggXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5zdG10IEFzdC5ub2RlKVxuIyA0MDEwIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gXG4jIDkxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICggcyApXG4jIDQwMTQgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF92IDogKFxuIyA4NCBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LnR5KVxuIyA0MDM5IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gXG4jIDEwNiBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICggVEludCApXG4jIDQwNDMgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF92IDogKFxuIyA4NCBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LnR5KVxuIyA0MDY4IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gXG4jIDEwNyBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICggVEJvb2wgKVxuIyA0MDcyIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfMSA6IHVuaXQgPSBPYmoubWFnaWMgXzEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfdiA6IChcbiMgODQgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC50eSlcbiMgNDA5NyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IGxldCByID0gXG4jIDExNiBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAoIFJTdHJpbmcgKVxuIyA0MTAxIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgXG4jIDEwOCBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICggVFJlZiByIClcbiMgNDEwNiBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18zXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzNfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzI7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18yXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMl87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHQ7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfdF87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc190XztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgXzMgOiB1bml0ID0gT2JqLm1hZ2ljIF8zIGluXG4gICAgICAgIGxldCBfMiA6IHVuaXQgPSBPYmoubWFnaWMgXzIgaW5cbiAgICAgICAgbGV0IHQgOiAoXG4jIDg0IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QudHkpXG4jIDQxNDEgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgdCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfdF8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX18zXyBpblxuICAgICAgICBsZXQgX3YgOiAoXG4jIDg0IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QudHkpXG4jIDQxNDkgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBsZXQgciA9IFxuIyAxMTcgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBSQXJyYXkgdCApXG4jIDQxNTMgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICBcbiMgMTA4IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgKCBUUmVmIHIgKVxuIyA0MTU4IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGluaXQ7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19pbml0XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfaW5pdF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzNfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18zXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGlkO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2lkXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2lkXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBpbml0IDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgNDE5NyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBpbml0IGluXG4gICAgICAgIGxldCBfMyA6IHVuaXQgPSBPYmoubWFnaWMgXzMgaW5cbiAgICAgICAgbGV0IGlkIDogKFxuIyAxNCBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgKHN0cmluZylcbiMgNDIwMyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBpZCBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2luaXRfIGluXG4gICAgICAgIGxldCBfdiA6ICd0dl92ZGVjbCA9IFxuIyAxNzYgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIChpZCwgaW5pdCkgKVxuIyA0MjEyIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0geHM7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc194c187XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3hzXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCB4cyA6ICd0dl9sb3B0aW9uX3NlcGFyYXRlZF9ub25lbXB0eV9saXN0X0NPTU1BX3ZkZWNsX18gPSBPYmoubWFnaWMgeHMgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3hzXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfeHNfIGluXG4gICAgICAgIGxldCBfdiA6ICd0dl92ZGVjbHMgPSBsZXQgZHMgPSBcbiMgMjMyIFwiPHN0YW5kYXJkLm1seT5cIlxuICAgICggeHMgKVxuIyA0MjM3IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgXG4jIDE3OSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIGRzIClcbiMgNDI0MiBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgIHxdXG4gIFxuICBhbmQgdHJhY2UgPVxuICAgIE5vbmVcbiAgXG5lbmRcblxubW9kdWxlIE1lbmhpckludGVycHJldGVyID0gc3RydWN0XG4gIFxuICBtb2R1bGUgRVQgPSBNZW5oaXJMaWIuVGFibGVJbnRlcnByZXRlci5NYWtlRW5naW5lVGFibGUgKFRhYmxlcylcbiAgXG4gIG1vZHVsZSBUSSA9IE1lbmhpckxpYi5FbmdpbmUuTWFrZSAoRVQpXG4gIFxuICBpbmNsdWRlIFRJXG4gIFxuZW5kXG5cbmxldCBzdG10X3RvcCA9XG4gIGZ1biBsZXhlciBsZXhidWYgLT5cbiAgICAoT2JqLm1hZ2ljIChNZW5oaXJJbnRlcnByZXRlci5lbnRyeSAxODkgbGV4ZXIgbGV4YnVmKSA6IChcbiMgNzggXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5zdG10IEFzdC5ub2RlKVxuIyA0MjczIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICkpXG5cbmFuZCBwcm9nID1cbiAgZnVuIGxleGVyIGxleGJ1ZiAtPlxuICAgIChPYmoubWFnaWMgKE1lbmhpckludGVycHJldGVyLmVudHJ5IDc4IGxleGVyIGxleGJ1ZikgOiAoXG4jIDgwIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QucHJvZylcbiMgNDI4MSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICApKVxuXG5hbmQgZXhwX3RvcCA9XG4gIGZ1biBsZXhlciBsZXhidWYgLT5cbiAgICAoT2JqLm1hZ2ljIChNZW5oaXJJbnRlcnByZXRlci5lbnRyeSAwIGxleGVyIGxleGJ1ZikgOiAoXG4jIDc3IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyA0Mjg5IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICkpXG5cbm1vZHVsZSBJbmNyZW1lbnRhbCA9IHN0cnVjdFxuICBcbiAgbGV0IHN0bXRfdG9wID1cbiAgICBmdW4gaW5pdGlhbF9wb3NpdGlvbiAtPlxuICAgICAgKE9iai5tYWdpYyAoTWVuaGlySW50ZXJwcmV0ZXIuc3RhcnQgMTg5IGluaXRpYWxfcG9zaXRpb24pIDogKFxuIyA3OCBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LnN0bXQgQXN0Lm5vZGUpXG4jIDQyOTkgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICApIE1lbmhpckludGVycHJldGVyLmNoZWNrcG9pbnQpXG4gIFxuICBhbmQgcHJvZyA9XG4gICAgZnVuIGluaXRpYWxfcG9zaXRpb24gLT5cbiAgICAgIChPYmoubWFnaWMgKE1lbmhpckludGVycHJldGVyLnN0YXJ0IDc4IGluaXRpYWxfcG9zaXRpb24pIDogKFxuIyA4MCBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LnByb2cpXG4jIDQzMDcgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICApIE1lbmhpckludGVycHJldGVyLmNoZWNrcG9pbnQpXG4gIFxuICBhbmQgZXhwX3RvcCA9XG4gICAgZnVuIGluaXRpYWxfcG9zaXRpb24gLT5cbiAgICAgIChPYmoubWFnaWMgKE1lbmhpckludGVycHJldGVyLnN0YXJ0IDAgaW5pdGlhbF9wb3NpdGlvbikgOiAoXG4jIDc3IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyA0MzE1IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgKSBNZW5oaXJJbnRlcnByZXRlci5jaGVja3BvaW50KVxuICBcbmVuZFxuXG4jIDI2OSBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgXG5cbiMgNDMyMyBcImh3MDMvcGFyc2VyLm1sXCJcbiIsIiV7XG5vcGVuIEFzdFxuXG5sZXQgbG9jIChzdGFydHBvczpMZXhpbmcucG9zaXRpb24pIChlbmRwb3M6TGV4aW5nLnBvc2l0aW9uKSAoZWx0OidhKSA6ICdhIG5vZGUgPVxuICB7IGVsdCA7IGxvYz1SYW5nZS5ta19sZXhfcmFuZ2Ugc3RhcnRwb3MgZW5kcG9zIH1cblxuJX1cblxuLyogRGVjbGFyZSB5b3VyIHRva2VucyBoZXJlLiAqL1xuJXRva2VuIEVPRlxuJXRva2VuIDxpbnQ2ND4gIElOVFxuJXRva2VuIE5VTExcbiV0b2tlbiA8c3RyaW5nPiBTVFJJTkdcbiV0b2tlbiA8c3RyaW5nPiBJREVOVFxuXG4ldG9rZW4gVElOVCAgICAgLyogaW50ICovXG4ldG9rZW4gVFZPSUQgICAgLyogdm9pZCAqL1xuJXRva2VuIFRTVFJJTkcgIC8qIHN0cmluZyAqL1xuJXRva2VuIFRCT09MICAgIC8qIGJvb2wgKi9cbiV0b2tlbiBORVcgICAgICAvKiBuZXcgKi9cbiV0b2tlbiBUUlVFICAgICAvKiB0cnVlICovXG4ldG9rZW4gRkFMU0UgICAgLyogZmFsc2UgKi9cbiV0b2tlbiBJRiAgICAgICAvKiBpZiAqL1xuJXRva2VuIEVMU0UgICAgIC8qIGVsc2UgKi9cbiV0b2tlbiBXSElMRSAgICAvKiB3aGlsZSAqL1xuJXRva2VuIEZPUiAgICAgIC8qIGZvciAqL1xuJXRva2VuIFJFVFVSTiAgIC8qIHJldHVybiAqL1xuJXRva2VuIFZBUiAgICAgIC8qIHZhciAqL1xuJXRva2VuIFNFTUkgICAgIC8qIDsgKi9cbiV0b2tlbiBDT01NQSAgICAvKiAsICovXG4ldG9rZW4gTEJSQUNFICAgLyogeyAqL1xuJXRva2VuIFJCUkFDRSAgIC8qIH0gKi9cbiV0b2tlbiBMUEFSRU4gICAvKiAoICovXG4ldG9rZW4gUlBBUkVOICAgLyogKSAqL1xuJXRva2VuIExCUkFDS0VUIC8qIFsgKi9cbiV0b2tlbiBSQlJBQ0tFVCAvKiBdICovXG4ldG9rZW4gRVEgICAgICAgLyogPSAqL1xuJXRva2VuIFBMVVMgICAgIC8qICsgKi9cbiV0b2tlbiBEQVNIICAgICAvKiAtICovXG4ldG9rZW4gU1RBUiAgICAgLyogKiAqL1xuJXRva2VuIEVRRVEgICAgIC8qID09ICovXG4ldG9rZW4gTkVRICAgICAgLyogIT0gKi9cbiV0b2tlbiBMVCAgICAgICAvKiA8ICovXG4ldG9rZW4gTFRFICAgICAgLyogPD0gKi9cbiV0b2tlbiBHVCAgICAgICAvKiA+ICovXG4ldG9rZW4gR1RFICAgICAgLyogPj0gKi9cbiV0b2tlbiBBTkQgICAgIC8qICYgKi9cbiV0b2tlbiBPUiAgICAgIC8qIHwgKi9cbiV0b2tlbiBJQU5EICAgLyogWyZdICovXG4ldG9rZW4gSU9SICAgIC8qIFt8XSAqL1xuJXRva2VuIFNITCAgICAgIC8qIDw8ICovXG4ldG9rZW4gU0hSICAgICAgLyogPj4gKi9cbiV0b2tlbiBTQVIgICAgICAvKiA+Pj4gKi9cbiV0b2tlbiBCQU5HICAgICAvKiAhICovXG4ldG9rZW4gVElMREUgICAgLyogfiAqL1xuJXRva2VuIEdMT0JBTCAgIC8qIGdsb2JhbCAqL1xuXG4lbGVmdCBJT1IgLyogcHJlY2VkZW5jZSAyMCAqL1xuJWxlZnQgSUFORCAvKiBwcmVjZWRlbmNlIDMwICovXG4lbGVmdCBPUiAvKiBwcmVjZWRlbmNlIDQwICovXG4lbGVmdCBBTkQgLyogcHJlY2VkZW5jZSA1MCAqL1xuJWxlZnQgRVFFUSBORVEgLyogcHJlY2VkZW5jZSA2MCAqL1xuJWxlZnQgTFQgTFRFIEdUIEdURSAvKiBwcmVjZWRlbmNlIDcwICovXG4lbGVmdCBTSEwgU0hSIFNBUiAvKiBwcmVjZWRlbmNlIDgwICovXG4lbGVmdCBQTFVTIERBU0ggLyogcHJlY2VkZW5jZSA5MCAqL1xuJWxlZnQgU1RBUiAvKiBwcmVjZWRlbmNlIDEwMCAqL1xuJW5vbmFzc29jIEJBTkdcbiVub25hc3NvYyBUSUxERVxuJW5vbmFzc29jIExCUkFDS0VUXG4lbm9uYXNzb2MgTFBBUkVOXG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuJXN0YXJ0IHByb2dcbiVzdGFydCBleHBfdG9wXG4lc3RhcnQgc3RtdF90b3BcbiV0eXBlIDxBc3QuZXhwIEFzdC5ub2RlPiBleHBfdG9wXG4ldHlwZSA8QXN0LnN0bXQgQXN0Lm5vZGU+IHN0bXRfdG9wXG5cbiV0eXBlIDxBc3QucHJvZz4gcHJvZ1xuJXR5cGUgPEFzdC5leHAgQXN0Lm5vZGU+IGV4cFxuJXR5cGUgPEFzdC5zdG10IEFzdC5ub2RlPiBzdG10XG4ldHlwZSA8QXN0LmJsb2NrPiBibG9ja1xuJXR5cGUgPEFzdC50eT4gdHlcbiUlXG5cbmV4cF90b3A6XG4gIHwgZT1leHAgRU9GIHsgZSB9XG5cbnN0bXRfdG9wOlxuICB8IHM9c3RtdCBFT0YgeyBzIH1cblxucHJvZzpcbiAgfCBwPWxpc3QoZGVjbCkgRU9GICB7IHAgfVxuXG5kZWNsOlxuICB8IEdMT0JBTCBuYW1lPUlERU5UIEVRIGluaXQ9Z2V4cCBTRU1JXG4gICAgeyBHdmRlY2wgKGxvYyAkc3RhcnRwb3MgJGVuZHBvcyB7IG5hbWU7IGluaXQgfSkgfVxuICB8IGZydHlwPXJldF90eSBmbmFtZT1JREVOVCBMUEFSRU4gYXJncz1hcmdsaXN0IFJQQVJFTiBib2R5PWJsb2NrXG4gICAgeyBHZmRlY2wgKGxvYyAkc3RhcnRwb3MgJGVuZHBvcyB7IGZydHlwOyBmbmFtZTsgYXJnczsgYm9keSB9KSB9XG5cbmFyZ2xpc3Q6XG4gIHwgbD1zZXBhcmF0ZWRfbGlzdChDT01NQSwgcGFpcih0eSxJREVOVCkpIHsgbCB9XG4gICAgXG50eTpcbiAgfCBUSU5UICAgeyBUSW50IH1cbiAgfCBUQk9PTCAgeyBUQm9vbCB9XG4gIHwgcj1ydHlwIHsgVFJlZiByIH0gXG5cblxuJWlubGluZSByZXRfdHk6XG4gIHwgVFZPSUQgIHsgUmV0Vm9pZCB9XG4gIHwgdD10eSAgIHsgUmV0VmFsIHQgfVxuXG4laW5saW5lIHJ0eXA6XG4gIHwgVFNUUklORyB7IFJTdHJpbmcgfVxuICB8IHQ9dHkgTEJSQUNLRVQgUkJSQUNLRVQgeyBSQXJyYXkgdCB9XG5cbiVpbmxpbmUgYm9wOlxuICB8IFBMVVMgICB7IEFkZCB9XG4gIHwgREFTSCAgIHsgU3ViIH1cbiAgfCBTVEFSICAgeyBNdWwgfVxuICB8IEVRRVEgICB7IEVxIH0gXG4gIHwgTkVRICAgeyBOZXEgfSBcbiAgfCBMVCAgIHsgTHQgfSBcbiAgfCBMVEUgICB7IEx0ZSB9IFxuICB8IEdUICAgeyBHdCB9IFxuICB8IEdURSAgIHsgR3RlIH0gXG4gIHwgQU5EICAgeyBBbmQgfSBcbiAgfCBPUiAgIHsgT3IgfSBcbiAgfCBJQU5EICAgeyBJQW5kIH0gXG4gIHwgSU9SICAgeyBJT3IgfSBcbiAgfCBTSEwgICAgeyBTaGwgfVxuICB8IFNIUiAgICB7IFNociB9XG4gIHwgU0FSICAgIHsgU2FyIH1cblxuJWlubGluZSB1b3A6XG4gIHwgREFTSCAgeyBOZWcgfVxuICB8IEJBTkcgIHsgTG9nbm90IH1cbiAgfCBUSUxERSB7IEJpdG5vdCB9XG5cbmdleHA6XG4gIHwgaT1JTlQgICAgICB7IGxvYyAkc3RhcnRwb3MgJGVuZHBvcyBAQCBDSW50IGkgfVxuICB8IHM9U1RSSU5HICAgeyBsb2MgJHN0YXJ0cG9zICRlbmRwb3MgQEAgQ1N0ciBzIH1cbiAgfCB0PXJ0eXAgTlVMTCAgeyBsb2MgJHN0YXJ0cG9zICRlbmRwb3MgQEAgQ051bGwgdCB9XG4gIHwgVFJVRSB7bG9jICRzdGFydHBvcyAkZW5kcG9zIEBAIENCb29sIHRydWUgfVxuICB8IEZBTFNFIHtsb2MgJHN0YXJ0cG9zICRlbmRwb3MgQEAgQ0Jvb2wgZmFsc2UgfVxuICB8IE5FVyB0PXR5IExCUkFDS0VUIFJCUkFDS0VUIExCUkFDRSBlcz1zZXBhcmF0ZWRfbGlzdChDT01NQSwgZ2V4cCkgUkJSQUNFXG4gICAgICAgICAgeyBsb2MgJHN0YXJ0cG9zICRlbmRwb3MgQEAgQ0Fycih0LCBlcykgfVxuKCogc3BlYyBkb2VzIG5vdCByZXF1aXJlIE5FVyBidXQgdGVzdHMgZG8gKilcbmxoczogIFxuICB8IGlkPUlERU5UICAgICAgICAgICAgeyBsb2MgJHN0YXJ0cG9zICRlbmRwb3MgQEAgSWQgaWQgfVxuICB8IGU9ZXhwIExCUkFDS0VUIGk9ZXhwIFJCUkFDS0VUXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGxvYyAkc3RhcnRwb3MgJGVuZHBvcyBAQCBJbmRleCAoZSwgaSkgfVxuXG5leHA6XG4gIHwgaWQ9SURFTlQgICAgICAgICAgICB7IGxvYyAkc3RhcnRwb3MgJGVuZHBvcyBAQCBJZCBpZCB9XG4gIHwgaT1JTlQgICAgICAgICAgICAgICB7IGxvYyAkc3RhcnRwb3MgJGVuZHBvcyBAQCBDSW50IGkgfVxuICB8IHM9U1RSSU5HICAgICAgICAgICAgeyBsb2MgJHN0YXJ0cG9zICRlbmRwb3MgQEAgQ1N0ciBzIH1cbiAgfCB0PXJ0eXAgTlVMTCAgICAgICAgICAgeyBsb2MgJHN0YXJ0cG9zICRlbmRwb3MgQEAgQ051bGwgdCB9XG4gIHwgVFJVRSAgICAgICAgICAgICAgICB7IGxvYyAkc3RhcnRwb3MgJGVuZHBvcyBAQCBDQm9vbCB0cnVlIH1cbiAgfCBGQUxTRSAgICAgICAgICAgICAgICB7IGxvYyAkc3RhcnRwb3MgJGVuZHBvcyBAQCBDQm9vbCBmYWxzZSB9XG4gIHwgZT1leHAgTEJSQUNLRVQgaT1leHAgUkJSQUNLRVRcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbG9jICRzdGFydHBvcyAkZW5kcG9zIEBAIEluZGV4IChlLCBpKSB9XG4gIHwgZT1leHAgTFBBUkVOIGVzPXNlcGFyYXRlZF9saXN0KENPTU1BLCBleHApIFJQQVJFTlxuICAgICAgICAgICAgICAgICAgICAgICAgeyBsb2MgJHN0YXJ0cG9zICRlbmRwb3MgQEAgQ2FsbCAoZSxlcykgfVxuICB8IE5FVyB0PXR5IExCUkFDS0VUIFJCUkFDS0VUIExCUkFDRSBlcz1zZXBhcmF0ZWRfbGlzdChDT01NQSwgZXhwKSBSQlJBQ0VcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbG9jICRzdGFydHBvcyAkZW5kcG9zIEBAIENBcnIodCwgZXMpIH1cbiAgfCBORVcgdD10eSBMQlJBQ0tFVCBlPWV4cCBSQlJBQ0tFVFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBsb2MgJHN0YXJ0cG9zICRlbmRwb3MgQEAgTmV3QXJyKHQsIGUpIH1cbiAgfCBlMT1leHAgYj1ib3AgZTI9ZXhwIHsgbG9jICRzdGFydHBvcyAkZW5kcG9zIEBAIEJvcCAoYiwgZTEsIGUyKSB9XG4gIHwgdT11b3AgZT1leHAgICAgICAgICB7IGxvYyAkc3RhcnRwb3MgJGVuZHBvcyBAQCBVb3AgKHUsIGUpIH1cbiAgfCBMUEFSRU4gZT1leHAgUlBBUkVOIHsgZSB9IFxuXG52ZGVjbDpcbiAgfCBWQVIgaWQ9SURFTlQgRVEgaW5pdD1leHAgeyAoaWQsIGluaXQpIH1cblxudmRlY2xzOlxuICB8IGRzPXNlcGFyYXRlZF9saXN0KENPTU1BLCB2ZGVjbCkgeyBkcyB9XG5cbmV4cF9vcHQ6XG4gIHwgKCogZW1wdHkgKikgeyBOb25lIH1cbiAgfCBlPWV4cCB7IFNvbWUgZSB9XG5cbnN0bXRfb3B0OlxuICB8ICgqIGVtcHR5ICopIHsgTm9uZSB9XG4gIHwgcz1zdG10IHsgU29tZSBzIH1cblxuc3RtdDogXG4gIHwgZD12ZGVjbCBTRU1JICAgICAgICB7IGxvYyAkc3RhcnRwb3MgJGVuZHBvcyBAQCBEZWNsKGQpIH1cbiAgfCBwPWxocyBFUSBlPWV4cCBTRU1JIHsgbG9jICRzdGFydHBvcyAkZW5kcG9zIEBAIEFzc24ocCxlKSB9XG4gIHwgZT1leHAgTFBBUkVOIGVzPXNlcGFyYXRlZF9saXN0KENPTU1BLCBleHApIFJQQVJFTiBTRU1JXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGxvYyAkc3RhcnRwb3MgJGVuZHBvcyBAQCBTQ2FsbCAoZSwgZXMpIH1cbiAgfCBpZnM9aWZfc3RtdCAgICAgICAgIHsgaWZzIH1cbiAgfCBSRVRVUk4gU0VNSSAgICAgICAgIHsgbG9jICRzdGFydHBvcyAkZW5kcG9zIEBAIFJldChOb25lKSB9XG4gIHwgUkVUVVJOIGU9ZXhwIFNFTUkgICB7IGxvYyAkc3RhcnRwb3MgJGVuZHBvcyBAQCBSZXQoU29tZSBlKSB9XG4gIHwgV0hJTEUgTFBBUkVOIGU9ZXhwIFJQQVJFTiBiPWJsb2NrICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbG9jICRzdGFydHBvcyAkZW5kcG9zIEBAIFdoaWxlKGUsIGIpIH1cbiAgfCBGT1IgTFBBUkVOIGRzPXZkZWNscyBTRU1JIGU9ZXhwX29wdCBTRU1JIHM9c3RtdF9vcHQgUlBBUkVOIGI9YmxvY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbG9jICRzdGFydHBvcyAkZW5kcG9zIEBAIEZvcihkcywgZSwgcywgYikgfVxuXG5ibG9jazpcbiAgfCBMQlJBQ0Ugc3RtdHM9bGlzdChzdG10KSBSQlJBQ0UgeyBzdG10cyB9XG5cbmlmX3N0bXQ6XG4gIHwgSUYgTFBBUkVOIGU9ZXhwIFJQQVJFTiBiMT1ibG9jayBiMj1lbHNlX3N0bXRcbiAgICB7IGxvYyAkc3RhcnRwb3MgJGVuZHBvcyBAQCBJZihlLGIxLGIyKSB9XG5cbmVsc2Vfc3RtdDpcbiAgfCAoKiBlbXB0eSAqKSAgICAgICB7IFtdIH1cbiAgfCBFTFNFIGI9YmxvY2sgICAgICB7IGIgfVxuICB8IEVMU0UgaWZzPWlmX3N0bXQgIHsgWyBpZnMgXSB9XG4iLCJ7XG4gIG9wZW4gTGV4aW5nXG4gIG9wZW4gUGFyc2VyXG4gIG9wZW4gUmFuZ2VcbiAgXG4gIGV4Y2VwdGlvbiBMZXhlcl9lcnJvciBvZiBSYW5nZS50ICogc3RyaW5nXG5cbiAgbGV0IHJlc2V0X2xleGJ1ZiAoZmlsZW5hbWU6c3RyaW5nKSAobG51bTppbnQpIGxleGJ1ZiA6IHVuaXQgPVxuICAgIGxleGJ1Zi5sZXhfY3Vycl9wIDwtIHtcbiAgICAgIHBvc19mbmFtZSA9IGZpbGVuYW1lO1xuICAgICAgcG9zX2NudW0gPSAwO1xuICAgICAgcG9zX2JvbCA9IDA7XG4gICAgICBwb3NfbG51bSA9IGxudW07XG4gICAgfVxuXG4gIGxldCBuZXdsaW5lIGxleGJ1ZiA9XG4gICAgbGV4YnVmLmxleF9jdXJyX3AgPC0geyAobGV4ZW1lX2VuZF9wIGxleGJ1Zikgd2l0aFxuICAgICAgcG9zX2xudW0gPSAobGV4ZW1lX2VuZF9wIGxleGJ1ZikucG9zX2xudW0gKyAxO1xuICAgICAgcG9zX2JvbCA9IChsZXhlbWVfZW5kIGxleGJ1ZikgfVxuICAgIFxuICAoKiBCb2lsZXJwbGF0ZSB0byBkZWZpbmUgZXhjZXB0aW9uYWwgY2FzZXMgaW4gdGhlIGxleGVyLiAqKVxuICBsZXQgdW5leHBlY3RlZF9jaGFyIGxleGJ1ZiAoYzpjaGFyKSA6ICdhID1cbiAgICByYWlzZSAoTGV4ZXJfZXJyb3IgKFJhbmdlLmxleF9yYW5nZSBsZXhidWYsXG4gICAgICAgIFByaW50Zi5zcHJpbnRmIFwiVW5leHBlY3RlZCBjaGFyYWN0ZXI6ICclYydcIiBjKSlcblxuICAoKiBMZXhpbmcgcmVzZXJ2ZWQgd29yZHMgKilcbiAgbGV0IHJlc2VydmVkX3dvcmRzID0gW1xuICAoKiBLZXl3b3JkcyAqKVxuICAoXCJudWxsXCIsIE5VTEwpO1xuICAoXCJ0cnVlXCIsIFRSVUUpO1xuICAoXCJmYWxzZVwiLCBGQUxTRSk7XG4gIChcInZvaWRcIiwgVFZPSUQpO1xuICAoXCJib29sXCIsIFRCT09MKTtcbiAgKFwiaW50XCIsIFRJTlQpO1xuICAoXCJzdHJpbmdcIiwgVFNUUklORyk7XG4gIChcIm5ld1wiLCBORVcpO1xuICAoXCJlbHNlXCIsIEVMU0UpO1xuICAoXCJpZlwiLCBJRik7XG4gIChcIndoaWxlXCIsIFdISUxFKTtcbiAgKFwiZm9yXCIsIEZPUik7XG4gIChcInJldHVyblwiLCBSRVRVUk4pO1xuICAoXCJ2YXJcIiwgVkFSKTtcbiAgKFwiZ2xvYmFsXCIsIEdMT0JBTCk7XG5cbiAgKCogU3ltYm9scyAqKVxuICAoIFwiO1wiLCBTRU1JKTtcbiAgKCBcIixcIiwgQ09NTUEpO1xuICAoIFwie1wiLCBMQlJBQ0UpO1xuICAoIFwifVwiLCBSQlJBQ0UpO1xuICAoIFwiKFwiLCBMUEFSRU4pO1xuICAoIFwiKVwiLCBSUEFSRU4pO1xuICAoIFwiW1wiLCBMQlJBQ0tFVCk7XG4gICggXCJdXCIsIFJCUkFDS0VUKTtcbiAgKCBcIj1cIiwgRVEpO1xuICAoKiBCaW5hcnkgT3BlcmF0b3JzICopXG4gICggXCIrXCIsIFBMVVMpO1xuICAoIFwiLVwiLCBEQVNIKTsgKCogQWxzbyBVbmFyeSAqKVxuICAoIFwiKlwiLCBTVEFSKTtcbiAgKCBcIj09XCIsIEVRRVEpO1xuICAoIFwiIT1cIiwgTkVRKTtcbiAgKCBcIjxcIiwgTFQpO1xuICAoIFwiPD1cIiwgTFRFKTtcbiAgKCBcIj5cIiwgR1QpO1xuICAoIFwiPj1cIiwgR1RFKTtcbiAgKCBcIiZcIiwgQU5EKTtcbiAgKCBcInxcIiwgT1IpO1xuICAoIFwiWyZdXCIsIElBTkQpO1xuICAoIFwiW3xdXCIsIElPUik7XG4gICggXCI8PFwiLCBTSEwpO1xuICAoIFwiPj5cIiwgU0hSKTtcbiAgKCBcIj4+PlwiLCBTQVIpO1xuICAoKiBVbmFyeSBPcGVyYXRvcnMgKilcbiAgKCBcIiFcIiwgQkFORyk7XG4gICggXCJ+XCIsIFRJTERFKTtcbiAgXG4gIF1cblxubGV0IChzeW1ib2xfdGFibGUgOiAoc3RyaW5nLCBQYXJzZXIudG9rZW4pIEhhc2h0YmwudCkgPSBIYXNodGJsLmNyZWF0ZSAxMDI0XG4gIGxldCBfID1cbiAgICBMaXN0Lml0ZXIgKGZ1biAoc3RyLHQpIC0+IEhhc2h0YmwuYWRkIHN5bWJvbF90YWJsZSBzdHIgdCkgcmVzZXJ2ZWRfd29yZHNcblxuICBsZXQgY3JlYXRlX3Rva2VuIGxleGJ1ZiA9XG4gICAgbGV0IHN0ciA9IGxleGVtZSBsZXhidWYgaW4gXG4gICAgdHJ5IChIYXNodGJsLmZpbmQgc3ltYm9sX3RhYmxlIHN0cikgXG4gICAgd2l0aCBfIC0+IElERU5UIHN0clxuXG4gICgqIExleGluZyBjb21tZW50cyBhbmQgc3RyaW5ncyAqKVxuICBsZXQgc3RyaW5nX2J1ZmZlciA9IHJlZiAoQnl0ZXMuY3JlYXRlIDIwNDgpXG4gIGxldCBzdHJpbmdfZW5kID0gcmVmIDBcbiAgbGV0IHN0YXJ0X2xleCA9IHJlZiAoUmFuZ2Uuc3RhcnRfb2ZfcmFuZ2UgUmFuZ2Uubm9yYW5nZSlcblxuICBsZXQgc3RhcnRfcG9zX29mX2xleGJ1ZiBsZXhidWYgOiBwb3MgPVxuICAgIChSYW5nZS5wb3Nfb2ZfbGV4cG9zIChsZXhlbWVfc3RhcnRfcCBsZXhidWYpKVxuXG4gIGxldCBsZXhfbG9uZ19yYW5nZSBsZXhidWYgOiBSYW5nZS50ID1cbiAgICBsZXQgZW5kX3AgPSBsZXhlbWVfZW5kX3AgbGV4YnVmIGluXG4gICAgbWtfcmFuZ2UgZW5kX3AucG9zX2ZuYW1lICghc3RhcnRfbGV4KSAocG9zX29mX2xleHBvcyBlbmRfcCkgIFxuXG4gIGxldCByZXNldF9zdHIgKCkgPSBzdHJpbmdfZW5kIDo9IDBcblxuICBsZXQgYWRkX3N0ciBjaCA9XG4gICAgbGV0IHggPSAhc3RyaW5nX2VuZCBpblxuICAgIGxldCBidWZmZXIgPSAhc3RyaW5nX2J1ZmZlclxuICAgIGluXG4gICAgICBpZiB4ID0gQnl0ZXMubGVuZ3RoIGJ1ZmZlciB0aGVuXG4gICAgICAgIGJlZ2luXG4gICAgICAgICAgbGV0IG5ld19idWZmZXIgPSBCeXRlcy5jcmVhdGUgKHgqMikgaW5cbiAgICAgICAgICBCeXRlcy5ibGl0IGJ1ZmZlciAwIG5ld19idWZmZXIgMCB4O1xuICAgICAgICAgIEJ5dGVzLnNldCBuZXdfYnVmZmVyIHggY2g7XG4gICAgICAgICAgc3RyaW5nX2J1ZmZlciA6PSBuZXdfYnVmZmVyO1xuICAgICAgICAgIHN0cmluZ19lbmQgOj0geCsxXG4gICAgICAgIGVuZFxuICAgICAgZWxzZVxuICAgICAgICBiZWdpblxuICAgICAgICAgIEJ5dGVzLnNldCBidWZmZXIgeCBjaDtcbiAgICAgICAgICBzdHJpbmdfZW5kIDo9IHgrMVxuICAgICAgICBlbmRcblxuICBsZXQgZ2V0X3N0ciAoKSA9IEJ5dGVzLnN1Yl9zdHJpbmcgKCFzdHJpbmdfYnVmZmVyKSAwICghc3RyaW5nX2VuZClcblxuICAoKiBMZXhpbmcgZGlyZWN0aXZlcyAqKVxuICBsZXQgbG51bSA9IHJlZiAxXG59XG5cbigqIERlY2xhcmUgeW91ciBhbGlhc2VzIChsZXQgZm9vID0gcmVnZXgpIGFuZCBydWxlcyBoZXJlLiAqKVxubGV0IG5ld2xpbmUgPSAnXFxuJyB8ICgnXFxyJyAnXFxuJykgfCAnXFxyJ1xubGV0IGxvd2VyY2FzZSA9IFsnYSctJ3onXVxubGV0IHVwcGVyY2FzZSA9IFsnQSctJ1onXVxubGV0IGNoYXJhY3RlciA9IHVwcGVyY2FzZSB8IGxvd2VyY2FzZVxubGV0IHdoaXRlc3BhY2UgPSBbJ1xcdCcgJyAnXVxubGV0IGRpZ2l0ID0gWycwJy0nOSddXG5sZXQgaGV4ZGlnaXQgPSBbJzAnLSc5J10gfCBbJ2EnLSdmJ10gfCBbJ0EnLSdGJ11cblxucnVsZSB0b2tlbiA9IHBhcnNlXG4gIHwgZW9mIHsgRU9GIH1cblxuICB8IFwiLypcIiB7IHN0YXJ0X2xleCA6PSBzdGFydF9wb3Nfb2ZfbGV4YnVmIGxleGJ1ZjsgY29tbWVudHMgMCBsZXhidWYgfVxuICB8ICdcIicgeyByZXNldF9zdHIoKTsgc3RhcnRfbGV4IDo9IHN0YXJ0X3Bvc19vZl9sZXhidWYgbGV4YnVmOyBzdHJpbmcgZmFsc2UgbGV4YnVmIH1cbiAgfCAnIycgeyBsZXQgcCA9IGxleGVtZV9zdGFydF9wIGxleGJ1ZiBpblxuICAgICAgICAgIGlmIHAucG9zX2NudW0gLSBwLnBvc19ib2wgPSAwIHRoZW4gZGlyZWN0aXZlIDAgbGV4YnVmIFxuICAgICAgICAgIGVsc2UgcmFpc2UgKExleGVyX2Vycm9yIChsZXhfbG9uZ19yYW5nZSBsZXhidWYsXG4gICAgICAgICAgICBQcmludGYuc3ByaW50ZiBcIiMgY2FuIG9ubHkgYmUgdGhlIDFzdCBjaGFyIGluIGEgbGluZS5cIikpIH1cblxuICB8IGxvd2VyY2FzZSAoZGlnaXQgfCBjaGFyYWN0ZXIgfCAnXycpKiB7IGNyZWF0ZV90b2tlbiBsZXhidWYgfVxuICB8IGRpZ2l0KyB8IFwiMHhcIiBoZXhkaWdpdCsgeyBJTlQgKEludDY0Lm9mX3N0cmluZyAobGV4ZW1lIGxleGJ1ZikpIH1cbiAgfCB3aGl0ZXNwYWNlKyB7IHRva2VuIGxleGJ1ZiB9XG4gIHwgbmV3bGluZSB7IG5ld2xpbmUgbGV4YnVmOyB0b2tlbiBsZXhidWYgfVxuXG4gIHwgJzsnIHwgJywnIHwgJ3snIHwgJ30nIHwgJysnIHwgJy0nIHwgJyonIHwgJz0nIHwgXCI9PVwiIFxuICB8IFwiIT1cIiB8ICchJyB8ICd+JyB8ICcoJyB8ICcpJyB8ICdbJyB8ICddJyBcbiAgfCAnPCcgfCBcIjw9XCIgfCAnPicgfCBcIj49XCIgfCAnJicgfCAnfCdcbiAgfCBcIlsmXVwiIHwgXCJbfF1cIiB8IFwiPDxcIiB8IFwiPj4+XCIgfCBcIj4+XCJcbiAgICB7IGNyZWF0ZV90b2tlbiBsZXhidWYgfVxuXG4gIHwgXyBhcyBjIHsgdW5leHBlY3RlZF9jaGFyIGxleGJ1ZiBjIH1cblxuYW5kIGRpcmVjdGl2ZSBzdGF0ZSA9IHBhcnNlXG4gIHwgd2hpdGVzcGFjZSsgeyBkaXJlY3RpdmUgc3RhdGUgbGV4YnVmIH0gXG4gIHwgZGlnaXQrIHsgaWYgc3RhdGUgPSAwIHRoZW4gXG4gICAgICAgICAgICAgICAobG51bSA6PSBpbnRfb2Zfc3RyaW5nIChsZXhlbWUgbGV4YnVmKTsgXG4gICAgICAgICAgICAgICAgZGlyZWN0aXZlIDEgbGV4YnVmKVxuICAgICAgICAgICAgIGVsc2UgaWYgc3RhdGUgPSAyIHRoZW4gZGlyZWN0aXZlIDMgbGV4YnVmXG4gICAgICAgICAgICAgZWxzZSByYWlzZSAoTGV4ZXJfZXJyb3IgKGxleF9sb25nX3JhbmdlIGxleGJ1ZixcbiAgICAgICAgICAgICAgIFByaW50Zi5zcHJpbnRmIFwiSWxsZWdhbCBkaXJlY3RpdmVzXCIpKSB9XG4gIHwgJ1wiJyB7IGlmIHN0YXRlID0gMSB0aGVuXG4gICAgICAgICAgICBiZWdpblxuICAgICAgICAgICAgICByZXNldF9zdHIoKTsgXG4gICAgICAgICAgICAgIHN0YXJ0X2xleCA6PSBzdGFydF9wb3Nfb2ZfbGV4YnVmIGxleGJ1ZjsgXG4gICAgICAgICAgICAgIHN0cmluZyB0cnVlIGxleGJ1ZlxuICAgICAgICAgICAgZW5kIFxuICAgICAgICAgIGVsc2UgcmFpc2UgKExleGVyX2Vycm9yIChsZXhfbG9uZ19yYW5nZSBsZXhidWYsXG4gICAgICAgICAgICBQcmludGYuc3ByaW50ZiBcIklsbGVnYWwgZGlyZWN0aXZlc1wiKSkgXG4gICAgICAgICB9XG4gIHwgbmV3bGluZSB7IGlmIHN0YXRlID0gMiB8fCBzdGF0ZSA9IDMgdGhlblxuICAgICAgICAgICAgICAgIGJlZ2luIFxuICAgICAgICAgICAgICAgICAgcmVzZXRfbGV4YnVmIChnZXRfc3RyKCkpICFsbnVtIGxleGJ1ZjtcbiAgICAgICAgICAgICAgICAgIHRva2VuIGxleGJ1ZlxuICAgICAgICAgICAgICAgIGVuZCBcbiAgICAgICAgICAgICAgZWxzZSByYWlzZSAoTGV4ZXJfZXJyb3IgKGxleF9sb25nX3JhbmdlIGxleGJ1ZixcbiAgICAgICAgICAgICAgICBQcmludGYuc3ByaW50ZiBcIklsbGVnYWwgZGlyZWN0aXZlc1wiKSkgfVxuICB8IF8geyByYWlzZSAoTGV4ZXJfZXJyb3IgKGxleF9sb25nX3JhbmdlIGxleGJ1ZiwgXG4gICAgICAgICAgUHJpbnRmLnNwcmludGYgXCJJbGxlZ2FsIGRpcmVjdGl2ZXNcIikpIH1cblxuYW5kIGNvbW1lbnRzIGxldmVsID0gcGFyc2VcbiAgfCBcIiovXCIgeyBpZiBsZXZlbCA9IDAgdGhlbiB0b2tlbiBsZXhidWZcblx0ICAgZWxzZSBjb21tZW50cyAobGV2ZWwtMSkgbGV4YnVmIH1cbiAgfCBcIi8qXCIgeyBjb21tZW50cyAobGV2ZWwrMSkgbGV4YnVmfVxuICB8IFteICdcXG4nXSB7IGNvbW1lbnRzIGxldmVsIGxleGJ1ZiB9XG4gIHwgXCJcXG5cIiB7IG5ld2xpbmUgbGV4YnVmOyBjb21tZW50cyBsZXZlbCBsZXhidWYgfVxuICB8IGVvZlx0IHsgcmFpc2UgKExleGVyX2Vycm9yIChsZXhfbG9uZ19yYW5nZSBsZXhidWYsXG4gICAgICAgICAgICAgUHJpbnRmLnNwcmludGYgXCJjb21tZW50cyBhcmUgbm90IGNsb3NlZFwiKSkgfVxuXG5hbmQgc3RyaW5nIGluX2RpcmVjdGl2ZSA9IHBhcnNlXG4gIHwgJ1wiJyAgeyBpZiBpbl9kaXJlY3RpdmUgPSBmYWxzZSB0aGVuXG4gICAgICAgICAgICAgU1RSSU5HIChnZXRfc3RyKCkpXG4gICAgICAgICAgIGVsc2UgZGlyZWN0aXZlIDIgbGV4YnVmIH0gIFxuICB8ICdcXFxcJyB7IGFkZF9zdHIoZXNjYXBlZCBsZXhidWYpOyBzdHJpbmcgaW5fZGlyZWN0aXZlIGxleGJ1ZiB9XG4gIHwgJ1xcbicgeyBhZGRfc3RyICdcXG4nOyBuZXdsaW5lIGxleGJ1Zjsgc3RyaW5nIGluX2RpcmVjdGl2ZSBsZXhidWYgfVxuICB8IGVvZiAgeyByYWlzZSAoTGV4ZXJfZXJyb3IgKGxleF9sb25nX3JhbmdlIGxleGJ1ZixcbiAgICAgICAgICAgICBQcmludGYuc3ByaW50ZiBcIlN0cmluZyBpcyBub3QgdGVybWluYXRlZFwiKSkgfVxuICB8IF8gICAgeyBhZGRfc3RyIChMZXhpbmcubGV4ZW1lX2NoYXIgbGV4YnVmIDApOyBzdHJpbmcgaW5fZGlyZWN0aXZlIGxleGJ1ZiB9XG5cbmFuZCBlc2NhcGVkID0gcGFyc2VcbiAgfCAnbicgICAgeyAnXFxuJyB9XG4gIHwgJ3QnICAgIHsgJ1xcdCcgfVxuICB8ICdcXFxcJyAgIHsgJ1xcXFwnIH1cbiAgfCAnXCInICAgIHsgJ1xcMDM0JyAgfVxuICB8ICdcXCcnICAgeyAnXFwnJyB9XG4gIHwgWycwJy0nOSddWycwJy0nOSddWycwJy0nOSddXG4gICAge1xuICAgICAgbGV0IHggPSBpbnRfb2Zfc3RyaW5nKGxleGVtZSBsZXhidWYpIGluXG4gICAgICBpZiB4ID4gMjU1IHRoZW5cbiAgICAgICAgcmFpc2UgKExleGVyX2Vycm9yIChsZXhfbG9uZ19yYW5nZSBsZXhidWYsXG4gICAgICAgICAgKFByaW50Zi5zcHJpbnRmIFwiJXMgaXMgYW4gaWxsZWdhbCBlc2NhcGVkIGNoYXJhY3RlciBjb25zdGFudFwiIChsZXhlbWUgbGV4YnVmKSkpKVxuICAgICAgZWxzZVxuICAgICAgICBDaGFyLmNociB4XG4gICAgfVxuICB8IFteICdcIicgJ1xcXFwnICd0JyAnbicgJ1xcJyddXG4gICAgeyByYWlzZSAoTGV4ZXJfZXJyb3IgKGxleF9sb25nX3JhbmdlIGxleGJ1ZixcbiAgICAgICAgKFByaW50Zi5zcHJpbnRmIFwiJXMgaXMgYW4gaWxsZWdhbCBlc2NhcGVkIGNoYXJhY3RlciBjb25zdGFudFwiIChsZXhlbWUgbGV4YnVmKSApKSkgfVxuXG4iLCIjIDEgXCJodzAzL2xleGVyLm1sbFwiXG4gXG4gIG9wZW4gTGV4aW5nXG4gIG9wZW4gUGFyc2VyXG4gIG9wZW4gUmFuZ2VcbiAgXG4gIGV4Y2VwdGlvbiBMZXhlcl9lcnJvciBvZiBSYW5nZS50ICogc3RyaW5nXG5cbiAgbGV0IHJlc2V0X2xleGJ1ZiAoZmlsZW5hbWU6c3RyaW5nKSAobG51bTppbnQpIGxleGJ1ZiA6IHVuaXQgPVxuICAgIGxleGJ1Zi5sZXhfY3Vycl9wIDwtIHtcbiAgICAgIHBvc19mbmFtZSA9IGZpbGVuYW1lO1xuICAgICAgcG9zX2NudW0gPSAwO1xuICAgICAgcG9zX2JvbCA9IDA7XG4gICAgICBwb3NfbG51bSA9IGxudW07XG4gICAgfVxuXG4gIGxldCBuZXdsaW5lIGxleGJ1ZiA9XG4gICAgbGV4YnVmLmxleF9jdXJyX3AgPC0geyAobGV4ZW1lX2VuZF9wIGxleGJ1Zikgd2l0aFxuICAgICAgcG9zX2xudW0gPSAobGV4ZW1lX2VuZF9wIGxleGJ1ZikucG9zX2xudW0gKyAxO1xuICAgICAgcG9zX2JvbCA9IChsZXhlbWVfZW5kIGxleGJ1ZikgfVxuICAgIFxuICAoKiBCb2lsZXJwbGF0ZSB0byBkZWZpbmUgZXhjZXB0aW9uYWwgY2FzZXMgaW4gdGhlIGxleGVyLiAqKVxuICBsZXQgdW5leHBlY3RlZF9jaGFyIGxleGJ1ZiAoYzpjaGFyKSA6ICdhID1cbiAgICByYWlzZSAoTGV4ZXJfZXJyb3IgKFJhbmdlLmxleF9yYW5nZSBsZXhidWYsXG4gICAgICAgIFByaW50Zi5zcHJpbnRmIFwiVW5leHBlY3RlZCBjaGFyYWN0ZXI6ICclYydcIiBjKSlcblxuICAoKiBMZXhpbmcgcmVzZXJ2ZWQgd29yZHMgKilcbiAgbGV0IHJlc2VydmVkX3dvcmRzID0gW1xuICAoKiBLZXl3b3JkcyAqKVxuICAoXCJudWxsXCIsIE5VTEwpO1xuICAoXCJ0cnVlXCIsIFRSVUUpO1xuICAoXCJmYWxzZVwiLCBGQUxTRSk7XG4gIChcInZvaWRcIiwgVFZPSUQpO1xuICAoXCJib29sXCIsIFRCT09MKTtcbiAgKFwiaW50XCIsIFRJTlQpO1xuICAoXCJzdHJpbmdcIiwgVFNUUklORyk7XG4gIChcIm5ld1wiLCBORVcpO1xuICAoXCJlbHNlXCIsIEVMU0UpO1xuICAoXCJpZlwiLCBJRik7XG4gIChcIndoaWxlXCIsIFdISUxFKTtcbiAgKFwiZm9yXCIsIEZPUik7XG4gIChcInJldHVyblwiLCBSRVRVUk4pO1xuICAoXCJ2YXJcIiwgVkFSKTtcbiAgKFwiZ2xvYmFsXCIsIEdMT0JBTCk7XG5cbiAgKCogU3ltYm9scyAqKVxuICAoIFwiO1wiLCBTRU1JKTtcbiAgKCBcIixcIiwgQ09NTUEpO1xuICAoIFwie1wiLCBMQlJBQ0UpO1xuICAoIFwifVwiLCBSQlJBQ0UpO1xuICAoIFwiKFwiLCBMUEFSRU4pO1xuICAoIFwiKVwiLCBSUEFSRU4pO1xuICAoIFwiW1wiLCBMQlJBQ0tFVCk7XG4gICggXCJdXCIsIFJCUkFDS0VUKTtcbiAgKCBcIj1cIiwgRVEpO1xuICAoKiBCaW5hcnkgT3BlcmF0b3JzICopXG4gICggXCIrXCIsIFBMVVMpO1xuICAoIFwiLVwiLCBEQVNIKTsgKCogQWxzbyBVbmFyeSAqKVxuICAoIFwiKlwiLCBTVEFSKTtcbiAgKCBcIj09XCIsIEVRRVEpO1xuICAoIFwiIT1cIiwgTkVRKTtcbiAgKCBcIjxcIiwgTFQpO1xuICAoIFwiPD1cIiwgTFRFKTtcbiAgKCBcIj5cIiwgR1QpO1xuICAoIFwiPj1cIiwgR1RFKTtcbiAgKCBcIiZcIiwgQU5EKTtcbiAgKCBcInxcIiwgT1IpO1xuICAoIFwiWyZdXCIsIElBTkQpO1xuICAoIFwiW3xdXCIsIElPUik7XG4gICggXCI8PFwiLCBTSEwpO1xuICAoIFwiPj5cIiwgU0hSKTtcbiAgKCBcIj4+PlwiLCBTQVIpO1xuICAoKiBVbmFyeSBPcGVyYXRvcnMgKilcbiAgKCBcIiFcIiwgQkFORyk7XG4gICggXCJ+XCIsIFRJTERFKTtcbiAgXG4gIF1cblxubGV0IChzeW1ib2xfdGFibGUgOiAoc3RyaW5nLCBQYXJzZXIudG9rZW4pIEhhc2h0YmwudCkgPSBIYXNodGJsLmNyZWF0ZSAxMDI0XG4gIGxldCBfID1cbiAgICBMaXN0Lml0ZXIgKGZ1biAoc3RyLHQpIC0+IEhhc2h0YmwuYWRkIHN5bWJvbF90YWJsZSBzdHIgdCkgcmVzZXJ2ZWRfd29yZHNcblxuICBsZXQgY3JlYXRlX3Rva2VuIGxleGJ1ZiA9XG4gICAgbGV0IHN0ciA9IGxleGVtZSBsZXhidWYgaW4gXG4gICAgdHJ5IChIYXNodGJsLmZpbmQgc3ltYm9sX3RhYmxlIHN0cikgXG4gICAgd2l0aCBfIC0+IElERU5UIHN0clxuXG4gICgqIExleGluZyBjb21tZW50cyBhbmQgc3RyaW5ncyAqKVxuICBsZXQgc3RyaW5nX2J1ZmZlciA9IHJlZiAoQnl0ZXMuY3JlYXRlIDIwNDgpXG4gIGxldCBzdHJpbmdfZW5kID0gcmVmIDBcbiAgbGV0IHN0YXJ0X2xleCA9IHJlZiAoUmFuZ2Uuc3RhcnRfb2ZfcmFuZ2UgUmFuZ2Uubm9yYW5nZSlcblxuICBsZXQgc3RhcnRfcG9zX29mX2xleGJ1ZiBsZXhidWYgOiBwb3MgPVxuICAgIChSYW5nZS5wb3Nfb2ZfbGV4cG9zIChsZXhlbWVfc3RhcnRfcCBsZXhidWYpKVxuXG4gIGxldCBsZXhfbG9uZ19yYW5nZSBsZXhidWYgOiBSYW5nZS50ID1cbiAgICBsZXQgZW5kX3AgPSBsZXhlbWVfZW5kX3AgbGV4YnVmIGluXG4gICAgbWtfcmFuZ2UgZW5kX3AucG9zX2ZuYW1lICghc3RhcnRfbGV4KSAocG9zX29mX2xleHBvcyBlbmRfcCkgIFxuXG4gIGxldCByZXNldF9zdHIgKCkgPSBzdHJpbmdfZW5kIDo9IDBcblxuICBsZXQgYWRkX3N0ciBjaCA9XG4gICAgbGV0IHggPSAhc3RyaW5nX2VuZCBpblxuICAgIGxldCBidWZmZXIgPSAhc3RyaW5nX2J1ZmZlclxuICAgIGluXG4gICAgICBpZiB4ID0gQnl0ZXMubGVuZ3RoIGJ1ZmZlciB0aGVuXG4gICAgICAgIGJlZ2luXG4gICAgICAgICAgbGV0IG5ld19idWZmZXIgPSBCeXRlcy5jcmVhdGUgKHgqMikgaW5cbiAgICAgICAgICBCeXRlcy5ibGl0IGJ1ZmZlciAwIG5ld19idWZmZXIgMCB4O1xuICAgICAgICAgIEJ5dGVzLnNldCBuZXdfYnVmZmVyIHggY2g7XG4gICAgICAgICAgc3RyaW5nX2J1ZmZlciA6PSBuZXdfYnVmZmVyO1xuICAgICAgICAgIHN0cmluZ19lbmQgOj0geCsxXG4gICAgICAgIGVuZFxuICAgICAgZWxzZVxuICAgICAgICBiZWdpblxuICAgICAgICAgIEJ5dGVzLnNldCBidWZmZXIgeCBjaDtcbiAgICAgICAgICBzdHJpbmdfZW5kIDo9IHgrMVxuICAgICAgICBlbmRcblxuICBsZXQgZ2V0X3N0ciAoKSA9IEJ5dGVzLnN1Yl9zdHJpbmcgKCFzdHJpbmdfYnVmZmVyKSAwICghc3RyaW5nX2VuZClcblxuICAoKiBMZXhpbmcgZGlyZWN0aXZlcyAqKVxuICBsZXQgbG51bSA9IHJlZiAxXG5cbiMgMTI2IFwiaHcwMy9sZXhlci5tbFwiXG5sZXQgX19vY2FtbF9sZXhfdGFibGVzID0ge1xuICBMZXhpbmcubGV4X2Jhc2UgPVxuICAgXCJcXDAwMFxcMDAwXFwyNDZcXDI1NVxcMjQ3XFwyNTVcXDAwMlxcMDAwXFwwMDVcXDAwMFxcMDA4XFwwMDBcXDAwNlxcMDAwXFwwMDdcXDAwMFxcXG4gICAgXFwwMDFcXDAwMFxcMjQ4XFwyNTVcXDAwNVxcMDAwXFwwMjFcXDAwMFxcMDMxXFwwMDBcXDA4N1xcMDAwXFwyNTJcXDI1NVxcMjUzXFwyNTVcXFxuICAgIFxcMDE2XFwwMDBcXDI1NVxcMjU1XFwyNTRcXDI1NVxcMTYyXFwwMDBcXDE4NVxcMDAwXFwwMDFcXDAwMFxcMDAyXFwwMDBcXDAyN1xcMDAwXFxcbiAgICBcXDAwMFxcMDAxXFwyNTFcXDI1NVxcMDAyXFwwMDBcXDI1MlxcMjU1XFwyNTNcXDI1NVxcMjIyXFwwMDBcXDAwN1xcMDAwXFwwODZcXDAwMFxcXG4gICAgXFwyNTFcXDI1NVxcMjUyXFwyNTVcXDI1M1xcMjU1XFwwNDhcXDAwMFxcMDQ1XFwwMDBcXDI1NVxcMjU1XFwyNTRcXDI1NVxcMjEwXFwwMDBcXFxuICAgIFxcMjUxXFwyNTVcXDI1MlxcMjU1XFwyNTNcXDI1NVxcMjU0XFwyNTVcXDI1NVxcMjU1XFwwMjRcXDAwMVxcMjQ5XFwyNTVcXDI0M1xcMDAwXFxcbiAgICBcXDI1MVxcMjU1XFwyNTJcXDI1NVxcMjUzXFwyNTVcXDI1NFxcMjU1XFwyNTVcXDI1NVxcMDM5XFwwMDFcXDI1MFxcMjU1XCI7XG4gIExleGluZy5sZXhfYmFja3RyayA9XG4gICBcIlxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDA4XFwwMDBcXDAwOFxcMDAwXFwwMDhcXDAwMFxcMDA4XFwwMDBcXDAwOFxcMDAwXFxcbiAgICBcXDAwN1xcMDAwXFwyNTVcXDI1NVxcMDA2XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA0XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwwMDlcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDA1XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDA4XFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDNcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDFcXDAwMFxcMDAwXFwwMDBcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDA2XFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcIjtcbiAgTGV4aW5nLmxleF9kZWZhdWx0ID1cbiAgIFwiXFwwMDFcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDAwMFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwwMjVcXDAwMFxcMDAwXFwwMDBcXDI1NVxcMjU1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDM0XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDA0MFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDQ2XFwwMDBcXDAwMFxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDI1NVxcMjU1XFwwMDBcXDAwMFwiO1xuICBMZXhpbmcubGV4X3RyYW5zID1cbiAgIFwiXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAxMFxcMDAwXFwwMDlcXDAwMFxcMDA5XFwwMDBcXDAyN1xcMDAwXFwwMDhcXDAwMFxcMDEwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAzMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDEwXFwwMDBcXDAwNlxcMDAwXFwwMTVcXDAwMFxcMDE0XFwwMDBcXDAwMFxcMDAwXFwwMTBcXDAwMFxcMDAyXFwwMDBcXDAzMFxcMDAwXFxcbiAgICBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAyMlxcMDAwXFwwMTZcXDAwMFxcXG4gICAgXFwwMTJcXDAwMFxcMDExXFwwMDBcXDAxMVxcMDAwXFwwMTFcXDAwMFxcMDExXFwwMDBcXDAxMVxcMDAwXFwwMTFcXDAwMFxcMDExXFwwMDBcXFxuICAgIFxcMDExXFwwMDBcXDAxMVxcMDAwXFwwMThcXDAwMFxcMDAyXFwwMDBcXDAwNFxcMDAwXFwwMDdcXDAwMFxcMDAzXFwwMDBcXDAwMlxcMDAwXFxcbiAgICBcXDAyM1xcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDExXFwwMDBcXDAxMVxcMDAwXFwwMTFcXDAwMFxcXG4gICAgXFwwMTFcXDAwMFxcMDExXFwwMDBcXDAxMVxcMDAwXFwwMTFcXDAwMFxcMDExXFwwMDBcXDAxMVxcMDAwXFwwMTFcXDAwMFxcMDExXFwwMDBcXFxuICAgIFxcMDExXFwwMDBcXDAxMVxcMDAwXFwwMTFcXDAwMFxcMDExXFwwMDBcXDAxMVxcMDAwXFwwMTFcXDAwMFxcMDExXFwwMDBcXDAxMVxcMDAwXFxcbiAgICBcXDAxMVxcMDAwXFwwMDJcXDAwMFxcMDM4XFwwMDBcXDAwNVxcMDAwXFwwMzdcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcXG4gICAgXFwwMzNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXFxuICAgIFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFxcbiAgICBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcXG4gICAgXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDM2XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAyMVxcMDAwXFwwMzVcXDAwMFxcMDAwXFwwMDBcXDAxM1xcMDAwXFxcbiAgICBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcXG4gICAgXFwwMTNcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFxcbiAgICBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcXG4gICAgXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXFxuICAgIFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDEzXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcXG4gICAgXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXFxuICAgIFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFxcbiAgICBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcXG4gICAgXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDQyXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFxcbiAgICBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcXG4gICAgXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMDBcXDAwMFxcMDQ0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFxcbiAgICBcXDAxN1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcXG4gICAgXFwwMjBcXDAwMFxcMDMwXFwwMDBcXDAyN1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAyNlxcMDAwXFwwMjlcXDAwMFxcMDI5XFwwMDBcXFxuICAgIFxcMDI5XFwwMDBcXDAyOVxcMDAwXFwwMjlcXDAwMFxcMDI5XFwwMDBcXDAyOVxcMDAwXFwwMjlcXDAwMFxcMDI5XFwwMDBcXDAyOVxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcXG4gICAgXFwwMzBcXDAwMFxcMDAwXFwwMDBcXDAyOFxcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXFxuICAgIFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwMDBcXDAwMFxcMDQzXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAyOVxcMDAwXFwwMjlcXDAwMFxcMDI5XFwwMDBcXDAyOVxcMDAwXFwwMjlcXDAwMFxcMDI5XFwwMDBcXDAyOVxcMDAwXFwwMjlcXDAwMFxcXG4gICAgXFwwMjlcXDAwMFxcMDI5XFwwMDBcXDA0OVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDQ4XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcXG4gICAgXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMzJcXDAwMFxcMDU0XFwwMDBcXFxuICAgIFxcMDU0XFwwMDBcXDA1NFxcMDAwXFwwNTRcXDAwMFxcMDU0XFwwMDBcXDA1NFxcMDAwXFwwNTRcXDAwMFxcMDU0XFwwMDBcXDA1NFxcMDAwXFxcbiAgICBcXDA1NFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDA1MFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwNTJcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDA1MVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwNDFcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXCI7XG4gIExleGluZy5sZXhfY2hlY2sgPVxuICAgXCJcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDhcXDAwMFxcMDI2XFwwMDBcXDAwMFxcMDAwXFwwMTBcXDAwMFxcMjU1XFwyNTVcXFxuICAgIFxcMDMwXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMjU1XFwyNTVcXDAxMFxcMDAwXFwwMDBcXDAwMFxcMDMwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA1XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAxNlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAzXFwwMDBcXFxuICAgIFxcMDAzXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA2XFwwMDBcXDAwN1xcMDAwXFwwMTFcXDAwMFxcMDExXFwwMDBcXDAxMVxcMDAwXFxcbiAgICBcXDAxMVxcMDAwXFwwMTFcXDAwMFxcMDExXFwwMDBcXDAxMVxcMDAwXFwwMTFcXDAwMFxcMDExXFwwMDBcXDAxMVxcMDAwXFwwMTJcXDAwMFxcXG4gICAgXFwwMTJcXDAwMFxcMDEyXFwwMDBcXDAxMlxcMDAwXFwwMTJcXDAwMFxcMDEyXFwwMDBcXDAxMlxcMDAwXFwwMTJcXDAwMFxcMDEyXFwwMDBcXFxuICAgIFxcMDEyXFwwMDBcXDAyM1xcMDAwXFwwMzVcXDAwMFxcMDAwXFwwMDBcXDAzNlxcMDAwXFwwMDBcXDAwMFxcMDIxXFwwMDBcXDAyMlxcMDAwXFxcbiAgICBcXDAzMVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwwMzFcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDA1XFwwMDBcXDAzMVxcMDAwXFwyNTVcXDI1NVxcMDEzXFwwMDBcXFxuICAgIFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFxcbiAgICBcXDAxM1xcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMTJcXDAwMFxcXG4gICAgXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXFxuICAgIFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFxcbiAgICBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcXG4gICAgXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMTNcXDAwMFxcMjU1XFwyNTVcXFxuICAgIFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFxcbiAgICBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcXG4gICAgXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXFxuICAgIFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMzlcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFxcbiAgICBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDI1NVxcMjU1XFwwMzlcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMjRcXDAwMFxcMDI0XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDI0XFwwMDBcXDAyOVxcMDAwXFwwMjlcXDAwMFxcXG4gICAgXFwwMjlcXDAwMFxcMDI5XFwwMDBcXDAyOVxcMDAwXFwwMjlcXDAwMFxcMDI5XFwwMDBcXDAyOVxcMDAwXFwwMjlcXDAwMFxcMDI5XFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFxcbiAgICBcXDAyNFxcMDAwXFwyNTVcXDI1NVxcMDI0XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcXG4gICAgXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDI1NVxcMjU1XFwwMzlcXDAwMFxcMjU1XFwyNTVcXFxuICAgIFxcMDI0XFwwMDBcXDAyNFxcMDAwXFwwMjRcXDAwMFxcMDI0XFwwMDBcXDAyNFxcMDAwXFwwMjRcXDAwMFxcMDI0XFwwMDBcXDAyNFxcMDAwXFxcbiAgICBcXDAyNFxcMDAwXFwwMjRcXDAwMFxcMDQ1XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNDVcXDAwMFxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFxcbiAgICBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAzMVxcMDAwXFwwNTNcXDAwMFxcXG4gICAgXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXFxuICAgIFxcMDUzXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDQ1XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA0NVxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDQ1XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAzOVxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwwMjRcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwwNDVcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcIjtcbiAgTGV4aW5nLmxleF9iYXNlX2NvZGUgPVxuICAgXCJcIjtcbiAgTGV4aW5nLmxleF9iYWNrdHJrX2NvZGUgPVxuICAgXCJcIjtcbiAgTGV4aW5nLmxleF9kZWZhdWx0X2NvZGUgPVxuICAgXCJcIjtcbiAgTGV4aW5nLmxleF90cmFuc19jb2RlID1cbiAgIFwiXCI7XG4gIExleGluZy5sZXhfY2hlY2tfY29kZSA9XG4gICBcIlwiO1xuICBMZXhpbmcubGV4X2NvZGUgPVxuICAgXCJcIjtcbn1cblxubGV0IHJlYyB0b2tlbiBsZXhidWYgPVxuICAgX19vY2FtbF9sZXhfdG9rZW5fcmVjIGxleGJ1ZiAwXG5hbmQgX19vY2FtbF9sZXhfdG9rZW5fcmVjIGxleGJ1ZiBfX29jYW1sX2xleF9zdGF0ZSA9XG4gIG1hdGNoIExleGluZy5lbmdpbmUgX19vY2FtbF9sZXhfdGFibGVzIF9fb2NhbWxfbGV4X3N0YXRlIGxleGJ1ZiB3aXRoXG4gICAgICB8IDAgLT5cbiMgMTM1IFwiaHcwMy9sZXhlci5tbGxcIlxuICAgICAgICAoIEVPRiApXG4jIDMxNSBcImh3MDMvbGV4ZXIubWxcIlxuXG4gIHwgMSAtPlxuIyAxMzcgXCJodzAzL2xleGVyLm1sbFwiXG4gICAgICAgICAoIHN0YXJ0X2xleCA6PSBzdGFydF9wb3Nfb2ZfbGV4YnVmIGxleGJ1ZjsgY29tbWVudHMgMCBsZXhidWYgKVxuIyAzMjAgXCJodzAzL2xleGVyLm1sXCJcblxuICB8IDIgLT5cbiMgMTM4IFwiaHcwMy9sZXhlci5tbGxcIlxuICAgICAgICAoIHJlc2V0X3N0cigpOyBzdGFydF9sZXggOj0gc3RhcnRfcG9zX29mX2xleGJ1ZiBsZXhidWY7IHN0cmluZyBmYWxzZSBsZXhidWYgKVxuIyAzMjUgXCJodzAzL2xleGVyLm1sXCJcblxuICB8IDMgLT5cbiMgMTM5IFwiaHcwMy9sZXhlci5tbGxcIlxuICAgICAgICAoIGxldCBwID0gbGV4ZW1lX3N0YXJ0X3AgbGV4YnVmIGluXG4gICAgICAgICAgaWYgcC5wb3NfY251bSAtIHAucG9zX2JvbCA9IDAgdGhlbiBkaXJlY3RpdmUgMCBsZXhidWYgXG4gICAgICAgICAgZWxzZSByYWlzZSAoTGV4ZXJfZXJyb3IgKGxleF9sb25nX3JhbmdlIGxleGJ1ZixcbiAgICAgICAgICAgIFByaW50Zi5zcHJpbnRmIFwiIyBjYW4gb25seSBiZSB0aGUgMXN0IGNoYXIgaW4gYSBsaW5lLlwiKSkgKVxuIyAzMzMgXCJodzAzL2xleGVyLm1sXCJcblxuICB8IDQgLT5cbiMgMTQ0IFwiaHcwMy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIGNyZWF0ZV90b2tlbiBsZXhidWYgKVxuIyAzMzggXCJodzAzL2xleGVyLm1sXCJcblxuICB8IDUgLT5cbiMgMTQ1IFwiaHcwMy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICggSU5UIChJbnQ2NC5vZl9zdHJpbmcgKGxleGVtZSBsZXhidWYpKSApXG4jIDM0MyBcImh3MDMvbGV4ZXIubWxcIlxuXG4gIHwgNiAtPlxuIyAxNDYgXCJodzAzL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICAgKCB0b2tlbiBsZXhidWYgKVxuIyAzNDggXCJodzAzL2xleGVyLm1sXCJcblxuICB8IDcgLT5cbiMgMTQ3IFwiaHcwMy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgKCBuZXdsaW5lIGxleGJ1ZjsgdG9rZW4gbGV4YnVmIClcbiMgMzUzIFwiaHcwMy9sZXhlci5tbFwiXG5cbiAgfCA4IC0+XG4jIDE1MyBcImh3MDMvbGV4ZXIubWxsXCJcbiAgICAoIGNyZWF0ZV90b2tlbiBsZXhidWYgKVxuIyAzNTggXCJodzAzL2xleGVyLm1sXCJcblxuICB8IDkgLT5cbmxldFxuIyAxNTUgXCJodzAzL2xleGVyLm1sbFwiXG4gICAgICAgICBjXG4jIDM2NCBcImh3MDMvbGV4ZXIubWxcIlxuPSBMZXhpbmcuc3ViX2xleGVtZV9jaGFyIGxleGJ1ZiBsZXhidWYuTGV4aW5nLmxleF9zdGFydF9wb3MgaW5cbiMgMTU1IFwiaHcwMy9sZXhlci5tbGxcIlxuICAgICAgICAgICAoIHVuZXhwZWN0ZWRfY2hhciBsZXhidWYgYyApXG4jIDM2OCBcImh3MDMvbGV4ZXIubWxcIlxuXG4gIHwgX19vY2FtbF9sZXhfc3RhdGUgLT4gbGV4YnVmLkxleGluZy5yZWZpbGxfYnVmZiBsZXhidWY7XG4gICAgICBfX29jYW1sX2xleF90b2tlbl9yZWMgbGV4YnVmIF9fb2NhbWxfbGV4X3N0YXRlXG5cbmFuZCBkaXJlY3RpdmUgc3RhdGUgbGV4YnVmID1cbiAgIF9fb2NhbWxfbGV4X2RpcmVjdGl2ZV9yZWMgc3RhdGUgbGV4YnVmIDI0XG5hbmQgX19vY2FtbF9sZXhfZGlyZWN0aXZlX3JlYyBzdGF0ZSBsZXhidWYgX19vY2FtbF9sZXhfc3RhdGUgPVxuICBtYXRjaCBMZXhpbmcuZW5naW5lIF9fb2NhbWxfbGV4X3RhYmxlcyBfX29jYW1sX2xleF9zdGF0ZSBsZXhidWYgd2l0aFxuICAgICAgfCAwIC0+XG4jIDE1OCBcImh3MDMvbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgICAoIGRpcmVjdGl2ZSBzdGF0ZSBsZXhidWYgKVxuIyAzODAgXCJodzAzL2xleGVyLm1sXCJcblxuICB8IDEgLT5cbiMgMTU5IFwiaHcwMy9sZXhlci5tbGxcIlxuICAgICAgICAgICAoIGlmIHN0YXRlID0gMCB0aGVuIFxuICAgICAgICAgICAgICAgKGxudW0gOj0gaW50X29mX3N0cmluZyAobGV4ZW1lIGxleGJ1Zik7IFxuICAgICAgICAgICAgICAgIGRpcmVjdGl2ZSAxIGxleGJ1ZilcbiAgICAgICAgICAgICBlbHNlIGlmIHN0YXRlID0gMiB0aGVuIGRpcmVjdGl2ZSAzIGxleGJ1ZlxuICAgICAgICAgICAgIGVsc2UgcmFpc2UgKExleGVyX2Vycm9yIChsZXhfbG9uZ19yYW5nZSBsZXhidWYsXG4gICAgICAgICAgICAgICBQcmludGYuc3ByaW50ZiBcIklsbGVnYWwgZGlyZWN0aXZlc1wiKSkgKVxuIyAzOTAgXCJodzAzL2xleGVyLm1sXCJcblxuICB8IDIgLT5cbiMgMTY1IFwiaHcwMy9sZXhlci5tbGxcIlxuICAgICAgICAoIGlmIHN0YXRlID0gMSB0aGVuXG4gICAgICAgICAgICBiZWdpblxuICAgICAgICAgICAgICByZXNldF9zdHIoKTsgXG4gICAgICAgICAgICAgIHN0YXJ0X2xleCA6PSBzdGFydF9wb3Nfb2ZfbGV4YnVmIGxleGJ1ZjsgXG4gICAgICAgICAgICAgIHN0cmluZyB0cnVlIGxleGJ1ZlxuICAgICAgICAgICAgZW5kIFxuICAgICAgICAgIGVsc2UgcmFpc2UgKExleGVyX2Vycm9yIChsZXhfbG9uZ19yYW5nZSBsZXhidWYsXG4gICAgICAgICAgICBQcmludGYuc3ByaW50ZiBcIklsbGVnYWwgZGlyZWN0aXZlc1wiKSkgXG4gICAgICAgICApXG4jIDQwMyBcImh3MDMvbGV4ZXIubWxcIlxuXG4gIHwgMyAtPlxuIyAxNzQgXCJodzAzL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAoIGlmIHN0YXRlID0gMiB8fCBzdGF0ZSA9IDMgdGhlblxuICAgICAgICAgICAgICAgIGJlZ2luIFxuICAgICAgICAgICAgICAgICAgcmVzZXRfbGV4YnVmIChnZXRfc3RyKCkpICFsbnVtIGxleGJ1ZjtcbiAgICAgICAgICAgICAgICAgIHRva2VuIGxleGJ1ZlxuICAgICAgICAgICAgICAgIGVuZCBcbiAgICAgICAgICAgICAgZWxzZSByYWlzZSAoTGV4ZXJfZXJyb3IgKGxleF9sb25nX3JhbmdlIGxleGJ1ZixcbiAgICAgICAgICAgICAgICBQcmludGYuc3ByaW50ZiBcIklsbGVnYWwgZGlyZWN0aXZlc1wiKSkgKVxuIyA0MTQgXCJodzAzL2xleGVyLm1sXCJcblxuICB8IDQgLT5cbiMgMTgxIFwiaHcwMy9sZXhlci5tbGxcIlxuICAgICAgKCByYWlzZSAoTGV4ZXJfZXJyb3IgKGxleF9sb25nX3JhbmdlIGxleGJ1ZiwgXG4gICAgICAgICAgUHJpbnRmLnNwcmludGYgXCJJbGxlZ2FsIGRpcmVjdGl2ZXNcIikpIClcbiMgNDIwIFwiaHcwMy9sZXhlci5tbFwiXG5cbiAgfCBfX29jYW1sX2xleF9zdGF0ZSAtPiBsZXhidWYuTGV4aW5nLnJlZmlsbF9idWZmIGxleGJ1ZjtcbiAgICAgIF9fb2NhbWxfbGV4X2RpcmVjdGl2ZV9yZWMgc3RhdGUgbGV4YnVmIF9fb2NhbWxfbGV4X3N0YXRlXG5cbmFuZCBjb21tZW50cyBsZXZlbCBsZXhidWYgPVxuICAgX19vY2FtbF9sZXhfY29tbWVudHNfcmVjIGxldmVsIGxleGJ1ZiAzMVxuYW5kIF9fb2NhbWxfbGV4X2NvbW1lbnRzX3JlYyBsZXZlbCBsZXhidWYgX19vY2FtbF9sZXhfc3RhdGUgPVxuICBtYXRjaCBMZXhpbmcuZW5naW5lIF9fb2NhbWxfbGV4X3RhYmxlcyBfX29jYW1sX2xleF9zdGF0ZSBsZXhidWYgd2l0aFxuICAgICAgfCAwIC0+XG4jIDE4NSBcImh3MDMvbGV4ZXIubWxsXCJcbiAgICAgICAgICggaWYgbGV2ZWwgPSAwIHRoZW4gdG9rZW4gbGV4YnVmXG5cdCAgIGVsc2UgY29tbWVudHMgKGxldmVsLTEpIGxleGJ1ZiApXG4jIDQzMyBcImh3MDMvbGV4ZXIubWxcIlxuXG4gIHwgMSAtPlxuIyAxODcgXCJodzAzL2xleGVyLm1sbFwiXG4gICAgICAgICAoIGNvbW1lbnRzIChsZXZlbCsxKSBsZXhidWYpXG4jIDQzOCBcImh3MDMvbGV4ZXIubWxcIlxuXG4gIHwgMiAtPlxuIyAxODggXCJodzAzL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgKCBjb21tZW50cyBsZXZlbCBsZXhidWYgKVxuIyA0NDMgXCJodzAzL2xleGVyLm1sXCJcblxuICB8IDMgLT5cbiMgMTg5IFwiaHcwMy9sZXhlci5tbGxcIlxuICAgICAgICAgKCBuZXdsaW5lIGxleGJ1ZjsgY29tbWVudHMgbGV2ZWwgbGV4YnVmIClcbiMgNDQ4IFwiaHcwMy9sZXhlci5tbFwiXG5cbiAgfCA0IC0+XG4jIDE5MCBcImh3MDMvbGV4ZXIubWxsXCJcbiAgICAgICAgICggcmFpc2UgKExleGVyX2Vycm9yIChsZXhfbG9uZ19yYW5nZSBsZXhidWYsXG4gICAgICAgICAgICAgUHJpbnRmLnNwcmludGYgXCJjb21tZW50cyBhcmUgbm90IGNsb3NlZFwiKSkgKVxuIyA0NTQgXCJodzAzL2xleGVyLm1sXCJcblxuICB8IF9fb2NhbWxfbGV4X3N0YXRlIC0+IGxleGJ1Zi5MZXhpbmcucmVmaWxsX2J1ZmYgbGV4YnVmO1xuICAgICAgX19vY2FtbF9sZXhfY29tbWVudHNfcmVjIGxldmVsIGxleGJ1ZiBfX29jYW1sX2xleF9zdGF0ZVxuXG5hbmQgc3RyaW5nIGluX2RpcmVjdGl2ZSBsZXhidWYgPVxuICAgX19vY2FtbF9sZXhfc3RyaW5nX3JlYyBpbl9kaXJlY3RpdmUgbGV4YnVmIDM5XG5hbmQgX19vY2FtbF9sZXhfc3RyaW5nX3JlYyBpbl9kaXJlY3RpdmUgbGV4YnVmIF9fb2NhbWxfbGV4X3N0YXRlID1cbiAgbWF0Y2ggTGV4aW5nLmVuZ2luZSBfX29jYW1sX2xleF90YWJsZXMgX19vY2FtbF9sZXhfc3RhdGUgbGV4YnVmIHdpdGhcbiAgICAgIHwgMCAtPlxuIyAxOTQgXCJodzAzL2xleGVyLm1sbFwiXG4gICAgICAgICAoIGlmIGluX2RpcmVjdGl2ZSA9IGZhbHNlIHRoZW5cbiAgICAgICAgICAgICBTVFJJTkcgKGdldF9zdHIoKSlcbiAgICAgICAgICAgZWxzZSBkaXJlY3RpdmUgMiBsZXhidWYgKVxuIyA0NjggXCJodzAzL2xleGVyLm1sXCJcblxuICB8IDEgLT5cbiMgMTk3IFwiaHcwMy9sZXhlci5tbGxcIlxuICAgICAgICAgKCBhZGRfc3RyKGVzY2FwZWQgbGV4YnVmKTsgc3RyaW5nIGluX2RpcmVjdGl2ZSBsZXhidWYgKVxuIyA0NzMgXCJodzAzL2xleGVyLm1sXCJcblxuICB8IDIgLT5cbiMgMTk4IFwiaHcwMy9sZXhlci5tbGxcIlxuICAgICAgICAgKCBhZGRfc3RyICdcXG4nOyBuZXdsaW5lIGxleGJ1Zjsgc3RyaW5nIGluX2RpcmVjdGl2ZSBsZXhidWYgKVxuIyA0NzggXCJodzAzL2xleGVyLm1sXCJcblxuICB8IDMgLT5cbiMgMTk5IFwiaHcwMy9sZXhlci5tbGxcIlxuICAgICAgICAgKCByYWlzZSAoTGV4ZXJfZXJyb3IgKGxleF9sb25nX3JhbmdlIGxleGJ1ZixcbiAgICAgICAgICAgICBQcmludGYuc3ByaW50ZiBcIlN0cmluZyBpcyBub3QgdGVybWluYXRlZFwiKSkgKVxuIyA0ODQgXCJodzAzL2xleGVyLm1sXCJcblxuICB8IDQgLT5cbiMgMjAxIFwiaHcwMy9sZXhlci5tbGxcIlxuICAgICAgICAgKCBhZGRfc3RyIChMZXhpbmcubGV4ZW1lX2NoYXIgbGV4YnVmIDApOyBzdHJpbmcgaW5fZGlyZWN0aXZlIGxleGJ1ZiApXG4jIDQ4OSBcImh3MDMvbGV4ZXIubWxcIlxuXG4gIHwgX19vY2FtbF9sZXhfc3RhdGUgLT4gbGV4YnVmLkxleGluZy5yZWZpbGxfYnVmZiBsZXhidWY7XG4gICAgICBfX29jYW1sX2xleF9zdHJpbmdfcmVjIGluX2RpcmVjdGl2ZSBsZXhidWYgX19vY2FtbF9sZXhfc3RhdGVcblxuYW5kIGVzY2FwZWQgbGV4YnVmID1cbiAgIF9fb2NhbWxfbGV4X2VzY2FwZWRfcmVjIGxleGJ1ZiA0NVxuYW5kIF9fb2NhbWxfbGV4X2VzY2FwZWRfcmVjIGxleGJ1ZiBfX29jYW1sX2xleF9zdGF0ZSA9XG4gIG1hdGNoIExleGluZy5lbmdpbmUgX19vY2FtbF9sZXhfdGFibGVzIF9fb2NhbWxfbGV4X3N0YXRlIGxleGJ1ZiB3aXRoXG4gICAgICB8IDAgLT5cbiMgMjA0IFwiaHcwMy9sZXhlci5tbGxcIlxuICAgICAgICAgICAoICdcXG4nIClcbiMgNTAxIFwiaHcwMy9sZXhlci5tbFwiXG5cbiAgfCAxIC0+XG4jIDIwNSBcImh3MDMvbGV4ZXIubWxsXCJcbiAgICAgICAgICAgKCAnXFx0JyApXG4jIDUwNiBcImh3MDMvbGV4ZXIubWxcIlxuXG4gIHwgMiAtPlxuIyAyMDYgXCJodzAzL2xleGVyLm1sbFwiXG4gICAgICAgICAgICggJ1xcXFwnIClcbiMgNTExIFwiaHcwMy9sZXhlci5tbFwiXG5cbiAgfCAzIC0+XG4jIDIwNyBcImh3MDMvbGV4ZXIubWxsXCJcbiAgICAgICAgICAgKCAnXFwwMzQnICApXG4jIDUxNiBcImh3MDMvbGV4ZXIubWxcIlxuXG4gIHwgNCAtPlxuIyAyMDggXCJodzAzL2xleGVyLm1sbFwiXG4gICAgICAgICAgICggJ1xcJycgKVxuIyA1MjEgXCJodzAzL2xleGVyLm1sXCJcblxuICB8IDUgLT5cbiMgMjEwIFwiaHcwMy9sZXhlci5tbGxcIlxuICAgIChcbiAgICAgIGxldCB4ID0gaW50X29mX3N0cmluZyhsZXhlbWUgbGV4YnVmKSBpblxuICAgICAgaWYgeCA+IDI1NSB0aGVuXG4gICAgICAgIHJhaXNlIChMZXhlcl9lcnJvciAobGV4X2xvbmdfcmFuZ2UgbGV4YnVmLFxuICAgICAgICAgIChQcmludGYuc3ByaW50ZiBcIiVzIGlzIGFuIGlsbGVnYWwgZXNjYXBlZCBjaGFyYWN0ZXIgY29uc3RhbnRcIiAobGV4ZW1lIGxleGJ1ZikpKSlcbiAgICAgIGVsc2VcbiAgICAgICAgQ2hhci5jaHIgeFxuICAgIClcbiMgNTMzIFwiaHcwMy9sZXhlci5tbFwiXG5cbiAgfCA2IC0+XG4jIDIxOSBcImh3MDMvbGV4ZXIubWxsXCJcbiAgICAoIHJhaXNlIChMZXhlcl9lcnJvciAobGV4X2xvbmdfcmFuZ2UgbGV4YnVmLFxuICAgICAgICAoUHJpbnRmLnNwcmludGYgXCIlcyBpcyBhbiBpbGxlZ2FsIGVzY2FwZWQgY2hhcmFjdGVyIGNvbnN0YW50XCIgKGxleGVtZSBsZXhidWYpICkpKSApXG4jIDUzOSBcImh3MDMvbGV4ZXIubWxcIlxuXG4gIHwgX19vY2FtbF9sZXhfc3RhdGUgLT4gbGV4YnVmLkxleGluZy5yZWZpbGxfYnVmZiBsZXhidWY7XG4gICAgICBfX29jYW1sX2xleF9lc2NhcGVkX3JlYyBsZXhidWYgX19vY2FtbF9sZXhfc3RhdGVcblxuOztcblxuIiwibW9kdWxlIEkgPVxuICBQYXJzZXIuTWVuaGlySW50ZXJwcmV0ZXJcblxubGV0IHN1Y2NlZWQgKF8gOiBBc3QucHJvZykgPSBbXVxuXG4oKiBDb25zdW1lIHVudGlsIGVpdGhlciBzZW1pY29sb24gb3Igb3BlbiBicmFjZVxuICBJZiBvcGVuIGJyYWNlLCBjb25zdW1lIHVudGlsIGl0IGlzIG1hdGNoZWQgKilcbmxldCByZWMgcmVjb3Zlcl9mcm9tX2Vycm9yIChzdXBwbGllcjpJLnN1cHBsaWVyKSA6IHVuaXQgPVxuICBcbiAgbGV0IHJlYyBjb25zdW1lX2Jsb2NrIHN1cHBsaWVyIGRlcHRoIDogdW5pdCA9XG4gICAgaWYgZGVwdGggPSAwIHRoZW4gKCkgZWxzZVxuICAgIG1hdGNoIHN1cHBsaWVyICgpIHdpdGhcbiAgICB8IChQYXJzZXIuTEJSQUNFLF8sXykgLT4gY29uc3VtZV9ibG9jayBzdXBwbGllciAoZGVwdGggKyAxKVxuICAgIHwgKFBhcnNlci5SQlJBQ0UsXyxfKSAtPiBjb25zdW1lX2Jsb2NrIHN1cHBsaWVyIChkZXB0aCAtIDEpXG4gICAgfCAoXyxzdGFydCxzdG9wKSB3aGVuIHN0YXJ0ID0gc3RvcCAtPiAoKSAoKiB0ZXJtaW5hdGUgYXQgRU9GICopXG4gICAgfCBfIC0+IGNvbnN1bWVfYmxvY2sgc3VwcGxpZXIgZGVwdGhcbiAgaW5cblxuXG4gIG1hdGNoIHN1cHBsaWVyICgpIHdpdGhcbiAgfCAoUGFyc2VyLlNFTUksXyxfKSAtPiAoKVxuICB8IChQYXJzZXIuTEJSQUNFLF8sXykgLT4gY29uc3VtZV9ibG9jayBzdXBwbGllciAxXG4gIHwgKF8sc3RhcnQsc3RvcCkgd2hlbiBzdGFydCA9IHN0b3AgLT4gKCkgKCogdGVybWluYXRlIGF0IEVPRiAqKVxuICB8IF8gLT4gXG4gIHJlY292ZXJfZnJvbV9lcnJvciBzdXBwbGllclxuXG4oKiBUaGUgcGFyc2VyIGhhcyBzdXNwZW5kZWQgaXRzZWxmIGJlY2F1c2Ugb2YgYSBzeW50YXggZXJyb3IuXG4gIENvbnN1bWUgdG8gbmV4dCBlbmQgb2Ygc3RhdGVtZW50IGFuZCBjb250aW51ZSAqKVxubGV0IHJlYyBmYWlsIGxleGJ1ZiAoYmFja2VkX3VwIDogQXN0LnByb2cgSS5jaGVja3BvaW50KSAoIF8gOiBBc3QucHJvZyBJLmNoZWNrcG9pbnQpID1cbiAgbGV0IF8sYSxiID0gUmFuZ2UubGV4X3JhbmdlIGxleGJ1ZiBpblxuICBsZXQgc3VwcGxpZXIgPSBJLmxleGVyX2xleGJ1Zl90b19zdXBwbGllciBMZXhlci50b2tlbiBsZXhidWYgaW5cbiAgcmVjb3Zlcl9mcm9tX2Vycm9yIHN1cHBsaWVyO1xuICAoYSwgYikgOjpcbiAgSS5sb29wX2hhbmRsZV91bmRvIHN1Y2NlZWQgKGZhaWwgbGV4YnVmKSBzdXBwbGllciBiYWNrZWRfdXBcblxuXG5cbmxldCBmaW5kX2Vycm9ycyAoY29udGVudHMgOiBzdHJpbmcpIDogKFJhbmdlLnBvcyAqIFJhbmdlLnBvcykgbGlzdCA9XG4gIGxldCBsZXhidWYgPSBjb250ZW50cyB8PiBMZXhpbmcuZnJvbV9zdHJpbmcgaW5cbiAgbGV0IHJlc3VsdCA9IFBhcnNlci5JbmNyZW1lbnRhbC5wcm9nIGxleGJ1Zi5sZXhfY3Vycl9wIGluXG4gIGxldCBzdXBwbGllciA9IEkubGV4ZXJfbGV4YnVmX3RvX3N1cHBsaWVyIExleGVyLnRva2VuIGxleGJ1ZiBpblxuICBJLmxvb3BfaGFuZGxlX3VuZG8gc3VjY2VlZCAoZmFpbCBsZXhidWYpIHN1cHBsaWVyIHJlc3VsdFxuXG5cblxuKCpmcm9tIE9jYW1sIDQuMDgqKVxubGV0IHJlYyBmaWx0ZXJfbWFwIChsIDogJ2Egb3B0aW9uIGxpc3QpIDogJ2EgbGlzdCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IE5vbmU6OnRsIC0+IGZpbHRlcl9tYXAgdGxcbiAgfCBTb21lIHg6OnRsIC0+IHggOjogZmlsdGVyX21hcCB0bFxuICB8IFtdIC0+IFtdXG5cbmxldCBwcmludF9lcnJvciAobG9jIDogUmFuZ2UudCkgPVxuICBQcmludGYucHJpbnRmIFwiUGFyc2UgZXJyb3IgYXQ6ICVzXFxuXCIgKFJhbmdlLnN0cmluZ19vZl9yYW5nZSBsb2MpIFxuXG5vcGVuIEpzX29mX29jYW1sXG5sZXQganNfb2ZfcmFuZ2UgKGxvYyA6IFJhbmdlLnBvcyAqIFJhbmdlLnBvcykgPVxuICBsZXQganNfb2ZfcG9zIChwb3MgOiBSYW5nZS5wb3MpID1cbiAgICBsZXQgbGluZSxjaGFyID0gcG9zIGluXG4gICAgKG9iamVjdCVqc1xuICAgICAgdmFsIGxpbmUgPSBsaW5lXG4gICAgICB2YWwgY2hhciA9IGNoYXJcbiAgICBlbmQpXG4gIGluXG4gIGxldCBzdGFydCwgZmluaXNoID0gbG9jIGluXG4gIChvYmplY3QlanNcbiAgICB2YWwgc3RhcnQgPSBqc19vZl9wb3Mgc3RhcnRcbiAgICB2YWwgZmluaXNoID0ganNfb2ZfcG9zIGZpbmlzaFxuICBlbmQpXG5cbmxldCBtYWluIGZpbGVzID1cbiAgZmlsZXNcbiAgfD4gSnMudG9fYXJyYXkgfD4gQXJyYXkudG9fbGlzdFxuICB8PiBMaXN0Lm1hcCBKcy50b19zdHJpbmdcbiAgfD4gTGlzdC5tYXAgZmluZF9lcnJvcnNcbiAgfD4gTGlzdC5mbGF0dGVuXG4gIHw+IExpc3QubWFwIGpzX29mX3JhbmdlXG4gIHw+IEFycmF5Lm9mX2xpc3QgfD4gSnMuYXJyYXlcblxubGV0IF8gPVxuICBKcy5leHBvcnRfYWxsXG4gICAgKG9iamVjdCVqc1xuICAgICAgbWV0aG9kIGNvbXBpbGUgZmlsZXMgPSBtYWluIGZpbGVzXG4gICAgZW5kKSJdfQ==