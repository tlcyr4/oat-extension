//# 1 "server.bc.runtime.js"
// Generated by js_of_ocaml 3.5.2
(function(joo_global_object)
   {"use strict";
    function caml_int64_is_zero(x){return (x[3] | x[2] | x[1]) == 0}
    function caml_str_repeat(n,s)
     {if(n == 0)return "";
      if(s.repeat)return s.repeat(n);
      var r="",l=0;
      if(n == 0)return r;
      for(;;)
       {if(n & 1)r += s;
        n >>= 1;
        if(n == 0)return r;
        s += s;
        l++;
        if(l == 9)s.slice(0,1)}}
    function caml_int64_of_int32(x)
     {return [255,x & 0xffffff,x >> 24 & 0xffffff,x >> 31 & 0xffff]}
    function caml_obj_dup(x)
     {var l=x.length,a=new Array(l);
      for(var i=0;i < l;i++)a[i] = x[i];
      return a}
    function caml_int64_sub(x,y)
     {var
       z1=x[1] - y[1],
       z2=x[2] - y[2] + (z1 >> 24),
       z3=x[3] - y[3] + (z2 >> 24);
      return [255,z1 & 0xffffff,z2 & 0xffffff,z3 & 0xffff]}
    function caml_int64_ucompare(x,y)
     {if(x[3] > y[3])return 1;
      if(x[3] < y[3])return - 1;
      if(x[2] > y[2])return 1;
      if(x[2] < y[2])return - 1;
      if(x[1] > y[1])return 1;
      if(x[1] < y[1])return - 1;
      return 0}
    function caml_int64_lsl1(x)
     {x[3] = x[3] << 1 | x[2] >> 23;
      x[2] = (x[2] << 1 | x[1] >> 23) & 0xffffff;
      x[1] = x[1] << 1 & 0xffffff}
    function caml_int64_lsr1(x)
     {x[1] = (x[1] >>> 1 | x[2] << 23) & 0xffffff;
      x[2] = (x[2] >>> 1 | x[3] << 23) & 0xffffff;
      x[3] = x[3] >>> 1}
    function caml_int64_udivmod(x,y)
     {var
       offset=0,
       modulus=caml_obj_dup(x),
       divisor=caml_obj_dup(y),
       quotient=[255,0,0,0];
      while(caml_int64_ucompare(modulus,divisor) > 0)
       {offset++;caml_int64_lsl1(divisor)}
      while(offset >= 0)
       {offset--;
        caml_int64_lsl1(quotient);
        if(caml_int64_ucompare(modulus,divisor) >= 0)
         {quotient[1]++;modulus = caml_int64_sub(modulus,divisor)}
        caml_int64_lsr1(divisor)}
      return [0,quotient,modulus]}
    function caml_int64_to_int32(x){return x[1] | x[2] << 24}
    function caml_int64_is_negative(x){return x[3] << 16 < 0}
    function caml_int64_neg(x)
     {var y1=- x[1],y2=- x[2] + (y1 >> 24),y3=- x[3] + (y2 >> 24);
      return [255,y1 & 0xffffff,y2 & 0xffffff,y3 & 0xffff]}
    function raw_array_sub(a,i,l)
     {var b=new Array(l);for(var j=0;j < l;j++)b[j] = a[i + j];return b}
    function caml_subarray_to_string(a,i,len)
     {var f=String.fromCharCode;
      if(i == 0 && len <= 4096 && len == a.length)return f.apply(null,a);
      var s="";
      for(;0 < len;i += 1024,len -= 1024)
       s += f.apply(null,raw_array_sub(a,i,Math.min(len,1024)));
      return s}
    function caml_convert_string_to_bytes(s)
     {if(s.t == 2)
       s.c += caml_str_repeat(s.l - s.c.length,"\0");
      else
       s.c = caml_subarray_to_string(s.c,0,s.c.length);
      s.t = 0}
    function caml_jsbytes_of_string(s)
     {if((s.t & 6) != 0)caml_convert_string_to_bytes(s);return s.c}
    function caml_raise_with_arg(tag,arg){throw [0,tag,arg]}
    function caml_is_ascii(s)
     {if(s.length < 24)
       {for(var i=0;i < s.length;i++)if(s.charCodeAt(i) > 127)return false;
        return true}
      else
       return ! /[^\x00-\x7f]/.test(s)}
    function caml_utf16_of_utf8(s)
     {for(var b="",t="",c,c1,c2,v,i=0,l=s.length;i < l;i++)
       {c1 = s.charCodeAt(i);
        if(c1 < 0x80)
         {for(var j=i + 1;j < l && (c1 = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        v = 1;
        if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
         {c = c2 + (c1 << 6);
          if(c1 < 0xe0)
           {v = c - 0x3080;if(v < 0x80)v = 1}
          else
           {v = 2;
            if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
             {c = c2 + (c << 6);
              if(c1 < 0xf0)
               {v = c - 0xe2080;
                if(v < 0x800 || v >= 0xd7ff && v < 0xe000)v = 2}
              else
               {v = 3;
                if
                 (++i
                  <
                  l
                  &&
                  ((c2 = s.charCodeAt(i)) & - 64)
                  ==
                  128
                  &&
                  c1
                  <
                  0xf5)
                 {v = c2 - 0x3c82080 + (c << 6);
                  if(v < 0x10000 || v > 0x10ffff)v = 3}}}}}
        if(v < 4)
         {i -= v;t += "\ufffd"}
        else
         if(v > 0xffff)
          t += String.fromCharCode(0xd7c0 + (v >> 10),0xdc00 + (v & 0x3FF));
         else
          t += String.fromCharCode(v);
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function caml_to_js_string(s)
     {switch(s.t)
       {case 9:return s.c;
        default:caml_convert_string_to_bytes(s);case 0:
         if(caml_is_ascii(s.c)){s.t = 9;return s.c}s.t = 8;
        case 8:return caml_utf16_of_utf8(s.c)
        }}
    function MlBytes(tag,contents,length)
     {this.t = tag;this.c = contents;this.l = length}
    MlBytes.prototype.toString = function(){return caml_to_js_string(this)};
    MlBytes.prototype.slice
    =
    function()
     {var content=this.t == 4?this.c.slice():this.c;
      return new MlBytes(this.t,content,this.l)};
    function caml_new_string(s){return new MlBytes(0,s,s.length)}
    function caml_raise_with_string(tag,msg)
     {caml_raise_with_arg(tag,caml_new_string(msg))}
    var caml_global_data=[0];
    function caml_invalid_argument(msg)
     {caml_raise_with_string(caml_global_data.Invalid_argument,msg)}
    function caml_parse_format(fmt)
     {fmt = caml_jsbytes_of_string(fmt);
      var len=fmt.length;
      if(len > 31)caml_invalid_argument("format_int: format too long");
      var
       f=
        {justify:"+",
         signstyle:"-",
         filler:" ",
         alternate:false,
         base:0,
         signedconv:false,
         width:0,
         uppercase:false,
         sign:1,
         prec:- 1,
         conv:"f"};
      for(var i=0;i < len;i++)
       {var c=fmt.charAt(i);
        switch(c)
         {case "-":f.justify = "-";break;
          case "+":
          case " ":f.signstyle = c;break;
          case "0":f.filler = "0";break;
          case "#":f.alternate = true;break;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
           f.width = 0;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.width = f.width * 10 + c;i++}
           i--;
           break;
          case ".":
           f.prec = 0;
           i++;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.prec = f.prec * 10 + c;i++}
           i--;
          case "d":
          case "i":f.signedconv = true;
          case "u":f.base = 10;break;
          case "x":f.base = 16;break;
          case "X":f.base = 16;f.uppercase = true;break;
          case "o":f.base = 8;break;
          case "e":
          case "f":
          case "g":f.signedconv = true;f.conv = c;break;
          case "E":
          case "F":
          case "G":
           f.signedconv = true;
           f.uppercase = true;
           f.conv = c.toLowerCase();
           break
          }}
      return f}
    function caml_finish_formatting(f,rawbuffer)
     {if(f.uppercase)rawbuffer = rawbuffer.toUpperCase();
      var len=rawbuffer.length;
      if(f.signedconv && (f.sign < 0 || f.signstyle != "-"))len++;
      if(f.alternate){if(f.base == 8)len += 1;if(f.base == 16)len += 2}
      var buffer="";
      if(f.justify == "+" && f.filler == " ")
       for(var i=len;i < f.width;i++)buffer += " ";
      if(f.signedconv)
       if(f.sign < 0)
        buffer += "-";
       else
        if(f.signstyle != "-")buffer += f.signstyle;
      if(f.alternate && f.base == 8)buffer += "0";
      if(f.alternate && f.base == 16)buffer += "0x";
      if(f.justify == "+" && f.filler == "0")
       for(var i=len;i < f.width;i++)buffer += "0";
      buffer += rawbuffer;
      if(f.justify == "-")for(var i=len;i < f.width;i++)buffer += " ";
      return caml_new_string(buffer)}
    function caml_int64_format(fmt,x)
     {var f=caml_parse_format(fmt);
      if(f.signedconv && caml_int64_is_negative(x))
       {f.sign = - 1;x = caml_int64_neg(x)}
      var
       buffer="",
       wbase=caml_int64_of_int32(f.base),
       cvtbl="0123456789abcdef";
      do
       {var p=caml_int64_udivmod(x,wbase);
        x = p[1];
        buffer = cvtbl.charAt(caml_int64_to_int32(p[2])) + buffer}
      while
       (! caml_int64_is_zero(x));
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - buffer.length;
        if(n > 0)buffer = caml_str_repeat(n,"0") + buffer}
      return caml_finish_formatting(f,buffer)}
    function caml_expm1_float(x)
     {var y=Math.exp(x),z=y - 1;
      return Math.abs(x) > 1?z:z == 0?x:x * z / Math.log(y)}
    if(joo_global_object.process && joo_global_object.process.cwd)
     var caml_current_dir=joo_global_object.process.cwd().replace(/\\/g,"/");
    else
     var caml_current_dir="/static";
    if(caml_current_dir.slice(- 1) !== "/")caml_current_dir += "/";
    function caml_make_path(name)
     {name = name instanceof MlBytes?name.toString():name;
      if(name.charCodeAt(0) != 47)name = caml_current_dir + name;
      var comp=name.split("/"),ncomp=[];
      for(var i=0;i < comp.length;i++)
       switch(comp[i])
        {case "..":if(ncomp.length > 1)ncomp.pop();break;
         case ".":break;
         case "":if(ncomp.length == 0)ncomp.push("");break;
         default:ncomp.push(comp[i]);break}
      ncomp.orig = name;
      return ncomp}
    function caml_raise_sys_error(msg)
     {caml_raise_with_string(caml_global_data.Sys_error,msg)}
    function caml_raise_no_such_file(name)
     {name = name instanceof MlBytes?name.toString():name;
      caml_raise_sys_error(name + ": No such file or directory")}
    function caml_string_of_array(a){return new MlBytes(4,a,a.length)}
    function caml_string_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_bytes_unsafe_get(s,i)
     {switch(s.t & 6)
       {default:if(i >= s.c.length)return 0;case 0:return s.c.charCodeAt(i);
        case 4:return s.c[i]
        }}
    function caml_bytes_get(s,i)
     {if(i >>> 0 >= s.l)caml_string_bound_error();
      return caml_bytes_unsafe_get(s,i)}
    function caml_create_bytes(len)
     {if(len < 0)caml_invalid_argument("Bytes.create");
      return new MlBytes(len?2:9,"",len)}
    function caml_ml_bytes_length(s){return s.l}
    function caml_convert_string_to_array(s)
     {if(joo_global_object.Uint8Array)
       var a=new (joo_global_object.Uint8Array)(s.l);
      else
       var a=new Array(s.l);
      var b=s.c,l=b.length,i=0;
      for(;i < l;i++)a[i] = b.charCodeAt(i);
      for(l = s.l;i < l;i++)a[i] = 0;
      s.c = a;
      s.t = 4;
      return a}
    function caml_blit_bytes(s1,i1,s2,i2,len)
     {if(len == 0)return 0;
      if(i2 == 0 && (len >= s2.l || s2.t == 2 && len >= s2.c.length))
       {s2.c
        =
        s1.t == 4
         ?caml_subarray_to_string(s1.c,i1,len)
         :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
        s2.t = s2.c.length == s2.l?0:2}
      else
       if(s2.t == 2 && i2 == s2.c.length)
        {s2.c
         +=
         s1.t == 4
          ?caml_subarray_to_string(s1.c,i1,len)
          :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
         s2.t = s2.c.length == s2.l?0:2}
       else
        {if(s2.t != 4)caml_convert_string_to_array(s2);
         var c1=s1.c,c2=s2.c;
         if(s1.t == 4)
          if(i2 <= i1)
           for(var i=0;i < len;i++)c2[i2 + i] = c1[i1 + i];
          else
           for(var i=len - 1;i >= 0;i--)c2[i2 + i] = c1[i1 + i];
         else
          {var l=Math.min(len,c1.length - i1);
           for(var i=0;i < l;i++)c2[i2 + i] = c1.charCodeAt(i1 + i);
           for(;i < len;i++)c2[i2 + i] = 0}}
      return 0}
    function MlFile(){}
    function MlFakeFile(content){this.data = content}
    MlFakeFile.prototype = new MlFile();
    MlFakeFile.prototype.truncate
    =
    function(len)
     {var old=this.data;
      this.data = caml_create_bytes(len | 0);
      caml_blit_bytes(old,0,this.data,0,len)};
    MlFakeFile.prototype.length
    =
    function(){return caml_ml_bytes_length(this.data)};
    MlFakeFile.prototype.write
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      if(offset + len >= clen)
       {var new_str=caml_create_bytes(offset + len),old_data=this.data;
        this.data = new_str;
        caml_blit_bytes(old_data,0,this.data,0,clen)}
      caml_blit_bytes(buf,pos,this.data,offset,len);
      return 0};
    MlFakeFile.prototype.read
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      caml_blit_bytes(this.data,offset,buf,pos,len);
      return 0};
    MlFakeFile.prototype.read_one
    =
    function(offset){return caml_bytes_get(this.data,offset)};
    MlFakeFile.prototype.close = function(){};
    MlFakeFile.prototype.constructor = MlFakeFile;
    function MlFakeDevice(root,f)
     {this.content = {};this.root = root;this.lookupFun = f}
    MlFakeDevice.prototype.nm = function(name){return this.root + name};
    MlFakeDevice.prototype.lookup
    =
    function(name)
     {if(! this.content[name] && this.lookupFun)
       {var
         res=
          this.lookupFun(caml_new_string(this.root),caml_new_string(name));
        if(res !== 0)this.content[name] = new MlFakeFile(res[1])}};
    MlFakeDevice.prototype.exists
    =
    function(name)
     {if(name == "")return 1;
      var name_slash=name + "/",r=new RegExp("^" + name_slash);
      for(var n in this.content)if(n.match(r))return 1;
      this.lookup(name);
      return this.content[name]?1:0};
    MlFakeDevice.prototype.readdir
    =
    function(name)
     {var
       name_slash=name == ""?"":name + "/",
       r=new RegExp("^" + name_slash + "([^/]*)"),
       seen={},
       a=[];
      for(var n in this.content)
       {var m=n.match(r);
        if(m && ! seen[m[1]]){seen[m[1]] = true;a.push(m[1])}}
      return a};
    MlFakeDevice.prototype.is_dir
    =
    function(name)
     {var
       name_slash=name == ""?"":name + "/",
       r=new RegExp("^" + name_slash + "([^/]*)"),
       a=[];
      for(var n in this.content){var m=n.match(r);if(m)return 1}
      return 0};
    MlFakeDevice.prototype.unlink
    =
    function(name)
     {var ok=this.content[name]?true:false;
      delete this.content[name];
      return ok};
    MlFakeDevice.prototype.open
    =
    function(name,f)
     {if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      this.lookup(name);
      if(this.content[name])
       {if(this.is_dir(name))
         caml_raise_sys_error(this.nm(name) + " : is a directory");
        if(f.create && f.excl)
         caml_raise_sys_error(this.nm(name) + " : file already exists");
        var file=this.content[name];
        if(f.truncate)file.truncate();
        return file}
      else
       if(f.create)
        {this.content[name] = new MlFakeFile(caml_create_bytes(0));
         return this.content[name]}
       else
        caml_raise_no_such_file(this.nm(name))};
    MlFakeDevice.prototype.register
    =
    function(name,content)
     {if(this.content[name])
       caml_raise_sys_error(this.nm(name) + " : file already exists");
      if(content instanceof MlBytes)
       this.content[name] = new MlFakeFile(content);
      else
       if(content instanceof Array)
        this.content[name] = new MlFakeFile(caml_string_of_array(content));
       else
        if(content.toString)
         {var mlstring=caml_new_string(content.toString());
          this.content[name] = new MlFakeFile(mlstring)}};
    MlFakeDevice.prototype.constructor = MlFakeDevice;
    function caml_array_of_string(s)
     {if(s.t != 4)caml_convert_string_to_array(s);return s.c}
    function caml_bytes_unsafe_set(s,i,c)
     {c &= 0xff;
      if(s.t != 4)
       {if(i == s.c.length)
         {s.c += String.fromCharCode(c);if(i + 1 == s.l)s.t = 0;return 0}
        caml_convert_string_to_array(s)}
      s.c[i] = c;
      return 0}
    function caml_bytes_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_string_bound_error();
      return caml_bytes_unsafe_set(s,i,c)}
    var Buffer=joo_global_object.Buffer;
    function MlNodeFile(fd){this.fs = require("fs");this.fd = fd}
    MlNodeFile.prototype = new MlFile();
    MlNodeFile.prototype.truncate
    =
    function(len){this.fs.ftruncateSync(this.fd,len | 0)};
    MlNodeFile.prototype.length
    =
    function(){return this.fs.fstatSync(this.fd).size};
    MlNodeFile.prototype.write
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_string(buf);
      if(! (a instanceof joo_global_object.Uint8Array))
       a = new (joo_global_object.Uint8Array)(a);
      var buffer=Buffer.from(a);
      this.fs.writeSync(this.fd,buffer,buf_offset,len,offset);
      return 0};
    MlNodeFile.prototype.read
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_string(buf);
      if(! (a instanceof joo_global_object.Uint8Array))
       a = new (joo_global_object.Uint8Array)(a);
      var buffer=Buffer.from(a);
      this.fs.readSync(this.fd,buffer,buf_offset,len,offset);
      for(var i=0;i < len;i++)
       caml_bytes_set(buf,buf_offset + i,buffer[buf_offset + i]);
      return 0};
    MlNodeFile.prototype.read_one
    =
    function(offset)
     {var a=new (joo_global_object.Uint8Array)(1),buffer=Buffer.from(a);
      this.fs.readSync(this.fd,buffer,0,1,offset);
      return buffer[0]};
    MlNodeFile.prototype.close = function(){this.fs.closeSync(this.fd)};
    MlNodeFile.prototype.constructor = MlNodeFile;
    function MlNodeDevice(root){this.fs = require("fs");this.root = root}
    MlNodeDevice.prototype.nm = function(name){return this.root + name};
    MlNodeDevice.prototype.exists
    =
    function(name){return this.fs.existsSync(this.nm(name))?1:0};
    MlNodeDevice.prototype.readdir
    =
    function(name){return this.fs.readdirSync(this.nm(name))};
    MlNodeDevice.prototype.is_dir
    =
    function(name){return this.fs.statSync(this.nm(name)).isDirectory()?1:0};
    MlNodeDevice.prototype.unlink
    =
    function(name)
     {var b=this.fs.existsSync(this.nm(name))?1:0;
      this.fs.unlinkSync(this.nm(name));
      return b};
    MlNodeDevice.prototype.open
    =
    function(name,f)
     {var consts=require("constants"),res=0;
      for(var key in f)
       switch(key)
        {case "rdonly":res |= consts.O_RDONLY;break;
         case "wronly":res |= consts.O_WRONLY;break;
         case "append":res |= consts.O_WRONLY | consts.O_APPEND;break;
         case "create":res |= consts.O_CREAT;break;
         case "truncate":res |= consts.O_TRUNC;break;
         case "excl":res |= consts.O_EXCL;break;
         case "binary":res |= consts.O_BINARY;break;
         case "text":res |= consts.O_TEXT;break;
         case "nonblock":res |= consts.O_NONBLOCK;break
         }
      var fd=this.fs.openSync(this.nm(name),res);
      return new MlNodeFile(fd)};
    MlNodeDevice.prototype.rename
    =
    function(o,n){this.fs.renameSync(this.nm(o),this.nm(n))};
    MlNodeDevice.prototype.constructor = MlNodeDevice;
    var caml_root=caml_current_dir.match(/[^\/]*\//)[0];
    function fs_node_supported()
     {return typeof joo_global_object.process
             !==
             "undefined"
             &&
             typeof joo_global_object.process.versions
             !==
             "undefined"
             &&
             typeof joo_global_object.process.versions.node
             !==
             "undefined"
             &&
             joo_global_object.process.platform
             !==
             "browser"}
    var jsoo_mount_point=[];
    if(fs_node_supported())
     jsoo_mount_point.push
      ({path:caml_root,device:new MlNodeDevice(caml_root)});
    else
     jsoo_mount_point.push
      ({path:caml_root,device:new MlFakeDevice(caml_root)});
    jsoo_mount_point.push
     ({path:caml_root + "static/",
       device:new MlFakeDevice(caml_root + "static/")});
    function resolve_fs_device(name)
     {var
       path=caml_make_path(name),
       name=path.join("/"),
       name_slash=name + "/",
       res;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var m=jsoo_mount_point[i];
        if
         (name_slash.search(m.path)
          ==
          0
          &&
          (! res || res.path.length < m.path.length))
         res
         =
         {path:m.path,
          device:m.device,
          rest:name.substring(m.path.length,name.length)}}
      return res}
    function caml_sys_is_directory(name)
     {var root=resolve_fs_device(name),a=root.device.is_dir(root.rest);
      return a?1:0}
    function caml_string_unsafe_get(s,i)
     {switch(s.t & 6)
       {default:if(i >= s.c.length)return 0;case 0:return s.c.charCodeAt(i);
        case 4:return s.c[i]
        }}
    function caml_utf8_of_utf16(s)
     {for(var b="",t=b,c,d,i=0,l=s.length;i < l;i++)
       {c = s.charCodeAt(i);
        if(c < 0x80)
         {for(var j=i + 1;j < l && (c = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        if(c < 0x800)
         {t += String.fromCharCode(0xc0 | c >> 6);
          t += String.fromCharCode(0x80 | c & 0x3f)}
        else
         if(c < 0xd800 || c >= 0xdfff)
          t
          +=
          String.fromCharCode
           (0xe0 | c >> 12,0x80 | c >> 6 & 0x3f,0x80 | c & 0x3f);
         else
          if
           (c
            >=
            0xdbff
            ||
            i
            +
            1
            ==
            l
            ||
            (d = s.charCodeAt(i + 1))
            <
            0xdc00
            ||
            d
            >
            0xdfff)
           t += "\xef\xbf\xbd";
          else
           {i++;
            c = (c << 10) + d - 0x35fdc00;
            t
            +=
            String.fromCharCode
             (0xf0 | c >> 18,
              0x80 | c >> 12 & 0x3f,
              0x80 | c >> 6 & 0x3f,
              0x80 | c & 0x3f)}
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function caml_js_to_string(s)
     {var tag=9;
      if(! caml_is_ascii(s))tag = 8,s = caml_utf8_of_utf16(s);
      return new MlBytes(tag,s,s.length)}
    function caml_raise_constant(tag){throw tag}
    function caml_raise_not_found()
     {caml_raise_constant(caml_global_data.Not_found)}
    function caml_sys_getenv(name)
     {var g=joo_global_object,n=name.toString();
      if(g.process && g.process.env && g.process.env[n] != undefined)
       return caml_js_to_string(g.process.env[n]);
      if
       (joo_global_object.jsoo_static_env
        &&
        joo_global_object.jsoo_static_env[n])
       return caml_js_to_string(joo_global_object.jsoo_static_env[n]);
      caml_raise_not_found()}
    function shift_right_nat(nat1,ofs1,len1,nat2,ofs2,nbits)
     {if(nbits == 0){nat2.data[ofs2] = 0;return 0}
      var wrap=0;
      for(var i=len1 - 1;i >= 0;i--)
       {var a=nat1.data[ofs1 + i] >>> 0;
        nat1.data[ofs1 + i] = a >>> nbits | wrap;
        wrap = a << 32 - nbits}
      nat2.data[ofs2] = wrap;
      return 0}
    var MlObjectTable;
    if(typeof joo_global_object.WeakMap === "undefined")
     MlObjectTable
     =
     function()
       {function NaiveLookup(objs){this.objs = objs}
        NaiveLookup.prototype.get
        =
        function(v)
         {for(var i=0;i < this.objs.length;i++)if(this.objs[i] === v)return i};
        NaiveLookup.prototype.set = function(){};
        return function()
         {this.objs = [];this.lookup = new NaiveLookup(this.objs)}}
      ();
    else
     MlObjectTable
     =
     function()
      {this.objs = [];this.lookup = new (joo_global_object.WeakMap)()};
    MlObjectTable.prototype.store
    =
    function(v){this.lookup.set(v,this.objs.length);this.objs.push(v)};
    MlObjectTable.prototype.recall
    =
    function(v)
     {var i=this.lookup.get(v);
      return i === undefined?undefined:this.objs.length - i};
    function caml_failwith(msg)
     {caml_raise_with_string(caml_global_data.Failure,msg)}
    function caml_sys_rename(o,n)
     {var o_root=resolve_fs_device(o),n_root=resolve_fs_device(n);
      if(o_root.device != n_root.device)
       caml_failwith
        ("caml_sys_rename: cannot move file between two filesystem");
      if(! o_root.device.rename)
       caml_failwith("caml_sys_rename: no implemented");
      o_root.device.rename(o_root.rest,n_root.rest)}
    function caml_log10_float(x){return Math.LOG10E * Math.log(x)}
    var caml_runtime_warnings=0;
    function caml_ml_enable_runtime_warnings(bool)
     {caml_runtime_warnings = bool;return 0}
    function caml_classify_float(x)
     {if(isFinite(x))
       {if(Math.abs(x) >= 2.2250738585072014e-308)return 0;
        if(x != 0)return 1;
        return 2}
      return isNaN(x)?4:3}
    function caml_ml_refill_input(chan)
     {var str=chan.refill(),str_len=caml_ml_bytes_length(str);
      if(str_len == 0)chan.refill = null;
      chan.file.write(chan.file.length(),str,0,str_len);
      return str_len}
    var caml_ml_channels=new Array();
    function caml_ml_may_refill_input(chanid)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill == null)return;
      if(chan.file.length() != chan.offset)return;
      caml_ml_refill_input(chan)}
    function caml_array_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_ml_input_scan_line(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_may_refill_input(chanid);
      var p=chan.offset,len=chan.file.length();
      if(p >= len)return 0;
      while(true)
       {if(p >= len)return - (p - chan.offset);
        if(chan.file.read_one(p) == 10)return p - chan.offset + 1;
        p++}}
    function caml_gc_minor(){return 0}
    function caml_int64_of_bytes(a)
     {return [255,
              a[7] | a[6] << 8 | a[5] << 16,
              a[4] | a[3] << 8 | a[2] << 16,
              a[1] | a[0] << 8]}
    function caml_ba_uint8_get64(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 7 >= ba.data.length)caml_array_bound_error();
      var
       b1=ba.get(ofs + 0),
       b2=ba.get(ofs + 1),
       b3=ba.get(ofs + 2),
       b4=ba.get(ofs + 3),
       b5=ba.get(ofs + 4),
       b6=ba.get(ofs + 5),
       b7=ba.get(ofs + 6),
       b8=ba.get(ofs + 7);
      return caml_int64_of_bytes([b8,b7,b6,b5,b4,b3,b2,b1])}
    function caml_int64_to_bytes(x)
     {return [x[3] >> 8,
              x[3] & 0xff,
              x[2] >> 16,
              x[2] >> 8 & 0xff,
              x[2] & 0xff,
              x[1] >> 16,
              x[1] >> 8 & 0xff,
              x[1] & 0xff]}
    function caml_int64_marshal(writer,v,sizes)
     {var b=caml_int64_to_bytes(v);
      for(var i=0;i < 8;i++)writer.write(8,b[i]);
      sizes[0] = 8;
      sizes[1] = 8}
    function caml_ba_num_dims(ba){return ba.dims.length}
    if(! Math.imul)
     Math.imul
     =
     function(x,y){y |= 0;return ((x >> 16) * y << 16) + (x & 0xffff) * y | 0};
    var caml_mul=Math.imul;
    function caml_hash_mix_int(h,d)
     {d = caml_mul(d,0xcc9e2d51 | 0);
      d = d << 15 | d >>> 32 - 15;
      d = caml_mul(d,0x1b873593);
      h ^= d;
      h = h << 13 | h >>> 32 - 13;
      return (h + (h << 2) | 0) + (0xe6546b64 | 0) | 0}
    function caml_hash_mix_string_arr(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w = s[i] | s[i + 1] << 8 | s[i + 2] << 16 | s[i + 3] << 24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s[i + 2] << 16;
        case 2:w |= s[i + 1] << 8;
        case 1:w |= s[i];h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_return_exn_constant(tag){return tag}
    var caml_named_values={};
    function caml_named_value(nm){return caml_named_values[nm]}
    function caml_wrap_exception(e)
     {if(e instanceof Array)return e;
      if
       (joo_global_object.RangeError
        &&
        e instanceof joo_global_object.RangeError
        &&
        e.message
        &&
        e.message.match(/maximum call stack/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if
       (joo_global_object.InternalError
        &&
        e instanceof joo_global_object.InternalError
        &&
        e.message
        &&
        e.message.match(/too much recursion/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if(e instanceof joo_global_object.Error && caml_named_value("jsError"))
       return [0,caml_named_value("jsError"),e];
      return [0,caml_global_data.Failure,caml_js_to_string(String(e))]}
    function caml_create_file(name,content)
     {var root=resolve_fs_device(name);
      if(! root.device.register)caml_failwith("cannot register file");
      root.device.register(root.rest,content);
      return 0}
    function caml_fs_init()
     {var tmp=joo_global_object.caml_fs_tmp;
      if(tmp)
       for(var i=0;i < tmp.length;i++)
        caml_create_file(tmp[i].name,tmp[i].content);
      joo_global_object.caml_create_file = caml_create_file;
      joo_global_object.caml_fs_tmp = [];
      return 0}
    function caml_list_of_js_array(a)
     {var l=0;
      for(var i=a.length - 1;i >= 0;i--){var e=a[i];l = [0,e,l]}
      return l}
    function caml_set_parser_trace(){return 0}
    function unix_gettimeofday(){return new Date().getTime() / 1000}
    function num_digits_nat(nat,ofs,len)
     {for(var i=len - 1;i >= 0;i--)if(nat.data[ofs + i] != 0)return i + 1;
      return 1}
    function caml_hash_nat(x)
     {var len=num_digits_nat(x,0,x.data.length),h=0;
      for(var i=0;i < len;i++)h = caml_hash_mix_int(h,x.data[i]);
      return h}
    function raw_array_append_one(a,x)
     {var l=a.length,b=new Array(l + 1),i=0;
      for(;i < l;i++)b[i] = a[i];
      b[i] = x;
      return b}
    function caml_call_gen(f,args)
     {if(f.fun)return caml_call_gen(f.fun,args);
      var n=f.length,argsLen=args.length,d=n - argsLen;
      if(d == 0)
       return f.apply(null,args);
      else
       if(d < 0)
        return caml_call_gen
                (f.apply(null,raw_array_sub(args,0,n)),
                 raw_array_sub(args,n,argsLen - n));
       else
        return function(x)
         {return caml_call_gen(f,raw_array_append_one(args,x))}}
    function caml_js_wrap_callback(f)
     {return function()
       {return arguments.length > 0
                ?caml_call_gen(f,arguments)
                :caml_call_gen(f,[undefined])}}
    function caml_js_wrap_callback_arguments(f)
     {return function(){return caml_js_wrap_callback(f)(arguments)}}
    function caml_sys_chdir(dir)
     {var root=resolve_fs_device(dir);
      if(root.device.exists(root.rest))
       {if(root.rest)
         caml_current_dir = root.path + root.rest + "/";
        else
         caml_current_dir = root.path;
        return 0}
      else
       caml_raise_no_such_file(dir)}
    function caml_gc_counters(){return [254,0,0,0]}
    function caml_hash_mix_string_str(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w
        =
        s.charCodeAt(i)
        |
        s.charCodeAt(i + 1)
        <<
        8
        |
        s.charCodeAt(i + 2)
        <<
        16
        |
        s.charCodeAt(i + 3)
        <<
        24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s.charCodeAt(i + 2) << 16;
        case 2:w |= s.charCodeAt(i + 1) << 8;
        case 1:w |= s.charCodeAt(i);h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    var log2_ok=Math.log2 && Math.log2(1.1235582092889474E+307) == 1020;
    function jsoo_floor_log2(x)
     {if(log2_ok)return Math.floor(Math.log2(x));
      var i=0;
      if(x == 0)return - Infinity;
      if(x >= 1)while(x >= 2){x /= 2;i++}else while(x < 1){x *= 2;i--}
      return i}
    function caml_int32_bits_of_float(x)
     {var float32a=new (joo_global_object.Float32Array)(1);
      float32a[0] = x;
      var int32a=new (joo_global_object.Int32Array)(float32a.buffer);
      return int32a[0] | 0}
    function caml_int64_create_lo_mi_hi(lo,mi,hi){return [255,lo,mi,hi]}
    function caml_int64_bits_of_float(x)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_int64_create_lo_mi_hi(1,0,0x7ff0);
        return x > 0
                ?caml_int64_create_lo_mi_hi(0,0,0x7ff0)
                :caml_int64_create_lo_mi_hi(0,0,0xfff0)}
      var sign=x == 0 && 1 / x == - Infinity?0x8000:x >= 0?0:0x8000;
      if(sign)x = - x;
      var exp=jsoo_floor_log2(x) + 1023;
      if(exp <= 0)
       {exp = 0;x /= Math.pow(2,- 1026)}
      else
       {x /= Math.pow(2,exp - 1027);
        if(x < 16){x *= 2;exp -= 1}
        if(exp == 0)x /= 2}
      var k=Math.pow(2,24),r3=x | 0;
      x = (x - r3) * k;
      var r2=x | 0;
      x = (x - r2) * k;
      var r1=x | 0;
      r3 = r3 & 0xf | sign | exp << 4;
      return caml_int64_create_lo_mi_hi(r1,r2,r3)}
    function caml_ba_serialize(writer,ba,sz)
     {writer.write(32,ba.dims.length);
      writer.write(32,ba.kind | ba.layout << 8);
      for(var i=0;i < ba.dims.length;i++)writer.write(32,ba.dims[i]);
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         for(var i=0;i < ba.data.length;i++)writer.write(8,ba.data[i]);break;
        case 4:
        case 5:
         for(var i=0;i < ba.data.length;i++)writer.write(16,ba.data[i]);break;
        case 6:
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);break;
        case 8:
        case 9:
         writer.write(8,0);
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);
         break;
        case 7:
         for(var i=0;i < ba.data.length / 2;i++)
          {var b=caml_int64_to_bytes(ba.get(i));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 1:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int64_to_bytes(caml_int64_bits_of_float(ba.get(i)));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 0:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int32_bits_of_float(ba.get(i));writer.write(32,b)}
         break;
        case 10:
         for(var i=0;i < ba.data.length / 2;i++)
          {var j=ba.get(i);
           writer.write(32,caml_int32_bits_of_float(j[1]));
           writer.write(32,caml_int32_bits_of_float(j[2]))}
         break;
        case 11:
         for(var i=0;i < ba.data.length / 2;i++)
          {var
            complex=ba.get(i),
            b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[1]));
           for(var j=0;j < 8;j++)writer.write(8,b[j]);
           var b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[2]));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break
        }
      sz[0] = (4 + ba.dims.length) * 4;
      sz[1] = (4 + ba.dims.length) * 8}
    function caml_ba_get_size_per_element(kind)
     {switch(kind){case 7:case 10:case 11:return 2;default:return 1}}
    function caml_ba_create_buffer(kind,size)
     {var g=joo_global_object,view;
      switch(kind)
       {case 0:view = g.Float32Array;break;
        case 1:view = g.Float64Array;break;
        case 2:view = g.Int8Array;break;
        case 3:view = g.Uint8Array;break;
        case 4:view = g.Int16Array;break;
        case 5:view = g.Uint16Array;break;
        case 6:view = g.Int32Array;break;
        case 7:view = g.Int32Array;break;
        case 8:view = g.Int32Array;break;
        case 9:view = g.Int32Array;break;
        case 10:view = g.Float32Array;break;
        case 11:view = g.Float64Array;break;
        case 12:view = g.Uint8Array;break
        }
      if(! view)caml_invalid_argument("Bigarray.create: unsupported kind");
      var data=new view(size * caml_ba_get_size_per_element(kind));
      return data}
    function caml_int32_float_of_bits(x)
     {var int32a=new (joo_global_object.Int32Array)(1);
      int32a[0] = x;
      var float32a=new (joo_global_object.Float32Array)(int32a.buffer);
      return float32a[0]}
    function caml_int64_float_of_bits(x)
     {var lo=x[1],mi=x[2],hi=x[3],exp=(hi & 0x7fff) >> 4;
      if(exp == 2047)
       return (lo | mi | hi & 0xf) == 0?hi & 0x8000?- Infinity:Infinity:NaN;
      var k=Math.pow(2,- 24),res=(lo * k + mi) * k + (hi & 0xf);
      if(exp > 0)
       {res += 16;res *= Math.pow(2,exp - 1027)}
      else
       res *= Math.pow(2,- 1026);
      if(hi & 0x8000)res = - res;
      return res}
    function caml_ba_get_size(dims)
     {var n_dims=dims.length,size=1;
      for(var i=0;i < n_dims;i++)
       {if(dims[i] < 0)
         caml_invalid_argument("Bigarray.create: negative dimension");
        size = size * dims[i]}
      return size}
    function caml_int64_create_lo_hi(lo,hi)
     {return [255,
              lo & 0xffffff,
              lo >>> 24 & 0xff | (hi & 0xffff) << 8,
              hi >>> 16 & 0xffff]}
    function caml_int64_hi32(v){return v[2] >>> 8 & 0xffff | v[3] << 16}
    function caml_int64_lo32(v){return v[1] | (v[2] & 0xff) << 24}
    function Ml_Bigarray(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray.prototype.caml_custom = "_bigarray";
    Ml_Bigarray.prototype.offset
    =
    function(arg)
     {var ofs=0;
      if(typeof arg === "number")arg = [arg];
      if(! (arg instanceof Array))
       caml_invalid_argument("bigarray.js: invalid offset");
      if(this.dims.length != arg.length)
       caml_invalid_argument("Bigarray.get/set: bad number of dimensions");
      if(this.layout == 0)
       for(var i=0;i < this.dims.length;i++)
        {if(arg[i] < 0 || arg[i] >= this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + arg[i]}
      else
       for(var i=this.dims.length - 1;i >= 0;i--)
        {if(arg[i] < 1 || arg[i] > this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + (arg[i] - 1)}
      return ofs};
    Ml_Bigarray.prototype.get
    =
    function(ofs)
     {switch(this.kind)
       {case 7:
         var l=this.data[ofs * 2 + 0],h=this.data[ofs * 2 + 1];
         return caml_int64_create_lo_hi(l,h);
        case 10:
        case 11:
         var r=this.data[ofs * 2 + 0],i=this.data[ofs * 2 + 1];
         return [254,r,i];
        default:return this.data[ofs]}};
    Ml_Bigarray.prototype.set
    =
    function(ofs,v)
     {switch(this.kind)
       {case 7:
         this.data[ofs * 2 + 0] = caml_int64_lo32(v);
         this.data[ofs * 2 + 1] = caml_int64_hi32(v);
         break;
        case 10:
        case 11:
         this.data[ofs * 2 + 0] = v[1];this.data[ofs * 2 + 1] = v[2];break;
        default:this.data[ofs] = v;break}
      return 0};
    Ml_Bigarray.prototype.fill
    =
    function(v)
     {switch(this.kind)
       {case 7:
         var a=caml_int64_lo32(v),b=caml_int64_hi32(v);
         if(a == b)
          this.data.fill(a);
         else
          for(var i=0;i < this.data.length;i++)this.data[i] = i % 2 == 0?a:b;
         break;
        case 10:
        case 11:
         var im=v[1],re=v[2];
         if(im == re)
          this.data.fill(im);
         else
          for(var i=0;i < this.data.length;i++)
           this.data[i] = i % 2 == 0?im:re;
         break;
        default:this.data.fill(v);break}};
    Ml_Bigarray.prototype.compare
    =
    function(b,total)
     {if(this.layout != b.layout || this.kind != b.kind)
       {var k1=this.kind | this.layout << 8,k2=b.kind | b.layout << 8;
        return k2 - k1}
      if(this.dims.length != b.dims.length)
       return b.dims.length - this.dims.length;
      for(var i=0;i < this.dims.length;i++)
       if(this.dims[i] != b.dims[i])return this.dims[i] < b.dims[i]?- 1:1;
      switch(this.kind)
       {case 0:
        case 1:
        case 10:
        case 11:
         var x,y;
         for(var i=0;i < this.data.length;i++)
          {x = this.data[i];
           y = b.data[i];
           if(x < y)return - 1;
           if(x > y)return 1;
           if(x != y)
            {if(! total)return NaN;if(x == x)return 1;if(y == y)return - 1}}
         break;
        case 7:
         for(var i=0;i < this.data.length;i += 2)
          {if(this.data[i + 1] < b.data[i + 1])return - 1;
           if(this.data[i + 1] > b.data[i + 1])return 1;
           if(this.data[i] >>> 0 < b.data[i] >>> 0)return - 1;
           if(this.data[i] >>> 0 > b.data[i] >>> 0)return 1}
         break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 8:
        case 9:
        case 12:
         for(var i=0;i < this.data.length;i++)
          {if(this.data[i] < b.data[i])return - 1;
           if(this.data[i] > b.data[i])return 1}
         break
        }
      return 0};
    function Ml_Bigarray_c_1_1(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray_c_1_1.prototype = new Ml_Bigarray();
    Ml_Bigarray_c_1_1.prototype.offset
    =
    function(arg)
     {if(typeof arg !== "number")
       if(arg instanceof Array && arg.length == 1)
        arg = arg[0];
       else
        caml_invalid_argument("Ml_Bigarray_c_1_1.offset");
      if(arg < 0 || arg >= this.dims[0])caml_array_bound_error();
      return arg};
    Ml_Bigarray_c_1_1.prototype.get = function(ofs){return this.data[ofs]};
    Ml_Bigarray_c_1_1.prototype.set
    =
    function(ofs,v){this.data[ofs] = v;return 0};
    Ml_Bigarray_c_1_1.prototype.fill
    =
    function(v){this.data.fill(v);return 0};
    function caml_ba_create_unsafe(kind,layout,dims,data)
     {var size_per_element=caml_ba_get_size_per_element(kind);
      if(caml_ba_get_size(dims) * size_per_element != data.length)
       caml_invalid_argument("length doesn't match dims");
      if(layout == 0 && dims.length == 1 && size_per_element == 1)
       return new Ml_Bigarray_c_1_1(kind,layout,dims,data);
      return new Ml_Bigarray(kind,layout,dims,data)}
    function caml_ba_deserialize(reader,sz)
     {var num_dims=reader.read32s();
      if(num_dims < 0 || num_dims > 16)
       caml_failwith("input_value: wrong number of bigarray dimensions");
      var tag=reader.read32s(),kind=tag & 0xff,layout=tag >> 8 & 1,dims=[];
      for(var i=0;i < num_dims;i++)dims.push(reader.read32u());
      var
       size=caml_ba_get_size(dims),
       data=caml_ba_create_buffer(kind,size),
       ba=caml_ba_create_unsafe(kind,layout,dims,data);
      switch(kind)
       {case 2:for(var i=0;i < size;i++)data[i] = reader.read8s();break;
        case 3:
        case 12:for(var i=0;i < size;i++)data[i] = reader.read8u();break;
        case 4:for(var i=0;i < size;i++)data[i] = reader.read16s();break;
        case 5:for(var i=0;i < size;i++)data[i] = reader.read16u();break;
        case 6:for(var i=0;i < size;i++)data[i] = reader.read32s();break;
        case 8:
        case 9:
         var sixty=reader.read8u();
         if(sixty)
          caml_failwith
           ("input_value: cannot read bigarray with 64-bit OCaml ints");
         for(var i=0;i < size;i++)data[i] = reader.read32s();
         break;
        case 7:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var int64=caml_int64_of_bytes(t);
           ba.set(i,int64)}
         break;
        case 1:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var f=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,f)}
         break;
        case 0:
         for(var i=0;i < size;i++)
          {var f=caml_int32_float_of_bits(reader.read32s());ba.set(i,f)}
         break;
        case 10:
         for(var i=0;i < size;i++)
          {var
            re=caml_int32_float_of_bits(reader.read32s()),
            im=caml_int32_float_of_bits(reader.read32s());
           ba.set(i,[254,re,im])}
         break;
        case 11:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var re=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var im=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,[254,re,im])}
         break
        }
      sz[0] = (4 + num_dims) * 4;
      return caml_ba_create_unsafe(kind,layout,dims,data)}
    function caml_ba_compare(a,b,total){return a.compare(b,total)}
    function caml_hash_mix_int64(h,v)
     {h = caml_hash_mix_int(h,caml_int64_lo32(v));
      h = caml_hash_mix_int(h,caml_int64_hi32(v));
      return h}
    function caml_hash_mix_float(h,v0)
     {return caml_hash_mix_int64(h,caml_int64_bits_of_float(v0))}
    function caml_ba_hash(ba)
     {var num_elts=caml_ba_get_size(ba.dims),h=0;
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         if(num_elts > 256)num_elts = 256;
         var w=0,i=0;
         for(i = 0;i + 4 <= ba.data.length;i += 4)
          {w
           =
           ba.data[i + 0]
           |
           ba.data[i + 1]
           <<
           8
           |
           ba.data[i + 2]
           <<
           16
           |
           ba.data[i + 3]
           <<
           24;
           h = caml_hash_mix_int(h,w)}
         w = 0;
         switch(num_elts & 3)
          {case 3:w = ba.data[i + 2] << 16;
           case 2:w |= ba.data[i + 1] << 8;
           case 1:w |= ba.data[i + 0];h = caml_hash_mix_int(h,w)
           }
         break;
        case 4:
        case 5:
         if(num_elts > 128)num_elts = 128;
         var w=0,i=0;
         for(i = 0;i + 2 <= ba.data.length;i += 2)
          {w = ba.data[i + 0] | ba.data[i + 1] << 16;
           h = caml_hash_mix_int(h,w)}
         if((num_elts & 1) != 0)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 6:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 8:
        case 9:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 7:
         if(num_elts > 32)num_elts = 32;
         num_elts *= 2;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 10:num_elts *= 2;
        case 0:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break;
        case 11:num_elts *= 2;
        case 1:
         if(num_elts > 32)num_elts = 32;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break
        }
      return h}
    function caml_int32_unmarshal(reader,size)
     {size[0] = 4;return reader.read32s()}
    function caml_nativeint_unmarshal(reader,size)
     {switch(reader.read8u())
       {case 1:size[0] = 4;return reader.read32s();
        case 2:caml_failwith("input_value: native integer value too large");
        default:caml_failwith("input_value: ill-formed native integer")}}
    function caml_int64_unmarshal(reader,size)
     {var t=new Array(8);
      for(var j=0;j < 8;j++)t[j] = reader.read8u();
      size[0] = 8;
      return caml_int64_of_bytes(t)}
    function caml_int64_compare(x,y)
     {var x3=x[3] << 16,y3=y[3] << 16;
      if(x3 > y3)return 1;
      if(x3 < y3)return - 1;
      if(x[2] > y[2])return 1;
      if(x[2] < y[2])return - 1;
      if(x[1] > y[1])return 1;
      if(x[1] < y[1])return - 1;
      return 0}
    function caml_int64_hash(x)
     {var lo=x[1] | (x[2] & 0xff) << 24,hi=x[2] >>> 8 & 0xffff | x[3] << 16;
      return lo ^ hi}
    var
     caml_custom_ops=
      {"_j":
       {deserialize:caml_int64_unmarshal,
        serialize:caml_int64_marshal,
        fixed_length:8,
        compare:caml_int64_compare,
        hash:caml_int64_hash},
       "_i":{deserialize:caml_int32_unmarshal,fixed_length:4},
       "_n":{deserialize:caml_nativeint_unmarshal,fixed_length:4},
       "_bigarray":
       {deserialize:caml_ba_deserialize,
        serialize:caml_ba_serialize,
        compare:caml_ba_compare,
        hash:caml_ba_hash}};
    function caml_compare_val_get_custom(a)
     {return caml_custom_ops[a.caml_custom]
             &&
             caml_custom_ops[a.caml_custom].compare}
    function caml_compare_val_number_custom(num,custom,swap,total)
     {var comp=caml_compare_val_get_custom(custom);
      if(comp)
       {var x=swap > 0?comp(custom,num,total):comp(num,custom,total);
        if(total && x != x)return swap;
        if(+ x != + x)return + x;
        if((x | 0) != 0)return x | 0}
      return swap}
    function caml_compare_val_tag(a)
     {if(typeof a === "number")
       return 1000;
      else
       if(a instanceof MlBytes)
        return 252;
       else
        if(a instanceof Array && a[0] === a[0] >>> 0 && a[0] <= 255)
         {var tag=a[0] | 0;return tag == 254?0:tag}
        else
         if(a instanceof String)
          return 1252;
         else
          if(typeof a == "string")
           return 1252;
          else
           if(a instanceof Number)
            return 1000;
           else
            if(a && a.caml_custom)
             return 1255;
            else
             if(a && a.compare)
              return 1256;
             else
              if(typeof a == "function")
               return 1247;
              else
               if(typeof a == "symbol")return 1251;
      return 1001}
    function caml_int_compare(a,b)
     {if(a < b)return - 1;if(a == b)return 0;return 1}
    function caml_string_compare(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?- 1:s1.c > s2.c?1:0}
    function caml_compare_val(a,b,total)
     {var stack=[];
      for(;;)
       {if(! (total && a === b))
         {var tag_a=caml_compare_val_tag(a);
          if(tag_a == 250){a = a[1];continue}
          var tag_b=caml_compare_val_tag(b);
          if(tag_b == 250){b = b[1];continue}
          if(tag_a !== tag_b)
           {if(tag_a == 1000)
             {if(tag_b == 1255)
               return caml_compare_val_number_custom(a,b,- 1,total);
              return - 1}
            if(tag_b == 1000)
             {if(tag_a == 1255)
               return caml_compare_val_number_custom(b,a,1,total);
              return 1}
            return tag_a < tag_b?- 1:1}
          switch(tag_a)
           {case 247:caml_invalid_argument("compare: functional value");break;
            case 248:
             var x=caml_int_compare(a[2],b[2]);if(x != 0)return x | 0;break;
            case 249:caml_invalid_argument("compare: functional value");break;
            case 250:
             caml_invalid_argument
              ("equal: got Forward_tag, should not happen");
             break;
            case 251:caml_invalid_argument("equal: abstract value");break;
            case 252:
             if(a !== b)
              {var x=caml_string_compare(a,b);if(x != 0)return x | 0}
             break;
            case 253:
             caml_invalid_argument("equal: got Double_tag, should not happen");
             break;
            case 254:
             caml_invalid_argument
              ("equal: got Double_array_tag, should not happen");
             break;
            case 255:
             var x=caml_int64_compare(a,b);if(x != 0)return x | 0;break;
            case 1247:
             caml_invalid_argument("compare: functional value");break;
            case 1255:
             var comp=caml_compare_val_get_custom(a);
             if(comp != caml_compare_val_get_custom(b))
              return a.caml_custom < b.caml_custom?- 1:1;
             if(! comp)caml_invalid_argument("compare: abstract value");
             var x=comp(a,b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1256:
             var x=a.compare(b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1000:
             a = + a;
             b = + b;
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1001:
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1251:if(a !== b){if(! total)return NaN;return 1}break;
            case 1252:
             var a=a.toString(),b=b.toString();
             if(a !== b){if(a < b)return - 1;if(a > b)return 1}
             break;
            case 246:
            case 254:
            default:
             if(a.length != b.length)return a.length < b.length?- 1:1;
             if(a.length > 1)stack.push(a,b,1);
             break}}
        if(stack.length == 0)return 0;
        var i=stack.pop();
        b = stack.pop();
        a = stack.pop();
        if(i + 1 < a.length)stack.push(a,b,i + 1);
        a = a[i];
        b = b[i]}}
    function caml_greaterthan(x,y){return + (caml_compare_val(x,y,false) > 0)}
    function div_helper(a,b,c)
     {var
       x=a * 65536 + (b >>> 16),
       y=Math.floor(x / c) * 65536,
       z=x % c * 65536,
       w=z + (b & 0x0000FFFF);
      return [y + Math.floor(w / c),w % c]}
    function div_digit_nat(natq,ofsq,natr,ofsr,nat1,ofs1,len,nat2,ofs2)
     {var rem=nat1.data[ofs1 + len - 1] >>> 0;
      for(var i=len - 2;i >= 0;i--)
       {var x=div_helper(rem,nat1.data[ofs1 + i] >>> 0,nat2.data[ofs2] >>> 0);
        natq.data[ofsq + i] = x[0];
        rem = x[1]}
      natr.data[ofsr] = rem;
      return 0}
    function num_leading_zero_bits_in_digit(nat,ofs)
     {var a=nat.data[ofs],b=0;
      if(a & 0xFFFF0000){b += 16;a >>>= 16}
      if(a & 0xFF00){b += 8;a >>>= 8}
      if(a & 0xF0){b += 4;a >>>= 4}
      if(a & 12){b += 2;a >>>= 2}
      if(a & 2){b += 1;a >>>= 1}
      if(a & 1)b += 1;
      return 32 - b}
    function shift_left_nat(nat1,ofs1,len1,nat2,ofs2,nbits)
     {if(nbits == 0){nat2.data[ofs2] = 0;return 0}
      var wrap=0;
      for(var i=0;i < len1;i++)
       {var a=nat1.data[ofs1 + i] >>> 0;
        nat1.data[ofs1 + i] = a << nbits | wrap;
        wrap = a >>> 32 - nbits}
      nat2.data[ofs2] = wrap;
      return 0}
    function MlNat(x)
     {this.data = new (joo_global_object.Int32Array)(x);
      this.length = this.data.length + 2}
    MlNat.prototype.caml_custom = "_nat";
    function create_nat(size)
     {var arr=new MlNat(size);
      for(var i=0;i < size;i++)arr.data[i] = - 1;
      return arr}
    function set_to_zero_nat(nat,ofs,len)
     {for(var i=0;i < len;i++)nat.data[ofs + i] = 0;return 0}
    function incr_nat(nat,ofs,len,carry_in)
     {var carry=carry_in;
      for(var i=0;i < len;i++)
       {var x=(nat.data[ofs + i] >>> 0) + carry;
        nat.data[ofs + i] = x | 0;
        if(x == x >>> 0){carry = 0;break}else carry = 1}
      return carry}
    function add_nat(nat1,ofs1,len1,nat2,ofs2,len2,carry_in)
     {var carry=carry_in;
      for(var i=0;i < len2;i++)
       {var
         x=
          (nat1.data[ofs1 + i] >>> 0) + (nat2.data[ofs2 + i] >>> 0) + carry;
        nat1.data[ofs1 + i] = x;
        if(x == x >>> 0)carry = 0;else carry = 1}
      return incr_nat(nat1,ofs1 + len2,len1 - len2,carry)}
    function nat_of_array(l){return new MlNat(l)}
    function mult_digit_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat3,ofs3)
     {var carry=0,a=nat3.data[ofs3] >>> 0;
      for(var i=0;i < len2;i++)
       {var
         x1=
          (nat1.data[ofs1 + i] >>> 0)
          +
          (nat2.data[ofs2 + i] >>> 0)
          *
          (a & 0x0000FFFF)
          +
          carry,
         x2=(nat2.data[ofs2 + i] >>> 0) * (a >>> 16);
        carry = Math.floor(x2 / 65536);
        var x3=x1 + x2 % 65536 * 65536;
        nat1.data[ofs1 + i] = x3;
        carry += Math.floor(x3 / 4294967296)}
      return len2 < len1 && carry
              ?add_nat
                (nat1,ofs1 + len2,len1 - len2,nat_of_array([carry]),0,1,0)
              :carry}
    function decr_nat(nat,ofs,len,carry_in)
     {var borrow=carry_in == 1?0:1;
      for(var i=0;i < len;i++)
       {var x=(nat.data[ofs + i] >>> 0) - borrow;
        nat.data[ofs + i] = x;
        if(x >= 0){borrow = 0;break}else borrow = 1}
      return borrow == 1?0:1}
    function sub_nat(nat1,ofs1,len1,nat2,ofs2,len2,carry_in)
     {var borrow=carry_in == 1?0:1;
      for(var i=0;i < len2;i++)
       {var
         x=
          (nat1.data[ofs1 + i] >>> 0) - (nat2.data[ofs2 + i] >>> 0) - borrow;
        nat1.data[ofs1 + i] = x;
        if(x >= 0)borrow = 0;else borrow = 1}
      return decr_nat(nat1,ofs1 + len2,len1 - len2,borrow == 1?0:1)}
    function compare_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {var a=num_digits_nat(nat1,ofs1,len1),b=num_digits_nat(nat2,ofs2,len2);
      if(a > b)return 1;
      if(a < b)return - 1;
      for(var i=len1 - 1;i >= 0;i--)
       {if(nat1.data[ofs1 + i] >>> 0 > nat2.data[ofs2 + i] >>> 0)return 1;
        if(nat1.data[ofs1 + i] >>> 0 < nat2.data[ofs2 + i] >>> 0)return - 1}
      return 0}
    function div_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {if(len2 == 1)
       {div_digit_nat(nat1,ofs1 + 1,nat1,ofs1,nat1,ofs1,len1,nat2,ofs2);
        return 0}
      var s=num_leading_zero_bits_in_digit(nat2,ofs2 + len2 - 1);
      shift_left_nat(nat2,ofs2,len2,nat_of_array([0]),0,s);
      shift_left_nat(nat1,ofs1,len1,nat_of_array([0]),0,s);
      var d=(nat2.data[ofs2 + len2 - 1] >>> 0) + 1,a=create_nat(len2 + 1);
      for(var i=len1 - 1;i >= len2;i--)
       {var
         quo=
          d == 4294967296
           ?nat1.data[ofs1 + i] >>> 0
           :div_helper
              (nat1.data[ofs1 + i] >>> 0,nat1.data[ofs1 + i - 1] >>> 0,d)
             [0];
        set_to_zero_nat(a,0,len2 + 1);
        mult_digit_nat(a,0,len2 + 1,nat2,ofs2,len2,nat_of_array([quo]),0);
        sub_nat(nat1,ofs1 + i - len2,len2 + 1,a,0,len2 + 1,1);
        while
         (nat1.data[ofs1 + i]
          !=
          0
          ||
          compare_nat(nat1,ofs1 + i - len2,len2,nat2,ofs2,len2)
          >=
          0)
         {quo = quo + 1;
          sub_nat(nat1,ofs1 + i - len2,len2 + 1,nat2,ofs2,len2,1)}
        nat1.data[ofs1 + i] = quo}
      shift_right_nat(nat1,ofs1,len2,nat_of_array([0]),0,s);
      shift_right_nat(nat2,ofs2,len2,nat_of_array([0]),0,s);
      return 0}
    function caml_ba_blit(src,dst)
     {if(dst.dims.length != src.dims.length)
       caml_invalid_argument("Bigarray.blit: dimension mismatch");
      for(var i=0;i < dst.dims.length;i++)
       if(dst.dims[i] != src.dims[i])
        caml_invalid_argument("Bigarray.blit: dimension mismatch");
      dst.data.set(src.data);
      return 0}
    function is_digit_int(nat,ofs){if(nat.data[ofs] >= 0)return 1;return 0}
    function caml_raise_zero_divide()
     {caml_raise_constant(caml_global_data.Division_by_zero)}
    function caml_int64_div(x,y)
     {if(caml_int64_is_zero(y))caml_raise_zero_divide();
      var sign=x[3] ^ y[3];
      if(x[3] & 0x8000)x = caml_int64_neg(x);
      if(y[3] & 0x8000)y = caml_int64_neg(y);
      var q=caml_int64_udivmod(x,y)[1];
      if(sign & 0x8000)q = caml_int64_neg(q);
      return q}
    function caml_js_html_entities(s)
     {var entity=/^&#?[0-9a-zA-Z]+;$/;
      if(s.match(entity))
       {var str,temp=document.createElement("p");
        temp.innerHTML = s;
        str = temp.textContent || temp.innerText;
        temp = null;
        return str}
      else
       caml_failwith("Invalid entity " + s)}
    function caml_string_unsafe_set(s,i,c)
     {return caml_bytes_unsafe_set(s,i,c)}
    var caml_int64_offset=Math.pow(2,- 24);
    function caml_int64_of_float(x)
     {if(x < 0)x = Math.ceil(x);
      return [255,
              x & 0xffffff,
              Math.floor(x * caml_int64_offset) & 0xffffff,
              Math.floor(x * caml_int64_offset * caml_int64_offset) & 0xffff]}
    function caml_ml_channel_size_64(chanid)
     {var chan=caml_ml_channels[chanid];
      return caml_int64_of_float(chan.file.length())}
    function caml_ba_set_2(ba,i0,i1,v){ba.set(ba.offset([i0,i1]),v);return 0}
    var
     caml_argv=
      function()
        {var g=joo_global_object,main="a.out",args=[];
         if(g.process && g.process.argv && g.process.argv.length > 1)
          {var argv=g.process.argv;
           main = argv[1];
           args = raw_array_sub(argv,2,argv.length - 2)}
         var p=caml_js_to_string(main),args2=[0,p];
         for(var i=0;i < args.length;i++)
          args2.push(caml_js_to_string(args[i]));
         return args2}
       (),
     caml_executable_name=caml_argv[1];
    function caml_bytes_compare(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?- 1:s1.c > s2.c?1:0}
    function caml_js_eval_string(s){return eval(s.toString())}
    function caml_CamlinternalMod_init_mod(loc,shape)
     {function undef_module(_x)
       {caml_raise_with_arg(caml_global_data.Undefined_recursive_module,loc)}
      function loop(shape,struct,idx)
       {if(typeof shape === "number")
         switch(shape)
          {case 0:struct[idx] = {fun:undef_module};break;
           case 1:struct[idx] = [246,undef_module];break;
           default:struct[idx] = []}
        else
         switch(shape[0])
          {case 0:
            struct[idx] = [0];
            for(var i=1;i < shape[1].length;i++)
             loop(shape[1][i],struct[idx],i);
            break;
           default:struct[idx] = shape[1]}}
      var res=[];
      loop(shape,res,0);
      return res[0]}
    function serialize_nat(writer,nat,sz)
     {var len=nat.data.length;
      writer.write(32,len);
      for(var i=0;i < len;i++)writer.write(32,nat.data[i]);
      sz[0] = len * 4;
      sz[1] = len * 8}
    function caml_memprof_set(_control){return 0}
    function caml_sys_exit(code)
     {var g=joo_global_object;
      if(g.quit)g.quit(code);
      if(g.process && g.process.exit)g.process.exit(code);
      caml_invalid_argument("Function 'exit' not implemented")}
    function caml_js_from_array(a){return raw_array_sub(a,1,a.length - 1)}
    function caml_ba_reshape(ba,vind)
     {vind = caml_js_from_array(vind);
      var new_dim=[],num_dims=vind.length;
      if(num_dims < 0 || num_dims > 16)
       caml_invalid_argument("Bigarray.reshape: bad number of dimensions");
      var num_elts=1;
      for(var i=0;i < num_dims;i++)
       {new_dim[i] = vind[i];
        if(new_dim[i] < 0)
         caml_invalid_argument("Bigarray.reshape: negative dimension");
        num_elts = num_elts * new_dim[i]}
      var size=caml_ba_get_size(ba.dims);
      if(num_elts != size)
       caml_invalid_argument("Bigarray.reshape: size mismatch");
      return caml_ba_create_unsafe(ba.kind,ba.layout,new_dim,ba.data)}
    var caml_oo_last_id=0;
    function caml_set_oo_id(b){b[2] = caml_oo_last_id++;return b}
    function caml_bigstring_blit_string_to_ba(str1,pos1,ba2,pos2,len)
     {if(12 != ba2.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs2=ba2.offset(pos2);
      if(pos1 + len > str1.l)caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=caml_array_of_string(str1).slice(pos1,pos1 + len);
      ba2.data.set(slice,ofs2);
      return 0}
    function caml_get_global_data(){return caml_global_data}
    function caml_int64_shift_right_unsigned(x,s)
     {s = s & 63;
      if(s == 0)return x;
      if(s < 24)
       return [255,
               (x[1] >> s | x[2] << 24 - s) & 0xffffff,
               (x[2] >> s | x[3] << 24 - s) & 0xffffff,
               x[3] >> s];
      if(s < 48)
       return [255,
               (x[2] >> s - 24 | x[3] << 48 - s) & 0xffffff,
               x[3] >> s - 24,
               0];
      return [255,x[3] >> s - 48,0,0]}
    function caml_ba_uint8_get16(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 1 >= ba.data.length)caml_array_bound_error();
      var b1=ba.get(ofs),b2=ba.get(ofs + 1);
      return b1 | b2 << 8}
    function caml_compare(a,b){return caml_compare_val(a,b,true)}
    function caml_fresh_oo_id(){return caml_oo_last_id++}
    function caml_int64_to_float(x)
     {return (x[3] << 16) * Math.pow(2,32) + x[2] * Math.pow(2,24) + x[1]}
    function caml_ba_get_1(ba,i0){return ba.get(ba.offset(i0))}
    function caml_bigstring_memcmp(s1,pos1,s2,pos2,len)
     {for(var i=0;i < len;i++)
       {var a=caml_ba_get_1(s1,pos1 + i),b=caml_ba_get_1(s2,pos2 + i);
        if(a < b)return - 1;
        if(a > b)return 1}
      return 0}
    function caml_raw_backtrace_length(){return 0}
    function caml_ba_uint8_get32(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 3 >= ba.data.length)caml_array_bound_error();
      var
       b1=ba.get(ofs + 0),
       b2=ba.get(ofs + 1),
       b3=ba.get(ofs + 2),
       b4=ba.get(ofs + 3);
      return b1 << 0 | b2 << 8 | b3 << 16 | b4 << 24}
    function caml_obj_block(tag,size)
     {var o=new Array(size + 1);
      o[0] = tag;
      for(var i=1;i <= size;i++)o[i] = 0;
      return o}
    function bigstring_to_array_buffer(bs){return bs.data.buffer}
    function lxor_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] ^= nat2.data[ofs2];return 0}
    function caml_final_release(){return 0}
    function raw_array_cons(a,x)
     {var l=a.length,b=new Array(l + 1);
      b[0] = x;
      for(var i=1;i <= l;i++)b[i] = a[i - 1];
      return b}
    function caml_js_to_array(a){return raw_array_cons(a,0)}
    function caml_bytes_set64(s,i,i64)
     {if(i >>> 0 >= s.l - 7)caml_string_bound_error();
      var a=caml_int64_to_bytes(i64);
      for(var j=0;j < 8;j++)caml_string_unsafe_set(s,i + 7 - j,a[j]);
      return 0}
    function caml_bytes_set16(s,i,i16)
     {if(i >>> 0 >= s.l - 1)caml_string_bound_error();
      var b2=0xFF & i16 >> 8,b1=0xFF & i16;
      caml_string_unsafe_set(s,i + 0,b1);
      caml_string_unsafe_set(s,i + 1,b2);
      return 0}
    function caml_string_set16(s,i,i16){return caml_bytes_set16(s,i,i16)}
    function caml_int64_bswap(x)
     {var y=caml_int64_to_bytes(x);
      return caml_int64_of_bytes([y[7],y[6],y[5],y[4],y[3],y[2],y[1],y[0]])}
    function caml_fill_bytes(s,i,l,c)
     {if(l > 0)
       if(i == 0 && (l >= s.l || s.t == 2 && l >= s.c.length))
        if(c == 0)
         {s.c = "";s.t = 2}
        else
         {s.c = caml_str_repeat(l,String.fromCharCode(c));s.t = l == s.l?0:2}
       else
        {if(s.t != 4)caml_convert_string_to_array(s);
         for(l += i;i < l;i++)s.c[i] = c}
      return 0}
    var caml_fill_string=caml_fill_bytes;
    function caml_gc_major(){return 0}
    function caml_lex_array(s)
     {s = caml_jsbytes_of_string(s);
      var l=s.length / 2,a=new Array(l);
      for(var i=0;i < l;i++)
       a[i]
       =
       (s.charCodeAt(2 * i) | s.charCodeAt(2 * i + 1) << 8)
       <<
       16
       >>
       16;
      return a}
    function caml_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      var c,state=start_state,buffer=caml_array_of_string(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)return - base - 1;
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        if(tbl.lex_check[base + c] == state)
         state = tbl.lex_trans[base + c];
        else
         state = tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         if(c == 256)lexbuf[lex_eof_reached] = 0}}
    function caml_sys_file_exists(name)
     {var root=resolve_fs_device(name);return root.device.exists(root.rest)}
    function caml_convert_raw_backtrace_slot()
     {caml_failwith("caml_convert_raw_backtrace_slot")}
    function caml_array_sub(a,i,len)
     {var a2=new Array(len + 1);
      a2[0] = 0;
      for(var i2=1,i1=i + 1;i2 <= len;i2++,i1++)a2[i2] = a[i1];
      return a2}
    function caml_bytes_equal(s1,s2)
     {if(s1 === s2)return 1;
      s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c == s2.c?1:0}
    function caml_sys_const_ostype_cygwin(){return 0}
    function caml_cosh_float(x){return (Math.exp(x) + Math.exp(- x)) / 2}
    var caml_ephe_key_offset=3;
    function caml_weak_check(x,i)
     {return x[caml_ephe_key_offset + i]
              !==
              undefined
              &&
              x[caml_ephe_key_offset + i]
              !==
              0
              ?1
              :0}
    var caml_ephe_check_key=caml_weak_check;
    function caml_hash_mix_final(h)
     {h ^= h >>> 16;
      h = caml_mul(h,0x85ebca6b | 0);
      h ^= h >>> 13;
      h = caml_mul(h,0xc2b2ae35 | 0);
      h ^= h >>> 16;
      return h}
    function caml_lex_run_mem(s,i,mem,curr_pos)
     {for(;;)
       {var dst=s.charCodeAt(i);
        i++;
        if(dst == 0xff)return;
        var src=s.charCodeAt(i);
        i++;
        if(src == 0xff)
         mem[dst + 1] = curr_pos;
        else
         mem[dst + 1] = mem[src + 1]}}
    function caml_lex_run_tag(s,i,mem)
     {for(;;)
       {var dst=s.charCodeAt(i);
        i++;
        if(dst == 0xff)return;
        var src=s.charCodeAt(i);
        i++;
        if(src == 0xff)mem[dst + 1] = - 1;else mem[dst + 1] = mem[src + 1]}}
    function caml_new_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_mem=10,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5,
       lex_base_code=6,
       lex_backtrk_code=7,
       lex_default_code=8,
       lex_trans_code=9,
       lex_check_code=10,
       lex_code=11;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      if(! tbl.lex_default_code)
       {tbl.lex_base_code = caml_lex_array(tbl[lex_base_code]);
        tbl.lex_backtrk_code = caml_lex_array(tbl[lex_backtrk_code]);
        tbl.lex_check_code = caml_lex_array(tbl[lex_check_code]);
        tbl.lex_trans_code = caml_lex_array(tbl[lex_trans_code]);
        tbl.lex_default_code = caml_lex_array(tbl[lex_default_code])}
      if(tbl.lex_code == null)
       tbl.lex_code = caml_jsbytes_of_string(tbl[lex_code]);
      var c,state=start_state,buffer=caml_array_of_string(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)
         {var pc_off=tbl.lex_base_code[state];
          caml_lex_run_tag(tbl.lex_code,pc_off,lexbuf[lex_mem]);
          return - base - 1}
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {var pc_off=tbl.lex_backtrk_code[state];
          caml_lex_run_tag(tbl.lex_code,pc_off,lexbuf[lex_mem]);
          lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        var pstate=state;
        if(tbl.lex_check[base + c] == state)
         state = tbl.lex_trans[base + c];
        else
         state = tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         {var base_code=tbl.lex_base_code[pstate],pc_off;
          if(tbl.lex_check_code[base_code + c] == pstate)
           pc_off = tbl.lex_trans_code[base_code + c];
          else
           pc_off = tbl.lex_default_code[pstate];
          if(pc_off > 0)
           caml_lex_run_mem
            (tbl.lex_code,pc_off,lexbuf[lex_mem],lexbuf[lex_curr_pos]);
          if(c == 256)lexbuf[lex_eof_reached] = 0}}}
    function caml_ba_uint8_set64(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 7 >= ba.data.length)caml_array_bound_error();
      var v=caml_int64_to_bytes(v);
      for(var i=0;i < 8;i++)ba.set(ofs + i,v[7 - i]);
      return 0}
    function caml_sys_executable_name(a){return caml_executable_name}
    function caml_lessequal(x,y){return + (caml_compare_val(x,y,false) <= 0)}
    function caml_ml_flush(chanid)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)caml_raise_sys_error("Cannot flush a closed channel");
      if(! chan.buffer || chan.buffer == "")return 0;
      if
       (chan.fd
        &&
        caml_global_data.fds[chan.fd]
        &&
        caml_global_data.fds[chan.fd].output)
       {var output=caml_global_data.fds[chan.fd].output;
        switch(output.length)
         {case 2:output(chanid,chan.buffer);break;default:output(chan.buffer)}}
      chan.buffer = "";
      return 0}
    function caml_ml_seek_out_64(chanid,pos)
     {caml_ml_flush(chanid);
      caml_ml_channels[chanid].offset = caml_int64_to_float(pos);
      return 0}
    function compare_nat_real(nat1,nat2)
     {return compare_nat(nat1,0,nat1.data.length,nat2,0,nat2.data.length)}
    function caml_gc_set(_control){return 0}
    function caml_js_get(o,f){return o[f]}
    function caml_gc_compaction(){return 0}
    function caml_weak_get(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_key");
      return x[caml_ephe_key_offset + i] === undefined
              ?0
              :x[caml_ephe_key_offset + i]}
    var caml_ephe_get_key=caml_weak_get;
    function win_cleanup(){}
    function caml_sys_close(fd){delete caml_global_data.fds[fd];return 0}
    function caml_ml_close_channel(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_flush(chanid);
      chan.opened = false;
      chan.file.close();
      caml_sys_close(chan.fd);
      return 0}
    function caml_exn_with_js_backtrace(exn,force)
     {if(! exn.js_error || force || exn[0] == 248)
       exn.js_error
       =
       new (joo_global_object.Error)("Js exception containing backtrace");
      return exn}
    function caml_sys_isatty(_chan){return 0}
    function is_digit_zero(nat,ofs){if(nat.data[ofs] == 0)return 1;return 0}
    function unix_inet_addr_of_string(){return 0}
    function caml_js_set(o,f,v){o[f] = v;return 0}
    function caml_array_get(array,index)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      return array[index + 1]}
    function caml_spacetime_only_works_for_native_code()
     {caml_failwith("Spacetime profiling only works for native code")}
    function caml_ml_seek_in_64(chanid,pos)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill != null)caml_raise_sys_error("Illegal seek");
      chan.offset = caml_int64_to_float(pos);
      return 0}
    function caml_notequal(x,y){return + (caml_compare_val(x,y,false) != 0)}
    function caml_int64_shift_left(x,s)
     {s = s & 63;
      if(s == 0)return x;
      if(s < 24)
       return [255,
               x[1] << s & 0xffffff,
               (x[2] << s | x[1] >> 24 - s) & 0xffffff,
               (x[3] << s | x[2] >> 24 - s) & 0xffff];
      if(s < 48)
       return [255,
               0,
               x[1] << s - 24 & 0xffffff,
               (x[2] << s - 24 | x[1] >> 48 - s) & 0xffff];
      return [255,0,0,x[1] << s - 48 & 0xffff]}
    function caml_sys_const_int_size(){return 32}
    function caml_js_wrap_meth_callback(f)
     {return function()
       {return caml_call_gen(f,raw_array_cons(arguments,this))}}
    function caml_is_js(){return 1}
    function caml_ba_dim(ba,i)
     {if(i < 0 || i >= ba.dims.length)caml_invalid_argument("Bigarray.dim");
      return ba.dims[i]}
    function caml_ba_dim_1(ba){return caml_ba_dim(ba,0)}
    function unix_localtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(d.getFullYear(),0,1).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000),
       jan=new Date(d.getFullYear(),0,1),
       jul=new Date(d.getFullYear(),6,1),
       stdTimezoneOffset=
        Math.max(jan.getTimezoneOffset(),jul.getTimezoneOffset());
      return [0,
              d.getSeconds(),
              d.getMinutes(),
              d.getHours(),
              d.getDate(),
              d.getMonth(),
              d.getFullYear() - 1900,
              d.getDay(),
              doy,
              d.getTimezoneOffset() < stdTimezoneOffset | 0]}
    function caml_js_meth_call(o,f,args)
     {return o[f.toString()].apply(o,caml_js_from_array(args))}
    function caml_weak_create(n)
     {if(n < 0)caml_invalid_argument("Weak.create");
      var x=[251,"caml_ephe_list_head"];
      x.length = caml_ephe_key_offset + n;
      return x}
    var caml_ephe_create=caml_weak_create;
    function caml_js_to_byte_string(s){return caml_new_string(s)}
    function unix_mktime(tm)
     {var
       d=new Date(tm[6] + 1900,tm[5],tm[4],tm[3],tm[2],tm[1]).getTime(),
       t=Math.floor(d / 1000),
       tm2=unix_localtime(t);
      return [0,t,tm2]}
    function caml_trampoline(res)
     {var c=1;
      while(res && res.joo_tramp)
       {res = res.joo_tramp.apply(null,res.joo_args);c++}
      return res}
    function caml_bytes_get64(s,i)
     {if(i >>> 0 >= s.l - 7)caml_string_bound_error();
      var a=new Array(8);
      for(var j=0;j < 8;j++)a[7 - j] = caml_string_unsafe_get(s,i + j);
      return caml_int64_of_bytes(a)}
    function caml_weak_set(x,i,v)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.set");
      x[caml_ephe_key_offset + i] = v;
      return 0}
    function caml_sys_remove(name)
     {var root=resolve_fs_device(name),ok=root.device.unlink(root.rest);
      if(ok == 0)caml_raise_no_such_file(name);
      return 0}
    function caml_string_get32(s,i)
     {if(i >>> 0 >= s.l - 3)caml_string_bound_error();
      var
       b1=caml_string_unsafe_get(s,i),
       b2=caml_string_unsafe_get(s,i + 1),
       b3=caml_string_unsafe_get(s,i + 2),
       b4=caml_string_unsafe_get(s,i + 3);
      return b4 << 24 | b3 << 16 | b2 << 8 | b1}
    function caml_hypot_float(x,y)
     {var
       x=Math.abs(x),
       y=Math.abs(y),
       a=Math.max(x,y),
       b=Math.min(x,y) / (a?a:1);
      return a * Math.sqrt(1 + b * b)}
    function caml_js_call(f,o,args)
     {return f.apply(o,caml_js_from_array(args))}
    function caml_sys_const_max_wosize(){return 0x7FFFFFFF / 4 | 0}
    function caml_ephe_unset_key(x,i){return caml_weak_set(x,i,0)}
    function caml_bytes_lessthan(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?1:0}
    function caml_gc_quick_stat(){return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
    function caml_raise_end_of_file()
     {caml_raise_constant(caml_global_data.End_of_file)}
    function caml_ml_input_int(chanid)
     {var chan=caml_ml_channels[chanid],file=chan.file;
      while(chan.offset + 3 >= file.length())
       {var l=caml_ml_refill_input(chan);if(l == 0)caml_raise_end_of_file()}
      var
       o=chan.offset,
       r=
        file.read_one(o)
        <<
        24
        |
        file.read_one(o + 1)
        <<
        16
        |
        file.read_one(o + 2)
        <<
        8
        |
        file.read_one(o + 3);
      chan.offset += 4;
      return r}
    function caml_array_blit(a1,i1,a2,i2,len)
     {if(i2 <= i1)
       for(var j=1;j <= len;j++)a2[i2 + j] = a1[i1 + j];
      else
       for(var j=len;j >= 1;j--)a2[i2 + j] = a1[i1 + j];
      return 0}
    function nth_digit_nat(nat,ofs){return nat.data[ofs]}
    function caml_float_of_string(s)
     {var res;
      s = caml_jsbytes_of_string(s);
      res = + s;
      if(s.length > 0 && res === res)return res;
      s = s.replace(/_/g,"");
      res = + s;
      if(s.length > 0 && res === res || /^[+-]?nan$/i.test(s))return res;
      var m=/^ *([+-]?)0x([0-9a-f]+)\.?([0-9a-f]*)p([+-]?[0-9]+)/i.exec(s);
      if(m)
       {var
         m3=m[3].replace(/0+$/,""),
         mantissa=parseInt(m[1] + m[2] + m3,16),
         exponent=(m[4] | 0) - 4 * m3.length;
        res = mantissa * Math.pow(2,exponent);
        return res}
      if(/^\+?inf(inity)?$/i.test(s))return Infinity;
      if(/^-inf(inity)?$/i.test(s))return - Infinity;
      caml_failwith("float_of_string")}
    function caml_sys_getcwd(){return caml_new_string(caml_current_dir)}
    function caml_sys_const_big_endian(){return 0}
    function caml_list_to_js_array(l)
     {var a=[];for(;l !== 0;l = l[2])a.push(l[1]);return a}
    var caml_legacy_custom_code=true;
    function caml_ml_string_length(s){return s.l}
    var
     caml_output_val=
      function()
        {function Writer(){this.chunk = []}
         Writer.prototype
         =
         {chunk_idx:20,
          block_len:0,
          obj_counter:0,
          size_32:0,
          size_64:0,
          write:
          function(size,value)
           {for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          write_at:
          function(pos,size,value)
           {var pos=pos;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[pos++] = value >> i & 0xFF},
          write_code:
          function(size,code,value)
           {this.chunk[this.chunk_idx++] = code;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          write_shared:
          function(offset)
           {if(offset < 1 << 8)
             this.write_code(8,0x04,offset);
            else
             if(offset < 1 << 16)
              this.write_code(16,0x05,offset);
             else
              this.write_code(32,0x06,offset)},
          pos:function(){return this.chunk_idx},
          finalize:
          function()
           {this.block_len = this.chunk_idx - 20;
            this.chunk_idx = 0;
            this.write(32,0x8495A6BE);
            this.write(32,this.block_len);
            this.write(32,this.obj_counter);
            this.write(32,this.size_32);
            this.write(32,this.size_64);
            return this.chunk}};
         return function(v,flags)
          {flags = caml_list_to_js_array(flags);
           var
            no_sharing=flags.indexOf(0) !== - 1,
            closures=flags.indexOf(1) !== - 1;
           if(closures)
            joo_global_object.console.warn
             ("in caml_output_val: flag Marshal.Closures is not supported.");
           var
            writer=new Writer(),
            stack=[],
            intern_obj_table=no_sharing?null:new MlObjectTable();
           function memo(v)
            {if(no_sharing)return false;
             var existing_offset=intern_obj_table.recall(v);
             if(existing_offset)
              {writer.write_shared(existing_offset);return true}
             else
              {intern_obj_table.store(v);return false}}
           function extern_rec(v)
            {if(v.caml_custom || v instanceof Array && v[0] === 255)
              {if(memo(v))return;
               var
                name=v.caml_custom || "_j",
                ops=caml_custom_ops[name],
                sz_32_64=[0,0];
               if(! ops.serialize)
                caml_invalid_argument("output_value: abstract value (Custom)");
               if(caml_legacy_custom_code)
                {writer.write(8,0x12);
                 for(var i=0;i < name.length;i++)
                  writer.write(8,name.charCodeAt(i));
                 writer.write(8,0);
                 ops.serialize(writer,v,sz_32_64)}
               else
                if(ops.fixed_length == undefined)
                 {writer.write(8,0x18);
                  for(var i=0;i < name.length;i++)
                   writer.write(8,name.charCodeAt(i));
                  writer.write(8,0);
                  var header_pos=writer.pos();
                  for(var i=0;i < 12;i++)writer.write(8,0);
                  ops.serialize(writer,v,sz_32_64);
                  writer.write_at(header_pos,32,sz_32_64[0]);
                  writer.write_at(header_pos + 4,32,0);
                  writer.write_at(header_pos + 8,32,sz_32_64[1])}
                else
                 {writer.write(8,0x19);
                  for(var i=0;i < name.length;i++)
                   writer.write(8,name.charCodeAt(i));
                  writer.write(8,0);
                  var old_pos=writer.pos();
                  ops.serialize(writer,v,sz_32_64);
                  if(ops.fixed_length != writer.pos() - old_pos)
                   caml_failwith
                    ("output_value: incorrect fixed sizes specified by " + name)}
               writer.size_32 += 2 + (sz_32_64[0] + 3 >> 2);
               writer.size_64 += 2 + (sz_32_64[1] + 7 >> 3)}
             else
              if(v instanceof Array && v[0] === (v[0] | 0))
               {if(v[0] == 251)
                 caml_failwith("output_value: abstract value (Abstract)");
                if(v.length > 1 && memo(v))return;
                if(v[0] < 16 && v.length - 1 < 8)
                 writer.write(8,0x80 + v[0] + (v.length - 1 << 4));
                else
                 writer.write_code(32,0x08,v.length - 1 << 10 | v[0]);
                writer.size_32 += v.length;
                writer.size_64 += v.length;
                if(v.length > 1)stack.push(v,1)}
              else
               if(v instanceof MlBytes)
                {if(memo(v))return;
                 var len=caml_ml_string_length(v);
                 if(len < 0x20)
                  writer.write(8,0x20 + len);
                 else
                  if(len < 0x100)
                   writer.write_code(8,0x09,len);
                  else
                   writer.write_code(32,0x0A,len);
                 for(var i=0;i < len;i++)
                  writer.write(8,caml_string_unsafe_get(v,i));
                 writer.size_32 += 1 + ((len + 4) / 4 | 0);
                 writer.size_64 += 1 + ((len + 8) / 8 | 0)}
               else
                if(v != (v | 0))
                 {var type_of_v=typeof v;
                  caml_failwith
                   ("output_value: abstract value (" + type_of_v + ")")}
                else
                 if(v >= 0 && v < 0x40)
                  writer.write(8,0X40 + v);
                 else
                  if(v >= - (1 << 7) && v < 1 << 7)
                   writer.write_code(8,0x00,v);
                  else
                   if(v >= - (1 << 15) && v < 1 << 15)
                    writer.write_code(16,0x01,v);
                   else
                    writer.write_code(32,0x02,v)}
           extern_rec(v);
           while(stack.length > 0)
            {var i=stack.pop(),v=stack.pop();
             if(i + 1 < v.length)stack.push(v,i + 1);
             extern_rec(v[i])}
           if(intern_obj_table)
            writer.obj_counter = intern_obj_table.objs.length;
           writer.finalize();
           return writer.chunk}}
       ();
    function caml_output_value_to_string(v,flags)
     {return caml_string_of_array(caml_output_val(v,flags))}
    function caml_raise_not_a_dir(name)
     {name = name instanceof MlBytes?name.toString():name;
      caml_raise_sys_error(name + ": Not a directory")}
    function caml_sys_system_command(cmd)
     {var cmd=cmd.toString();
      joo_global_object.console.log(cmd);
      if
       (typeof require
        !=
        "undefined"
        &&
        require("child_process")
        &&
        require("child_process").execSync)
       try {require("child_process").execSync(cmd);return 0}catch(e){return 1}
      else
       return 127}
    function caml_js_error_of_exception(exn)
     {if(exn.js_error)return exn.js_error;return null}
    function deserialize_nat(reader,sz)
     {var len=reader.read32s(),nat=new MlNat(len);
      for(var i=0;i < len;i++)nat.data[i] = reader.read32s();
      sz[0] = len * 4;
      return nat}
    function initialize_nat()
     {caml_custom_ops["_nat"]
      =
      {deserialize:deserialize_nat,serialize:serialize_nat,hash:caml_hash_nat}}
    function js_print_stdout(s)
     {var s=caml_utf16_of_utf8(s),g=joo_global_object;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stdout.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.log && v.log(s)}}
    function caml_copysign_float(x,y)
     {if(y == 0)y = 1 / y;x = Math.abs(x);return y < 0?- x:x}
    function caml_ba_set_generic(ba,i,v)
     {ba.set(ba.offset(caml_js_from_array(i)),v);return 0}
    function caml_ephe_set_key(x,i,v){return caml_weak_set(x,i,[0,v])}
    function caml_string_lessequal(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c <= s2.c?1:0}
    function caml_string_greaterequal(s1,s2)
     {return caml_string_lessequal(s2,s1)}
    function caml_int64_add(x,y)
     {var
       z1=x[1] + y[1],
       z2=x[2] + y[2] + (z1 >> 24),
       z3=x[3] + y[3] + (z2 >> 24);
      return [255,z1 & 0xffffff,z2 & 0xffffff,z3 & 0xffff]}
    function caml_nextafter_float(x,y)
     {if(isNaN(x) || isNaN(y))return NaN;
      if(x == y)return y;
      if(x == 0)return y < 0?- Math.pow(2,- 1074):Math.pow(2,- 1074);
      var bits=caml_int64_bits_of_float(x),one=caml_int64_of_int32(1);
      if(x < y == x > 0)
       bits = caml_int64_add(bits,one);
      else
       bits = caml_int64_sub(bits,one);
      return caml_int64_float_of_bits(bits)}
    function caml_ml_pos_in(chanid){return caml_ml_channels[chanid].offset}
    function caml_int64_and(x,y)
     {return [255,x[1] & y[1],x[2] & y[2],x[3] & y[3]]}
    function caml_sys_const_word_size(){return 32}
    function caml_std_output(chanid,s)
     {var
       chan=caml_ml_channels[chanid],
       str=caml_new_string(s),
       slen=caml_ml_string_length(str);
      chan.file.write(chan.offset,str,0,slen);
      chan.offset += slen;
      return 0}
    function js_print_stderr(s)
     {var s=caml_utf16_of_utf8(s),g=joo_global_object;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stderr.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.error && v.error(s)}}
    function caml_sys_open_internal(idx,output,file,flags)
     {if(caml_global_data.fds === undefined)
       caml_global_data.fds = new Array();
      flags = flags?flags:{};
      var info={};
      info.file = file;
      info.offset = flags.append?file.length():0;
      info.flags = flags;
      info.output = output;
      caml_global_data.fds[idx] = info;
      if(! caml_global_data.fd_last_idx || idx > caml_global_data.fd_last_idx)
       caml_global_data.fd_last_idx = idx;
      return idx}
    function caml_sys_open(name,flags,_perms)
     {var f={};
      while(flags)
       {switch(flags[1])
         {case 0:f.rdonly = 1;break;
          case 1:f.wronly = 1;break;
          case 2:f.append = 1;break;
          case 3:f.create = 1;break;
          case 4:f.truncate = 1;break;
          case 5:f.excl = 1;break;
          case 6:f.binary = 1;break;
          case 7:f.text = 1;break;
          case 8:f.nonblock = 1;break
          }
        flags = flags[2]}
      if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (name.toString()
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (name.toString()
         +
         " : flags Open_text and Open_binary are not compatible");
      var
       root=resolve_fs_device(name),
       file=root.device.open(root.rest,f),
       idx=caml_global_data.fd_last_idx?caml_global_data.fd_last_idx:0;
      return caml_sys_open_internal(idx + 1,caml_std_output,file,f)}
    caml_sys_open_internal
     (0,caml_std_output,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (1,js_print_stdout,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (2,js_print_stderr,new MlFakeFile(caml_create_bytes(0)));
    function MlBytesReader(s,i){this.s = caml_jsbytes_of_string(s);this.i = i}
    MlBytesReader.prototype
    =
    {read8u:function(){return this.s.charCodeAt(this.i++)},
     read8s:function(){return this.s.charCodeAt(this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 8 | s.charCodeAt(i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 24 >> 16 | s.charCodeAt(i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (s.charCodeAt(i)
               <<
               24
               |
               s.charCodeAt(i + 1)
               <<
               16
               |
               s.charCodeAt(i + 2)
               <<
               8
               |
               s.charCodeAt(i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return s.charCodeAt(i)
              <<
              24
              |
              s.charCodeAt(i + 1)
              <<
              16
              |
              s.charCodeAt(i + 2)
              <<
              8
              |
              s.charCodeAt(i + 3)},
     readstr:
     function(len)
      {var i=this.i;
       this.i = i + len;
       return caml_new_string(this.s.substring(i,i + len))}};
    function caml_float_of_bytes(a)
     {return caml_int64_float_of_bits(caml_int64_of_bytes(a))}
    function caml_input_value_from_reader(reader,ofs)
     {var
       _magic=reader.read32u(),
       _block_len=reader.read32u(),
       num_objects=reader.read32u(),
       _size_32=reader.read32u(),
       _size_64=reader.read32u(),
       stack=[],
       intern_obj_table=num_objects > 0?[]:null,
       obj_counter=0;
      function intern_rec()
       {var code=reader.read8u();
        if(code >= 0x40)
         if(code >= 0x80)
          {var tag=code & 0xF,size=code >> 4 & 0x7,v=[tag];
           if(size == 0)return v;
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           stack.push(v,size);
           return v}
         else
          return code & 0x3F;
        else
         if(code >= 0x20)
          {var len=code & 0x1F,v=reader.readstr(len);
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           return v}
         else
          switch(code)
           {case 0x00:return reader.read8s();
            case 0x01:return reader.read16s();
            case 0x02:return reader.read32s();
            case 0x03:caml_failwith("input_value: integer too large");break;
            case 0x04:
             var offset=reader.read8u();
             return intern_obj_table[obj_counter - offset];
            case 0x05:
             var offset=reader.read16u();
             return intern_obj_table[obj_counter - offset];
            case 0x06:
             var offset=reader.read32u();
             return intern_obj_table[obj_counter - offset];
            case 0x08:
             var
              header=reader.read32u(),
              tag=header & 0xFF,
              size=header >> 10,
              v=[tag];
             if(size == 0)return v;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             stack.push(v,size);
             return v;
            case 0x13:
             caml_failwith("input_value: data block too large");break;
            case 0x09:
             var len=reader.read8u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0A:
             var len=reader.read32u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0C:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[7 - i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0B:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0E:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x0D:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x07:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x0F:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x10:
            case 0x11:caml_failwith("input_value: code pointer");break;
            case 0x12:
            case 0x18:
            case 0x19:
             var c,s="";
             while((c = reader.read8u()) != 0)s += String.fromCharCode(c);
             var ops=caml_custom_ops[s],expected_size;
             if(! ops)
              caml_failwith("input_value: unknown custom block identifier");
             switch(code)
              {case 0x12:break;
               case 0x19:
                if(! ops.fixed_length)
                 caml_failwith
                  ("input_value: expected a fixed-size custom block");
                expected_size = ops.fixed_length;
                break;
               case 0x18:
                expected_size = reader.read32u();
                reader.read32s();
                reader.read32s();
                break
               }
             var old_pos=reader.i,size=[0],v=ops.deserialize(reader,size);
             if(expected_size != undefined)
              if(expected_size != size[0])
               caml_failwith
                ("input_value: incorrect length of serialized custom block");
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            default:caml_failwith("input_value: ill-formed message")}}
      var res=intern_rec();
      while(stack.length > 0)
       {var size=stack.pop(),v=stack.pop(),d=v.length;
        if(d < size)stack.push(v,size);
        v[d] = intern_rec()}
      if(typeof ofs != "number")ofs[0] = reader.i;
      return res}
    function caml_input_value_from_bytes(s,ofs)
     {var reader=new MlBytesReader(s,typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_js_from_string(s){return s.toString()}
    function caml_ba_sub(ba,ofs,len)
     {var changed_dim,mul=1;
      if(ba.layout == 0)
       {for(var i=1;i < ba.dims.length;i++)mul = mul * ba.dims[i];
        changed_dim = 0}
      else
       {for(var i=0;i < ba.dims.length - 1;i++)mul = mul * ba.dims[i];
        changed_dim = ba.dims.length - 1;
        ofs = ofs - 1}
      if(ofs < 0 || len < 0 || ofs + len > ba.dims[changed_dim])
       caml_invalid_argument("Bigarray.sub: bad sub-array");
      var new_dims=[];
      for(var i=0;i < ba.dims.length;i++)new_dims[i] = ba.dims[i];
      new_dims[changed_dim] = len;
      mul *= caml_ba_get_size_per_element(ba.kind);
      var new_data=ba.data.subarray(ofs * mul,(ofs + len) * mul);
      return caml_ba_create_unsafe(ba.kind,ba.layout,new_dims,new_data)}
    function caml_gc_full_major(){return 0}
    function caml_bytes_set32(s,i,i32)
     {if(i >>> 0 >= s.l - 3)caml_string_bound_error();
      var
       b4=0xFF & i32 >> 24,
       b3=0xFF & i32 >> 16,
       b2=0xFF & i32 >> 8,
       b1=0xFF & i32;
      caml_string_unsafe_set(s,i + 0,b1);
      caml_string_unsafe_set(s,i + 1,b2);
      caml_string_unsafe_set(s,i + 2,b3);
      caml_string_unsafe_set(s,i + 3,b4);
      return 0}
    function caml_int64_is_minus_one(x)
     {return x[3] == 0xffff && (x[1] & x[2]) == 0xffffff}
    function caml_ba_uint8_set32(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 3 >= ba.data.length)caml_array_bound_error();
      ba.set(ofs + 0,v & 0xff);
      ba.set(ofs + 1,v >>> 8 & 0xff);
      ba.set(ofs + 2,v >>> 16 & 0xff);
      ba.set(ofs + 3,v >>> 24 & 0xff);
      return 0}
    function caml_sys_const_ostype_unix(){return 1}
    function caml_signbit_float(x){if(x == 0)x = 1 / x;return x < 0?1:0}
    function caml_ml_seek_out(chanid,pos)
     {caml_ml_flush(chanid);caml_ml_channels[chanid].offset = pos;return 0}
    function caml_restore_raw_backtrace(exn,bt){return 0}
    function caml_js_typeof(o){return typeof o}
    function caml_js_wrap_meth_callback_unsafe(f)
     {return function(){f.apply(null,raw_array_cons(arguments,this))}}
    function caml_ba_dim_3(ba){return caml_ba_dim(ba,2)}
    var caml_ephe_data_offset=2;
    function caml_ephe_check_data(x)
     {return x[caml_ephe_data_offset] === undefined?0:1}
    function caml_bytes_get16(s,i)
     {if(i >>> 0 >= s.l - 1)caml_string_bound_error();
      var b1=caml_string_unsafe_get(s,i),b2=caml_string_unsafe_get(s,i + 1);
      return b2 << 8 | b1}
    function caml_obj_make_forward(b,v){b[0] = 250;b[1] = v;return 0}
    function caml_js_from_bool(x){return ! ! x}
    function caml_ml_set_channel_name(){return 0}
    function caml_create_string(len)
     {if(len < 0)caml_invalid_argument("String.create");
      return new MlBytes(len?2:9,"",len)}
    var
     caml_md5_string=
      function()
        {function add(x,y){return x + y | 0}
         function xx(q,a,b,x,s,t)
          {a = add(add(a,q),add(x,t));return add(a << s | a >>> 32 - s,b)}
         function ff(a,b,c,d,x,s,t){return xx(b & c | ~ b & d,a,b,x,s,t)}
         function gg(a,b,c,d,x,s,t){return xx(b & d | c & ~ d,a,b,x,s,t)}
         function hh(a,b,c,d,x,s,t){return xx(b ^ c ^ d,a,b,x,s,t)}
         function ii(a,b,c,d,x,s,t){return xx(c ^ (b | ~ d),a,b,x,s,t)}
         function md5(buffer,length)
          {var i=length;
           buffer[i >> 2] |= 0x80 << 8 * (i & 3);
           for(i = (i & ~ 0x3) + 8;(i & 0x3F) < 60;i += 4)
            buffer[(i >> 2) - 1] = 0;
           buffer[(i >> 2) - 1] = length << 3;
           buffer[i >> 2] = length >> 29 & 0x1FFFFFFF;
           var w=[0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476];
           for(i = 0;i < buffer.length;i += 16)
            {var a=w[0],b=w[1],c=w[2],d=w[3];
             a = ff(a,b,c,d,buffer[i + 0],7,0xD76AA478);
             d = ff(d,a,b,c,buffer[i + 1],12,0xE8C7B756);
             c = ff(c,d,a,b,buffer[i + 2],17,0x242070DB);
             b = ff(b,c,d,a,buffer[i + 3],22,0xC1BDCEEE);
             a = ff(a,b,c,d,buffer[i + 4],7,0xF57C0FAF);
             d = ff(d,a,b,c,buffer[i + 5],12,0x4787C62A);
             c = ff(c,d,a,b,buffer[i + 6],17,0xA8304613);
             b = ff(b,c,d,a,buffer[i + 7],22,0xFD469501);
             a = ff(a,b,c,d,buffer[i + 8],7,0x698098D8);
             d = ff(d,a,b,c,buffer[i + 9],12,0x8B44F7AF);
             c = ff(c,d,a,b,buffer[i + 10],17,0xFFFF5BB1);
             b = ff(b,c,d,a,buffer[i + 11],22,0x895CD7BE);
             a = ff(a,b,c,d,buffer[i + 12],7,0x6B901122);
             d = ff(d,a,b,c,buffer[i + 13],12,0xFD987193);
             c = ff(c,d,a,b,buffer[i + 14],17,0xA679438E);
             b = ff(b,c,d,a,buffer[i + 15],22,0x49B40821);
             a = gg(a,b,c,d,buffer[i + 1],5,0xF61E2562);
             d = gg(d,a,b,c,buffer[i + 6],9,0xC040B340);
             c = gg(c,d,a,b,buffer[i + 11],14,0x265E5A51);
             b = gg(b,c,d,a,buffer[i + 0],20,0xE9B6C7AA);
             a = gg(a,b,c,d,buffer[i + 5],5,0xD62F105D);
             d = gg(d,a,b,c,buffer[i + 10],9,0x02441453);
             c = gg(c,d,a,b,buffer[i + 15],14,0xD8A1E681);
             b = gg(b,c,d,a,buffer[i + 4],20,0xE7D3FBC8);
             a = gg(a,b,c,d,buffer[i + 9],5,0x21E1CDE6);
             d = gg(d,a,b,c,buffer[i + 14],9,0xC33707D6);
             c = gg(c,d,a,b,buffer[i + 3],14,0xF4D50D87);
             b = gg(b,c,d,a,buffer[i + 8],20,0x455A14ED);
             a = gg(a,b,c,d,buffer[i + 13],5,0xA9E3E905);
             d = gg(d,a,b,c,buffer[i + 2],9,0xFCEFA3F8);
             c = gg(c,d,a,b,buffer[i + 7],14,0x676F02D9);
             b = gg(b,c,d,a,buffer[i + 12],20,0x8D2A4C8A);
             a = hh(a,b,c,d,buffer[i + 5],4,0xFFFA3942);
             d = hh(d,a,b,c,buffer[i + 8],11,0x8771F681);
             c = hh(c,d,a,b,buffer[i + 11],16,0x6D9D6122);
             b = hh(b,c,d,a,buffer[i + 14],23,0xFDE5380C);
             a = hh(a,b,c,d,buffer[i + 1],4,0xA4BEEA44);
             d = hh(d,a,b,c,buffer[i + 4],11,0x4BDECFA9);
             c = hh(c,d,a,b,buffer[i + 7],16,0xF6BB4B60);
             b = hh(b,c,d,a,buffer[i + 10],23,0xBEBFBC70);
             a = hh(a,b,c,d,buffer[i + 13],4,0x289B7EC6);
             d = hh(d,a,b,c,buffer[i + 0],11,0xEAA127FA);
             c = hh(c,d,a,b,buffer[i + 3],16,0xD4EF3085);
             b = hh(b,c,d,a,buffer[i + 6],23,0x04881D05);
             a = hh(a,b,c,d,buffer[i + 9],4,0xD9D4D039);
             d = hh(d,a,b,c,buffer[i + 12],11,0xE6DB99E5);
             c = hh(c,d,a,b,buffer[i + 15],16,0x1FA27CF8);
             b = hh(b,c,d,a,buffer[i + 2],23,0xC4AC5665);
             a = ii(a,b,c,d,buffer[i + 0],6,0xF4292244);
             d = ii(d,a,b,c,buffer[i + 7],10,0x432AFF97);
             c = ii(c,d,a,b,buffer[i + 14],15,0xAB9423A7);
             b = ii(b,c,d,a,buffer[i + 5],21,0xFC93A039);
             a = ii(a,b,c,d,buffer[i + 12],6,0x655B59C3);
             d = ii(d,a,b,c,buffer[i + 3],10,0x8F0CCC92);
             c = ii(c,d,a,b,buffer[i + 10],15,0xFFEFF47D);
             b = ii(b,c,d,a,buffer[i + 1],21,0x85845DD1);
             a = ii(a,b,c,d,buffer[i + 8],6,0x6FA87E4F);
             d = ii(d,a,b,c,buffer[i + 15],10,0xFE2CE6E0);
             c = ii(c,d,a,b,buffer[i + 6],15,0xA3014314);
             b = ii(b,c,d,a,buffer[i + 13],21,0x4E0811A1);
             a = ii(a,b,c,d,buffer[i + 4],6,0xF7537E82);
             d = ii(d,a,b,c,buffer[i + 11],10,0xBD3AF235);
             c = ii(c,d,a,b,buffer[i + 2],15,0x2AD7D2BB);
             b = ii(b,c,d,a,buffer[i + 9],21,0xEB86D391);
             w[0] = add(a,w[0]);
             w[1] = add(b,w[1]);
             w[2] = add(c,w[2]);
             w[3] = add(d,w[3])}
           var t=new Array(16);
           for(var i=0;i < 4;i++)
            for(var j=0;j < 4;j++)t[i * 4 + j] = w[i] >> 8 * j & 0xFF;
           return t}
         return function(s,ofs,len)
          {var buf=[];
           switch(s.t & 6)
            {default:caml_convert_string_to_bytes(s);case 0:
              var b=s.c;
              for(var i=0;i < len;i += 4)
               {var j=i + ofs;
                buf[i >> 2]
                =
                b.charCodeAt(j)
                |
                b.charCodeAt(j + 1)
                <<
                8
                |
                b.charCodeAt(j + 2)
                <<
                16
                |
                b.charCodeAt(j + 3)
                <<
                24}
              for(;i < len;i++)
               buf[i >> 2] |= b.charCodeAt(i + ofs) << 8 * (i & 3);
              break;
             case 4:
              var a=s.c;
              for(var i=0;i < len;i += 4)
               {var j=i + ofs;
                buf[i >> 2]
                =
                a[j]
                |
                a[j + 1]
                <<
                8
                |
                a[j + 2]
                <<
                16
                |
                a[j + 3]
                <<
                24}
              for(;i < len;i++)buf[i >> 2] |= a[i + ofs] << 8 * (i & 3)
             }
           return caml_string_of_array(md5(buf,len))}}
       ();
    function caml_md5_chan(chanid,len)
     {var chan=caml_ml_channels[chanid],chan_len=chan.file.length();
      if(len < 0)len = chan_len - chan.offset;
      if(chan.offset + len > chan_len)caml_raise_end_of_file();
      var buf=caml_create_bytes(len);
      chan.file.read(chan.offset,buf,0,len);
      return caml_md5_string(buf,0,len)}
    function caml_weak_get_copy(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_copy");
      var y=caml_weak_get(x,i);
      if(y === 0)return y;
      var z=y[1];
      if(z instanceof Array)return [0,caml_obj_dup(z)];
      return y}
    function caml_ml_output_bytes(chanid,buffer,offset,len)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)
       caml_raise_sys_error("Cannot output to a closed channel");
      var string;
      if(offset == 0 && caml_ml_bytes_length(buffer) == len)
       string = buffer;
      else
       {string = caml_create_bytes(len);
        caml_blit_bytes(buffer,offset,string,0,len)}
      var
       jsstring=caml_jsbytes_of_string(string),
       id=jsstring.lastIndexOf("\n");
      if(id < 0)
       chan.buffer += jsstring;
      else
       {chan.buffer += jsstring.substr(0,id + 1);
        caml_ml_flush(chanid);
        chan.buffer += jsstring.substr(id + 1)}
      return 0}
    function caml_ml_output(chanid,buffer,offset,len)
     {return caml_ml_output_bytes(chanid,buffer,offset,len)}
    function caml_ephe_get_data(x)
     {return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,x[caml_ephe_data_offset]]}
    function caml_trampoline_return(f,args)
     {return {joo_tramp:f,joo_args:args}}
    function caml_array_append(a1,a2)
     {var l1=a1.length,l2=a2.length,l=l1 + l2 - 1,a=new Array(l);
      a[0] = 0;
      var i=1,j=1;
      for(;i < l1;i++)a[i] = a1[i];
      for(;i < l;i++,j++)a[i] = a2[j];
      return a}
    function caml_string_of_bytes(s){return s}
    function caml_ml_set_channel_refill(chanid,f)
     {caml_ml_channels[chanid].refill = f;return 0}
    function caml_js_expr(s)
     {js_print_stderr("caml_js_expr: fallback to runtime evaluation");
      return eval(s.toString())}
    function caml_int64_mul(x,y)
     {var
       z1=x[1] * y[1],
       z2=(z1 * caml_int64_offset | 0) + x[2] * y[1] + x[1] * y[2],
       z3=
        (z2 * caml_int64_offset | 0)
        +
        x[3]
        *
        y[1]
        +
        x[2]
        *
        y[2]
        +
        x[1]
        *
        y[3];
      return [255,z1 & 0xffffff,z2 & 0xffffff,z3 & 0xffff]}
    function caml_ml_runtime_warnings_enabled(_unit)
     {return caml_runtime_warnings}
    function caml_output_value_to_bytes(v,flags)
     {return caml_string_of_array(caml_output_val(v,flags))}
    function caml_hash_univ_param(count,limit,obj)
     {var hash_accu=0;
      function hash_aux(obj)
       {limit--;
        if(count < 0 || limit < 0)return;
        if(obj instanceof Array && obj[0] === (obj[0] | 0))
         switch(obj[0])
          {case 248:count--;hash_accu = hash_accu * 65599 + obj[2] | 0;break;
           case 250:limit++;hash_aux(obj);break;
           case 255:
            count--;
            hash_accu = hash_accu * 65599 + obj[1] + (obj[2] << 24) | 0;
            break;
           default:
            count--;
            hash_accu = hash_accu * 19 + obj[0] | 0;
            for(var i=obj.length - 1;i > 0;i--)hash_aux(obj[i])}
        else
         if(obj instanceof MlBytes)
          {count--;
           switch(obj.t & 6)
            {default:caml_convert_string_to_bytes(obj);case 0:
              for(var b=obj.c,l=obj.l,i=0;i < l;i++)
               hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0;
              break;
             case 2:
              for(var a=obj.c,l=obj.l,i=0;i < l;i++)
               hash_accu = hash_accu * 19 + a[i] | 0
             }}
         else
          if(obj === (obj | 0))
           {count--;hash_accu = hash_accu * 65599 + obj | 0}
          else
           if(obj === + obj)
            {count--;
             var p=caml_int64_to_bytes(caml_int64_bits_of_float(obj));
             for(var i=7;i >= 0;i--)hash_accu = hash_accu * 19 + p[i] | 0}
           else
            if(obj && obj.caml_custom)
             if
              (caml_custom_ops[obj.caml_custom]
               &&
               caml_custom_ops[obj.caml_custom].hash)
              {var h=caml_custom_ops[obj.caml_custom].hash(obj) | 0;
               hash_accu = hash_accu * 65599 + h | 0}}
      hash_aux(obj);
      return hash_accu & 0x3FFFFFFF}
    function caml_string_equal(s1,s2)
     {if(s1 === s2)return 1;
      s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c == s2.c?1:0}
    function raw_array_copy(a)
     {var l=a.length,b=new Array(l);
      for(var i=0;i < l;i++)b[i] = a[i];
      return b}
    function caml_output_value_to_buffer(s,ofs,len,v,flags)
     {var t=caml_output_val(v,flags);
      if(t.length > len)caml_failwith("Marshal.to_buffer: buffer overflow");
      caml_blit_bytes(t,0,s,ofs,t.length);
      return 0}
    function caml_pure_js_expr(s)
     {js_print_stderr("caml_pure_js_expr: fallback to runtime evaluation");
      return eval(s.toString())}
    function caml_blit_string(s1,i1,s2,i2,len)
     {return caml_blit_bytes(s1,i1,s2,i2,len)}
    function blit_nat(nat1,ofs1,nat2,ofs2,len)
     {for(var i=0;i < len;i++)nat1.data[ofs1 + i] = nat2.data[ofs2 + i];
      return 0}
    function caml_int64_ult(x,y){return caml_int64_ucompare(x,y) < 0}
    function caml_int64_xor(x,y)
     {return [255,x[1] ^ y[1],x[2] ^ y[2],x[3] ^ y[3]]}
    function caml_bigstring_blit_ba_to_bytes(ba1,pos1,bytes2,pos2,len)
     {if(12 != ba1.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs1=ba1.offset(pos1);
      if(ofs1 + len > ba1.data.length)caml_array_bound_error();
      if(pos2 + len > bytes2.l)caml_array_bound_error();
      var slice=ba1.data.slice(ofs1,ofs1 + len);
      caml_blit_bytes(caml_string_of_array(slice),0,bytes2,pos2,len);
      return 0}
    function caml_register_named_value(nm,v)
     {caml_named_values[caml_jsbytes_of_string(nm)] = v;return 0}
    function caml_parse_sign_and_base(s)
     {var i=0,len=caml_ml_string_length(s),base=10,sign=1;
      if(len > 0)
       switch(caml_string_unsafe_get(s,i))
        {case 45:i++;sign = - 1;break;case 43:i++;sign = 1;break}
      if(i + 1 < len && caml_string_unsafe_get(s,i) == 48)
       switch(caml_string_unsafe_get(s,i + 1))
        {case 120:
         case 88:base = 16;i += 2;break;
         case 111:
         case 79:base = 8;i += 2;break;
         case 98:
         case 66:base = 2;i += 2;break;
         case 117:
         case 85:sign = 0;i += 2;break
         }
      return [i,sign,base]}
    function caml_parse_digit(c)
     {if(c >= 48 && c <= 57)return c - 48;
      if(c >= 65 && c <= 90)return c - 55;
      if(c >= 97 && c <= 122)return c - 87;
      return - 1}
    function caml_int64_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       base64=caml_int64_of_int32(base),
       threshold=caml_int64_udivmod([255,0xffffff,0xfffffff,0xffff],base64)[1],
       c=caml_string_unsafe_get(s,i),
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=caml_int64_of_int32(d);
      for(;;)
       {i++;
        c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        if(caml_int64_ult(threshold,res))caml_failwith("int_of_string");
        d = caml_int64_of_int32(d);
        res = caml_int64_add(caml_int64_mul(base64,res),d);
        if(caml_int64_ult(res,d))caml_failwith("int_of_string")}
      if(i != caml_ml_string_length(s))caml_failwith("int_of_string");
      if(r[2] == 10 && caml_int64_ult([255,0,0,0x8000],res))
       caml_failwith("int_of_string");
      if(sign < 0)res = caml_int64_neg(res);
      return res}
    function caml_make_vect(len,init)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 0;
      for(var i=1;i < len;i++)b[i] = init;
      return b}
    var caml_blit_string_to_bigstring=caml_bigstring_blit_string_to_ba;
    function caml_ml_seek_in(chanid,pos)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill != null)caml_raise_sys_error("Illegal seek");
      chan.offset = pos;
      return 0}
    function caml_sys_read_directory(name)
     {var
       root=resolve_fs_device(name),
       a=root.device.readdir(root.rest),
       l=new Array(a.length + 1);
      l[0] = 0;
      for(var i=0;i < a.length;i++)l[i + 1] = caml_new_string(a[i]);
      return l}
    function caml_ml_output_char(chanid,c)
     {var s=caml_new_string(String.fromCharCode(c));
      caml_ml_output(chanid,s,0,1);
      return 0}
    function caml_sys_const_ostype_win32(){return 0}
    function caml_obj_is_block(x){return + (x instanceof Array)}
    function caml_ml_input_char(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_may_refill_input(chanid);
      if(chan.offset >= chan.file.length())caml_raise_end_of_file();
      var res=chan.file.read_one(chan.offset);
      chan.offset++;
      return res}
    function caml_js_var(x)
     {var x=x.toString();
      if(! x.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*(\.[a-zA-Z_$][a-zA-Z_$0-9]*)*$/))
       js_print_stderr
        ('caml_js_var: "'
         +
         x
         +
         '" is not a valid JavaScript variable. continuing ..');
      return eval(x)}
    function caml_trunc_float(x){return Math.trunc(x)}
    function caml_ephe_blit_data(src,dst)
     {dst[caml_ephe_data_offset] = src[caml_ephe_data_offset];return 0}
    function caml_is_printable(c){return + (c > 31 && c < 127)}
    function caml_bytes_lessequal(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c <= s2.c?1:0}
    function caml_equal(x,y){return + (caml_compare_val(x,y,false) == 0)}
    function caml_final_register_called_without_value(){return 0}
    function caml_sys_random_seed()
     {var now=new Date().getTime(),x=now ^ 0xffffffff * Math.random();
      return [0,x]}
    function caml_ba_get_2(ba,i0,i1){return ba.get(ba.offset([i0,i1]))}
    function win_handle_fd(x){return x}
    function caml_ba_uint8_set16(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 1 >= ba.data.length)caml_array_bound_error();
      ba.set(ofs + 0,v & 0xff);
      ba.set(ofs + 1,v >>> 8 & 0xff);
      return 0}
    function caml_js_delete(o,f){delete o[f];return 0}
    function caml_int_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       len=caml_ml_string_length(s),
       threshold=- 1 >>> 0,
       c=i < len?caml_string_unsafe_get(s,i):0,
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=d;
      for(i++;i < len;i++)
       {c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        res = base * res + d;
        if(res > threshold)caml_failwith("int_of_string")}
      if(i != len)caml_failwith("int_of_string");
      res = sign * res;
      if(base == 10 && (res | 0) != res)caml_failwith("int_of_string");
      return res | 0}
    function caml_list_mount_point()
     {var prev=0;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var old=prev;prev = [0,caml_new_string(jsoo_mount_point[i].path),old]}
      return prev}
    var
     caml_marshal_constants=
      {PREFIX_SMALL_BLOCK:0x80,
       PREFIX_SMALL_INT:0x40,
       PREFIX_SMALL_STRING:0x20,
       CODE_INT8:0x00,
       CODE_INT16:0x01,
       CODE_INT32:0x02,
       CODE_INT64:0x03,
       CODE_SHARED8:0x04,
       CODE_SHARED16:0x05,
       CODE_SHARED32:0x06,
       CODE_BLOCK32:0x08,
       CODE_BLOCK64:0x13,
       CODE_STRING8:0x09,
       CODE_STRING32:0x0A,
       CODE_DOUBLE_BIG:0x0B,
       CODE_DOUBLE_LITTLE:0x0C,
       CODE_DOUBLE_ARRAY8_BIG:0x0D,
       CODE_DOUBLE_ARRAY8_LITTLE:0x0E,
       CODE_DOUBLE_ARRAY32_BIG:0x0F,
       CODE_DOUBLE_ARRAY32_LITTLE:0x07,
       CODE_CODEPOINTER:0x10,
       CODE_INFIXPOINTER:0x11,
       CODE_CUSTOM:0x12,
       CODE_CUSTOM_LEN:0x18,
       CODE_CUSTOM_FIXED:0x19};
    function caml_js_equals(x,y){return + (x == y)}
    function bigstring_to_typed_array(bs){return bs.data}
    function caml_ba_slice(ba,vind)
     {vind = caml_js_from_array(vind);
      var num_inds=vind.length,index=[],sub_dims=[],ofs;
      if(num_inds > ba.dims.length)
       caml_invalid_argument("Bigarray.slice: too many indices");
      if(ba.layout == 0)
       {for(var i=0;i < num_inds;i++)index[i] = vind[i];
        for(;i < ba.dims.length;i++)index[i] = 0;
        sub_dims = ba.dims.slice(num_inds)}
      else
       {for(var i=0;i < num_inds;i++)
         index[ba.dims.length - num_inds + i] = vind[i];
        for(var i=0;i < ba.dims.length - num_inds;i++)index[i] = 1;
        sub_dims = ba.dims.slice(0,ba.dims.length - num_inds)}
      ofs = ba.offset(index);
      var
       size=caml_ba_get_size(sub_dims),
       size_per_element=caml_ba_get_size_per_element(ba.kind),
       new_data=
        ba.data.subarray
         (ofs * size_per_element,(ofs + size) * size_per_element);
      return caml_ba_create_unsafe(ba.kind,ba.layout,sub_dims,new_data)}
    function caml_marshal_data_size(s,ofs)
     {function get32(s,i)
       {return caml_bytes_unsafe_get(s,i)
               <<
               24
               |
               caml_bytes_unsafe_get(s,i + 1)
               <<
               16
               |
               caml_bytes_unsafe_get(s,i + 2)
               <<
               8
               |
               caml_bytes_unsafe_get(s,i + 3)}
      if(get32(s,ofs) != (0x8495A6BE | 0))
       caml_failwith("Marshal.data_size: bad object");
      return get32(s,ofs + 4)}
    function caml_input_value_from_string(s,ofs)
     {var reader=new MlBytesReader(s,typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_input_value(chanid)
     {var chan=caml_ml_channels[chanid],buf=caml_create_bytes(8);
      chan.file.read(chan.offset,buf,0,8);
      var len=caml_marshal_data_size(buf,0) + 20,buf=caml_create_bytes(len);
      chan.file.read(chan.offset,buf,0,len);
      var offset=[0],res=caml_input_value_from_string(buf,offset);
      chan.offset = chan.offset + offset[0];
      return res}
    function caml_ba_kind(ba){return ba.kind}
    function caml_js_fun_call(f,a)
     {switch(a.length)
       {case 1:return f();
        case 2:return f(a[1]);
        case 3:return f(a[1],a[2]);
        case 4:return f(a[1],a[2],a[3]);
        case 5:return f(a[1],a[2],a[3],a[4]);
        case 6:return f(a[1],a[2],a[3],a[4],a[5]);
        case 7:return f(a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:return f(a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
      return f.apply(null,caml_js_from_array(a))}
    function caml_js_pure_expr(f){return f()}
    function compare_digits_nat(nat1,ofs1,nat2,ofs2)
     {if(nat1.data[ofs1] > nat2.data[ofs2])return 1;
      if(nat1.data[ofs1] < nat2.data[ofs2])return - 1;
      return 0}
    function caml_ml_input(chanid,s,i,l)
     {var chan=caml_ml_channels[chanid],l2=chan.file.length() - chan.offset;
      if(l2 == 0 && chan.refill != null)l2 = caml_ml_refill_input(chan);
      if(l2 < l)l = l2;
      chan.file.read(chan.offset,s,i,l);
      chan.offset += l;
      return l}
    function caml_hash_mix_bigstring(h,bs)
     {return caml_hash_mix_string_arr(h,bs.data)}
    function caml_record_backtrace(){return 0}
    function unix_gmtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(Date.UTC(d.getUTCFullYear(),0,1)).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000);
      return [0,
              d.getUTCSeconds(),
              d.getUTCMinutes(),
              d.getUTCHours(),
              d.getUTCDate(),
              d.getUTCMonth(),
              d.getUTCFullYear() - 1900,
              d.getUTCDay(),
              doy,
              false | 0]}
    function caml_sys_const_backend_type()
     {return [0,caml_new_string("js_of_ocaml")]}
    function caml_sys_get_config(){return [0,caml_new_string("Unix"),32,0]}
    function unix_time(){return Math.floor(unix_gettimeofday())}
    function caml_ml_out_channels_list()
     {var l=0;
      for(var c=0;c < caml_ml_channels.length;c++)
       if
        (caml_ml_channels[c]
         &&
         caml_ml_channels[c].opened
         &&
         caml_ml_channels[c].out)
        l = [0,caml_ml_channels[c].fd,l];
      return l}
    function bigstring_of_array_buffer(ab)
     {var ta=new (joo_global_object.Uint8Array)(ab);
      return caml_ba_create_unsafe(12,0,[ta.length],ta)}
    function caml_mod(x,y){if(y == 0)caml_raise_zero_divide();return x % y}
    function caml_ba_init(){return 0}
    function BigStringReader(bs,i){this.s = bs;this.i = i}
    BigStringReader.prototype
    =
    {read8u:function(){return caml_ba_get_1(this.s,this.i++)},
     read8s:function(){return caml_ba_get_1(this.s,this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return caml_ba_get_1(s,i) << 8 | caml_ba_get_1(s,i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return caml_ba_get_1(s,i) << 24 >> 16 | caml_ba_get_1(s,i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (caml_ba_get_1(s,i)
               <<
               24
               |
               caml_ba_get_1(s,i + 1)
               <<
               16
               |
               caml_ba_get_1(s,i + 2)
               <<
               8
               |
               caml_ba_get_1(s,i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return caml_ba_get_1(s,i)
              <<
              24
              |
              caml_ba_get_1(s,i + 1)
              <<
              16
              |
              caml_ba_get_1(s,i + 2)
              <<
              8
              |
              caml_ba_get_1(s,i + 3)},
     readstr:
     function(len)
      {var i=this.i,arr=new Array(len);
       for(var j=0;j < len;j++)arr[j] = caml_ba_get_1(this.s,i + j);
       this.i = i + len;
       return caml_string_of_array(arr)}};
    function caml_ba_get_generic(ba,i)
     {var ofs=ba.offset(caml_js_from_array(i));return ba.get(ofs)}
    function caml_get_exception_backtrace(){return 0}
    function caml_format_float(fmt,x)
     {function toFixed(x,dp)
       {if(Math.abs(x) < 1.0)
         return x.toFixed(dp);
        else
         {var e=parseInt(x.toString().split("+")[1]);
          if(e > 20)
           {e -= 20;
            x /= Math.pow(10,e);
            x += new Array(e + 1).join("0");
            if(dp > 0)x = x + "." + new Array(dp + 1).join("0");
            return x}
          else
           return x.toFixed(dp)}}
      var s,f=caml_parse_format(fmt),prec=f.prec < 0?6:f.prec;
      if(x < 0 || x == 0 && 1 / x == - Infinity){f.sign = - 1;x = - x}
      if(isNaN(x))
       {s = "nan";f.filler = " "}
      else
       if(! isFinite(x))
        {s = "inf";f.filler = " "}
       else
        switch(f.conv)
         {case "e":
           var s=x.toExponential(prec),i=s.length;
           if(s.charAt(i - 3) == "e")
            s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
           break;
          case "f":s = toFixed(x,prec);break;
          case "g":
           prec = prec?prec:1;
           s = x.toExponential(prec - 1);
           var j=s.indexOf("e"),exp=+ s.slice(j + 1);
           if(exp < - 4 || x >= 1e21 || x.toFixed(0).length > prec)
            {var i=j - 1;
             while(s.charAt(i) == "0")i--;
             if(s.charAt(i) == ".")i--;
             s = s.slice(0,i + 1) + s.slice(j);
             i = s.length;
             if(s.charAt(i - 3) == "e")
              s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
             break}
           else
            {var p=prec;
             if(exp < 0)
              {p -= exp + 1;s = x.toFixed(p)}
             else
              while(s = x.toFixed(p),s.length > prec + 1)p--;
             if(p)
              {var i=s.length - 1;
               while(s.charAt(i) == "0")i--;
               if(s.charAt(i) == ".")i--;
               s = s.slice(0,i + 1)}}
           break
          }
      return caml_finish_formatting(f,s)}
    function caml_mount_autoload(name,f)
     {var path=caml_make_path(name),name=path.join("/") + "/";
      jsoo_mount_point.push({path:name,device:new MlFakeDevice(name,f)});
      return 0}
    function caml_bigstring_blit_ba_to_ba(ba1,pos1,ba2,pos2,len)
     {if(12 != ba1.kind)
       caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
      if(12 != ba2.kind)
       caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs1=ba1.offset(pos1),ofs2=ba2.offset(pos2);
      if(ofs1 + len > ba1.data.length)caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=ba1.data.subarray(ofs1,ofs1 + len);
      ba2.data.set(slice,pos2);
      return 0}
    var caml_blit_bigstring_to_bigstring=caml_bigstring_blit_ba_to_ba;
    function caml_div(x,y)
     {if(y == 0)caml_raise_zero_divide();return x / y | 0}
    function caml_string_lessthan(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?1:0}
    function caml_string_greaterthan(s1,s2)
     {return caml_string_lessthan(s2,s1)}
    function caml_ephe_get_data_copy(x)
     {return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,caml_obj_dup(x[caml_ephe_data_offset])]}
    function caml_sys_get_argv(a){return [0,caml_argv[1],caml_argv]}
    function caml_js_to_bool(x){return + x}
    var caml_ephe_get_key_copy=caml_weak_get_copy;
    function caml_raw_backtrace_next_slot(){return 0}
    function caml_lessthan(x,y){return + (caml_compare_val(x,y,false) < 0)}
    function caml_register_global(n,v,name_opt)
     {if(name_opt && joo_global_object.toplevelReloc)
       n = joo_global_object.toplevelReloc(name_opt);
      caml_global_data[n + 1] = v;
      if(name_opt)caml_global_data[name_opt] = v}
    function mult_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat3,ofs3,len3)
     {var carry=0;
      for(var i=0;i < len3;i++)
       carry
       +=
       mult_digit_nat(nat1,ofs1 + i,len1 - i,nat2,ofs2,len2,nat3,ofs3 + i);
      return carry}
    function square_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {var carry=0;
      carry += add_nat(nat1,ofs1,len1,nat1,ofs1,len1,0);
      carry += mult_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat2,ofs2,len2);
      return carry}
    function caml_floatarray_create(len)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 254;
      for(var i=1;i < len;i++)b[i] = 0;
      return b}
    function caml_js_from_float(x){return x}
    function caml_gc_stat(){return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
    function caml_sys_modify_argv(arg){caml_argv = arg;return 0}
    var caml_method_cache=[];
    function caml_get_public_method(obj,tag,cacheid)
     {var meths=obj[1],ofs=caml_method_cache[cacheid];
      if(ofs === null)
       for(var i=caml_method_cache.length;i < cacheid;i++)
        caml_method_cache[i] = 0;
      else
       if(meths[ofs] === tag)return meths[ofs - 1];
      var li=3,hi=meths[1] * 2 + 1,mi;
      while(li < hi)
       {mi = li + hi >> 1 | 1;if(tag < meths[mi + 1])hi = mi - 2;else li = mi}
      caml_method_cache[cacheid] = li + 1;
      return tag == meths[li + 1]?meths[li]:0}
    function caml_js_get_console()
     {var
       c=joo_global_object.console?joo_global_object.console:{},
       m=
        ["log",
         "debug",
         "info",
         "warn",
         "error",
         "assert",
         "dir",
         "dirxml",
         "trace",
         "group",
         "groupCollapsed",
         "groupEnd",
         "time",
         "timeEnd"];
      function f(){}
      for(var i=0;i < m.length;i++)if(! c[m[i]])c[m[i]] = f;
      return c}
    function caml_ml_open_descriptor_in(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.wronly)caml_raise_sys_error("fd " + fd + " is writeonly");
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:false,
         refill:null};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function bigstring_of_typed_array(ba)
     {var
       ta=
        new
         (joo_global_object.Uint8Array)
         (ba.buffer,ba.byteOffset,ba.length * ba.BYTES_PER_ELEMENT);
      return caml_ba_create_unsafe(12,0,[ta.length],ta)}
    function caml_round_float(x){return Math.round(x)}
    function caml_ojs_new_arr(c,a)
     {switch(a.length)
       {case 0:return new c();
        case 1:return new c(a[0]);
        case 2:return new c(a[0],a[1]);
        case 3:return new c(a[0],a[1],a[2]);
        case 4:return new c(a[0],a[1],a[2],a[3]);
        case 5:return new c(a[0],a[1],a[2],a[3],a[4]);
        case 6:return new c(a[0],a[1],a[2],a[3],a[4],a[5]);
        case 7:return new c(a[0],a[1],a[2],a[3],a[4],a[5],a[6])
        }
      function F(){return c.apply(this,a)}
      F.prototype = c.prototype;
      return new F()}
    function complement_nat(nat,ofs,len)
     {for(var i=0;i < len;i++)
       nat.data[ofs + i] = (- 1 >>> 0) - (nat.data[ofs + i] >>> 0)}
    var caml_js_regexps={amp:/&/g,lt:/</g,quot:/\"/g,all:/[&<\"]/};
    function caml_js_html_escape(s)
     {if(! caml_js_regexps.all.test(s))return s;
      return s.replace(caml_js_regexps.amp,"&amp;").replace
               (caml_js_regexps.lt,"&lt;").replace
              (caml_js_regexps.quot,"&quot;")}
    function caml_ba_dim_2(ba){return caml_ba_dim(ba,1)}
    function caml_js_wrap_meth_callback_arguments(f)
     {return function(){return caml_call_gen(f,[this,arguments])}}
    function caml_sinh_float(x){return (Math.exp(x) - Math.exp(- x)) / 2}
    function caml_ldexp_float(x,exp)
     {exp |= 0;
      if(exp > 1023)
       {exp -= 1023;
        x *= Math.pow(2,1023);
        if(exp > 1023){exp -= 1023;x *= Math.pow(2,1023)}}
      if(exp < - 1023){exp += 1023;x *= Math.pow(2,- 1023)}
      x *= Math.pow(2,exp);
      return x}
    function caml_js_wrap_callback_strict(arity,f)
     {return function()
       {var n=arguments.length;
        if(n == arity)return caml_call_gen(f,arguments);
        var args=new Array(arity);
        for(var i=0;i < n && i < arity;i++)args[i] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_get_current_callstack(){return [0]}
    function caml_ba_set_1(ba,i0,v){ba.set(ba.offset(i0),v);return 0}
    function land_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] &= nat2.data[ofs2];return 0}
    function caml_int64_mod(x,y)
     {if(caml_int64_is_zero(y))caml_raise_zero_divide();
      var sign=x[3];
      if(x[3] & 0x8000)x = caml_int64_neg(x);
      if(y[3] & 0x8000)y = caml_int64_neg(y);
      var r=caml_int64_udivmod(x,y)[2];
      if(sign & 0x8000)r = caml_int64_neg(r);
      return r}
    function caml_obj_set_tag(x,tag){x[0] = tag;return 0}
    function caml_create_file_extern(name,content)
     {if(joo_global_object.caml_create_file)
       joo_global_object.caml_create_file(name,content);
      else
       {if(! joo_global_object.caml_fs_tmp)joo_global_object.caml_fs_tmp = [];
        joo_global_object.caml_fs_tmp.push({name:name,content:content})}
      return 0}
    function caml_int32_bswap(x)
     {return (x & 0x000000FF)
             <<
             24
             |
             (x & 0x0000FF00)
             <<
             8
             |
             (x & 0x00FF0000)
             >>>
             8
             |
             (x & 0xFF000000)
             >>>
             24}
    function win_startup(){}
    function caml_ba_set_3(ba,i0,i1,i2,v)
     {ba.set(ba.offset([i0,i1,i2]),v);return 0}
    function caml_js_instanceof(o,c){return o instanceof c}
    var caml_blit_bigstring_to_string=caml_bigstring_blit_ba_to_bytes;
    function nth_digit_nat_native(nat,ofs){return nat.data[ofs]}
    function set_digit_nat_native(nat,ofs,digit)
     {nat.data[ofs] = digit;return 0}
    function caml_string_set64(s,i,i64){return caml_bytes_set64(s,i,i64)}
    function caml_ba_map_file(vfd,kind,layout,shared,dims,pos)
     {caml_failwith("caml_ba_map_file not implemented")}
    function caml_ba_map_file_bytecode(argv,argn)
     {return caml_ba_map_file(argv[0],argv[1],argv[2],argv[3],argv[4],argv[5])}
    function caml_ba_create_from(data1,data2,jstyp,kind,layout,dims)
     {if(data2 || caml_ba_get_size_per_element(kind) == 2)
       caml_invalid_argument
        ("caml_ba_create_from: use return caml_ba_create_unsafe");
      return caml_ba_create_unsafe(kind,layout,dims,data1)}
    function caml_tanh_float(x)
     {var y=Math.exp(x),z=Math.exp(- x);return (y - z) / (y + z)}
    var JSON=joo_global_object.JSON;
    if(typeof JSON !== "object")JSON = {};
    (function()
       {"use strict";
        var
         rx_one=/^[\],:{}\s]*$/,
         rx_two=/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
         rx_three=
          /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
         rx_four=/(?:^|:|,)(?:\s*\[)+/g,
         rx_escapable=
          /[\\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
         rx_dangerous=
          /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
        function f(n){return n < 10?"0" + n:n}
        function this_value(){return this.valueOf()}
        if(typeof Date.prototype.toJSON !== "function")
         {Date.prototype.toJSON
          =
          function()
           {return isFinite(this.valueOf())
                    ?this.getUTCFullYear()
                     +
                     "-"
                     +
                     f(this.getUTCMonth() + 1)
                     +
                     "-"
                     +
                     f(this.getUTCDate())
                     +
                     "T"
                     +
                     f(this.getUTCHours())
                     +
                     ":"
                     +
                     f(this.getUTCMinutes())
                     +
                     ":"
                     +
                     f(this.getUTCSeconds())
                     +
                     "Z"
                    :null};
          Boolean.prototype.toJSON = this_value;
          Number.prototype.toJSON = this_value;
          String.prototype.toJSON = this_value}
        var gap,indent,meta,rep;
        function quote(string)
         {rx_escapable.lastIndex = 0;
          return rx_escapable.test(string)
                  ?'"'
                   +
                   string.replace
                    (rx_escapable,
                     function(a)
                      {var c=meta[a];
                       return typeof c === "string"
                               ?c
                               :"\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(- 4)})
                   +
                   '"'
                  :'"' + string + '"'}
        function str(key,holder)
         {var i,k,v,length,mind=gap,partial,value=holder[key];
          if
           (value
            &&
            typeof value
            ===
            "object"
            &&
            typeof value.toJSON
            ===
            "function")
           value = value.toJSON(key);
          if(typeof rep === "function")value = rep.call(holder,key,value);
          switch(typeof value)
           {case "string":return quote(value);
            case "number":return isFinite(value)?String(value):"null";
            case "boolean":
            case "null":return String(value);
            case "object":
             if(! value)return "null";
             gap += indent;
             partial = [];
             if(Object.prototype.toString.apply(value) === "[object Array]")
              {length = value.length;
               for(i = 0;i < length;i += 1)
                partial[i] = str(i,value) || "null";
               v
               =
               partial.length === 0
                ?"[]"
                :gap
                  ?"[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]"
                  :"[" + partial.join(",") + "]";
               gap = mind;
               return v}
             if(rep && typeof rep === "object")
              {length = rep.length;
               for(i = 0;i < length;i += 1)
                if(typeof rep[i] === "string")
                 {k = rep[i];
                  v = str(k,value);
                  if(v)partial.push(quote(k) + (gap?": ":":") + v)}}
             else
              for(k in value)
               if(Object.prototype.hasOwnProperty.call(value,k))
                {v = str(k,value);
                 if(v)partial.push(quote(k) + (gap?": ":":") + v)}
             v
             =
             partial.length === 0
              ?"{}"
              :gap
                ?"{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}"
                :"{" + partial.join(",") + "}";
             gap = mind;
             return v
            }}
        if(typeof JSON.stringify !== "function")
         {meta
          =
          {"\b":"\\b",
           "\t":"\\t",
           "\n":"\\n",
           "\f":"\\f",
           "\r":"\\r",
           '"':'\\"',
           "\\":"\\\\"};
          JSON.stringify
          =
          function(value,replacer,space)
           {var i;
            gap = "";
            indent = "";
            if(typeof space === "number")
             for(i = 0;i < space;i += 1)indent += " ";
            else
             if(typeof space === "string")indent = space;
            rep = replacer;
            if
             (replacer
              &&
              typeof replacer
              !==
              "function"
              &&
              (typeof replacer
               !==
               "object"
               ||
               typeof replacer.length
               !==
               "number"))
             throw new Error("JSON.stringify");
            return str("",{"":value})}}
        if(typeof JSON.parse !== "function")
         JSON.parse
         =
         function(text,reviver)
          {var j;
           function walk(holder,key)
            {var k,v,value=holder[key];
             if(value && typeof value === "object")
              for(k in value)
               if(Object.prototype.hasOwnProperty.call(value,k))
                {v = walk(value,k);
                 if(v !== undefined)value[k] = v;else delete value[k]}
             return reviver.call(holder,key,value)}
           text = String(text);
           rx_dangerous.lastIndex = 0;
           if(rx_dangerous.test(text))
            text
            =
            text.replace
             (rx_dangerous,
              function(a)
               {return "\\u"
                       +
                       ("0000" + a.charCodeAt(0).toString(16)).slice(- 4)});
           if
            (rx_one.test
              (text.replace(rx_two,"@").replace(rx_three,"]").replace
                (rx_four,"")))
            {j = eval("(" + text + ")");
             return typeof reviver === "function"?walk({"":j},""):j}
           throw new SyntaxError("JSON.parse")}}
      ());
    function caml_json(){return JSON}
    function caml_unmount(name)
     {var path=caml_make_path(name),name=path.join("/") + "/",idx=- 1;
      for(var i=0;i < jsoo_mount_point.length;i++)
       if(jsoo_mount_point[i].path == name)idx = i;
      if(idx > - 1)jsoo_mount_point.splice(idx,1);
      return 0}
    function caml_ml_pos_in_64(chanid)
     {return caml_int64_of_float(caml_ml_channels[chanid].offset)}
    function caml_register_channel_for_spacetime(_channel){return 0}
    function caml_string_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_string_bound_error();
      return caml_string_unsafe_set(s,i,c)}
    function caml_ml_pos_out(chanid)
     {caml_ml_flush(chanid);return caml_ml_channels[chanid].offset}
    function caml_spacetime_enabled(_unit){return 0}
    function caml_bytes_notequal(s1,s2){return 1 - caml_string_equal(s1,s2)}
    function caml_runtime_parameters(_unit){return caml_new_string("")}
    function caml_js_object(a)
     {var o={};
      for(var i=1;i < a.length;i++){var p=a[i];o[p[1].toString()] = p[2]}
      return o}
    function caml_ba_create(kind,layout,dims_ml)
     {var
       dims=caml_js_from_array(dims_ml),
       data=caml_ba_create_buffer(kind,caml_ba_get_size(dims));
      return caml_ba_create_unsafe(kind,layout,dims,data)}
    function caml_weak_blit(a1,i1,a2,i2,len)
     {caml_array_blit
       (a1,caml_ephe_key_offset + i1 - 1,a2,caml_ephe_key_offset + i2 - 1,len);
      return 0}
    function caml_bswap16(x){return (x & 0x00FF) << 8 | (x & 0xFF00) >> 8}
    function caml_final_register(){return 0}
    function caml_ml_set_binary_mode(chanid,mode)
     {var chan=caml_ml_channels[chanid],data=caml_global_data.fds[chan.fd];
      data.flags.text = ! mode;
      data.flags.binary = mode;
      return 0}
    function caml_string_get16(s,i)
     {if(i >>> 0 >= s.l - 1)caml_string_bound_error();
      var b1=caml_string_unsafe_get(s,i),b2=caml_string_unsafe_get(s,i + 1);
      return b2 << 8 | b1}
    function caml_ephe_unset_data(x,data)
     {x[caml_ephe_data_offset] = undefined;return 0}
    function caml_output_value(chanid,v,flags)
     {var s=caml_output_value_to_string(v,flags);
      caml_ml_output(chanid,s,0,caml_ml_string_length(s));
      return 0}
    function caml_ba_get_3(ba,i0,i1,i2){return ba.get(ba.offset([i0,i1,i2]))}
    var caml_ephe_blit_key=caml_weak_blit;
    function caml_check_bound(array,index)
     {if(index >>> 0 >= array.length - 1)caml_array_bound_error();
      return array}
    function caml_bytes_of_string(s){return s}
    function caml_hash_mix_string(h,v)
     {switch(v.t & 6)
       {default:caml_convert_string_to_bytes(v);case 0:
         h = caml_hash_mix_string_str(h,v.c);break;
        case 2:h = caml_hash_mix_string_arr(h,v.c)
        }
      return h}
    function caml_hash(count,limit,seed,obj)
     {var queue,rd,wr,sz,num,h,v,i,len;
      sz = limit;
      if(sz < 0 || sz > 256)sz = 256;
      num = count;
      h = seed;
      queue = [obj];
      rd = 0;
      wr = 1;
      while(rd < wr && num > 0)
       {v = queue[rd++];
        if(v && v.caml_custom)
         {if
           (caml_custom_ops[v.caml_custom]
            &&
            caml_custom_ops[v.caml_custom].hash)
           {var hh=caml_custom_ops[v.caml_custom].hash(v);
            h = caml_hash_mix_int(h,hh);
            num--}}
        else
         if(v instanceof Array && v[0] === (v[0] | 0))
          switch(v[0])
           {case 248:h = caml_hash_mix_int(h,v[2]);num--;break;
            case 250:queue[--rd] = v[1];break;
            case 255:h = caml_hash_mix_int64(h,v);num--;break;
            default:
             var tag=v.length - 1 << 10 | v[0];
             h = caml_hash_mix_int(h,tag);
             for(i = 1,len = v.length;i < len;i++)
              {if(wr >= sz)break;queue[wr++] = v[i]}
             break}
         else
          if(v instanceof MlBytes)
           {h = caml_hash_mix_string(h,v);num--}
          else
           if(v === (v | 0))
            {h = caml_hash_mix_int(h,v + v + 1);num--}
           else
            if(v === + v){h = caml_hash_mix_float(h,v);num--}}
      h = caml_hash_mix_final(h);
      return h & 0x3FFFFFFF}
    function caml_obj_tag(x)
     {if(x instanceof Array && x[0] == x[0] >>> 0)
       return x[0];
      else
       if(x instanceof MlBytes)
        return 252;
       else
        if(x instanceof Function || typeof x == "function")
         return 247;
        else
         if(x && x.caml_custom)return 255;else return 1000}
    function caml_js_export_var()
     {return typeof module !== "undefined" && module && module.exports
              ?module.exports
              :joo_global_object}
    function caml_bytes_get32(s,i)
     {if(i >>> 0 >= s.l - 3)caml_string_bound_error();
      var
       b1=caml_string_unsafe_get(s,i),
       b2=caml_string_unsafe_get(s,i + 1),
       b3=caml_string_unsafe_get(s,i + 2),
       b4=caml_string_unsafe_get(s,i + 3);
      return b4 << 24 | b3 << 16 | b2 << 8 | b1}
    function caml_frexp_float(x)
     {if(x == 0 || ! isFinite(x))return [0,x,0];
      var neg=x < 0;
      if(neg)x = - x;
      var exp=Math.max(- 1023,jsoo_floor_log2(x) + 1);
      x *= Math.pow(2,- exp);
      while(x < 0.5){x *= 2;exp--}
      while(x >= 1){x *= 0.5;exp++}
      if(neg)x = - x;
      return [0,x,exp]}
    function caml_string_get64(s,i)
     {if(i >>> 0 >= s.l - 7)caml_string_bound_error();
      var a=new Array(8);
      for(var j=0;j < 8;j++)a[7 - j] = caml_string_unsafe_get(s,i + j);
      return caml_int64_of_bytes(a)}
    function caml_ml_pos_out_64(chanid)
     {caml_ml_flush(chanid);
      return caml_int64_of_float(caml_ml_channels[chanid].offset)}
    function caml_set_static_env(k,v)
     {if(! joo_global_object.jsoo_static_env)
       joo_global_object.jsoo_static_env = {};
      joo_global_object.jsoo_static_env[k] = v;
      return 0}
    function caml_ba_change_layout(ba,layout)
     {if(ba.layout == layout)return ba;
      var new_dims=[];
      for(var i=0;i < ba.dims.length;i++)
       new_dims[i] = ba.dims[ba.dims.length - i - 1];
      return caml_ba_create_unsafe(ba.kind,layout,new_dims,ba.data)}
    function caml_js_new(c,a)
     {switch(a.length)
       {case 1:return new c();
        case 2:return new c(a[1]);
        case 3:return new c(a[1],a[2]);
        case 4:return new c(a[1],a[2],a[3]);
        case 5:return new c(a[1],a[2],a[3],a[4]);
        case 6:return new c(a[1],a[2],a[3],a[4],a[5]);
        case 7:return new c(a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:return new c(a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
      function F(){return c.apply(this,caml_js_from_array(a))}
      F.prototype = c.prototype;
      return new F()}
    function caml_format_int(fmt,i)
     {if(caml_jsbytes_of_string(fmt) == "%d")return caml_new_string("" + i);
      var f=caml_parse_format(fmt);
      if(i < 0)if(f.signedconv){f.sign = - 1;i = - i}else i >>>= 0;
      var s=i.toString(f.base);
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - s.length;
        if(n > 0)s = caml_str_repeat(n,"0") + s}
      return caml_finish_formatting(f,s)}
    function caml_obj_truncate(x,s)
     {if(s <= 0 || s + 1 > x.length)caml_invalid_argument("Obj.truncate");
      if(x.length != s + 1)x.length = s + 1;
      return 0}
    function is_digit_odd(nat,ofs){if(nat.data[ofs] & 1)return 1;return 0}
    function caml_runtime_variant(_unit){return caml_new_string("")}
    function caml_array_concat(l)
     {var a=[0];
      while(l !== 0)
       {var b=l[1];for(var i=1;i < b.length;i++)a.push(b[i]);l = l[2]}
      return a}
    function caml_ml_open_descriptor_out(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.rdonly)caml_raise_sys_error("fd " + fd + " is readonly");
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:true,
         buffer:""};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function caml_ephe_set_data(x,data)
     {x[caml_ephe_data_offset] = data;return 0}
    function caml_make_float_vect(len)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 254;
      for(var i=1;i < len;i++)b[i] = 0;
      return b}
    function caml_greaterequal(x,y)
     {return + (caml_compare_val(x,y,false) >= 0)}
    function caml_get_exception_raw_backtrace(){return [0]}
    function caml_log1p_float(x)
     {var y=1 + x,z=y - 1;return z == 0?x:x * Math.log(y) / z}
    function caml_string_get(s,i)
     {if(i >>> 0 >= s.l)caml_string_bound_error();
      return caml_string_unsafe_get(s,i)}
    function caml_int64_or(x,y)
     {return [255,x[1] | y[1],x[2] | y[2],x[3] | y[3]]}
    function caml_lazy_make_forward(v){return [250,v]}
    function lor_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] |= nat2.data[ofs2];return 0}
    function caml_js_on_ie()
     {var
       ua=
        joo_global_object.navigator?joo_global_object.navigator.userAgent:"";
      return ua.indexOf("MSIE") != - 1 && ua.indexOf("Opera") != 0}
    function caml_int64_shift_right(x,s)
     {s = s & 63;
      if(s == 0)return x;
      var h=x[3] << 16 >> 16;
      if(s < 24)
       return [255,
               (x[1] >> s | x[2] << 24 - s) & 0xffffff,
               (x[2] >> s | h << 24 - s) & 0xffffff,
               x[3] << 16 >> s >>> 16];
      var sign=x[3] << 16 >> 31;
      if(s < 48)
       return [255,
               (x[2] >> s - 24 | x[3] << 48 - s) & 0xffffff,
               x[3] << 16 >> s - 24 >> 16 & 0xffffff,
               sign & 0xffff];
      return [255,
              x[3] << 16 >> s - 32 & 0xffffff,
              sign & 0xffffff,
              sign & 0xffff]}
    function caml_ba_layout(ba){return ba.layout}
    function caml_convert_raw_backtrace(){return [0]}
    function caml_array_set(array,index,newval)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      array[index + 1] = newval;
      return 0}
    function caml_bytes_greaterequal(s1,s2)
     {return caml_bytes_lessequal(s2,s1)}
    function set_digit_nat(nat,ofs,digit){nat.data[ofs] = digit;return 0}
    function caml_update_dummy(x,y)
     {if(typeof y === "function"){x.fun = y;return 0}
      if(y.fun){x.fun = y.fun;return 0}
      var i=y.length;
      while(i--)x[i] = y[i];
      return 0}
    function caml_CamlinternalMod_update_mod(shape,real,x)
     {if(typeof shape === "number")
       switch(shape)
        {case 0:real.fun = x;break;case 1:default:caml_update_dummy(real,x)}
      else
       switch(shape[0])
        {case 0:
          for(var i=1;i < shape[1].length;i++)
           caml_CamlinternalMod_update_mod(shape[1][i],real[i],x[i]);
          break
         }
      return 0}
    function caml_ml_output_int(chanid,i)
     {var
       arr=[i >> 24 & 0xFF,i >> 16 & 0xFF,i >> 8 & 0xFF,i & 0xFF],
       s=caml_string_of_array(arr);
      caml_ml_output(chanid,s,0,4);
      return 0}
    function caml_obj_with_tag(tag,x)
     {var l=x.length,a=new Array(l);
      a[0] = tag;
      for(var i=1;i < l;i++)a[i] = x[i];
      return a}
    var caml_initial_time=new Date().getTime() * 0.001;
    function caml_sys_time()
     {var now=new Date().getTime();return now * 0.001 - caml_initial_time}
    function caml_ml_channel_size(chanid)
     {var chan=caml_ml_channels[chanid];return chan.file.length()}
    function caml_raw_backtrace_slot()
     {caml_invalid_argument
       ("Printexc.get_raw_backtrace_slot: index out of bounds")}
    function caml_int64_is_min_int(x)
     {return x[3] == 0x8000 && (x[1] | x[2]) == 0}
    function caml_hexstring_of_float(x,prec,style)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_js_to_string("nan");
        return caml_js_to_string(x > 0?"infinity":"-infinity")}
      var sign=x == 0 && 1 / x == - Infinity?1:x >= 0?0:1;
      if(sign)x = - x;
      var exp=0;
      if(x == 0)
       ;
      else
       if(x < 1)
        while(x < 1 && exp > - 1022){x *= 2;exp--}
       else
        while(x >= 2){x /= 2;exp++}
      var exp_sign=exp < 0?"":"+",sign_str="";
      if(sign)
       sign_str = "-";
      else
       switch(style)
        {case 43:sign_str = "+";break;
         case 32:sign_str = " ";break;
         default:break}
      if(prec >= 0 && prec < 13)
       {var cst=Math.pow(2,prec * 4);x = Math.round(x * cst) / cst}
      var x_str=x.toString(16);
      if(prec >= 0)
       {var idx=x_str.indexOf(".");
        if(idx < 0)
         x_str += "." + caml_str_repeat(prec,"0");
        else
         {var size=idx + 1 + prec;
          if(x_str.length < size)
           x_str += caml_str_repeat(size - x_str.length,"0");
          else
           x_str = x_str.substr(0,size)}}
      return caml_js_to_string
              (sign_str + "0x" + x_str + "p" + exp_sign + exp.toString(10))}
    function caml_js_wrap_meth_callback_strict(arity,f)
     {return function()
       {var n=arguments.length;
        if(n == arity)return caml_call_gen(f,raw_array_cons(arguments,this));
        var args=new Array(arity + 1);
        args[0] = this;
        for(var i=1;i < n && i <= arity;i++)args[i] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_backtrace_status(){return 0}
    function caml_install_signal_handler(){return 0}
    function caml_sys_argv(a){return caml_argv}
    function caml_ba_fill(ba,v){ba.fill(v);return 0}
    function caml_modf_float(x)
     {if(isFinite(x))
       {var neg=1 / x < 0;
        x = Math.abs(x);
        var i=Math.floor(x),f=x - i;
        if(neg){i = - i;f = - f}
        return [0,f,i]}
      if(isNaN(x))return [0,NaN,NaN];
      return [0,1 / x,x]}
    function caml_gc_get(){return [0,0,0,0,0,0,0,0,0]}
    function caml_float_compare(x,y)
     {if(x === y)return 0;
      if(x < y)return - 1;
      if(x > y)return 1;
      if(x === x)return 1;
      if(y === y)return - 1;
      return 0}
    function caml_string_set32(s,i,i32){return caml_bytes_set32(s,i,i32)}
    function caml_parse_engine(tables,env,cmd,arg)
     {var
       ERRCODE=256,
       loop=6,
       testshift=7,
       shift=8,
       shift_recover=9,
       reduce=10,
       READ_TOKEN=0,
       RAISE_PARSE_ERROR=1,
       GROW_STACKS_1=2,
       GROW_STACKS_2=3,
       COMPUTE_SEMANTIC_ACTION=4,
       CALL_ERROR_FUNCTION=5,
       env_s_stack=1,
       env_v_stack=2,
       env_symb_start_stack=3,
       env_symb_end_stack=4,
       env_stacksize=5,
       env_stackbase=6,
       env_curr_char=7,
       env_lval=8,
       env_symb_start=9,
       env_symb_end=10,
       env_asp=11,
       env_rule_len=12,
       env_rule_number=13,
       env_sp=14,
       env_state=15,
       env_errflag=16,
       tbl_transl_const=2,
       tbl_transl_block=3,
       tbl_lhs=4,
       tbl_len=5,
       tbl_defred=6,
       tbl_dgoto=7,
       tbl_sindex=8,
       tbl_rindex=9,
       tbl_gindex=10,
       tbl_tablesize=11,
       tbl_table=12,
       tbl_check=13;
      if(! tables.dgoto)
       {tables.defred = caml_lex_array(tables[tbl_defred]);
        tables.sindex = caml_lex_array(tables[tbl_sindex]);
        tables.check = caml_lex_array(tables[tbl_check]);
        tables.rindex = caml_lex_array(tables[tbl_rindex]);
        tables.table = caml_lex_array(tables[tbl_table]);
        tables.len = caml_lex_array(tables[tbl_len]);
        tables.lhs = caml_lex_array(tables[tbl_lhs]);
        tables.gindex = caml_lex_array(tables[tbl_gindex]);
        tables.dgoto = caml_lex_array(tables[tbl_dgoto])}
      var
       res=0,
       n,
       n1,
       n2,
       state1,
       sp=env[env_sp],
       state=env[env_state],
       errflag=env[env_errflag];
      exit:
      for(;;)
       switch(cmd)
        {case 0:state = 0;errflag = 0;
         case 6:
          n = tables.defred[state];
          if(n != 0){cmd = reduce;break}
          if(env[env_curr_char] >= 0){cmd = testshift;break}
          res = READ_TOKEN;
          break exit;
         case 1:
          if(arg instanceof Array)
           {env[env_curr_char] = tables[tbl_transl_block][arg[0] + 1];
            env[env_lval] = arg[1]}
          else
           {env[env_curr_char] = tables[tbl_transl_const][arg + 1];
            env[env_lval] = 0}
         case 7:
          n1 = tables.sindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {cmd = shift;break}
          n1 = tables.rindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {n = tables.table[n2];cmd = reduce;break}
          if(errflag <= 0){res = CALL_ERROR_FUNCTION;break exit}
         case 5:
          if(errflag < 3)
           {errflag = 3;
            for(;;)
             {state1 = env[env_s_stack][sp + 1];
              n1 = tables.sindex[state1];
              n2 = n1 + ERRCODE;
              if
               (n1
                !=
                0
                &&
                n2
                >=
                0
                &&
                n2
                <=
                tables[tbl_tablesize]
                &&
                tables.check[n2]
                ==
                ERRCODE)
               {cmd = shift_recover;break}
              else
               {if(sp <= env[env_stackbase])return RAISE_PARSE_ERROR;sp--}}}
          else
           {if(env[env_curr_char] == 0)return RAISE_PARSE_ERROR;
            env[env_curr_char] = - 1;
            cmd = loop;
            break}
         case 8:env[env_curr_char] = - 1;if(errflag > 0)errflag--;
         case 9:
          state = tables.table[n2];
          sp++;
          if(sp >= env[env_stacksize]){res = GROW_STACKS_1;break exit}
         case 2:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = env[env_lval];
          env[env_symb_start_stack][sp + 1] = env[env_symb_start];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end];
          cmd = loop;
          break;
         case 10:
          var m=tables.len[n];
          env[env_asp] = sp;
          env[env_rule_number] = n;
          env[env_rule_len] = m;
          sp = sp - m + 1;
          m = tables.lhs[n];
          state1 = env[env_s_stack][sp];
          n1 = tables.gindex[m];
          n2 = n1 + state1;
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            state1)
           state = tables.table[n2];
          else
           state = tables.dgoto[m];
          if(sp >= env[env_stacksize]){res = GROW_STACKS_2;break exit}
         case 3:res = COMPUTE_SEMANTIC_ACTION;break exit;
         case 4:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = arg;
          var asp=env[env_asp];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end_stack][asp + 1];
          if(sp > asp)
           env[env_symb_start_stack][sp + 1]
           =
           env[env_symb_end_stack][asp + 1];
          cmd = loop;
          break;
         default:return RAISE_PARSE_ERROR}
      env[env_sp] = sp;
      env[env_state] = state;
      env[env_errflag] = errflag;
      return res}
    function caml_array_fill(array,ofs,len,v)
     {for(var i=0;i < len;i++)array[ofs + i + 1] = v;return 0}
    function caml_string_notequal(s1,s2){return 1 - caml_string_equal(s1,s2)}
    function caml_bytes_greaterthan(s1,s2){return caml_bytes_lessthan(s2,s1)}
    function caml_ml_set_channel_output(chanid,f)
     {var chan=caml_ml_channels[chanid];
      caml_global_data.fds[chan.fd].output = f;
      return 0}
    function caml_read_file_content(name)
     {var root=resolve_fs_device(name);
      if(root.device.exists(root.rest))
       {var
         file=root.device.open(root.rest,{rdonly:1}),
         len=file.length(),
         buf=caml_create_bytes(len);
        file.read(0,buf,0,len);
        return buf}
      caml_raise_no_such_file(name)}
    function caml_js_to_float(x){return x}
    joo_global_object.jsoo_runtime
    =
    {caml_ephe_check_data:caml_ephe_check_data,
     caml_ephe_unset_data:caml_ephe_unset_data,
     caml_ephe_set_data:caml_ephe_set_data,
     caml_ephe_get_data_copy:caml_ephe_get_data_copy,
     caml_ephe_get_data:caml_ephe_get_data,
     caml_ephe_blit_data:caml_ephe_blit_data,
     caml_ephe_unset_key:caml_ephe_unset_key,
     caml_ephe_set_key:caml_ephe_set_key,
     caml_ephe_check_key:caml_ephe_check_key,
     caml_ephe_get_key_copy:caml_ephe_get_key_copy,
     caml_ephe_get_key:caml_ephe_get_key,
     caml_ephe_blit_key:caml_ephe_blit_key,
     caml_ephe_create:caml_ephe_create,
     caml_weak_blit:caml_weak_blit,
     caml_weak_check:caml_weak_check,
     caml_weak_get_copy:caml_weak_get_copy,
     caml_weak_get:caml_weak_get,
     caml_weak_set:caml_weak_set,
     caml_weak_create:caml_weak_create,
     caml_ephe_data_offset:caml_ephe_data_offset,
     caml_ephe_key_offset:caml_ephe_key_offset,
     win_handle_fd:win_handle_fd,
     win_cleanup:win_cleanup,
     win_startup:win_startup,
     unix_mktime:unix_mktime,
     unix_localtime:unix_localtime,
     unix_gmtime:unix_gmtime,
     unix_time:unix_time,
     unix_gettimeofday:unix_gettimeofday,
     caml_is_js:caml_is_js,
     caml_spacetime_only_works_for_native_code:
     caml_spacetime_only_works_for_native_code,
     caml_register_channel_for_spacetime:caml_register_channel_for_spacetime,
     caml_spacetime_enabled:caml_spacetime_enabled,
     caml_sys_isatty:caml_sys_isatty,
     caml_runtime_parameters:caml_runtime_parameters,
     caml_runtime_variant:caml_runtime_variant,
     caml_ml_runtime_warnings_enabled:caml_ml_runtime_warnings_enabled,
     caml_ml_enable_runtime_warnings:caml_ml_enable_runtime_warnings,
     caml_runtime_warnings:caml_runtime_warnings,
     caml_list_to_js_array:caml_list_to_js_array,
     caml_list_of_js_array:caml_list_of_js_array,
     caml_int64_bswap:caml_int64_bswap,
     caml_int32_bswap:caml_int32_bswap,
     caml_bswap16:caml_bswap16,
     caml_convert_raw_backtrace_slot:caml_convert_raw_backtrace_slot,
     caml_install_signal_handler:caml_install_signal_handler,
     caml_fresh_oo_id:caml_fresh_oo_id,
     caml_set_oo_id:caml_set_oo_id,
     caml_oo_last_id:caml_oo_last_id,
     unix_inet_addr_of_string:unix_inet_addr_of_string,
     caml_sys_executable_name:caml_sys_executable_name,
     caml_sys_modify_argv:caml_sys_modify_argv,
     caml_sys_argv:caml_sys_argv,
     caml_sys_get_argv:caml_sys_get_argv,
     caml_executable_name:caml_executable_name,
     caml_argv:caml_argv,
     caml_sys_exit:caml_sys_exit,
     caml_sys_getenv:caml_sys_getenv,
     caml_set_static_env:caml_set_static_env,
     caml_get_current_callstack:caml_get_current_callstack,
     caml_restore_raw_backtrace:caml_restore_raw_backtrace,
     caml_raw_backtrace_slot:caml_raw_backtrace_slot,
     caml_raw_backtrace_next_slot:caml_raw_backtrace_next_slot,
     caml_raw_backtrace_length:caml_raw_backtrace_length,
     caml_convert_raw_backtrace:caml_convert_raw_backtrace,
     caml_record_backtrace:caml_record_backtrace,
     caml_get_exception_raw_backtrace:caml_get_exception_raw_backtrace,
     caml_get_exception_backtrace:caml_get_exception_backtrace,
     caml_backtrace_status:caml_backtrace_status,
     caml_final_release:caml_final_release,
     caml_final_register_called_without_value:
     caml_final_register_called_without_value,
     caml_final_register:caml_final_register,
     caml_get_public_method:caml_get_public_method,
     caml_array_blit:caml_array_blit,
     caml_array_concat:caml_array_concat,
     caml_array_append:caml_array_append,
     caml_array_sub:caml_array_sub,
     caml_sys_system_command:caml_sys_system_command,
     caml_sys_const_ostype_win32:caml_sys_const_ostype_win32,
     caml_sys_const_ostype_unix:caml_sys_const_ostype_unix,
     caml_sys_const_ostype_cygwin:caml_sys_const_ostype_cygwin,
     caml_sys_const_max_wosize:caml_sys_const_max_wosize,
     caml_sys_const_int_size:caml_sys_const_int_size,
     caml_sys_const_word_size:caml_sys_const_word_size,
     caml_sys_const_big_endian:caml_sys_const_big_endian,
     caml_sys_random_seed:caml_sys_random_seed,
     caml_sys_const_backend_type:caml_sys_const_backend_type,
     caml_sys_get_config:caml_sys_get_config,
     caml_sys_time:caml_sys_time,
     caml_hash:caml_hash,
     caml_hash_mix_string:caml_hash_mix_string,
     caml_hash_mix_string_arr:caml_hash_mix_string_arr,
     caml_hash_mix_string_str:caml_hash_mix_string_str,
     caml_hash_mix_int64:caml_hash_mix_int64,
     caml_hash_mix_float:caml_hash_mix_float,
     caml_hash_mix_final:caml_hash_mix_final,
     caml_hash_mix_int:caml_hash_mix_int,
     caml_hash_univ_param:caml_hash_univ_param,
     caml_format_float:caml_format_float,
     caml_format_int:caml_format_int,
     caml_finish_formatting:caml_finish_formatting,
     caml_parse_format:caml_parse_format,
     caml_is_printable:caml_is_printable,
     caml_float_of_string:caml_float_of_string,
     caml_int_of_string:caml_int_of_string,
     caml_parse_digit:caml_parse_digit,
     caml_parse_sign_and_base:caml_parse_sign_and_base,
     caml_lessthan:caml_lessthan,
     caml_lessequal:caml_lessequal,
     caml_greaterthan:caml_greaterthan,
     caml_greaterequal:caml_greaterequal,
     caml_notequal:caml_notequal,
     caml_equal:caml_equal,
     caml_int_compare:caml_int_compare,
     caml_compare:caml_compare,
     caml_compare_val:caml_compare_val,
     caml_compare_val_number_custom:caml_compare_val_number_custom,
     caml_compare_val_get_custom:caml_compare_val_get_custom,
     caml_compare_val_tag:caml_compare_val_tag,
     caml_floatarray_create:caml_floatarray_create,
     caml_make_float_vect:caml_make_float_vect,
     caml_make_vect:caml_make_vect,
     caml_check_bound:caml_check_bound,
     caml_array_fill:caml_array_fill,
     caml_array_get:caml_array_get,
     caml_array_set:caml_array_set,
     caml_mod:caml_mod,
     caml_div:caml_div,
     caml_mul:caml_mul,
     caml_lazy_make_forward:caml_lazy_make_forward,
     caml_obj_make_forward:caml_obj_make_forward,
     caml_obj_truncate:caml_obj_truncate,
     caml_obj_dup:caml_obj_dup,
     caml_obj_with_tag:caml_obj_with_tag,
     caml_obj_block:caml_obj_block,
     caml_obj_set_tag:caml_obj_set_tag,
     caml_obj_tag:caml_obj_tag,
     caml_obj_is_block:caml_obj_is_block,
     caml_update_dummy:caml_update_dummy,
     caml_array_bound_error:caml_array_bound_error,
     caml_raise_not_found:caml_raise_not_found,
     caml_raise_zero_divide:caml_raise_zero_divide,
     caml_raise_end_of_file:caml_raise_end_of_file,
     caml_invalid_argument:caml_invalid_argument,
     caml_js_error_of_exception:caml_js_error_of_exception,
     caml_exn_with_js_backtrace:caml_exn_with_js_backtrace,
     caml_wrap_exception:caml_wrap_exception,
     caml_failwith:caml_failwith,
     caml_raise_sys_error:caml_raise_sys_error,
     caml_raise_with_string:caml_raise_with_string,
     caml_raise_with_arg:caml_raise_with_arg,
     caml_return_exn_constant:caml_return_exn_constant,
     caml_raise_constant:caml_raise_constant,
     caml_get_global_data:caml_get_global_data,
     caml_register_global:caml_register_global,
     caml_global_data:caml_global_data,
     caml_named_value:caml_named_value,
     caml_register_named_value:caml_register_named_value,
     caml_named_values:caml_named_values,
     caml_call_gen:caml_call_gen,
     raw_array_append_one:raw_array_append_one,
     raw_array_cons:raw_array_cons,
     raw_array_copy:raw_array_copy,
     raw_array_sub:raw_array_sub,
     caml_json:caml_json,
     JSON:JSON,
     caml_set_parser_trace:caml_set_parser_trace,
     caml_parse_engine:caml_parse_engine,
     deserialize_nat:deserialize_nat,
     serialize_nat:serialize_nat,
     lxor_digit_nat:lxor_digit_nat,
     lor_digit_nat:lor_digit_nat,
     land_digit_nat:land_digit_nat,
     compare_nat_real:compare_nat_real,
     compare_nat:compare_nat,
     compare_digits_nat:compare_digits_nat,
     shift_right_nat:shift_right_nat,
     div_nat:div_nat,
     div_digit_nat:div_digit_nat,
     div_helper:div_helper,
     shift_left_nat:shift_left_nat,
     square_nat:square_nat,
     mult_nat:mult_nat,
     mult_digit_nat:mult_digit_nat,
     sub_nat:sub_nat,
     decr_nat:decr_nat,
     complement_nat:complement_nat,
     add_nat:add_nat,
     incr_nat:incr_nat,
     is_digit_odd:is_digit_odd,
     is_digit_zero:is_digit_zero,
     is_digit_int:is_digit_int,
     num_leading_zero_bits_in_digit:num_leading_zero_bits_in_digit,
     num_digits_nat:num_digits_nat,
     nth_digit_nat_native:nth_digit_nat_native,
     set_digit_nat_native:set_digit_nat_native,
     nth_digit_nat:nth_digit_nat,
     set_digit_nat:set_digit_nat,
     blit_nat:blit_nat,
     set_to_zero_nat:set_to_zero_nat,
     create_nat:create_nat,
     nat_of_array:nat_of_array,
     caml_hash_nat:caml_hash_nat,
     MlNat:MlNat,
     initialize_nat:initialize_nat,
     caml_bytes_of_string:caml_bytes_of_string,
     caml_string_of_bytes:caml_string_of_bytes,
     caml_ml_bytes_length:caml_ml_bytes_length,
     caml_ml_string_length:caml_ml_string_length,
     caml_blit_string:caml_blit_string,
     caml_blit_bytes:caml_blit_bytes,
     caml_fill_string:caml_fill_string,
     caml_fill_bytes:caml_fill_bytes,
     caml_bytes_greaterthan:caml_bytes_greaterthan,
     caml_string_greaterthan:caml_string_greaterthan,
     caml_bytes_greaterequal:caml_bytes_greaterequal,
     caml_string_greaterequal:caml_string_greaterequal,
     caml_bytes_lessthan:caml_bytes_lessthan,
     caml_string_lessthan:caml_string_lessthan,
     caml_bytes_lessequal:caml_bytes_lessequal,
     caml_string_lessequal:caml_string_lessequal,
     caml_bytes_notequal:caml_bytes_notequal,
     caml_string_notequal:caml_string_notequal,
     caml_bytes_equal:caml_bytes_equal,
     caml_string_equal:caml_string_equal,
     caml_bytes_compare:caml_bytes_compare,
     caml_string_compare:caml_string_compare,
     caml_string_of_array:caml_string_of_array,
     caml_new_string:caml_new_string,
     caml_create_bytes:caml_create_bytes,
     caml_create_string:caml_create_string,
     caml_js_to_string:caml_js_to_string,
     caml_jsbytes_of_string:caml_jsbytes_of_string,
     caml_array_of_string:caml_array_of_string,
     caml_convert_string_to_array:caml_convert_string_to_array,
     caml_convert_string_to_bytes:caml_convert_string_to_bytes,
     MlBytes:MlBytes,
     caml_bytes_set:caml_bytes_set,
     caml_string_set64:caml_string_set64,
     caml_bytes_set64:caml_bytes_set64,
     caml_string_set32:caml_string_set32,
     caml_bytes_set32:caml_bytes_set32,
     caml_string_set16:caml_string_set16,
     caml_bytes_set16:caml_bytes_set16,
     caml_string_set:caml_string_set,
     caml_bytes_get:caml_bytes_get,
     caml_bytes_get64:caml_bytes_get64,
     caml_string_get64:caml_string_get64,
     caml_bytes_get32:caml_bytes_get32,
     caml_string_get32:caml_string_get32,
     caml_bytes_get16:caml_bytes_get16,
     caml_string_get16:caml_string_get16,
     caml_string_get:caml_string_get,
     caml_string_bound_error:caml_string_bound_error,
     caml_string_unsafe_set:caml_string_unsafe_set,
     caml_bytes_unsafe_set:caml_bytes_unsafe_set,
     caml_bytes_unsafe_get:caml_bytes_unsafe_get,
     caml_string_unsafe_get:caml_string_unsafe_get,
     caml_to_js_string:caml_to_js_string,
     caml_is_ascii:caml_is_ascii,
     caml_utf16_of_utf8:caml_utf16_of_utf8,
     caml_utf8_of_utf16:caml_utf8_of_utf16,
     caml_subarray_to_string:caml_subarray_to_string,
     caml_str_repeat:caml_str_repeat,
     caml_md5_string:caml_md5_string,
     caml_md5_chan:caml_md5_chan,
     caml_output_value_to_buffer:caml_output_value_to_buffer,
     caml_output_value_to_bytes:caml_output_value_to_bytes,
     caml_output_value_to_string:caml_output_value_to_string,
     caml_output_val:caml_output_val,
     caml_legacy_custom_code:caml_legacy_custom_code,
     MlObjectTable:MlObjectTable,
     caml_marshal_data_size:caml_marshal_data_size,
     caml_input_value_from_reader:caml_input_value_from_reader,
     caml_custom_ops:caml_custom_ops,
     caml_nativeint_unmarshal:caml_nativeint_unmarshal,
     caml_int32_unmarshal:caml_int32_unmarshal,
     caml_int64_marshal:caml_int64_marshal,
     caml_int64_unmarshal:caml_int64_unmarshal,
     caml_input_value_from_bytes:caml_input_value_from_bytes,
     caml_input_value_from_string:caml_input_value_from_string,
     caml_float_of_bytes:caml_float_of_bytes,
     BigStringReader:BigStringReader,
     MlBytesReader:MlBytesReader,
     caml_marshal_constants:caml_marshal_constants,
     caml_new_lex_engine:caml_new_lex_engine,
     caml_lex_engine:caml_lex_engine,
     caml_lex_array:caml_lex_array,
     caml_js_export_var:caml_js_export_var,
     caml_js_object:caml_js_object,
     caml_pure_js_expr:caml_pure_js_expr,
     caml_js_expr:caml_js_expr,
     caml_js_eval_string:caml_js_eval_string,
     caml_js_to_byte_string:caml_js_to_byte_string,
     caml_js_equals:caml_js_equals,
     caml_js_wrap_meth_callback_unsafe:caml_js_wrap_meth_callback_unsafe,
     caml_js_wrap_meth_callback_strict:caml_js_wrap_meth_callback_strict,
     caml_js_wrap_meth_callback_arguments:caml_js_wrap_meth_callback_arguments,
     caml_js_wrap_meth_callback:caml_js_wrap_meth_callback,
     caml_js_wrap_callback_strict:caml_js_wrap_callback_strict,
     caml_js_wrap_callback_arguments:caml_js_wrap_callback_arguments,
     caml_js_wrap_callback:caml_js_wrap_callback,
     caml_ojs_new_arr:caml_ojs_new_arr,
     caml_js_new:caml_js_new,
     caml_js_meth_call:caml_js_meth_call,
     caml_js_fun_call:caml_js_fun_call,
     caml_js_call:caml_js_call,
     caml_js_var:caml_js_var,
     caml_js_to_array:caml_js_to_array,
     caml_js_from_array:caml_js_from_array,
     caml_js_from_string:caml_js_from_string,
     caml_js_to_float:caml_js_to_float,
     caml_js_from_float:caml_js_from_float,
     caml_js_to_bool:caml_js_to_bool,
     caml_js_from_bool:caml_js_from_bool,
     js_print_stderr:js_print_stderr,
     js_print_stdout:js_print_stdout,
     caml_trampoline_return:caml_trampoline_return,
     caml_trampoline:caml_trampoline,
     caml_js_get_console:caml_js_get_console,
     caml_js_html_entities:caml_js_html_entities,
     caml_js_html_escape:caml_js_html_escape,
     caml_js_on_ie:caml_js_on_ie,
     caml_js_typeof:caml_js_typeof,
     caml_js_instanceof:caml_js_instanceof,
     caml_js_delete:caml_js_delete,
     caml_js_get:caml_js_get,
     caml_js_set:caml_js_set,
     caml_js_pure_expr:caml_js_pure_expr,
     caml_ml_output_int:caml_ml_output_int,
     caml_ml_pos_out_64:caml_ml_pos_out_64,
     caml_ml_pos_out:caml_ml_pos_out,
     caml_ml_seek_out_64:caml_ml_seek_out_64,
     caml_ml_seek_out:caml_ml_seek_out,
     caml_output_value:caml_output_value,
     caml_ml_output_char:caml_ml_output_char,
     caml_ml_output:caml_ml_output,
     caml_ml_output_bytes:caml_ml_output_bytes,
     caml_ml_flush:caml_ml_flush,
     caml_ml_input_scan_line:caml_ml_input_scan_line,
     caml_ml_pos_in_64:caml_ml_pos_in_64,
     caml_ml_pos_in:caml_ml_pos_in,
     caml_ml_seek_in_64:caml_ml_seek_in_64,
     caml_ml_seek_in:caml_ml_seek_in,
     caml_ml_input_int:caml_ml_input_int,
     caml_ml_input_char:caml_ml_input_char,
     caml_input_value:caml_input_value,
     caml_ml_input:caml_ml_input,
     caml_ml_may_refill_input:caml_ml_may_refill_input,
     caml_ml_refill_input:caml_ml_refill_input,
     caml_ml_set_channel_refill:caml_ml_set_channel_refill,
     caml_ml_set_channel_output:caml_ml_set_channel_output,
     caml_ml_channel_size_64:caml_ml_channel_size_64,
     caml_ml_channel_size:caml_ml_channel_size,
     caml_ml_close_channel:caml_ml_close_channel,
     caml_ml_set_binary_mode:caml_ml_set_binary_mode,
     caml_ml_open_descriptor_in:caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out:caml_ml_open_descriptor_out,
     caml_ml_out_channels_list:caml_ml_out_channels_list,
     caml_ml_channels:caml_ml_channels,
     caml_ml_set_channel_name:caml_ml_set_channel_name,
     caml_sys_open:caml_sys_open,
     caml_std_output:caml_std_output,
     caml_sys_close:caml_sys_close,
     caml_CamlinternalMod_update_mod:caml_CamlinternalMod_update_mod,
     caml_CamlinternalMod_init_mod:caml_CamlinternalMod_init_mod,
     caml_int64_hash:caml_int64_hash,
     caml_int64_to_bytes:caml_int64_to_bytes,
     caml_int64_of_bytes:caml_int64_of_bytes,
     caml_int64_hi32:caml_int64_hi32,
     caml_int64_lo32:caml_int64_lo32,
     caml_int64_create_lo_hi:caml_int64_create_lo_hi,
     caml_int64_create_lo_mi_hi:caml_int64_create_lo_mi_hi,
     caml_int64_of_string:caml_int64_of_string,
     caml_int64_format:caml_int64_format,
     caml_int64_of_float:caml_int64_of_float,
     caml_int64_to_float:caml_int64_to_float,
     caml_int64_to_int32:caml_int64_to_int32,
     caml_int64_of_int32:caml_int64_of_int32,
     caml_int64_mod:caml_int64_mod,
     caml_int64_div:caml_int64_div,
     caml_int64_udivmod:caml_int64_udivmod,
     caml_int64_lsr1:caml_int64_lsr1,
     caml_int64_lsl1:caml_int64_lsl1,
     caml_int64_shift_right:caml_int64_shift_right,
     caml_int64_shift_right_unsigned:caml_int64_shift_right_unsigned,
     caml_int64_shift_left:caml_int64_shift_left,
     caml_int64_xor:caml_int64_xor,
     caml_int64_or:caml_int64_or,
     caml_int64_and:caml_int64_and,
     caml_int64_is_minus_one:caml_int64_is_minus_one,
     caml_int64_is_min_int:caml_int64_is_min_int,
     caml_int64_is_negative:caml_int64_is_negative,
     caml_int64_is_zero:caml_int64_is_zero,
     caml_int64_mul:caml_int64_mul,
     caml_int64_sub:caml_int64_sub,
     caml_int64_add:caml_int64_add,
     caml_int64_neg:caml_int64_neg,
     caml_int64_compare:caml_int64_compare,
     caml_int64_ult:caml_int64_ult,
     caml_int64_ucompare:caml_int64_ucompare,
     caml_int64_offset:caml_int64_offset,
     caml_round_float:caml_round_float,
     caml_tanh_float:caml_tanh_float,
     caml_sinh_float:caml_sinh_float,
     caml_cosh_float:caml_cosh_float,
     caml_log10_float:caml_log10_float,
     caml_hypot_float:caml_hypot_float,
     caml_log1p_float:caml_log1p_float,
     caml_expm1_float:caml_expm1_float,
     caml_signbit_float:caml_signbit_float,
     caml_copysign_float:caml_copysign_float,
     caml_float_compare:caml_float_compare,
     caml_frexp_float:caml_frexp_float,
     caml_ldexp_float:caml_ldexp_float,
     caml_modf_float:caml_modf_float,
     caml_classify_float:caml_classify_float,
     caml_int32_float_of_bits:caml_int32_float_of_bits,
     caml_trunc_float:caml_trunc_float,
     caml_nextafter_float:caml_nextafter_float,
     caml_int64_float_of_bits:caml_int64_float_of_bits,
     caml_hexstring_of_float:caml_hexstring_of_float,
     caml_int32_bits_of_float:caml_int32_bits_of_float,
     caml_int64_bits_of_float:caml_int64_bits_of_float,
     jsoo_floor_log2:jsoo_floor_log2,
     caml_memprof_set:caml_memprof_set,
     caml_gc_get:caml_gc_get,
     caml_gc_set:caml_gc_set,
     caml_gc_stat:caml_gc_stat,
     caml_gc_quick_stat:caml_gc_quick_stat,
     caml_gc_counters:caml_gc_counters,
     caml_gc_compaction:caml_gc_compaction,
     caml_gc_full_major:caml_gc_full_major,
     caml_gc_major:caml_gc_major,
     caml_gc_minor:caml_gc_minor,
     MlNodeFile:MlNodeFile,
     MlNodeDevice:MlNodeDevice,
     fs_node_supported:fs_node_supported,
     MlFakeFile:MlFakeFile,
     MlFakeDevice:MlFakeDevice,
     caml_read_file_content:caml_read_file_content,
     caml_create_file:caml_create_file,
     caml_fs_init:caml_fs_init,
     caml_create_file_extern:caml_create_file_extern,
     caml_ba_map_file_bytecode:caml_ba_map_file_bytecode,
     caml_ba_map_file:caml_ba_map_file,
     caml_sys_rename:caml_sys_rename,
     caml_sys_is_directory:caml_sys_is_directory,
     caml_sys_remove:caml_sys_remove,
     caml_sys_read_directory:caml_sys_read_directory,
     caml_sys_file_exists:caml_sys_file_exists,
     caml_raise_not_a_dir:caml_raise_not_a_dir,
     caml_raise_no_such_file:caml_raise_no_such_file,
     caml_sys_chdir:caml_sys_chdir,
     caml_sys_getcwd:caml_sys_getcwd,
     caml_unmount:caml_unmount,
     caml_mount_autoload:caml_mount_autoload,
     resolve_fs_device:resolve_fs_device,
     caml_list_mount_point:caml_list_mount_point,
     jsoo_mount_point:jsoo_mount_point,
     caml_make_path:caml_make_path,
     MlFile:MlFile,
     caml_root:caml_root,
     caml_current_dir:caml_current_dir,
     caml_bigstring_blit_ba_to_bytes:caml_bigstring_blit_ba_to_bytes,
     caml_bigstring_blit_string_to_ba:caml_bigstring_blit_string_to_ba,
     caml_bigstring_blit_ba_to_ba:caml_bigstring_blit_ba_to_ba,
     caml_bigstring_memcmp:caml_bigstring_memcmp,
     bigstring_of_typed_array:bigstring_of_typed_array,
     bigstring_of_array_buffer:bigstring_of_array_buffer,
     bigstring_to_typed_array:bigstring_to_typed_array,
     bigstring_to_array_buffer:bigstring_to_array_buffer,
     caml_hash_mix_bigstring:caml_hash_mix_bigstring,
     caml_blit_string_to_bigstring:caml_blit_string_to_bigstring,
     caml_blit_bigstring_to_string:caml_blit_bigstring_to_string,
     caml_blit_bigstring_to_bigstring:caml_blit_bigstring_to_bigstring,
     caml_ba_hash:caml_ba_hash,
     caml_ba_create_from:caml_ba_create_from,
     caml_ba_deserialize:caml_ba_deserialize,
     caml_ba_serialize:caml_ba_serialize,
     caml_ba_reshape:caml_ba_reshape,
     caml_ba_slice:caml_ba_slice,
     caml_ba_sub:caml_ba_sub,
     caml_ba_blit:caml_ba_blit,
     caml_ba_fill:caml_ba_fill,
     caml_ba_set_3:caml_ba_set_3,
     caml_ba_set_2:caml_ba_set_2,
     caml_ba_set_1:caml_ba_set_1,
     caml_ba_uint8_set64:caml_ba_uint8_set64,
     caml_ba_uint8_set32:caml_ba_uint8_set32,
     caml_ba_uint8_set16:caml_ba_uint8_set16,
     caml_ba_set_generic:caml_ba_set_generic,
     caml_ba_get_3:caml_ba_get_3,
     caml_ba_get_2:caml_ba_get_2,
     caml_ba_get_1:caml_ba_get_1,
     caml_ba_uint8_get64:caml_ba_uint8_get64,
     caml_ba_uint8_get32:caml_ba_uint8_get32,
     caml_ba_uint8_get16:caml_ba_uint8_get16,
     caml_ba_get_generic:caml_ba_get_generic,
     caml_ba_dim_3:caml_ba_dim_3,
     caml_ba_dim_2:caml_ba_dim_2,
     caml_ba_dim_1:caml_ba_dim_1,
     caml_ba_dim:caml_ba_dim,
     caml_ba_num_dims:caml_ba_num_dims,
     caml_ba_layout:caml_ba_layout,
     caml_ba_kind:caml_ba_kind,
     caml_ba_change_layout:caml_ba_change_layout,
     caml_ba_create:caml_ba_create,
     caml_ba_create_unsafe:caml_ba_create_unsafe,
     caml_ba_compare:caml_ba_compare,
     Ml_Bigarray_c_1_1:Ml_Bigarray_c_1_1,
     Ml_Bigarray:Ml_Bigarray,
     caml_ba_create_buffer:caml_ba_create_buffer,
     caml_ba_get_size_per_element:caml_ba_get_size_per_element,
     caml_ba_get_size:caml_ba_get_size,
     caml_ba_init:caml_ba_init};
    caml_fs_init();
    caml_register_global
     (0,[248,caml_new_string("Out_of_memory"),0],"Out_of_memory");
    caml_register_global(1,[248,caml_new_string("Sys_error"),-1],"Sys_error");
    caml_register_global(2,[248,caml_new_string("Failure"),-2],"Failure");
    caml_register_global
     (3,[248,caml_new_string("Invalid_argument"),-3],"Invalid_argument");
    caml_register_global
     (4,[248,caml_new_string("End_of_file"),-4],"End_of_file");
    caml_register_global
     (5,[248,caml_new_string("Division_by_zero"),-5],"Division_by_zero");
    caml_register_global(6,[248,caml_new_string("Not_found"),-6],"Not_found");
    caml_register_global
     (7,[248,caml_new_string("Match_failure"),-7],"Match_failure");
    caml_register_global
     (8,[248,caml_new_string("Stack_overflow"),-8],"Stack_overflow");
    caml_register_global
     (9,[248,caml_new_string("Sys_blocked_io"),-9],"Sys_blocked_io");
    caml_register_global
     (10,[248,caml_new_string("Assert_failure"),-10],"Assert_failure");
    caml_register_global
     (11,
      [248,caml_new_string("Undefined_recursive_module"),-11],
      "Undefined_recursive_module");
    return}
  (function(){return this}()));


//# 1 "../.js/stdlib/stdlib.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_array_concat=runtime.caml_array_concat,
     caml_array_sub=runtime.caml_array_sub,
     caml_blit_bytes=runtime.caml_blit_bytes,
     caml_blit_string=runtime.caml_blit_string,
     caml_bytes_get=runtime.caml_bytes_get,
     caml_bytes_set=runtime.caml_bytes_set,
     caml_bytes_unsafe_get=runtime.caml_bytes_unsafe_get,
     caml_bytes_unsafe_set=runtime.caml_bytes_unsafe_set,
     caml_check_bound=runtime.caml_check_bound,
     caml_compare=runtime.caml_compare,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_equal=runtime.caml_equal,
     caml_fill_bytes=runtime.caml_fill_bytes,
     caml_float_of_string=runtime.caml_float_of_string,
     caml_format_float=runtime.caml_format_float,
     caml_format_int=runtime.caml_format_int,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_get_exception_raw_backtrace=runtime.caml_get_exception_raw_backtrace,
     caml_get_public_method=runtime.caml_get_public_method,
     caml_greaterequal=runtime.caml_greaterequal,
     caml_greaterthan=runtime.caml_greaterthan,
     caml_hash=runtime.caml_hash,
     caml_input_value=runtime.caml_input_value,
     caml_int64_add=runtime.caml_int64_add,
     caml_int64_compare=runtime.caml_int64_compare,
     caml_int64_float_of_bits=runtime.caml_int64_float_of_bits,
     caml_int64_format=runtime.caml_int64_format,
     caml_int64_of_int32=runtime.caml_int64_of_int32,
     caml_int64_of_string=runtime.caml_int64_of_string,
     caml_int64_or=runtime.caml_int64_or,
     caml_int64_shift_left=runtime.caml_int64_shift_left,
     caml_int64_sub=runtime.caml_int64_sub,
     caml_int_compare=runtime.caml_int_compare,
     caml_int_of_string=runtime.caml_int_of_string,
     caml_lessequal=runtime.caml_lessequal,
     caml_make_vect=runtime.caml_make_vect,
     caml_marshal_data_size=runtime.caml_marshal_data_size,
     caml_md5_string=runtime.caml_md5_string,
     caml_ml_bytes_length=runtime.caml_ml_bytes_length,
     caml_ml_channel_size=runtime.caml_ml_channel_size,
     caml_ml_channel_size_64=runtime.caml_ml_channel_size_64,
     caml_ml_close_channel=runtime.caml_ml_close_channel,
     caml_ml_flush=runtime.caml_ml_flush,
     caml_ml_input=runtime.caml_ml_input,
     caml_ml_input_char=runtime.caml_ml_input_char,
     caml_ml_open_descriptor_in=runtime.caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out=runtime.caml_ml_open_descriptor_out,
     caml_ml_output=runtime.caml_ml_output,
     caml_ml_output_bytes=runtime.caml_ml_output_bytes,
     caml_ml_output_char=runtime.caml_ml_output_char,
     caml_ml_set_binary_mode=runtime.caml_ml_set_binary_mode,
     caml_ml_set_channel_name=runtime.caml_ml_set_channel_name,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_mod=runtime.caml_mod,
     caml_new_string=runtime.caml_new_string,
     caml_notequal=runtime.caml_notequal,
     caml_obj_block=runtime.caml_obj_block,
     caml_obj_set_tag=runtime.caml_obj_set_tag,
     caml_obj_tag=runtime.caml_obj_tag,
     caml_obj_truncate=runtime.caml_obj_truncate,
     caml_output_value=runtime.caml_output_value,
     caml_register_global=runtime.caml_register_global,
     caml_register_named_value=runtime.caml_register_named_value,
     caml_set_oo_id=runtime.caml_set_oo_id,
     caml_spacetime_enabled=runtime.caml_spacetime_enabled,
     caml_spacetime_only_works_for_native_code=
      runtime.caml_spacetime_only_works_for_native_code,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_equal=runtime.caml_string_equal,
     caml_string_get=runtime.caml_string_get,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_sys_getenv=runtime.caml_sys_getenv,
     caml_sys_open=runtime.caml_sys_open,
     caml_sys_random_seed=runtime.caml_sys_random_seed,
     caml_trampoline=runtime.caml_trampoline,
     caml_trampoline_return=runtime.caml_trampoline_return,
     caml_weak_blit=runtime.caml_weak_blit,
     caml_weak_check=runtime.caml_weak_check,
     caml_weak_create=runtime.caml_weak_create,
     caml_weak_get=runtime.caml_weak_get,
     caml_weak_get_copy=runtime.caml_weak_get_copy,
     caml_weak_set=runtime.caml_weak_set,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    var
     global_data=runtime.caml_get_global_data(),
     cst$0=caml_new_string("%,"),
     cst_really_input=caml_new_string("really_input"),
     cst_input=caml_new_string("input"),
     cst_output_substring=caml_new_string("output_substring"),
     cst_output=caml_new_string("output"),
     cst_12g=caml_new_string("%.12g"),
     cst=caml_new_string("."),
     cst_false$1=caml_new_string("false"),
     cst_true$1=caml_new_string("true"),
     cst_false$0=caml_new_string("false"),
     cst_true$0=caml_new_string("true"),
     cst_bool_of_string=caml_new_string("bool_of_string"),
     cst_true=caml_new_string("true"),
     cst_false=caml_new_string("false"),
     cst_char_of_int=caml_new_string("char_of_int"),
     cst_Pervasives_Exit=caml_new_string("Pervasives.Exit"),
     cst_List_map2=caml_new_string("List.map2"),
     cst_List_iter2=caml_new_string("List.iter2"),
     cst_List_fold_left2=caml_new_string("List.fold_left2"),
     cst_List_fold_right2=caml_new_string("List.fold_right2"),
     cst_List_for_all2=caml_new_string("List.for_all2"),
     cst_List_exists2=caml_new_string("List.exists2"),
     cst_List_combine=caml_new_string("List.combine"),
     cst_List_rev_map2=caml_new_string("List.rev_map2"),
     cst_List_init=caml_new_string("List.init"),
     cst_List_nth$0=caml_new_string("List.nth"),
     cst_nth=caml_new_string("nth"),
     cst_List_nth=caml_new_string("List.nth"),
     cst_tl=caml_new_string("tl"),
     cst_hd=caml_new_string("hd"),
     cst$1=caml_new_string("\\\\"),
     cst$2=caml_new_string("\\'"),
     cst_b=caml_new_string("\\b"),
     cst_t=caml_new_string("\\t"),
     cst_n=caml_new_string("\\n"),
     cst_r=caml_new_string("\\r"),
     cst_Char_chr=caml_new_string("Char.chr"),
     cst_is_not_a_latin1_character=
      caml_new_string(" is not a latin1 character"),
     cst_04X=caml_new_string("%04X"),
     cst_U=caml_new_string("U+"),
     cst_is_not_an_Unicode_scalar_value=
      caml_new_string(" is not an Unicode scalar value"),
     cst_X=caml_new_string("%X"),
     err_no_pred=caml_new_string("U+0000 has no predecessor"),
     err_no_succ=caml_new_string("U+10FFFF has no successor"),
     cst_String_rcontains_from_Bytes_rcontains_from=
      caml_new_string("String.rcontains_from / Bytes.rcontains_from"),
     cst_String_contains_from_Bytes_contains_from=
      caml_new_string("String.contains_from / Bytes.contains_from"),
     cst_String_rindex_from_opt_Bytes_rindex_from_opt=
      caml_new_string("String.rindex_from_opt / Bytes.rindex_from_opt"),
     cst_String_rindex_from_Bytes_rindex_from=
      caml_new_string("String.rindex_from / Bytes.rindex_from"),
     cst_String_index_from_opt_Bytes_index_from_opt=
      caml_new_string("String.index_from_opt / Bytes.index_from_opt"),
     cst_String_index_from_Bytes_index_from=
      caml_new_string("String.index_from / Bytes.index_from"),
     cst_Bytes_concat=caml_new_string("Bytes.concat"),
     cst_String_blit_Bytes_blit_string=
      caml_new_string("String.blit / Bytes.blit_string"),
     cst_Bytes_blit=caml_new_string("Bytes.blit"),
     cst_String_fill_Bytes_fill=caml_new_string("String.fill / Bytes.fill"),
     cst_Bytes_extend=caml_new_string("Bytes.extend"),
     cst_String_sub_Bytes_sub=caml_new_string("String.sub / Bytes.sub"),
     cst_String_rcontains_from_Bytes_rcontains_from$0=
      caml_new_string("String.rcontains_from / Bytes.rcontains_from"),
     cst_String_contains_from_Bytes_contains_from$0=
      caml_new_string("String.contains_from / Bytes.contains_from"),
     cst_String_rindex_from_opt_Bytes_rindex_from_opt$0=
      caml_new_string("String.rindex_from_opt / Bytes.rindex_from_opt"),
     cst_String_rindex_from_Bytes_rindex_from$0=
      caml_new_string("String.rindex_from / Bytes.rindex_from"),
     cst_String_index_from_opt_Bytes_index_from_opt$0=
      caml_new_string("String.index_from_opt / Bytes.index_from_opt"),
     cst_String_index_from_Bytes_index_from$0=
      caml_new_string("String.index_from / Bytes.index_from"),
     cst$4=caml_new_string(""),
     cst$3=caml_new_string(""),
     cst_String_concat=caml_new_string("String.concat"),
     cst_Sys_Break=caml_new_string("Sys.Break"),
     ocaml_version=caml_new_string("4.06.0"),
     cst_Sort_array=caml_new_string("Sort.array"),
     cst_Marshal_from_bytes=caml_new_string("Marshal.from_bytes"),
     cst_Marshal_from_bytes$0=caml_new_string("Marshal.from_bytes"),
     cst_Marshal_data_size=caml_new_string("Marshal.data_size"),
     cst_Marshal_to_buffer_substring_out_of_bounds=
      caml_new_string("Marshal.to_buffer: substring out of bounds"),
     cst_Obj_extension_constructor$0=
      caml_new_string("Obj.extension_constructor"),
     cst_Obj_extension_constructor=
      caml_new_string("Obj.extension_constructor"),
     cst_Array_map2_arrays_must_have_the_same_length=
      caml_new_string("Array.map2: arrays must have the same length"),
     cst_Array_iter2_arrays_must_have_the_same_length=
      caml_new_string("Array.iter2: arrays must have the same length"),
     cst_Array_blit=caml_new_string("Array.blit"),
     cst_Array_fill=caml_new_string("Array.fill"),
     cst_Array_sub=caml_new_string("Array.sub"),
     cst_Array_init=caml_new_string("Array.init"),
     cst_Array_Bottom=caml_new_string("Array.Bottom"),
     cst_d=caml_new_string("%d"),
     cst_d$0=caml_new_string("%d"),
     zero$0=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     one$0=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     minus_one$0=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,65535),
     min_int$1=runtime.caml_int64_create_lo_mi_hi(0,0,32768),
     max_int$1=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,32767),
     cst_d$1=caml_new_string("%d"),
     cst_Lexing_lex_refill_cannot_grow_buffer=
      caml_new_string("Lexing.lex_refill: cannot grow buffer"),
     dummy_pos=[0,caml_new_string(""),0,0,-1],
     zero_pos=[0,caml_new_string(""),1,0,0],
     cst_syntax_error=caml_new_string("syntax error"),
     cst_Parsing_YYexit=caml_new_string("Parsing.YYexit"),
     cst_Parsing_Parse_error=caml_new_string("Parsing.Parse_error"),
     cst_Set_remove_min_elt=caml_new_string("Set.remove_min_elt"),
     cst_Set_bal=caml_new_string("Set.bal"),
     cst_Set_bal$0=caml_new_string("Set.bal"),
     cst_Set_bal$1=caml_new_string("Set.bal"),
     cst_Set_bal$2=caml_new_string("Set.bal"),
     cst_Map_remove_min_elt=caml_new_string("Map.remove_min_elt"),
     cst_Map_bal=caml_new_string("Map.bal"),
     cst_Map_bal$0=caml_new_string("Map.bal"),
     cst_Map_bal$1=caml_new_string("Map.bal"),
     cst_Map_bal$2=caml_new_string("Map.bal"),
     cst_Stack_Empty=caml_new_string("Stack.Empty"),
     cst_Queue_Empty=caml_new_string("Queue.Empty"),
     cst_CamlinternalLazy_Undefined=
      caml_new_string("CamlinternalLazy.Undefined"),
     cst_count=caml_new_string("{count = "),
     cst_data=caml_new_string("; data = "),
     cst$5=caml_new_string("}"),
     cst_Sempty=caml_new_string("Sempty"),
     cst_Scons=caml_new_string("Scons ("),
     cst$6=caml_new_string(", "),
     cst$7=caml_new_string(")"),
     cst_Sapp=caml_new_string("Sapp ("),
     cst$8=caml_new_string(", "),
     cst$9=caml_new_string(")"),
     cst_Slazy=caml_new_string("Slazy"),
     cst_Sgen=caml_new_string("Sgen"),
     cst_Sbuffio=caml_new_string("Sbuffio"),
     cst_Stream_Failure=caml_new_string("Stream.Failure"),
     cst_Stream_Error=caml_new_string("Stream.Error"),
     cst_Buffer_truncate=caml_new_string("Buffer.truncate"),
     cst_Buffer_add_channel=caml_new_string("Buffer.add_channel"),
     cst_Buffer_add_substring_add_subbytes=
      caml_new_string("Buffer.add_substring/add_subbytes"),
     cst_Buffer_add_cannot_grow_buffer=
      caml_new_string("Buffer.add: cannot grow buffer"),
     cst_Buffer_nth=caml_new_string("Buffer.nth"),
     cst_Buffer_blit=caml_new_string("Buffer.blit"),
     cst_Buffer_sub=caml_new_string("Buffer.sub"),
     cst_c=caml_new_string("%c"),
     cst_s=caml_new_string("%s"),
     cst_i=caml_new_string("%i"),
     cst_li=caml_new_string("%li"),
     cst_ni=caml_new_string("%ni"),
     cst_Li=caml_new_string("%Li"),
     cst_f=caml_new_string("%f"),
     cst_B=caml_new_string("%B"),
     cst$20=caml_new_string("%{"),
     cst$21=caml_new_string("%}"),
     cst$22=caml_new_string("%("),
     cst$23=caml_new_string("%)"),
     cst_a=caml_new_string("%a"),
     cst_t$0=caml_new_string("%t"),
     cst$24=caml_new_string("%?"),
     cst_r$0=caml_new_string("%r"),
     cst_r$1=caml_new_string("%_r"),
     cst_u$0=caml_new_string("%u"),
     cst_Printf_bad_conversion=caml_new_string("Printf: bad conversion %["),
     cst_Printf_bad_conversion$0=caml_new_string("Printf: bad conversion %_"),
     cst$28=caml_new_string("@{"),
     cst$29=caml_new_string("@["),
     cst$30=caml_new_string("@{"),
     cst$31=caml_new_string("@["),
     cst$32=caml_new_string("@{"),
     cst$33=caml_new_string("@["),
     cst_0=caml_new_string("0"),
     cst_padding=caml_new_string("padding"),
     cst_precision=caml_new_string("precision"),
     cst$38=caml_new_string("'*'"),
     cst$36=caml_new_string("'-'"),
     cst_0$2=caml_new_string("'0'"),
     cst$37=caml_new_string("'*'"),
     cst_0$0=caml_new_string("0"),
     cst_0$1=caml_new_string("0"),
     cst_precision$0=caml_new_string("precision"),
     cst_precision$1=caml_new_string("precision"),
     cst$39=caml_new_string("'+'"),
     cst$40=caml_new_string("'#'"),
     cst$41=caml_new_string("' '"),
     cst_padding$0=caml_new_string("`padding'"),
     cst_precision$2=caml_new_string("`precision'"),
     cst$42=caml_new_string("'+'"),
     cst$43=caml_new_string("'_'"),
     sub_format=[0,0,caml_new_string("")],
     formatting_lit=[0,caml_new_string("@;"),1,0],
     cst_digit=caml_new_string("digit"),
     cst_character=caml_new_string("character ')'"),
     cst_character$0=caml_new_string("character '}'"),
     cst$47=caml_new_string("'#'"),
     cst$46=caml_new_string("'+'"),
     cst$45=caml_new_string("'+'"),
     cst$44=caml_new_string("' '"),
     cst$50=caml_new_string("'+'"),
     cst$49=caml_new_string("'+'"),
     cst$48=caml_new_string("' '"),
     cst_non_zero_widths_are_unsupported_for_c_conversions=
      caml_new_string("non-zero widths are unsupported for %c conversions"),
     cst_unexpected_end_of_format=caml_new_string("unexpected end of format"),
     cst$34=caml_new_string(""),
     cst$35=caml_new_string(""),
     cst_b$0=caml_new_string("b"),
     cst_h=caml_new_string("h"),
     cst_hov=caml_new_string("hov"),
     cst_hv=caml_new_string("hv"),
     cst_v=caml_new_string("v"),
     cst_nan=caml_new_string("nan"),
     cst$27=caml_new_string("."),
     cst_neg_infinity=caml_new_string("neg_infinity"),
     cst_infinity=caml_new_string("infinity"),
     cst_12g$0=caml_new_string("%.12g"),
     cst_nd=caml_new_string("%nd"),
     cst_nd$0=caml_new_string("%+nd"),
     cst_nd$1=caml_new_string("% nd"),
     cst_ni$0=caml_new_string("%ni"),
     cst_ni$1=caml_new_string("%+ni"),
     cst_ni$2=caml_new_string("% ni"),
     cst_nx=caml_new_string("%nx"),
     cst_nx$0=caml_new_string("%#nx"),
     cst_nX=caml_new_string("%nX"),
     cst_nX$0=caml_new_string("%#nX"),
     cst_no=caml_new_string("%no"),
     cst_no$0=caml_new_string("%#no"),
     cst_nu=caml_new_string("%nu"),
     cst_ld=caml_new_string("%ld"),
     cst_ld$0=caml_new_string("%+ld"),
     cst_ld$1=caml_new_string("% ld"),
     cst_li$0=caml_new_string("%li"),
     cst_li$1=caml_new_string("%+li"),
     cst_li$2=caml_new_string("% li"),
     cst_lx=caml_new_string("%lx"),
     cst_lx$0=caml_new_string("%#lx"),
     cst_lX=caml_new_string("%lX"),
     cst_lX$0=caml_new_string("%#lX"),
     cst_lo=caml_new_string("%lo"),
     cst_lo$0=caml_new_string("%#lo"),
     cst_lu=caml_new_string("%lu"),
     cst_Ld=caml_new_string("%Ld"),
     cst_Ld$0=caml_new_string("%+Ld"),
     cst_Ld$1=caml_new_string("% Ld"),
     cst_Li$0=caml_new_string("%Li"),
     cst_Li$1=caml_new_string("%+Li"),
     cst_Li$2=caml_new_string("% Li"),
     cst_Lx=caml_new_string("%Lx"),
     cst_Lx$0=caml_new_string("%#Lx"),
     cst_LX=caml_new_string("%LX"),
     cst_LX$0=caml_new_string("%#LX"),
     cst_Lo=caml_new_string("%Lo"),
     cst_Lo$0=caml_new_string("%#Lo"),
     cst_Lu=caml_new_string("%Lu"),
     cst_d$2=caml_new_string("%d"),
     cst_d$3=caml_new_string("%+d"),
     cst_d$4=caml_new_string("% d"),
     cst_i$0=caml_new_string("%i"),
     cst_i$1=caml_new_string("%+i"),
     cst_i$2=caml_new_string("% i"),
     cst_x=caml_new_string("%x"),
     cst_x$0=caml_new_string("%#x"),
     cst_X$0=caml_new_string("%X"),
     cst_X$1=caml_new_string("%#X"),
     cst_o=caml_new_string("%o"),
     cst_o$0=caml_new_string("%#o"),
     cst_u=caml_new_string("%u"),
     cst$25=caml_new_string("%!"),
     cst$26=caml_new_string("@{"),
     cst_0c=caml_new_string("0c"),
     cst$19=caml_new_string("%%"),
     cst$11=caml_new_string("@]"),
     cst$12=caml_new_string("@}"),
     cst$13=caml_new_string("@?"),
     cst$14=caml_new_string("@\n"),
     cst$15=caml_new_string("@."),
     cst$16=caml_new_string("@@"),
     cst$17=caml_new_string("@%"),
     cst$18=caml_new_string("@"),
     cst$10=caml_new_string(".*"),
     cst_CamlinternalFormat_Type_mismatch=
      caml_new_string("CamlinternalFormat.Type_mismatch"),
     cst$58=caml_new_string(""),
     cst$59=caml_new_string("\n"),
     cst_a_boolean=caml_new_string("a boolean"),
     cst_an_integer=caml_new_string("an integer"),
     cst_an_integer$0=caml_new_string("an integer"),
     cst_a_float=caml_new_string("a float"),
     cst_a_float$0=caml_new_string("a float"),
     cst$55=caml_new_string(""),
     cst$56=caml_new_string(" "),
     cst$57=caml_new_string(""),
     cst_one_of=caml_new_string("one of: "),
     cst_Arg_Expand_is_is_only_allowed_with_Arg_parse_and_expand_argv_dynamic=
      caml_new_string
       ("Arg.Expand is is only allowed with Arg.parse_and_expand_argv_dynamic"),
     cst_no_argument=caml_new_string("no argument"),
     cst$54=caml_new_string("(?)"),
     cst_help$3=caml_new_string("--help"),
     cst_help$4=caml_new_string("-help"),
     cst_help$2=caml_new_string("-help"),
     cst_Display_this_list_of_options=
      caml_new_string(" Display this list of options"),
     cst_help=caml_new_string("-help"),
     cst_help$1=caml_new_string("--help"),
     cst_Display_this_list_of_options$0=
      caml_new_string(" Display this list of options"),
     cst_help$0=caml_new_string("--help"),
     cst$51=caml_new_string("}"),
     cst$52=caml_new_string("|"),
     cst$53=caml_new_string("{"),
     cst_none=caml_new_string("<none>"),
     cst_Arg_Bad=caml_new_string("Arg.Bad"),
     cst_Arg_Help=caml_new_string("Arg.Help"),
     cst_Arg_Stop=caml_new_string("Arg.Stop"),
     cst$61=caml_new_string(""),
     cst_Program_not_linked_with_g_cannot_print_stack_backtrace=
      caml_new_string
       ("(Program not linked with -g, cannot print stack backtrace)\n"),
     cst_Raised_at=caml_new_string("Raised at"),
     cst_Re_raised_at=caml_new_string("Re-raised at"),
     cst_Raised_by_primitive_operation_at=
      caml_new_string("Raised by primitive operation at"),
     cst_Called_from=caml_new_string("Called from"),
     cst_inlined=caml_new_string(" (inlined)"),
     cst$64=caml_new_string(""),
     partial=[4,0,0,0,0],
     cst_Out_of_memory=caml_new_string("Out of memory"),
     cst_Stack_overflow=caml_new_string("Stack overflow"),
     cst_Pattern_matching_failed=caml_new_string("Pattern matching failed"),
     cst_Assertion_failed=caml_new_string("Assertion failed"),
     cst_Undefined_recursive_module=
      caml_new_string("Undefined recursive module"),
     cst$62=caml_new_string(""),
     cst$63=caml_new_string(""),
     cst$60=caml_new_string("_"),
     locfmt=
      [0,
       [11,
        caml_new_string('File "'),
        [2,
         0,
         [11,
          caml_new_string('", line '),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(", characters "),
            [4,0,0,0,[12,45,[4,0,0,0,[11,caml_new_string(": "),[2,0,0]]]]]]]]]],
       caml_new_string('File "%s", line %d, characters %d-%d: %s')],
     cst_Digest_from_hex$0=caml_new_string("Digest.from_hex"),
     cst_Digest_from_hex=caml_new_string("Digest.from_hex"),
     cst_Digest_to_hex=caml_new_string("Digest.to_hex"),
     cst_Digest_substring=caml_new_string("Digest.substring"),
     cst_Random_int64=caml_new_string("Random.int64"),
     cst_Random_int32=caml_new_string("Random.int32"),
     cst_Random_int=caml_new_string("Random.int"),
     cst_x$1=caml_new_string("x"),
     cst_OCAMLRUNPARAM=caml_new_string("OCAMLRUNPARAM"),
     cst_CAMLRUNPARAM=caml_new_string("CAMLRUNPARAM"),
     cst$65=caml_new_string(""),
     cst_Weak_Make_hash_bucket_cannot_grow_more=
      caml_new_string("Weak.Make: hash bucket cannot grow more"),
     cst_Weak_fill=caml_new_string("Weak.fill"),
     cst$71=caml_new_string("."),
     cst$69=caml_new_string(">"),
     cst$70=caml_new_string("<\/"),
     cst$67=caml_new_string(">"),
     cst$68=caml_new_string("<"),
     cst$66=caml_new_string("\n"),
     cst_Format_Empty_queue=caml_new_string("Format.Empty_queue"),
     cst_end_of_input_not_found=caml_new_string("end of input not found"),
     cst_scanf_bad_conversion_a=caml_new_string('scanf: bad conversion "%a"'),
     cst_scanf_bad_conversion_t=caml_new_string('scanf: bad conversion "%t"'),
     cst_scanf_missing_reader=caml_new_string("scanf: missing reader"),
     cst_scanf_bad_conversion_custom_converter=
      caml_new_string('scanf: bad conversion "%?" (custom converter)'),
     cst_scanf_bad_conversion=caml_new_string('scanf: bad conversion "%*"'),
     cst_scanf_bad_conversion$1=caml_new_string('scanf: bad conversion "%*"'),
     cst_scanf_bad_conversion$0=caml_new_string('scanf: bad conversion "%-"'),
     cst_scanf_bad_conversion$2=caml_new_string('scanf: bad conversion "%*"'),
     cst$75=caml_new_string('"'),
     cst$76=caml_new_string('"'),
     cst$74=caml_new_string('"'),
     cst_in_format=caml_new_string(' in format "'),
     cst_an=caml_new_string("an"),
     cst_x$2=caml_new_string("x"),
     cst_nfinity=caml_new_string("nfinity"),
     cst_digits=caml_new_string("digits"),
     cst_decimal_digits=caml_new_string("decimal digits"),
     cst_0b=caml_new_string("0b"),
     cst_0o=caml_new_string("0o"),
     cst_0u=caml_new_string("0u"),
     cst_0x=caml_new_string("0x"),
     cst_false$2=caml_new_string("false"),
     cst_true$2=caml_new_string("true"),
     cst_not_a_valid_float_in_hexadecimal_notation=
      caml_new_string("not a valid float in hexadecimal notation"),
     cst_no_dot_or_exponent_part_found_in_float_token=
      caml_new_string("no dot or exponent part found in float token"),
     cst$73=caml_new_string("-"),
     cst_unnamed_function=caml_new_string("unnamed function"),
     cst_unnamed_character_string=caml_new_string("unnamed character string"),
     cst_unnamed_Pervasives_input_channel=
      caml_new_string("unnamed Pervasives input channel"),
     cst$72=caml_new_string("-"),
     cst_Scanf_Scan_failure=caml_new_string("Scanf.Scan_failure"),
     cst_binary=caml_new_string("binary"),
     cst_octal=caml_new_string("octal"),
     cst_hexadecimal=caml_new_string("hexadecimal"),
     cst_a_Char=caml_new_string("a Char"),
     cst_a_String=caml_new_string("a String"),
     cst$77=caml_new_string(""),
     cst$78=caml_new_string(""),
     cst$79=caml_new_string(""),
     cst$80=caml_new_string(""),
     cst$81=caml_new_string(""),
     cst$83=caml_new_string(""),
     cst$82=caml_new_string(""),
     cst_Illegal_character=caml_new_string("Illegal character "),
     cst_Filename_chop_extension=caml_new_string("Filename.chop_extension"),
     cst$94=caml_new_string(""),
     cst_Filename_chop_suffix=caml_new_string("Filename.chop_suffix"),
     cst$93=caml_new_string(""),
     cst$91=caml_new_string("./"),
     cst$90=caml_new_string(".\\"),
     cst$89=caml_new_string("../"),
     cst$88=caml_new_string("..\\"),
     cst$87=caml_new_string("./"),
     cst$86=caml_new_string("../"),
     cst$85=caml_new_string(""),
     cst$84=caml_new_string(""),
     current_dir_name=caml_new_string("."),
     parent_dir_name=caml_new_string(".."),
     dir_sep=caml_new_string("/"),
     cst_TMPDIR=caml_new_string("TMPDIR"),
     cst_tmp=caml_new_string("/tmp"),
     quotequote=caml_new_string("'\\''"),
     current_dir_name$0=caml_new_string("."),
     parent_dir_name$0=caml_new_string(".."),
     dir_sep$0=caml_new_string("\\"),
     cst_TEMP=caml_new_string("TEMP"),
     cst$92=caml_new_string("."),
     current_dir_name$1=caml_new_string("."),
     parent_dir_name$1=caml_new_string(".."),
     dir_sep$1=caml_new_string("/"),
     cst_Cygwin=caml_new_string("Cygwin"),
     cst_Win32=caml_new_string("Win32"),
     zero$2=[254,0.,0.],
     one$2=[254,1.,0.],
     i=[254,0.,1.],
     cst_Series_is_closed$0=caml_new_string("Series is closed"),
     cst_Series_is_closed=caml_new_string("Series is closed"),
     End_of_file=global_data.End_of_file,
     Sys_error=global_data.Sys_error,
     Failure=global_data.Failure,
     Invalid_argument=global_data.Invalid_argument,
     Not_found=global_data.Not_found,
     Assert_failure=global_data.Assert_failure,
     Out_of_memory=global_data.Out_of_memory,
     Stack_overflow=global_data.Stack_overflow,
     Match_failure=global_data.Match_failure,
     Undefined_recursive_module=global_data.Undefined_recursive_module,
     _l_=[0,0,[0,6,0]],
     _k_=[0,0,[0,7,0]],
     _j_=[0,1,[0,3,[0,4,[0,6,0]]]],
     _i_=[0,1,[0,3,[0,4,[0,7,0]]]],
     _g_=[0,1],
     _h_=[0,0],
     _a_=runtime.caml_int64_create_lo_mi_hi(0,0,32752),
     _b_=runtime.caml_int64_create_lo_mi_hi(0,0,65520),
     _c_=runtime.caml_int64_create_lo_mi_hi(1,0,32752),
     _d_=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,32751),
     _e_=runtime.caml_int64_create_lo_mi_hi(0,0,16),
     _f_=runtime.caml_int64_create_lo_mi_hi(0,0,15536),
     _n_=[0,0,0],
     _o_=[0,caml_new_string("list.ml"),262,11],
     _F_=[0,caml_new_string("array.ml"),233,4],
     _J_=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,65535),
     _I_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _H_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _G_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _K_=[0,0,0,0],
     _L_=[0,0,0],
     _M_=[0,caml_new_string("set.ml"),510,18],
     _N_=[0,0,0,0],
     _O_=[0,caml_new_string("map.ml"),393,10],
     _P_=[0,0,0],
     _Q_=[0,caml_new_string("stream.ml"),53,12],
     _R_=[0,0],
     _S_=[0,caml_new_string("stream.ml"),82,12],
     _Z_=[0,caml_new_string("buffer.ml"),205,9],
     _Y_=[0,caml_new_string("buffer.ml"),141,19],
     _X_=[0,caml_new_string("buffer.ml"),159,8],
     _W_=[0,caml_new_string("buffer.ml"),120,19],
     _V_=[0,caml_new_string("buffer.ml"),138,8],
     _U_=[0,caml_new_string("buffer.ml"),84,19],
     _T_=[0,caml_new_string("buffer.ml"),117,8],
     ___=[0,caml_new_string("camlinternalFormat.ml"),846,23],
     _aj_=[0,caml_new_string("camlinternalFormat.ml"),810,21],
     _ab_=[0,caml_new_string("camlinternalFormat.ml"),811,21],
     _ak_=[0,caml_new_string("camlinternalFormat.ml"),814,21],
     _ac_=[0,caml_new_string("camlinternalFormat.ml"),815,21],
     _al_=[0,caml_new_string("camlinternalFormat.ml"),818,19],
     _ad_=[0,caml_new_string("camlinternalFormat.ml"),819,19],
     _am_=[0,caml_new_string("camlinternalFormat.ml"),822,22],
     _ae_=[0,caml_new_string("camlinternalFormat.ml"),823,22],
     _an_=[0,caml_new_string("camlinternalFormat.ml"),827,30],
     _af_=[0,caml_new_string("camlinternalFormat.ml"),828,30],
     _ah_=[0,caml_new_string("camlinternalFormat.ml"),832,26],
     _$_=[0,caml_new_string("camlinternalFormat.ml"),833,26],
     _ai_=[0,caml_new_string("camlinternalFormat.ml"),842,28],
     _aa_=[0,caml_new_string("camlinternalFormat.ml"),843,28],
     _ag_=[0,caml_new_string("camlinternalFormat.ml"),847,23],
     _ao_=[0,caml_new_string("camlinternalFormat.ml"),1525,4],
     _ap_=[0,caml_new_string("camlinternalFormat.ml"),1593,39],
     _aq_=[0,caml_new_string("camlinternalFormat.ml"),1616,31],
     _ar_=[0,caml_new_string("camlinternalFormat.ml"),1617,31],
     _as_=[0,caml_new_string("camlinternalFormat.ml"),1797,8],
     _aW_=
      [0,
       [11,
        caml_new_string("bad input: format type mismatch between "),
        [3,0,[11,caml_new_string(" and "),[3,0,0]]]],
       caml_new_string("bad input: format type mismatch between %S and %S")],
     _aV_=
      [0,
       [11,
        caml_new_string("bad input: format type mismatch between "),
        [3,0,[11,caml_new_string(" and "),[3,0,0]]]],
       caml_new_string("bad input: format type mismatch between %S and %S")],
     _ay_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,0,0,0,[11,caml_new_string(", duplicate flag "),[1,0]]]]]],
       caml_new_string
        ("invalid format %S: at character number %d, duplicate flag %C")],
     _az_=[0,1,0],
     _aA_=[0,0],
     _aC_=[1,0],
     _aB_=[1,1],
     _aE_=[1,1],
     _aD_=[1,1],
     _aI_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(", flag "),
            [1,
             [11,
              caml_new_string(" is only allowed after the '"),
              [12,
               37,
               [11,caml_new_string("', before padding and precision"),0]]]]]]]]],
       caml_new_string
        ("invalid format %S: at character number %d, flag %C is only allowed after the '%%', before padding and precision")],
     _aF_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(', invalid conversion "'),
            [12,37,[0,[12,34,0]]]]]]]],
       caml_new_string
        ('invalid format %S: at character number %d, invalid conversion "%%%c"')],
     _aG_=[0,0],
     _aH_=[0,0],
     _aJ_=[0,[12,64,0]],
     _aK_=[0,caml_new_string("@ "),1,0],
     _aL_=[0,caml_new_string("@,"),0,0],
     _aM_=[2,60],
     _aN_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": '"),
          [12,
           37,
           [11,
            caml_new_string("' alone is not accepted in character sets, use "),
            [12,
             37,
             [12,
              37,
              [11,
               caml_new_string(" instead at position "),
               [4,0,0,0,[12,46,0]]]]]]]]]],
       caml_new_string
        ("invalid format %S: '%%' alone is not accepted in character sets, use %%%% instead at position %d.")],
     _aO_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": integer "),
          [4,
           0,
           0,
           0,
           [11,caml_new_string(" is greater than the limit "),[4,0,0,0,0]]]]]],
       caml_new_string
        ("invalid format %S: integer %d is greater than the limit %d")],
     _aP_=[0,caml_new_string("camlinternalFormat.ml"),2811,11],
     _aQ_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(': unclosed sub-format, expected "'),
          [12,
           37,
           [0,[11,caml_new_string('" at character number '),[4,0,0,0,0]]]]]]],
       caml_new_string
        ('invalid format %S: unclosed sub-format, expected "%%%c" at character number %d')],
     _aR_=[0,caml_new_string("camlinternalFormat.ml"),2873,34],
     _aS_=[0,caml_new_string("camlinternalFormat.ml"),2906,28],
     _aT_=[0,caml_new_string("camlinternalFormat.ml"),2940,25],
     _aU_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(", "),
            [2,
             0,
             [11,
              caml_new_string(" is incompatible with '"),
              [0,[11,caml_new_string("' in sub-format "),[3,0,0]]]]]]]]]],
       caml_new_string
        ("invalid format %S: at character number %d, %s is incompatible with '%c' in sub-format %S")],
     _ax_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(", "),
            [2,0,[11,caml_new_string(" expected, read "),[1,0]]]]]]]],
       caml_new_string
        ("invalid format %S: at character number %d, %s expected, read %C")],
     _aw_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(", '"),
            [0,[11,caml_new_string("' without "),[2,0,0]]]]]]]],
       caml_new_string
        ("invalid format %S: at character number %d, '%c' without %s")],
     _av_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,0,0,0,[11,caml_new_string(", "),[2,0,0]]]]]],
       caml_new_string("invalid format %S: at character number %d, %s")],
     _au_=
      [0,
       [11,caml_new_string("invalid box description "),[3,0,0]],
       caml_new_string("invalid box description %S")],
     _at_=[0,0,4],
     _bg_=[0,[2,0,[0,0]],caml_new_string("%s%c")],
     _ba_=[0,[2,0,0],caml_new_string("%s")],
     _bb_=[0,[2,0,0],caml_new_string("%s")],
     _a__=[0,[2,0,0],caml_new_string("%s")],
     _a$_=[0,[2,0,0],caml_new_string("%s")],
     _a8_=[0,[2,0,0],caml_new_string("%s")],
     _a9_=[0,[2,0,0],caml_new_string("%s")],
     _a2_=
      [0,
       [2,
        0,
        [11,
         caml_new_string(": unknown option '"),
         [2,0,[11,caml_new_string("'.\n"),0]]]],
       caml_new_string("%s: unknown option '%s'.\n")],
     _a5_=
      [0,
       [2,
        0,
        [11,
         caml_new_string(": wrong argument '"),
         [2,
          0,
          [11,
           caml_new_string("'; option '"),
           [2,
            0,
            [11,
             caml_new_string("' expects "),
             [2,0,[11,caml_new_string(".\n"),0]]]]]]]],
       caml_new_string("%s: wrong argument '%s'; option '%s' expects %s.\n")],
     _a6_=
      [0,
       [2,
        0,
        [11,
         caml_new_string(": option '"),
         [2,0,[11,caml_new_string("' needs an argument.\n"),0]]]],
       caml_new_string("%s: option '%s' needs an argument.\n")],
     _a7_=
      [0,
       [2,0,[11,caml_new_string(": "),[2,0,[11,caml_new_string(".\n"),0]]]],
       caml_new_string("%s: %s.\n")],
     _a3_=[0,caml_new_string("-help")],
     _a4_=[0,caml_new_string("--help")],
     _a1_=[0,[2,0,0],caml_new_string("%s")],
     _a0_=[0,[2,0,[12,10,0]],caml_new_string("%s\n")],
     _aZ_=[0,caml_new_string("-help")],
     _aX_=
      [0,
       [11,caml_new_string("  "),[2,0,[12,32,[2,0,[12,10,0]]]]],
       caml_new_string("  %s %s\n")],
     _aY_=
      [0,
       [11,caml_new_string("  "),[2,0,[12,32,[2,0,[2,0,[12,10,0]]]]]],
       caml_new_string("  %s %s%s\n")],
     _bl_=
      [0,[11,caml_new_string(", "),[2,0,[2,0,0]]],caml_new_string(", %s%s")],
     _bu_=[0,[2,0,[12,10,0]],caml_new_string("%s\n")],
     _bs_=[0,[2,0,[12,10,0]],caml_new_string("%s\n")],
     _bt_=
      [0,
       [11,
        caml_new_string
         ("(Program not linked with -g, cannot print stack backtrace)\n"),
        0],
       caml_new_string
        ("(Program not linked with -g, cannot print stack backtrace)\n")],
     _bq_=
      [0,
       [2,
        0,
        [11,
         caml_new_string(' file "'),
         [2,
          0,
          [12,
           34,
           [2,
            0,
            [11,
             caml_new_string(", line "),
             [4,
              0,
              0,
              0,
              [11,caml_new_string(", characters "),[4,0,0,0,[12,45,partial]]]]]]]]]],
       caml_new_string('%s file "%s"%s, line %d, characters %d-%d')],
     _br_=
      [0,
       [2,0,[11,caml_new_string(" unknown location"),0]],
       caml_new_string("%s unknown location")],
     _bp_=
      [0,
       [11,caml_new_string("Uncaught exception: "),[2,0,[12,10,0]]],
       caml_new_string("Uncaught exception: %s\n")],
     _bo_=
      [0,
       [11,caml_new_string("Uncaught exception: "),[2,0,[12,10,0]]],
       caml_new_string("Uncaught exception: %s\n")],
     _bm_=[0,[12,40,[2,0,[2,0,[12,41,0]]]],caml_new_string("(%s%s)")],
     _bn_=[0,[12,40,[2,0,[12,41,0]]],caml_new_string("(%s)")],
     _bk_=[0,[4,0,0,0,0],caml_new_string("%d")],
     _bj_=[0,[3,0,0],caml_new_string("%S")],
     _bD_=
      [0,
       [11,caml_new_string("minor_collections: "),[4,0,0,0,[12,10,0]]],
       caml_new_string("minor_collections: %d\n")],
     _bE_=
      [0,
       [11,caml_new_string("major_collections: "),[4,0,0,0,[12,10,0]]],
       caml_new_string("major_collections: %d\n")],
     _bF_=
      [0,
       [11,caml_new_string("compactions:       "),[4,0,0,0,[12,10,0]]],
       caml_new_string("compactions:       %d\n")],
     _bG_=[0,[12,10,0],caml_new_string("\n")],
     _bH_=[0,[8,0,0,[0,0],0],caml_new_string("%.0f")],
     _bI_=
      [0,
       [11,caml_new_string("minor_words:    "),[8,0,[1,1],[0,0],[12,10,0]]],
       caml_new_string("minor_words:    %*.0f\n")],
     _bJ_=
      [0,
       [11,caml_new_string("promoted_words: "),[8,0,[1,1],[0,0],[12,10,0]]],
       caml_new_string("promoted_words: %*.0f\n")],
     _bK_=
      [0,
       [11,caml_new_string("major_words:    "),[8,0,[1,1],[0,0],[12,10,0]]],
       caml_new_string("major_words:    %*.0f\n")],
     _bL_=[0,[12,10,0],caml_new_string("\n")],
     _bM_=[0,[4,0,0,0,0],caml_new_string("%d")],
     _bN_=
      [0,
       [11,caml_new_string("top_heap_words: "),[4,0,[1,1],0,[12,10,0]]],
       caml_new_string("top_heap_words: %*d\n")],
     _bO_=
      [0,
       [11,caml_new_string("heap_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_new_string("heap_words:     %*d\n")],
     _bP_=
      [0,
       [11,caml_new_string("live_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_new_string("live_words:     %*d\n")],
     _bQ_=
      [0,
       [11,caml_new_string("free_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_new_string("free_words:     %*d\n")],
     _bR_=
      [0,
       [11,caml_new_string("largest_free:   "),[4,0,[1,1],0,[12,10,0]]],
       caml_new_string("largest_free:   %*d\n")],
     _bS_=
      [0,
       [11,caml_new_string("fragments:      "),[4,0,[1,1],0,[12,10,0]]],
       caml_new_string("fragments:      %*d\n")],
     _bT_=[0,[12,10,0],caml_new_string("\n")],
     _bU_=
      [0,
       [11,caml_new_string("live_blocks: "),[4,0,0,0,[12,10,0]]],
       caml_new_string("live_blocks: %d\n")],
     _bV_=
      [0,
       [11,caml_new_string("free_blocks: "),[4,0,0,0,[12,10,0]]],
       caml_new_string("free_blocks: %d\n")],
     _bW_=
      [0,
       [11,caml_new_string("heap_chunks: "),[4,0,0,0,[12,10,0]]],
       caml_new_string("heap_chunks: %d\n")],
     _bZ_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _b0_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _b1_=
      [0,
       987910699,
       495797812,
       364182224,
       414272206,
       318284740,
       990407751,
       383018966,
       270373319,
       840823159,
       24560019,
       536292337,
       512266505,
       189156120,
       730249596,
       143776328,
       51606627,
       140166561,
       366354223,
       1003410265,
       700563762,
       981890670,
       913149062,
       526082594,
       1021425055,
       784300257,
       667753350,
       630144451,
       949649812,
       48546892,
       415514493,
       258888527,
       511570777,
       89983870,
       283659902,
       308386020,
       242688715,
       482270760,
       865188196,
       1027664170,
       207196989,
       193777847,
       619708188,
       671350186,
       149669678,
       257044018,
       87658204,
       558145612,
       183450813,
       28133145,
       901332182,
       710253903,
       510646120,
       652377910,
       409934019,
       801085050],
     _b5_=[0,0],
     _b4_=[0,caml_new_string("hashtbl.ml"),108,23],
     _b7_=[3,0,3],
     _b6_=[0,caml_new_string("")],
     _cl_=[0,91],
     _ck_=[0,123],
     _cm_=[0,caml_new_string("scanf.ml"),1455,13],
     _cn_=[0,[3,0,[10,0]],caml_new_string("%S%!")],
     _cj_=[0,37,caml_new_string("")],
     _ci_=
      [0,
       [11,
        caml_new_string("scanf: bad input at char number "),
        [4,3,0,0,[11,caml_new_string(": "),[2,0,0]]]],
       caml_new_string("scanf: bad input at char number %i: %s")],
     _ch_=
      [0,
       [11,
        caml_new_string("the character "),
        [1,[11,caml_new_string(" cannot start a boolean"),0]]],
       caml_new_string("the character %C cannot start a boolean")],
     _cg_=
      [0,
       [11,caml_new_string("bad character hexadecimal encoding \\"),[0,[0,0]]],
       caml_new_string("bad character hexadecimal encoding \\%c%c")],
     _cf_=
      [0,
       [11,caml_new_string("bad character decimal encoding \\"),[0,[0,[0,0]]]],
       caml_new_string("bad character decimal encoding \\%c%c%c")],
     _ce_=
      [0,
       [11,
        caml_new_string("character "),
        [1,
         [11,
          caml_new_string(" is not a valid "),
          [2,0,[11,caml_new_string(" digit"),0]]]]],
       caml_new_string("character %C is not a valid %s digit")],
     _cd_=
      [0,
       [11,
        caml_new_string("character "),
        [1,[11,caml_new_string(" is not a decimal digit"),0]]],
       caml_new_string("character %C is not a decimal digit")],
     _cc_=[0,caml_new_string("scanf.ml"),555,9],
     _cb_=
      [0,
       [11,caml_new_string("invalid boolean '"),[2,0,[12,39,0]]],
       caml_new_string("invalid boolean '%s'")],
     _ca_=
      [0,
       [11,
        caml_new_string("looking for "),
        [1,[11,caml_new_string(", found "),[1,0]]]],
       caml_new_string("looking for %C, found %C")],
     _b$_=
      [0,
       [11,
        caml_new_string("scanning of "),
        [2,
         0,
         [11,
          caml_new_string
           (" failed: premature end of file occurred before end of token"),
          0]]],
       caml_new_string
        ("scanning of %s failed: premature end of file occurred before end of token")],
     _b__=
      [0,
       [11,
        caml_new_string("scanning of "),
        [2,
         0,
         [11,
          caml_new_string
           (" failed: the specified length was too short for token"),
          0]]],
       caml_new_string
        ("scanning of %s failed: the specified length was too short for token")],
     _b9_=
      [0,
       [11,caml_new_string("illegal escape character "),[1,0]],
       caml_new_string("illegal escape character %C")],
     _cu_=[0,caml_new_string("camlinternalOO.ml"),438,17],
     _ct_=[0,caml_new_string("camlinternalOO.ml"),420,13],
     _cs_=[0,caml_new_string("camlinternalOO.ml"),417,13],
     _cr_=[0,caml_new_string("camlinternalOO.ml"),414,13],
     _cq_=[0,caml_new_string("camlinternalOO.ml"),411,13],
     _cp_=[0,caml_new_string("camlinternalOO.ml"),408,13],
     _co_=[0,caml_new_string("camlinternalOO.ml"),281,50],
     _cx_=[0,0],
     _cw_=[0,0],
     _cv_=[0,0],
     _cB_=[0,7,0],
     _cA_=[0,1,[0,3,[0,5,0]]],
     _cz_=[0,[2,0,[4,6,[0,2,6],0,[2,0,0]]],caml_new_string("%s%06x%s")],
     _cC_=[254,0.,0.];
    function erase_rel(param)
     {if(typeof param === "number")
       return 0;
      else
       switch(param[0])
        {case 0:var rest=param[1];return [0,erase_rel(rest)];
         case 1:var rest$0=param[1];return [1,erase_rel(rest$0)];
         case 2:var rest$1=param[1];return [2,erase_rel(rest$1)];
         case 3:var rest$2=param[1];return [3,erase_rel(rest$2)];
         case 4:var rest$3=param[1];return [4,erase_rel(rest$3)];
         case 5:var rest$4=param[1];return [5,erase_rel(rest$4)];
         case 6:var rest$5=param[1];return [6,erase_rel(rest$5)];
         case 7:var rest$6=param[1];return [7,erase_rel(rest$6)];
         case 8:
          var rest$7=param[2],ty=param[1];return [8,ty,erase_rel(rest$7)];
         case 9:
          var rest$8=param[3],ty1=param[1];
          return [9,ty1,ty1,erase_rel(rest$8)];
         case 10:var rest$9=param[1];return [10,erase_rel(rest$9)];
         case 11:var rest$10=param[1];return [11,erase_rel(rest$10)];
         case 12:var rest$11=param[1];return [12,erase_rel(rest$11)];
         case 13:var rest$12=param[1];return [13,erase_rel(rest$12)];
         default:var rest$13=param[1];return [14,erase_rel(rest$13)]}}
    function concat_fmtty(fmtty1,fmtty2)
     {if(typeof fmtty1 === "number")
       return fmtty2;
      else
       switch(fmtty1[0])
        {case 0:var rest=fmtty1[1];return [0,concat_fmtty(rest,fmtty2)];
         case 1:var rest$0=fmtty1[1];return [1,concat_fmtty(rest$0,fmtty2)];
         case 2:var rest$1=fmtty1[1];return [2,concat_fmtty(rest$1,fmtty2)];
         case 3:var rest$2=fmtty1[1];return [3,concat_fmtty(rest$2,fmtty2)];
         case 4:var rest$3=fmtty1[1];return [4,concat_fmtty(rest$3,fmtty2)];
         case 5:var rest$4=fmtty1[1];return [5,concat_fmtty(rest$4,fmtty2)];
         case 6:var rest$5=fmtty1[1];return [6,concat_fmtty(rest$5,fmtty2)];
         case 7:var rest$6=fmtty1[1];return [7,concat_fmtty(rest$6,fmtty2)];
         case 8:
          var rest$7=fmtty1[2],ty=fmtty1[1];
          return [8,ty,concat_fmtty(rest$7,fmtty2)];
         case 9:
          var rest$8=fmtty1[3],ty2=fmtty1[2],ty1=fmtty1[1];
          return [9,ty1,ty2,concat_fmtty(rest$8,fmtty2)];
         case 10:var rest$9=fmtty1[1];return [10,concat_fmtty(rest$9,fmtty2)];
         case 11:
          var rest$10=fmtty1[1];return [11,concat_fmtty(rest$10,fmtty2)];
         case 12:
          var rest$11=fmtty1[1];return [12,concat_fmtty(rest$11,fmtty2)];
         case 13:
          var rest$12=fmtty1[1];return [13,concat_fmtty(rest$12,fmtty2)];
         default:
          var rest$13=fmtty1[1];return [14,concat_fmtty(rest$13,fmtty2)]}}
    function concat_fmt(fmt1,fmt2)
     {if(typeof fmt1 === "number")
       return fmt2;
      else
       switch(fmt1[0])
        {case 0:var rest=fmt1[1];return [0,concat_fmt(rest,fmt2)];
         case 1:var rest$0=fmt1[1];return [1,concat_fmt(rest$0,fmt2)];
         case 2:
          var rest$1=fmt1[2],pad=fmt1[1];
          return [2,pad,concat_fmt(rest$1,fmt2)];
         case 3:
          var rest$2=fmt1[2],pad$0=fmt1[1];
          return [3,pad$0,concat_fmt(rest$2,fmt2)];
         case 4:
          var rest$3=fmt1[4],prec=fmt1[3],pad$1=fmt1[2],iconv=fmt1[1];
          return [4,iconv,pad$1,prec,concat_fmt(rest$3,fmt2)];
         case 5:
          var rest$4=fmt1[4],prec$0=fmt1[3],pad$2=fmt1[2],iconv$0=fmt1[1];
          return [5,iconv$0,pad$2,prec$0,concat_fmt(rest$4,fmt2)];
         case 6:
          var rest$5=fmt1[4],prec$1=fmt1[3],pad$3=fmt1[2],iconv$1=fmt1[1];
          return [6,iconv$1,pad$3,prec$1,concat_fmt(rest$5,fmt2)];
         case 7:
          var rest$6=fmt1[4],prec$2=fmt1[3],pad$4=fmt1[2],iconv$2=fmt1[1];
          return [7,iconv$2,pad$4,prec$2,concat_fmt(rest$6,fmt2)];
         case 8:
          var rest$7=fmt1[4],prec$3=fmt1[3],pad$5=fmt1[2],fconv=fmt1[1];
          return [8,fconv,pad$5,prec$3,concat_fmt(rest$7,fmt2)];
         case 9:
          var rest$8=fmt1[2],pad$6=fmt1[1];
          return [9,pad$6,concat_fmt(rest$8,fmt2)];
         case 10:var rest$9=fmt1[1];return [10,concat_fmt(rest$9,fmt2)];
         case 11:
          var rest$10=fmt1[2],str=fmt1[1];
          return [11,str,concat_fmt(rest$10,fmt2)];
         case 12:
          var rest$11=fmt1[2],chr=fmt1[1];
          return [12,chr,concat_fmt(rest$11,fmt2)];
         case 13:
          var rest$12=fmt1[3],fmtty=fmt1[2],pad$7=fmt1[1];
          return [13,pad$7,fmtty,concat_fmt(rest$12,fmt2)];
         case 14:
          var rest$13=fmt1[3],fmtty$0=fmt1[2],pad$8=fmt1[1];
          return [14,pad$8,fmtty$0,concat_fmt(rest$13,fmt2)];
         case 15:var rest$14=fmt1[1];return [15,concat_fmt(rest$14,fmt2)];
         case 16:var rest$15=fmt1[1];return [16,concat_fmt(rest$15,fmt2)];
         case 17:
          var rest$16=fmt1[2],fmting_lit=fmt1[1];
          return [17,fmting_lit,concat_fmt(rest$16,fmt2)];
         case 18:
          var rest$17=fmt1[2],fmting_gen=fmt1[1];
          return [18,fmting_gen,concat_fmt(rest$17,fmt2)];
         case 19:var rest$18=fmt1[1];return [19,concat_fmt(rest$18,fmt2)];
         case 20:
          var rest$19=fmt1[3],char_set=fmt1[2],width_opt=fmt1[1];
          return [20,width_opt,char_set,concat_fmt(rest$19,fmt2)];
         case 21:
          var rest$20=fmt1[2],counter=fmt1[1];
          return [21,counter,concat_fmt(rest$20,fmt2)];
         case 22:var rest$21=fmt1[1];return [22,concat_fmt(rest$21,fmt2)];
         case 23:
          var rest$22=fmt1[2],ign=fmt1[1];
          return [23,ign,concat_fmt(rest$22,fmt2)];
         default:
          var rest$23=fmt1[3],f=fmt1[2],arity=fmt1[1];
          return [24,arity,f,concat_fmt(rest$23,fmt2)]}}
    var CamlinternalFormatBasics=[0,concat_fmtty,erase_rel,concat_fmt];
    caml_register_global
     (637,CamlinternalFormatBasics,"CamlinternalFormatBasics");
    function failwith(s){throw [0,Failure,s]}
    function invalid_arg(s){throw [0,Invalid_argument,s]}
    var Exit=[248,cst_Pervasives_Exit,caml_fresh_oo_id(0)];
    function min(x,y){return caml_lessequal(x,y)?x:y}
    function max(x,y){return caml_greaterequal(x,y)?x:y}
    function abs(x){return 0 <= x?x:- x | 0}
    function lnot(x){return x ^ -1}
    var
     infinity=caml_int64_float_of_bits(_a_),
     neg_infinity=caml_int64_float_of_bits(_b_),
     nan=caml_int64_float_of_bits(_c_),
     max_float=caml_int64_float_of_bits(_d_),
     min_float=caml_int64_float_of_bits(_e_),
     epsilon_float=caml_int64_float_of_bits(_f_),
     max_int=2147483647,
     min_int=-2147483648;
    function symbol(s1,s2)
     {var
       l1=caml_ml_string_length(s1),
       l2=caml_ml_string_length(s2),
       s=caml_create_bytes(l1 + l2 | 0);
      caml_blit_string(s1,0,s,0,l1);
      caml_blit_string(s2,0,s,l1,l2);
      return s}
    function char_of_int(n)
     {if(0 <= n)if(! (255 < n))return n;return invalid_arg(cst_char_of_int)}
    function string_of_bool(b){return b?cst_true:cst_false}
    function bool_of_string(param)
     {return caml_string_notequal(param,cst_false$0)
              ?caml_string_notequal(param,cst_true$0)
                ?invalid_arg(cst_bool_of_string)
                :1
              :0}
    function bool_of_string_opt(param)
     {return caml_string_notequal(param,cst_false$1)
              ?caml_string_notequal(param,cst_true$1)?0:_g_
              :_h_}
    function string_of_int(n){return caml_new_string("" + n)}
    function int_of_string_opt(s)
     {try
       {var _xr_=[0,caml_int_of_string(s)];return _xr_}
      catch(_xs_)
       {_xs_ = caml_wrap_exception(_xs_);
        if(_xs_[1] === Failure)return 0;
        throw _xs_}}
    function valid_float_lexem(s)
     {var l=caml_ml_string_length(s),i=0;
      for(;;)
       {if(l <= i)return symbol(s,cst);
        var
         match=caml_string_get(s,i),
         switch$0=48 <= match?58 <= match?0:1:45 === match?1:0;
        if(switch$0){var i$0=i + 1 | 0,i=i$0;continue}
        return s}}
    function string_of_float(f)
     {return valid_float_lexem(caml_format_float(cst_12g,f))}
    function float_of_string_opt(s)
     {try
       {var _xp_=[0,caml_float_of_string(s)];return _xp_}
      catch(_xq_)
       {_xq_ = caml_wrap_exception(_xq_);
        if(_xq_[1] === Failure)return 0;
        throw _xq_}}
    function append(l1,l2)
     {if(l1){var tl=l1[2],hd=l1[1];return [0,hd,append(tl,l2)]}return l2}
    var
     stdin=caml_ml_open_descriptor_in(0),
     stdout=caml_ml_open_descriptor_out(1),
     stderr=caml_ml_open_descriptor_out(2);
    function open_out_gen(mode,perm,name)
     {var c=caml_ml_open_descriptor_out(caml_sys_open(name,mode,perm));
      caml_ml_set_channel_name(c,name);
      return c}
    function open_out(name){return open_out_gen(_i_,438,name)}
    function open_out_bin(name){return open_out_gen(_j_,438,name)}
    function flush_all(param)
     {function iter(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var l=param$0[2],a=param$0[1];
            try
             {caml_ml_flush(a)}
            catch(_xo_)
             {_xo_ = caml_wrap_exception(_xo_);
              if(_xo_[1] !== Sys_error)throw _xo_;
              var _xn_=_xo_}
            var param$0=l;
            continue}
          return 0}}
      return iter(runtime.caml_ml_out_channels_list(0))}
    function output_bytes(oc,s)
     {return caml_ml_output_bytes(oc,s,0,caml_ml_bytes_length(s))}
    function output_string(oc,s)
     {return caml_ml_output(oc,s,0,caml_ml_string_length(s))}
    function output(oc,s,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(s) - len | 0) < ofs))
         return caml_ml_output_bytes(oc,s,ofs,len);
      return invalid_arg(cst_output)}
    function output_substring(oc,s,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_string_length(s) - len | 0) < ofs))
         return caml_ml_output(oc,s,ofs,len);
      return invalid_arg(cst_output_substring)}
    function output_value(chan,v){return caml_output_value(chan,v,0)}
    function close_out(oc){caml_ml_flush(oc);return caml_ml_close_channel(oc)}
    function close_out_noerr(oc)
     {try {caml_ml_flush(oc)}catch(_xm_){}
      try
       {var _xk_=caml_ml_close_channel(oc);return _xk_}
      catch(_xl_){return 0}}
    function open_in_gen(mode,perm,name)
     {var c=caml_ml_open_descriptor_in(caml_sys_open(name,mode,perm));
      caml_ml_set_channel_name(c,name);
      return c}
    function open_in(name){return open_in_gen(_k_,0,name)}
    function open_in_bin(name){return open_in_gen(_l_,0,name)}
    function input(ic,s,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(s) - len | 0) < ofs))
         return caml_ml_input(ic,s,ofs,len);
      return invalid_arg(cst_input)}
    function unsafe_really_input(ic,s,ofs,len)
     {var ofs$0=ofs,len$0=len;
      for(;;)
       {if(0 < len$0)
         {var r=caml_ml_input(ic,s,ofs$0,len$0);
          if(0 === r)throw End_of_file;
          var len$1=len$0 - r | 0,ofs$1=ofs$0 + r | 0,ofs$0=ofs$1,len$0=len$1;
          continue}
        return 0}}
    function really_input(ic,s,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(s) - len | 0) < ofs))
         return unsafe_really_input(ic,s,ofs,len);
      return invalid_arg(cst_really_input)}
    function really_input_string(ic,len)
     {var s=caml_create_bytes(len);really_input(ic,s,0,len);return s}
    function input_line(chan)
     {function build_result(buf,pos,param)
       {var pos$0=pos,param$0=param;
        for(;;)
         {if(param$0)
           {var tl=param$0[2],hd=param$0[1],len=caml_ml_bytes_length(hd);
            caml_blit_bytes(hd,0,buf,pos$0 - len | 0,len);
            var pos$1=pos$0 - len | 0,pos$0=pos$1,param$0=tl;
            continue}
          return buf}}
      var accu=0,len=0;
      for(;;)
       {var n=runtime.caml_ml_input_scan_line(chan);
        if(0 === n)
         {if(accu)return build_result(caml_create_bytes(len),len,accu);
          throw End_of_file}
        if(0 < n)
         {var res=caml_create_bytes(n - 1 | 0);
          caml_ml_input(chan,res,0,n - 1 | 0);
          caml_ml_input_char(chan);
          if(accu)
           {var len$0=(len + n | 0) - 1 | 0;
            return build_result(caml_create_bytes(len$0),len$0,[0,res,accu])}
          return res}
        var beg=caml_create_bytes(- n | 0);
        caml_ml_input(chan,beg,0,- n | 0);
        var len$1=len - n | 0,accu$0=[0,beg,accu],accu=accu$0,len=len$1;
        continue}}
    function close_in_noerr(ic)
     {try
       {var _xi_=caml_ml_close_channel(ic);return _xi_}
      catch(_xj_){return 0}}
    function print_char(c){return caml_ml_output_char(stdout,c)}
    function print_string(s){return output_string(stdout,s)}
    function print_bytes(s){return output_bytes(stdout,s)}
    function print_int(i)
     {return output_string(stdout,caml_new_string("" + i))}
    function print_float(f){return output_string(stdout,string_of_float(f))}
    function print_endline(s)
     {output_string(stdout,s);
      caml_ml_output_char(stdout,10);
      return caml_ml_flush(stdout)}
    function print_newline(param)
     {caml_ml_output_char(stdout,10);return caml_ml_flush(stdout)}
    function prerr_char(c){return caml_ml_output_char(stderr,c)}
    function prerr_string(s){return output_string(stderr,s)}
    function prerr_bytes(s){return output_bytes(stderr,s)}
    function prerr_int(i)
     {return output_string(stderr,caml_new_string("" + i))}
    function prerr_float(f){return output_string(stderr,string_of_float(f))}
    function prerr_endline(s)
     {output_string(stderr,s);
      caml_ml_output_char(stderr,10);
      return caml_ml_flush(stderr)}
    function prerr_newline(param)
     {caml_ml_output_char(stderr,10);return caml_ml_flush(stderr)}
    function read_line(param){caml_ml_flush(stdout);return input_line(stdin)}
    function read_int(param){return caml_int_of_string(read_line(0))}
    function read_int_opt(param){return int_of_string_opt(read_line(0))}
    function read_float(param){return caml_float_of_string(read_line(0))}
    function read_float_opt(param){return float_of_string_opt(read_line(0))}
    function string_of_format(param){var str=param[2];return str}
    function symbol$0(param,_xg_)
     {var
       str2=_xg_[2],
       fmt2=_xg_[1],
       str1=param[2],
       fmt1=param[1],
       _xh_=symbol(str1,symbol(cst$0,str2));
      return [0,concat_fmt(fmt1,fmt2),_xh_]}
    var exit_function=[0,flush_all];
    function at_exit(f)
     {var g=exit_function[1];
      exit_function[1]
      =
      function(param){caml_call1(f,0);return caml_call1(g,0)};
      return 0}
    function do_at_exit(param){return caml_call1(exit_function[1],0)}
    function exit(retcode)
     {do_at_exit(0);return runtime.caml_sys_exit(retcode)}
    var
     Pervasives=
      [0,
       invalid_arg,
       failwith,
       Exit,
       min,
       max,
       abs,
       max_int,
       min_int,
       lnot,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       symbol,
       char_of_int,
       string_of_bool,
       bool_of_string,
       bool_of_string_opt,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       append,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int,
       read_int_opt,
       read_float,
       read_float_opt,
       open_out,
       open_out_bin,
       open_out_gen,
       caml_ml_flush,
       flush_all,
       caml_ml_output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       caml_ml_output_char,
       runtime.caml_ml_output_int,
       output_value,
       runtime.caml_ml_seek_out,
       runtime.caml_ml_pos_out,
       caml_ml_channel_size,
       close_out,
       close_out_noerr,
       caml_ml_set_binary_mode,
       open_in,
       open_in_bin,
       open_in_gen,
       caml_ml_input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       caml_ml_input_char,
       runtime.caml_ml_input_int,
       caml_input_value,
       runtime.caml_ml_seek_in,
       runtime.caml_ml_pos_in,
       caml_ml_channel_size,
       caml_ml_close_channel,
       close_in_noerr,
       caml_ml_set_binary_mode,
       [0,
        runtime.caml_ml_seek_out_64,
        runtime.caml_ml_pos_out_64,
        caml_ml_channel_size_64,
        runtime.caml_ml_seek_in_64,
        runtime.caml_ml_pos_in_64,
        caml_ml_channel_size_64],
       string_of_format,
       symbol$0,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit];
    caml_register_global(642,Pervasives,"Pervasives");
    function length(l)
     {var len=0,param=l;
      for(;;)
       {if(param)
         {var param$0=param[2],len$0=len + 1 | 0,len=len$0,param=param$0;
          continue}
        return len}}
    function cons(a,l){return [0,a,l]}
    function hd(param)
     {if(param){var a=param[1];return a}return failwith(cst_hd)}
    function tl(param)
     {if(param){var l=param[2];return l}return failwith(cst_tl)}
    function nth(l,n)
     {if(0 <= n)
       {var l$0=l,n$0=n;
        for(;;)
         {if(l$0)
           {var l$1=l$0[2],a=l$0[1];
            if(0 === n$0)return a;
            var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;
            continue}
          return failwith(cst_nth)}}
      return invalid_arg(cst_List_nth)}
    function nth_opt(l,n)
     {if(0 <= n)
       {var l$0=l,n$0=n;
        for(;;)
         {if(l$0)
           {var l$1=l$0[2],a=l$0[1];
            if(0 === n$0)return [0,a];
            var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;
            continue}
          return 0}}
      return invalid_arg(cst_List_nth$0)}
    function rev_append(l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {var l1$1=l1$0[2],a=l1$0[1],l2$1=[0,a,l2$0],l1$0=l1$1,l2$0=l2$1;
          continue}
        return l2$0}}
    function rev(l){return rev_append(l,0)}
    function init_aux(i,n,f)
     {if(n <= i)return 0;
      var r=caml_call1(f,i);
      return [0,r,init_aux(i + 1 | 0,n,f)]}
    function init(len,f)
     {if(0 <= len)
       {if(10000 < len)
         {var acc=0,i=0;
          for(;;)
           {if(len <= i)return rev(acc);
            var i$0=i + 1 | 0,acc$0=[0,caml_call1(f,i),acc],acc=acc$0,i=i$0;
            continue}}
        return init_aux(0,len,f)}
      return invalid_arg(cst_List_init)}
    function flatten(param)
     {if(param){var r=param[2],l=param[1];return append(l,flatten(r))}
      return 0}
    function map(f,param)
     {if(param)
       {var l=param[2],a=param[1],r=caml_call1(f,a);return [0,r,map(f,l)]}
      return 0}
    function _m_(i,f,param)
     {if(param)
       {var l=param[2],a=param[1],r=caml_call2(f,i,a);
        return [0,r,_m_(i + 1 | 0,f,l)]}
      return 0}
    function mapi(f,l){return _m_(0,f,l)}
    function rev_map(f,param)
     {var accu=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           a=param$0[1],
           accu$0=[0,caml_call1(f,a),accu],
           accu=accu$0,
           param$0=l;
          continue}
        return accu}}
    function iter(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1];
          caml_call1(f,a);
          var param$0=l;
          continue}
        return 0}}
    function iteri(f,l$0)
     {var i=0,param=l$0;
      for(;;)
       {if(param)
         {var l=param[2],a=param[1];
          caml_call2(f,i,a);
          var i$0=i + 1 | 0,i=i$0,param=l;
          continue}
        return 0}}
    function fold_left(f,accu,l)
     {var accu$0=accu,l$0=l;
      for(;;)
       {if(l$0)
         {var
           l$1=l$0[2],
           a=l$0[1],
           accu$1=caml_call2(f,accu$0,a),
           accu$0=accu$1,
           l$0=l$1;
          continue}
        return accu$0}}
    function fold_right(f,l,accu)
     {if(l){var l$0=l[2],a=l[1];return caml_call2(f,a,fold_right(f,l$0,accu))}
      return accu}
    function map2(f,l1,l2)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1],r=caml_call2(f,a1,a2);
          return [0,r,map2(f,l1$0,l2$0)]}}
      else
       if(! l2)return 0;
      return invalid_arg(cst_List_map2)}
    function rev_map2(f,l1,l2)
     {var accu=0,l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             accu$0=[0,caml_call2(f,a1,a2),accu],
             accu=accu$0,
             l1$0=l1$1,
             l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return accu;
        return invalid_arg(cst_List_rev_map2)}}
    function iter2(f,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var l2$1=l2$0[2],a2=l2$0[1],l1$1=l1$0[2],a1=l1$0[1];
            caml_call2(f,a1,a2);
            var l1$0=l1$1,l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return 0;
        return invalid_arg(cst_List_iter2)}}
    function fold_left2(f,accu,l1,l2)
     {var accu$0=accu,l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             accu$1=caml_call3(f,accu$0,a1,a2),
             accu$0=accu$1,
             l1$0=l1$1,
             l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return accu$0;
        return invalid_arg(cst_List_fold_left2)}}
    function fold_right2(f,l1,l2,accu)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1];
          return caml_call3(f,a1,a2,fold_right2(f,l1$0,l2$0,accu))}}
      else
       if(! l2)return accu;
      return invalid_arg(cst_List_fold_right2)}
    function for_all(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_xf_=caml_call1(p,a);
          if(_xf_){var param$0=l;continue}
          return _xf_}
        return 1}}
    function exists(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_xe_=caml_call1(p,a);
          if(_xe_)return _xe_;
          var param$0=l;
          continue}
        return 0}}
    function for_all2(p,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             _xd_=caml_call2(p,a1,a2);
            if(_xd_){var l1$0=l1$1,l2$0=l2$1;continue}
            return _xd_}}
        else
         if(! l2$0)return 1;
        return invalid_arg(cst_List_for_all2)}}
    function exists2(p,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             _xc_=caml_call2(p,a1,a2);
            if(_xc_)return _xc_;
            var l1$0=l1$1,l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return 0;
        return invalid_arg(cst_List_exists2)}}
    function mem(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_xb_=0 === caml_compare(a,x)?1:0;
          if(_xb_)return _xb_;
          var param$0=l;
          continue}
        return 0}}
    function memq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_xa_=a === x?1:0;
          if(_xa_)return _xa_;
          var param$0=l;
          continue}
        return 0}}
    function assoc(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(0 === caml_compare(a,x))return b;
          var param$0=l;
          continue}
        throw Not_found}}
    function assoc_opt(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(0 === caml_compare(a,x))return [0,b];
          var param$0=l;
          continue}
        return 0}}
    function assq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(a === x)return b;
          var param$0=l;
          continue}
        throw Not_found}}
    function assq_opt(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(a === x)return [0,b];
          var param$0=l;
          continue}
        return 0}}
    function mem_assoc(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           match=param$0[1],
           a=match[1],
           _w$_=0 === caml_compare(a,x)?1:0;
          if(_w$_)return _w$_;
          var param$0=l;
          continue}
        return 0}}
    function mem_assq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],a=match[1],_w__=a === x?1:0;
          if(_w__)return _w__;
          var param$0=l;
          continue}
        return 0}}
    function remove_assoc(x,param)
     {if(param)
       {var l=param[2],pair=param[1],a=pair[1];
        return 0 === caml_compare(a,x)?l:[0,pair,remove_assoc(x,l)]}
      return 0}
    function remove_assq(x,param)
     {if(param)
       {var l=param[2],pair=param[1],a=pair[1];
        return a === x?l:[0,pair,remove_assq(x,l)]}
      return 0}
    function find(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))return x;
          var param$0=l;
          continue}
        throw Not_found}}
    function find_opt(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))return [0,x];
          var param$0=l;
          continue}
        return 0}}
    function find_all(p)
     {var accu=0;
      return function(param$0)
       {var accu$0=accu,param=param$0;
        for(;;)
         {if(param)
           {var l=param[2],x=param[1];
            if(caml_call1(p,x))
             {var accu$1=[0,x,accu$0],accu$0=accu$1,param=l;continue}
            var param=l;
            continue}
          return rev(accu$0)}}}
    function partition(p,param)
     {var yes=0,no=0,param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))
           {var yes$0=[0,x,yes],yes=yes$0,param$0=l;continue}
          var no$0=[0,x,no],no=no$0,param$0=l;
          continue}
        var _w9_=rev(no);
        return [0,rev(yes),_w9_]}}
    function split(param)
     {if(param)
       {var
         l=param[2],
         match=param[1],
         y=match[2],
         x=match[1],
         match$0=split(l),
         ry=match$0[2],
         rx=match$0[1];
        return [0,[0,x,rx],[0,y,ry]]}
      return _n_}
    function combine(l1,l2)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1];
          return [0,[0,a1,a2],combine(l1$0,l2$0)]}}
      else
       if(! l2)return 0;
      return invalid_arg(cst_List_combine)}
    function merge(cmp,l1,match)
     {if(l1)
       {if(match)
         {var t2=match[2],h2=match[1],t1=l1[2],h1=l1[1];
          return 0 < caml_call2(cmp,h1,h2)
                  ?[0,h2,merge(cmp,l1,t2)]
                  :[0,h1,merge(cmp,t1,match)]}
        return l1}
      return match}
    function chop(k,l)
     {var k$0=k,l$0=l;
      for(;;)
       {if(0 === k$0)return l$0;
        if(l$0){var l$1=l$0[2],k$1=k$0 - 1 | 0,k$0=k$1,l$0=l$1;continue}
        throw [0,Assert_failure,_o_]}}
    function fast_sort(cmp,l)
     {function sort(n,l)
       {if(2 === n)
         {if(l)
           {var _w6_=l[2];
            if(_w6_)
             {var x2=_w6_[1],x1=l[1];
              return 0 < caml_call2(cmp,x1,x2)?[0,x2,[0,x1,0]]:[0,x1,[0,x2,0]]}}}
        else
         if(3 === n)
          if(l)
           {var _w7_=l[2];
            if(_w7_)
             {var _w8_=_w7_[2];
              if(_w8_)
               {var x3=_w8_[1],x2$0=_w7_[1],x1$0=l[1];
                return 0 < caml_call2(cmp,x1$0,x2$0)
                        ?0 < caml_call2(cmp,x1$0,x3)
                          ?0 < caml_call2(cmp,x2$0,x3)
                            ?[0,x3,[0,x2$0,[0,x1$0,0]]]
                            :[0,x2$0,[0,x3,[0,x1$0,0]]]
                          :[0,x2$0,[0,x1$0,[0,x3,0]]]
                        :0 < caml_call2(cmp,x2$0,x3)
                          ?0 < caml_call2(cmp,x1$0,x3)
                            ?[0,x3,[0,x1$0,[0,x2$0,0]]]
                            :[0,x1$0,[0,x3,[0,x2$0,0]]]
                          :[0,x1$0,[0,x2$0,[0,x3,0]]]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         l2$0=chop(n1,l),
         l1$0=rev_sort(n1,l),
         l2$1=rev_sort(n2,l2$0),
         l1=l1$0,
         l2=l2$1,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1];
              if(0 < caml_call2(cmp,h1,h2))
               {var accu$0=[0,h1,accu],l1=t1,accu=accu$0;continue}
              var accu$1=[0,h2,accu],l2=t2,accu=accu$1;
              continue}
            return rev_append(l1,accu)}
          return rev_append(l2,accu)}}
      function rev_sort(n,l)
       {if(2 === n)
         {if(l)
           {var _w3_=l[2];
            if(_w3_)
             {var x2=_w3_[1],x1=l[1];
              return 0 < caml_call2(cmp,x1,x2)?[0,x1,[0,x2,0]]:[0,x2,[0,x1,0]]}}}
        else
         if(3 === n)
          if(l)
           {var _w4_=l[2];
            if(_w4_)
             {var _w5_=_w4_[2];
              if(_w5_)
               {var x3=_w5_[1],x2$0=_w4_[1],x1$0=l[1];
                return 0 < caml_call2(cmp,x1$0,x2$0)
                        ?0 < caml_call2(cmp,x2$0,x3)
                          ?[0,x1$0,[0,x2$0,[0,x3,0]]]
                          :0 < caml_call2(cmp,x1$0,x3)
                            ?[0,x1$0,[0,x3,[0,x2$0,0]]]
                            :[0,x3,[0,x1$0,[0,x2$0,0]]]
                        :0 < caml_call2(cmp,x1$0,x3)
                          ?[0,x2$0,[0,x1$0,[0,x3,0]]]
                          :0 < caml_call2(cmp,x2$0,x3)
                            ?[0,x2$0,[0,x3,[0,x1$0,0]]]
                            :[0,x3,[0,x2$0,[0,x1$0,0]]]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         l2$0=chop(n1,l),
         l1$0=sort(n1,l),
         l2$1=sort(n2,l2$0),
         l1=l1$0,
         l2=l2$1,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1];
              if(0 < caml_call2(cmp,h1,h2))
               {var accu$0=[0,h2,accu],l2=t2,accu=accu$0;continue}
              var accu$1=[0,h1,accu],l1=t1,accu=accu$1;
              continue}
            return rev_append(l1,accu)}
          return rev_append(l2,accu)}}
      var len=length(l);
      return 2 <= len?sort(len,l):l}
    function sort_uniq(cmp,l)
     {function sort(n,l)
       {if(2 === n)
         {if(l)
           {var _w0_=l[2];
            if(_w0_)
             {var x2=_w0_[1],x1=l[1],c$0=caml_call2(cmp,x1,x2);
              return 0 === c$0
                      ?[0,x1,0]
                      :0 <= c$0?[0,x2,[0,x1,0]]:[0,x1,[0,x2,0]]}}}
        else
         if(3 === n)
          if(l)
           {var _w1_=l[2];
            if(_w1_)
             {var _w2_=_w1_[2];
              if(_w2_)
               {var
                 x3=_w2_[1],
                 x2$0=_w1_[1],
                 x1$0=l[1],
                 c$1=caml_call2(cmp,x1$0,x2$0);
                if(0 === c$1)
                 {var c$2=caml_call2(cmp,x2$0,x3);
                  return 0 === c$2
                          ?[0,x2$0,0]
                          :0 <= c$2?[0,x3,[0,x2$0,0]]:[0,x2$0,[0,x3,0]]}
                if(0 <= c$1)
                 {var c$3=caml_call2(cmp,x1$0,x3);
                  if(0 === c$3)return [0,x2$0,[0,x1$0,0]];
                  if(0 <= c$3)
                   {var c$4=caml_call2(cmp,x2$0,x3);
                    return 0 === c$4
                            ?[0,x2$0,[0,x1$0,0]]
                            :0 <= c$4
                              ?[0,x3,[0,x2$0,[0,x1$0,0]]]
                              :[0,x2$0,[0,x3,[0,x1$0,0]]]}
                  return [0,x2$0,[0,x1$0,[0,x3,0]]]}
                var c$5=caml_call2(cmp,x2$0,x3);
                if(0 === c$5)return [0,x1$0,[0,x2$0,0]];
                if(0 <= c$5)
                 {var c$6=caml_call2(cmp,x1$0,x3);
                  return 0 === c$6
                          ?[0,x1$0,[0,x2$0,0]]
                          :0 <= c$6
                            ?[0,x3,[0,x1$0,[0,x2$0,0]]]
                            :[0,x1$0,[0,x3,[0,x2$0,0]]]}
                return [0,x1$0,[0,x2$0,[0,x3,0]]]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         l2$0=chop(n1,l),
         l1$0=rev_sort(n1,l),
         l2$1=rev_sort(n2,l2$0),
         l1=l1$0,
         l2=l2$1,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1],c=caml_call2(cmp,h1,h2);
              if(0 === c)
               {var accu$0=[0,h1,accu],l1=t1,l2=t2,accu=accu$0;continue}
              if(0 < c){var accu$1=[0,h1,accu],l1=t1,accu=accu$1;continue}
              var accu$2=[0,h2,accu],l2=t2,accu=accu$2;
              continue}
            return rev_append(l1,accu)}
          return rev_append(l2,accu)}}
      function rev_sort(n,l)
       {if(2 === n)
         {if(l)
           {var _wX_=l[2];
            if(_wX_)
             {var x2=_wX_[1],x1=l[1],c$0=caml_call2(cmp,x1,x2);
              return 0 === c$0
                      ?[0,x1,0]
                      :0 < c$0?[0,x1,[0,x2,0]]:[0,x2,[0,x1,0]]}}}
        else
         if(3 === n)
          if(l)
           {var _wY_=l[2];
            if(_wY_)
             {var _wZ_=_wY_[2];
              if(_wZ_)
               {var
                 x3=_wZ_[1],
                 x2$0=_wY_[1],
                 x1$0=l[1],
                 c$1=caml_call2(cmp,x1$0,x2$0);
                if(0 === c$1)
                 {var c$2=caml_call2(cmp,x2$0,x3);
                  return 0 === c$2
                          ?[0,x2$0,0]
                          :0 < c$2?[0,x2$0,[0,x3,0]]:[0,x3,[0,x2$0,0]]}
                if(0 < c$1)
                 {var c$3=caml_call2(cmp,x2$0,x3);
                  if(0 === c$3)return [0,x1$0,[0,x2$0,0]];
                  if(0 < c$3)return [0,x1$0,[0,x2$0,[0,x3,0]]];
                  var c$4=caml_call2(cmp,x1$0,x3);
                  return 0 === c$4
                          ?[0,x1$0,[0,x2$0,0]]
                          :0 < c$4
                            ?[0,x1$0,[0,x3,[0,x2$0,0]]]
                            :[0,x3,[0,x1$0,[0,x2$0,0]]]}
                var c$5=caml_call2(cmp,x1$0,x3);
                if(0 === c$5)return [0,x2$0,[0,x1$0,0]];
                if(0 < c$5)return [0,x2$0,[0,x1$0,[0,x3,0]]];
                var c$6=caml_call2(cmp,x2$0,x3);
                return 0 === c$6
                        ?[0,x2$0,[0,x1$0,0]]
                        :0 < c$6
                          ?[0,x2$0,[0,x3,[0,x1$0,0]]]
                          :[0,x3,[0,x2$0,[0,x1$0,0]]]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         l2$0=chop(n1,l),
         l1$0=sort(n1,l),
         l2$1=sort(n2,l2$0),
         l1=l1$0,
         l2=l2$1,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1],c=caml_call2(cmp,h1,h2);
              if(0 === c)
               {var accu$0=[0,h1,accu],l1=t1,l2=t2,accu=accu$0;continue}
              if(0 <= c){var accu$1=[0,h2,accu],l2=t2,accu=accu$1;continue}
              var accu$2=[0,h1,accu],l1=t1,accu=accu$2;
              continue}
            return rev_append(l1,accu)}
          return rev_append(l2,accu)}}
      var len=length(l);
      return 2 <= len?sort(len,l):l}
    function compare_lengths(l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0){var l2$1=l2$0[2],l1$1=l1$0[2],l1$0=l1$1,l2$0=l2$1;continue}
          return 1}
        return l2$0?-1:0}}
    function compare_length_with(l,n)
     {var l$0=l,n$0=n;
      for(;;)
       {if(l$0)
         {var l$1=l$0[2];
          if(0 < n$0){var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;continue}
          return 1}
        return 0 === n$0?0:0 < n$0?-1:1}}
    var
     include=
      [0,
       length,
       compare_lengths,
       compare_length_with,
       cons,
       hd,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       flatten,
       flatten,
       iter,
       iteri,
       map,
       mapi,
       rev_map,
       fold_left,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_all,
       find_all,
       partition,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       fast_sort,
       fast_sort,
       fast_sort,
       sort_uniq,
       merge];
    caml_register_global(645,include,"List");
    function chr(n)
     {if(0 <= n)if(! (255 < n))return n;return invalid_arg(cst_Char_chr)}
    function escaped(c)
     {if(40 <= c)
       {if(92 === c)return cst$1;var switch$0=127 <= c?0:1}
      else
       if(32 <= c)
        {if(39 <= c)return cst$2;var switch$0=1}
       else
        if(14 <= c)
         var switch$0=0;
        else
         switch(c)
          {case 8:return cst_b;
           case 9:return cst_t;
           case 10:return cst_n;
           case 13:return cst_r;
           default:var switch$0=0}
      if(switch$0)
       {var s$0=caml_create_bytes(1);
        caml_bytes_unsafe_set(s$0,0,c);
        return s$0}
      var s=caml_create_bytes(4);
      caml_bytes_unsafe_set(s,0,92);
      caml_bytes_unsafe_set(s,1,48 + (c / 100 | 0) | 0);
      caml_bytes_unsafe_set(s,2,48 + ((c / 10 | 0) % 10 | 0) | 0);
      caml_bytes_unsafe_set(s,3,48 + (c % 10 | 0) | 0);
      return s}
    function lowercase(c)
     {var switch$0=65 <= c?90 < c?0:1:0;
      if(! switch$0)
       {var switch$1=192 <= c?214 < c?0:1:0;
        if(! switch$1)
         {var switch$2=216 <= c?222 < c?1:0:1;if(switch$2)return c}}
      return c + 32 | 0}
    function uppercase(c)
     {var switch$0=97 <= c?122 < c?0:1:0;
      if(! switch$0)
       {var switch$1=224 <= c?246 < c?0:1:0;
        if(! switch$1)
         {var switch$2=248 <= c?254 < c?1:0:1;if(switch$2)return c}}
      return c - 32 | 0}
    function lowercase_ascii(c)
     {if(65 <= c)if(! (90 < c))return c + 32 | 0;return c}
    function uppercase_ascii(c)
     {if(97 <= c)if(! (122 < c))return c - 32 | 0;return c}
    function compare(c1,c2){return c1 - c2 | 0}
    function equal(c1,c2){return 0 === (c1 - c2 | 0)?1:0}
    var
     Char=
      [0,
       chr,
       escaped,
       lowercase,
       uppercase,
       lowercase_ascii,
       uppercase_ascii,
       compare,
       equal];
    caml_register_global(646,Char,"Char");
    var
     min$0=0,
     max$0=1114111,
     lo_bound=55295,
     hi_bound=57344,
     bom=65279,
     rep=65533;
    function succ(u)
     {return u === 55295
              ?hi_bound
              :u === 1114111?invalid_arg(err_no_succ):u + 1 | 0}
    function pred(u)
     {return u === 57344?lo_bound:u === 0?invalid_arg(err_no_pred):u - 1 | 0}
    function is_valid(i)
     {var _wT_=0 <= i?1:0,_wU_=_wT_?i <= 55295?1:0:_wT_;
      if(_wU_)
       var _wV_=_wU_;
      else
       var _wW_=57344 <= i?1:0,_wV_=_wW_?i <= 1114111?1:0:_wW_;
      return _wV_}
    function of_int(i)
     {return is_valid(i)
              ?i
              :invalid_arg
                (symbol
                  (caml_format_int(cst_X,i),
                   cst_is_not_an_Unicode_scalar_value))}
    function is_char(u){return u < 256?1:0}
    function of_char(c){return c}
    function to_char(u)
     {return 255 < u
              ?invalid_arg
                (symbol
                  (cst_U,
                   symbol
                    (caml_format_int(cst_04X,u),cst_is_not_a_latin1_character)))
              :u}
    function unsafe_to_char(_wS_){return _wS_}
    function equal$0(_wR_,_wQ_){return _wR_ === _wQ_?1:0}
    var compare$0=caml_int_compare;
    function hash(_wP_){return _wP_}
    function _p_(_wO_){return _wO_}
    var
     Uchar=
      [0,
       min$0,
       max$0,
       bom,
       rep,
       succ,
       pred,
       is_valid,
       of_int,
       function(_wN_){return _wN_},
       _p_,
       is_char,
       of_char,
       to_char,
       unsafe_to_char,
       equal$0,
       compare$0,
       hash];
    caml_register_global(647,Uchar,"Uchar");
    function make(n,c)
     {var s=caml_create_bytes(n);caml_fill_bytes(s,0,n,c);return s}
    function init$0(n,f)
     {var s=caml_create_bytes(n),_wL_=n - 1 | 0,_wK_=0;
      if(! (_wL_ < 0))
       {var i=_wK_;
        for(;;)
         {caml_bytes_unsafe_set(s,i,caml_call1(f,i));
          var _wM_=i + 1 | 0;
          if(_wL_ !== i){var i=_wM_;continue}
          break}}
      return s}
    var empty=caml_create_bytes(0);
    function copy(s)
     {var len=caml_ml_bytes_length(s),r=caml_create_bytes(len);
      caml_blit_bytes(s,0,r,0,len);
      return r}
    function to_string(b){return copy(b)}
    function of_string(s){return copy(s)}
    function sub(s,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(s) - len | 0) < ofs))
         {var r=caml_create_bytes(len);
          caml_blit_bytes(s,ofs,r,0,len);
          return r}
      return invalid_arg(cst_String_sub_Bytes_sub)}
    function sub_string(b,ofs,len){return sub(b,ofs,len)}
    function symbol$1(a,b)
     {var
       c=a + b | 0,
       _wJ_=b < 0?1:0,
       match=c < 0?1:0,
       switch$0=
        0 === (a < 0?1:0)
         ?0 === _wJ_?0 === match?0:1:0
         :0 === _wJ_?0:0 === match?1:0;
      return switch$0?invalid_arg(cst_Bytes_extend):c}
    function extend(s,left,right)
     {var
       len=symbol$1(symbol$1(caml_ml_bytes_length(s),left),right),
       r=caml_create_bytes(len);
      if(0 <= left)
       var srcoff=0,dstoff=left;
      else
       var srcoff=- left | 0,dstoff=0;
      var cpylen=min(caml_ml_bytes_length(s) - srcoff | 0,len - dstoff | 0);
      if(0 < cpylen)caml_blit_bytes(s,srcoff,r,dstoff,cpylen);
      return r}
    function fill(s,ofs,len,c)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(s) - len | 0) < ofs))
         return caml_fill_bytes(s,ofs,len,c);
      return invalid_arg(cst_String_fill_Bytes_fill)}
    function blit(s1,ofs1,s2,ofs2,len)
     {if(0 <= len)
       if(0 <= ofs1)
        if(! ((caml_ml_bytes_length(s1) - len | 0) < ofs1))
         if(0 <= ofs2)
          if(! ((caml_ml_bytes_length(s2) - len | 0) < ofs2))
           return caml_blit_bytes(s1,ofs1,s2,ofs2,len);
      return invalid_arg(cst_Bytes_blit)}
    function blit$0(s1,ofs1,s2,ofs2,len)
     {if(0 <= len)
       if(0 <= ofs1)
        if(! ((caml_ml_string_length(s1) - len | 0) < ofs1))
         if(0 <= ofs2)
          if(! ((caml_ml_bytes_length(s2) - len | 0) < ofs2))
           return caml_blit_string(s1,ofs1,s2,ofs2,len);
      return invalid_arg(cst_String_blit_Bytes_blit_string)}
    function iter$0(f,a)
     {var _wH_=caml_ml_bytes_length(a) - 1 | 0,_wG_=0;
      if(! (_wH_ < 0))
       {var i=_wG_;
        for(;;)
         {caml_call1(f,caml_bytes_unsafe_get(a,i));
          var _wI_=i + 1 | 0;
          if(_wH_ !== i){var i=_wI_;continue}
          break}}
      return 0}
    function iteri$0(f,a)
     {var _wE_=caml_ml_bytes_length(a) - 1 | 0,_wD_=0;
      if(! (_wE_ < 0))
       {var i=_wD_;
        for(;;)
         {caml_call2(f,i,caml_bytes_unsafe_get(a,i));
          var _wF_=i + 1 | 0;
          if(_wE_ !== i){var i=_wF_;continue}
          break}}
      return 0}
    function concat(sep,l)
     {if(l)
       {var seplen=caml_ml_bytes_length(sep),acc=0,param=l,pos$1=0;
        for(;;)
         {if(param)
           {var _wy_=param[2],_wz_=param[1];
            if(_wy_)
             {var
               x=(caml_ml_bytes_length(_wz_) + seplen | 0) + acc | 0,
               acc$0=acc <= x?x:invalid_arg(cst_Bytes_concat),
               acc=acc$0,
               param=_wy_;
              continue}
            var _wC_=caml_ml_bytes_length(_wz_) + acc | 0}
          else
           var _wC_=acc;
          var dst=caml_create_bytes(_wC_),pos=pos$1,param$0=l;
          for(;;)
           {if(param$0)
             {var _wA_=param$0[2],_wB_=param$0[1];
              if(_wA_)
               {caml_blit_bytes(_wB_,0,dst,pos,caml_ml_bytes_length(_wB_));
                caml_blit_bytes
                 (sep,0,dst,pos + caml_ml_bytes_length(_wB_) | 0,seplen);
                var
                 pos$0=(pos + caml_ml_bytes_length(_wB_) | 0) + seplen | 0,
                 pos=pos$0,
                 param$0=_wA_;
                continue}
              caml_blit_bytes(_wB_,0,dst,pos,caml_ml_bytes_length(_wB_));
              return dst}
            return dst}}}
      return empty}
    function cat(s1,s2)
     {var
       l1=caml_ml_bytes_length(s1),
       l2=caml_ml_bytes_length(s2),
       r=caml_create_bytes(l1 + l2 | 0);
      caml_blit_bytes(s1,0,r,0,l1);
      caml_blit_bytes(s2,0,r,l1,l2);
      return r}
    function is_space(param)
     {var
       _wx_=param - 9 | 0,
       switch$0=4 < _wx_ >>> 0?23 === _wx_?1:0:2 === _wx_?0:1;
      return switch$0?1:0}
    function trim(s)
     {var len=caml_ml_bytes_length(s),i=[0,0];
      for(;;)
       {if(i[1] < len)
         if(is_space(caml_bytes_unsafe_get(s,i[1]))){i[1]++;continue}
        var j=[0,len - 1 | 0];
        for(;;)
         {if(i[1] <= j[1])
           if(is_space(caml_bytes_unsafe_get(s,j[1]))){j[1] += -1;continue}
          return i[1] <= j[1]?sub(s,i[1],(j[1] - i[1] | 0) + 1 | 0):empty}}}
    function escaped$0(s)
     {var n=[0,0],_wq_=caml_ml_bytes_length(s) - 1 | 0,_wp_=0;
      if(! (_wq_ < 0))
       {var i$0=_wp_;
        for(;;)
         {var match=caml_bytes_unsafe_get(s,i$0);
          if(32 <= match)
           {var _wu_=match - 34 | 0;
            if(58 < _wu_ >>> 0)
             if(93 <= _wu_)var switch$0=0,switch$1=0;else var switch$1=1;
            else
             if(56 < (_wu_ - 1 | 0) >>> 0)
              var switch$0=1,switch$1=0;
             else
              var switch$1=1;
            if(switch$1)var _wv_=1,switch$0=2}
          else
           var switch$0=11 <= match?13 === match?1:0:8 <= match?1:0;
          switch(switch$0){case 0:var _wv_=4;break;case 1:var _wv_=2;break}
          n[1] = n[1] + _wv_ | 0;
          var _ww_=i$0 + 1 | 0;
          if(_wq_ !== i$0){var i$0=_ww_;continue}
          break}}
      if(n[1] === caml_ml_bytes_length(s))return copy(s);
      var s$0=caml_create_bytes(n[1]);
      n[1] = 0;
      var _ws_=caml_ml_bytes_length(s) - 1 | 0,_wr_=0;
      if(! (_ws_ < 0))
       {var i=_wr_;
        for(;;)
         {var c=caml_bytes_unsafe_get(s,i);
          if(35 <= c)
           var switch$2=92 === c?1:127 <= c?0:2;
          else
           if(32 <= c)
            var switch$2=34 <= c?1:2;
           else
            if(14 <= c)
             var switch$2=0;
            else
             switch(c)
              {case 8:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],98);
                var switch$2=3;
                break;
               case 9:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],116);
                var switch$2=3;
                break;
               case 10:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],110);
                var switch$2=3;
                break;
               case 13:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],114);
                var switch$2=3;
                break;
               default:var switch$2=0}
          switch(switch$2)
           {case 0:
             caml_bytes_unsafe_set(s$0,n[1],92);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + (c / 100 | 0) | 0);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + ((c / 10 | 0) % 10 | 0) | 0);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + (c % 10 | 0) | 0);
             break;
            case 1:
             caml_bytes_unsafe_set(s$0,n[1],92);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],c);
             break;
            case 2:caml_bytes_unsafe_set(s$0,n[1],c);break
            }
          n[1]++;
          var _wt_=i + 1 | 0;
          if(_ws_ !== i){var i=_wt_;continue}
          break}}
      return s$0}
    function map$0(f,s)
     {var l=caml_ml_bytes_length(s);
      if(0 === l)return s;
      var r=caml_create_bytes(l),_wn_=l - 1 | 0,_wm_=0;
      if(! (_wn_ < 0))
       {var i=_wm_;
        for(;;)
         {caml_bytes_unsafe_set(r,i,caml_call1(f,caml_bytes_unsafe_get(s,i)));
          var _wo_=i + 1 | 0;
          if(_wn_ !== i){var i=_wo_;continue}
          break}}
      return r}
    function mapi$0(f,s)
     {var l=caml_ml_bytes_length(s);
      if(0 === l)return s;
      var r=caml_create_bytes(l),_wk_=l - 1 | 0,_wj_=0;
      if(! (_wk_ < 0))
       {var i=_wj_;
        for(;;)
         {caml_bytes_unsafe_set
           (r,i,caml_call2(f,i,caml_bytes_unsafe_get(s,i)));
          var _wl_=i + 1 | 0;
          if(_wk_ !== i){var i=_wl_;continue}
          break}}
      return r}
    function uppercase_ascii$0(s){return map$0(uppercase_ascii,s)}
    function lowercase_ascii$0(s){return map$0(lowercase_ascii,s)}
    function apply1(f,s)
     {if(0 === caml_ml_bytes_length(s))return s;
      var r=copy(s);
      caml_bytes_unsafe_set(r,0,caml_call1(f,caml_bytes_unsafe_get(s,0)));
      return r}
    function capitalize_ascii(s){return apply1(uppercase_ascii,s)}
    function uncapitalize_ascii(s){return apply1(lowercase_ascii,s)}
    function index_rec(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)throw Not_found;
        if(caml_bytes_unsafe_get(s,i$0) === c)return i$0;
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index(s,c){return index_rec(s,caml_ml_bytes_length(s),0,c)}
    function index_rec_opt(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)return 0;
        if(caml_bytes_unsafe_get(s,i$0) === c)return [0,i$0];
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index_opt(s,c)
     {return index_rec_opt(s,caml_ml_bytes_length(s),0,c)}
    function index_from(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i)if(! (l < i))return index_rec(s,l,i,c);
      return invalid_arg(cst_String_index_from_Bytes_index_from)}
    function index_from_opt(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i)if(! (l < i))return index_rec_opt(s,l,i,c);
      return invalid_arg(cst_String_index_from_opt_Bytes_index_from_opt)}
    function rindex_rec(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_bytes_unsafe_get(s,i$0) === c)return i$0;
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        throw Not_found}}
    function rindex(s,c)
     {return rindex_rec(s,caml_ml_bytes_length(s) - 1 | 0,c)}
    function rindex_from(s,i,c)
     {if(-1 <= i)if(! (caml_ml_bytes_length(s) <= i))return rindex_rec(s,i,c);
      return invalid_arg(cst_String_rindex_from_Bytes_rindex_from)}
    function rindex_rec_opt(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_bytes_unsafe_get(s,i$0) === c)return [0,i$0];
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        return 0}}
    function rindex_opt(s,c)
     {return rindex_rec_opt(s,caml_ml_bytes_length(s) - 1 | 0,c)}
    function rindex_from_opt(s,i,c)
     {if(-1 <= i)
       if(! (caml_ml_bytes_length(s) <= i))return rindex_rec_opt(s,i,c);
      return invalid_arg(cst_String_rindex_from_opt_Bytes_rindex_from_opt)}
    function contains_from(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i)
       if(! (l < i))
        try
         {index_rec(s,l,i,c);var _wh_=1;return _wh_}
        catch(_wi_)
         {_wi_ = caml_wrap_exception(_wi_);
          if(_wi_ === Not_found)return 0;
          throw _wi_}
      return invalid_arg(cst_String_contains_from_Bytes_contains_from)}
    function contains(s,c){return contains_from(s,0,c)}
    function rcontains_from(s,i,c)
     {if(0 <= i)
       if(! (caml_ml_bytes_length(s) <= i))
        try
         {rindex_rec(s,i,c);var _wf_=1;return _wf_}
        catch(_wg_)
         {_wg_ = caml_wrap_exception(_wg_);
          if(_wg_ === Not_found)return 0;
          throw _wg_}
      return invalid_arg(cst_String_rcontains_from_Bytes_rcontains_from)}
    var compare$1=runtime.caml_bytes_compare;
    function uppercase$0(s){return map$0(uppercase,s)}
    function lowercase$0(s){return map$0(lowercase,s)}
    function capitalize(s){return apply1(uppercase,s)}
    function uncapitalize(s){return apply1(lowercase,s)}
    function unsafe_of_string(_we_){return _we_}
    function unsafe_to_string(_wd_){return _wd_}
    var
     equal$1=runtime.caml_bytes_equal,
     include$0=
      [0,
       make,
       init$0,
       empty,
       copy,
       of_string,
       to_string,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit$0,
       concat,
       cat,
       iter$0,
       iteri$0,
       map$0,
       mapi$0,
       trim,
       escaped$0,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase$0,
       lowercase$0,
       capitalize,
       uncapitalize,
       uppercase_ascii$0,
       lowercase_ascii$0,
       capitalize_ascii,
       uncapitalize_ascii,
       compare$1,
       equal$1,
       unsafe_to_string,
       unsafe_of_string];
    caml_register_global(648,include$0,"Bytes");
    function make$0(n,c){return make(n,c)}
    function init$1(n,f){return init$0(n,f)}
    function copy$0(s){return copy(s)}
    function sub$0(s,ofs,len){return sub(s,ofs,len)}
    function concat$0(sep,l)
     {if(l)
       {var seplen=caml_ml_string_length(sep),acc=0,param=l,pos$1=0;
        for(;;)
         {if(param)
           {var _v__=param[2],_v$_=param[1];
            if(_v__)
             {var
               x=(caml_ml_string_length(_v$_) + seplen | 0) + acc | 0,
               acc$0=acc <= x?x:invalid_arg(cst_String_concat),
               acc=acc$0,
               param=_v__;
              continue}
            var _wc_=caml_ml_string_length(_v$_) + acc | 0}
          else
           var _wc_=acc;
          var dst=caml_create_bytes(_wc_),pos=pos$1,param$0=l;
          for(;;)
           {if(param$0)
             {var _wa_=param$0[2],_wb_=param$0[1];
              if(_wa_)
               {caml_blit_string(_wb_,0,dst,pos,caml_ml_string_length(_wb_));
                caml_blit_string
                 (sep,0,dst,pos + caml_ml_string_length(_wb_) | 0,seplen);
                var
                 pos$0=(pos + caml_ml_string_length(_wb_) | 0) + seplen | 0,
                 pos=pos$0,
                 param$0=_wa_;
                continue}
              caml_blit_string(_wb_,0,dst,pos,caml_ml_string_length(_wb_));
              return dst}
            return dst}}}
      return cst$3}
    function iter$1(f,s)
     {var _v8_=caml_ml_string_length(s) - 1 | 0,_v7_=0;
      if(! (_v8_ < 0))
       {var i=_v7_;
        for(;;)
         {caml_call1(f,caml_bytes_unsafe_get(s,i));
          var _v9_=i + 1 | 0;
          if(_v8_ !== i){var i=_v9_;continue}
          break}}
      return 0}
    function iteri$1(f,s)
     {var _v5_=caml_ml_string_length(s) - 1 | 0,_v4_=0;
      if(! (_v5_ < 0))
       {var i=_v4_;
        for(;;)
         {caml_call2(f,i,caml_bytes_unsafe_get(s,i));
          var _v6_=i + 1 | 0;
          if(_v5_ !== i){var i=_v6_;continue}
          break}}
      return 0}
    function map$1(f,s){return map$0(f,s)}
    function mapi$1(f,s){return mapi$0(f,s)}
    function is_space$0(param)
     {var
       _v3_=param - 9 | 0,
       switch$0=4 < _v3_ >>> 0?23 === _v3_?1:0:2 === _v3_?0:1;
      return switch$0?1:0}
    function trim$0(s)
     {if(caml_string_equal(s,cst$4))return s;
      if(! is_space$0(caml_bytes_unsafe_get(s,0)))
       if
        (!
         is_space$0(caml_bytes_unsafe_get(s,caml_ml_string_length(s) - 1 | 0)))
        return s;
      return trim(s)}
    function escaped$1(s)
     {var i=0;
      for(;;)
       {if(caml_ml_string_length(s) <= i)
         var _v2_=0;
        else
         {var match=caml_bytes_unsafe_get(s,i);
          if(32 <= match)
           {var _v1_=match - 34 | 0;
            if(58 < _v1_ >>> 0)
             if(93 <= _v1_)var switch$0=0,switch$1=0;else var switch$1=1;
            else
             if(56 < (_v1_ - 1 | 0) >>> 0)
              var switch$0=1,switch$1=0;
             else
              var switch$1=1;
            if(switch$1){var i$0=i + 1 | 0,i=i$0;continue}}
          else
           var switch$0=11 <= match?13 === match?1:0:8 <= match?1:0;
          var _v2_=switch$0?1:1}
        return _v2_?escaped$0(s):s}}
    function index_rec$0(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)throw Not_found;
        if(caml_bytes_unsafe_get(s,i$0) === c)return i$0;
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index$0(s,c){return index_rec$0(s,caml_ml_string_length(s),0,c)}
    function index_rec_opt$0(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)return 0;
        if(caml_bytes_unsafe_get(s,i$0) === c)return [0,i$0];
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index_opt$0(s,c)
     {return index_rec_opt$0(s,caml_ml_string_length(s),0,c)}
    function index_from$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i)if(! (l < i))return index_rec$0(s,l,i,c);
      return invalid_arg(cst_String_index_from_Bytes_index_from$0)}
    function index_from_opt$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i)if(! (l < i))return index_rec_opt$0(s,l,i,c);
      return invalid_arg(cst_String_index_from_opt_Bytes_index_from_opt$0)}
    function rindex_rec$0(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_bytes_unsafe_get(s,i$0) === c)return i$0;
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        throw Not_found}}
    function rindex$0(s,c)
     {return rindex_rec$0(s,caml_ml_string_length(s) - 1 | 0,c)}
    function rindex_from$0(s,i,c)
     {if(-1 <= i)
       if(! (caml_ml_string_length(s) <= i))return rindex_rec$0(s,i,c);
      return invalid_arg(cst_String_rindex_from_Bytes_rindex_from$0)}
    function rindex_rec_opt$0(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_bytes_unsafe_get(s,i$0) === c)return [0,i$0];
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        return 0}}
    function rindex_opt$0(s,c)
     {return rindex_rec_opt$0(s,caml_ml_string_length(s) - 1 | 0,c)}
    function rindex_from_opt$0(s,i,c)
     {if(-1 <= i)
       if(! (caml_ml_string_length(s) <= i))return rindex_rec_opt$0(s,i,c);
      return invalid_arg(cst_String_rindex_from_opt_Bytes_rindex_from_opt$0)}
    function contains_from$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i)
       if(! (l < i))
        try
         {index_rec$0(s,l,i,c);var _vZ_=1;return _vZ_}
        catch(_v0_)
         {_v0_ = caml_wrap_exception(_v0_);
          if(_v0_ === Not_found)return 0;
          throw _v0_}
      return invalid_arg(cst_String_contains_from_Bytes_contains_from$0)}
    function contains$0(s,c){return contains_from$0(s,0,c)}
    function rcontains_from$0(s,i,c)
     {if(0 <= i)
       if(! (caml_ml_string_length(s) <= i))
        try
         {rindex_rec$0(s,i,c);var _vX_=1;return _vX_}
        catch(_vY_)
         {_vY_ = caml_wrap_exception(_vY_);
          if(_vY_ === Not_found)return 0;
          throw _vY_}
      return invalid_arg(cst_String_rcontains_from_Bytes_rcontains_from$0)}
    function uppercase_ascii$1(s){return uppercase_ascii$0(s)}
    function lowercase_ascii$1(s){return lowercase_ascii$0(s)}
    function capitalize_ascii$0(s){return capitalize_ascii(s)}
    function uncapitalize_ascii$0(s){return uncapitalize_ascii(s)}
    var compare$2=caml_string_compare;
    function split_on_char(sep,s)
     {var
       r=[0,0],
       j=[0,caml_ml_string_length(s)],
       _vT_=caml_ml_string_length(s) - 1 | 0;
      if(! (_vT_ < 0))
       {var i=_vT_;
        for(;;)
         {if(caml_bytes_unsafe_get(s,i) === sep)
           {var _vV_=r[1];
            r[1] = [0,sub$0(s,i + 1 | 0,(j[1] - i | 0) - 1 | 0),_vV_];
            j[1] = i}
          var _vW_=i - 1 | 0;
          if(0 !== i){var i=_vW_;continue}
          break}}
      var _vU_=r[1];
      return [0,sub$0(s,0,j[1]),_vU_]}
    function uppercase$1(s){return uppercase$0(s)}
    function lowercase$1(s){return lowercase$0(s)}
    function capitalize$0(s){return capitalize(s)}
    function uncapitalize$0(s){return uncapitalize(s)}
    var
     equal$2=caml_string_equal,
     include$1=
      [0,
       make$0,
       init$1,
       copy$0,
       sub$0,
       fill,
       blit$0,
       concat$0,
       iter$1,
       iteri$1,
       map$1,
       mapi$1,
       trim$0,
       escaped$1,
       index$0,
       index_opt$0,
       rindex$0,
       rindex_opt$0,
       index_from$0,
       index_from_opt$0,
       rindex_from$0,
       rindex_from_opt$0,
       contains$0,
       contains_from$0,
       rcontains_from$0,
       uppercase$1,
       lowercase$1,
       capitalize$0,
       uncapitalize$0,
       uppercase_ascii$1,
       lowercase_ascii$1,
       capitalize_ascii$0,
       uncapitalize_ascii$0,
       compare$2,
       equal$2,
       split_on_char];
    caml_register_global(649,include$1,"String");
    var
     match=runtime.caml_sys_get_argv(0),
     _q_=match[2],
     match$0=runtime.caml_sys_get_config(0),
     os_type=match$0[1],
     backend_type=runtime.caml_sys_const_backend_type(0),
     unix=runtime.caml_sys_const_ostype_unix(0),
     win32=runtime.caml_sys_const_ostype_win32(0),
     cygwin=runtime.caml_sys_const_ostype_cygwin(0),
     max_array_length=runtime.caml_sys_const_max_wosize(0),
     max_string_length=(4 * max_array_length | 0) - 1 | 0,
     _r_=match[1],
     big_endian=0,
     size=32,
     int_size=32;
    function getenv_opt(s)
     {try
       {var _vR_=[0,caml_sys_getenv(s)];return _vR_}
      catch(_vS_)
       {_vS_ = caml_wrap_exception(_vS_);
        if(_vS_ === Not_found)return 0;
        throw _vS_}}
    var interactive=[0,0];
    function set_signal(sig_num,sig_beh){return 0}
    var
     Break=[248,cst_Sys_Break,caml_fresh_oo_id(0)],
     sigabrt=-1,
     sigalrm=-2,
     sigfpe=-3,
     sighup=-4,
     sigill=-5,
     sigint=-6,
     sigkill=-7,
     sigpipe=-8,
     sigquit=-9,
     sigsegv=-10,
     sigterm=-11,
     sigusr1=-12,
     sigusr2=-13,
     sigchld=-14,
     sigcont=-15,
     sigstop=-16,
     sigtstp=-17,
     sigttin=-18,
     sigttou=-19,
     sigvtalrm=-20,
     sigprof=-21,
     sigbus=-22,
     sigpoll=-23,
     sigsys=-24,
     sigtrap=-25,
     sigurg=-26,
     sigxcpu=-27,
     sigxfsz=-28;
    function catch_break(on){return on?0:0}
    var
     Sys=
      [0,
       _q_,
       _r_,
       getenv_opt,
       interactive,
       os_type,
       backend_type,
       unix,
       win32,
       cygwin,
       size,
       int_size,
       big_endian,
       max_string_length,
       max_array_length,
       set_signal,
       sigabrt,
       sigalrm,
       sigfpe,
       sighup,
       sigill,
       sigint,
       sigkill,
       sigpipe,
       sigquit,
       sigsegv,
       sigterm,
       sigusr1,
       sigusr2,
       sigchld,
       sigcont,
       sigstop,
       sigtstp,
       sigttin,
       sigttou,
       sigvtalrm,
       sigprof,
       sigbus,
       sigpoll,
       sigsys,
       sigtrap,
       sigurg,
       sigxcpu,
       sigxfsz,
       Break,
       catch_break,
       ocaml_version,
       runtime.caml_ml_enable_runtime_warnings,
       runtime.caml_ml_runtime_warnings_enabled];
    caml_register_global(650,Sys,"Sys");
    function merge$0(order,l1,l2)
     {if(l1)
       {var t1=l1[2],h1=l1[1];
        if(l2)
         {var t2=l2[2],h2=l2[1];
          return caml_call2(order,h1,h2)
                  ?[0,h1,merge$0(order,t1,l2)]
                  :[0,h2,merge$0(order,l1,t2)]}
        return l1}
      return l2}
    function list(order,l)
     {function initlist(param)
       {if(param)
         {var _vN_=param[2],_vO_=param[1];
          if(_vN_)
           {var
             rest=_vN_[2],
             e2=_vN_[1],
             _vP_=initlist(rest),
             _vQ_=
              caml_call2(order,_vO_,e2)?[0,_vO_,[0,e2,0]]:[0,e2,[0,_vO_,0]];
            return [0,_vQ_,_vP_]}
          return [0,[0,_vO_,0],0]}
        return 0}
      function merge2(x)
       {if(x)
         {var _vL_=x[2];
          if(_vL_)
           {var rest=_vL_[2],l2=_vL_[1],l1=x[1],_vM_=merge2(rest);
            return [0,merge$0(order,l1,l2),_vM_]}}
        return x}
      var llist$1=initlist(l),llist=llist$1;
      for(;;)
       {if(llist)
         {if(llist[2]){var llist$0=merge2(llist),llist=llist$0;continue}
          var l$0=llist[1];
          return l$0}
        return 0}}
    function swap(arr,i,j)
     {var tmp=arr[1 + i];arr[1 + i] = arr[1 + j];arr[1 + j] = tmp;return 0}
    function array(cmp,arr)
     {function qsort(lo,hi)
       {var lo$0=lo,hi$0=hi;
        a:
        for(;;)
         {var _vI_=6 <= (hi$0 - lo$0 | 0)?1:0;
          if(_vI_)
           {var mid=(lo$0 + hi$0 | 0) >>> 1 | 0;
            if(caml_call2(cmp,arr[1 + mid],arr[1 + lo$0]))swap(arr,mid,lo$0);
            if(caml_call2(cmp,arr[1 + hi$0],arr[1 + mid]))
             {swap(arr,mid,hi$0);
              if(caml_call2(cmp,arr[1 + mid],arr[1 + lo$0]))swap(arr,mid,lo$0)}
            var
             pivot=arr[1 + mid],
             i=[0,lo$0 + 1 | 0],
             j=[0,hi$0 - 1 | 0],
             _vJ_=1 - caml_call2(cmp,pivot,arr[1 + hi$0]),
             _vK_=_vJ_ || 1 - caml_call2(cmp,arr[1 + lo$0],pivot);
            if(_vK_)throw [0,Invalid_argument,cst_Sort_array];
            b:
            for(;;)
             {if(i[1] < j[1])
               for(;;)
                {if(caml_call2(cmp,pivot,arr[1 + i[1]]))
                  for(;;)
                   {if(caml_call2(cmp,arr[1 + j[1]],pivot))
                     {if(i[1] < j[1])swap(arr,i[1],j[1]);
                      i[1]++;
                      j[1] += -1;
                      continue b}
                    j[1] += -1;
                    continue}
                 i[1]++;
                 continue}
              if((j[1] - lo$0 | 0) <= (hi$0 - i[1] | 0))
               {qsort(lo$0,j[1]);var lo$1=i[1],lo$0=lo$1;continue a}
              qsort(i[1],hi$0);
              var hi$1=j[1],hi$0=hi$1;
              continue a}}
          return _vI_}}
      qsort(0,arr.length - 1 - 1 | 0);
      var _vG_=arr.length - 1 - 1 | 0,_vF_=1;
      if(! (_vG_ < 1))
       {var i=_vF_;
        for(;;)
         {var val_i=arr[1 + i];
          if(1 - caml_call2(cmp,arr[1 + (i - 1 | 0)],val_i))
           {arr[1 + i] = arr[1 + (i - 1 | 0)];
            var j=[0,i - 1 | 0];
            for(;;)
             {if(1 <= j[1])
               if(! caml_call2(cmp,arr[1 + (j[1] - 1 | 0)],val_i))
                {arr[1 + j[1]] = arr[1 + (j[1] - 1 | 0)];j[1] += -1;continue}
              arr[1 + j[1]] = val_i;
              break}}
          var _vH_=i + 1 | 0;
          if(_vG_ !== i){var i=_vH_;continue}
          break}}
      return 0}
    var Sort=[0,list,array,merge$0];
    caml_register_global(651,Sort,"Sort");
    function to_buffer(buff,ofs,len,v,flags)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(buff) - len | 0) < ofs))
         return runtime.caml_output_value_to_buffer(buff,ofs,len,v,flags);
      return invalid_arg(cst_Marshal_to_buffer_substring_out_of_bounds)}
    var header_size=20;
    function data_size(buff,ofs)
     {if(0 <= ofs)
       if(! ((caml_ml_bytes_length(buff) - 20 | 0) < ofs))
        return caml_marshal_data_size(buff,ofs);
      return invalid_arg(cst_Marshal_data_size)}
    function total_size(buff,ofs){return 20 + data_size(buff,ofs) | 0}
    function from_bytes(buff,ofs)
     {if(0 <= ofs)
       if(! ((caml_ml_bytes_length(buff) - 20 | 0) < ofs))
        {var len=caml_marshal_data_size(buff,ofs);
         return (caml_ml_bytes_length(buff) - (20 + len | 0) | 0) < ofs
                 ?invalid_arg(cst_Marshal_from_bytes$0)
                 :runtime.caml_input_value_from_string(buff,ofs)}
      return invalid_arg(cst_Marshal_from_bytes)}
    function from_string(buff,ofs){return from_bytes(buff,ofs)}
    var
     Marshal=
      [0,
       caml_output_value,
       to_buffer,
       caml_input_value,
       from_bytes,
       from_string,
       header_size,
       data_size,
       total_size];
    caml_register_global(652,Marshal,"Marshal");
    function is_block(a){return 1 - (typeof a === "number"?1:0)}
    var
     double_field=runtime.caml_array_get,
     set_double_field=runtime.caml_array_set;
    function marshal(obj){return runtime.caml_output_value_to_string(obj,0)}
    function unmarshal(str,pos)
     {var _vE_=pos + total_size(str,pos) | 0;
      return [0,from_bytes(str,pos),_vE_]}
    var
     first_non_constant_constructor_tag=0,
     last_non_constant_constructor_tag=245,
     lazy_tag=246,
     closure_tag=247,
     object_tag=248,
     infix_tag=249,
     forward_tag=250,
     no_scan_tag=251,
     abstract_tag=251,
     string_tag=252,
     double_tag=253,
     double_array_tag=254,
     custom_tag=255,
     int_tag=1000,
     out_of_heap_tag=1001,
     unaligned_tag=1002;
    function extension_constructor(x)
     {if(is_block(x))
       if(caml_obj_tag(x) !== 248)
        if(1 <= x.length - 1)var slot=x[1],switch$0=1;else var switch$0=0;
       else
        var switch$0=0;
      else
       var switch$0=0;
      if(! switch$0)var slot=x;
      if(is_block(slot))
       if(caml_obj_tag(slot) === 248)
        var name=slot[1],switch$1=1;
       else
        var switch$1=0;
      else
       var switch$1=0;
      if(! switch$1)var name=invalid_arg(cst_Obj_extension_constructor$0);
      return caml_obj_tag(name) === 252
              ?slot
              :invalid_arg(cst_Obj_extension_constructor)}
    function extension_name(slot){return slot[1]}
    function extension_id(slot){return slot[2]}
    function length$0(x){return x.length - 1 - 2 | 0}
    var _s_=runtime.caml_ephe_blit_data,_t_=runtime.caml_ephe_check_data;
    function _u_(_vD_){return runtime.caml_ephe_unset_data(_vD_)}
    var
     _v_=runtime.caml_ephe_set_data,
     _w_=runtime.caml_ephe_get_data_copy,
     _x_=runtime.caml_ephe_get_data;
    function _y_(_vC_,_vB_,_vA_,_vz_,_vy_)
     {return runtime.caml_ephe_blit_key(_vC_,_vB_,_vA_,_vz_,_vy_)}
    function _z_(_vx_,_vw_){return runtime.caml_ephe_check_key(_vx_,_vw_)}
    var _A_=runtime.caml_ephe_unset_key,_B_=runtime.caml_ephe_set_key;
    function _C_(_vv_,_vu_){return runtime.caml_ephe_get_key_copy(_vv_,_vu_)}
    function _D_(_vt_,_vs_){return runtime.caml_ephe_get_key(_vt_,_vs_)}
    var
     _E_=
      [0,
       function(_vr_){return runtime.caml_ephe_create(_vr_)},
       length$0,
       _D_,
       _C_,
       _B_,
       _A_,
       _z_,
       _y_,
       _x_,
       _w_,
       _v_,
       _u_,
       _t_,
       _s_],
     Obj=
      [0,
       is_block,
       double_field,
       set_double_field,
       first_non_constant_constructor_tag,
       last_non_constant_constructor_tag,
       lazy_tag,
       closure_tag,
       object_tag,
       infix_tag,
       forward_tag,
       no_scan_tag,
       abstract_tag,
       string_tag,
       double_tag,
       double_array_tag,
       custom_tag,
       custom_tag,
       int_tag,
       out_of_heap_tag,
       unaligned_tag,
       extension_constructor,
       extension_name,
       extension_id,
       marshal,
       unmarshal,
       _E_];
    caml_register_global(653,Obj,"Obj");
    var make_float=runtime.caml_make_float_vect,Floatarray=[0];
    function init$2(l,f)
     {if(0 === l)return [0];
      if(0 <= l)
       {var res=caml_make_vect(l,caml_call1(f,0)),_vp_=l - 1 | 0,_vo_=1;
        if(! (_vp_ < 1))
         {var i=_vo_;
          for(;;)
           {res[1 + i] = caml_call1(f,i);
            var _vq_=i + 1 | 0;
            if(_vp_ !== i){var i=_vq_;continue}
            break}}
        return res}
      return invalid_arg(cst_Array_init)}
    function create_matrix(sx,sy,init)
     {var res=caml_make_vect(sx,[0]),_vm_=sx - 1 | 0,_vl_=0;
      if(! (_vm_ < 0))
       {var x=_vl_;
        for(;;)
         {res[1 + x] = caml_make_vect(sy,init);
          var _vn_=x + 1 | 0;
          if(_vm_ !== x){var x=_vn_;continue}
          break}}
      return res}
    function copy$1(a)
     {var l=a.length - 1;return 0 === l?[0]:caml_array_sub(a,0,l)}
    function append$0(a1,a2)
     {var l1=a1.length - 1;
      return 0 === l1
              ?copy$1(a2)
              :0 === a2.length - 1
                ?caml_array_sub(a1,0,l1)
                :runtime.caml_array_append(a1,a2)}
    function sub$1(a,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((a.length - 1 - len | 0) < ofs))
         return caml_array_sub(a,ofs,len);
      return invalid_arg(cst_Array_sub)}
    function fill$0(a,ofs,len,v)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((a.length - 1 - len | 0) < ofs))
         {var _vj_=(ofs + len | 0) - 1 | 0;
          if(! (_vj_ < ofs))
           {var i=ofs;
            for(;;)
             {a[1 + i] = v;
              var _vk_=i + 1 | 0;
              if(_vj_ !== i){var i=_vk_;continue}
              break}}
          return 0}
      return invalid_arg(cst_Array_fill)}
    function blit$1(a1,ofs1,a2,ofs2,len)
     {if(0 <= len)
       if(0 <= ofs1)
        if(! ((a1.length - 1 - len | 0) < ofs1))
         if(0 <= ofs2)
          if(! ((a2.length - 1 - len | 0) < ofs2))
           return runtime.caml_array_blit(a1,ofs1,a2,ofs2,len);
      return invalid_arg(cst_Array_blit)}
    function iter$2(f,a)
     {var _vh_=a.length - 1 - 1 | 0,_vg_=0;
      if(! (_vh_ < 0))
       {var i=_vg_;
        for(;;)
         {caml_call1(f,a[1 + i]);
          var _vi_=i + 1 | 0;
          if(_vh_ !== i){var i=_vi_;continue}
          break}}
      return 0}
    function iter2$0(f,a,b)
     {if(a.length - 1 !== b.length - 1)
       return invalid_arg(cst_Array_iter2_arrays_must_have_the_same_length);
      var _ve_=a.length - 1 - 1 | 0,_vd_=0;
      if(! (_ve_ < 0))
       {var i=_vd_;
        for(;;)
         {caml_call2(f,a[1 + i],b[1 + i]);
          var _vf_=i + 1 | 0;
          if(_ve_ !== i){var i=_vf_;continue}
          break}}
      return 0}
    function map$2(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call1(f,a[1])),_vb_=l - 1 | 0,_va_=1;
      if(! (_vb_ < 1))
       {var i=_va_;
        for(;;)
         {r[1 + i] = caml_call1(f,a[1 + i]);
          var _vc_=i + 1 | 0;
          if(_vb_ !== i){var i=_vc_;continue}
          break}}
      return r}
    function map2$0(f,a,b)
     {var la=a.length - 1,lb=b.length - 1;
      if(la !== lb)
       return invalid_arg(cst_Array_map2_arrays_must_have_the_same_length);
      if(0 === la)return [0];
      var r=caml_make_vect(la,caml_call2(f,a[1],b[1])),_u__=la - 1 | 0,_u9_=1;
      if(! (_u__ < 1))
       {var i=_u9_;
        for(;;)
         {r[1 + i] = caml_call2(f,a[1 + i],b[1 + i]);
          var _u$_=i + 1 | 0;
          if(_u__ !== i){var i=_u$_;continue}
          break}}
      return r}
    function iteri$2(f,a)
     {var _u7_=a.length - 1 - 1 | 0,_u6_=0;
      if(! (_u7_ < 0))
       {var i=_u6_;
        for(;;)
         {caml_call2(f,i,a[1 + i]);
          var _u8_=i + 1 | 0;
          if(_u7_ !== i){var i=_u8_;continue}
          break}}
      return 0}
    function mapi$2(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call2(f,0,a[1])),_u4_=l - 1 | 0,_u3_=1;
      if(! (_u4_ < 1))
       {var i=_u3_;
        for(;;)
         {r[1 + i] = caml_call2(f,i,a[1 + i]);
          var _u5_=i + 1 | 0;
          if(_u4_ !== i){var i=_u5_;continue}
          break}}
      return r}
    function to_list(a)
     {var i$1=a.length - 1 - 1 | 0,i=i$1,res=0;
      for(;;)
       {if(0 <= i)
         {var res$0=[0,a[1 + i],res],i$0=i - 1 | 0,i=i$0,res=res$0;continue}
        return res}}
    function of_list(l)
     {if(l)
       {var tl=l[2],hd=l[1],accu=0,param=l;
        for(;;)
         {if(param)
           {var
             param$0=param[2],
             accu$0=accu + 1 | 0,
             accu=accu$0,
             param=param$0;
            continue}
          var a=caml_make_vect(accu,hd),i=1,param$1=tl;
          for(;;)
           {if(param$1)
             {var tl$0=param$1[2],hd$0=param$1[1];
              a[1 + i] = hd$0;
              var i$0=i + 1 | 0,i=i$0,param$1=tl$0;
              continue}
            return a}}}
      return [0]}
    function fold_left$0(f,x,a)
     {var r=[0,x],_u1_=a.length - 1 - 1 | 0,_u0_=0;
      if(! (_u1_ < 0))
       {var i=_u0_;
        for(;;)
         {r[1] = caml_call2(f,r[1],a[1 + i]);
          var _u2_=i + 1 | 0;
          if(_u1_ !== i){var i=_u2_;continue}
          break}}
      return r[1]}
    function fold_right$0(f,a,x)
     {var r=[0,x],_uY_=a.length - 1 - 1 | 0;
      if(! (_uY_ < 0))
       {var i=_uY_;
        for(;;)
         {r[1] = caml_call2(f,a[1 + i],r[1]);
          var _uZ_=i - 1 | 0;
          if(0 !== i){var i=_uZ_;continue}
          break}}
      return r[1]}
    function exists$0(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(caml_call1(p,a[1 + i]))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function for_all$0(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 1;
        if(caml_call1(p,a[1 + i])){var i$0=i + 1 | 0,i=i$0;continue}
        return 0}}
    function mem$0(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(0 === caml_compare(a[1 + i],x))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function memq$0(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(x === a[1 + i])return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    var Bottom=[248,cst_Array_Bottom,caml_fresh_oo_id(0)];
    function sort(cmp,a)
     {function maxson(l,i)
       {var i31=((i + i | 0) + i | 0) + 1 | 0,x=[0,i31];
        if((i31 + 2 | 0) < l)
         {var _uR_=i31 + 1 | 0,_uS_=caml_check_bound(a,_uR_)[1 + _uR_];
          if(caml_call2(cmp,caml_check_bound(a,i31)[1 + i31],_uS_) < 0)
           x[1] = i31 + 1 | 0;
          var
           _uT_=i31 + 2 | 0,
           _uU_=caml_check_bound(a,_uT_)[1 + _uT_],
           _uV_=x[1];
          if(caml_call2(cmp,caml_check_bound(a,_uV_)[1 + _uV_],_uU_) < 0)
           x[1] = i31 + 2 | 0;
          return x[1]}
        if((i31 + 1 | 0) < l)
         {var _uW_=i31 + 1 | 0,_uX_=caml_check_bound(a,_uW_)[1 + _uW_];
          if(! (0 <= caml_call2(cmp,caml_check_bound(a,i31)[1 + i31],_uX_)))
           return i31 + 1 | 0}
        if(i31 < l)return i31;
        throw [0,Bottom,i]}
      function trickledown(l,i,e)
       {var i$0=i;
        for(;;)
         {var j=maxson(l,i$0);
          if(0 < caml_call2(cmp,caml_check_bound(a,j)[1 + j],e))
           {var _uQ_=caml_check_bound(a,j)[1 + j];
            caml_check_bound(a,i$0)[1 + i$0] = _uQ_;
            var i$0=j;
            continue}
          caml_check_bound(a,i$0)[1 + i$0] = e;
          return 0}}
      function trickle(l,i,e)
       {try
         {var _uP_=trickledown(l,i,e);return _uP_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom)
           {var i$0=exn[2];caml_check_bound(a,i$0)[1 + i$0] = e;return 0}
          throw exn}}
      function bubbledown(l,i)
       {var i$0=i;
        for(;;)
         {var i$1=maxson(l,i$0),_uO_=caml_check_bound(a,i$1)[1 + i$1];
          caml_check_bound(a,i$0)[1 + i$0] = _uO_;
          var i$0=i$1;
          continue}}
      function bubble(l,i)
       {try
         {var _uN_=bubbledown(l,i);return _uN_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom){var i$0=exn[2];return i$0}
          throw exn}}
      var l=a.length - 1,_uF_=((l + 1 | 0) / 3 | 0) - 1 | 0;
      if(! (_uF_ < 0))
       {var i$2=_uF_;
        for(;;)
         {trickle(l,i$2,caml_check_bound(a,i$2)[1 + i$2]);
          var _uM_=i$2 - 1 | 0;
          if(0 !== i$2){var i$2=_uM_;continue}
          break}}
      var _uG_=l - 1 | 0;
      if(! (_uG_ < 2))
       {var i$0=_uG_;
        a:
        for(;;)
         {var
           e$0=caml_check_bound(a,i$0)[1 + i$0],
           _uK_=caml_check_bound(a,0)[1];
          caml_check_bound(a,i$0)[1 + i$0] = _uK_;
          var i$1=bubble(i$0,0),i=i$1;
          for(;;)
           {var father=(i - 1 | 0) / 3 | 0;
            if(i === father)throw [0,Assert_failure,_F_];
            if
             (0 <= caml_call2(cmp,caml_check_bound(a,father)[1 + father],e$0))
             caml_check_bound(a,i)[1 + i] = e$0;
            else
             {var _uE_=caml_check_bound(a,father)[1 + father];
              caml_check_bound(a,i)[1 + i] = _uE_;
              if(0 < father){var i=father;continue}
              caml_check_bound(a,0)[1] = e$0}
            var _uL_=i$0 - 1 | 0;
            if(2 !== i$0){var i$0=_uL_;continue a}
            break}
          break}}
      var _uH_=1 < l?1:0;
      if(_uH_)
       {var e=caml_check_bound(a,1)[2],_uI_=caml_check_bound(a,0)[1];
        caml_check_bound(a,1)[2] = _uI_;
        caml_check_bound(a,0)[1] = e;
        var _uJ_=0}
      else
       var _uJ_=_uH_;
      return _uJ_}
    function fast_sort$0(cmp,a)
     {function merge(src1ofs,src1len,src2,src2ofs,src2len,dst,dstofs)
       {var
         src1r=src1ofs + src1len | 0,
         src2r=src2ofs + src2len | 0,
         s2$1=caml_check_bound(src2,src2ofs)[1 + src2ofs],
         s1$1=caml_check_bound(a,src1ofs)[1 + src1ofs],
         i1=src1ofs,
         s1=s1$1,
         i2=src2ofs,
         s2=s2$1,
         d=dstofs;
        for(;;)
         {if(0 < caml_call2(cmp,s1,s2))
           {caml_check_bound(dst,d)[1 + d] = s2;
            var i2$0=i2 + 1 | 0;
            if(i2$0 < src2r)
             {var
               d$0=d + 1 | 0,
               s2$0=caml_check_bound(src2,i2$0)[1 + i2$0],
               i2=i2$0,
               s2=s2$0,
               d=d$0;
              continue}
            return blit$1(a,i1,dst,d + 1 | 0,src1r - i1 | 0)}
          caml_check_bound(dst,d)[1 + d] = s1;
          var i1$0=i1 + 1 | 0;
          if(i1$0 < src1r)
           {var
             d$1=d + 1 | 0,
             s1$0=caml_check_bound(a,i1$0)[1 + i1$0],
             i1=i1$0,
             s1=s1$0,
             d=d$1;
            continue}
          return blit$1(src2,i2,dst,d + 1 | 0,src2r - i2 | 0)}}
      function isortto(srcofs,dst,dstofs,len)
       {var _uw_=len - 1 | 0,_uv_=0;
        if(! (_uw_ < 0))
         {var i=_uv_;
          a:
          for(;;)
           {var
             _ux_=srcofs + i | 0,
             e=caml_check_bound(a,_ux_)[1 + _ux_],
             j=[0,(dstofs + i | 0) - 1 | 0];
            for(;;)
             {if(dstofs <= j[1])
               {var _uy_=j[1];
                if(0 < caml_call2(cmp,caml_check_bound(dst,_uy_)[1 + _uy_],e))
                 {var
                   _uz_=j[1],
                   _uA_=caml_check_bound(dst,_uz_)[1 + _uz_],
                   _uB_=j[1] + 1 | 0;
                  caml_check_bound(dst,_uB_)[1 + _uB_] = _uA_;
                  j[1] += -1;
                  continue}}
              var _uC_=j[1] + 1 | 0;
              caml_check_bound(dst,_uC_)[1 + _uC_] = e;
              var _uD_=i + 1 | 0;
              if(_uw_ !== i){var i=_uD_;continue a}
              break}
            break}}
        return 0}
      function sortto(srcofs,dst,dstofs,len)
       {if(len <= 5)return isortto(srcofs,dst,dstofs,len);
        var l1=len / 2 | 0,l2=len - l1 | 0;
        sortto(srcofs + l1 | 0,dst,dstofs + l1 | 0,l2);
        sortto(srcofs,a,srcofs + l2 | 0,l1);
        return merge(srcofs + l2 | 0,l1,dst,dstofs + l1 | 0,l2,dst,dstofs)}
      var l=a.length - 1;
      if(l <= 5)return isortto(0,a,0,l);
      var
       l1=l / 2 | 0,
       l2=l - l1 | 0,
       t=caml_make_vect(l2,caml_check_bound(a,0)[1]);
      sortto(l1,t,0,l2);
      sortto(0,a,l2,l1);
      return merge(l2,l1,t,0,l2,a,0)}
    var
     concat$1=caml_array_concat,
     include$2=
      [0,
       make_float,
       init$2,
       create_matrix,
       create_matrix,
       append$0,
       concat$1,
       sub$1,
       copy$1,
       fill$0,
       blit$1,
       to_list,
       of_list,
       iter$2,
       iteri$2,
       map$2,
       mapi$2,
       fold_left$0,
       fold_right$0,
       iter2$0,
       map2$0,
       for_all$0,
       exists$0,
       mem$0,
       memq$0,
       sort,
       fast_sort$0,
       fast_sort$0,
       Floatarray];
    caml_register_global(654,include$2,"Array");
    var zero=0,one=1,minus_one=-1;
    function succ$0(n){return n + 1 | 0}
    function pred$0(n){return n - 1 | 0}
    function abs$0(n){return caml_greaterequal(n,0)?n:- n | 0}
    var min_int$0=-2147483648,max_int$0=2147483647;
    function lognot(n){return n ^ -1}
    function to_string$0(n){return caml_format_int(cst_d,n)}
    function of_string_opt(s)
     {try
       {var _ut_=[0,caml_int_of_string(s)];return _ut_}
      catch(_uu_)
       {_uu_ = caml_wrap_exception(_uu_);
        if(_uu_[1] === Failure)return 0;
        throw _uu_}}
    var compare$3=caml_int_compare;
    function equal$3(x,y){return 0 === caml_int_compare(x,y)?1:0}
    var
     Int32=
      [0,
       zero,
       one,
       minus_one,
       succ$0,
       pred$0,
       abs$0,
       max_int$0,
       min_int$0,
       lognot,
       of_string_opt,
       to_string$0,
       compare$3,
       equal$3];
    caml_register_global(655,Int32,"Int32");
    function succ$1(n){return caml_int64_add(n,_G_)}
    function pred$1(n){return caml_int64_sub(n,_H_)}
    function abs$1(n)
     {return caml_greaterequal(n,_I_)?n:runtime.caml_int64_neg(n)}
    function lognot$0(n){return runtime.caml_int64_xor(n,_J_)}
    function to_string$1(n){return caml_int64_format(cst_d$0,n)}
    function of_string_opt$0(s)
     {try
       {var _ur_=[0,caml_int64_of_string(s)];return _ur_}
      catch(_us_)
       {_us_ = caml_wrap_exception(_us_);
        if(_us_[1] === Failure)return 0;
        throw _us_}}
    var compare$4=caml_int64_compare;
    function equal$4(x,y){return 0 === caml_int64_compare(x,y)?1:0}
    var
     Int64=
      [0,
       zero$0,
       one$0,
       minus_one$0,
       succ$1,
       pred$1,
       abs$1,
       max_int$1,
       min_int$1,
       lognot$0,
       of_string_opt$0,
       to_string$1,
       compare$4,
       equal$4];
    caml_register_global(656,Int64,"Int64");
    var zero$1=0,one$1=1,minus_one$1=-1;
    function succ$2(n){return n + 1 | 0}
    function pred$2(n){return n - 1 | 0}
    function abs$2(n){return caml_greaterequal(n,0)?n:- n | 0}
    var min_int$2=-2147483648,max_int$2=2147483647;
    function lognot$1(n){return n ^ -1}
    function to_string$2(n){return caml_format_int(cst_d$1,n)}
    function of_string_opt$1(s)
     {try
       {var _up_=[0,caml_int_of_string(s)];return _up_}
      catch(_uq_)
       {_uq_ = caml_wrap_exception(_uq_);
        if(_uq_[1] === Failure)return 0;
        throw _uq_}}
    var compare$5=caml_int_compare;
    function equal$5(x,y){return 0 === caml_int_compare(x,y)?1:0}
    var
     Nativeint=
      [0,
       zero$1,
       one$1,
       minus_one$1,
       succ$2,
       pred$2,
       abs$2,
       size,
       max_int$2,
       min_int$2,
       lognot$1,
       of_string_opt$1,
       to_string$2,
       compare$5,
       equal$5];
    caml_register_global(657,Nativeint,"Nativeint");
    function engine(tbl,state,buf)
     {var result=runtime.caml_lex_engine(tbl,state,buf);
      if(0 <= result)
       {buf[11] = buf[12];
        var _uo_=buf[12];
        buf[12] = [0,_uo_[1],_uo_[2],_uo_[3],buf[4] + buf[6] | 0]}
      return result}
    function new_engine(tbl,state,buf)
     {var result=runtime.caml_new_lex_engine(tbl,state,buf);
      if(0 <= result)
       {buf[11] = buf[12];
        var _un_=buf[12];
        buf[12] = [0,_un_[1],_un_[2],_un_[3],buf[4] + buf[6] | 0]}
      return result}
    function from_function(f)
     {var
       aux_buffer=caml_create_bytes(512),
       _ub_=[0],
       _uc_=0,
       _ud_=0,
       _ue_=0,
       _uf_=0,
       _ug_=0,
       _uh_=0,
       _ui_=0,
       _uj_=caml_create_bytes(1024);
      return [0,
              function(lexbuf)
               {var
                 read=
                  caml_call2(f,aux_buffer,caml_ml_bytes_length(aux_buffer)),
                 n=0 < read?read:(lexbuf[9] = 1,0);
                if(caml_ml_bytes_length(lexbuf[2]) < (lexbuf[3] + n | 0))
                 {if
                   (((lexbuf[3] - lexbuf[5] | 0) + n | 0)
                    <=
                    caml_ml_bytes_length(lexbuf[2]))
                   blit
                    (lexbuf[2],lexbuf[5],lexbuf[2],0,lexbuf[3] - lexbuf[5] | 0);
                  else
                   {var
                     newlen=
                      min
                       (2 * caml_ml_bytes_length(lexbuf[2]) | 0,max_string_length);
                    if(newlen < ((lexbuf[3] - lexbuf[5] | 0) + n | 0))
                     failwith(cst_Lexing_lex_refill_cannot_grow_buffer);
                    var newbuf=caml_create_bytes(newlen);
                    blit(lexbuf[2],lexbuf[5],newbuf,0,lexbuf[3] - lexbuf[5] | 0);
                    lexbuf[2] = newbuf}
                  var s=lexbuf[5];
                  lexbuf[4] = lexbuf[4] + s | 0;
                  lexbuf[6] = lexbuf[6] - s | 0;
                  lexbuf[5] = 0;
                  lexbuf[7] = lexbuf[7] - s | 0;
                  lexbuf[3] = lexbuf[3] - s | 0;
                  var t=lexbuf[10],_ul_=t.length - 1 - 1 | 0,_uk_=0;
                  if(! (_ul_ < 0))
                   {var i=_uk_;
                    for(;;)
                     {var v=caml_check_bound(t,i)[1 + i];
                      if(0 <= v)caml_check_bound(t,i)[1 + i] = v - s | 0;
                      var _um_=i + 1 | 0;
                      if(_ul_ !== i){var i=_um_;continue}
                      break}}}
                blit(aux_buffer,0,lexbuf[2],lexbuf[3],n);
                lexbuf[3] = lexbuf[3] + n | 0;
                return 0},
              _uj_,
              _ui_,
              _uh_,
              _ug_,
              _uf_,
              _ue_,
              _ud_,
              _uc_,
              _ub_,
              zero_pos,
              zero_pos]}
    function from_channel(ic)
     {return from_function(function(buf,n){return input(ic,buf,0,n)})}
    function from_string$0(s)
     {var
       _t4_=[0],
       _t5_=1,
       _t6_=0,
       _t7_=0,
       _t8_=0,
       _t9_=0,
       _t__=0,
       _t$_=caml_ml_string_length(s),
       _ua_=of_string(s);
      return [0,
              function(lexbuf){lexbuf[9] = 1;return 0},
              _ua_,
              _t$_,
              _t__,
              _t9_,
              _t8_,
              _t7_,
              _t6_,
              _t5_,
              _t4_,
              zero_pos,
              zero_pos]}
    function lexeme(lexbuf)
     {var len=lexbuf[6] - lexbuf[5] | 0;
      return sub_string(lexbuf[2],lexbuf[5],len)}
    function sub_lexeme(lexbuf,i1,i2)
     {var len=i2 - i1 | 0;return sub_string(lexbuf[2],i1,len)}
    function sub_lexeme_opt(lexbuf,i1,i2)
     {if(0 <= i1){var len=i2 - i1 | 0;return [0,sub_string(lexbuf[2],i1,len)]}
      return 0}
    function sub_lexeme_char(lexbuf,i){return caml_bytes_get(lexbuf[2],i)}
    function sub_lexeme_char_opt(lexbuf,i)
     {return 0 <= i?[0,caml_bytes_get(lexbuf[2],i)]:0}
    function lexeme_char(lexbuf,i)
     {return caml_bytes_get(lexbuf[2],lexbuf[5] + i | 0)}
    function lexeme_start(lexbuf){return lexbuf[11][4]}
    function lexeme_end(lexbuf){return lexbuf[12][4]}
    function lexeme_start_p(lexbuf){return lexbuf[11]}
    function lexeme_end_p(lexbuf){return lexbuf[12]}
    function new_line(lexbuf)
     {var lcp=lexbuf[12];
      lexbuf[12] = [0,lcp[1],lcp[2] + 1 | 0,lcp[4],lcp[4]];
      return 0}
    function flush_input(lb)
     {lb[6] = 0;
      lb[4] = 0;
      var _t3_=lb[12];
      lb[12] = [0,_t3_[1],_t3_[2],_t3_[3],0];
      lb[3] = 0;
      return 0}
    var
     Lexing=
      [0,
       dummy_pos,
       from_channel,
       from_string$0,
       from_function,
       lexeme,
       lexeme_char,
       lexeme_start,
       lexeme_end,
       lexeme_start_p,
       lexeme_end_p,
       new_line,
       flush_input,
       sub_lexeme,
       sub_lexeme_opt,
       sub_lexeme_char,
       sub_lexeme_char_opt,
       engine,
       new_engine];
    caml_register_global(658,Lexing,"Lexing");
    var
     YYexit=[248,cst_Parsing_YYexit,caml_fresh_oo_id(0)],
     Parse_error=[248,cst_Parsing_Parse_error,caml_fresh_oo_id(0)],
     env=
      [0,
       caml_make_vect(100,0),
       caml_make_vect(100,0),
       caml_make_vect(100,dummy_pos),
       caml_make_vect(100,dummy_pos),
       100,
       0,
       0,
       0,
       dummy_pos,
       dummy_pos,
       0,
       0,
       0,
       0,
       0,
       0];
    function grow_stacks(param)
     {var
       oldsize=env[5],
       newsize=oldsize * 2 | 0,
       new_s=caml_make_vect(newsize,0),
       new_v=caml_make_vect(newsize,0),
       new_start=caml_make_vect(newsize,dummy_pos),
       new_end=caml_make_vect(newsize,dummy_pos);
      blit$1(env[1],0,new_s,0,oldsize);
      env[1] = new_s;
      blit$1(env[2],0,new_v,0,oldsize);
      env[2] = new_v;
      blit$1(env[3],0,new_start,0,oldsize);
      env[3] = new_start;
      blit$1(env[4],0,new_end,0,oldsize);
      env[4] = new_end;
      env[5] = newsize;
      return 0}
    function clear_parser(param)
     {fill$0(env[2],0,env[5],0);env[8] = 0;return 0}
    var current_lookahead_fun=[0,function(param){return 0}];
    function yyparse(tables,start,lexer,lexbuf)
     {var
       init_asp=env[11],
       init_sp=env[14],
       init_stackbase=env[6],
       init_state=env[15],
       init_curr_char=env[7],
       init_lval=env[8],
       init_errflag=env[16];
      env[6] = env[14] + 1 | 0;
      env[7] = start;
      env[10] = lexbuf[12];
      try
       {var cmd=0,arg=0;
        for(;;)
         {var match=runtime.caml_parse_engine(tables,env,cmd,arg);
          switch(match)
           {case 0:
             var arg$0=caml_call1(lexer,lexbuf);
             env[9] = lexbuf[11];
             env[10] = lexbuf[12];
             var cmd=1,arg=arg$0;
             continue;
            case 1:throw Parse_error;
            case 2:grow_stacks(0);var cmd=2,arg=0;continue;
            case 3:grow_stacks(0);var cmd=3,arg=0;continue;
            case 4:
             try
              {var
                _tX_=env[13],
                _tY_=
                 caml_call1(caml_check_bound(tables[1],_tX_)[1 + _tX_],env),
                _tZ_=4,
                cmd$0=_tZ_,
                arg$1=_tY_}
             catch(_t2_)
              {_t2_ = caml_wrap_exception(_t2_);
               if(_t2_ !== Parse_error)throw _t2_;
               var cmd$0=5,arg$1=0,_t0_=_t2_}
             var cmd=cmd$0,arg=arg$1;
             continue;
            default:
             caml_call1(tables[14],cst_syntax_error);var cmd=5,arg=0;continue}}}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        var curr_char=env[7];
        env[11] = init_asp;
        env[14] = init_sp;
        env[6] = init_stackbase;
        env[15] = init_state;
        env[7] = init_curr_char;
        env[8] = init_lval;
        env[16] = init_errflag;
        if(exn[1] === YYexit){var v=exn[2];return v}
        current_lookahead_fun[1]
        =
        function(tok)
         {if(is_block(tok))
           {var _t1_=caml_obj_tag(tok);
            return caml_check_bound(tables[3],_t1_)[1 + _t1_] === curr_char
                    ?1
                    :0}
          return caml_check_bound(tables[2],tok)[1 + tok] === curr_char?1:0};
        throw exn}}
    function peek_val(env,n)
     {var _tW_=env[11] - n | 0;return caml_check_bound(env[2],_tW_)[1 + _tW_]}
    function symbol_start_pos(param)
     {var i=env[12];
      for(;;)
       {if(0 < i)
         {var
           _tT_=(env[11] - i | 0) + 1 | 0,
           st=caml_check_bound(env[3],_tT_)[1 + _tT_],
           _tU_=(env[11] - i | 0) + 1 | 0,
           en=caml_check_bound(env[4],_tU_)[1 + _tU_];
          if(caml_notequal(st,en))return st;
          var i$0=i - 1 | 0,i=i$0;
          continue}
        var _tV_=env[11];
        return caml_check_bound(env[4],_tV_)[1 + _tV_]}}
    function symbol_end_pos(param)
     {var _tS_=env[11];return caml_check_bound(env[4],_tS_)[1 + _tS_]}
    function rhs_start_pos(n)
     {var _tR_=env[11] - (env[12] - n | 0) | 0;
      return caml_check_bound(env[3],_tR_)[1 + _tR_]}
    function rhs_end_pos(n)
     {var _tQ_=env[11] - (env[12] - n | 0) | 0;
      return caml_check_bound(env[4],_tQ_)[1 + _tQ_]}
    function symbol_start(param){return symbol_start_pos(0)[4]}
    function symbol_end(param){return symbol_end_pos(0)[4]}
    function rhs_start(n){return rhs_start_pos(n)[4]}
    function rhs_end(n){return rhs_end_pos(n)[4]}
    function is_current_lookahead(tok)
     {return caml_call1(current_lookahead_fun[1],tok)}
    function parse_error(param){return 0}
    var
     Parsing=
      [0,
       symbol_start,
       symbol_end,
       rhs_start,
       rhs_end,
       symbol_start_pos,
       symbol_end_pos,
       rhs_start_pos,
       rhs_end_pos,
       clear_parser,
       Parse_error,
       function(_tP_){return runtime.caml_set_parser_trace(_tP_)},
       YYexit,
       yyparse,
       peek_val,
       is_current_lookahead,
       parse_error];
    caml_register_global(659,Parsing,"Parsing");
    var
     Set=
      [0,
       function(Ord)
        {function height(param){if(param){var h=param[4];return h}return 0}
         function create(l,v,r)
          {if(l)var h=l[4],hl=h;else var hl=0;
           if(r)var h$0=r[4],hr=h$0;else var hr=0;
           var _tO_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,v,r,_tO_]}
         function bal(l,v,r)
          {if(l)var h=l[4],hl=h;else var hl=0;
           if(r)var h$0=r[4],hr=h$0;else var hr=0;
           if((hr + 2 | 0) < hl)
            {if(l)
              {var lr=l[3],lv=l[2],ll=l[1],_tJ_=height(lr);
               if(_tJ_ <= height(ll))return create(ll,lv,create(lr,v,r));
               if(lr)
                {var lrr=lr[3],lrv=lr[2],lrl=lr[1],_tK_=create(lrr,v,r);
                 return create(create(ll,lv,lrl),lrv,_tK_)}
               return invalid_arg(cst_Set_bal)}
             return invalid_arg(cst_Set_bal$0)}
           if((hl + 2 | 0) < hr)
            {if(r)
              {var rr=r[3],rv=r[2],rl=r[1],_tL_=height(rl);
               if(_tL_ <= height(rr))return create(create(l,v,rl),rv,rr);
               if(rl)
                {var rlr=rl[3],rlv=rl[2],rll=rl[1],_tM_=create(rlr,rv,rr);
                 return create(create(l,v,rll),rlv,_tM_)}
               return invalid_arg(cst_Set_bal$1)}
             return invalid_arg(cst_Set_bal$2)}
           var _tN_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,v,r,_tN_]}
         function add(x,t)
          {if(t)
            {var r=t[3],v=t[2],l=t[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return t;
             if(0 <= c){var rr=add(x,r);return r === rr?t:bal(l,v,rr)}
             var ll=add(x,l);
             return l === ll?t:bal(ll,v,r)}
           return [0,0,x,0,1]}
         function singleton(x){return [0,0,x,0,1]}
         function add_min_element(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1];
             return bal(add_min_element(x,l),v,r)}
           return singleton(x)}
         function add_max_element(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1];
             return bal(l,v,add_max_element(x,r))}
           return singleton(x)}
         function join(l,v,r)
          {if(l)
            {if(r)
              {var
                rh=r[4],
                rr=r[3],
                rv=r[2],
                rl=r[1],
                lh=l[4],
                lr=l[3],
                lv=l[2],
                ll=l[1];
               return (rh + 2 | 0) < lh
                       ?bal(ll,lv,join(lr,v,r))
                       :(lh + 2 | 0) < rh?bal(join(l,v,rl),rv,rr):create(l,v,r)}
             return add_max_element(v,l)}
           return add_min_element(v,r)}
         function min_elt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _tI_=param$0[1];
               if(_tI_){var param$0=_tI_;continue}
               var v=param$0[2];
               return v}
             throw Not_found}}
         function min_elt_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _tH_=param$0[1];
               if(_tH_){var param$0=_tH_;continue}
               var v=param$0[2];
               return [0,v]}
             return 0}}
         function max_elt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _tF_=param$0[3],_tG_=param$0[2];
               if(_tF_){var param$0=_tF_;continue}
               return _tG_}
             throw Not_found}}
         function max_elt_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _tD_=param$0[3],_tE_=param$0[2];
               if(_tD_){var param$0=_tD_;continue}
               return [0,_tE_]}
             return 0}}
         function remove_min_elt(param)
          {if(param)
            {var _tC_=param[1];
             if(_tC_)
              {var r=param[3],v=param[2];return bal(remove_min_elt(_tC_),v,r)}
             var r$0=param[3];
             return r$0}
           return invalid_arg(cst_Set_remove_min_elt)}
         function concat(t,match)
          {if(t)
            {if(match)
              {var _tB_=remove_min_elt(match);
               return join(t,min_elt(match),_tB_)}
             return t}
           return match}
         function split(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return [0,l,1,r];
             if(0 <= c)
              {var match=split(x,r),rr=match[3],pres=match[2],lr=match[1];
               return [0,join(l,v,lr),pres,rr]}
             var
              match$0=split(x,l),
              rl=match$0[3],
              pres$0=match$0[2],
              ll=match$0[1];
             return [0,ll,pres$0,join(rl,v,r)]}
           return _K_}
         var empty=0;
         function is_empty(param){return param?0:1}
         function mem(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v),
                _tA_=0 === c?1:0;
               if(_tA_)return _tA_;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function remove(x,t)
          {if(t)
            {var r=t[3],v=t[2],l=t[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)
              {if(l)
                {if(r)
                  {var _tz_=remove_min_elt(r);return bal(l,min_elt(r),_tz_)}
                 return l}
               return r}
             if(0 <= c){var rr=remove(x,r);return r === rr?t:bal(l,v,rr)}
             var ll=remove(x,l);
             return l === ll?t:bal(ll,v,r)}
           return 0}
         function union(t1,match)
          {if(t1)
            {if(match)
              {var
                h2=match[4],
                r2=match[3],
                v2=match[2],
                l2=match[1],
                h1=t1[4],
                r1=t1[3],
                v1=t1[2],
                l1=t1[1];
               if(h2 <= h1)
                {if(1 === h2)return add(v2,t1);
                 var
                  match$0=split(v1,match),
                  r2$0=match$0[3],
                  l2$0=match$0[1],
                  _tx_=union(r1,r2$0);
                 return join(union(l1,l2$0),v1,_tx_)}
               if(1 === h1)return add(v1,match);
               var
                match$1=split(v2,t1),
                r1$0=match$1[3],
                l1$0=match$1[1],
                _ty_=union(r1$0,r2);
               return join(union(l1$0,l2),v2,_ty_)}
             return t1}
           return match}
         function inter(s1,match)
          {if(s1)
            {if(match)
              {var
                r1=s1[3],
                v1=s1[2],
                l1=s1[1],
                _tt_=split(v1,match),
                _tu_=_tt_[1];
               if(0 === _tt_[2])
                {var r2=_tt_[3],_tv_=inter(r1,r2);
                 return concat(inter(l1,_tu_),_tv_)}
               var r2$0=_tt_[3],_tw_=inter(r1,r2$0);
               return join(inter(l1,_tu_),v1,_tw_)}
             return 0}
           return 0}
         function diff(t1,match)
          {if(t1)
            {if(match)
              {var
                r1=t1[3],
                v1=t1[2],
                l1=t1[1],
                _tp_=split(v1,match),
                _tq_=_tp_[1];
               if(0 === _tp_[2])
                {var r2=_tp_[3],_tr_=diff(r1,r2);
                 return join(diff(l1,_tq_),v1,_tr_)}
               var r2$0=_tp_[3],_ts_=diff(r1,r2$0);
               return concat(diff(l1,_tq_),_ts_)}
             return t1}
           return 0}
         function cons_enum(s,e)
          {var s$0=s,e$0=e;
           for(;;)
            {if(s$0)
              {var
                r=s$0[3],
                v=s$0[2],
                s$1=s$0[1],
                e$1=[0,v,r,e$0],
                s$0=s$1,
                e$0=e$1;
               continue}
             return e$0}}
         function compare(s1,s2)
          {var e2$2=cons_enum(s2,0),e1$2=cons_enum(s1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[3],
                  r2=e2[2],
                  v2=e2[1],
                  e1$0=e1[3],
                  r1=e1[2],
                  v1=e1[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var
                    e2$1=cons_enum(r2,e2$0),
                    e1$1=cons_enum(r1,e1$0),
                    e1=e1$1,
                    e2=e2$1;
                   continue}
                 return c}
               return 1}
             return e2?-1:0}}
         function equal(s1,s2){return 0 === compare(s1,s2)?1:0}
         function subset(s1,s2)
          {var s1$0=s1,s2$0=s2;
           for(;;)
            {if(s1$0)
              {if(s2$0)
                {var
                  r2=s2$0[3],
                  v2=s2$0[2],
                  l2=s2$0[1],
                  r1=s1$0[3],
                  v1=s1$0[2],
                  l1=s1$0[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var _tm_=subset(l1,l2);
                   if(_tm_){var s1$0=r1,s2$0=r2;continue}
                   return _tm_}
                 if(0 <= c)
                  {var _tn_=subset([0,0,v1,r1,0],r2);
                   if(_tn_){var s1$0=l1;continue}
                   return _tn_}
                 var _to_=subset([0,l1,v1,0,0],l2);
                 if(_to_){var s1$0=r1;continue}
                 return _to_}
               return 0}
             return 1}}
         function iter(f,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var r=param$0[3],v=param$0[2],l=param$0[1];
               iter(f,l);
               caml_call1(f,v);
               var param$0=r;
               continue}
             return 0}}
         function fold(f,s,accu)
          {var s$0=s,accu$0=accu;
           for(;;)
            {if(s$0)
              {var
                r=s$0[3],
                v=s$0[2],
                l=s$0[1],
                accu$1=caml_call2(f,v,fold(f,l,accu$0)),
                s$0=r,
                accu$0=accu$1;
               continue}
             return accu$0}}
         function for_all(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _tj_=caml_call1(p,v);
               if(_tj_)
                {var _tk_=for_all(p,l);
                 if(_tk_){var param$0=r;continue}
                 var _tl_=_tk_}
               else
                var _tl_=_tj_;
               return _tl_}
             return 1}}
         function exists(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _tg_=caml_call1(p,v);
               if(_tg_)
                var _th_=_tg_;
               else
                {var _ti_=exists(p,l);
                 if(! _ti_){var param$0=r;continue}
                 var _th_=_ti_}
               return _th_}
             return 0}}
         function filter(p,t)
          {if(t)
            {var
              r=t[3],
              v=t[2],
              l=t[1],
              l$0=filter(p,l),
              pv=caml_call1(p,v),
              r$0=filter(p,r);
             if(pv){if(l === l$0)if(r === r$0)return t;return join(l$0,v,r$0)}
             return concat(l$0,r$0)}
           return 0}
         function partition(p,param)
          {if(param)
            {var
              r=param[3],
              v=param[2],
              l=param[1],
              match=partition(p,l),
              lf=match[2],
              lt=match[1],
              pv=caml_call1(p,v),
              match$0=partition(p,r),
              rf=match$0[2],
              rt=match$0[1];
             if(pv){var _te_=concat(lf,rf);return [0,join(lt,v,rt),_te_]}
             var _tf_=join(lf,v,rf);
             return [0,concat(lt,rt),_tf_]}
           return _L_}
         function cardinal(param)
          {if(param)
            {var r=param[3],l=param[1],_td_=cardinal(r);
             return (cardinal(l) + 1 | 0) + _td_ | 0}
           return 0}
         function elements_aux(accu,param)
          {var accu$0=accu,param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                accu$1=[0,v,elements_aux(accu$0,r)],
                accu$0=accu$1,
                param$0=l;
               continue}
             return accu$0}}
         function elements(s){return elements_aux(0,s)}
         function find(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return v;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             throw Not_found}}
         function find_first(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=l;continue}
                     var param=r;
                     continue}
                   return v0}}
               var param$1=r$0;
               continue}
             throw Not_found}}
         function find_first_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=l;continue}
                     var param=r;
                     continue}
                   return [0,v0]}}
               var param$1=r$0;
               continue}
             return 0}}
         function find_last(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=r;continue}
                     var param=l;
                     continue}
                   return v0}}
               var param$1=l$0;
               continue}
             throw Not_found}}
         function find_last_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=r;continue}
                     var param=l;
                     continue}
                   return [0,v0]}}
               var param$1=l$0;
               continue}
             return 0}}
         function find_opt(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return [0,v];
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function map(f,t)
          {if(t)
            {var
              r=t[3],
              v=t[2],
              l=t[1],
              l$0=map(f,l),
              v$0=caml_call1(f,v),
              r$0=map(f,r);
             if(l === l$0)if(v === v$0)if(r === r$0)return t;
             if(0 === l$0)
              var switch$0=0;
             else
              var
               _tc_=max_elt(l$0),
               switch$0=0 <= caml_call2(Ord[1],_tc_,v$0)?1:0;
             if(! switch$0)
              {if(0 === r$0)
                var switch$1=0;
               else
                var
                 _tb_=min_elt(r$0),
                 switch$1=0 <= caml_call2(Ord[1],v$0,_tb_)?1:0;
               if(! switch$1)return join(l$0,v$0,r$0)}
             return union(l$0,add(v$0,r$0))}
           return 0}
         function of_list(l)
          {if(l)
            {var _s2_=l[2],_s3_=l[1];
             if(_s2_)
              {var _s4_=_s2_[2],_s5_=_s2_[1];
               if(_s4_)
                {var _s6_=_s4_[2],_s7_=_s4_[1];
                 if(_s6_)
                  {var _s8_=_s6_[2],_s9_=_s6_[1];
                   if(_s8_)
                    {if(_s8_[2])
                      {var
                        l$0=sort_uniq(Ord[1],l),
                        sub=
                         function(n,l)
                          {if(! (3 < n >>> 0))
                            switch(n)
                             {case 0:return [0,0,l];
                              case 1:
                               if(l){var l$3=l[2],x0=l[1];return [0,[0,0,x0,0,1],l$3]}
                               break;
                              case 2:
                               if(l)
                                {var _s__=l[2];
                                 if(_s__)
                                  {var l$4=_s__[2],x1=_s__[1],x0$0=l[1];
                                   return [0,[0,[0,0,x0$0,0,1],x1,0,2],l$4]}}
                               break;
                              default:
                               if(l)
                                {var _s$_=l[2];
                                 if(_s$_)
                                  {var _ta_=_s$_[2];
                                   if(_ta_)
                                    {var l$5=_ta_[2],x2=_ta_[1],x1$0=_s$_[1],x0$1=l[1];
                                     return [0,[0,[0,0,x0$1,0,1],x1$0,[0,0,x2,0,1],2],l$5]}}}}
                           var nl=n / 2 | 0,match=sub(nl,l),l$0=match[2],left=match[1];
                           if(l$0)
                            {var
                              l$1=l$0[2],
                              mid=l$0[1],
                              match$0=sub((n - nl | 0) - 1 | 0,l$1),
                              l$2=match$0[2],
                              right=match$0[1];
                             return [0,create(left,mid,right),l$2]}
                           throw [0,Assert_failure,_M_]};
                       return sub(length(l$0),l$0)[1]}
                     var x4=_s8_[1];
                     return add(x4,add(_s9_,add(_s7_,add(_s5_,singleton(_s3_)))))}
                   return add(_s9_,add(_s7_,add(_s5_,singleton(_s3_))))}
                 return add(_s7_,add(_s5_,singleton(_s3_)))}
               return add(_s5_,singleton(_s3_))}
             return singleton(_s3_)}
           return empty}
         return [0,
                 empty,
                 is_empty,
                 mem,
                 add,
                 singleton,
                 remove,
                 union,
                 inter,
                 diff,
                 compare,
                 equal,
                 subset,
                 iter,
                 map,
                 fold,
                 for_all,
                 exists,
                 filter,
                 partition,
                 cardinal,
                 elements,
                 min_elt,
                 min_elt_opt,
                 max_elt,
                 max_elt_opt,
                 min_elt,
                 min_elt_opt,
                 split,
                 find,
                 find_opt,
                 find_first,
                 find_first_opt,
                 find_last,
                 find_last_opt,
                 of_list]}];
    caml_register_global(660,Set,"Set");
    var
     Map=
      [0,
       function(Ord)
        {function height(param){if(param){var h=param[5];return h}return 0}
         function create(l,x,d,r)
          {var hl=height(l),hr=height(r),_s1_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,x,d,r,_s1_]}
         function singleton(x,d){return [0,0,x,d,0,1]}
         function bal(l,x,d,r)
          {if(l)var h=l[5],hl=h;else var hl=0;
           if(r)var h$0=r[5],hr=h$0;else var hr=0;
           if((hr + 2 | 0) < hl)
            {if(l)
              {var lr=l[4],ld=l[3],lv=l[2],ll=l[1],_sW_=height(lr);
               if(_sW_ <= height(ll))return create(ll,lv,ld,create(lr,x,d,r));
               if(lr)
                {var
                  lrr=lr[4],
                  lrd=lr[3],
                  lrv=lr[2],
                  lrl=lr[1],
                  _sX_=create(lrr,x,d,r);
                 return create(create(ll,lv,ld,lrl),lrv,lrd,_sX_)}
               return invalid_arg(cst_Map_bal)}
             return invalid_arg(cst_Map_bal$0)}
           if((hl + 2 | 0) < hr)
            {if(r)
              {var rr=r[4],rd=r[3],rv=r[2],rl=r[1],_sY_=height(rl);
               if(_sY_ <= height(rr))return create(create(l,x,d,rl),rv,rd,rr);
               if(rl)
                {var
                  rlr=rl[4],
                  rld=rl[3],
                  rlv=rl[2],
                  rll=rl[1],
                  _sZ_=create(rlr,rv,rd,rr);
                 return create(create(l,x,d,rll),rlv,rld,_sZ_)}
               return invalid_arg(cst_Map_bal$1)}
             return invalid_arg(cst_Map_bal$2)}
           var _s0_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,x,d,r,_s0_]}
         var empty=0;
         function is_empty(param){return param?0:1}
         function add(x,data,m)
          {if(m)
            {var h=m[5],r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return d === data?m:[0,l,x,data,r,h];
             if(0 <= c){var rr=add(x,data,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=add(x,data,l);
             return l === ll?m:bal(ll,v,d,r)}
           return [0,0,x,data,0,1]}
         function find(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return d;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             throw Not_found}}
         function find_first(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=l;continue}
                     var param=r;
                     continue}
                   return [0,v0,d0]}}
               var param$1=r$0;
               continue}
             throw Not_found}}
         function find_first_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=l;continue}
                     var param=r;
                     continue}
                   return [0,[0,v0,d0]]}}
               var param$1=r$0;
               continue}
             return 0}}
         function find_last(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=r;continue}
                     var param=l;
                     continue}
                   return [0,v0,d0]}}
               var param$1=l$0;
               continue}
             throw Not_found}}
         function find_last_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=r;continue}
                     var param=l;
                     continue}
                   return [0,[0,v0,d0]]}}
               var param$1=l$0;
               continue}
             return 0}}
         function find_opt(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return [0,d];
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function mem(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v),
                _sV_=0 === c?1:0;
               if(_sV_)return _sV_;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function min_binding(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _sU_=param$0[1];
               if(_sU_){var param$0=_sU_;continue}
               var d=param$0[3],v=param$0[2];
               return [0,v,d]}
             throw Not_found}}
         function min_binding_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _sT_=param$0[1];
               if(_sT_){var param$0=_sT_;continue}
               var d=param$0[3],v=param$0[2];
               return [0,[0,v,d]]}
             return 0}}
         function max_binding(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _sQ_=param$0[4],_sR_=param$0[3],_sS_=param$0[2];
               if(_sQ_){var param$0=_sQ_;continue}
               return [0,_sS_,_sR_]}
             throw Not_found}}
         function max_binding_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _sN_=param$0[4],_sO_=param$0[3],_sP_=param$0[2];
               if(_sN_){var param$0=_sN_;continue}
               return [0,[0,_sP_,_sO_]]}
             return 0}}
         function remove_min_binding(param)
          {if(param)
            {var _sM_=param[1];
             if(_sM_)
              {var r=param[4],d=param[3],v=param[2];
               return bal(remove_min_binding(_sM_),v,d,r)}
             var r$0=param[4];
             return r$0}
           return invalid_arg(cst_Map_remove_min_elt)}
         function _sv_(t,match)
          {if(t)
            {if(match)
              {var match$0=min_binding(match),d=match$0[2],x=match$0[1];
               return bal(t,x,d,remove_min_binding(match))}
             return t}
           return match}
         function remove(x,m)
          {if(m)
            {var r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return _sv_(l,r);
             if(0 <= c){var rr=remove(x,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=remove(x,l);
             return l === ll?m:bal(ll,v,d,r)}
           return 0}
         function update(x,f,m)
          {if(m)
            {var h=m[5],r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)
              {var match=caml_call1(f,[0,d]);
               if(match)
                {var data=match[1];return d === data?m:[0,l,x,data,r,h]}
               return _sv_(l,r)}
             if(0 <= c){var rr=update(x,f,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=update(x,f,l);
             return l === ll?m:bal(ll,v,d,r)}
           var match$0=caml_call1(f,0);
           if(match$0){var data$0=match$0[1];return [0,0,x,data$0,0,1]}
           return 0}
         function iter(f,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var r=param$0[4],d=param$0[3],v=param$0[2],l=param$0[1];
               iter(f,l);
               caml_call2(f,v,d);
               var param$0=r;
               continue}
             return 0}}
         function map(f,param)
          {if(param)
            {var
              h=param[5],
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              l$0=map(f,l),
              d$0=caml_call1(f,d),
              r$0=map(f,r);
             return [0,l$0,v,d$0,r$0,h]}
           return 0}
         function mapi(f,param)
          {if(param)
            {var
              h=param[5],
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              l$0=mapi(f,l),
              d$0=caml_call2(f,v,d),
              r$0=mapi(f,r);
             return [0,l$0,v,d$0,r$0,h]}
           return 0}
         function fold(f,m,accu)
          {var m$0=m,accu$0=accu;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                l=m$0[1],
                accu$1=caml_call3(f,v,d,fold(f,l,accu$0)),
                m$0=r,
                accu$0=accu$1;
               continue}
             return accu$0}}
         function for_all(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _sJ_=caml_call2(p,v,d);
               if(_sJ_)
                {var _sK_=for_all(p,l);
                 if(_sK_){var param$0=r;continue}
                 var _sL_=_sK_}
               else
                var _sL_=_sJ_;
               return _sL_}
             return 1}}
         function exists(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _sG_=caml_call2(p,v,d);
               if(_sG_)
                var _sH_=_sG_;
               else
                {var _sI_=exists(p,l);
                 if(! _sI_){var param$0=r;continue}
                 var _sH_=_sI_}
               return _sH_}
             return 0}}
         function add_min_binding(k,x,param)
          {if(param)
            {var r=param[4],d=param[3],v=param[2],l=param[1];
             return bal(add_min_binding(k,x,l),v,d,r)}
           return singleton(k,x)}
         function add_max_binding(k,x,param)
          {if(param)
            {var r=param[4],d=param[3],v=param[2],l=param[1];
             return bal(l,v,d,add_max_binding(k,x,r))}
           return singleton(k,x)}
         function join(l,v,d,r)
          {if(l)
            {if(r)
              {var
                rh=r[5],
                rr=r[4],
                rd=r[3],
                rv=r[2],
                rl=r[1],
                lh=l[5],
                lr=l[4],
                ld=l[3],
                lv=l[2],
                ll=l[1];
               return (rh + 2 | 0) < lh
                       ?bal(ll,lv,ld,join(lr,v,d,r))
                       :(lh + 2 | 0) < rh
                         ?bal(join(l,v,d,rl),rv,rd,rr)
                         :create(l,v,d,r)}
             return add_max_binding(v,d,l)}
           return add_min_binding(v,d,r)}
         function concat(t,match)
          {if(t)
            {if(match)
              {var match$0=min_binding(match),d=match$0[2],x=match$0[1];
               return join(t,x,d,remove_min_binding(match))}
             return t}
           return match}
         function concat_or_join(t1,v,d,t2)
          {if(d){var d$0=d[1];return join(t1,v,d$0,t2)}return concat(t1,t2)}
         function split(x,param)
          {if(param)
            {var
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              c=caml_call2(Ord[1],x,v);
             if(0 === c)return [0,l,[0,d],r];
             if(0 <= c)
              {var match=split(x,r),rr=match[3],pres=match[2],lr=match[1];
               return [0,join(l,v,d,lr),pres,rr]}
             var
              match$0=split(x,l),
              rl=match$0[3],
              pres$0=match$0[2],
              ll=match$0[1];
             return [0,ll,pres$0,join(rl,v,d,r)]}
           return _N_}
         function merge(f,s1,s2)
          {if(s1)
            {var h1=s1[5],r1=s1[4],d1=s1[3],v1=s1[2],l1=s1[1];
             if(height(s2) <= h1)
              {var
                match=split(v1,s2),
                r2=match[3],
                d2=match[2],
                l2=match[1],
                _sC_=merge(f,r1,r2),
                _sD_=caml_call3(f,v1,[0,d1],d2);
               return concat_or_join(merge(f,l1,l2),v1,_sD_,_sC_)}}
           else
            if(! s2)return 0;
           if(s2)
            {var
              r2$0=s2[4],
              d2$0=s2[3],
              v2=s2[2],
              l2$0=s2[1],
              match$0=split(v2,s1),
              r1$0=match$0[3],
              d1$0=match$0[2],
              l1$0=match$0[1],
              _sE_=merge(f,r1$0,r2$0),
              _sF_=caml_call3(f,v2,d1$0,[0,d2$0]);
             return concat_or_join(merge(f,l1$0,l2$0),v2,_sF_,_sE_)}
           throw [0,Assert_failure,_O_]}
         function union(f,s1,s2)
          {if(s1)
            {if(s2)
              {var
                h2=s2[5],
                r2=s2[4],
                d2=s2[3],
                v2=s2[2],
                l2=s2[1],
                h1=s1[5],
                r1=s1[4],
                d1=s1[3],
                v1=s1[2],
                l1=s1[1];
               if(h2 <= h1)
                {var
                  match=split(v1,s2),
                  r2$0=match[3],
                  d2$0=match[2],
                  l2$0=match[1],
                  l=union(f,l1,l2$0),
                  r=union(f,r1,r2$0);
                 if(d2$0)
                  {var d2$1=d2$0[1];
                   return concat_or_join(l,v1,caml_call3(f,v1,d1,d2$1),r)}
                 return join(l,v1,d1,r)}
               var
                match$0=split(v2,s1),
                r1$0=match$0[3],
                d1$0=match$0[2],
                l1$0=match$0[1],
                l$0=union(f,l1$0,l2),
                r$0=union(f,r1$0,r2);
               if(d1$0)
                {var d1$1=d1$0[1];
                 return concat_or_join(l$0,v2,caml_call3(f,v2,d1$1,d2),r$0)}
               return join(l$0,v2,d2,r$0)}
             var s=s1}
           else
            var s=s2;
           return s}
         function filter(p,m)
          {if(m)
            {var
              r=m[4],
              d=m[3],
              v=m[2],
              l=m[1],
              l$0=filter(p,l),
              pvd=caml_call2(p,v,d),
              r$0=filter(p,r);
             if(pvd)
              {if(l === l$0)if(r === r$0)return m;return join(l$0,v,d,r$0)}
             return concat(l$0,r$0)}
           return 0}
         function partition(p,param)
          {if(param)
            {var
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              match=partition(p,l),
              lf=match[2],
              lt=match[1],
              pvd=caml_call2(p,v,d),
              match$0=partition(p,r),
              rf=match$0[2],
              rt=match$0[1];
             if(pvd){var _sA_=concat(lf,rf);return [0,join(lt,v,d,rt),_sA_]}
             var _sB_=join(lf,v,d,rf);
             return [0,concat(lt,rt),_sB_]}
           return _P_}
         function cons_enum(m,e)
          {var m$0=m,e$0=e;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                m$1=m$0[1],
                e$1=[0,v,d,r,e$0],
                m$0=m$1,
                e$0=e$1;
               continue}
             return e$0}}
         function compare(cmp,m1,m2)
          {var e2$2=cons_enum(m2,0),e1$2=cons_enum(m1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[4],
                  r2=e2[3],
                  d2=e2[2],
                  v2=e2[1],
                  e1$0=e1[4],
                  r1=e1[3],
                  d1=e1[2],
                  v1=e1[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var c$0=caml_call2(cmp,d1,d2);
                   if(0 === c$0)
                    {var
                      e2$1=cons_enum(r2,e2$0),
                      e1$1=cons_enum(r1,e1$0),
                      e1=e1$1,
                      e2=e2$1;
                     continue}
                   return c$0}
                 return c}
               return 1}
             return e2?-1:0}}
         function equal(cmp,m1,m2)
          {var e2$2=cons_enum(m2,0),e1$2=cons_enum(m1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[4],
                  r2=e2[3],
                  d2=e2[2],
                  v2=e2[1],
                  e1$0=e1[4],
                  r1=e1[3],
                  d1=e1[2],
                  v1=e1[1],
                  _sx_=0 === caml_call2(Ord[1],v1,v2)?1:0;
                 if(_sx_)
                  {var _sy_=caml_call2(cmp,d1,d2);
                   if(_sy_)
                    {var
                      e2$1=cons_enum(r2,e2$0),
                      e1$1=cons_enum(r1,e1$0),
                      e1=e1$1,
                      e2=e2$1;
                     continue}
                   var _sz_=_sy_}
                 else
                  var _sz_=_sx_;
                 return _sz_}
               return 0}
             return e2?0:1}}
         function cardinal(param)
          {if(param)
            {var r=param[4],l=param[1],_sw_=cardinal(r);
             return (cardinal(l) + 1 | 0) + _sw_ | 0}
           return 0}
         function bindings_aux(accu,param)
          {var accu$0=accu,param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                accu$1=[0,[0,v,d],bindings_aux(accu$0,r)],
                accu$0=accu$1,
                param$0=l;
               continue}
             return accu$0}}
         function bindings(s){return bindings_aux(0,s)}
         return [0,
                 empty,
                 is_empty,
                 mem,
                 add,
                 update,
                 singleton,
                 remove,
                 merge,
                 union,
                 compare,
                 equal,
                 iter,
                 fold,
                 for_all,
                 exists,
                 filter,
                 partition,
                 cardinal,
                 bindings,
                 min_binding,
                 min_binding_opt,
                 max_binding,
                 max_binding_opt,
                 min_binding,
                 min_binding_opt,
                 split,
                 find,
                 find_opt,
                 find_first,
                 find_first_opt,
                 find_last,
                 find_last_opt,
                 map,
                 mapi]}];
    caml_register_global(661,Map,"Map");
    var Empty=[248,cst_Stack_Empty,caml_fresh_oo_id(0)];
    function create(param){return [0,0,0]}
    function clear(s){s[1] = 0;s[2] = 0;return 0}
    function copy$2(s){return [0,s[1],s[2]]}
    function push(x,s){s[1] = [0,x,s[1]];s[2] = s[2] + 1 | 0;return 0}
    function pop(s)
     {var _su_=s[1];
      if(_su_)
       {var tl=_su_[2],hd=_su_[1];s[1] = tl;s[2] = s[2] - 1 | 0;return hd}
      throw Empty}
    function top(s)
     {var _st_=s[1];if(_st_){var hd=_st_[1];return hd}throw Empty}
    function is_empty(s){return 0 === s[1]?1:0}
    function length$1(s){return s[2]}
    function iter$3(f,s){return iter(f,s[1])}
    function fold(f,acc,s){return fold_left(f,acc,s[1])}
    var
     Stack=
      [0,Empty,create,push,pop,top,clear,copy$2,is_empty,length$1,iter$3,fold];
    caml_register_global(662,Stack,"Stack");
    var Empty$0=[248,cst_Queue_Empty,caml_fresh_oo_id(0)];
    function create$0(param){return [0,0,0,0]}
    function clear$0(q){q[1] = 0;q[2] = 0;q[3] = 0;return 0}
    function add(x,q)
     {var cell=[0,x,0],_ss_=q[3];
      return _ss_
              ?(q[1] = q[1] + 1 | 0,_ss_[2] = cell,q[3] = cell,0)
              :(q[1] = 1,q[2] = cell,q[3] = cell,0)}
    function peek(q)
     {var _sr_=q[2];if(_sr_){var content=_sr_[1];return content}throw Empty$0}
    function take(q)
     {var _so_=q[2];
      if(_so_)
       {var _sp_=_so_[1],_sq_=_so_[2];
        return _sq_?(q[1] = q[1] - 1 | 0,q[2] = _sq_,_sp_):(clear$0(q),_sp_)}
      throw Empty$0}
    function copy$3(q)
     {var q_res=[0,q[1],0,0],prev=0,cell=q[2];
      for(;;)
       {if(cell)
         {var content=cell[1],next=cell[2],res=[0,content,0];
          if(prev)prev[2] = res;else q_res[2] = res;
          var prev=res,cell=next;
          continue}
        q_res[3] = prev;
        return q_res}}
    function is_empty$0(q){return 0 === q[1]?1:0}
    function length$2(q){return q[1]}
    function iter$4(f,q)
     {var cell=q[2];
      for(;;)
       {if(cell)
         {var content=cell[1],next=cell[2];
          caml_call1(f,content);
          var cell=next;
          continue}
        return 0}}
    function fold$0(f,accu$1,q)
     {var accu=accu$1,cell=q[2];
      for(;;)
       {if(cell)
         {var
           content=cell[1],
           next=cell[2],
           accu$0=caml_call2(f,accu,content),
           accu=accu$0,
           cell=next;
          continue}
        return accu}}
    function transfer(q1,q2)
     {var _sm_=0 < q1[1]?1:0;
      if(_sm_)
       {var _sn_=q2[3];
        return _sn_
                ?(q2[1]
                  =
                  q2[1]
                  +
                  q1[1]
                  |
                  0,
                  _sn_[2]
                  =
                  q1[2],
                  q2[3]
                  =
                  q1[3],
                  clear$0(q1))
                :(q2[1] = q1[1],q2[2] = q1[2],q2[3] = q1[3],clear$0(q1))}
      return _sm_}
    var
     Queue=
      [0,
       Empty$0,
       create$0,
       add,
       add,
       take,
       take,
       peek,
       peek,
       clear$0,
       copy$3,
       is_empty$0,
       length$2,
       iter$4,
       fold$0,
       transfer];
    caml_register_global(663,Queue,"Queue");
    var Undefined=[248,cst_CamlinternalLazy_Undefined,caml_fresh_oo_id(0)];
    function raise_undefined(param){throw Undefined}
    function force_lazy_block(blk)
     {var closure=blk[1];
      blk[1] = raise_undefined;
      try
       {var result=caml_call1(closure,0);
        blk[1] = result;
        caml_obj_set_tag(blk,250);
        return result}
      catch(e)
       {e = caml_wrap_exception(e);blk[1] = function(param){throw e};throw e}}
    function force_val_lazy_block(blk)
     {var closure=blk[1];
      blk[1] = raise_undefined;
      var result=caml_call1(closure,0);
      blk[1] = result;
      caml_obj_set_tag(blk,250);
      return result}
    function force(lzv)
     {var t=caml_obj_tag(lzv);
      return t === 250?lzv[1]:t !== 246?lzv:force_lazy_block(lzv)}
    function force_val(lzv)
     {var t=caml_obj_tag(lzv);
      return t === 250?lzv[1]:t !== 246?lzv:force_val_lazy_block(lzv)}
    var
     CamlinternalLazy=
      [0,Undefined,force_lazy_block,force_val_lazy_block,force,force_val];
    caml_register_global(664,CamlinternalLazy,"CamlinternalLazy");
    function from_fun(f){var x=caml_obj_block(246,1);x[1] = f;return x}
    function from_val(v)
     {var t=caml_obj_tag(v);
      if(t !== 250)if(t !== 246)if(t !== 253)return v;
      return runtime.caml_lazy_make_forward(v)}
    function is_val(l){return caml_obj_tag(l) !== 246?1:0}
    var
     Lazy=
      [0,
       Undefined,
       force_val,
       from_fun,
       from_val,
       is_val,
       from_fun,
       from_val,
       is_val];
    caml_register_global(665,Lazy,"Lazy");
    var
     Failure$0=[248,cst_Stream_Failure,caml_fresh_oo_id(0)],
     Error=[248,cst_Stream_Error,caml_fresh_oo_id(0)];
    function count(param)
     {if(param){var match=param[1],count=match[1];return count}return 0}
    function data(param)
     {if(param){var match=param[1],data=match[2];return data}return 0}
    function fill_buff(b)
     {b[3] = input(b[1],b[2],0,caml_ml_bytes_length(b[2]));b[4] = 0;return 0}
    function get_data(count,d)
     {var d$0=d;
      for(;;)
       {if(typeof d$0 !== "number")
         switch(d$0[0])
          {case 1:
            var d2=d$0[2],d1=d$0[1],match=get_data(count,d1);
            if(typeof match === "number")
             {var d$0=d2;continue}
            else
             {if(0 === match[0])
               {var d11=match[2],a=match[1];return [0,a,[1,d11,d2]]}
              throw [0,Assert_failure,_Q_]}
           case 2:
            var
             f=d$0[1],
             _si_=caml_obj_tag(f),
             d$1=250 === _si_?f[1]:246 === _si_?force_lazy_block(f):f,
             d$0=d$1;
            continue;
           case 3:
            var _sj_=d$0[1],_sk_=_sj_[1];
            if(_sk_)
             {var _sl_=_sk_[1];
              if(_sl_){var a$0=_sl_[1];_sj_[1] = 0;return [0,a$0,d$0]}
              return 0}
            var match$0=caml_call1(_sj_[2],count);
            if(match$0){var a$1=match$0[1];return [0,a$1,d$0]}
            _sj_[1] = _R_;
            return 0;
           case 4:
            var b=d$0[1];
            if(b[3] <= b[4])fill_buff(b);
            if(0 === b[3])return 0;
            var r=caml_bytes_unsafe_get(b[2],b[4]);
            b[4] = b[4] + 1 | 0;
            return [0,r,d$0]
           }
        return d$0}}
    function peek_data(s)
     {for(;;)
       {var _sd_=s[2];
        if(typeof _sd_ === "number")
         return 0;
        else
         switch(_sd_[0])
          {case 0:var a=_sd_[1];return [0,a];
           case 1:
            var d=get_data(s[1],s[2]);
            if(typeof d === "number")
             return 0;
            else
             {if(0 === d[0]){var a$0=d[1];s[2] = d;return [0,a$0]}
              throw [0,Assert_failure,_S_]}
           case 2:
            var
             f=_sd_[1],
             _se_=caml_obj_tag(f),
             _sf_=250 === _se_?f[1]:246 === _se_?force_lazy_block(f):f;
            s[2] = _sf_;
            continue;
           case 3:
            var _sg_=_sd_[1],_sh_=_sg_[1];
            if(_sh_){var a$1=_sh_[1];return a$1}
            var x=caml_call1(_sg_[2],s[1]);
            _sg_[1] = [0,x];
            return x;
           default:
            var b=_sd_[1];
            if(b[3] <= b[4])fill_buff(b);
            return 0 === b[3]
                    ?(s[2] = 0,0)
                    :[0,caml_bytes_unsafe_get(b[2],b[4])]}}}
    function peek$0(param)
     {if(param){var s=param[1];return peek_data(s)}return 0}
    function junk_data(s)
     {for(;;)
       {var _sb_=s[2];
        if(typeof _sb_ !== "number")
         switch(_sb_[0])
          {case 0:var d=_sb_[2];s[1] = s[1] + 1 | 0;s[2] = d;return 0;
           case 3:
            var _sc_=_sb_[1];
            if(_sc_[1]){s[1] = s[1] + 1 | 0;_sc_[1] = 0;return 0}
            break;
           case 4:
            var b=_sb_[1];s[1] = s[1] + 1 | 0;b[4] = b[4] + 1 | 0;return 0
           }
        var match=peek_data(s);
        if(match)continue;
        return 0}}
    function junk(param)
     {if(param){var data=param[1];return junk_data(data)}return 0}
    function nget_data(n,s)
     {if(0 < n)
       {var match=peek_data(s);
        if(match)
         {var a=match[1];
          junk_data(s);
          var
           match$0=nget_data(n - 1 | 0,s),
           k=match$0[3],
           d=match$0[2],
           al=match$0[1];
          return [0,[0,a,al],[0,a,d],k + 1 | 0]}
        return [0,0,s[2],0]}
      return [0,0,s[2],0]}
    function npeek(n,param)
     {if(param)
       {var
         d$0=param[1],
         match=nget_data(n,d$0),
         len=match[3],
         d=match[2],
         al=match[1];
        d$0[1] = d$0[1] - len | 0;
        d$0[2] = d;
        return al}
      return 0}
    function next(s)
     {var match=peek$0(s);
      if(match){var a=match[1];junk(s);return a}
      throw Failure$0}
    function empty$0(s){var match=peek$0(s);if(match)throw Failure$0;return 0}
    function iter$5(f,strm)
     {for(;;)
       {var match=peek$0(strm);
        if(match){var a=match[1];junk(strm);caml_call1(f,a);continue}
        return 0}}
    function from(f){return [0,[0,0,[3,[0,0,f]]]]}
    function of_list$0(l)
     {var _sa_=0;
      return [0,[0,0,fold_right(function(x,l){return [0,x,l]},l,_sa_)]]}
    function of_string$0(s)
     {var count=[0,0];
      return from
              (function(param)
                {var c=count[1];
                 return c < caml_ml_string_length(s)
                         ?(count[1]++,[0,caml_string_get(s,c)])
                         :0})}
    function of_bytes(s)
     {var count=[0,0];
      return from
              (function(param)
                {var c=count[1];
                 return c < caml_ml_bytes_length(s)
                         ?(count[1]++,[0,caml_bytes_get(s,c)])
                         :0})}
    function of_channel(ic)
     {return [0,[0,0,[4,[0,ic,caml_create_bytes(4096),0,0]]]]}
    function iapp(i,s){var _r$_=data(s);return [0,[0,0,[1,data(i),_r$_]]]}
    function icons(i,s){return [0,[0,0,[0,i,data(s)]]]}
    function ising(i){return [0,[0,0,[0,i,0]]]}
    function lapp(f,s)
     {return [0,
              [0,
               0,
               [2,
                [246,
                 function(_r9_)
                  {var _r__=data(s);return [1,data(caml_call1(f,0)),_r__]}]]]]}
    function lcons(f,s)
     {return [0,
              [0,
               0,
               [2,
                [246,
                 function(_r7_)
                  {var _r8_=data(s);return [0,caml_call1(f,0),_r8_]}]]]]}
    function lsing(f)
     {return [0,[0,0,[2,[246,function(_r6_){return [0,caml_call1(f,0),0]}]]]]}
    var sempty=0;
    function slazy(f)
     {return [0,[0,0,[2,[246,function(_r5_){return data(caml_call1(f,0))}]]]]}
    function dump(f,s)
     {print_string(cst_count);
      print_int(count(s));
      print_string(cst_data);
      dump_data(f,data(s));
      print_string(cst$5);
      return print_newline(0)}
    function dump_data(f,param)
     {if(typeof param === "number")
       return print_string(cst_Sempty);
      else
       switch(param[0])
        {case 0:
          var d=param[2],a=param[1];
          print_string(cst_Scons);
          caml_call1(f,a);
          print_string(cst$6);
          dump_data(f,d);
          return print_string(cst$7);
         case 1:
          var d2=param[2],d1=param[1];
          print_string(cst_Sapp);
          dump_data(f,d1);
          print_string(cst$8);
          dump_data(f,d2);
          return print_string(cst$9);
         case 2:return print_string(cst_Slazy);
         case 3:return print_string(cst_Sgen);
         default:return print_string(cst_Sbuffio)}}
    var
     Stream=
      [0,
       Failure$0,
       Error,
       from,
       of_list$0,
       of_string$0,
       of_bytes,
       of_channel,
       iter$5,
       next,
       empty$0,
       peek$0,
       junk,
       count,
       npeek,
       iapp,
       icons,
       ising,
       lapp,
       lcons,
       lsing,
       sempty,
       slazy,
       dump];
    caml_register_global(666,Stream,"Stream");
    function create$1(n)
     {var
       n$0=1 <= n?n:1,
       n$1=max_string_length < n$0?max_string_length:n$0,
       s=caml_create_bytes(n$1);
      return [0,s,0,n$1,s]}
    function contents(b){return sub_string(b[1],0,b[2])}
    function to_bytes(b){return sub(b[1],0,b[2])}
    function sub$2(b,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((b[2] - len | 0) < ofs))return sub_string(b[1],ofs,len);
      return invalid_arg(cst_Buffer_sub)}
    function blit$2(src,srcoff,dst,dstoff,len)
     {if(0 <= len)
       if(0 <= srcoff)
        if(! ((src[2] - len | 0) < srcoff))
         if(0 <= dstoff)
          if(! ((caml_ml_bytes_length(dst) - len | 0) < dstoff))
           return caml_blit_bytes(src[1],srcoff,dst,dstoff,len);
      return invalid_arg(cst_Buffer_blit)}
    function nth$0(b,ofs)
     {if(0 <= ofs)if(! (b[2] <= ofs))return caml_bytes_unsafe_get(b[1],ofs);
      return invalid_arg(cst_Buffer_nth)}
    function length$3(b){return b[2]}
    function clear$1(b){b[2] = 0;return 0}
    function reset(b)
     {b[2] = 0;b[1] = b[4];b[3] = caml_ml_bytes_length(b[1]);return 0}
    function resize(b,more)
     {var len=b[3],new_len=[0,len];
      for(;;)
       {if(new_len[1] < (b[2] + more | 0))
         {new_len[1] = 2 * new_len[1] | 0;continue}
        if(max_string_length < new_len[1])
         if((b[2] + more | 0) <= max_string_length)
          new_len[1] = max_string_length;
         else
          failwith(cst_Buffer_add_cannot_grow_buffer);
        var new_buffer=caml_create_bytes(new_len[1]);
        blit(b[1],0,new_buffer,0,b[2]);
        b[1] = new_buffer;
        b[3] = new_len[1];
        return 0}}
    function add_char(b,c)
     {var pos=b[2];
      if(b[3] <= pos)resize(b,1);
      caml_bytes_unsafe_set(b[1],pos,c);
      b[2] = pos + 1 | 0;
      return 0}
    function add_utf_8_uchar(b,u)
     {if(0 <= u)
       {if(127 < u)
         {if(2047 < u)
           {if(65535 < u)
             {if(1114111 < u)throw [0,Assert_failure,_T_];
              var pos=b[2];
              if(b[3] < (pos + 4 | 0))resize(b,4);
              caml_bytes_unsafe_set(b[1],pos,240 | u >>> 18 | 0);
              caml_bytes_unsafe_set
               (b[1],pos + 1 | 0,128 | (u >>> 12 | 0) & 63);
              caml_bytes_unsafe_set(b[1],pos + 2 | 0,128 | (u >>> 6 | 0) & 63);
              caml_bytes_unsafe_set(b[1],pos + 3 | 0,128 | u & 63);
              b[2] = pos + 4 | 0;
              return 0}
            var pos$0=b[2];
            if(b[3] < (pos$0 + 3 | 0))resize(b,3);
            caml_bytes_unsafe_set(b[1],pos$0,224 | u >>> 12 | 0);
            caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,128 | (u >>> 6 | 0) & 63);
            caml_bytes_unsafe_set(b[1],pos$0 + 2 | 0,128 | u & 63);
            b[2] = pos$0 + 3 | 0;
            return 0}
          var pos$1=b[2];
          if(b[3] < (pos$1 + 2 | 0))resize(b,2);
          caml_bytes_unsafe_set(b[1],pos$1,192 | u >>> 6 | 0);
          caml_bytes_unsafe_set(b[1],pos$1 + 1 | 0,128 | u & 63);
          b[2] = pos$1 + 2 | 0;
          return 0}
        return add_char(b,u)}
      throw [0,Assert_failure,_U_]}
    function add_utf_16be_uchar(b,u)
     {if(0 <= u)
       {if(65535 < u)
         {if(1114111 < u)throw [0,Assert_failure,_V_];
          var
           u$0=u - 65536 | 0,
           hi=55296 | u$0 >>> 10 | 0,
           lo=56320 | u$0 & 1023,
           pos=b[2];
          if(b[3] < (pos + 4 | 0))resize(b,4);
          caml_bytes_unsafe_set(b[1],pos,hi >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 1 | 0,hi & 255);
          caml_bytes_unsafe_set(b[1],pos + 2 | 0,lo >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 3 | 0,lo & 255);
          b[2] = pos + 4 | 0;
          return 0}
        var pos$0=b[2];
        if(b[3] < (pos$0 + 2 | 0))resize(b,2);
        caml_bytes_unsafe_set(b[1],pos$0,u >>> 8 | 0);
        caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,u & 255);
        b[2] = pos$0 + 2 | 0;
        return 0}
      throw [0,Assert_failure,_W_]}
    function add_utf_16le_uchar(b,u)
     {if(0 <= u)
       {if(65535 < u)
         {if(1114111 < u)throw [0,Assert_failure,_X_];
          var
           u$0=u - 65536 | 0,
           hi=55296 | u$0 >>> 10 | 0,
           lo=56320 | u$0 & 1023,
           pos=b[2];
          if(b[3] < (pos + 4 | 0))resize(b,4);
          caml_bytes_unsafe_set(b[1],pos,hi & 255);
          caml_bytes_unsafe_set(b[1],pos + 1 | 0,hi >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 2 | 0,lo & 255);
          caml_bytes_unsafe_set(b[1],pos + 3 | 0,lo >>> 8 | 0);
          b[2] = pos + 4 | 0;
          return 0}
        var pos$0=b[2];
        if(b[3] < (pos$0 + 2 | 0))resize(b,2);
        caml_bytes_unsafe_set(b[1],pos$0,u & 255);
        caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,u >>> 8 | 0);
        b[2] = pos$0 + 2 | 0;
        return 0}
      throw [0,Assert_failure,_Y_]}
    function add_substring(b,s,offset,len)
     {var _r2_=offset < 0?1:0;
      if(_r2_)
       var _r3_=_r2_;
      else
       var
        _r4_=len < 0?1:0,
        _r3_=_r4_ || ((caml_ml_string_length(s) - len | 0) < offset?1:0);
      if(_r3_)invalid_arg(cst_Buffer_add_substring_add_subbytes);
      var new_position=b[2] + len | 0;
      if(b[3] < new_position)resize(b,len);
      blit$0(s,offset,b[1],b[2],len);
      b[2] = new_position;
      return 0}
    function add_subbytes(b,s,offset,len)
     {return add_substring(b,s,offset,len)}
    function add_string(b,s)
     {var len=caml_ml_string_length(s),new_position=b[2] + len | 0;
      if(b[3] < new_position)resize(b,len);
      blit$0(s,0,b[1],b[2],len);
      b[2] = new_position;
      return 0}
    function add_bytes(b,s){return add_string(b,s)}
    function add_buffer(b,bs){return add_subbytes(b,bs[1],0,bs[2])}
    function add_channel(b,ic,len$1)
     {var _r0_=len$1 < 0?1:0,_r1_=_r0_ || (max_string_length < len$1?1:0);
      if(_r1_)invalid_arg(cst_Buffer_add_channel);
      if(b[3] < (b[2] + len$1 | 0))resize(b,len$1);
      var len=len$1;
      for(;;)
       {var _rZ_=0 < len?1:0;
        if(_rZ_)
         {var n=input(ic,b[1],b[2],len);
          b[2] = b[2] + n | 0;
          if(0 === n)throw End_of_file;
          var len$0=len - n | 0,len=len$0;
          continue}
        return _rZ_}}
    function output_buffer(oc,b){return output(oc,b[1],0,b[2])}
    function add_substitute(b,f,s)
     {var lim$1=caml_ml_string_length(s),previous=32,i$7=0;
      for(;;)
       {if(i$7 < lim$1)
         {var current=caml_string_get(s,i$7);
          if(36 === current)
           {if(92 === previous)
             {add_char(b,current);
              var i$8=i$7 + 1 | 0,previous=32,i$7=i$8;
              continue}
            var start=i$7 + 1 | 0;
            if(lim$1 <= start)throw Not_found;
            var opening=caml_string_get(s,start);
            if(40 === opening)
             var switch$0=0;
            else
             if(123 === opening)
              var switch$0=0;
             else
              {var i$6=start + 1 | 0,lim$0=caml_ml_string_length(s),i$3=i$6;
               for(;;)
                {if(lim$0 <= i$3)
                  var stop=lim$0;
                 else
                  {var
                    match=caml_string_get(s,i$3),
                    switch$1=
                     91 <= match
                      ?97 <= match?123 <= match?0:1:95 === match?1:0
                      :58 <= match?65 <= match?1:0:48 <= match?1:0;
                   if(switch$1){var i$4=i$3 + 1 | 0,i$3=i$4;continue}
                   var stop=i$3}
                 var
                  match$0=[0,sub$0(s,start,stop - start | 0),stop],
                  switch$0=1;
                 break}}
            if(! switch$0)
             {var i$5=start + 1 | 0,k$2=0;
              if(40 === opening)
               var _rX_=41;
              else
               {if(123 !== opening)throw [0,Assert_failure,_Z_];var _rX_=125}
              var lim=caml_ml_string_length(s),k=k$2,i=i$5;
              for(;;)
               {if(lim <= i)throw Not_found;
                if(caml_string_get(s,i) === opening)
                 {var i$0=i + 1 | 0,k$0=k + 1 | 0,k=k$0,i=i$0;continue}
                if(caml_string_get(s,i) !== _rX_)
                 {var i$2=i + 1 | 0,i=i$2;continue}
                if(0 !== k)
                 {var i$1=i + 1 | 0,k$1=k - 1 | 0,k=k$1,i=i$1;continue}
                var
                 match$0=
                  [0,sub$0(s,i$5,(i - start | 0) - 1 | 0),i + 1 | 0];
                break}}
            var next_i=match$0[2],ident=match$0[1];
            add_string(b,caml_call1(f,ident));
            var previous=32,i$7=next_i;
            continue}
          if(92 === previous)
           {add_char(b,92);
            add_char(b,current);
            var i$9=i$7 + 1 | 0,previous=32,i$7=i$9;
            continue}
          if(92 === current)
           {var i$10=i$7 + 1 | 0,previous=current,i$7=i$10;continue}
          add_char(b,current);
          var i$11=i$7 + 1 | 0,previous=current,i$7=i$11;
          continue}
        var _rY_=92 === previous?1:0;
        return _rY_?add_char(b,previous):_rY_}}
    function truncate(b,len)
     {if(0 <= len)if(! (b[2] < len)){b[2] = len;return 0}
      return invalid_arg(cst_Buffer_truncate)}
    var
     Buffer=
      [0,
       create$1,
       contents,
       to_bytes,
       sub$2,
       blit$2,
       nth$0,
       length$3,
       clear$1,
       reset,
       add_char,
       add_utf_8_uchar,
       add_utf_16le_uchar,
       add_utf_16be_uchar,
       add_string,
       add_bytes,
       add_substring,
       add_subbytes,
       add_substitute,
       add_buffer,
       add_channel,
       output_buffer,
       truncate];
    caml_register_global(667,Buffer,"Buffer");
    function create_char_set(param){return make(32,0)}
    function add_in_char_set(char_set,c)
     {var str_ind=c >>> 3 | 0,mask=1 << (c & 7);
      return caml_bytes_set
              (char_set,
               str_ind,
               char_of_int(caml_bytes_get(char_set,str_ind) | mask))}
    function freeze_char_set(char_set){return to_string(char_set)}
    function rev_char_set(char_set)
     {var char_set$0=create_char_set(0),i=0;
      for(;;)
       {caml_bytes_set
         (char_set$0,i,char_of_int(caml_string_get(char_set,i) ^ 255));
        var _rW_=i + 1 | 0;
        if(31 !== i){var i=_rW_;continue}
        return char_set$0}}
    function is_in_char_set(char_set,c)
     {var str_ind=c >>> 3 | 0,mask=1 << (c & 7);
      return 0 !== (caml_string_get(char_set,str_ind) & mask)?1:0}
    function pad_of_pad_opt(pad_opt)
     {if(pad_opt){var width=pad_opt[1];return [0,1,width]}return 0}
    function param_format_of_ignored_format(ign,fmt)
     {if(typeof ign === "number")
       switch(ign)
        {case 0:return [0,[0,fmt]];
         case 1:return [0,[1,fmt]];
         case 2:return [0,[19,fmt]];
         default:return [0,[22,fmt]]}
      else
       switch(ign[0])
        {case 0:var pad_opt=ign[1];return [0,[2,pad_of_pad_opt(pad_opt),fmt]];
         case 1:
          var pad_opt$0=ign[1];return [0,[3,pad_of_pad_opt(pad_opt$0),fmt]];
         case 2:
          var pad_opt$1=ign[2],iconv=ign[1];
          return [0,[4,iconv,pad_of_pad_opt(pad_opt$1),0,fmt]];
         case 3:
          var pad_opt$2=ign[2],iconv$0=ign[1];
          return [0,[5,iconv$0,pad_of_pad_opt(pad_opt$2),0,fmt]];
         case 4:
          var pad_opt$3=ign[2],iconv$1=ign[1];
          return [0,[6,iconv$1,pad_of_pad_opt(pad_opt$3),0,fmt]];
         case 5:
          var pad_opt$4=ign[2],iconv$2=ign[1];
          return [0,[7,iconv$2,pad_of_pad_opt(pad_opt$4),0,fmt]];
         case 6:
          var prec_opt=ign[2],pad_opt$5=ign[1];
          if(prec_opt)var ndec=prec_opt[1],_rV_=[0,ndec];else var _rV_=0;
          return [0,[8,0,pad_of_pad_opt(pad_opt$5),_rV_,fmt]];
         case 7:
          var pad_opt$6=ign[1];return [0,[9,pad_of_pad_opt(pad_opt$6),fmt]];
         case 8:
          var fmtty=ign[2],pad_opt$7=ign[1];
          return [0,[13,pad_opt$7,fmtty,fmt]];
         case 9:
          var fmtty$0=ign[2],pad_opt$8=ign[1];
          return [0,[14,pad_opt$8,fmtty$0,fmt]];
         case 10:
          var char_set=ign[2],width_opt=ign[1];
          return [0,[20,width_opt,char_set,fmt]];
         default:var counter=ign[1];return [0,[21,counter,fmt]]}}
    var default_float_precision=-6;
    function buffer_create(init_size)
     {return [0,0,caml_create_bytes(init_size)]}
    function buffer_check_size(buf,overhead)
     {var
       len=caml_ml_bytes_length(buf[2]),
       min_len=buf[1] + overhead | 0,
       _rT_=len < min_len?1:0;
      if(_rT_)
       {var
         new_len=max(len * 2 | 0,min_len),
         new_str=caml_create_bytes(new_len);
        blit(buf[2],0,new_str,0,len);
        buf[2] = new_str;
        var _rU_=0}
      else
       var _rU_=_rT_;
      return _rU_}
    function buffer_add_char(buf,c)
     {buffer_check_size(buf,1);
      caml_bytes_set(buf[2],buf[1],c);
      buf[1] = buf[1] + 1 | 0;
      return 0}
    function buffer_add_string(buf,s)
     {var str_len=caml_ml_string_length(s);
      buffer_check_size(buf,str_len);
      blit$0(s,0,buf[2],buf[1],str_len);
      buf[1] = buf[1] + str_len | 0;
      return 0}
    function buffer_contents(buf){return sub_string(buf[2],0,buf[1])}
    function char_of_iconv(iconv)
     {switch(iconv)
       {case 12:return 117;
        case 6:
        case 7:return 120;
        case 8:
        case 9:return 88;
        case 10:
        case 11:return 111;
        case 0:
        case 1:
        case 2:return 100;
        default:return 105}}
    function char_of_fconv(fconv)
     {switch(fconv)
       {case 15:return 70;
        case 0:
        case 1:
        case 2:return 102;
        case 3:
        case 4:
        case 5:return 101;
        case 6:
        case 7:
        case 8:return 69;
        case 9:
        case 10:
        case 11:return 103;
        case 12:
        case 13:
        case 14:return 71;
        case 16:
        case 17:
        case 18:return 104;
        default:return 72}}
    function bprint_padty(buf,padty)
     {switch(padty)
       {case 0:return buffer_add_char(buf,45);
        case 1:return 0;
        default:return buffer_add_char(buf,48)}}
    function bprint_ignored_flag(buf,ign_flag)
     {return ign_flag?buffer_add_char(buf,95):ign_flag}
    function bprint_pad_opt(buf,pad_opt)
     {if(pad_opt)
       {var width=pad_opt[1];
        return buffer_add_string(buf,caml_new_string("" + width))}
      return 0}
    function bprint_padding(buf,pad)
     {if(typeof pad === "number")
       return 0;
      else
       {if(0 === pad[0])
         {var n=pad[2],padty=pad[1];
          bprint_padty(buf,padty);
          return buffer_add_string(buf,caml_new_string("" + n))}
        var padty$0=pad[1];
        bprint_padty(buf,padty$0);
        return buffer_add_char(buf,42)}}
    function bprint_precision(buf,prec)
     {if(typeof prec === "number")
       return 0 === prec?0:buffer_add_string(buf,cst$10);
      var n=prec[1];
      buffer_add_char(buf,46);
      return buffer_add_string(buf,caml_new_string("" + n))}
    function bprint_iconv_flag(buf,iconv)
     {switch(iconv)
       {case 1:
        case 4:return buffer_add_char(buf,43);
        case 2:
        case 5:return buffer_add_char(buf,32);
        case 7:
        case 9:
        case 11:return buffer_add_char(buf,35);
        default:return 0}}
    function bprint_altint_fmt(buf,ign_flag,iconv,pad,prec,c)
     {buffer_add_char(buf,37);
      bprint_ignored_flag(buf,ign_flag);
      bprint_iconv_flag(buf,iconv);
      bprint_padding(buf,pad);
      bprint_precision(buf,prec);
      buffer_add_char(buf,c);
      return buffer_add_char(buf,char_of_iconv(iconv))}
    function bprint_fconv_flag(buf,fconv)
     {switch(fconv)
       {case 1:
        case 4:
        case 7:
        case 10:
        case 13:
        case 17:
        case 20:return buffer_add_char(buf,43);
        case 2:
        case 5:
        case 8:
        case 11:
        case 14:
        case 18:
        case 21:return buffer_add_char(buf,32);
        default:return 0}}
    function string_of_formatting_lit(formatting_lit)
     {if(typeof formatting_lit === "number")
       switch(formatting_lit)
        {case 0:return cst$11;
         case 1:return cst$12;
         case 2:return cst$13;
         case 3:return cst$14;
         case 4:return cst$15;
         case 5:return cst$16;
         default:return cst$17}
      else
       switch(formatting_lit[0])
        {case 0:var str=formatting_lit[1];return str;
         case 1:var str$0=formatting_lit[1];return str$0;
         default:var c=formatting_lit[1];return symbol(cst$18,make$0(1,c))}}
    function string_of_formatting_gen(formatting_gen)
     {if(0 === formatting_gen[0])
       {var match=formatting_gen[1],str=match[2];return str}
      var match$0=formatting_gen[1],str$0=match$0[2];
      return str$0}
    function bprint_char_literal(buf,chr)
     {return 37 === chr?buffer_add_string(buf,cst$19):buffer_add_char(buf,chr)}
    function bprint_string_literal(buf,str)
     {var _rR_=caml_ml_string_length(str) - 1 | 0,_rQ_=0;
      if(! (_rR_ < 0))
       {var i=_rQ_;
        for(;;)
         {bprint_char_literal(buf,caml_string_get(str,i));
          var _rS_=i + 1 | 0;
          if(_rR_ !== i){var i=_rS_;continue}
          break}}
      return 0}
    function bprint_fmtty(buf,fmtty)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        return 0;
       else
        switch(fmtty$0[0])
         {case 0:
           var rest=fmtty$0[1];
           buffer_add_string(buf,cst_c);
           var fmtty$0=rest;
           continue;
          case 1:
           var rest$0=fmtty$0[1];
           buffer_add_string(buf,cst_s);
           var fmtty$0=rest$0;
           continue;
          case 2:
           var rest$1=fmtty$0[1];
           buffer_add_string(buf,cst_i);
           var fmtty$0=rest$1;
           continue;
          case 3:
           var rest$2=fmtty$0[1];
           buffer_add_string(buf,cst_li);
           var fmtty$0=rest$2;
           continue;
          case 4:
           var rest$3=fmtty$0[1];
           buffer_add_string(buf,cst_ni);
           var fmtty$0=rest$3;
           continue;
          case 5:
           var rest$4=fmtty$0[1];
           buffer_add_string(buf,cst_Li);
           var fmtty$0=rest$4;
           continue;
          case 6:
           var rest$5=fmtty$0[1];
           buffer_add_string(buf,cst_f);
           var fmtty$0=rest$5;
           continue;
          case 7:
           var rest$6=fmtty$0[1];
           buffer_add_string(buf,cst_B);
           var fmtty$0=rest$6;
           continue;
          case 8:
           var rest$7=fmtty$0[2],sub_fmtty=fmtty$0[1];
           buffer_add_string(buf,cst$20);
           bprint_fmtty(buf,sub_fmtty);
           buffer_add_string(buf,cst$21);
           var fmtty$0=rest$7;
           continue;
          case 9:
           var rest$8=fmtty$0[3],sub_fmtty$0=fmtty$0[1];
           buffer_add_string(buf,cst$22);
           bprint_fmtty(buf,sub_fmtty$0);
           buffer_add_string(buf,cst$23);
           var fmtty$0=rest$8;
           continue;
          case 10:
           var rest$9=fmtty$0[1];
           buffer_add_string(buf,cst_a);
           var fmtty$0=rest$9;
           continue;
          case 11:
           var rest$10=fmtty$0[1];
           buffer_add_string(buf,cst_t$0);
           var fmtty$0=rest$10;
           continue;
          case 12:
           var rest$11=fmtty$0[1];
           buffer_add_string(buf,cst$24);
           var fmtty$0=rest$11;
           continue;
          case 13:
           var rest$12=fmtty$0[1];
           buffer_add_string(buf,cst_r$0);
           var fmtty$0=rest$12;
           continue;
          default:
           var rest$13=fmtty$0[1];
           buffer_add_string(buf,cst_r$1);
           var fmtty$0=rest$13;
           continue}}
    function int_of_custom_arity(param)
     {if(param){var x=param[1];return 1 + int_of_custom_arity(x) | 0}return 0}
    function string_of_fmt(fmt$1)
     {var buf=buffer_create(16),fmt=fmt$1,ign_flag=0;
      a:
      for(;;)
       if(typeof fmt === "number")
        return buffer_contents(buf);
       else
        switch(fmt[0])
         {case 0:
           var rest=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,99);
           var fmt=rest,ign_flag=0;
           continue;
          case 1:
           var rest$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,67);
           var fmt=rest$0,ign_flag=0;
           continue;
          case 2:
           var rest$1=fmt[2],pad=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad);
           buffer_add_char(buf,115);
           var fmt=rest$1,ign_flag=0;
           continue;
          case 3:
           var rest$2=fmt[2],pad$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad$0);
           buffer_add_char(buf,83);
           var fmt=rest$2,ign_flag=0;
           continue;
          case 4:
           var rest$3=fmt[4],prec=fmt[3],pad$1=fmt[2],iconv=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_iconv_flag(buf,iconv);
           bprint_padding(buf,pad$1);
           bprint_precision(buf,prec);
           buffer_add_char(buf,char_of_iconv(iconv));
           var fmt=rest$3,ign_flag=0;
           continue;
          case 5:
           var rest$4=fmt[4],prec$0=fmt[3],pad$2=fmt[2],iconv$0=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$0,pad$2,prec$0,108);
           var fmt=rest$4,ign_flag=0;
           continue;
          case 6:
           var rest$5=fmt[4],prec$1=fmt[3],pad$3=fmt[2],iconv$1=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$1,pad$3,prec$1,110);
           var fmt=rest$5,ign_flag=0;
           continue;
          case 7:
           var rest$6=fmt[4],prec$2=fmt[3],pad$4=fmt[2],iconv$2=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$2,pad$4,prec$2,76);
           var fmt=rest$6,ign_flag=0;
           continue;
          case 8:
           var rest$7=fmt[4],prec$3=fmt[3],pad$5=fmt[2],fconv=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_fconv_flag(buf,fconv);
           bprint_padding(buf,pad$5);
           bprint_precision(buf,prec$3);
           buffer_add_char(buf,char_of_fconv(fconv));
           var fmt=rest$7,ign_flag=0;
           continue;
          case 9:
           var rest$8=fmt[2],pad$6=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad$6);
           buffer_add_char(buf,66);
           var fmt=rest$8,ign_flag=0;
           continue;
          case 10:
           var rest$9=fmt[1];
           buffer_add_string(buf,cst$25);
           var fmt=rest$9;
           continue;
          case 11:
           var rest$10=fmt[2],str=fmt[1];
           bprint_string_literal(buf,str);
           var fmt=rest$10;
           continue;
          case 12:
           var rest$11=fmt[2],chr$0=fmt[1];
           bprint_char_literal(buf,chr$0);
           var fmt=rest$11;
           continue;
          case 13:
           var rest$12=fmt[3],fmtty=fmt[2],pad_opt=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,pad_opt);
           buffer_add_char(buf,123);
           bprint_fmtty(buf,fmtty);
           buffer_add_char(buf,37);
           buffer_add_char(buf,125);
           var fmt=rest$12,ign_flag=0;
           continue;
          case 14:
           var rest$13=fmt[3],fmtty$0=fmt[2],pad_opt$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,pad_opt$0);
           buffer_add_char(buf,40);
           bprint_fmtty(buf,fmtty$0);
           buffer_add_char(buf,37);
           buffer_add_char(buf,41);
           var fmt=rest$13,ign_flag=0;
           continue;
          case 15:
           var rest$14=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,97);
           var fmt=rest$14,ign_flag=0;
           continue;
          case 16:
           var rest$15=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,116);
           var fmt=rest$15,ign_flag=0;
           continue;
          case 17:
           var rest$16=fmt[2],fmting_lit=fmt[1];
           bprint_string_literal(buf,string_of_formatting_lit(fmting_lit));
           var fmt=rest$16;
           continue;
          case 18:
           var rest$17=fmt[2],fmting_gen=fmt[1];
           bprint_string_literal(buf,cst$26);
           bprint_string_literal(buf,string_of_formatting_gen(fmting_gen));
           var fmt=rest$17;
           continue;
          case 19:
           var rest$18=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,114);
           var fmt=rest$18,ign_flag=0;
           continue;
          case 20:
           var rest$19=fmt[3],char_set=fmt[2],width_opt=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,width_opt);
           var
            print_char=
             function(buf,i)
              {var c=char_of_int(i);
               return 37 === c
                       ?(buffer_add_char(buf,37),buffer_add_char(buf,37))
                       :64 === c
                         ?(buffer_add_char(buf,37),buffer_add_char(buf,64))
                         :buffer_add_char(buf,c)};
           buffer_add_char(buf,91);
           var
            _rG_=
             is_in_char_set(char_set,0)
              ?(buffer_add_char(buf,94),rev_char_set(char_set))
              :char_set,
            is_alone$0=
             function(_rL_)
              {function is_alone(c)
                {var
                  after=chr(c + 1 | 0),
                  before=chr(c - 1 | 0),
                  _rM_=is_in_char_set(_rL_,c);
                 if(_rM_)
                  var
                   _rN_=is_in_char_set(_rL_,before),
                   _rO_=_rN_?is_in_char_set(_rL_,after):_rN_,
                   _rP_=1 - _rO_;
                 else
                  var _rP_=_rM_;
                 return _rP_}
               return is_alone},
            is_alone=is_alone$0(_rG_);
           if(is_alone(93))buffer_add_char(buf,93);
           var i=1;
           b:
           for(;;)
            {if(i < 256)
              {if(! is_in_char_set(_rG_,char_of_int(i)))
                {var i$0=i + 1 | 0,i=i$0;continue}
               var match=char_of_int(i),switcher=match - 45 | 0;
               if(48 < switcher >>> 0)
                var switch$0=210 <= switcher?(print_char(buf,255),1):0;
               else
                {var switcher$0=switcher - 1 | 0;
                 if(46 < switcher$0 >>> 0){var i$2=i + 1 | 0,i=i$2;continue}
                 var switch$0=0}
               if(! switch$0)
                {var i$1=i + 1 | 0;
                 if(! is_in_char_set(_rG_,char_of_int(i$1)))
                  {print_char(buf,i$1 - 1 | 0);
                   var i$6=i$1 + 1 | 0,i=i$6;
                   continue}
                 var match$0=char_of_int(i$1),switcher$1=match$0 - 45 | 0;
                 if(48 < switcher$1 >>> 0)
                  var
                   switch$1=
                    210 <= switcher$1
                     ?(print_char(buf,254),print_char(buf,255),1)
                     :0;
                 else
                  {var switcher$2=switcher$1 - 1 | 0;
                   if(46 < switcher$2 >>> 0)
                    {if(! is_in_char_set(_rG_,char_of_int(i$1 + 1 | 0)))
                      {print_char(buf,i$1 - 1 | 0);
                       var i$5=i$1 + 1 | 0,i=i$5;
                       continue}
                     var switch$1=0}
                   else
                    var switch$1=0}
                 if(! switch$1)
                  {if(! is_in_char_set(_rG_,char_of_int(i$1 + 1 | 0)))
                    {print_char(buf,i$1 - 1 | 0);
                     print_char(buf,i$1);
                     var i$4=i$1 + 2 | 0,i=i$4;
                     continue}
                   var j=i$1 + 2 | 0,i$3=i$1 - 1 | 0,j$0=j;
                   for(;;)
                    {if(256 !== j$0)
                      if(is_in_char_set(_rG_,char_of_int(j$0)))
                       {var j$1=j$0 + 1 | 0,j$0=j$1;continue}
                     print_char(buf,i$3);
                     print_char(buf,45);
                     print_char(buf,j$0 - 1 | 0);
                     if(j$0 < 256){var i$7=j$0 + 1 | 0,i=i$7;continue b}
                     break}}}}
             if(is_alone(45))buffer_add_char(buf,45);
             buffer_add_char(buf,93);
             var fmt=rest$19,ign_flag=0;
             continue a}
          case 21:
           var rest$20=fmt[2],counter=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           switch(counter)
            {case 0:var _rH_=108;break;
             case 1:var _rH_=110;break;
             default:var _rH_=78}
           buffer_add_char(buf,_rH_);
           var fmt=rest$20,ign_flag=0;
           continue;
          case 22:
           var rest$21=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_string_literal(buf,cst_0c);
           var fmt=rest$21,ign_flag=0;
           continue;
          case 23:
           var
            rest$22=fmt[2],
            ign=fmt[1],
            match$1=param_format_of_ignored_format(ign,rest$22),
            fmt$0=match$1[1],
            fmt=fmt$0,
            ign_flag=1;
           continue;
          default:
           var
            rest$23=fmt[3],
            arity=fmt[1],
            _rJ_=int_of_custom_arity(arity),
            _rI_=1;
           if(! (_rJ_ < 1))
            {var i$8=_rI_;
             for(;;)
              {buffer_add_char(buf,37);
               bprint_ignored_flag(buf,ign_flag);
               buffer_add_char(buf,63);
               var _rK_=i$8 + 1 | 0;
               if(_rJ_ !== i$8){var i$8=_rK_;continue}
               break}}
           var fmt=rest$23,ign_flag=0;
           continue}}
    function symm(param)
     {if(typeof param === "number")
       return 0;
      else
       switch(param[0])
        {case 0:var rest=param[1];return [0,symm(rest)];
         case 1:var rest$0=param[1];return [1,symm(rest$0)];
         case 2:var rest$1=param[1];return [2,symm(rest$1)];
         case 3:var rest$2=param[1];return [3,symm(rest$2)];
         case 4:var rest$3=param[1];return [4,symm(rest$3)];
         case 5:var rest$4=param[1];return [5,symm(rest$4)];
         case 6:var rest$5=param[1];return [6,symm(rest$5)];
         case 7:var rest$6=param[1];return [7,symm(rest$6)];
         case 8:var rest$7=param[2],ty=param[1];return [8,ty,symm(rest$7)];
         case 9:
          var rest$8=param[3],ty2=param[2],ty1=param[1];
          return [9,ty2,ty1,symm(rest$8)];
         case 10:var rest$9=param[1];return [10,symm(rest$9)];
         case 11:var rest$10=param[1];return [11,symm(rest$10)];
         case 12:var rest$11=param[1];return [12,symm(rest$11)];
         case 13:var rest$12=param[1];return [13,symm(rest$12)];
         default:var rest$13=param[1];return [14,symm(rest$13)]}}
    function fmtty_rel_det(param)
     {if(typeof param === "number")
       {var
         _ri_=function(param){return 0},
         _rj_=function(param){return 0},
         _rk_=function(param){return 0};
        return [0,function(param){return 0},_rk_,_rj_,_ri_]}
      else
       switch(param[0])
        {case 0:
          var
           rest=param[1],
           match=fmtty_rel_det(rest),
           de=match[4],
           ed=match[3],
           af=match[2],
           fa=match[1],
           _rl_=function(param){caml_call1(af,0);return 0};
          return [0,function(param){caml_call1(fa,0);return 0},_rl_,ed,de];
         case 1:
          var
           rest$0=param[1],
           match$0=fmtty_rel_det(rest$0),
           de$0=match$0[4],
           ed$0=match$0[3],
           af$0=match$0[2],
           fa$0=match$0[1],
           _rm_=function(param){caml_call1(af$0,0);return 0};
          return [0,
                  function(param){caml_call1(fa$0,0);return 0},
                  _rm_,
                  ed$0,
                  de$0];
         case 2:
          var
           rest$1=param[1],
           match$1=fmtty_rel_det(rest$1),
           de$1=match$1[4],
           ed$1=match$1[3],
           af$1=match$1[2],
           fa$1=match$1[1],
           _rn_=function(param){caml_call1(af$1,0);return 0};
          return [0,
                  function(param){caml_call1(fa$1,0);return 0},
                  _rn_,
                  ed$1,
                  de$1];
         case 3:
          var
           rest$2=param[1],
           match$2=fmtty_rel_det(rest$2),
           de$2=match$2[4],
           ed$2=match$2[3],
           af$2=match$2[2],
           fa$2=match$2[1],
           _ro_=function(param){caml_call1(af$2,0);return 0};
          return [0,
                  function(param){caml_call1(fa$2,0);return 0},
                  _ro_,
                  ed$2,
                  de$2];
         case 4:
          var
           rest$3=param[1],
           match$3=fmtty_rel_det(rest$3),
           de$3=match$3[4],
           ed$3=match$3[3],
           af$3=match$3[2],
           fa$3=match$3[1],
           _rp_=function(param){caml_call1(af$3,0);return 0};
          return [0,
                  function(param){caml_call1(fa$3,0);return 0},
                  _rp_,
                  ed$3,
                  de$3];
         case 5:
          var
           rest$4=param[1],
           match$4=fmtty_rel_det(rest$4),
           de$4=match$4[4],
           ed$4=match$4[3],
           af$4=match$4[2],
           fa$4=match$4[1],
           _rq_=function(param){caml_call1(af$4,0);return 0};
          return [0,
                  function(param){caml_call1(fa$4,0);return 0},
                  _rq_,
                  ed$4,
                  de$4];
         case 6:
          var
           rest$5=param[1],
           match$5=fmtty_rel_det(rest$5),
           de$5=match$5[4],
           ed$5=match$5[3],
           af$5=match$5[2],
           fa$5=match$5[1],
           _rr_=function(param){caml_call1(af$5,0);return 0};
          return [0,
                  function(param){caml_call1(fa$5,0);return 0},
                  _rr_,
                  ed$5,
                  de$5];
         case 7:
          var
           rest$6=param[1],
           match$6=fmtty_rel_det(rest$6),
           de$6=match$6[4],
           ed$6=match$6[3],
           af$6=match$6[2],
           fa$6=match$6[1],
           _rs_=function(param){caml_call1(af$6,0);return 0};
          return [0,
                  function(param){caml_call1(fa$6,0);return 0},
                  _rs_,
                  ed$6,
                  de$6];
         case 8:
          var
           rest$7=param[2],
           match$7=fmtty_rel_det(rest$7),
           de$7=match$7[4],
           ed$7=match$7[3],
           af$7=match$7[2],
           fa$7=match$7[1],
           _rt_=function(param){caml_call1(af$7,0);return 0};
          return [0,
                  function(param){caml_call1(fa$7,0);return 0},
                  _rt_,
                  ed$7,
                  de$7];
         case 9:
          var
           rest$8=param[3],
           ty2=param[2],
           ty1=param[1],
           match$8=fmtty_rel_det(rest$8),
           de$8=match$8[4],
           ed$8=match$8[3],
           af$8=match$8[2],
           fa$8=match$8[1],
           ty=trans(symm(ty1),ty2),
           match$9=fmtty_rel_det(ty),
           jd=match$9[4],
           dj=match$9[3],
           ga=match$9[2],
           ag=match$9[1],
           _ru_=function(param){caml_call1(jd,0);caml_call1(de$8,0);return 0},
           _rv_=function(param){caml_call1(ed$8,0);caml_call1(dj,0);return 0},
           _rw_=function(param){caml_call1(ga,0);caml_call1(af$8,0);return 0};
          return [0,
                  function(param)
                   {caml_call1(fa$8,0);caml_call1(ag,0);return 0},
                  _rw_,
                  _rv_,
                  _ru_];
         case 10:
          var
           rest$9=param[1],
           match$10=fmtty_rel_det(rest$9),
           de$9=match$10[4],
           ed$9=match$10[3],
           af$9=match$10[2],
           fa$9=match$10[1],
           _rx_=function(param){caml_call1(af$9,0);return 0};
          return [0,
                  function(param){caml_call1(fa$9,0);return 0},
                  _rx_,
                  ed$9,
                  de$9];
         case 11:
          var
           rest$10=param[1],
           match$11=fmtty_rel_det(rest$10),
           de$10=match$11[4],
           ed$10=match$11[3],
           af$10=match$11[2],
           fa$10=match$11[1],
           _ry_=function(param){caml_call1(af$10,0);return 0};
          return [0,
                  function(param){caml_call1(fa$10,0);return 0},
                  _ry_,
                  ed$10,
                  de$10];
         case 12:
          var
           rest$11=param[1],
           match$12=fmtty_rel_det(rest$11),
           de$11=match$12[4],
           ed$11=match$12[3],
           af$11=match$12[2],
           fa$11=match$12[1],
           _rz_=function(param){caml_call1(af$11,0);return 0};
          return [0,
                  function(param){caml_call1(fa$11,0);return 0},
                  _rz_,
                  ed$11,
                  de$11];
         case 13:
          var
           rest$12=param[1],
           match$13=fmtty_rel_det(rest$12),
           de$12=match$13[4],
           ed$12=match$13[3],
           af$12=match$13[2],
           fa$12=match$13[1],
           _rA_=function(param){caml_call1(de$12,0);return 0},
           _rB_=function(param){caml_call1(ed$12,0);return 0},
           _rC_=function(param){caml_call1(af$12,0);return 0};
          return [0,
                  function(param){caml_call1(fa$12,0);return 0},
                  _rC_,
                  _rB_,
                  _rA_];
         default:
          var
           rest$13=param[1],
           match$14=fmtty_rel_det(rest$13),
           de$13=match$14[4],
           ed$13=match$14[3],
           af$13=match$14[2],
           fa$13=match$14[1],
           _rD_=function(param){caml_call1(de$13,0);return 0},
           _rE_=function(param){caml_call1(ed$13,0);return 0},
           _rF_=function(param){caml_call1(af$13,0);return 0};
          return [0,
                  function(param){caml_call1(fa$13,0);return 0},
                  _rF_,
                  _rE_,
                  _rD_]}}
    function trans(ty1,match)
     {if(typeof ty1 === "number")
       if(typeof match === "number")
        return 0;
       else
        switch(match[0])
         {case 10:var switch$0=0;break;
          case 11:var switch$0=1;break;
          case 12:var switch$0=2;break;
          case 13:var switch$0=3;break;
          case 14:var switch$0=4;break;
          case 8:var switch$0=5;break;
          case 9:var switch$0=6;break;
          default:throw [0,Assert_failure,___]}
      else
       switch(ty1[0])
        {case 0:
          var _q1_=ty1[1];
          if(typeof match === "number")
           var switch$1=1;
          else
           switch(match[0])
            {case 0:var rest2=match[1];return [0,trans(_q1_,rest2)];
             case 8:var switch$0=5,switch$1=0;break;
             case 9:var switch$0=6,switch$1=0;break;
             case 10:var switch$0=0,switch$1=0;break;
             case 11:var switch$0=1,switch$1=0;break;
             case 12:var switch$0=2,switch$1=0;break;
             case 13:var switch$0=3,switch$1=0;break;
             case 14:var switch$0=4,switch$1=0;break;
             default:var switch$1=1}
          if(switch$1)var switch$0=7;
          break;
         case 1:
          var _q2_=ty1[1];
          if(typeof match === "number")
           var switch$2=1;
          else
           switch(match[0])
            {case 1:var rest2$0=match[1];return [1,trans(_q2_,rest2$0)];
             case 8:var switch$0=5,switch$2=0;break;
             case 9:var switch$0=6,switch$2=0;break;
             case 10:var switch$0=0,switch$2=0;break;
             case 11:var switch$0=1,switch$2=0;break;
             case 12:var switch$0=2,switch$2=0;break;
             case 13:var switch$0=3,switch$2=0;break;
             case 14:var switch$0=4,switch$2=0;break;
             default:var switch$2=1}
          if(switch$2)var switch$0=7;
          break;
         case 2:
          var _q3_=ty1[1];
          if(typeof match === "number")
           var switch$3=1;
          else
           switch(match[0])
            {case 2:var rest2$1=match[1];return [2,trans(_q3_,rest2$1)];
             case 8:var switch$0=5,switch$3=0;break;
             case 9:var switch$0=6,switch$3=0;break;
             case 10:var switch$0=0,switch$3=0;break;
             case 11:var switch$0=1,switch$3=0;break;
             case 12:var switch$0=2,switch$3=0;break;
             case 13:var switch$0=3,switch$3=0;break;
             case 14:var switch$0=4,switch$3=0;break;
             default:var switch$3=1}
          if(switch$3)var switch$0=7;
          break;
         case 3:
          var _q4_=ty1[1];
          if(typeof match === "number")
           var switch$4=1;
          else
           switch(match[0])
            {case 3:var rest2$2=match[1];return [3,trans(_q4_,rest2$2)];
             case 8:var switch$0=5,switch$4=0;break;
             case 9:var switch$0=6,switch$4=0;break;
             case 10:var switch$0=0,switch$4=0;break;
             case 11:var switch$0=1,switch$4=0;break;
             case 12:var switch$0=2,switch$4=0;break;
             case 13:var switch$0=3,switch$4=0;break;
             case 14:var switch$0=4,switch$4=0;break;
             default:var switch$4=1}
          if(switch$4)var switch$0=7;
          break;
         case 4:
          var _q5_=ty1[1];
          if(typeof match === "number")
           var switch$5=1;
          else
           switch(match[0])
            {case 4:var rest2$3=match[1];return [4,trans(_q5_,rest2$3)];
             case 8:var switch$0=5,switch$5=0;break;
             case 9:var switch$0=6,switch$5=0;break;
             case 10:var switch$0=0,switch$5=0;break;
             case 11:var switch$0=1,switch$5=0;break;
             case 12:var switch$0=2,switch$5=0;break;
             case 13:var switch$0=3,switch$5=0;break;
             case 14:var switch$0=4,switch$5=0;break;
             default:var switch$5=1}
          if(switch$5)var switch$0=7;
          break;
         case 5:
          var _q6_=ty1[1];
          if(typeof match === "number")
           var switch$6=1;
          else
           switch(match[0])
            {case 5:var rest2$4=match[1];return [5,trans(_q6_,rest2$4)];
             case 8:var switch$0=5,switch$6=0;break;
             case 9:var switch$0=6,switch$6=0;break;
             case 10:var switch$0=0,switch$6=0;break;
             case 11:var switch$0=1,switch$6=0;break;
             case 12:var switch$0=2,switch$6=0;break;
             case 13:var switch$0=3,switch$6=0;break;
             case 14:var switch$0=4,switch$6=0;break;
             default:var switch$6=1}
          if(switch$6)var switch$0=7;
          break;
         case 6:
          var _q7_=ty1[1];
          if(typeof match === "number")
           var switch$7=1;
          else
           switch(match[0])
            {case 6:var rest2$5=match[1];return [6,trans(_q7_,rest2$5)];
             case 8:var switch$0=5,switch$7=0;break;
             case 9:var switch$0=6,switch$7=0;break;
             case 10:var switch$0=0,switch$7=0;break;
             case 11:var switch$0=1,switch$7=0;break;
             case 12:var switch$0=2,switch$7=0;break;
             case 13:var switch$0=3,switch$7=0;break;
             case 14:var switch$0=4,switch$7=0;break;
             default:var switch$7=1}
          if(switch$7)var switch$0=7;
          break;
         case 7:
          var _q8_=ty1[1];
          if(typeof match === "number")
           var switch$8=1;
          else
           switch(match[0])
            {case 7:var rest2$6=match[1];return [7,trans(_q8_,rest2$6)];
             case 8:var switch$0=5,switch$8=0;break;
             case 9:var switch$0=6,switch$8=0;break;
             case 10:var switch$0=0,switch$8=0;break;
             case 11:var switch$0=1,switch$8=0;break;
             case 12:var switch$0=2,switch$8=0;break;
             case 13:var switch$0=3,switch$8=0;break;
             case 14:var switch$0=4,switch$8=0;break;
             default:var switch$8=1}
          if(switch$8)var switch$0=7;
          break;
         case 8:
          var _q9_=ty1[2],_q__=ty1[1];
          if(typeof match === "number")
           var switch$9=1;
          else
           switch(match[0])
            {case 8:
              var rest2$7=match[2],ty2=match[1],_q$_=trans(_q9_,rest2$7);
              return [8,trans(_q__,ty2),_q$_];
             case 10:var switch$0=0,switch$9=0;break;
             case 11:var switch$0=1,switch$9=0;break;
             case 12:var switch$0=2,switch$9=0;break;
             case 13:var switch$0=3,switch$9=0;break;
             case 14:var switch$0=4,switch$9=0;break;
             default:var switch$9=1}
          if(switch$9)throw [0,Assert_failure,_ah_];
          break;
         case 9:
          var _ra_=ty1[3],_rb_=ty1[2],_rc_=ty1[1];
          if(typeof match === "number")
           var switch$10=1;
          else
           switch(match[0])
            {case 8:var switch$0=5,switch$10=0;break;
             case 9:
              var
               rest2$8=match[3],
               ty22=match[2],
               ty21=match[1],
               ty=trans(symm(_rb_),ty21),
               match$0=fmtty_rel_det(ty),
               f4=match$0[4],
               f2=match$0[2];
              caml_call1(f2,0);
              caml_call1(f4,0);
              return [9,_rc_,ty22,trans(_ra_,rest2$8)];
             case 10:var switch$0=0,switch$10=0;break;
             case 11:var switch$0=1,switch$10=0;break;
             case 12:var switch$0=2,switch$10=0;break;
             case 13:var switch$0=3,switch$10=0;break;
             case 14:var switch$0=4,switch$10=0;break;
             default:var switch$10=1}
          if(switch$10)throw [0,Assert_failure,_ai_];
          break;
         case 10:
          var _rd_=ty1[1];
          if(typeof match !== "number" && 10 === match[0])
           {var rest2$9=match[1];return [10,trans(_rd_,rest2$9)]}
          throw [0,Assert_failure,_aj_];
         case 11:
          var _re_=ty1[1];
          if(typeof match === "number")
           var switch$11=1;
          else
           switch(match[0])
            {case 10:var switch$0=0,switch$11=0;break;
             case 11:var rest2$10=match[1];return [11,trans(_re_,rest2$10)];
             default:var switch$11=1}
          if(switch$11)throw [0,Assert_failure,_ak_];
          break;
         case 12:
          var _rf_=ty1[1];
          if(typeof match === "number")
           var switch$12=1;
          else
           switch(match[0])
            {case 10:var switch$0=0,switch$12=0;break;
             case 11:var switch$0=1,switch$12=0;break;
             case 12:var rest2$11=match[1];return [12,trans(_rf_,rest2$11)];
             default:var switch$12=1}
          if(switch$12)throw [0,Assert_failure,_al_];
          break;
         case 13:
          var _rg_=ty1[1];
          if(typeof match === "number")
           var switch$13=1;
          else
           switch(match[0])
            {case 10:var switch$0=0,switch$13=0;break;
             case 11:var switch$0=1,switch$13=0;break;
             case 12:var switch$0=2,switch$13=0;break;
             case 13:var rest2$12=match[1];return [13,trans(_rg_,rest2$12)];
             default:var switch$13=1}
          if(switch$13)throw [0,Assert_failure,_am_];
          break;
         default:
          var _rh_=ty1[1];
          if(typeof match === "number")
           var switch$14=1;
          else
           switch(match[0])
            {case 10:var switch$0=0,switch$14=0;break;
             case 11:var switch$0=1,switch$14=0;break;
             case 12:var switch$0=2,switch$14=0;break;
             case 13:var switch$0=3,switch$14=0;break;
             case 14:var rest2$13=match[1];return [14,trans(_rh_,rest2$13)];
             default:var switch$14=1}
          if(switch$14)throw [0,Assert_failure,_an_]}
      switch(switch$0)
       {case 0:throw [0,Assert_failure,_ab_];
        case 1:throw [0,Assert_failure,_ac_];
        case 2:throw [0,Assert_failure,_ad_];
        case 3:throw [0,Assert_failure,_ae_];
        case 4:throw [0,Assert_failure,_af_];
        case 5:throw [0,Assert_failure,_$_];
        case 6:throw [0,Assert_failure,_aa_];
        default:throw [0,Assert_failure,_ag_]}}
    function fmtty_of_padding_fmtty(pad,fmtty)
     {return typeof pad === "number"?fmtty:0 === pad[0]?fmtty:[2,fmtty]}
    function fmtty_of_custom(arity,fmtty)
     {if(arity)
       {var arity$0=arity[1];return [12,fmtty_of_custom(arity$0,fmtty)]}
      return fmtty}
    function fmtty_of_fmt(fmtty)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        return 0;
       else
        switch(fmtty$0[0])
         {case 0:var rest=fmtty$0[1];return [0,fmtty_of_fmt(rest)];
          case 1:var rest$0=fmtty$0[1];return [0,fmtty_of_fmt(rest$0)];
          case 2:
           var rest$1=fmtty$0[2],pad=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad,[1,fmtty_of_fmt(rest$1)]);
          case 3:
           var rest$2=fmtty$0[2],pad$0=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad$0,[1,fmtty_of_fmt(rest$2)]);
          case 4:
           var
            rest$3=fmtty$0[4],
            prec=fmtty$0[3],
            pad$1=fmtty$0[2],
            ty_rest=fmtty_of_fmt(rest$3),
            prec_ty=fmtty_of_precision_fmtty(prec,[2,ty_rest]);
           return fmtty_of_padding_fmtty(pad$1,prec_ty);
          case 5:
           var
            rest$4=fmtty$0[4],
            prec$0=fmtty$0[3],
            pad$2=fmtty$0[2],
            ty_rest$0=fmtty_of_fmt(rest$4),
            prec_ty$0=fmtty_of_precision_fmtty(prec$0,[3,ty_rest$0]);
           return fmtty_of_padding_fmtty(pad$2,prec_ty$0);
          case 6:
           var
            rest$5=fmtty$0[4],
            prec$1=fmtty$0[3],
            pad$3=fmtty$0[2],
            ty_rest$1=fmtty_of_fmt(rest$5),
            prec_ty$1=fmtty_of_precision_fmtty(prec$1,[4,ty_rest$1]);
           return fmtty_of_padding_fmtty(pad$3,prec_ty$1);
          case 7:
           var
            rest$6=fmtty$0[4],
            prec$2=fmtty$0[3],
            pad$4=fmtty$0[2],
            ty_rest$2=fmtty_of_fmt(rest$6),
            prec_ty$2=fmtty_of_precision_fmtty(prec$2,[5,ty_rest$2]);
           return fmtty_of_padding_fmtty(pad$4,prec_ty$2);
          case 8:
           var
            rest$7=fmtty$0[4],
            prec$3=fmtty$0[3],
            pad$5=fmtty$0[2],
            ty_rest$3=fmtty_of_fmt(rest$7),
            prec_ty$3=fmtty_of_precision_fmtty(prec$3,[6,ty_rest$3]);
           return fmtty_of_padding_fmtty(pad$5,prec_ty$3);
          case 9:
           var rest$8=fmtty$0[2],pad$6=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad$6,[7,fmtty_of_fmt(rest$8)]);
          case 10:var fmtty$1=fmtty$0[1],fmtty$0=fmtty$1;continue;
          case 11:var fmtty$2=fmtty$0[2],fmtty$0=fmtty$2;continue;
          case 12:var fmtty$3=fmtty$0[2],fmtty$0=fmtty$3;continue;
          case 13:
           var rest$9=fmtty$0[3],ty=fmtty$0[2];
           return [8,ty,fmtty_of_fmt(rest$9)];
          case 14:
           var rest$10=fmtty$0[3],ty$0=fmtty$0[2];
           return [9,ty$0,ty$0,fmtty_of_fmt(rest$10)];
          case 15:var rest$11=fmtty$0[1];return [10,fmtty_of_fmt(rest$11)];
          case 16:var rest$12=fmtty$0[1];return [11,fmtty_of_fmt(rest$12)];
          case 17:var fmtty$4=fmtty$0[2],fmtty$0=fmtty$4;continue;
          case 18:
           var
            rest$13=fmtty$0[2],
            fmting_gen=fmtty$0[1],
            _qZ_=fmtty_of_fmt(rest$13);
           if(0 === fmting_gen[0])
            var match=fmting_gen[1],fmt=match[1],_q0_=fmtty_of_fmt(fmt);
           else
            var
             match$0=fmting_gen[1],
             fmt$0=match$0[1],
             _q0_=fmtty_of_fmt(fmt$0);
           return concat_fmtty(_q0_,_qZ_);
          case 19:var rest$14=fmtty$0[1];return [13,fmtty_of_fmt(rest$14)];
          case 20:var rest$15=fmtty$0[3];return [1,fmtty_of_fmt(rest$15)];
          case 21:var rest$16=fmtty$0[2];return [2,fmtty_of_fmt(rest$16)];
          case 22:var rest$17=fmtty$0[1];return [0,fmtty_of_fmt(rest$17)];
          case 23:
           var rest$18=fmtty$0[2],ign=fmtty$0[1];
           if(typeof ign === "number")
            switch(ign)
             {case 0:var fmtty$0=rest$18;continue;
              case 1:var fmtty$0=rest$18;continue;
              case 2:return [14,fmtty_of_fmt(rest$18)];
              default:var fmtty$0=rest$18;continue}
           else
            switch(ign[0])
             {case 0:var fmtty$0=rest$18;continue;
              case 1:var fmtty$0=rest$18;continue;
              case 2:var fmtty$0=rest$18;continue;
              case 3:var fmtty$0=rest$18;continue;
              case 4:var fmtty$0=rest$18;continue;
              case 5:var fmtty$0=rest$18;continue;
              case 6:var fmtty$0=rest$18;continue;
              case 7:var fmtty$0=rest$18;continue;
              case 8:var fmtty$0=rest$18;continue;
              case 9:
               var fmtty$5=ign[2];
               return concat_fmtty(fmtty$5,fmtty_of_fmt(rest$18));
              case 10:var fmtty$0=rest$18;continue;
              default:var fmtty$0=rest$18;continue}
          default:
           var rest$19=fmtty$0[3],arity=fmtty$0[1];
           return fmtty_of_custom(arity,fmtty_of_fmt(rest$19))}}
    function fmtty_of_precision_fmtty(prec,fmtty)
     {return typeof prec === "number"?0 === prec?fmtty:[2,fmtty]:fmtty}
    var
     Type_mismatch=
      [248,cst_CamlinternalFormat_Type_mismatch,caml_fresh_oo_id(0)];
    function type_padding(pad,match)
     {if(typeof pad === "number")
       return [0,0,match];
      else
       {if(0 === pad[0])
         {var w=pad[2],padty=pad[1];return [0,[0,padty,w],match]}
        if(typeof match !== "number" && 2 === match[0])
         {var rest=match[1],padty$0=pad[1];return [0,[1,padty$0],rest]}
        throw Type_mismatch}}
    function type_padprec(pad,prec,fmtty)
     {var match=type_padding(pad,fmtty);
      if(typeof prec === "number")
       {if(0 === prec)
         {var rest=match[2],pad$0=match[1];return [0,pad$0,0,rest]}
        var _qY_=match[2];
        if(typeof _qY_ !== "number" && 2 === _qY_[0])
         {var rest$0=_qY_[1],pad$1=match[1];return [0,pad$1,1,rest$0]}
        throw Type_mismatch}
      var rest$1=match[2],pad$2=match[1],p=prec[1];
      return [0,pad$2,[0,p],rest$1]}
    function type_format(fmt,fmtty)
     {var _qX_=type_format_gen(fmt,fmtty);
      if(typeof _qX_[2] === "number"){var fmt$0=_qX_[1];return fmt$0}
      throw Type_mismatch}
    function type_ignored_param_one(ign,fmt,fmtty)
     {var match=type_format_gen(fmt,fmtty),fmtty$0=match[2],fmt$0=match[1];
      return [0,[23,ign,fmt$0],fmtty$0]}
    function type_format_gen(fmt,fmtty)
     {if(typeof fmt === "number")
       return [0,0,fmtty];
      else
       switch(fmt[0])
        {case 0:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest=fmtty[1],
             fmt_rest=fmt[1],
             match=type_format_gen(fmt_rest,fmtty_rest),
             fmtty$0=match[2],
             fmt$0=match[1];
            return [0,[0,fmt$0],fmtty$0]}
          break;
         case 1:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest$0=fmtty[1],
             fmt_rest$0=fmt[1],
             match$0=type_format_gen(fmt_rest$0,fmtty_rest$0),
             fmtty$1=match$0[2],
             fmt$1=match$0[1];
            return [0,[1,fmt$1],fmtty$1]}
          break;
         case 2:
          var
           fmt_rest$1=fmt[2],
           pad=fmt[1],
           _qs_=type_padding(pad,fmtty),
           _qt_=_qs_[2],
           _qu_=_qs_[1];
          if(typeof _qt_ !== "number" && 1 === _qt_[0])
           {var
             fmtty_rest$1=_qt_[1],
             match$1=type_format_gen(fmt_rest$1,fmtty_rest$1),
             fmtty$2=match$1[2],
             fmt$2=match$1[1];
            return [0,[2,_qu_,fmt$2],fmtty$2]}
          throw Type_mismatch;
         case 3:
          var
           fmt_rest$2=fmt[2],
           pad$0=fmt[1],
           _qv_=type_padding(pad$0,fmtty),
           _qw_=_qv_[2],
           _qx_=_qv_[1];
          if(typeof _qw_ !== "number" && 1 === _qw_[0])
           {var
             fmtty_rest$2=_qw_[1],
             match$2=type_format_gen(fmt_rest$2,fmtty_rest$2),
             fmtty$3=match$2[2],
             fmt$3=match$2[1];
            return [0,[3,_qx_,fmt$3],fmtty$3]}
          throw Type_mismatch;
         case 4:
          var
           fmt_rest$3=fmt[4],
           prec=fmt[3],
           pad$1=fmt[2],
           iconv=fmt[1],
           _qy_=type_padprec(pad$1,prec,fmtty),
           _qz_=_qy_[3],
           _qA_=_qy_[2],
           _qB_=_qy_[1];
          if(typeof _qz_ !== "number" && 2 === _qz_[0])
           {var
             fmtty_rest$3=_qz_[1],
             match$3=type_format_gen(fmt_rest$3,fmtty_rest$3),
             fmtty$4=match$3[2],
             fmt$4=match$3[1];
            return [0,[4,iconv,_qB_,_qA_,fmt$4],fmtty$4]}
          throw Type_mismatch;
         case 5:
          var
           fmt_rest$4=fmt[4],
           prec$0=fmt[3],
           pad$2=fmt[2],
           iconv$0=fmt[1],
           _qC_=type_padprec(pad$2,prec$0,fmtty),
           _qD_=_qC_[3],
           _qE_=_qC_[2],
           _qF_=_qC_[1];
          if(typeof _qD_ !== "number" && 3 === _qD_[0])
           {var
             fmtty_rest$4=_qD_[1],
             match$4=type_format_gen(fmt_rest$4,fmtty_rest$4),
             fmtty$5=match$4[2],
             fmt$5=match$4[1];
            return [0,[5,iconv$0,_qF_,_qE_,fmt$5],fmtty$5]}
          throw Type_mismatch;
         case 6:
          var
           fmt_rest$5=fmt[4],
           prec$1=fmt[3],
           pad$3=fmt[2],
           iconv$1=fmt[1],
           _qG_=type_padprec(pad$3,prec$1,fmtty),
           _qH_=_qG_[3],
           _qI_=_qG_[2],
           _qJ_=_qG_[1];
          if(typeof _qH_ !== "number" && 4 === _qH_[0])
           {var
             fmtty_rest$5=_qH_[1],
             match$5=type_format_gen(fmt_rest$5,fmtty_rest$5),
             fmtty$6=match$5[2],
             fmt$6=match$5[1];
            return [0,[6,iconv$1,_qJ_,_qI_,fmt$6],fmtty$6]}
          throw Type_mismatch;
         case 7:
          var
           fmt_rest$6=fmt[4],
           prec$2=fmt[3],
           pad$4=fmt[2],
           iconv$2=fmt[1],
           _qK_=type_padprec(pad$4,prec$2,fmtty),
           _qL_=_qK_[3],
           _qM_=_qK_[2],
           _qN_=_qK_[1];
          if(typeof _qL_ !== "number" && 5 === _qL_[0])
           {var
             fmtty_rest$6=_qL_[1],
             match$6=type_format_gen(fmt_rest$6,fmtty_rest$6),
             fmtty$7=match$6[2],
             fmt$7=match$6[1];
            return [0,[7,iconv$2,_qN_,_qM_,fmt$7],fmtty$7]}
          throw Type_mismatch;
         case 8:
          var
           fmt_rest$7=fmt[4],
           prec$3=fmt[3],
           pad$5=fmt[2],
           fconv=fmt[1],
           _qO_=type_padprec(pad$5,prec$3,fmtty),
           _qP_=_qO_[3],
           _qQ_=_qO_[2],
           _qR_=_qO_[1];
          if(typeof _qP_ !== "number" && 6 === _qP_[0])
           {var
             fmtty_rest$7=_qP_[1],
             match$7=type_format_gen(fmt_rest$7,fmtty_rest$7),
             fmtty$8=match$7[2],
             fmt$8=match$7[1];
            return [0,[8,fconv,_qR_,_qQ_,fmt$8],fmtty$8]}
          throw Type_mismatch;
         case 9:
          var
           fmt_rest$8=fmt[2],
           pad$6=fmt[1],
           _qS_=type_padding(pad$6,fmtty),
           _qT_=_qS_[2],
           _qU_=_qS_[1];
          if(typeof _qT_ !== "number" && 7 === _qT_[0])
           {var
             fmtty_rest$8=_qT_[1],
             match$8=type_format_gen(fmt_rest$8,fmtty_rest$8),
             fmtty$9=match$8[2],
             fmt$9=match$8[1];
            return [0,[9,_qU_,fmt$9],fmtty$9]}
          throw Type_mismatch;
         case 10:
          var
           fmt_rest$9=fmt[1],
           match$9=type_format_gen(fmt_rest$9,fmtty),
           fmtty$10=match$9[2],
           fmt$10=match$9[1];
          return [0,[10,fmt$10],fmtty$10];
         case 11:
          var
           fmt_rest$10=fmt[2],
           str=fmt[1],
           match$10=type_format_gen(fmt_rest$10,fmtty),
           fmtty$11=match$10[2],
           fmt$11=match$10[1];
          return [0,[11,str,fmt$11],fmtty$11];
         case 12:
          var
           fmt_rest$11=fmt[2],
           chr=fmt[1],
           match$11=type_format_gen(fmt_rest$11,fmtty),
           fmtty$12=match$11[2],
           fmt$12=match$11[1];
          return [0,[12,chr,fmt$12],fmtty$12];
         case 13:
          if(typeof fmtty !== "number" && 8 === fmtty[0])
           {var
             fmtty_rest$9=fmtty[2],
             sub_fmtty=fmtty[1],
             fmt_rest$12=fmt[3],
             sub_fmtty$0=fmt[2],
             pad_opt=fmt[1];
            if(caml_notequal([0,sub_fmtty$0],[0,sub_fmtty]))
             throw Type_mismatch;
            var
             match$12=type_format_gen(fmt_rest$12,fmtty_rest$9),
             fmtty$13=match$12[2],
             fmt$13=match$12[1];
            return [0,[13,pad_opt,sub_fmtty,fmt$13],fmtty$13]}
          break;
         case 14:
          if(typeof fmtty !== "number" && 9 === fmtty[0])
           {var
             fmtty_rest$10=fmtty[3],
             sub_fmtty1=fmtty[1],
             fmt_rest$13=fmt[3],
             sub_fmtty$1=fmt[2],
             pad_opt$0=fmt[1],
             _qV_=[0,erase_rel(sub_fmtty1)];
            if(caml_notequal([0,erase_rel(sub_fmtty$1)],_qV_))
             throw Type_mismatch;
            var
             match$13=type_format_gen(fmt_rest$13,erase_rel(fmtty_rest$10)),
             fmtty$14=match$13[2],
             fmt$14=match$13[1];
            return [0,[14,pad_opt$0,sub_fmtty1,fmt$14],fmtty$14]}
          break;
         case 15:
          if(typeof fmtty !== "number" && 10 === fmtty[0])
           {var
             fmtty_rest$11=fmtty[1],
             fmt_rest$14=fmt[1],
             match$14=type_format_gen(fmt_rest$14,fmtty_rest$11),
             fmtty$15=match$14[2],
             fmt$15=match$14[1];
            return [0,[15,fmt$15],fmtty$15]}
          break;
         case 16:
          if(typeof fmtty !== "number" && 11 === fmtty[0])
           {var
             fmtty_rest$12=fmtty[1],
             fmt_rest$15=fmt[1],
             match$15=type_format_gen(fmt_rest$15,fmtty_rest$12),
             fmtty$16=match$15[2],
             fmt$16=match$15[1];
            return [0,[16,fmt$16],fmtty$16]}
          break;
         case 17:
          var
           fmt_rest$16=fmt[2],
           formatting_lit=fmt[1],
           match$16=type_format_gen(fmt_rest$16,fmtty),
           fmtty$17=match$16[2],
           fmt$17=match$16[1];
          return [0,[17,formatting_lit,fmt$17],fmtty$17];
         case 18:
          var fmt_rest$17=fmt[2],formatting_gen=fmt[1];
          if(0 === formatting_gen[0])
           {var
             match$20=formatting_gen[1],
             str$0=match$20[2],
             fmt1=match$20[1],
             match$21=type_format_gen(fmt1,fmtty),
             fmtty2=match$21[2],
             fmt2=match$21[1],
             match$22=type_format_gen(fmt_rest$17,fmtty2),
             fmtty3=match$22[2],
             fmt3=match$22[1];
            return [0,[18,[0,[0,fmt2,str$0]],fmt3],fmtty3]}
          var
           match$23=formatting_gen[1],
           str$1=match$23[2],
           fmt1$0=match$23[1],
           match$24=type_format_gen(fmt1$0,fmtty),
           fmtty2$0=match$24[2],
           fmt2$0=match$24[1],
           match$25=type_format_gen(fmt_rest$17,fmtty2$0),
           fmtty3$0=match$25[2],
           fmt3$0=match$25[1];
          return [0,[18,[1,[0,fmt2$0,str$1]],fmt3$0],fmtty3$0];
         case 19:
          if(typeof fmtty !== "number" && 13 === fmtty[0])
           {var
             fmtty_rest$13=fmtty[1],
             fmt_rest$18=fmt[1],
             match$17=type_format_gen(fmt_rest$18,fmtty_rest$13),
             fmtty$18=match$17[2],
             fmt$18=match$17[1];
            return [0,[19,fmt$18],fmtty$18]}
          break;
         case 20:
          if(typeof fmtty !== "number" && 1 === fmtty[0])
           {var
             fmtty_rest$14=fmtty[1],
             fmt_rest$19=fmt[3],
             char_set=fmt[2],
             width_opt=fmt[1],
             match$18=type_format_gen(fmt_rest$19,fmtty_rest$14),
             fmtty$19=match$18[2],
             fmt$19=match$18[1];
            return [0,[20,width_opt,char_set,fmt$19],fmtty$19]}
          break;
         case 21:
          if(typeof fmtty !== "number" && 2 === fmtty[0])
           {var
             fmtty_rest$15=fmtty[1],
             fmt_rest$20=fmt[2],
             counter=fmt[1],
             match$19=type_format_gen(fmt_rest$20,fmtty_rest$15),
             fmtty$20=match$19[2],
             fmt$20=match$19[1];
            return [0,[21,counter,fmt$20],fmtty$20]}
          break;
         case 23:
          var rest=fmt[2],ign=fmt[1];
          if(typeof ign === "number")
           switch(ign)
            {case 0:return type_ignored_param_one(ign,rest,fmtty);
             case 1:return type_ignored_param_one(ign,rest,fmtty);
             case 2:
              if(typeof fmtty !== "number" && 14 === fmtty[0])
               {var
                 fmtty_rest$16=fmtty[1],
                 match$26=type_format_gen(rest,fmtty_rest$16),
                 fmtty$21=match$26[2],
                 fmt$21=match$26[1];
                return [0,[23,2,fmt$21],fmtty$21]}
              throw Type_mismatch;
             default:return type_ignored_param_one(ign,rest,fmtty)}
          else
           switch(ign[0])
            {case 0:return type_ignored_param_one(ign,rest,fmtty);
             case 1:return type_ignored_param_one(ign,rest,fmtty);
             case 2:return type_ignored_param_one(ign,rest,fmtty);
             case 3:return type_ignored_param_one(ign,rest,fmtty);
             case 4:return type_ignored_param_one(ign,rest,fmtty);
             case 5:return type_ignored_param_one(ign,rest,fmtty);
             case 6:return type_ignored_param_one(ign,rest,fmtty);
             case 7:return type_ignored_param_one(ign,rest,fmtty);
             case 8:
              var sub_fmtty$2=ign[2],pad_opt$1=ign[1];
              return type_ignored_param_one
                      ([8,pad_opt$1,sub_fmtty$2],rest,fmtty);
             case 9:
              var
               sub_fmtty$3=ign[2],
               pad_opt$2=ign[1],
               _qW_=type_ignored_format_substitution(sub_fmtty$3,rest,fmtty),
               match$27=_qW_[2],
               fmtty$22=match$27[2],
               fmt$22=match$27[1],
               sub_fmtty$4=_qW_[1];
              return [0,[23,[9,pad_opt$2,sub_fmtty$4],fmt$22],fmtty$22];
             case 10:return type_ignored_param_one(ign,rest,fmtty);
             default:return type_ignored_param_one(ign,rest,fmtty)}
         }
      throw Type_mismatch}
    function type_ignored_format_substitution(sub_fmtty,fmt,match)
     {if(typeof sub_fmtty === "number")
       return [0,0,type_format_gen(fmt,match)];
      else
       switch(sub_fmtty[0])
        {case 0:
          if(typeof match !== "number" && 0 === match[0])
           {var
             fmtty_rest=match[1],
             sub_fmtty_rest=sub_fmtty[1],
             match$0=
              type_ignored_format_substitution(sub_fmtty_rest,fmt,fmtty_rest),
             fmt$0=match$0[2],
             sub_fmtty_rest$0=match$0[1];
            return [0,[0,sub_fmtty_rest$0],fmt$0]}
          break;
         case 1:
          if(typeof match !== "number" && 1 === match[0])
           {var
             fmtty_rest$0=match[1],
             sub_fmtty_rest$1=sub_fmtty[1],
             match$1=
              type_ignored_format_substitution
               (sub_fmtty_rest$1,fmt,fmtty_rest$0),
             fmt$1=match$1[2],
             sub_fmtty_rest$2=match$1[1];
            return [0,[1,sub_fmtty_rest$2],fmt$1]}
          break;
         case 2:
          if(typeof match !== "number" && 2 === match[0])
           {var
             fmtty_rest$1=match[1],
             sub_fmtty_rest$3=sub_fmtty[1],
             match$2=
              type_ignored_format_substitution
               (sub_fmtty_rest$3,fmt,fmtty_rest$1),
             fmt$2=match$2[2],
             sub_fmtty_rest$4=match$2[1];
            return [0,[2,sub_fmtty_rest$4],fmt$2]}
          break;
         case 3:
          if(typeof match !== "number" && 3 === match[0])
           {var
             fmtty_rest$2=match[1],
             sub_fmtty_rest$5=sub_fmtty[1],
             match$3=
              type_ignored_format_substitution
               (sub_fmtty_rest$5,fmt,fmtty_rest$2),
             fmt$3=match$3[2],
             sub_fmtty_rest$6=match$3[1];
            return [0,[3,sub_fmtty_rest$6],fmt$3]}
          break;
         case 4:
          if(typeof match !== "number" && 4 === match[0])
           {var
             fmtty_rest$3=match[1],
             sub_fmtty_rest$7=sub_fmtty[1],
             match$4=
              type_ignored_format_substitution
               (sub_fmtty_rest$7,fmt,fmtty_rest$3),
             fmt$4=match$4[2],
             sub_fmtty_rest$8=match$4[1];
            return [0,[4,sub_fmtty_rest$8],fmt$4]}
          break;
         case 5:
          if(typeof match !== "number" && 5 === match[0])
           {var
             fmtty_rest$4=match[1],
             sub_fmtty_rest$9=sub_fmtty[1],
             match$5=
              type_ignored_format_substitution
               (sub_fmtty_rest$9,fmt,fmtty_rest$4),
             fmt$5=match$5[2],
             sub_fmtty_rest$10=match$5[1];
            return [0,[5,sub_fmtty_rest$10],fmt$5]}
          break;
         case 6:
          if(typeof match !== "number" && 6 === match[0])
           {var
             fmtty_rest$5=match[1],
             sub_fmtty_rest$11=sub_fmtty[1],
             match$6=
              type_ignored_format_substitution
               (sub_fmtty_rest$11,fmt,fmtty_rest$5),
             fmt$6=match$6[2],
             sub_fmtty_rest$12=match$6[1];
            return [0,[6,sub_fmtty_rest$12],fmt$6]}
          break;
         case 7:
          if(typeof match !== "number" && 7 === match[0])
           {var
             fmtty_rest$6=match[1],
             sub_fmtty_rest$13=sub_fmtty[1],
             match$7=
              type_ignored_format_substitution
               (sub_fmtty_rest$13,fmt,fmtty_rest$6),
             fmt$7=match$7[2],
             sub_fmtty_rest$14=match$7[1];
            return [0,[7,sub_fmtty_rest$14],fmt$7]}
          break;
         case 8:
          if(typeof match !== "number" && 8 === match[0])
           {var
             fmtty_rest$7=match[2],
             sub2_fmtty=match[1],
             sub_fmtty_rest$15=sub_fmtty[2],
             sub2_fmtty$0=sub_fmtty[1];
            if(caml_notequal([0,sub2_fmtty$0],[0,sub2_fmtty]))
             throw Type_mismatch;
            var
             match$8=
              type_ignored_format_substitution
               (sub_fmtty_rest$15,fmt,fmtty_rest$7),
             fmt$8=match$8[2],
             sub_fmtty_rest$16=match$8[1];
            return [0,[8,sub2_fmtty,sub_fmtty_rest$16],fmt$8]}
          break;
         case 9:
          if(typeof match !== "number" && 9 === match[0])
           {var
             fmtty_rest$8=match[3],
             sub2_fmtty$1=match[2],
             sub1_fmtty=match[1],
             sub_fmtty_rest$17=sub_fmtty[3],
             sub2_fmtty$2=sub_fmtty[2],
             sub1_fmtty$0=sub_fmtty[1],
             _qq_=[0,erase_rel(sub1_fmtty)];
            if(caml_notequal([0,erase_rel(sub1_fmtty$0)],_qq_))
             throw Type_mismatch;
            var _qr_=[0,erase_rel(sub2_fmtty$1)];
            if(caml_notequal([0,erase_rel(sub2_fmtty$2)],_qr_))
             throw Type_mismatch;
            var
             sub_fmtty$0=trans(symm(sub1_fmtty),sub2_fmtty$1),
             match$9=fmtty_rel_det(sub_fmtty$0),
             f4=match$9[4],
             f2=match$9[2];
            caml_call1(f2,0);
            caml_call1(f4,0);
            var
             match$10=
              type_ignored_format_substitution
               (erase_rel(sub_fmtty_rest$17),fmt,fmtty_rest$8),
             fmt$9=match$10[2],
             sub_fmtty_rest$18=match$10[1];
            return [0,
                    [9,sub1_fmtty,sub2_fmtty$1,symm(sub_fmtty_rest$18)],
                    fmt$9]}
          break;
         case 10:
          if(typeof match !== "number" && 10 === match[0])
           {var
             fmtty_rest$9=match[1],
             sub_fmtty_rest$19=sub_fmtty[1],
             match$11=
              type_ignored_format_substitution
               (sub_fmtty_rest$19,fmt,fmtty_rest$9),
             fmt$10=match$11[2],
             sub_fmtty_rest$20=match$11[1];
            return [0,[10,sub_fmtty_rest$20],fmt$10]}
          break;
         case 11:
          if(typeof match !== "number" && 11 === match[0])
           {var
             fmtty_rest$10=match[1],
             sub_fmtty_rest$21=sub_fmtty[1],
             match$12=
              type_ignored_format_substitution
               (sub_fmtty_rest$21,fmt,fmtty_rest$10),
             fmt$11=match$12[2],
             sub_fmtty_rest$22=match$12[1];
            return [0,[11,sub_fmtty_rest$22],fmt$11]}
          break;
         case 13:
          if(typeof match !== "number" && 13 === match[0])
           {var
             fmtty_rest$11=match[1],
             sub_fmtty_rest$23=sub_fmtty[1],
             match$13=
              type_ignored_format_substitution
               (sub_fmtty_rest$23,fmt,fmtty_rest$11),
             fmt$12=match$13[2],
             sub_fmtty_rest$24=match$13[1];
            return [0,[13,sub_fmtty_rest$24],fmt$12]}
          break;
         case 14:
          if(typeof match !== "number" && 14 === match[0])
           {var
             fmtty_rest$12=match[1],
             sub_fmtty_rest$25=sub_fmtty[1],
             match$14=
              type_ignored_format_substitution
               (sub_fmtty_rest$25,fmt,fmtty_rest$12),
             fmt$13=match$14[2],
             sub_fmtty_rest$26=match$14[1];
            return [0,[14,sub_fmtty_rest$26],fmt$13]}
          break
         }
      throw Type_mismatch}
    function recast(fmt,fmtty){return type_format(fmt,erase_rel(symm(fmtty)))}
    function fix_padding(padty,width,str)
     {var
       len=caml_ml_string_length(str),
       padty$0=0 <= width?padty:0,
       width$0=abs(width);
      if(width$0 <= len)return str;
      var _qp_=2 === padty$0?48:32,res=make(width$0,_qp_);
      switch(padty$0)
       {case 0:blit$0(str,0,res,0,len);break;
        case 1:blit$0(str,0,res,width$0 - len | 0,len);break;
        default:
         if(0 < len)
          {if(43 === caml_string_get(str,0))
            var switch$1=1;
           else
            if(45 === caml_string_get(str,0))
             var switch$1=1;
            else
             if(32 === caml_string_get(str,0))
              var switch$1=1;
             else
              var switch$0=0,switch$1=0;
           if(switch$1)
            {caml_bytes_set(res,0,caml_string_get(str,0));
             blit$0(str,1,res,(width$0 - len | 0) + 1 | 0,len - 1 | 0);
             var switch$0=1}}
         else
          var switch$0=0;
         if(! switch$0)
          {if(1 < len)
            if(48 === caml_string_get(str,0))
             {if(120 === caml_string_get(str,1))
               var switch$3=1;
              else
               if(88 === caml_string_get(str,1))
                var switch$3=1;
               else
                var switch$2=0,switch$3=0;
              if(switch$3)
               {caml_bytes_set(res,1,caml_string_get(str,1));
                blit$0(str,2,res,(width$0 - len | 0) + 2 | 0,len - 2 | 0);
                var switch$2=1}}
            else
             var switch$2=0;
           else
            var switch$2=0;
           if(! switch$2)blit$0(str,0,res,width$0 - len | 0,len)}}
      return res}
    function fix_int_precision(prec,str)
     {var
       prec$0=abs(prec),
       len=caml_ml_string_length(str),
       c=caml_string_get(str,0);
      if(58 <= c)
       var switch$0=71 <= c?5 < (c - 97 | 0) >>> 0?1:0:65 <= c?0:1;
      else
       {if(32 === c)
         var switch$1=1;
        else
         if(43 <= c)
          {var switcher=c - 43 | 0;
           switch(switcher)
            {case 5:
              if(len < (prec$0 + 2 | 0))
               if(1 < len)
                {var
                  switch$2=
                   120 === caml_string_get(str,1)
                    ?0
                    :88 === caml_string_get(str,1)?0:1;
                 if(! switch$2)
                  {var res$1=make(prec$0 + 2 | 0,48);
                   caml_bytes_set(res$1,1,caml_string_get(str,1));
                   blit$0(str,2,res$1,(prec$0 - len | 0) + 4 | 0,len - 2 | 0);
                   return res$1}}
              var switch$0=0,switch$1=0;
              break;
             case 0:
             case 2:var switch$1=1;break;
             case 1:
             case 3:
             case 4:var switch$0=1,switch$1=0;break;
             default:var switch$0=0,switch$1=0}}
         else
          var switch$0=1,switch$1=0;
        if(switch$1)
         {if(len < (prec$0 + 1 | 0))
           {var res$0=make(prec$0 + 1 | 0,48);
            caml_bytes_set(res$0,0,c);
            blit$0(str,1,res$0,(prec$0 - len | 0) + 2 | 0,len - 1 | 0);
            return res$0}
          var switch$0=1}}
      if(! switch$0)
       if(len < prec$0)
        {var res=make(prec$0,48);
         blit$0(str,0,res,prec$0 - len | 0,len);
         return res}
      return str}
    function string_to_caml_string(str)
     {var
       str$0=escaped$1(str),
       l=caml_ml_string_length(str$0),
       res=make(l + 2 | 0,34);
      caml_blit_string(str$0,0,res,1,l);
      return res}
    function convert_int(iconv,n)
     {switch(iconv)
       {case 0:var _qo_=cst_d$2;break;
        case 1:var _qo_=cst_d$3;break;
        case 2:var _qo_=cst_d$4;break;
        case 3:var _qo_=cst_i$0;break;
        case 4:var _qo_=cst_i$1;break;
        case 5:var _qo_=cst_i$2;break;
        case 6:var _qo_=cst_x;break;
        case 7:var _qo_=cst_x$0;break;
        case 8:var _qo_=cst_X$0;break;
        case 9:var _qo_=cst_X$1;break;
        case 10:var _qo_=cst_o;break;
        case 11:var _qo_=cst_o$0;break;
        default:var _qo_=cst_u}
      return caml_format_int(_qo_,n)}
    function convert_int32(iconv,n)
     {switch(iconv)
       {case 0:var _qn_=cst_ld;break;
        case 1:var _qn_=cst_ld$0;break;
        case 2:var _qn_=cst_ld$1;break;
        case 3:var _qn_=cst_li$0;break;
        case 4:var _qn_=cst_li$1;break;
        case 5:var _qn_=cst_li$2;break;
        case 6:var _qn_=cst_lx;break;
        case 7:var _qn_=cst_lx$0;break;
        case 8:var _qn_=cst_lX;break;
        case 9:var _qn_=cst_lX$0;break;
        case 10:var _qn_=cst_lo;break;
        case 11:var _qn_=cst_lo$0;break;
        default:var _qn_=cst_lu}
      return caml_format_int(_qn_,n)}
    function convert_nativeint(iconv,n)
     {switch(iconv)
       {case 0:var _qm_=cst_nd;break;
        case 1:var _qm_=cst_nd$0;break;
        case 2:var _qm_=cst_nd$1;break;
        case 3:var _qm_=cst_ni$0;break;
        case 4:var _qm_=cst_ni$1;break;
        case 5:var _qm_=cst_ni$2;break;
        case 6:var _qm_=cst_nx;break;
        case 7:var _qm_=cst_nx$0;break;
        case 8:var _qm_=cst_nX;break;
        case 9:var _qm_=cst_nX$0;break;
        case 10:var _qm_=cst_no;break;
        case 11:var _qm_=cst_no$0;break;
        default:var _qm_=cst_nu}
      return caml_format_int(_qm_,n)}
    function convert_int64(iconv,n)
     {switch(iconv)
       {case 0:var _ql_=cst_Ld;break;
        case 1:var _ql_=cst_Ld$0;break;
        case 2:var _ql_=cst_Ld$1;break;
        case 3:var _ql_=cst_Li$0;break;
        case 4:var _ql_=cst_Li$1;break;
        case 5:var _ql_=cst_Li$2;break;
        case 6:var _ql_=cst_Lx;break;
        case 7:var _ql_=cst_Lx$0;break;
        case 8:var _ql_=cst_LX;break;
        case 9:var _ql_=cst_LX$0;break;
        case 10:var _ql_=cst_Lo;break;
        case 11:var _ql_=cst_Lo$0;break;
        default:var _ql_=cst_Lu}
      return caml_int64_format(_ql_,n)}
    function convert_float(fconv,prec$0,x)
     {if(16 <= fconv)
       {if(17 <= fconv)
         switch(fconv - 17 | 0)
          {case 2:var switch$0=0;break;
           case 0:
           case 3:var sign=43,switch$0=1;break;
           default:var sign=32,switch$0=1}
        else
         var switch$0=0;
        if(! switch$0)var sign=45;
        var str=runtime.caml_hexstring_of_float(x,prec$0,sign);
        return 19 <= fconv?uppercase_ascii$1(str):str}
      if(15 === fconv)
       var _qi_=cst_12g$0;
      else
       {var prec=abs(prec$0),symb=char_of_fconv(fconv),buf=buffer_create(16);
        buffer_add_char(buf,37);
        bprint_fconv_flag(buf,fconv);
        buffer_add_char(buf,46);
        buffer_add_string(buf,caml_new_string("" + prec));
        buffer_add_char(buf,symb);
        var _qi_=buffer_contents(buf)}
      var str$0=caml_format_float(_qi_,x);
      if(15 === fconv)
       {var
         len=caml_ml_string_length(str$0),
         match$0=runtime.caml_classify_float(x);
        if(3 === match$0)return x < 0.?cst_neg_infinity:cst_infinity;
        if(4 <= match$0)return cst_nan;
        var i=0;
        for(;;)
         {if(i === len)
           var _qk_=0;
          else
           {var
             match=caml_string_get(str$0,i),
             _qj_=match - 46 | 0,
             switch$1=
              23 < _qj_ >>> 0?55 === _qj_?1:0:21 < (_qj_ - 1 | 0) >>> 0?1:0;
            if(! switch$1){var i$0=i + 1 | 0,i=i$0;continue}
            var _qk_=1}
          return _qk_?str$0:symbol(str$0,cst$27)}}
      return str$0}
    function string_of_fmtty(fmtty)
     {var buf=buffer_create(16);
      bprint_fmtty(buf,fmtty);
      return buffer_contents(buf)}
    function make_int_padding_precision(k,o,acc,fmt,pad,match,trans,iconv)
     {if(typeof pad === "number")
       {if(typeof match === "number")
         return 0 === match
                 ?function(x)
                   {var str=caml_call2(trans,iconv,x);
                    return make_printf(k,o,[4,acc,str],fmt)}
                 :function(p,x)
                   {var str=fix_int_precision(p,caml_call2(trans,iconv,x));
                    return make_printf(k,o,[4,acc,str],fmt)};
        var p=match[1];
        return function(x)
         {var str=fix_int_precision(p,caml_call2(trans,iconv,x));
          return make_printf(k,o,[4,acc,str],fmt)}}
      else
       {if(0 === pad[0])
         {var _qf_=pad[2],_qg_=pad[1];
          if(typeof match === "number")
           return 0 === match
                   ?function(x)
                     {var str=fix_padding(_qg_,_qf_,caml_call2(trans,iconv,x));
                      return make_printf(k,o,[4,acc,str],fmt)}
                   :function(p,x)
                     {var
                       str=
                        fix_padding
                         (_qg_,_qf_,fix_int_precision(p,caml_call2(trans,iconv,x)));
                      return make_printf(k,o,[4,acc,str],fmt)};
          var p$0=match[1];
          return function(x)
           {var
             str=
              fix_padding
               (_qg_,_qf_,fix_int_precision(p$0,caml_call2(trans,iconv,x)));
            return make_printf(k,o,[4,acc,str],fmt)}}
        var _qh_=pad[1];
        if(typeof match === "number")
         return 0 === match
                 ?function(w,x)
                   {var str=fix_padding(_qh_,w,caml_call2(trans,iconv,x));
                    return make_printf(k,o,[4,acc,str],fmt)}
                 :function(w,p,x)
                   {var
                     str=
                      fix_padding
                       (_qh_,w,fix_int_precision(p,caml_call2(trans,iconv,x)));
                    return make_printf(k,o,[4,acc,str],fmt)};
        var p$1=match[1];
        return function(w,x)
         {var
           str=
            fix_padding
             (_qh_,w,fix_int_precision(p$1,caml_call2(trans,iconv,x)));
          return make_printf(k,o,[4,acc,str],fmt)}}}
    function make_padding(k,o,acc,fmt,pad,trans)
     {if(typeof pad === "number")
       return function(x)
        {var new_acc=[4,acc,caml_call1(trans,x)];
         return make_printf(k,o,new_acc,fmt)};
      else
       {if(0 === pad[0])
         {var width=pad[2],padty=pad[1];
          return function(x)
           {var new_acc=[4,acc,fix_padding(padty,width,caml_call1(trans,x))];
            return make_printf(k,o,new_acc,fmt)}}
        var padty$0=pad[1];
        return function(w,x)
         {var new_acc=[4,acc,fix_padding(padty$0,w,caml_call1(trans,x))];
          return make_printf(k,o,new_acc,fmt)}}}
    function make_printf$0(counter,k,o,acc,fmt)
     {var k$0=k,acc$0=acc,fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call2(k$0,o,acc$0);
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1];
           return function(c)
            {var new_acc=[5,acc$0,c];return make_printf(k$0,o,new_acc,rest)};
          case 1:
           var rest$0=fmt$0[1];
           return function(c)
            {var
              str=escaped(c),
              l=caml_ml_string_length(str),
              res=make(l + 2 | 0,39);
             caml_blit_string(str,0,res,1,l);
             var new_acc=[4,acc$0,res];
             return make_printf(k$0,o,new_acc,rest$0)};
          case 2:
           var rest$1=fmt$0[2],pad=fmt$0[1];
           return make_padding
                   (k$0,o,acc$0,rest$1,pad,function(str){return str});
          case 3:
           var rest$2=fmt$0[2],pad$0=fmt$0[1];
           return make_padding(k$0,o,acc$0,rest$2,pad$0,string_to_caml_string);
          case 4:
           var rest$3=fmt$0[4],prec=fmt$0[3],pad$1=fmt$0[2],iconv=fmt$0[1];
           return make_int_padding_precision
                   (k$0,o,acc$0,rest$3,pad$1,prec,convert_int,iconv);
          case 5:
           var
            rest$4=fmt$0[4],
            prec$0=fmt$0[3],
            pad$2=fmt$0[2],
            iconv$0=fmt$0[1];
           return make_int_padding_precision
                   (k$0,o,acc$0,rest$4,pad$2,prec$0,convert_int32,iconv$0);
          case 6:
           var
            rest$5=fmt$0[4],
            prec$1=fmt$0[3],
            pad$3=fmt$0[2],
            iconv$1=fmt$0[1];
           return make_int_padding_precision
                   (k$0,o,acc$0,rest$5,pad$3,prec$1,convert_nativeint,iconv$1);
          case 7:
           var
            rest$6=fmt$0[4],
            prec$2=fmt$0[3],
            pad$4=fmt$0[2],
            iconv$2=fmt$0[1];
           return make_int_padding_precision
                   (k$0,o,acc$0,rest$6,pad$4,prec$2,convert_int64,iconv$2);
          case 8:
           var rest$7=fmt$0[4],prec$3=fmt$0[3],pad$5=fmt$0[2],fconv=fmt$0[1];
           if(typeof pad$5 === "number")
            {if(typeof prec$3 === "number")
              return 0 === prec$3
                      ?function(x)
                        {var str=convert_float(fconv,default_float_precision,x);
                         return make_printf(k$0,o,[4,acc$0,str],rest$7)}
                      :function(p,x)
                        {var str=convert_float(fconv,p,x);
                         return make_printf(k$0,o,[4,acc$0,str],rest$7)};
             var p=prec$3[1];
             return function(x)
              {var str=convert_float(fconv,p,x);
               return make_printf(k$0,o,[4,acc$0,str],rest$7)}}
           else
            {if(0 === pad$5[0])
              {var _qc_=pad$5[2],_qd_=pad$5[1];
               if(typeof prec$3 === "number")
                return 0 === prec$3
                        ?function(x)
                          {var
                            str=convert_float(fconv,default_float_precision,x),
                            str$0=fix_padding(_qd_,_qc_,str);
                           return make_printf(k$0,o,[4,acc$0,str$0],rest$7)}
                        :function(p,x)
                          {var str=fix_padding(_qd_,_qc_,convert_float(fconv,p,x));
                           return make_printf(k$0,o,[4,acc$0,str],rest$7)};
               var p$0=prec$3[1];
               return function(x)
                {var str=fix_padding(_qd_,_qc_,convert_float(fconv,p$0,x));
                 return make_printf(k$0,o,[4,acc$0,str],rest$7)}}
             var _qe_=pad$5[1];
             if(typeof prec$3 === "number")
              return 0 === prec$3
                      ?function(w,x)
                        {var
                          str=convert_float(fconv,default_float_precision,x),
                          str$0=fix_padding(_qe_,w,str);
                         return make_printf(k$0,o,[4,acc$0,str$0],rest$7)}
                      :function(w,p,x)
                        {var str=fix_padding(_qe_,w,convert_float(fconv,p,x));
                         return make_printf(k$0,o,[4,acc$0,str],rest$7)};
             var p$1=prec$3[1];
             return function(w,x)
              {var str=fix_padding(_qe_,w,convert_float(fconv,p$1,x));
               return make_printf(k$0,o,[4,acc$0,str],rest$7)}}
          case 9:
           var rest$8=fmt$0[2],pad$6=fmt$0[1];
           return make_padding(k$0,o,acc$0,rest$8,pad$6,string_of_bool);
          case 10:
           var fmt$1=fmt$0[1],acc$1=[7,acc$0],acc$0=acc$1,fmt$0=fmt$1;
           continue;
          case 11:
           var
            fmt$2=fmt$0[2],
            str=fmt$0[1],
            acc$2=[2,acc$0,str],
            acc$0=acc$2,
            fmt$0=fmt$2;
           continue;
          case 12:
           var
            fmt$3=fmt$0[2],
            chr=fmt$0[1],
            acc$3=[3,acc$0,chr],
            acc$0=acc$3,
            fmt$0=fmt$3;
           continue;
          case 13:
           var
            rest$9=fmt$0[3],
            sub_fmtty=fmt$0[2],
            ty=string_of_fmtty(sub_fmtty);
           return function(str)
            {return make_printf(k$0,o,[4,acc$0,ty],rest$9)};
          case 14:
           var rest$10=fmt$0[3],fmtty=fmt$0[2];
           return function(param)
            {var fmt=param[1];
             return make_printf
                     (k$0,o,acc$0,concat_fmt(recast(fmt,fmtty),rest$10))};
          case 15:
           var rest$11=fmt$0[1];
           return function(f,x)
            {return make_printf
                     (k$0,
                      o,
                      [6,acc$0,function(o){return caml_call2(f,o,x)}],
                      rest$11)};
          case 16:
           var rest$12=fmt$0[1];
           return function(f){return make_printf(k$0,o,[6,acc$0,f],rest$12)};
          case 17:
           var
            fmt$4=fmt$0[2],
            fmting_lit=fmt$0[1],
            acc$4=[0,acc$0,fmting_lit],
            acc$0=acc$4,
            fmt$0=fmt$4;
           continue;
          case 18:
           var _qa_=fmt$0[1];
           if(0 === _qa_[0])
            {var
              rest$13=fmt$0[2],
              match=_qa_[1],
              fmt$5=match[1],
              k$3=
               function(acc,k,rest)
                {function k$0(koc,kacc)
                  {return make_printf(k,koc,[1,acc,[0,kacc]],rest)}
                 return k$0},
              k$1=k$3(acc$0,k$0,rest$13),
              k$0=k$1,
              acc$0=0,
              fmt$0=fmt$5;
             continue}
           var
            rest$14=fmt$0[2],
            match$0=_qa_[1],
            fmt$6=match$0[1],
            k$4=
             function(acc,k,rest)
              {function k$0(koc,kacc)
                {return make_printf(k,koc,[1,acc,[1,kacc]],rest)}
               return k$0},
            k$2=k$4(acc$0,k$0,rest$14),
            k$0=k$2,
            acc$0=0,
            fmt$0=fmt$6;
           continue;
          case 19:throw [0,Assert_failure,_ao_];
          case 20:
           var rest$15=fmt$0[3],new_acc=[8,acc$0,cst_Printf_bad_conversion];
           return function(param){return make_printf(k$0,o,new_acc,rest$15)};
          case 21:
           var rest$16=fmt$0[2];
           return function(n)
            {var new_acc=[4,acc$0,caml_format_int(cst_u$0,n)];
             return make_printf(k$0,o,new_acc,rest$16)};
          case 22:
           var rest$17=fmt$0[1];
           return function(c)
            {var new_acc=[5,acc$0,c];
             return make_printf(k$0,o,new_acc,rest$17)};
          case 23:
           var rest$18=fmt$0[2],ign=fmt$0[1];
           if(counter < 50)
            {var counter$1=counter + 1 | 0;
             return make_ignored_param$0(counter$1,k$0,o,acc$0,ign,rest$18)}
           return caml_trampoline_return
                   (make_ignored_param$0,[0,k$0,o,acc$0,ign,rest$18]);
          default:
           var
            rest$19=fmt$0[3],
            f=fmt$0[2],
            arity=fmt$0[1],
            _qb_=caml_call1(f,0);
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return make_custom$0(counter$0,k$0,o,acc$0,rest$19,arity,_qb_)}
           return caml_trampoline_return
                   (make_custom$0,[0,k$0,o,acc$0,rest$19,arity,_qb_])}}
    function make_ignored_param$0(counter,k,o,acc,ign,fmt)
     {if(typeof ign === "number")
       switch(ign)
        {case 0:
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return make_invalid_arg(counter$0,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 1:
          if(counter < 50)
           {var counter$1=counter + 1 | 0;
            return make_invalid_arg(counter$1,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 2:throw [0,Assert_failure,_ap_];
         default:
          if(counter < 50)
           {var counter$2=counter + 1 | 0;
            return make_invalid_arg(counter$2,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt])}
      else
       switch(ign[0])
        {case 0:
          if(counter < 50)
           {var counter$3=counter + 1 | 0;
            return make_invalid_arg(counter$3,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 1:
          if(counter < 50)
           {var counter$4=counter + 1 | 0;
            return make_invalid_arg(counter$4,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 2:
          if(counter < 50)
           {var counter$5=counter + 1 | 0;
            return make_invalid_arg(counter$5,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 3:
          if(counter < 50)
           {var counter$6=counter + 1 | 0;
            return make_invalid_arg(counter$6,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 4:
          if(counter < 50)
           {var counter$7=counter + 1 | 0;
            return make_invalid_arg(counter$7,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 5:
          if(counter < 50)
           {var counter$8=counter + 1 | 0;
            return make_invalid_arg(counter$8,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 6:
          if(counter < 50)
           {var counter$9=counter + 1 | 0;
            return make_invalid_arg(counter$9,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 7:
          if(counter < 50)
           {var counter$10=counter + 1 | 0;
            return make_invalid_arg(counter$10,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 8:
          if(counter < 50)
           {var counter$11=counter + 1 | 0;
            return make_invalid_arg(counter$11,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 9:
          var fmtty=ign[2];
          if(counter < 50)
           {var counter$14=counter + 1 | 0;
            return make_from_fmtty$0(counter$14,k,o,acc,fmtty,fmt)}
          return caml_trampoline_return
                  (make_from_fmtty$0,[0,k,o,acc,fmtty,fmt]);
         case 10:
          if(counter < 50)
           {var counter$12=counter + 1 | 0;
            return make_invalid_arg(counter$12,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         default:
          if(counter < 50)
           {var counter$13=counter + 1 | 0;
            return make_invalid_arg(counter$13,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt])}}
    function make_from_fmtty$0(counter,k,o,acc,fmtty,fmt)
     {if(typeof fmtty === "number")
       {if(counter < 50)
         {var counter$0=counter + 1 | 0;
          return make_invalid_arg(counter$0,k,o,acc,fmt)}
        return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt])}
      else
       switch(fmtty[0])
        {case 0:
          var rest=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest,fmt)};
         case 1:
          var rest$0=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$0,fmt)};
         case 2:
          var rest$1=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$1,fmt)};
         case 3:
          var rest$2=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$2,fmt)};
         case 4:
          var rest$3=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$3,fmt)};
         case 5:
          var rest$4=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$4,fmt)};
         case 6:
          var rest$5=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$5,fmt)};
         case 7:
          var rest$6=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$6,fmt)};
         case 8:
          var rest$7=fmtty[2];
          return function(param){return make_from_fmtty(k,o,acc,rest$7,fmt)};
         case 9:
          var
           rest$8=fmtty[3],
           ty2=fmtty[2],
           ty1=fmtty[1],
           ty=trans(symm(ty1),ty2);
          return function(param)
           {return make_from_fmtty(k,o,acc,concat_fmtty(ty,rest$8),fmt)};
         case 10:
          var rest$9=fmtty[1];
          return function(param,_p$_)
           {return make_from_fmtty(k,o,acc,rest$9,fmt)};
         case 11:
          var rest$10=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$10,fmt)};
         case 12:
          var rest$11=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$11,fmt)};
         case 13:throw [0,Assert_failure,_aq_];
         default:throw [0,Assert_failure,_ar_]}}
    function make_invalid_arg(counter,k,o,acc,fmt)
     {var _p__=[8,acc,cst_Printf_bad_conversion$0];
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_printf$0(counter$0,k,o,_p__,fmt)}
      return caml_trampoline_return(make_printf$0,[0,k,o,_p__,fmt])}
    function make_custom$0(counter,k,o,acc,rest,arity,f)
     {if(arity)
       {var arity$0=arity[1];
        return function(x)
         {return make_custom(k,o,acc,rest,arity$0,caml_call1(f,x))}}
      var _p9_=[4,acc,f];
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_printf$0(counter$0,k,o,_p9_,rest)}
      return caml_trampoline_return(make_printf$0,[0,k,o,_p9_,rest])}
    function make_printf(k,o,acc,fmt)
     {return caml_trampoline(make_printf$0(0,k,o,acc,fmt))}
    function make_ignored_param(k,o,acc,ign,fmt)
     {return caml_trampoline(make_ignored_param$0(0,k,o,acc,ign,fmt))}
    function make_from_fmtty(k,o,acc,fmtty,fmt)
     {return caml_trampoline(make_from_fmtty$0(0,k,o,acc,fmtty,fmt))}
    function make_custom(k,o,acc,rest,arity,f)
     {return caml_trampoline(make_custom$0(0,k,o,acc,rest,arity,f))}
    function fn_of_padding_precision(k,o,fmt,pad,prec)
     {if(typeof pad === "number")
       {if(typeof prec === "number")
         {if(0 === prec)
           {var _pF_=make_iprintf(k,o,fmt);return function(_pX_){return _pF_}}
          var _pG_=make_iprintf(k,o,fmt),_pH_=function(_pW_){return _pG_};
          return function(_pV_){return _pH_}}
        var _pI_=make_iprintf(k,o,fmt);
        return function(_pU_){return _pI_}}
      else
       {if(0 === pad[0])
         {if(typeof prec === "number")
           {if(0 === prec)
             {var _pJ_=make_iprintf(k,o,fmt);
              return function(_p8_){return _pJ_}}
            var _pK_=make_iprintf(k,o,fmt),_pL_=function(_p7_){return _pK_};
            return function(_p6_){return _pL_}}
          var _pM_=make_iprintf(k,o,fmt);
          return function(_p5_){return _pM_}}
        if(typeof prec === "number")
         {if(0 === prec)
           {var _pN_=make_iprintf(k,o,fmt),_pO_=function(_p4_){return _pN_};
            return function(_p3_){return _pO_}}
          var
           _pP_=make_iprintf(k,o,fmt),
           _pQ_=function(_p2_){return _pP_},
           _pR_=function(_p1_){return _pQ_};
          return function(_p0_){return _pR_}}
        var _pS_=make_iprintf(k,o,fmt),_pT_=function(_pZ_){return _pS_};
        return function(_pY_){return _pT_}}}
    function make_iprintf$0(counter,k,o,fmt)
     {var k$0=k,fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k$0,o);
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1],_oW_=make_iprintf(k$0,o,rest);
           return function(_pE_){return _oW_};
          case 1:
           var rest$0=fmt$0[1],_oX_=make_iprintf(k$0,o,rest$0);
           return function(_pD_){return _oX_};
          case 2:
           var _oY_=fmt$0[1];
           if(typeof _oY_ === "number")
            {var rest$1=fmt$0[2],_oZ_=make_iprintf(k$0,o,rest$1);
             return function(_pz_){return _oZ_}}
           else
            {if(0 === _oY_[0])
              {var rest$2=fmt$0[2],_o0_=make_iprintf(k$0,o,rest$2);
               return function(_pC_){return _o0_}}
             var
              rest$3=fmt$0[2],
              _o1_=make_iprintf(k$0,o,rest$3),
              _o2_=function(_pB_){return _o1_};
             return function(_pA_){return _o2_}}
          case 3:
           var _o3_=fmt$0[1];
           if(typeof _o3_ === "number")
            {var rest$4=fmt$0[2],_o4_=make_iprintf(k$0,o,rest$4);
             return function(_pv_){return _o4_}}
           else
            {if(0 === _o3_[0])
              {var rest$5=fmt$0[2],_o5_=make_iprintf(k$0,o,rest$5);
               return function(_py_){return _o5_}}
             var
              rest$6=fmt$0[2],
              _o6_=make_iprintf(k$0,o,rest$6),
              _o7_=function(_px_){return _o6_};
             return function(_pw_){return _o7_}}
          case 4:
           var rest$7=fmt$0[4],prec=fmt$0[3],pad=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$7,pad,prec);
          case 5:
           var rest$8=fmt$0[4],prec$0=fmt$0[3],pad$0=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$8,pad$0,prec$0);
          case 6:
           var rest$9=fmt$0[4],prec$1=fmt$0[3],pad$1=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$9,pad$1,prec$1);
          case 7:
           var rest$10=fmt$0[4],prec$2=fmt$0[3],pad$2=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$10,pad$2,prec$2);
          case 8:
           var rest$11=fmt$0[4],prec$3=fmt$0[3],pad$3=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$11,pad$3,prec$3);
          case 9:
           var _o8_=fmt$0[1];
           if(typeof _o8_ === "number")
            {var rest$12=fmt$0[2],_o9_=make_iprintf(k$0,o,rest$12);
             return function(_pr_){return _o9_}}
           else
            {if(0 === _o8_[0])
              {var rest$13=fmt$0[2],_o__=make_iprintf(k$0,o,rest$13);
               return function(_pu_){return _o__}}
             var
              rest$14=fmt$0[2],
              _o$_=make_iprintf(k$0,o,rest$14),
              _pa_=function(_pt_){return _o$_};
             return function(_ps_){return _pa_}}
          case 10:var fmt$1=fmt$0[1],fmt$0=fmt$1;continue;
          case 11:var fmt$2=fmt$0[2],fmt$0=fmt$2;continue;
          case 12:var fmt$3=fmt$0[2],fmt$0=fmt$3;continue;
          case 13:
           var rest$15=fmt$0[3],_pb_=make_iprintf(k$0,o,rest$15);
           return function(_pq_){return _pb_};
          case 14:
           var rest$16=fmt$0[3],fmtty=fmt$0[2];
           return function(param)
            {var fmt=param[1];
             return make_iprintf(k$0,o,concat_fmt(recast(fmt,fmtty),rest$16))};
          case 15:
           var
            rest$17=fmt$0[1],
            _pc_=make_iprintf(k$0,o,rest$17),
            _pd_=function(_pp_){return _pc_};
           return function(_po_){return _pd_};
          case 16:
           var rest$18=fmt$0[1],_pe_=make_iprintf(k$0,o,rest$18);
           return function(_pn_){return _pe_};
          case 17:var fmt$4=fmt$0[2],fmt$0=fmt$4;continue;
          case 18:
           var _pf_=fmt$0[1];
           if(0 === _pf_[0])
            {var
              rest$19=fmt$0[2],
              match=_pf_[1],
              fmt$5=match[1],
              k$3=
               function(k,rest)
                {function k$0(koc){return make_iprintf(k,koc,rest)}return k$0},
              k$1=k$3(k$0,rest$19),
              k$0=k$1,
              fmt$0=fmt$5;
             continue}
           var
            rest$20=fmt$0[2],
            match$0=_pf_[1],
            fmt$6=match$0[1],
            k$4=
             function(k,rest)
              {function k$0(koc){return make_iprintf(k,koc,rest)}return k$0},
            k$2=k$4(k$0,rest$20),
            k$0=k$2,
            fmt$0=fmt$6;
           continue;
          case 19:throw [0,Assert_failure,_as_];
          case 20:
           var rest$21=fmt$0[3],_pg_=make_iprintf(k$0,o,rest$21);
           return function(_pm_){return _pg_};
          case 21:
           var rest$22=fmt$0[2],_ph_=make_iprintf(k$0,o,rest$22);
           return function(_pl_){return _ph_};
          case 22:
           var rest$23=fmt$0[1],_pi_=make_iprintf(k$0,o,rest$23);
           return function(_pk_){return _pi_};
          case 23:
           var rest$24=fmt$0[2],ign=fmt$0[1],_pj_=0;
           return make_ignored_param
                   (function(x,param){return caml_call1(k$0,x)},
                    o,
                    _pj_,
                    ign,
                    rest$24);
          default:
           var rest$25=fmt$0[3],arity=fmt$0[1];
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return fn_of_custom_arity$0(counter$0,k$0,o,rest$25,arity)}
           return caml_trampoline_return
                   (fn_of_custom_arity$0,[0,k$0,o,rest$25,arity])}}
    function fn_of_custom_arity$0(counter,k,o,fmt,param)
     {if(param)
       {var arity=param[1],_oU_=fn_of_custom_arity(k,o,fmt,arity);
        return function(_oV_){return _oU_}}
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_iprintf$0(counter$0,k,o,fmt)}
      return caml_trampoline_return(make_iprintf$0,[0,k,o,fmt])}
    function make_iprintf(k,o,fmt)
     {return caml_trampoline(make_iprintf$0(0,k,o,fmt))}
    function fn_of_custom_arity(k,o,fmt,param)
     {return caml_trampoline(fn_of_custom_arity$0(0,k,o,fmt,param))}
    function output_acc(o,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           output_acc(o,p);
           return output_string(o,s);
          case 1:
           var _oS_=acc$0[2],_oT_=acc$0[1];
           if(0 === _oS_[0])
            {var acc$1=_oS_[1];
             output_acc(o,_oT_);
             output_string(o,cst$28);
             var acc$0=acc$1;
             continue}
           var acc$2=_oS_[1];
           output_acc(o,_oT_);
           output_string(o,cst$29);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           output_acc(o,p$2);
           return caml_call1(f,o);
          case 7:var p$3=acc$0[1];output_acc(o,p$3);return caml_ml_flush(o);
          case 8:
           var msg=acc$0[2],p$4=acc$0[1];
           output_acc(o,p$4);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           output_acc(o,p$0);
           return output_string(o,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];
           output_acc(o,p$1);
           return caml_ml_output_char(o,c)}}
    function bufput_acc(b,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           bufput_acc(b,p);
           return add_string(b,s);
          case 1:
           var _oQ_=acc$0[2],_oR_=acc$0[1];
           if(0 === _oQ_[0])
            {var acc$1=_oQ_[1];
             bufput_acc(b,_oR_);
             add_string(b,cst$30);
             var acc$0=acc$1;
             continue}
           var acc$2=_oQ_[1];
           bufput_acc(b,_oR_);
           add_string(b,cst$31);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           bufput_acc(b,p$2);
           return caml_call1(f,b);
          case 7:var acc$3=acc$0[1],acc$0=acc$3;continue;
          case 8:
           var msg=acc$0[2],p$3=acc$0[1];
           bufput_acc(b,p$3);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           bufput_acc(b,p$0);
           return add_string(b,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];bufput_acc(b,p$1);return add_char(b,c)}}
    function strput_acc(b,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           strput_acc(b,p);
           return add_string(b,s);
          case 1:
           var _oO_=acc$0[2],_oP_=acc$0[1];
           if(0 === _oO_[0])
            {var acc$1=_oO_[1];
             strput_acc(b,_oP_);
             add_string(b,cst$32);
             var acc$0=acc$1;
             continue}
           var acc$2=_oO_[1];
           strput_acc(b,_oP_);
           add_string(b,cst$33);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           strput_acc(b,p$2);
           return add_string(b,caml_call1(f,0));
          case 7:var acc$3=acc$0[1],acc$0=acc$3;continue;
          case 8:
           var msg=acc$0[2],p$3=acc$0[1];
           strput_acc(b,p$3);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           strput_acc(b,p$0);
           return add_string(b,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];strput_acc(b,p$1);return add_char(b,c)}}
    function failwith_message(param)
     {var fmt=param[1],buf=create$1(256);
      function k(param,acc)
       {strput_acc(buf,acc);return failwith(contents(buf))}
      return make_printf(k,0,0,fmt)}
    function open_box_of_string(str)
     {if(caml_string_equal(str,cst$34))return _at_;
      var len=caml_ml_string_length(str);
      function invalid_box(param)
       {return caml_call1(failwith_message(_au_),str)}
      function parse_spaces(i)
       {var i$0=i;
        for(;;)
         {if(i$0 === len)return i$0;
          var match=caml_string_get(str,i$0);
          if(9 !== match)if(32 !== match)return i$0;
          var i$1=i$0 + 1 | 0,i$0=i$1;
          continue}}
      function parse_lword(i,j)
       {var j$0=j;
        for(;;)
         {if(j$0 === len)return j$0;
          var match=caml_string_get(str,j$0),switcher=match - 97 | 0;
          if(25 < switcher >>> 0)return j$0;
          var j$1=j$0 + 1 | 0,j$0=j$1;
          continue}}
      function parse_int(i,j)
       {var j$0=j;
        for(;;)
         {if(j$0 === len)return j$0;
          var
           match=caml_string_get(str,j$0),
           switch$0=48 <= match?58 <= match?0:1:45 === match?1:0;
          if(switch$0){var j$1=j$0 + 1 | 0,j$0=j$1;continue}
          return j$0}}
      var
       wstart=parse_spaces(0),
       wend=parse_lword(wstart,wstart),
       box_name=sub$0(str,wstart,wend - wstart | 0),
       nstart=parse_spaces(wend),
       nend=parse_int(nstart,nstart);
      if(nstart === nend)
       var indent=0;
      else
       try
        {var
          _oM_=caml_int_of_string(sub$0(str,nstart,nend - nstart | 0)),
          indent=_oM_}
       catch(_oN_)
        {_oN_ = caml_wrap_exception(_oN_);
         if(_oN_[1] !== Failure)throw _oN_;
         var indent=invalid_box(0)}
      var exp_end=parse_spaces(nend);
      if(exp_end !== len)invalid_box(0);
      if(caml_string_notequal(box_name,cst$35))
       if(caml_string_notequal(box_name,cst_b$0))
        if(caml_string_notequal(box_name,cst_h))
         if(caml_string_notequal(box_name,cst_hov))
          if(caml_string_notequal(box_name,cst_hv))
           if(caml_string_notequal(box_name,cst_v))
            var box_type=invalid_box(0),switch$0=1;
           else
            var box_type=1,switch$0=1;
          else
           var box_type=2,switch$0=1;
         else
          var box_type=3,switch$0=1;
        else
         var box_type=0,switch$0=1;
       else
        var switch$0=0;
      else
       var switch$0=0;
      if(! switch$0)var box_type=4;
      return [0,indent,box_type]}
    function make_padding_fmt_ebb(pad,fmt)
     {if(typeof pad === "number")
       return [0,0,fmt];
      else
       {if(0 === pad[0]){var w=pad[2],s=pad[1];return [0,[0,s,w],fmt]}
        var s$0=pad[1];
        return [0,[1,s$0],fmt]}}
    function make_padprec_fmt_ebb(pad,prec,fmt)
     {if(typeof prec === "number")
       var match=0 === prec?[0,0,fmt]:[0,1,fmt];
      else
       var p=prec[1],match=[0,[0,p],fmt];
      var prec$0=match[1];
      if(typeof pad === "number")
       return [0,0,prec$0,fmt];
      else
       {if(0 === pad[0]){var w=pad[2],s=pad[1];return [0,[0,s,w],prec$0,fmt]}
        var s$0=pad[1];
        return [0,[1,s$0],prec$0,fmt]}}
    function fmt_ebb_of_string(legacy_behavior,str)
     {if(legacy_behavior)
       var flag=legacy_behavior[1],legacy_behavior$0=flag;
      else
       var legacy_behavior$0=1;
      function invalid_format_message(str_ind,msg)
       {return caml_call3(failwith_message(_av_),str,str_ind,msg)}
      function unexpected_end_of_format(end_ind)
       {return invalid_format_message(end_ind,cst_unexpected_end_of_format)}
      function invalid_format_without(str_ind,c,s)
       {return caml_call4(failwith_message(_aw_),str,str_ind,c,s)}
      function expected_character(str_ind,expected,read)
       {return caml_call4(failwith_message(_ax_),str,str_ind,expected,read)}
      function add_literal(lit_start,str_ind,fmt)
       {var size=str_ind - lit_start | 0;
        return 0 === size
                ?[0,fmt]
                :1 === size
                  ?[0,[12,caml_string_get(str,lit_start),fmt]]
                  :[0,[11,sub$0(str,lit_start,size),fmt]]}
      function parse(lit_start,end_ind)
       {var str_ind=lit_start;
        for(;;)
         {if(str_ind === end_ind)return add_literal(lit_start,str_ind,0);
          var match=caml_string_get(str,str_ind);
          if(37 === match)
           {var str_ind$2=str_ind + 1 | 0;
            if(str_ind$2 === end_ind)unexpected_end_of_format(end_ind);
            var
             match$1=caml_string_get(str,str_ind$2),
             _oL_=
              95 === match$1
               ?parse_flags(str_ind,str_ind$2 + 1 | 0,end_ind,1)
               :parse_flags(str_ind,str_ind$2,end_ind,0),
             fmt_rest=_oL_[1];
            return add_literal(lit_start,str_ind,fmt_rest)}
          if(64 === match)
           {var str_ind$0=str_ind + 1 | 0;
            if(str_ind$0 === end_ind)
             var match$0=_aJ_;
            else
             {var c=caml_string_get(str,str_ind$0);
              if(65 <= c)
               if(94 <= c)
                {var switcher=c - 123 | 0;
                 if(2 < switcher >>> 0)
                  var switch$0=0;
                 else
                  switch(switcher)
                   {case 0:
                     var
                      match$0=parse_tag(1,str_ind$0 + 1 | 0,end_ind),
                      switch$0=1;
                     break;
                    case 1:var switch$0=0;break;
                    default:
                     var
                      match$3=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$2=match$3[1],
                      match$0=[0,[17,1,fmt_rest$2]],
                      switch$0=1}}
               else
                if(91 <= c)
                 {var switcher$0=c - 91 | 0;
                  switch(switcher$0)
                   {case 0:
                     var
                      match$0=parse_tag(0,str_ind$0 + 1 | 0,end_ind),
                      switch$0=1;
                     break;
                    case 1:var switch$0=0;break;
                    default:
                     var
                      match$4=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$3=match$4[1],
                      match$0=[0,[17,0,fmt_rest$3]],
                      switch$0=1}}
                else
                 var switch$0=0;
              else
               if(10 === c)
                var
                 match$5=parse(str_ind$0 + 1 | 0,end_ind),
                 fmt_rest$4=match$5[1],
                 match$0=[0,[17,3,fmt_rest$4]],
                 switch$0=1;
               else
                if(32 <= c)
                 {var switcher$1=c - 32 | 0;
                  switch(switcher$1)
                   {case 0:
                     var
                      match$6=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$5=match$6[1],
                      match$0=[0,[17,_aK_,fmt_rest$5]],
                      switch$0=1;
                     break;
                    case 5:
                     if((str_ind$0 + 1 | 0) < end_ind)
                      if(37 === caml_string_get(str,str_ind$0 + 1 | 0))
                       var
                        match$7=parse(str_ind$0 + 2 | 0,end_ind),
                        fmt_rest$6=match$7[1],
                        match$0=[0,[17,6,fmt_rest$6]],
                        switch$0=1,
                        switch$1=0;
                      else
                       var switch$1=1;
                     else
                      var switch$1=1;
                     if(switch$1)
                      var
                       match$8=parse(str_ind$0,end_ind),
                       fmt_rest$7=match$8[1],
                       match$0=[0,[12,64,fmt_rest$7]],
                       switch$0=1;
                     break;
                    case 12:
                     var
                      match$9=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$8=match$9[1],
                      match$0=[0,[17,_aL_,fmt_rest$8]],
                      switch$0=1;
                     break;
                    case 14:
                     var
                      match$10=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$9=match$10[1],
                      match$0=[0,[17,4,fmt_rest$9]],
                      switch$0=1;
                     break;
                    case 27:
                     var
                      match$0=parse_good_break(str_ind$0 + 1 | 0,end_ind),
                      switch$0=1;
                     break;
                    case 28:
                     var
                      match$0=parse_magic_size(str_ind$0 + 1 | 0,end_ind),
                      switch$0=1;
                     break;
                    case 31:
                     var
                      match$11=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$10=match$11[1],
                      match$0=[0,[17,2,fmt_rest$10]],
                      switch$0=1;
                     break;
                    case 32:
                     var
                      match$12=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$11=match$12[1],
                      match$0=[0,[17,5,fmt_rest$11]],
                      switch$0=1;
                     break;
                    default:var switch$0=0}}
                else
                 var switch$0=0;
              if(! switch$0)
               var
                match$2=parse(str_ind$0 + 1 | 0,end_ind),
                fmt_rest$1=match$2[1],
                match$0=[0,[17,[2,c],fmt_rest$1]]}
            var fmt_rest$0=match$0[1];
            return add_literal(lit_start,str_ind,fmt_rest$0)}
          var str_ind$1=str_ind + 1 | 0,str_ind=str_ind$1;
          continue}}
      function parse_conversion
       (pct_ind,str_ind,end_ind,plus,hash,space,ign,pad,prec,padprec,symb)
       {var
         plus_used=[0,0],
         hash_used=[0,0],
         space_used=[0,0],
         ign_used=[0,0],
         pad_used=[0,0],
         prec_used=[0,0];
        function get_plus(param){plus_used[1] = 1;return plus}
        function get_hash(param){hash_used[1] = 1;return hash}
        function get_space(param){space_used[1] = 1;return space}
        function get_ign(param){ign_used[1] = 1;return ign}
        function get_pad(param){pad_used[1] = 1;return pad}
        function get_prec(param){prec_used[1] = 1;return prec}
        function get_padprec(param){pad_used[1] = 1;return padprec}
        function get_int_pad(param)
         {var pad=get_pad(0),match=get_prec(0);
          if(typeof match === "number")if(0 === match)return pad;
          if(typeof pad === "number")
           return 0;
          else
           {if(0 === pad[0])
             {if(2 <= pad[1])
               {var n=pad[2];
                return legacy_behavior$0
                        ?[0,1,n]
                        :incompatible_flag(pct_ind,str_ind,48,cst_precision$0)}
              return pad}
            return 2 <= pad[1]
                    ?legacy_behavior$0
                      ?_aD_
                      :incompatible_flag(pct_ind,str_ind,48,cst_precision$1)
                    :pad}}
        function check_no_0(symb,pad)
         {if(typeof pad === "number")
           return pad;
          else
           {if(0 === pad[0])
             {if(2 <= pad[1])
               {var width=pad[2];
                return legacy_behavior$0
                        ?[0,1,width]
                        :incompatible_flag(pct_ind,str_ind,symb,cst_0$0)}
              return pad}
            return 2 <= pad[1]
                    ?legacy_behavior$0
                      ?_aE_
                      :incompatible_flag(pct_ind,str_ind,symb,cst_0$1)
                    :pad}}
        function opt_of_pad(c,pad)
         {if(typeof pad === "number")
           return 0;
          else
           {if(0 === pad[0])
             switch(pad[1])
              {case 0:
                var width=pad[2];
                return legacy_behavior$0
                        ?[0,width]
                        :incompatible_flag(pct_ind,str_ind,c,cst$36);
               case 1:var width$0=pad[2];return [0,width$0];
               default:
                var width$1=pad[2];
                return legacy_behavior$0
                        ?[0,width$1]
                        :incompatible_flag(pct_ind,str_ind,c,cst_0$2)}
            return incompatible_flag(pct_ind,str_ind,c,cst$37)}}
        function get_pad_opt(c){return opt_of_pad(c,get_pad(0))}
        function get_padprec_opt(c){return opt_of_pad(c,get_padprec(0))}
        if(124 <= symb)
         var switch$0=0;
        else
         switch(symb)
          {case 33:
            var
             match$6=parse(str_ind,end_ind),
             fmt_rest$5=match$6[1],
             fmt_result=[0,[10,fmt_rest$5]],
             switch$0=1;
            break;
           case 40:
            var
             sub_end=search_subformat_end(str_ind,end_ind,41),
             match$8=parse(sub_end + 2 | 0,end_ind),
             fmt_rest$7=match$8[1],
             match$9=parse(str_ind,sub_end),
             sub_fmt=match$9[1],
             sub_fmtty=fmtty_of_fmt(sub_fmt);
            if(get_ign(0))
             var
              ignored$2=[9,get_pad_opt(95),sub_fmtty],
              _ok_=[0,[23,ignored$2,fmt_rest$7]];
            else
             var _ok_=[0,[14,get_pad_opt(40),sub_fmtty,fmt_rest$7]];
            var fmt_result=_ok_,switch$0=1;
            break;
           case 44:var fmt_result=parse(str_ind,end_ind),switch$0=1;break;
           case 67:
            var
             match$12=parse(str_ind,end_ind),
             fmt_rest$10=match$12[1],
             _om_=get_ign(0)?[0,[23,1,fmt_rest$10]]:[0,[1,fmt_rest$10]],
             fmt_result=_om_,
             switch$0=1;
            break;
           case 78:
            var
             match$16=parse(str_ind,end_ind),
             fmt_rest$14=match$16[1],
             counter$0=2;
            if(get_ign(0))
             var ignored$6=[11,counter$0],_os_=[0,[23,ignored$6,fmt_rest$14]];
            else
             var _os_=[0,[21,counter$0,fmt_rest$14]];
            var fmt_result=_os_,switch$0=1;
            break;
           case 83:
            var
             pad$6=check_no_0(symb,get_padprec(0)),
             match$17=parse(str_ind,end_ind),
             fmt_rest$15=match$17[1];
            if(get_ign(0))
             var
              ignored$7=[1,get_padprec_opt(95)],
              _ot_=[0,[23,ignored$7,fmt_rest$15]];
            else
             var
              match$18=make_padding_fmt_ebb(pad$6,fmt_rest$15),
              fmt_rest$16=match$18[2],
              pad$7=match$18[1],
              _ot_=[0,[3,pad$7,fmt_rest$16]];
            var fmt_result=_ot_,switch$0=1;
            break;
           case 91:
            if(str_ind === end_ind)unexpected_end_of_format(end_ind);
            var
             char_set=create_char_set(0),
             add_char=function(c){return add_in_char_set(char_set,c)},
             add_range=
              function(c$0,c)
               {if(! (c < c$0))
                 {var i=c$0;
                  for(;;)
                   {add_in_char_set(char_set,char_of_int(i));
                    var _oK_=i + 1 | 0;
                    if(c !== i){var i=_oK_;continue}
                    break}}
                return 0},
             fail_single_percent=
              function(str_ind)
               {return caml_call2(failwith_message(_aN_),str,str_ind)},
             parse_char_set_content=
              function(counter,str_ind,end_ind)
               {var str_ind$0=str_ind;
                for(;;)
                 {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
                  var c=caml_string_get(str,str_ind$0);
                  if(45 === c)
                   {add_char(45);
                    var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;
                    continue}
                  if(93 === c)return str_ind$0 + 1 | 0;
                  var _oJ_=str_ind$0 + 1 | 0;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return parse_char_set_after_char$0(counter$0,_oJ_,end_ind,c)}
                  return caml_trampoline_return
                          (parse_char_set_after_char$0,[0,_oJ_,end_ind,c])}},
             parse_char_set_after_char$0=
              function(counter,str_ind,end_ind,c)
               {var str_ind$0=str_ind,c$0=c;
                for(;;)
                 {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
                  var c$1=caml_string_get(str,str_ind$0);
                  if(46 <= c$1)
                   if(64 === c$1)
                    var switch$0=0;
                   else
                    {if(93 === c$1){add_char(c$0);return str_ind$0 + 1 | 0}
                     var switch$0=1}
                  else
                   if(37 === c$1)
                    var switch$0=0;
                   else
                    {if(45 <= c$1)
                      {var str_ind$2=str_ind$0 + 1 | 0;
                       if(str_ind$2 === end_ind)unexpected_end_of_format(end_ind);
                       var c$2=caml_string_get(str,str_ind$2);
                       if(37 === c$2)
                        {if((str_ind$2 + 1 | 0) === end_ind)
                          unexpected_end_of_format(end_ind);
                         var c$3=caml_string_get(str,str_ind$2 + 1 | 0);
                         if(37 !== c$3)
                          if(64 !== c$3)return fail_single_percent(str_ind$2);
                         add_range(c$0,c$3);
                         var _oH_=str_ind$2 + 2 | 0;
                         if(counter < 50)
                          {var counter$2=counter + 1 | 0;
                           return parse_char_set_content(counter$2,_oH_,end_ind)}
                         return caml_trampoline_return
                                 (parse_char_set_content,[0,_oH_,end_ind])}
                       if(93 === c$2)
                        {add_char(c$0);add_char(45);return str_ind$2 + 1 | 0}
                       add_range(c$0,c$2);
                       var _oI_=str_ind$2 + 1 | 0;
                       if(counter < 50)
                        {var counter$1=counter + 1 | 0;
                         return parse_char_set_content(counter$1,_oI_,end_ind)}
                       return caml_trampoline_return
                               (parse_char_set_content,[0,_oI_,end_ind])}
                     var switch$0=1}
                  if(! switch$0)
                   if(37 === c$0)
                    {add_char(c$1);
                     var _oG_=str_ind$0 + 1 | 0;
                     if(counter < 50)
                      {var counter$0=counter + 1 | 0;
                       return parse_char_set_content(counter$0,_oG_,end_ind)}
                     return caml_trampoline_return
                             (parse_char_set_content,[0,_oG_,end_ind])}
                  if(37 === c$0)fail_single_percent(str_ind$0);
                  add_char(c$0);
                  var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1,c$0=c$1;
                  continue}},
             parse_char_set_after_char=
              function(str_ind,end_ind,c)
               {return caml_trampoline
                        (parse_char_set_after_char$0(0,str_ind,end_ind,c))};
            if(str_ind === end_ind)unexpected_end_of_format(end_ind);
            var match$31=caml_string_get(str,str_ind);
            if(94 === match$31)
             var str_ind$0=str_ind + 1 | 0,str_ind$1=str_ind$0,reverse=1;
            else
             var str_ind$1=str_ind,reverse=0;
            if(str_ind$1 === end_ind)unexpected_end_of_format(end_ind);
            var
             c=caml_string_get(str,str_ind$1),
             next_ind=parse_char_set_after_char(str_ind$1 + 1 | 0,end_ind,c),
             char_set$0=freeze_char_set(char_set),
             char_set$1=reverse?rev_char_set(char_set$0):char_set$0,
             match$21=parse(next_ind,end_ind),
             fmt_rest$19=match$21[1];
            if(get_ign(0))
             var
              ignored$9=[10,get_pad_opt(95),char_set$1],
              _oy_=[0,[23,ignored$9,fmt_rest$19]];
            else
             var _oy_=[0,[20,get_pad_opt(91),char_set$1,fmt_rest$19]];
            var fmt_result=_oy_,switch$0=1;
            break;
           case 97:
            var
             match$22=parse(str_ind,end_ind),
             fmt_rest$20=match$22[1],
             fmt_result=[0,[15,fmt_rest$20]],
             switch$0=1;
            break;
           case 99:
            var
             char_format=
              function(fmt_rest)
               {return get_ign(0)?[0,[23,0,fmt_rest]]:[0,[0,fmt_rest]]},
             match$23=parse(str_ind,end_ind),
             fmt_rest$21=match$23[1],
             match$24=get_pad_opt(99);
            if(match$24)
             {if(0 === match$24[1])
               var
                _oz_=get_ign(0)?[0,[23,3,fmt_rest$21]]:[0,[22,fmt_rest$21]],
                _oA_=_oz_;
              else
               var
                _oA_=
                 legacy_behavior$0
                  ?char_format(fmt_rest$21)
                  :invalid_format_message
                    (str_ind,
                     cst_non_zero_widths_are_unsupported_for_c_conversions);
              var _oB_=_oA_}
            else
             var _oB_=char_format(fmt_rest$21);
            var fmt_result=_oB_,switch$0=1;
            break;
           case 114:
            var
             match$25=parse(str_ind,end_ind),
             fmt_rest$22=match$25[1],
             _oC_=get_ign(0)?[0,[23,2,fmt_rest$22]]:[0,[19,fmt_rest$22]],
             fmt_result=_oC_,
             switch$0=1;
            break;
           case 115:
            var
             pad$9=check_no_0(symb,get_padprec(0)),
             match$26=parse(str_ind,end_ind),
             fmt_rest$23=match$26[1];
            if(get_ign(0))
             var
              ignored$10=[0,get_padprec_opt(95)],
              _oD_=[0,[23,ignored$10,fmt_rest$23]];
            else
             var
              match$27=make_padding_fmt_ebb(pad$9,fmt_rest$23),
              fmt_rest$24=match$27[2],
              pad$10=match$27[1],
              _oD_=[0,[2,pad$10,fmt_rest$24]];
            var fmt_result=_oD_,switch$0=1;
            break;
           case 116:
            var
             match$28=parse(str_ind,end_ind),
             fmt_rest$25=match$28[1],
             fmt_result=[0,[16,fmt_rest$25]],
             switch$0=1;
            break;
           case 123:
            var
             sub_end$0=search_subformat_end(str_ind,end_ind,125),
             match$29=parse(str_ind,sub_end$0),
             sub_fmt$0=match$29[1],
             match$30=parse(sub_end$0 + 2 | 0,end_ind),
             fmt_rest$26=match$30[1],
             sub_fmtty$0=fmtty_of_fmt(sub_fmt$0);
            if(get_ign(0))
             var
              ignored$11=[8,get_pad_opt(95),sub_fmtty$0],
              _oE_=[0,[23,ignored$11,fmt_rest$26]];
            else
             var _oE_=[0,[13,get_pad_opt(123),sub_fmtty$0,fmt_rest$26]];
            var fmt_result=_oE_,switch$0=1;
            break;
           case 66:
           case 98:
            var
             pad$3=check_no_0(symb,get_padprec(0)),
             match$10=parse(str_ind,end_ind),
             fmt_rest$8=match$10[1];
            if(get_ign(0))
             var
              ignored$3=[7,get_padprec_opt(95)],
              _ol_=[0,[23,ignored$3,fmt_rest$8]];
            else
             var
              match$11=make_padding_fmt_ebb(pad$3,fmt_rest$8),
              fmt_rest$9=match$11[2],
              pad$4=match$11[1],
              _ol_=[0,[9,pad$4,fmt_rest$9]];
            var fmt_result=_ol_,switch$0=1;
            break;
           case 37:
           case 64:
            var
             match$7=parse(str_ind,end_ind),
             fmt_rest$6=match$7[1],
             fmt_result=[0,[12,symb,fmt_rest$6]],
             switch$0=1;
            break;
           case 76:
           case 108:
           case 110:
            if(str_ind === end_ind)
             var switch$1=1;
            else
             {var symb$0=caml_string_get(str,str_ind),_oF_=symb$0 - 88 | 0;
              if(32 < _oF_ >>> 0)
               var switch$2=0;
              else
               switch(_oF_)
                {case 0:
                 case 12:
                 case 17:
                 case 23:
                 case 29:
                 case 32:var _or_=1,switch$2=1;break;
                 default:var switch$2=0}
              if(! switch$2)var _or_=0;
              if(_or_)var switch$0=0,switch$1=0;else var switch$1=1}
            if(switch$1)
             {var match$15=parse(str_ind,end_ind),fmt_rest$13=match$15[1];
              if(108 <= symb)
               if(111 <= symb)
                var switch$3=0;
               else
                {var switcher$0=symb - 108 | 0;
                 switch(switcher$0)
                  {case 0:var counter=0,switch$3=1;break;
                   case 1:var switch$3=0;break;
                   default:var counter=1,switch$3=1}}
              else
               if(76 === symb)var counter=2,switch$3=1;else var switch$3=0;
              if(! switch$3)throw [0,Assert_failure,_aR_];
              if(get_ign(0))
               var ignored$5=[11,counter],_oq_=[0,[23,ignored$5,fmt_rest$13]];
              else
               var _oq_=[0,[21,counter,fmt_rest$13]];
              var fmt_result=_oq_,switch$0=1}
            break;
           case 32:
           case 35:
           case 43:
           case 45:
           case 95:
            var
             fmt_result=caml_call3(failwith_message(_aI_),str,pct_ind,symb),
             switch$0=1;
            break;
           case 88:
           case 100:
           case 105:
           case 111:
           case 117:
           case 120:
            var
             _ou_=get_space(0),
             _ov_=get_hash(0),
             iconv$2=
              compute_int_conv(pct_ind,str_ind,get_plus(0),_ov_,_ou_,symb),
             match$19=parse(str_ind,end_ind),
             fmt_rest$17=match$19[1];
            if(get_ign(0))
             var
              ignored$8=[2,iconv$2,get_pad_opt(95)],
              _ow_=[0,[23,ignored$8,fmt_rest$17]];
            else
             var
              _ox_=get_prec(0),
              match$20=make_padprec_fmt_ebb(get_int_pad(0),_ox_,fmt_rest$17),
              fmt_rest$18=match$20[3],
              prec$4=match$20[2],
              pad$8=match$20[1],
              _ow_=[0,[4,iconv$2,pad$8,prec$4,fmt_rest$18]];
            var fmt_result=_ow_,switch$0=1;
            break;
           case 69:
           case 70:
           case 71:
           case 72:
           case 101:
           case 102:
           case 103:
           case 104:
            var
             space$1=get_space(0),
             plus$2=get_plus(0),
             plus$3=plus$2,
             space$2=space$1;
            for(;;)
             {if(0 === plus$3)
               if(0 === space$2)
                {if(73 <= symb)
                  {var switcher$1=symb - 101 | 0;
                   if(3 < switcher$1 >>> 0)
                    var switch$4=0;
                   else
                    switch(switcher$1)
                     {case 0:var fconv=3,switch$4=1;break;
                      case 1:var fconv=0,switch$4=1;break;
                      case 2:var fconv=9,switch$4=1;break;
                      default:var fconv=16,switch$4=1}}
                 else
                  if(69 <= symb)
                   {var switcher$2=symb - 69 | 0;
                    switch(switcher$2)
                     {case 0:var fconv=6,switch$4=1;break;
                      case 1:var fconv=15,switch$4=1;break;
                      case 2:var fconv=12,switch$4=1;break;
                      default:var fconv=19,switch$4=1}}
                  else
                   var switch$4=0;
                 if(! switch$4)throw [0,Assert_failure,_aT_]}
               else
                {if(73 <= symb)
                  {var switcher$3=symb - 101 | 0;
                   if(3 < switcher$3 >>> 0)
                    var switch$5=0;
                   else
                    switch(switcher$3)
                     {case 0:var fconv=5,switch$5=1;break;
                      case 1:var fconv=2,switch$5=1;break;
                      case 2:var fconv=11,switch$5=1;break;
                      default:var fconv=18,switch$5=1}}
                 else
                  if(69 <= symb)
                   {var switcher$4=symb - 69 | 0;
                    switch(switcher$4)
                     {case 0:var fconv=8,switch$5=1;break;
                      case 1:var switch$5=0;break;
                      case 2:var fconv=14,switch$5=1;break;
                      default:var fconv=21,switch$5=1}}
                  else
                   var switch$5=0;
                 if(! switch$5)
                  {if(legacy_behavior$0){var space$2=0;continue}
                   var fconv=incompatible_flag(pct_ind,str_ind,symb,cst$48)}}
              else
               if(0 === space$2)
                {if(73 <= symb)
                  {var switcher$5=symb - 101 | 0;
                   if(3 < switcher$5 >>> 0)
                    var switch$6=0;
                   else
                    switch(switcher$5)
                     {case 0:var fconv=4,switch$6=1;break;
                      case 1:var fconv=1,switch$6=1;break;
                      case 2:var fconv=10,switch$6=1;break;
                      default:var fconv=17,switch$6=1}}
                 else
                  if(69 <= symb)
                   {var switcher$6=symb - 69 | 0;
                    switch(switcher$6)
                     {case 0:var fconv=7,switch$6=1;break;
                      case 1:var switch$6=0;break;
                      case 2:var fconv=13,switch$6=1;break;
                      default:var fconv=20,switch$6=1}}
                  else
                   var switch$6=0;
                 if(! switch$6)
                  {if(legacy_behavior$0){var plus$3=0;continue}
                   var fconv=incompatible_flag(pct_ind,str_ind,symb,cst$49)}}
               else
                {if(legacy_behavior$0){var space$2=0;continue}
                 var fconv=incompatible_flag(pct_ind,str_ind,32,cst$50)}
              var match$13=parse(str_ind,end_ind),fmt_rest$11=match$13[1];
              if(get_ign(0))
               {var match=get_prec(0);
                if(typeof match === "number")
                 var
                  _on_=
                   0 === match?0:incompatible_flag(pct_ind,str_ind,95,cst$38);
                else
                 var ndec=match[1],_on_=[0,ndec];
                var
                 ignored$4=[6,get_pad_opt(95),_on_],
                 _oo_=[0,[23,ignored$4,fmt_rest$11]]}
              else
               var
                _op_=get_prec(0),
                match$14=make_padprec_fmt_ebb(get_pad(0),_op_,fmt_rest$11),
                fmt_rest$12=match$14[3],
                prec$3=match$14[2],
                pad$5=match$14[1],
                _oo_=[0,[8,fconv,pad$5,prec$3,fmt_rest$12]];
              var fmt_result=_oo_,switch$0=1;
              break}
            break;
           default:var switch$0=0}
        if(! switch$0)
         {if(108 <= symb)
           if(111 <= symb)
            var switch$7=0;
           else
            {var switcher=symb - 108 | 0;
             switch(switcher)
              {case 0:
                var
                 _n6_=caml_string_get(str,str_ind),
                 _n7_=get_space(0),
                 _n8_=get_hash(0),
                 iconv=
                  compute_int_conv
                   (pct_ind,str_ind + 1 | 0,get_plus(0),_n8_,_n7_,_n6_),
                 match$0=parse(str_ind + 1 | 0,end_ind),
                 fmt_rest=match$0[1];
                if(get_ign(0))
                 var
                  ignored=[3,iconv,get_pad_opt(95)],
                  _n9_=[0,[23,ignored,fmt_rest]];
                else
                 var
                  _n$_=get_prec(0),
                  match$1=make_padprec_fmt_ebb(get_int_pad(0),_n$_,fmt_rest),
                  fmt_rest$0=match$1[3],
                  prec$0=match$1[2],
                  pad$0=match$1[1],
                  _n9_=[0,[5,iconv,pad$0,prec$0,fmt_rest$0]];
                var _n__=_n9_,switch$8=1;
                break;
               case 1:var switch$7=0,switch$8=0;break;
               default:
                var
                 _oa_=caml_string_get(str,str_ind),
                 _ob_=get_space(0),
                 _oc_=get_hash(0),
                 iconv$0=
                  compute_int_conv
                   (pct_ind,str_ind + 1 | 0,get_plus(0),_oc_,_ob_,_oa_),
                 match$2=parse(str_ind + 1 | 0,end_ind),
                 fmt_rest$1=match$2[1];
                if(get_ign(0))
                 var
                  ignored$0=[4,iconv$0,get_pad_opt(95)],
                  _od_=[0,[23,ignored$0,fmt_rest$1]];
                else
                 var
                  _oe_=get_prec(0),
                  match$3=make_padprec_fmt_ebb(get_int_pad(0),_oe_,fmt_rest$1),
                  fmt_rest$2=match$3[3],
                  prec$1=match$3[2],
                  pad$1=match$3[1],
                  _od_=[0,[6,iconv$0,pad$1,prec$1,fmt_rest$2]];
                var _n__=_od_,switch$8=1}
             if(switch$8)var fmt_result=_n__,switch$7=1}
          else
           if(76 === symb)
            {var
              _of_=caml_string_get(str,str_ind),
              _og_=get_space(0),
              _oh_=get_hash(0),
              iconv$1=
               compute_int_conv
                (pct_ind,str_ind + 1 | 0,get_plus(0),_oh_,_og_,_of_),
              match$4=parse(str_ind + 1 | 0,end_ind),
              fmt_rest$3=match$4[1];
             if(get_ign(0))
              var
               ignored$1=[5,iconv$1,get_pad_opt(95)],
               _oi_=[0,[23,ignored$1,fmt_rest$3]];
             else
              var
               _oj_=get_prec(0),
               match$5=make_padprec_fmt_ebb(get_int_pad(0),_oj_,fmt_rest$3),
               fmt_rest$4=match$5[3],
               prec$2=match$5[2],
               pad$2=match$5[1],
               _oi_=[0,[7,iconv$1,pad$2,prec$2,fmt_rest$4]];
             var fmt_result=_oi_,switch$7=1}
           else
            var switch$7=0;
          if(! switch$7)
           var
            fmt_result=
             caml_call3(failwith_message(_aF_),str,str_ind - 1 | 0,symb)}
        if(1 - legacy_behavior$0)
         {var _nX_=1 - plus_used[1],plus$0=_nX_?plus:_nX_;
          if(plus$0)incompatible_flag(pct_ind,str_ind,symb,cst$39);
          var _nY_=1 - hash_used[1],hash$0=_nY_?hash:_nY_;
          if(hash$0)incompatible_flag(pct_ind,str_ind,symb,cst$40);
          var _nZ_=1 - space_used[1],space$0=_nZ_?space:_nZ_;
          if(space$0)incompatible_flag(pct_ind,str_ind,symb,cst$41);
          var _n0_=1 - pad_used[1],_n1_=_n0_?caml_notequal([0,pad],_aG_):_n0_;
          if(_n1_)incompatible_flag(pct_ind,str_ind,symb,cst_padding$0);
          var
           _n2_=1 - prec_used[1],
           _n3_=_n2_?caml_notequal([0,prec],_aH_):_n2_;
          if(_n3_)
           {var _n4_=ign?95:symb;
            incompatible_flag(pct_ind,str_ind,_n4_,cst_precision$2)}
          var plus$1=ign?plus:ign;
          if(plus$1)incompatible_flag(pct_ind,str_ind,95,cst$42)}
        var _n5_=1 - ign_used[1],ign$0=_n5_?ign:_n5_;
        if(ign$0)
         {var
           switch$9=
            38 <= symb
             ?44 === symb?0:64 === symb?0:1
             :33 === symb?0:37 <= symb?0:1,
           switch$10=switch$9?0:legacy_behavior$0?1:0;
          if(! switch$10)incompatible_flag(pct_ind,str_ind,symb,cst$43)}
        return fmt_result}
      function parse_after_precision
       (pct_ind,str_ind,end_ind,minus,plus,hash,space,ign,pad,match)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        function parse_conv(padprec)
         {return parse_conversion
                  (pct_ind,
                   str_ind + 1 | 0,
                   end_ind,
                   plus,
                   hash,
                   space,
                   ign,
                   pad,
                   match,
                   padprec,
                   caml_string_get(str,str_ind))}
        if(typeof pad === "number")
         {if(typeof match === "number")if(0 === match)return parse_conv(0);
          if(0 === minus)
           {if(typeof match === "number")return parse_conv(_aB_);
            var n=match[1];
            return parse_conv([0,1,n])}
          if(typeof match === "number")return parse_conv(_aC_);
          var n$0=match[1];
          return parse_conv([0,0,n$0])}
        return parse_conv(pad)}
      function parse_after_padding
       (pct_ind,str_ind,end_ind,minus,plus,hash,space,ign,pad)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        var symb=caml_string_get(str,str_ind);
        if(46 === symb)
         {var str_ind$0=str_ind + 1 | 0;
          if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var
           parse_literal=
            function(minus,str_ind)
             {var
               match=parse_positive(str_ind,end_ind,0),
               prec=match[2],
               new_ind=match[1];
              return parse_after_precision
                      (pct_ind,
                       new_ind,
                       end_ind,
                       minus,
                       plus,
                       hash,
                       space,
                       ign,
                       pad,
                       [0,prec])},
           symb$0=caml_string_get(str,str_ind$0);
          if(48 <= symb$0)
           {if(! (58 <= symb$0))return parse_literal(minus,str_ind$0)}
          else
           if(42 <= symb$0)
            {var switcher=symb$0 - 42 | 0;
             switch(switcher)
              {case 0:
                return parse_after_precision
                        (pct_ind,
                         str_ind$0 + 1 | 0,
                         end_ind,
                         minus,
                         plus,
                         hash,
                         space,
                         ign,
                         pad,
                         1);
               case 1:
               case 3:
                if(legacy_behavior$0)
                 {var
                   _nW_=str_ind$0 + 1 | 0,
                   minus$0=minus || (45 === symb$0?1:0);
                  return parse_literal(minus$0,_nW_)}
                break
               }}
          return legacy_behavior$0
                  ?parse_after_precision
                    (pct_ind,
                     str_ind$0,
                     end_ind,
                     minus,
                     plus,
                     hash,
                     space,
                     ign,
                     pad,
                     _aA_)
                  :invalid_format_without(str_ind$0 - 1 | 0,46,cst_precision)}
        return parse_conversion
                (pct_ind,
                 str_ind + 1 | 0,
                 end_ind,
                 plus,
                 hash,
                 space,
                 ign,
                 pad,
                 0,
                 pad,
                 symb)}
      function parse_flags(pct_ind,str_ind,end_ind,ign)
       {var zero=[0,0],minus=[0,0],plus=[0,0],space=[0,0],hash=[0,0];
        function set_flag(str_ind,flag)
         {var _nT_=flag[1],_nU_=_nT_?1 - legacy_behavior$0:_nT_;
          if(_nU_)
           {var _nV_=caml_string_get(str,str_ind);
            caml_call3(failwith_message(_ay_),str,str_ind,_nV_)}
          flag[1] = 1;
          return 0}
        var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var match=caml_string_get(str,str_ind$0),switcher=match - 32 | 0;
          if(! (16 < switcher >>> 0))
           switch(switcher)
            {case 0:
              set_flag(str_ind$0,space);
              var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;
              continue;
             case 3:
              set_flag(str_ind$0,hash);
              var str_ind$2=str_ind$0 + 1 | 0,str_ind$0=str_ind$2;
              continue;
             case 11:
              set_flag(str_ind$0,plus);
              var str_ind$3=str_ind$0 + 1 | 0,str_ind$0=str_ind$3;
              continue;
             case 13:
              set_flag(str_ind$0,minus);
              var str_ind$4=str_ind$0 + 1 | 0,str_ind$0=str_ind$4;
              continue;
             case 16:
              set_flag(str_ind$0,zero);
              var str_ind$5=str_ind$0 + 1 | 0,str_ind$0=str_ind$5;
              continue
             }
          var
           _nO_=space[1],
           _nP_=hash[1],
           _nQ_=plus[1],
           _nR_=minus[1],
           _nS_=zero[1];
          if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var
           padty=
            0 === _nS_
             ?0 === _nR_?1:0
             :0 === _nR_
               ?2
               :legacy_behavior$0
                 ?0
                 :incompatible_flag(pct_ind,str_ind$0,45,cst_0),
           match$0=caml_string_get(str,str_ind$0);
          if(48 <= match$0)
           {if(! (58 <= match$0))
             {var
               match$1=parse_positive(str_ind$0,end_ind,0),
               width=match$1[2],
               new_ind=match$1[1];
              return parse_after_padding
                      (pct_ind,
                       new_ind,
                       end_ind,
                       _nR_,
                       _nQ_,
                       _nP_,
                       _nO_,
                       ign,
                       [0,padty,width])}}
          else
           if(42 === match$0)
            return parse_after_padding
                    (pct_ind,
                     str_ind$0 + 1 | 0,
                     end_ind,
                     _nR_,
                     _nQ_,
                     _nP_,
                     _nO_,
                     ign,
                     [1,padty]);
          switch(padty)
           {case 0:
             if(1 - legacy_behavior$0)
              invalid_format_without(str_ind$0 - 1 | 0,45,cst_padding);
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_nR_,_nQ_,_nP_,_nO_,ign,0);
            case 1:
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_nR_,_nQ_,_nP_,_nO_,ign,0);
            default:
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_nR_,_nQ_,_nP_,_nO_,ign,_az_)}}}
      function parse_tag(is_open_tag,str_ind,end_ind)
       {try
         {if(str_ind === end_ind)throw Not_found;
          var match$0=caml_string_get(str,str_ind);
          if(60 === match$0)
           {var ind=index_from$0(str,str_ind + 1 | 0,62);
            if(end_ind <= ind)throw Not_found;
            var
             sub_str=sub$0(str,str_ind,(ind - str_ind | 0) + 1 | 0),
             match$1=parse(ind + 1 | 0,end_ind),
             fmt_rest$0=match$1[1],
             match$2=parse(str_ind,ind + 1 | 0),
             sub_fmt=match$2[1],
             sub_format$0=[0,sub_fmt,sub_str];
            if(is_open_tag)
             var formatting$0=[0,sub_format$0];
            else
             {if(typeof sub_fmt === "number")
               var switch$0=0;
              else
               if(11 === sub_fmt[0])
                if(typeof sub_fmt[2] === "number")
                 {var str$0=sub_fmt[1];
                  try
                   {open_box_of_string(str$0);var switch$1=1}
                  catch(_nN_)
                   {_nN_ = caml_wrap_exception(_nN_);
                    if(_nN_[1] !== Failure)throw _nN_;
                    var switch$0=1,switch$1=0}
                  if(switch$1)var switch$0=1}
                else
                 var switch$0=0;
               else
                var switch$0=0;
              var formatting$0=[1,sub_format$0]}
            var _nL_=[0,[18,formatting$0,fmt_rest$0]];
            return _nL_}
          throw Not_found}
        catch(_nM_)
         {_nM_ = caml_wrap_exception(_nM_);
          if(_nM_ === Not_found)
           {var
             match=parse(str_ind,end_ind),
             fmt_rest=match[1],
             formatting=is_open_tag?[0,sub_format]:[1,sub_format];
            return [0,[18,formatting,fmt_rest]]}
          throw _nM_}}
      function parse_good_break(str_ind,end_ind)
       {try
         {var
           _nE_=str_ind === end_ind?1:0,
           _nF_=_nE_ || (60 !== caml_string_get(str,str_ind)?1:0);
          if(_nF_)throw Not_found;
          var
           str_ind_1=parse_spaces(str_ind + 1 | 0,end_ind),
           match$0=caml_string_get(str,str_ind_1),
           switch$0=48 <= match$0?58 <= match$0?0:1:45 === match$0?1:0;
          if(! switch$0)throw Not_found;
          var
           match$1=parse_integer(str_ind_1,end_ind),
           width=match$1[2],
           str_ind_2=match$1[1],
           str_ind_3=parse_spaces(str_ind_2,end_ind),
           match$2=caml_string_get(str,str_ind_3),
           switcher=match$2 - 45 | 0;
          if(12 < switcher >>> 0)
           if(17 === switcher)
            var
             s=sub$0(str,str_ind - 2 | 0,(str_ind_3 - str_ind | 0) + 3 | 0),
             _nG_=[0,s,width,0],
             _nH_=str_ind_3 + 1 | 0,
             next_ind=_nH_,
             formatting_lit$0=_nG_,
             switch$1=1;
           else
            var switch$1=0;
          else
           {var switcher$0=switcher - 1 | 0;
            if(1 < switcher$0 >>> 0)
             {var
               match$3=parse_integer(str_ind_3,end_ind),
               offset=match$3[2],
               str_ind_4=match$3[1],
               str_ind_5=parse_spaces(str_ind_4,end_ind);
              if(62 !== caml_string_get(str,str_ind_5))throw Not_found;
              var
               s$0=
                sub$0(str,str_ind - 2 | 0,(str_ind_5 - str_ind | 0) + 3 | 0),
               _nI_=[0,s$0,width,offset],
               _nJ_=str_ind_5 + 1 | 0,
               next_ind=_nJ_,
               formatting_lit$0=_nI_,
               switch$1=1}
            else
             var switch$1=0}
          if(! switch$1)throw Not_found}
        catch(_nK_)
         {_nK_ = caml_wrap_exception(_nK_);
          if(_nK_ !== Not_found)if(_nK_[1] !== Failure)throw _nK_;
          var next_ind=str_ind,formatting_lit$0=formatting_lit}
        var match=parse(next_ind,end_ind),fmt_rest=match[1];
        return [0,[17,formatting_lit$0,fmt_rest]]}
      function parse_magic_size(str_ind,end_ind)
       {try
         {var
           str_ind_1=parse_spaces(str_ind,end_ind),
           match$2=caml_string_get(str,str_ind_1),
           switch$0=48 <= match$2?58 <= match$2?0:1:45 === match$2?1:0;
          if(switch$0)
           {var
             match$3=parse_integer(str_ind_1,end_ind),
             size=match$3[2],
             str_ind_2=match$3[1],
             str_ind_3=parse_spaces(str_ind_2,end_ind);
            if(62 !== caml_string_get(str,str_ind_3))throw Not_found;
            var
             s=sub$0(str,str_ind - 2 | 0,(str_ind_3 - str_ind | 0) + 3 | 0),
             _nC_=[0,[0,str_ind_3 + 1 | 0,[1,s,size]]]}
          else
           var _nC_=0;
          var _nB_=_nC_}
        catch(_nD_)
         {_nD_ = caml_wrap_exception(_nD_);
          if(_nD_ !== Not_found)if(_nD_[1] !== Failure)throw _nD_;
          var _nB_=0}
        if(_nB_)
         {var
           match=_nB_[1],
           formatting_lit=match[2],
           next_ind=match[1],
           match$0=parse(next_ind,end_ind),
           fmt_rest=match$0[1];
          return [0,[17,formatting_lit,fmt_rest]]}
        var match$1=parse(str_ind,end_ind),fmt_rest$0=match$1[1];
        return [0,[17,_aM_,fmt_rest$0]]}
      function parse_spaces(str_ind,end_ind)
       {var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          if(32 === caml_string_get(str,str_ind$0))
           {var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;continue}
          return str_ind$0}}
      function parse_positive(str_ind,end_ind,acc)
       {var str_ind$0=str_ind,acc$0=acc;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var c=caml_string_get(str,str_ind$0),switcher=c - 48 | 0;
          if(9 < switcher >>> 0)return [0,str_ind$0,acc$0];
          var acc$1=(acc$0 * 10 | 0) + (c - 48 | 0) | 0;
          if(max_string_length < acc$1)
           return caml_call3
                   (failwith_message(_aO_),str,acc$1,max_string_length);
          var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1,acc$0=acc$1;
          continue}}
      function parse_integer(str_ind,end_ind)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        var match=caml_string_get(str,str_ind);
        if(48 <= match)
         {if(! (58 <= match))return parse_positive(str_ind,end_ind,0)}
        else
         if(45 === match)
          {if((str_ind + 1 | 0) === end_ind)unexpected_end_of_format(end_ind);
           var c=caml_string_get(str,str_ind + 1 | 0),switcher=c - 48 | 0;
           if(9 < switcher >>> 0)
            return expected_character(str_ind + 1 | 0,cst_digit,c);
           var
            match$0=parse_positive(str_ind + 1 | 0,end_ind,0),
            n=match$0[2],
            next_ind=match$0[1];
           return [0,next_ind,- n | 0]}
        throw [0,Assert_failure,_aP_]}
      function search_subformat_end(str_ind,end_ind,c)
       {var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)
           caml_call3(failwith_message(_aQ_),str,c,end_ind);
          var match=caml_string_get(str,str_ind$0);
          if(37 === match)
           {if((str_ind$0 + 1 | 0) === end_ind)
             unexpected_end_of_format(end_ind);
            if(caml_string_get(str,str_ind$0 + 1 | 0) === c)return str_ind$0;
            var match$0=caml_string_get(str,str_ind$0 + 1 | 0);
            if(95 <= match$0)
             {if(123 <= match$0)
               {if(! (126 <= match$0))
                 {var switcher=match$0 - 123 | 0;
                  switch(switcher)
                   {case 0:
                     var
                      sub_end=search_subformat_end(str_ind$0 + 2 | 0,end_ind,125),
                      str_ind$2=sub_end + 2 | 0,
                      str_ind$0=str_ind$2;
                     continue;
                    case 1:break;
                    default:
                     return expected_character
                             (str_ind$0 + 1 | 0,cst_character,125)}}}
              else
               if(! (96 <= match$0))
                {if((str_ind$0 + 2 | 0) === end_ind)
                  unexpected_end_of_format(end_ind);
                 var match$1=caml_string_get(str,str_ind$0 + 2 | 0);
                 if(40 === match$1)
                  {var
                    sub_end$0=search_subformat_end(str_ind$0 + 3 | 0,end_ind,41),
                    str_ind$3=sub_end$0 + 2 | 0,
                    str_ind$0=str_ind$3;
                   continue}
                 if(123 === match$1)
                  {var
                    sub_end$1=
                     search_subformat_end(str_ind$0 + 3 | 0,end_ind,125),
                    str_ind$4=sub_end$1 + 2 | 0,
                    str_ind$0=str_ind$4;
                   continue}
                 var str_ind$5=str_ind$0 + 3 | 0,str_ind$0=str_ind$5;
                 continue}}
            else
             {if(40 === match$0)
               {var
                 sub_end$2=search_subformat_end(str_ind$0 + 2 | 0,end_ind,41),
                 str_ind$6=sub_end$2 + 2 | 0,
                 str_ind$0=str_ind$6;
                continue}
              if(41 === match$0)
               return expected_character(str_ind$0 + 1 | 0,cst_character$0,41)}
            var str_ind$1=str_ind$0 + 2 | 0,str_ind$0=str_ind$1;
            continue}
          var str_ind$7=str_ind$0 + 1 | 0,str_ind$0=str_ind$7;
          continue}}
      function incompatible_flag(pct_ind,str_ind,symb,option)
       {var subfmt=sub$0(str,pct_ind,str_ind - pct_ind | 0);
        return caml_call5
                (failwith_message(_aU_),str,pct_ind,option,symb,subfmt)}
      function compute_int_conv(pct_ind,str_ind,plus,hash,space,symb)
       {var plus$0=plus,hash$0=hash,space$0=space;
        for(;;)
         {if(0 === plus$0)
           if(0 === hash$0)
            if(0 === space$0)
             {var switcher=symb - 88 | 0;
              if(32 < switcher >>> 0)
               var switch$0=1;
              else
               switch(switcher)
                {case 0:return 8;
                 case 12:return 0;
                 case 17:return 3;
                 case 23:return 10;
                 case 29:return 12;
                 case 32:return 6;
                 default:var switch$0=1}}
            else
             {if(100 === symb)return 2;
              if(105 === symb)return 5;
              var switch$0=1}
           else
            if(0 === space$0)
             {if(88 === symb)return 9;
              if(111 === symb)return 11;
              if(120 === symb)return 7;
              var switch$0=0}
            else
             var switch$0=0;
          else
           if(0 === hash$0)
            if(0 === space$0)
             {if(100 === symb)return 1;
              if(105 === symb)return 4;
              var switch$0=1}
            else
             var switch$0=1;
           else
            var switch$0=0;
          if(! switch$0)
           {var switcher$0=symb - 88 | 0;
            if(! (32 < switcher$0 >>> 0))
             switch(switcher$0)
              {case 0:if(legacy_behavior$0)return 9;break;
               case 23:if(legacy_behavior$0)return 11;break;
               case 32:if(legacy_behavior$0)return 7;break;
               case 12:
               case 17:
               case 29:
                if(legacy_behavior$0){var hash$0=0;continue}
                return incompatible_flag(pct_ind,str_ind,symb,cst$47)
               }}
          if(0 === plus$0)
           {if(0 === space$0)throw [0,Assert_failure,_aS_];
            if(legacy_behavior$0){var space$0=0;continue}
            return incompatible_flag(pct_ind,str_ind,symb,cst$44)}
          if(0 === space$0)
           {if(legacy_behavior$0){var plus$0=0;continue}
            return incompatible_flag(pct_ind,str_ind,symb,cst$45)}
          if(legacy_behavior$0){var space$0=0;continue}
          return incompatible_flag(pct_ind,str_ind,32,cst$46)}}
      return parse(0,caml_ml_string_length(str))}
    function format_of_string_fmtty(str,fmtty)
     {var match=fmt_ebb_of_string(0,str),fmt=match[1];
      try
       {var _nz_=[0,type_format(fmt,fmtty),str];return _nz_}
      catch(_nA_)
       {_nA_ = caml_wrap_exception(_nA_);
        if(_nA_ === Type_mismatch)
         {var _ny_=string_of_fmtty(fmtty);
          return caml_call2(failwith_message(_aV_),str,_ny_)}
        throw _nA_}}
    function format_of_string_format(str,param)
     {var
       str$0=param[2],
       fmt=param[1],
       match=fmt_ebb_of_string(0,str),
       fmt$0=match[1];
      try
       {var _nw_=[0,type_format(fmt$0,fmtty_of_fmt(fmt)),str];return _nw_}
      catch(_nx_)
       {_nx_ = caml_wrap_exception(_nx_);
        if(_nx_ === Type_mismatch)
         return caml_call2(failwith_message(_aW_),str,str$0);
        throw _nx_}}
    var
     CamlinternalFormat=
      [0,
       is_in_char_set,
       rev_char_set,
       create_char_set,
       add_in_char_set,
       freeze_char_set,
       param_format_of_ignored_format,
       make_printf,
       make_iprintf,
       output_acc,
       bufput_acc,
       strput_acc,
       type_format,
       fmt_ebb_of_string,
       format_of_string_fmtty,
       format_of_string_format,
       char_of_iconv,
       string_of_formatting_lit,
       string_of_formatting_gen,
       string_of_fmtty,
       string_of_fmt,
       open_box_of_string,
       symm,
       trans,
       recast];
    caml_register_global(668,CamlinternalFormat,"CamlinternalFormat");
    function kfprintf(k,o,param)
     {var fmt=param[1],_nv_=0;
      return make_printf
              (function(o,acc){output_acc(o,acc);return caml_call1(k,o)},
               o,
               _nv_,
               fmt)}
    function kbprintf(k,b,param)
     {var fmt=param[1],_nu_=0;
      return make_printf
              (function(b,acc){bufput_acc(b,acc);return caml_call1(k,b)},
               b,
               _nu_,
               fmt)}
    function ikfprintf(k,oc,param)
     {var fmt=param[1];return make_iprintf(k,oc,fmt)}
    function fprintf(oc,fmt){return kfprintf(function(_nt_){return 0},oc,fmt)}
    function bprintf(b,fmt){return kbprintf(function(_ns_){return 0},b,fmt)}
    function ifprintf(oc,fmt)
     {return ikfprintf(function(_nr_){return 0},oc,fmt)}
    function printf(fmt){return fprintf(stdout,fmt)}
    function eprintf(fmt){return fprintf(stderr,fmt)}
    function ksprintf(k,param)
     {var fmt=param[1];
      function k$0(param,acc)
       {var buf=create$1(64);
        strput_acc(buf,acc);
        return caml_call1(k,contents(buf))}
      return make_printf(k$0,0,0,fmt)}
    function sprintf(fmt){return ksprintf(function(s){return s},fmt)}
    var
     Printf=
      [0,
       fprintf,
       printf,
       eprintf,
       sprintf,
       bprintf,
       ifprintf,
       kfprintf,
       ikfprintf,
       ksprintf,
       kbprintf,
       ksprintf];
    caml_register_global(669,Printf,"Printf");
    var
     Bad=[248,cst_Arg_Bad,caml_fresh_oo_id(0)],
     Help=[248,cst_Arg_Help,caml_fresh_oo_id(0)],
     Stop=[248,cst_Arg_Stop,caml_fresh_oo_id(0)];
    function assoc3(x,l)
     {var l$0=l;
      for(;;)
       {if(l$0)
         {var t=l$0[2],match=l$0[1],y2=match[2],y1=match[1];
          if(caml_equal(y1,x))return y2;
          var l$0=t;
          continue}
        throw Not_found}}
    function split$0(s)
     {var
       i=index$0(s,61),
       len=caml_ml_string_length(s),
       _nq_=sub$0(s,i + 1 | 0,len - (i + 1 | 0) | 0);
      return [0,sub$0(s,0,i),_nq_]}
    function make_symlist(prefix,sep,suffix,l)
     {if(l)
       {var t=l[2],h=l[1],_np_=symbol(prefix,h);
        return symbol
                (fold_left
                  (function(x,y){return symbol(x,symbol(sep,y))},_np_,t),
                 suffix)}
      return cst_none}
    function help_action(param){throw [0,Stop,_aZ_]}
    function add_help(speclist)
     {try
       {assoc3(cst_help$2,speclist);var _nm_=0,_nk_=_nm_}
      catch(_no_)
       {_no_ = caml_wrap_exception(_no_);
        if(_no_ !== Not_found)throw _no_;
        var
         _nk_=
          [0,[0,cst_help,[0,help_action],cst_Display_this_list_of_options],0]}
      try
       {assoc3(cst_help$1,speclist);var _nl_=0,add2=_nl_}
      catch(_nn_)
       {_nn_ = caml_wrap_exception(_nn_);
        if(_nn_ !== Not_found)throw _nn_;
        var
         add2=
          [0,
           [0,cst_help$0,[0,help_action],cst_Display_this_list_of_options$0],
           0]}
      return append(speclist,append(_nk_,add2))}
    function usage_b(buf,speclist,errmsg)
     {caml_call1(bprintf(buf,_a0_),errmsg);
      var _nh_=add_help(speclist);
      return iter
              (function(param)
                {var
                  doc=param[3],
                  spec=param[2],
                  key=param[1],
                  _ni_=0 < caml_ml_string_length(doc)?1:0;
                 if(_ni_)
                  {if(11 === spec[0])
                    {var l=spec[1],_nj_=make_symlist(cst$53,cst$52,cst$51,l);
                     return caml_call3(bprintf(buf,_aY_),key,_nj_,doc)}
                   return caml_call2(bprintf(buf,_aX_),key,doc)}
                 return _ni_},
               _nh_)}
    function usage_string(speclist,errmsg)
     {var b=create$1(200);usage_b(b,speclist,errmsg);return contents(b)}
    function usage(speclist,errmsg)
     {var _ng_=usage_string(speclist,errmsg);
      return caml_call1(eprintf(_a1_),_ng_)}
    var current=[0,0];
    function bool_of_string_opt$0(x)
     {try
       {var _ne_=[0,bool_of_string(x)];return _ne_}
      catch(_nf_)
       {_nf_ = caml_wrap_exception(_nf_);
        if(_nf_[1] === Invalid_argument)return 0;
        throw _nf_}}
    function int_of_string_opt$0(x)
     {try
       {var _nc_=[0,caml_int_of_string(x)];return _nc_}
      catch(_nd_)
       {_nd_ = caml_wrap_exception(_nd_);
        if(_nd_[1] === Failure)return 0;
        throw _nd_}}
    function float_of_string_opt$0(x)
     {try
       {var _na_=[0,caml_float_of_string(x)];return _na_}
      catch(_nb_)
       {_nb_ = caml_wrap_exception(_nb_);
        if(_nb_[1] === Failure)return 0;
        throw _nb_}}
    function parse_and_expand_argv_dynamic_aux
     (allow_expand,current,argv,speclist,anonfun,errmsg)
     {var initpos=current[1];
      function convert_error(error)
       {var
         b=create$1(200),
         progname=
          initpos < argv[1].length - 1
           ?caml_check_bound(argv[1],initpos)[1 + initpos]
           :cst$54;
        switch(error[0])
         {case 0:
           var _m$_=error[1];
           if(caml_string_notequal(_m$_,cst_help$3))
            if(caml_string_notequal(_m$_,cst_help$4))
             caml_call2(bprintf(b,_a2_),progname,_m$_);
           break;
          case 1:
           var expected=error[3],arg=error[2],opt=error[1];
           caml_call4(bprintf(b,_a5_),progname,arg,opt,expected);
           break;
          case 2:var s=error[1];caml_call2(bprintf(b,_a6_),progname,s);break;
          default:var s$0=error[1];caml_call2(bprintf(b,_a7_),progname,s$0)}
        usage_b(b,speclist[1],errmsg);
        if(! caml_equal(error,_a3_))
         if(! caml_equal(error,_a4_))return [0,Bad,contents(b)];
        return [0,Help,contents(b)]}
      current[1]++;
      for(;;)
       {if(current[1] < argv[1].length - 1)
         {try
           {var _m2_=current[1],s=caml_check_bound(argv[1],_m2_)[1 + _m2_];
            if(1 <= caml_ml_string_length(s))
             if(45 === caml_string_get(s,0))
              {try
                {var
                  follow$1=0,
                  _m4_=assoc3(s,speclist[1]),
                  action=_m4_,
                  follow$0=follow$1}
               catch(_m9_)
                {_m9_ = caml_wrap_exception(_m9_);
                 if(_m9_ !== Not_found)throw _m9_;
                 try
                  {var
                    match=split$0(s),
                    arg=match[2],
                    keyword=match[1],
                    follow=[0,arg],
                    _m3_=assoc3(keyword,speclist[1])}
                 catch(_m__)
                  {_m__ = caml_wrap_exception(_m__);
                   if(_m__ === Not_found)throw [0,Stop,[0,s]];
                   throw _m__;
                   var _m5_=_m__}
                 var action=_m3_,follow$0=follow,_m6_=_m9_}
               var
                no_arg$0=
                 function(s,follow)
                  {function no_arg(param)
                    {if(follow)
                      {var arg=follow[1];throw [0,Stop,[1,s,arg,cst_no_argument]]}
                     return 0}
                   return no_arg},
                no_arg=no_arg$0(s,follow$0),
                get_arg$0=
                 function(s,follow)
                  {function get_arg(param)
                    {if(follow){var arg=follow[1];return arg}
                     if((current[1] + 1 | 0) < argv[1].length - 1)
                      {var _m8_=current[1] + 1 | 0;
                       return caml_check_bound(argv[1],_m8_)[1 + _m8_]}
                     throw [0,Stop,[2,s]]}
                   return get_arg},
                get_arg=get_arg$0(s,follow$0),
                consume_arg$0=
                 function(follow)
                  {function consume_arg(param)
                    {return follow?0:(current[1]++,0)}
                   return consume_arg},
                consume_arg=consume_arg$0(follow$0),
                treat_action$0=
                 function(s,no_arg,get_arg,consume_arg)
                  {function treat_action(param)
                    {switch(param[0])
                      {case 0:var f=param[1];return caml_call1(f,0);
                       case 1:
                        var
                         f$0=param[1],
                         arg=get_arg(0),
                         match=bool_of_string_opt$0(arg);
                        if(match)
                         {var s$0=match[1];caml_call1(f$0,s$0);return consume_arg(0)}
                        throw [0,Stop,[1,s,arg,cst_a_boolean]];
                       case 2:var r=param[1];no_arg(0);r[1] = 1;return 0;
                       case 3:var r$0=param[1];no_arg(0);r$0[1] = 0;return 0;
                       case 4:
                        var f$1=param[1],arg$0=get_arg(0);
                        caml_call1(f$1,arg$0);
                        return consume_arg(0);
                       case 5:
                        var r$1=param[1];r$1[1] = get_arg(0);return consume_arg(0);
                       case 6:
                        var
                         f$2=param[1],
                         arg$1=get_arg(0),
                         match$0=int_of_string_opt$0(arg$1);
                        if(match$0)
                         {var x=match$0[1];caml_call1(f$2,x);return consume_arg(0)}
                        throw [0,Stop,[1,s,arg$1,cst_an_integer]];
                       case 7:
                        var
                         r$2=param[1],
                         arg$2=get_arg(0),
                         match$1=int_of_string_opt$0(arg$2);
                        if(match$1)
                         {var x$0=match$1[1];r$2[1] = x$0;return consume_arg(0)}
                        throw [0,Stop,[1,s,arg$2,cst_an_integer$0]];
                       case 8:
                        var
                         f$3=param[1],
                         arg$3=get_arg(0),
                         match$2=float_of_string_opt$0(arg$3);
                        if(match$2)
                         {var x$1=match$2[1];
                          caml_call1(f$3,x$1);
                          return consume_arg(0)}
                        throw [0,Stop,[1,s,arg$3,cst_a_float]];
                       case 9:
                        var
                         r$3=param[1],
                         arg$4=get_arg(0),
                         match$3=float_of_string_opt$0(arg$4);
                        if(match$3)
                         {var x$2=match$3[1];r$3[1] = x$2;return consume_arg(0)}
                        throw [0,Stop,[1,s,arg$4,cst_a_float$0]];
                       case 10:var specs=param[1];return iter(treat_action,specs);
                       case 11:
                        var f$4=param[2],symb=param[1],arg$5=get_arg(0);
                        if(mem(arg$5,symb))
                         {caml_call1(f$4,arg$5);return consume_arg(0)}
                        throw [0,
                               Stop,
                               [1,
                                s,
                                arg$5,
                                symbol(cst_one_of,make_symlist(cst$57,cst$56,cst$55,symb))]];
                       case 12:
                        var f$5=param[1];
                        for(;;)
                         {if(current[1] < (argv[1].length - 1 - 1 | 0))
                           {var _m7_=current[1] + 1 | 0;
                            caml_call1(f$5,caml_check_bound(argv[1],_m7_)[1 + _m7_]);
                            consume_arg(0);
                            continue}
                          return 0}
                       default:
                        var f$6=param[1];
                        if(1 - allow_expand)
                         throw [0,
                                Invalid_argument,
                                cst_Arg_Expand_is_is_only_allowed_with_Arg_parse_and_expand_argv_dynamic];
                        var arg$6=get_arg(0),newarg=caml_call1(f$6,arg$6);
                        consume_arg(0);
                        var
                         before=sub$1(argv[1],0,current[1] + 1 | 0),
                         after=
                          sub$1
                           (argv[1],
                            current[1] + 1 | 0,
                            (argv[1].length - 1 - current[1] | 0) - 1 | 0);
                        argv[1]
                        =
                        caml_array_concat([0,before,[0,newarg,[0,after,0]]]);
                        return 0}}
                   return treat_action},
                treat_action=treat_action$0(s,no_arg,get_arg,consume_arg);
               treat_action(action);
               var switch$0=1}
             else
              var switch$0=0;
            else
             var switch$0=0;
            if(! switch$0)caml_call1(anonfun,s)}
          catch(exn$0)
           {exn$0 = caml_wrap_exception(exn$0);
            if(exn$0[1] === Bad){var m=exn$0[2];throw convert_error([3,m])}
            if(exn$0[1] === Stop){var e=exn$0[2];throw convert_error(e)}
            throw exn$0;
            var exn=exn$0}
          current[1]++;
          continue}
        return 0}}
    function parse_and_expand_argv_dynamic
     (current,argv,speclist,anonfun,errmsg)
     {return parse_and_expand_argv_dynamic_aux
              (1,current,argv,speclist,anonfun,errmsg)}
    function parse_argv_dynamic(opt,argv,speclist,anonfun,errmsg)
     {if(opt)var sth=opt[1],current$0=sth;else var current$0=current;
      return parse_and_expand_argv_dynamic_aux
              (0,current$0,[0,argv],speclist,anonfun,errmsg)}
    function parse_argv(opt,argv,speclist,anonfun,errmsg)
     {if(opt)var sth=opt[1],current$0=sth;else var current$0=current;
      return parse_argv_dynamic
              ([0,current$0],argv,[0,speclist],anonfun,errmsg)}
    function parse(l,f,msg)
     {try
       {var _m1_=parse_argv(0,_q_,l,f,msg);return _m1_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_a8_),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_a9_),msg$1);return exit(0)}
        throw exn}}
    function parse_dynamic(l,f,msg)
     {try
       {var _m0_=parse_argv_dynamic(0,_q_,l,f,msg);return _m0_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_a__),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_a$_),msg$1);return exit(0)}
        throw exn}}
    function parse_expand(l,f,msg)
     {try
       {var
         argv=[0,_q_],
         spec=[0,l],
         current$0=[0,current[1]],
         _mZ_=parse_and_expand_argv_dynamic(current$0,argv,spec,f,msg);
        return _mZ_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_ba_),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_bb_),msg$1);return exit(0)}
        throw exn}}
    function second_word(s)
     {var len=caml_ml_string_length(s);
      function loop(n)
       {var n$0=n;
        for(;;)
         {if(len <= n$0)return len;
          if(32 === caml_string_get(s,n$0))
           {var n$1=n$0 + 1 | 0,n$0=n$1;continue}
          return n$0}}
      try
       {var n$0=index$0(s,9)}
      catch(_mX_)
       {_mX_ = caml_wrap_exception(_mX_);
        if(_mX_ === Not_found)
         {try
           {var n=index$0(s,32)}
          catch(_mY_)
           {_mY_ = caml_wrap_exception(_mY_);
            if(_mY_ === Not_found)return len;
            throw _mY_}
          return loop(n + 1 | 0)}
        throw _mX_}
      return loop(n$0 + 1 | 0)}
    function max_arg_len(cur,param)
     {var doc=param[3],spec=param[2],kwd=param[1];
      return 11 === spec[0]
              ?max(cur,caml_ml_string_length(kwd))
              :max(cur,caml_ml_string_length(kwd) + second_word(doc) | 0)}
    function replace_leading_tab(s)
     {var seen=[0,0];
      return map$1
              (function(c)
                {if(9 === c)if(! seen[1]){seen[1] = 1;return 32}return c},
               s)}
    function align(opt,speclist)
     {if(opt)var sth=opt[1],limit=sth;else var limit=max_int;
      var
       completed=add_help(speclist),
       len=fold_left(max_arg_len,0,completed),
       len$0=min(len,limit);
      return map
              (function(ksd)
                {var _mV_=ksd[2],_mW_=ksd[1];
                 if(caml_string_notequal(ksd[3],cst$58))
                  {if(11 === _mV_[0])
                    {var
                      msg$0=ksd[3],
                      cutcol$0=second_word(msg$0),
                      spaces$0=make$0(max(0,len$0 - cutcol$0 | 0) + 3 | 0,32);
                     return [0,
                             _mW_,
                             _mV_,
                             symbol(cst$59,symbol(spaces$0,replace_leading_tab(msg$0)))]}
                   var
                    msg=ksd[3],
                    cutcol=second_word(msg),
                    kwd_len=caml_ml_string_length(_mW_),
                    diff=(len$0 - kwd_len | 0) - cutcol | 0;
                   if(0 < diff)
                    {var
                      spaces=make$0(diff,32),
                      prefix=sub$0(replace_leading_tab(msg),0,cutcol),
                      suffix=
                       sub$0(msg,cutcol,caml_ml_string_length(msg) - cutcol | 0);
                     return [0,_mW_,_mV_,symbol(prefix,symbol(spaces,suffix))]}
                   return [0,_mW_,_mV_,replace_leading_tab(msg)]}
                 return ksd},
               completed)}
    function read_aux(trim,sep,file)
     {var ic=open_in_bin(file),buf=create$1(200),words=[0,0];
      function stash(param)
       {var s=contents(buf);
        if(trim)
         {var len=caml_ml_string_length(s);
          if(0 < len)
           if(13 === caml_string_get(s,len - 1 | 0))
            var _mU_=sub$0(s,0,len - 1 | 0),switch$0=1;
           else
            var switch$0=0;
          else
           var switch$0=0;
          if(! switch$0)var _mU_=s;
          var word=_mU_}
        else
         var word=s;
        words[1] = [0,word,words[1]];
        return clear$1(buf)}
      function read(param)
       {try
         {var
           c=caml_ml_input_char(ic),
           _mS_=c === sep?(stash(0),read(0)):(add_char(buf,c),read(0));
          return _mS_}
        catch(_mT_)
         {_mT_ = caml_wrap_exception(_mT_);
          if(_mT_ === End_of_file)
           {var _mR_=0 < buf[2]?1:0;return _mR_?stash(0):_mR_}
          throw _mT_}}
      read(0);
      caml_ml_close_channel(ic);
      return of_list(rev(words[1]))}
    var _bc_=10,_bd_=1;
    function read_arg(_mQ_){return read_aux(_bd_,_bc_,_mQ_)}
    var _be_=0,_bf_=0;
    function read_arg0(_mP_){return read_aux(_bf_,_be_,_mP_)}
    function write_aux(sep,file,args)
     {var oc=open_out_bin(file);
      iter$2(function(s){return caml_call2(fprintf(oc,_bg_),s,sep)},args);
      return close_out(oc)}
    var _bh_=10;
    function write_arg(_mN_,_mO_){return write_aux(_bh_,_mN_,_mO_)}
    var _bi_=0;
    function write_arg0(_mL_,_mM_){return write_aux(_bi_,_mL_,_mM_)}
    var
     Arg=
      [0,
       parse,
       parse_dynamic,
       parse_argv,
       parse_argv_dynamic,
       parse_and_expand_argv_dynamic,
       parse_expand,
       Help,
       Bad,
       usage,
       usage_string,
       align,
       current,
       read_arg,
       read_arg0,
       write_arg,
       write_arg0];
    caml_register_global(670,Arg,"Arg");
    var printers=[0,0];
    function field(x,i)
     {var f=x[1 + i];
      return is_block(f)
              ?caml_obj_tag(f) === 252
                ?caml_call1(sprintf(_bj_),f)
                :caml_obj_tag(f) === 253?string_of_float(f):cst$60
              :caml_call1(sprintf(_bk_),f)}
    function other_fields(x,i)
     {if(x.length - 1 <= i)return cst$61;
      var _mJ_=other_fields(x,i + 1 | 0),_mK_=field(x,i);
      return caml_call2(sprintf(_bl_),_mK_,_mJ_)}
    function fields(x)
     {var match=x.length - 1;
      if(2 < match >>> 0)
       {var _mG_=other_fields(x,2),_mH_=field(x,1);
        return caml_call2(sprintf(_bm_),_mH_,_mG_)}
      switch(match)
       {case 0:return cst$62;
        case 1:return cst$63;
        default:var _mI_=field(x,1);return caml_call1(sprintf(_bn_),_mI_)}}
    function to_string$3(x)
     {function conv(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var tl=param$0[2],hd=param$0[1];
            try {var _mE_=caml_call1(hd,x),_mD_=_mE_}catch(_mF_){var _mD_=0}
            if(_mD_){var s=_mD_[1];return s}
            var param$0=tl;
            continue}
          if(x === Out_of_memory)return cst_Out_of_memory;
          if(x === Stack_overflow)return cst_Stack_overflow;
          if(x[1] === Match_failure)
           {var match=x[2],char$0=match[3],line=match[2],file=match[1];
            return caml_call5
                    (sprintf(locfmt),
                     file,
                     line,
                     char$0,
                     char$0 + 5 | 0,
                     cst_Pattern_matching_failed)}
          if(x[1] === Assert_failure)
           {var
             match$0=x[2],
             char$1=match$0[3],
             line$0=match$0[2],
             file$0=match$0[1];
            return caml_call5
                    (sprintf(locfmt),
                     file$0,
                     line$0,
                     char$1,
                     char$1 + 6 | 0,
                     cst_Assertion_failed)}
          if(x[1] === Undefined_recursive_module)
           {var
             match$1=x[2],
             char$2=match$1[3],
             line$1=match$1[2],
             file$1=match$1[1];
            return caml_call5
                    (sprintf(locfmt),
                     file$1,
                     line$1,
                     char$2,
                     char$2 + 6 | 0,
                     cst_Undefined_recursive_module)}
          if(0 === caml_obj_tag(x))
           {var constructor=x[1][1];return symbol(constructor,fields(x))}
          return x[1]}}
      return conv(printers[1])}
    function print(fct,arg)
     {try
       {var _mC_=caml_call1(fct,arg);return _mC_}
      catch(x)
       {x = caml_wrap_exception(x);
        var _mB_=to_string$3(x);
        caml_call1(eprintf(_bo_),_mB_);
        caml_ml_flush(stderr);
        throw x}}
    function catch$0(fct,arg)
     {try
       {var _mA_=caml_call1(fct,arg);return _mA_}
      catch(x)
       {x = caml_wrap_exception(x);
        caml_ml_flush(stdout);
        var _mz_=to_string$3(x);
        caml_call1(eprintf(_bp_),_mz_);
        return exit(2)}}
    function convert_raw_backtrace(bt)
     {return [0,runtime.caml_convert_raw_backtrace(bt)]}
    function format_backtrace_slot(pos,slot)
     {function info(is_raise)
       {return is_raise
                ?0 === pos?cst_Raised_at:cst_Re_raised_at
                :0 === pos
                  ?cst_Raised_by_primitive_operation_at
                  :cst_Called_from}
      if(0 === slot[0])
       {var
         _ms_=slot[5],
         _mt_=slot[4],
         _mu_=slot[3],
         _mv_=slot[6]?cst_inlined:cst$64,
         _mw_=slot[2],
         _mx_=info(slot[1]);
        return [0,caml_call6(sprintf(_bq_),_mx_,_mw_,_mv_,_mu_,_mt_,_ms_)]}
      if(slot[1])return 0;
      var _my_=info(0);
      return [0,caml_call1(sprintf(_br_),_my_)]}
    function print_raw_backtrace(outchan,raw_backtrace)
     {var backtrace=convert_raw_backtrace(raw_backtrace);
      if(backtrace)
       {var a=backtrace[1],_mq_=a.length - 1 - 1 | 0,_mp_=0;
        if(! (_mq_ < 0))
         {var i=_mp_;
          for(;;)
           {var match=format_backtrace_slot(i,caml_check_bound(a,i)[1 + i]);
            if(match){var str=match[1];caml_call1(fprintf(outchan,_bs_),str)}
            var _mr_=i + 1 | 0;
            if(_mq_ !== i){var i=_mr_;continue}
            break}}
        return 0}
      return fprintf(outchan,_bt_)}
    function print_backtrace(outchan)
     {return print_raw_backtrace(outchan,caml_get_exception_raw_backtrace(0))}
    function raw_backtrace_to_string(raw_backtrace)
     {var backtrace=convert_raw_backtrace(raw_backtrace);
      if(backtrace)
       {var a=backtrace[1],b=create$1(1024),_mn_=a.length - 1 - 1 | 0,_mm_=0;
        if(! (_mn_ < 0))
         {var i=_mm_;
          for(;;)
           {var match=format_backtrace_slot(i,caml_check_bound(a,i)[1 + i]);
            if(match){var str=match[1];caml_call1(bprintf(b,_bu_),str)}
            var _mo_=i + 1 | 0;
            if(_mn_ !== i){var i=_mo_;continue}
            break}}
        return contents(b)}
      return cst_Program_not_linked_with_g_cannot_print_stack_backtrace}
    function backtrace_slot_is_raise(param)
     {return 0 === param[0]?param[1]:param[1]}
    function backtrace_slot_is_inline(param){return 0 === param[0]?param[6]:0}
    function backtrace_slot_location(param)
     {return 0 === param[0]?[0,[0,param[2],param[3],param[4],param[5]]]:0}
    function backtrace_slots(raw_backtrace)
     {var match=convert_raw_backtrace(raw_backtrace);
      if(match)
       {var backtrace=match[1],i$1=backtrace.length - 1 - 1 | 0,i=i$1;
        for(;;)
         {if(-1 === i)
           var _ml_=0;
          else
           {var
             param=caml_check_bound(backtrace,i)[1 + i],
             _mk_=0 === param[0]?1:0;
            if(! _mk_){var i$0=i - 1 | 0,i=i$0;continue}
            var _ml_=_mk_}
          return _ml_?[0,backtrace]:0}}
      return 0}
    function get_backtrace(param)
     {return raw_backtrace_to_string(caml_get_exception_raw_backtrace(0))}
    function register_printer(fn){printers[1] = [0,fn,printers[1]];return 0}
    function exn_slot(x){return 0 === caml_obj_tag(x)?x[1]:x}
    function exn_slot_id(x){var slot=exn_slot(x);return slot[2]}
    function exn_slot_name(x){var slot=exn_slot(x);return slot[1]}
    var uncaught_exception_handler=[0,0];
    function set_uncaught_exception_handler(fn)
     {uncaught_exception_handler[1] = [0,fn];return 0}
    function _bv_(_mj_){return runtime.caml_raw_backtrace_next_slot(_mj_)}
    function _bw_(_mi_){return runtime.caml_convert_raw_backtrace_slot(_mi_)}
    function _bx_(_mh_,_mg_)
     {return runtime.caml_raw_backtrace_slot(_mh_,_mg_)}
    function _by_(_mf_){return runtime.caml_raw_backtrace_length(_mf_)}
    var
     _bz_=
      [0,
       backtrace_slot_is_raise,
       backtrace_slot_is_inline,
       backtrace_slot_location,
       format_backtrace_slot];
    function _bA_(_me_){return runtime.caml_get_current_callstack(_me_)}
    function _bB_(_md_){return caml_get_exception_raw_backtrace(_md_)}
    function _bC_(_mc_){return runtime.caml_backtrace_status(_mc_)}
    var
     Printexc=
      [0,
       to_string$3,
       print,
       catch$0,
       print_backtrace,
       get_backtrace,
       function(_mb_){return runtime.caml_record_backtrace(_mb_)},
       _bC_,
       register_printer,
       _bB_,
       print_raw_backtrace,
       raw_backtrace_to_string,
       _bA_,
       set_uncaught_exception_handler,
       backtrace_slots,
       _bz_,
       _by_,
       _bx_,
       _bw_,
       _bv_,
       exn_slot_id,
       exn_slot_name];
    caml_register_global(675,Printexc,"Printexc");
    function print_stat(c)
     {var st=runtime.caml_gc_stat(0),_lW_=st[4];
      caml_call1(fprintf(c,_bD_),_lW_);
      var _lX_=st[5];
      caml_call1(fprintf(c,_bE_),_lX_);
      var _lY_=st[14];
      caml_call1(fprintf(c,_bF_),_lY_);
      fprintf(c,_bG_);
      var
       _lZ_=st[1],
       l1=caml_ml_string_length(caml_call1(sprintf(_bH_),_lZ_)),
       _l0_=st[1];
      caml_call2(fprintf(c,_bI_),l1,_l0_);
      var _l1_=st[2];
      caml_call2(fprintf(c,_bJ_),l1,_l1_);
      var _l2_=st[3];
      caml_call2(fprintf(c,_bK_),l1,_l2_);
      fprintf(c,_bL_);
      var
       _l3_=st[15],
       l2=caml_ml_string_length(caml_call1(sprintf(_bM_),_l3_)),
       _l4_=st[15];
      caml_call2(fprintf(c,_bN_),l2,_l4_);
      var _l5_=st[6];
      caml_call2(fprintf(c,_bO_),l2,_l5_);
      var _l6_=st[8];
      caml_call2(fprintf(c,_bP_),l2,_l6_);
      var _l7_=st[10];
      caml_call2(fprintf(c,_bQ_),l2,_l7_);
      var _l8_=st[12];
      caml_call2(fprintf(c,_bR_),l2,_l8_);
      var _l9_=st[13];
      caml_call2(fprintf(c,_bS_),l2,_l9_);
      fprintf(c,_bT_);
      var _l__=st[9];
      caml_call1(fprintf(c,_bU_),_l__);
      var _l$_=st[11];
      caml_call1(fprintf(c,_bV_),_l$_);
      var _ma_=st[7];
      return caml_call1(fprintf(c,_bW_),_ma_)}
    function allocated_bytes(param)
     {var
       match=runtime.caml_gc_counters(0),
       ma=match[3],
       pro=match[2],
       mi=match[1];
      return (mi + ma - pro) * 4}
    function create_alarm(f){return [0,1]}
    function delete_alarm(a){a[1] = 0;return 0}
    function _bX_(_lV_){return runtime.caml_final_release(_lV_)}
    function _bY_(_lU_,_lT_)
     {return runtime.caml_final_register_called_without_value(_lU_,_lT_)}
    var
     Gc=
      [0,
       print_stat,
       allocated_bytes,
       function(_lS_,_lR_){return runtime.caml_final_register(_lS_,_lR_)},
       _bY_,
       _bX_,
       create_alarm,
       delete_alarm];
    caml_register_global(676,Gc,"Gc");
    function string(str)
     {return caml_md5_string(str,0,caml_ml_string_length(str))}
    function bytes(b){return string(b)}
    function substring(str,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_string_length(str) - len | 0) < ofs))
         return caml_md5_string(str,ofs,len);
      return invalid_arg(cst_Digest_substring)}
    function subbytes(b,ofs,len){return substring(b,ofs,len)}
    function file(filename)
     {var ic=open_in_bin(filename);
      try
       {var d=runtime.caml_md5_chan(ic,-1)}
      catch(e){e = caml_wrap_exception(e);caml_ml_close_channel(ic);throw e}
      caml_ml_close_channel(ic);
      return d}
    function output$0(chan,digest){return output_string(chan,digest)}
    function input$0(chan){return really_input_string(chan,16)}
    function char_hex(n){var _lQ_=10 <= n?87:48;return n + _lQ_ | 0}
    function to_hex(d)
     {if(16 !== caml_ml_string_length(d))invalid_arg(cst_Digest_to_hex);
      var result=caml_create_bytes(32),i=0;
      for(;;)
       {var x=caml_string_get(d,i);
        caml_bytes_unsafe_set(result,i * 2 | 0,char_hex(x >>> 4 | 0));
        caml_bytes_unsafe_set(result,(i * 2 | 0) + 1 | 0,char_hex(x & 15));
        var _lP_=i + 1 | 0;
        if(15 !== i){var i=_lP_;continue}
        return result}}
    function from_hex(s)
     {if(32 !== caml_ml_string_length(s))invalid_arg(cst_Digest_from_hex);
      function digit(c)
       {if(65 <= c)
         {if(97 <= c)
           {if(! (103 <= c))return (c - 97 | 0) + 10 | 0}
          else
           if(! (71 <= c))return (c - 65 | 0) + 10 | 0}
        else
         {var switcher=c - 48 | 0;if(! (9 < switcher >>> 0))return c - 48 | 0}
        throw [0,Invalid_argument,cst_Digest_from_hex$0]}
      var result=caml_create_bytes(16),i=0;
      for(;;)
       {var i$0=2 * i | 0,_lN_=digit(caml_string_get(s,i$0 + 1 | 0));
        caml_bytes_set
         (result,i,chr((digit(caml_string_get(s,i$0)) << 4) + _lN_ | 0));
        var _lO_=i + 1 | 0;
        if(15 !== i){var i=_lO_;continue}
        return result}}
    var
     Digest=
      [0,
       compare$2,
       equal$2,
       string,
       bytes,
       substring,
       subbytes,
       file,
       output$0,
       input$0,
       to_hex,
       from_hex];
    caml_register_global(677,Digest,"Digest");
    function new_state(param){return [0,caml_make_vect(55,0),0]}
    function assign(st1,st2)
     {blit$1(st2[1],0,st1[1],0,55);st1[2] = st2[2];return 0}
    function full_init(s,seed)
     {var seed$0=0 === seed.length - 1?[0,0]:seed,l=seed$0.length - 1,i$0=0;
      for(;;)
       {caml_check_bound(s[1],i$0)[1 + i$0] = i$0;
        var _lM_=i$0 + 1 | 0;
        if(54 !== i$0){var i$0=_lM_;continue}
        var accu=[0,cst_x$1],_lI_=54 + max(55,l) | 0,_lH_=0;
        if(! (_lI_ < 0))
         {var i=_lH_;
          for(;;)
           {var
             j=i % 55 | 0,
             k=caml_mod(i,l),
             x=caml_check_bound(seed$0,k)[1 + k];
            accu[1] = string(symbol(accu[1],caml_new_string("" + x)));
            var
             _lJ_=accu[1],
             _lD_=caml_string_get(_lJ_,3) << 24,
             _lE_=caml_string_get(_lJ_,2) << 16,
             _lF_=caml_string_get(_lJ_,1) << 8,
             _lG_=((caml_string_get(_lJ_,0) + _lF_ | 0) + _lE_ | 0) + _lD_ | 0,
             _lK_=(caml_check_bound(s[1],j)[1 + j] ^ _lG_) & 1073741823;
            caml_check_bound(s[1],j)[1 + j] = _lK_;
            var _lL_=i + 1 | 0;
            if(_lI_ !== i){var i=_lL_;continue}
            break}}
        s[2] = 0;
        return 0}}
    function make$1(seed)
     {var result=new_state(0);full_init(result,seed);return result}
    function make_self_init(param){return make$1(caml_sys_random_seed(0))}
    function copy$4(s){var result=new_state(0);assign(result,s);return result}
    function bits(s)
     {s[2] = (s[2] + 1 | 0) % 55 | 0;
      var
       _lA_=s[2],
       curval=caml_check_bound(s[1],_lA_)[1 + _lA_],
       _lB_=(s[2] + 24 | 0) % 55 | 0,
       newval=
        caml_check_bound(s[1],_lB_)[1 + _lB_]
        +
        (curval ^ (curval >>> 25 | 0) & 31)
        |
        0,
       newval30=newval & 1073741823,
       _lC_=s[2];
      caml_check_bound(s[1],_lC_)[1 + _lC_] = newval30;
      return newval30}
    function int$0(s,bound)
     {if(! (1073741823 < bound))
       if(0 < bound)
        for(;;)
         {var r=bits(s),v=caml_mod(r,bound);
          if(((1073741823 - bound | 0) + 1 | 0) < (r - v | 0))continue;
          return v}
      return invalid_arg(cst_Random_int)}
    function int32(s,bound)
     {if(caml_lessequal(bound,0))return invalid_arg(cst_Random_int32);
      for(;;)
       {var b1=bits(s),b2=(bits(s) & 1) << 30,r=b1 | b2,v=caml_mod(r,bound);
        if(caml_greaterthan(r - v | 0,(2147483647 - bound | 0) + 1 | 0))
         continue;
        return v}}
    function int64(s,bound)
     {if(caml_lessequal(bound,_b0_))return invalid_arg(cst_Random_int64);
      for(;;)
       {var
         b1=caml_int64_of_int32(bits(s)),
         b2=caml_int64_shift_left(caml_int64_of_int32(bits(s)),30),
         b3=caml_int64_shift_left(caml_int64_of_int32(bits(s) & 7),60),
         r=caml_int64_or(b1,caml_int64_or(b2,b3)),
         v=runtime.caml_int64_mod(r,bound);
        if
         (caml_greaterthan
           (caml_int64_sub(r,v),
            caml_int64_add(caml_int64_sub(max_int$1,bound),_bZ_)))
         continue;
        return v}}
    function nativeint(s,bound){return int32(s,bound)}
    function float$0(s,bound)
     {var r1=bits(s),r2=bits(s);
      return (r1 / 1073741824. + r2) / 1073741824. * bound}
    function bool(s){return 0 === (bits(s) & 1)?1:0}
    var default$0=[0,_b1_.slice(),0];
    function bits$0(param){return bits(default$0)}
    function int$1(bound){return int$0(default$0,bound)}
    function int32$0(bound){return int32(default$0,bound)}
    function nativeint$0(bound){return nativeint(default$0,bound)}
    function int64$0(bound){return int64(default$0,bound)}
    function float$1(scale){return float$0(default$0,scale)}
    function bool$0(param){return bool(default$0)}
    function full_init$0(seed){return full_init(default$0,seed)}
    function init$3(seed){return full_init(default$0,[0,seed])}
    function self_init(param){return full_init$0(caml_sys_random_seed(0))}
    function get_state(param){return copy$4(default$0)}
    function set_state(s){return assign(default$0,s)}
    var
     _b2_=
      [0,
       make$1,
       make_self_init,
       copy$4,
       bits,
       int$0,
       int32,
       nativeint,
       int64,
       float$0,
       bool],
     Random=
      [0,
       init$3,
       full_init$0,
       self_init,
       bits$0,
       int$1,
       int32$0,
       nativeint$0,
       int64$0,
       float$1,
       bool$0,
       _b2_,
       get_state,
       set_state];
    caml_register_global(678,Random,"Random");
    function hash$0(x){return caml_hash(10,100,0,x)}
    function hash_param(n1,n2,x){return caml_hash(n1,n2,0,x)}
    function seeded_hash(seed,x){return caml_hash(10,100,seed,x)}
    function ongoing_traversal(h)
     {var _ly_=h.length - 1 < 4?1:0,_lz_=_ly_ || (h[4] < 0?1:0);return _lz_}
    function flip_ongoing_traversal(h){h[4] = - h[4] | 0;return 0}
    try
     {var _cH_=caml_sys_getenv(cst_OCAMLRUNPARAM),params=_cH_}
    catch(_lw_)
     {_lw_ = caml_wrap_exception(_lw_);
      if(_lw_ !== Not_found)throw _lw_;
      try
       {var _cG_=caml_sys_getenv(cst_CAMLRUNPARAM),_b3_=_cG_}
      catch(_lx_)
       {_lx_ = caml_wrap_exception(_lx_);
        if(_lx_ !== Not_found)throw _lx_;
        var _b3_=cst$65}
      var params=_b3_}
    var
     randomized_default=contains$0(params,82),
     randomized=[0,randomized_default];
    function randomize(param){randomized[1] = 1;return 0}
    function is_randomized(param){return randomized[1]}
    var prng=[246,function(_lv_){return caml_call1(_b2_[2],0)}];
    function create$2(opt,initial_size)
     {if(opt)var sth=opt[1],random=sth;else var random=randomized[1];
      var x=16;
      for(;;)
       {if(! (initial_size <= x))
         if(! (max_array_length < (x * 2 | 0)))
          {var x$0=x * 2 | 0,x=x$0;continue}
        if(random)
         var
          _lt_=caml_obj_tag(prng),
          _lu_=250 === _lt_?prng[1]:246 === _lt_?force_lazy_block(prng):prng,
          seed=caml_call1(_b2_[4],_lu_);
        else
         var seed=0;
        return [0,0,caml_make_vect(x,0),seed,x]}}
    function clear$2(h)
     {h[1] = 0;
      var len=h[2].length - 1,_lr_=len - 1 | 0,_lq_=0;
      if(! (_lr_ < 0))
       {var i=_lq_;
        for(;;)
         {caml_check_bound(h[2],i)[1 + i] = 0;
          var _ls_=i + 1 | 0;
          if(_lr_ !== i){var i=_ls_;continue}
          break}}
      return 0}
    function reset$0(h)
     {var len=h[2].length - 1;
      if(4 <= h.length - 1)
       if(len !== abs(h[4]))
        {h[1] = 0;h[2] = caml_make_vect(abs(h[4]),0);return 0}
      return clear$2(h)}
    function copy_bucketlist(param)
     {if(param)
       {var
         key=param[1],
         data=param[2],
         next=param[3],
         prec$0=[0,key,data,next],
         prec=prec$0,
         param$0=next;
        for(;;)
         {if(param$0)
           {var
             key$0=param$0[1],
             data$0=param$0[2],
             next$0=param$0[3],
             r=[0,key$0,data$0,next$0];
            if(prec){prec[3] = r;var prec=r,param$0=next$0;continue}
            throw [0,Assert_failure,_b4_]}
          return prec$0}}
      return 0}
    function copy$5(init)
     {var _ln_=init[4],_lo_=init[3],_lp_=map$2(copy_bucketlist,init[2]);
      return [0,init[1],_lp_,_lo_,_ln_]}
    function length$4(h){return h[1]}
    function resize$0(indexfun,h)
     {var
       odata=h[2],
       osize=odata.length - 1,
       nsize=osize * 2 | 0,
       _le_=nsize < max_array_length?1:0;
      if(_le_)
       {var
         ndata=caml_make_vect(nsize,0),
         ndata_tail=caml_make_vect(nsize,0),
         inplace=1 - ongoing_traversal(h);
        h[2] = ndata;
        var _lg_=osize - 1 | 0,_lf_=0;
        if(! (_lg_ < 0))
         {var i$0=_lf_;
          a:
          for(;;)
           {var cell$1=caml_check_bound(odata,i$0)[1 + i$0],cell=cell$1;
            for(;;)
             {if(cell)
               {var
                 key=cell[1],
                 data=cell[2],
                 next=cell[3],
                 cell$0=inplace?cell:[0,key,data,0],
                 nidx=caml_call2(indexfun,h,key),
                 match=caml_check_bound(ndata_tail,nidx)[1 + nidx];
                if(match)
                 match[3] = cell$0;
                else
                 caml_check_bound(ndata,nidx)[1 + nidx] = cell$0;
                caml_check_bound(ndata_tail,nidx)[1 + nidx] = cell$0;
                var cell=next;
                continue}
              var _lm_=i$0 + 1 | 0;
              if(_lg_ !== i$0){var i$0=_lm_;continue a}
              break}
            break}}
        if(inplace)
         {var _li_=nsize - 1 | 0,_lh_=0;
          if(! (_li_ < 0))
           {var i=_lh_;
            for(;;)
             {var match$0=caml_check_bound(ndata_tail,i)[1 + i];
              if(match$0)match$0[3] = 0;
              var _ll_=i + 1 | 0;
              if(_li_ !== i){var i=_ll_;continue}
              break}}
          var _lj_=0}
        else
         var _lj_=inplace;
        var _lk_=_lj_}
      else
       var _lk_=_le_;
      return _lk_}
    function key_index(h,key)
     {return 3 <= h.length - 1
              ?caml_hash(10,100,h[3],key) & (h[2].length - 1 - 1 | 0)
              :caml_mod
                (runtime.caml_hash_univ_param(10,100,key),h[2].length - 1)}
    function add$0(h,key,data)
     {var
       i=key_index(h,key),
       bucket=[0,key,data,caml_check_bound(h[2],i)[1 + i]];
      caml_check_bound(h[2],i)[1 + i] = bucket;
      h[1] = h[1] + 1 | 0;
      var _ld_=h[2].length - 1 << 1 < h[1]?1:0;
      return _ld_?resize$0(key_index,h):_ld_}
    function remove(h,key)
     {var i=key_index(h,key),c$0=caml_check_bound(h[2],i)[1 + i],prec=0,c=c$0;
      for(;;)
       {if(c)
         {var k=c[1],next=c[3];
          if(0 === caml_compare(k,key))
           {h[1] = h[1] - 1 | 0;
            return prec
                    ?(prec[3] = next,0)
                    :(caml_check_bound(h[2],i)[1 + i] = next,0)}
          var prec=c,c=next;
          continue}
        return 0}}
    function find$0(h,key)
     {var _lc_=key_index(h,key),match=caml_check_bound(h[2],_lc_)[1 + _lc_];
      if(match)
       {var k1=match[1],d1=match[2],next1=match[3];
        if(0 === caml_compare(key,k1))return d1;
        if(next1)
         {var k2=next1[1],d2=next1[2],next2=next1[3];
          if(0 === caml_compare(key,k2))return d2;
          if(next2)
           {var k3=next2[1],d3=next2[2],next3=next2[3];
            if(0 === caml_compare(key,k3))return d3;
            var param=next3;
            for(;;)
             {if(param)
               {var k=param[1],data=param[2],next=param[3];
                if(0 === caml_compare(key,k))return data;
                var param=next;
                continue}
              throw Not_found}}
          throw Not_found}
        throw Not_found}
      throw Not_found}
    function find_opt$0(h,key)
     {var _lb_=key_index(h,key),match=caml_check_bound(h[2],_lb_)[1 + _lb_];
      if(match)
       {var k1=match[1],d1=match[2],next1=match[3];
        if(0 === caml_compare(key,k1))return [0,d1];
        if(next1)
         {var k2=next1[1],d2=next1[2],next2=next1[3];
          if(0 === caml_compare(key,k2))return [0,d2];
          if(next2)
           {var k3=next2[1],d3=next2[2],next3=next2[3];
            if(0 === caml_compare(key,k3))return [0,d3];
            var param=next3;
            for(;;)
             {if(param)
               {var k=param[1],data=param[2],next=param[3];
                if(0 === caml_compare(key,k))return [0,data];
                var param=next;
                continue}
              return 0}}
          return 0}
        return 0}
      return 0}
    function find_all$0(h,key)
     {function find_in_bucket(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var k=param$0[1],data=param$0[2],next=param$0[3];
            if(0 === caml_compare(k,key))return [0,data,find_in_bucket(next)];
            var param$0=next;
            continue}
          return 0}}
      var _la_=key_index(h,key);
      return find_in_bucket(caml_check_bound(h[2],_la_)[1 + _la_])}
    function replace(h,key,data)
     {var
       i=key_index(h,key),
       param$0=caml_check_bound(h[2],i)[1 + i],
       param=param$0;
      for(;;)
       {if(param)
         {var k=param[1],next=param[3];
          if(0 !== caml_compare(k,key)){var param=next;continue}
          param[1] = key;
          param[2] = data;
          var _k9_=0}
        else
         var _k9_=1;
        if(_k9_)
         {caml_check_bound(h[2],i)[1 + i] = [0,key,data,param$0];
          h[1] = h[1] + 1 | 0;
          var _k__=h[2].length - 1 << 1 < h[1]?1:0;
          if(_k__)return resize$0(key_index,h);
          var _k$_=_k__}
        else
         var _k$_=_k9_;
        return _k$_}}
    function mem$1(h,key)
     {var
       _k8_=key_index(h,key),
       param$0=caml_check_bound(h[2],_k8_)[1 + _k8_],
       param=param$0;
      for(;;)
       {if(param)
         {var k=param[1],next=param[3],_k7_=0 === caml_compare(k,key)?1:0;
          if(_k7_)return _k7_;
          var param=next;
          continue}
        return 0}}
    function iter$6(f,h)
     {function do_bucket(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var key=param$0[1],data=param$0[2],next=param$0[3];
            caml_call2(f,key,data);
            var param$0=next;
            continue}
          return 0}}
      var old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var d=h[2],_k3_=d.length - 1 - 1 | 0,_k2_=0;
        if(! (_k3_ < 0))
         {var i=_k2_;
          for(;;)
           {do_bucket(caml_check_bound(d,i)[1 + i]);
            var _k6_=i + 1 | 0;
            if(_k3_ !== i){var i=_k6_;continue}
            break}}
        var _k4_=1 - old_trav,_k5_=_k4_?flip_ongoing_traversal(h):_k4_;
        return _k5_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function filter_map_inplace_bucket(f,h,i,prec,slot)
     {var prec$0=prec,slot$0=slot;
      for(;;)
       {if(slot$0)
         {var
           key=slot$0[1],
           data=slot$0[2],
           next=slot$0[3],
           match=caml_call2(f,key,data);
          if(match)
           {var data$0=match[1];
            if(prec$0)
             prec$0[3] = slot$0;
            else
             caml_check_bound(h[2],i)[1 + i] = slot$0;
            slot$0[2] = data$0;
            var prec$0=slot$0,slot$0=next;
            continue}
          h[1] = h[1] - 1 | 0;
          var slot$0=next;
          continue}
        return prec$0
                ?(prec$0[3] = 0,0)
                :(caml_check_bound(h[2],i)[1 + i] = 0,0)}}
    function filter_map_inplace(f,h)
     {var d=h[2],old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var _kZ_=d.length - 1 - 1 | 0,_kY_=0;
        if(! (_kZ_ < 0))
         {var i=_kY_;
          for(;;)
           {filter_map_inplace_bucket(f,h,i,0,caml_check_bound(h[2],i)[1 + i]);
            var _k1_=i + 1 | 0;
            if(_kZ_ !== i){var i=_k1_;continue}
            break}}
        var _k0_=0;
        return _k0_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function fold$1(f,h,init)
     {function do_bucket(b,accu)
       {var b$0=b,accu$0=accu;
        for(;;)
         {if(b$0)
           {var
             key=b$0[1],
             data=b$0[2],
             next=b$0[3],
             accu$1=caml_call3(f,key,data,accu$0),
             b$0=next,
             accu$0=accu$1;
            continue}
          return accu$0}}
      var old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var d=h[2],accu=[0,init],_kU_=d.length - 1 - 1 | 0,_kT_=0;
        if(! (_kU_ < 0))
         {var i=_kT_;
          for(;;)
           {var _kW_=accu[1];
            accu[1] = do_bucket(caml_check_bound(d,i)[1 + i],_kW_);
            var _kX_=i + 1 | 0;
            if(_kU_ !== i){var i=_kX_;continue}
            break}}
        if(1 - old_trav)flip_ongoing_traversal(h);
        var _kV_=accu[1];
        return _kV_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function bucket_length(accu,param)
     {var accu$0=accu,param$0=param;
      for(;;)
       {if(param$0)
         {var
           param$1=param$0[3],
           accu$1=accu$0 + 1 | 0,
           accu$0=accu$1,
           param$0=param$1;
          continue}
        return accu$0}}
    function stats(h)
     {var
       _kQ_=h[2],
       _kR_=0,
       mbl=
        fold_left$0(function(m,b){return max(m,bucket_length(0,b))},_kR_,_kQ_),
       histo=caml_make_vect(mbl + 1 | 0,0),
       _kS_=h[2];
      iter$2
       (function(b)
         {var l=bucket_length(0,b);
          histo[1 + l] = caml_check_bound(histo,l)[1 + l] + 1 | 0;
          return 0},
        _kS_);
      return [0,h[1],h[2].length - 1,mbl,histo]}
    function MakeSeeded(H)
     {function key_index(h,key)
       {var _kP_=h[2].length - 1 - 1 | 0;
        return caml_call2(H[2],h[3],key) & _kP_}
      function add(h,key,data)
       {var
         i=key_index(h,key),
         bucket=[0,key,data,caml_check_bound(h[2],i)[1 + i]];
        caml_check_bound(h[2],i)[1 + i] = bucket;
        h[1] = h[1] + 1 | 0;
        var _kO_=h[2].length - 1 << 1 < h[1]?1:0;
        return _kO_?resize$0(key_index,h):_kO_}
      function remove(h,key)
       {var
         i=key_index(h,key),
         c$0=caml_check_bound(h[2],i)[1 + i],
         prec=0,
         c=c$0;
        for(;;)
         {if(c)
           {var k=c[1],next=c[3];
            if(caml_call2(H[1],k,key))
             {h[1] = h[1] - 1 | 0;
              return prec
                      ?(prec[3] = next,0)
                      :(caml_check_bound(h[2],i)[1 + i] = next,0)}
            var prec=c,c=next;
            continue}
          return 0}}
      function find(h,key)
       {var _kN_=key_index(h,key),match=caml_check_bound(h[2],_kN_)[1 + _kN_];
        if(match)
         {var k1=match[1],d1=match[2],next1=match[3];
          if(caml_call2(H[1],key,k1))return d1;
          if(next1)
           {var k2=next1[1],d2=next1[2],next2=next1[3];
            if(caml_call2(H[1],key,k2))return d2;
            if(next2)
             {var k3=next2[1],d3=next2[2],next3=next2[3];
              if(caml_call2(H[1],key,k3))return d3;
              var param=next3;
              for(;;)
               {if(param)
                 {var k=param[1],data=param[2],next=param[3];
                  if(caml_call2(H[1],key,k))return data;
                  var param=next;
                  continue}
                throw Not_found}}
            throw Not_found}
          throw Not_found}
        throw Not_found}
      function find_opt(h,key)
       {var _kM_=key_index(h,key),match=caml_check_bound(h[2],_kM_)[1 + _kM_];
        if(match)
         {var k1=match[1],d1=match[2],next1=match[3];
          if(caml_call2(H[1],key,k1))return [0,d1];
          if(next1)
           {var k2=next1[1],d2=next1[2],next2=next1[3];
            if(caml_call2(H[1],key,k2))return [0,d2];
            if(next2)
             {var k3=next2[1],d3=next2[2],next3=next2[3];
              if(caml_call2(H[1],key,k3))return [0,d3];
              var param=next3;
              for(;;)
               {if(param)
                 {var k=param[1],data=param[2],next=param[3];
                  if(caml_call2(H[1],key,k))return [0,data];
                  var param=next;
                  continue}
                return 0}}
            return 0}
          return 0}
        return 0}
      function find_all(h,key)
       {function find_in_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var k=param$0[1],d=param$0[2],next=param$0[3];
              if(caml_call2(H[1],k,key))return [0,d,find_in_bucket(next)];
              var param$0=next;
              continue}
            return 0}}
        var _kL_=key_index(h,key);
        return find_in_bucket(caml_check_bound(h[2],_kL_)[1 + _kL_])}
      function replace(h,key,data)
       {var
         i=key_index(h,key),
         param$0=caml_check_bound(h[2],i)[1 + i],
         param=param$0;
        for(;;)
         {if(param)
           {var k=param[1],next=param[3];
            if(! caml_call2(H[1],k,key)){var param=next;continue}
            param[1] = key;
            param[2] = data;
            var _kI_=0}
          else
           var _kI_=1;
          if(_kI_)
           {caml_check_bound(h[2],i)[1 + i] = [0,key,data,param$0];
            h[1] = h[1] + 1 | 0;
            var _kJ_=h[2].length - 1 << 1 < h[1]?1:0;
            if(_kJ_)return resize$0(key_index,h);
            var _kK_=_kJ_}
          else
           var _kK_=_kI_;
          return _kK_}}
      function mem(h,key)
       {var
         _kH_=key_index(h,key),
         param$0=caml_check_bound(h[2],_kH_)[1 + _kH_],
         param=param$0;
        for(;;)
         {if(param)
           {var k=param[1],next=param[3],_kG_=caml_call2(H[1],k,key);
            if(_kG_)return _kG_;
            var param=next;
            continue}
          return 0}}
      return [0,
              create$2,
              clear$2,
              reset$0,
              copy$5,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter$6,
              filter_map_inplace,
              fold$1,
              length$4,
              stats]}
    function Make(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       _kF_=include[1];
      function create(sz){return caml_call2(_kF_,_b5_,sz)}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats]}
    var
     Hashtbl=
      [0,
       create$2,
       clear$2,
       reset$0,
       copy$5,
       add$0,
       find$0,
       find_opt$0,
       find_all$0,
       mem$1,
       remove,
       replace,
       iter$6,
       filter_map_inplace,
       fold$1,
       length$4,
       randomize,
       is_randomized,
       stats,
       Make,
       MakeSeeded,
       hash$0,
       seeded_hash,
       hash_param,
       caml_hash];
    caml_register_global(679,Hashtbl,"Hashtbl");
    function length$5(x){return x.length - 1 - 2 | 0}
    function fill$1(ar,ofs,len,x)
     {if(0 <= ofs)
       if(0 <= len)
        if(! (length$5(ar) < (ofs + len | 0)))
         {var _kD_=(ofs + len | 0) - 1 | 0;
          if(! (_kD_ < ofs))
           {var i=ofs;
            for(;;)
             {caml_weak_set(ar,i,x);
              var _kE_=i + 1 | 0;
              if(_kD_ !== i){var i=_kE_;continue}
              break}}
          return 0}
      throw [0,Invalid_argument,cst_Weak_fill]}
    function Make$0(H)
     {var emptybucket=caml_weak_create(0);
      function get_index(t,h){return caml_mod(h & 2147483647,t[1].length - 1)}
      var limit=7;
      function create(sz)
       {var
         sz$0=7 <= sz?sz:7,
         sz$1=max_array_length < sz$0?max_array_length:sz$0;
        return [0,
                caml_make_vect(sz$1,emptybucket),
                caml_make_vect(sz$1,[0]),
                limit,
                0,
                0]}
      function clear(t)
       {var _kB_=t[1].length - 1 - 1 | 0,_kA_=0;
        if(! (_kB_ < 0))
         {var i=_kA_;
          for(;;)
           {caml_check_bound(t[1],i)[1 + i] = emptybucket;
            caml_check_bound(t[2],i)[1 + i] = [0];
            var _kC_=i + 1 | 0;
            if(_kB_ !== i){var i=_kC_;continue}
            break}}
        t[3] = limit;
        t[4] = 0;
        return 0}
      function fold(f,t,init)
       {var _kz_=t[1],i=0;
        return fold_right$0
                (function(b,accu$1)
                  {var i$0=i,accu=accu$1;
                   for(;;)
                    {if(length$5(b) <= i$0)return accu;
                     var match=caml_weak_get(b,i$0);
                     if(match)
                      {var
                        v=match[1],
                        accu$0=caml_call2(f,v,accu),
                        i$1=i$0 + 1 | 0,
                        i$0=i$1,
                        accu=accu$0;
                       continue}
                     var i$2=i$0 + 1 | 0,i$0=i$2;
                     continue}},
                 _kz_,
                 init)}
      function iter(f,t)
       {var _ky_=t[1],i=0;
        return iter$2
                (function(b)
                  {var i$0=i;
                   for(;;)
                    {if(length$5(b) <= i$0)return 0;
                     var match=caml_weak_get(b,i$0);
                     if(match)
                      {var v=match[1];
                       caml_call1(f,v);
                       var i$1=i$0 + 1 | 0,i$0=i$1;
                       continue}
                     var i$2=i$0 + 1 | 0,i$0=i$2;
                     continue}},
                 _ky_)}
      function count_bucket(i,b,accu)
       {var i$0=i,accu$0=accu;
        for(;;)
         {if(length$5(b) <= i$0)return accu$0;
          var
           _kx_=caml_weak_check(b,i$0)?1:0,
           accu$1=accu$0 + _kx_ | 0,
           i$1=i$0 + 1 | 0,
           i$0=i$1,
           accu$0=accu$1;
          continue}}
      function count(t)
       {var _ks_=0,_kt_=t[1],_ku_=0;
        return fold_right$0
                (function(_kv_,_kw_){return count_bucket(_ku_,_kv_,_kw_)},
                 _kt_,
                 _ks_)}
      function add_aux(t,setter,d,h,index)
       {var
         bucket$0=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket$0),
         i$3=0;
        for(;;)
         {if(sz <= i$3)
           {var
             newsz=
              min(((3 * sz | 0) / 2 | 0) + 3 | 0,max_array_length - 2 | 0);
            if(newsz <= sz)
             failwith(cst_Weak_Make_hash_bucket_cannot_grow_more);
            var
             newbucket=caml_weak_create(newsz),
             newhashes=caml_make_vect(newsz,0);
            caml_weak_blit(bucket$0,0,newbucket,0,sz);
            blit$1(hashes,0,newhashes,0,sz);
            caml_call3(setter,newbucket,sz,d);
            caml_check_bound(newhashes,sz)[1 + sz] = h;
            caml_check_bound(t[1],index)[1 + index] = newbucket;
            caml_check_bound(t[2],index)[1 + index] = newhashes;
            var _ko_=sz <= t[3]?1:0,_kp_=_ko_?t[3] < newsz?1:0:_ko_;
            if(_kp_)
             {t[4] = t[4] + 1 | 0;
              var i$4=0;
              for(;;)
               {var
                 _kh_=t[5],
                 bucket=caml_check_bound(t[1],_kh_)[1 + _kh_],
                 _ki_=t[5],
                 hbucket=caml_check_bound(t[2],_ki_)[1 + _ki_],
                 n=length$5(bucket),
                 prev_len=(((n - 3 | 0) * 2 | 0) + 2 | 0) / 3 | 0,
                 live=count_bucket(0,bucket,0);
                if(live <= prev_len)
                 {var j$2=length$5(bucket) - 1 | 0,i$0=0,j=j$2;
                  for(;;)
                   {if(prev_len <= j)
                     {if(caml_weak_check(bucket,i$0))
                       {var i$1=i$0 + 1 | 0,i$0=i$1;continue}
                      if(caml_weak_check(bucket,j))
                       {caml_weak_blit(bucket,j,bucket,i$0,1);
                        var _kj_=caml_check_bound(hbucket,j)[1 + j];
                        caml_check_bound(hbucket,i$0)[1 + i$0] = _kj_;
                        var j$0=j - 1 | 0,i$2=i$0 + 1 | 0,i$0=i$2,j=j$0;
                        continue}
                      var j$1=j - 1 | 0,j=j$1;
                      continue}
                    if(0 === prev_len)
                     {var _kk_=t[5];
                      caml_check_bound(t[1],_kk_)[1 + _kk_] = emptybucket;
                      var _kl_=t[5];
                      caml_check_bound(t[2],_kl_)[1 + _kl_] = [0]}
                    else
                     {caml_obj_truncate(bucket,prev_len + 2 | 0);
                      caml_obj_truncate(hbucket,prev_len)}
                    var _km_=t[3] < n?1:0,_kn_=_km_?prev_len <= t[3]?1:0:_km_;
                    if(_kn_)t[4] = t[4] - 1 | 0;
                    break}}
                t[5] = caml_mod(t[5] + 1 | 0,t[1].length - 1);
                var _kr_=i$4 + 1 | 0;
                if(2 !== i$4){var i$4=_kr_;continue}
                break}}
            var _kq_=((t[1].length - 1) / 2 | 0) < t[4]?1:0;
            if(_kq_)
             {var
               n$0=t[1].length - 1,
               newlen=min(((3 * n$0 | 0) / 2 | 0) + 3 | 0,max_array_length);
              if(n$0 < newlen)
               {var newt=create(newlen),_kg_=t[1],i=0;
                iteri$2
                 (function(j,ob)
                   {var i$0=i;
                    for(;;)
                     {if(length$5(ob) <= i$0)return 0;
                      var match=caml_weak_check(ob,i$0);
                      if(0 === match){var i$1=i$0 + 1 | 0,i$0=i$1;continue}
                      var
                       oh=caml_check_bound(t[2],j)[1 + j],
                       setter$0=
                        function(i)
                         {function setter(nb,ni,param)
                           {return caml_weak_blit(ob,i,nb,ni,1)}
                          return setter},
                       setter=setter$0(i$0),
                       h=caml_check_bound(oh,i$0)[1 + i$0];
                      add_aux(newt,setter,0,h,get_index(newt,h));
                      var i$2=i$0 + 1 | 0,i$0=i$2;
                      continue}},
                  _kg_);
                t[1] = newt[1];
                t[2] = newt[2];
                t[3] = newt[3];
                t[4] = newt[4];
                t[5] = caml_mod(t[5],newt[1].length - 1);
                return 0}
              t[3] = max_int;
              t[4] = 0;
              return 0}
            return _kq_}
          if(caml_weak_check(bucket$0,i$3))
           {var i$5=i$3 + 1 | 0,i$3=i$5;continue}
          caml_call3(setter,bucket$0,i$3,d);
          caml_check_bound(hashes,i$3)[1 + i$3] = h;
          return 0}}
      function add(t,d)
       {var h=caml_call1(H[2],d);
        return add_aux(t,caml_weak_set,[0,d],h,get_index(t,h))}
      function find_or(t,d,ifnotfound)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return caml_call2(ifnotfound,h,index);
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=caml_weak_get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var match$0=caml_weak_get(bucket,i);
                if(match$0){var v$0=match$0[1];return v$0}
                var i$0=i + 1 | 0,i=i$0;
                continue}}
            var i$1=i + 1 | 0,i=i$1;
            continue}
          var i$2=i + 1 | 0,i=i$2;
          continue}}
      function merge(t,d)
       {return find_or
                (t,
                 d,
                 function(h,index)
                  {add_aux(t,caml_weak_set,[0,d],h,index);return d})}
      function find(t,d)
       {return find_or(t,d,function(h,index){throw Not_found})}
      function find_opt(t,d)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return 0;
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=caml_weak_get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var v$0=caml_weak_get(bucket,i);
                if(v$0)return v$0;
                var i$0=i + 1 | 0,i=i$0;
                continue}}
            var i$1=i + 1 | 0,i=i$1;
            continue}
          var i$2=i + 1 | 0,i=i$2;
          continue}}
      function find_shadow(t,d,iffound,ifnotfound)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return ifnotfound;
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=caml_weak_get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))return caml_call2(iffound,bucket,i)}
            var i$0=i + 1 | 0,i=i$0;
            continue}
          var i$1=i + 1 | 0,i=i$1;
          continue}}
      function remove(t,d)
       {var _kf_=0;
        return find_shadow
                (t,d,function(w,i){return caml_weak_set(w,i,0)},_kf_)}
      function mem(t,d)
       {var _ke_=0;return find_shadow(t,d,function(w,i){return 1},_ke_)}
      function find_all(t,d)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0,
         accu=0;
        for(;;)
         {if(sz <= i)return accu;
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=caml_weak_get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var match$0=caml_weak_get(bucket,i);
                if(match$0)
                 {var
                   v$0=match$0[1],
                   accu$0=[0,v$0,accu],
                   i$0=i + 1 | 0,
                   i=i$0,
                   accu=accu$0;
                  continue}
                var i$1=i + 1 | 0,i=i$1;
                continue}}
            var i$2=i + 1 | 0,i=i$2;
            continue}
          var i$3=i + 1 | 0,i=i$3;
          continue}}
      function stats(t)
       {var len=t[1].length - 1,lens=map$2(length$5,t[1]);
        sort(caml_int_compare,lens);
        var
         _j8_=0,
         totlen=
          fold_left$0(function(_kd_,_kc_){return _kd_ + _kc_ | 0},_j8_,lens),
         _j9_=len - 1 | 0,
         _j$_=len / 2 | 0,
         _j__=caml_check_bound(lens,_j9_)[1 + _j9_],
         _ka_=caml_check_bound(lens,_j$_)[1 + _j$_],
         _kb_=caml_check_bound(lens,0)[1];
        return [0,len,count(t),totlen,_kb_,_ka_,_j__]}
      return [0,
              create,
              clear,
              merge,
              add,
              remove,
              find,
              find_opt,
              find_all,
              mem,
              iter,
              fold,
              count,
              stats]}
    var
     Weak=
      [0,
       caml_weak_create,
       length$5,
       caml_weak_set,
       caml_weak_get,
       caml_weak_get_copy,
       caml_weak_check,
       fill$1,
       caml_weak_blit,
       Make$0];
    caml_register_global(680,Weak,"Weak");
    function add_queue(x,q)
     {var c=[0,x,0],_j7_=q[1];
      return _j7_?(q[1] = c,_j7_[2] = c,0):(q[1] = c,q[2] = c,0)}
    var Empty_queue=[248,cst_Format_Empty_queue,caml_fresh_oo_id(0)];
    function take_queue(q)
     {var _j6_=q[2];
      if(_j6_)
       {var x=_j6_[1],tl=_j6_[2];q[2] = tl;if(0 === tl)q[1] = 0;return x}
      throw Empty_queue}
    function pp_enqueue(state,token)
     {var len=token[3];
      state[13] = state[13] + len | 0;
      return add_queue(token,state[28])}
    var pp_infinity=1000000010;
    function pp_output_string(state,s)
     {return caml_call3(state[17],s,0,caml_ml_string_length(s))}
    function pp_output_newline(state){return caml_call1(state[19],0)}
    function break_new_line(state,offset,width)
     {pp_output_newline(state);
      state[11] = 1;
      var
       indent=(state[6] - width | 0) + offset | 0,
       real_indent=min(state[8],indent);
      state[10] = real_indent;
      state[9] = state[6] - state[10] | 0;
      return caml_call1(state[21],state[10])}
    function break_line(state,width){return break_new_line(state,0,width)}
    function break_same_line(state,width)
     {state[9] = state[9] - width | 0;return caml_call1(state[20],width)}
    function pp_force_break_line(state)
     {var _j3_=state[2];
      if(_j3_)
       {var
         match=_j3_[1],
         width=match[2],
         bl_ty=match[1],
         _j4_=state[9] < width?1:0;
        if(_j4_)
         {if(0 !== bl_ty)return 5 <= bl_ty?0:break_line(state,width);
          var _j5_=0}
        else
         var _j5_=_j4_;
        return _j5_}
      return pp_output_newline(state)}
    function pp_skip_token(state)
     {var match=take_queue(state[28]),size=match[1],len=match[3];
      state[12] = state[12] - len | 0;
      state[9] = state[9] + size | 0;
      return 0}
    function format_pp_token(state,size,param)
     {if(typeof param === "number")
       switch(param)
        {case 0:
          var _jS_=state[3];
          if(_jS_)
           {var
             match=_jS_[1],
             tabs=match[1],
             add_tab=
              function(n,ls)
               {if(ls)
                 {var l=ls[2],x=ls[1];
                  return runtime.caml_lessthan(n,x)
                          ?[0,n,ls]
                          :[0,x,add_tab(n,l)]}
                return [0,n,0]};
            tabs[1] = add_tab(state[6] - state[9] | 0,tabs[1]);
            return 0}
          return 0;
         case 1:
          var _jT_=state[2];
          if(_jT_){var ls=_jT_[2];state[2] = ls;return 0}
          return 0;
         case 2:
          var _jU_=state[3];
          if(_jU_){var ls$0=_jU_[2];state[3] = ls$0;return 0}
          return 0;
         case 3:
          var _jV_=state[2];
          if(_jV_)
           {var match$0=_jV_[1],width=match$0[2];
            return break_line(state,width)}
          return pp_output_newline(state);
         case 4:
          var _jW_=state[10] !== (state[6] - state[9] | 0)?1:0;
          return _jW_?pp_skip_token(state):_jW_;
         default:
          var _jX_=state[5];
          if(_jX_)
           {var
             tags=_jX_[2],
             tag_name=_jX_[1],
             marker=caml_call1(state[25],tag_name);
            pp_output_string(state,marker);
            state[5] = tags;
            return 0}
          return 0}
      else
       switch(param[0])
        {case 0:
          var s=param[1];
          state[9] = state[9] - size | 0;
          pp_output_string(state,s);
          state[11] = 0;
          return 0;
         case 1:
          var off=param[2],n=param[1],_jY_=state[2];
          if(_jY_)
           {var match$1=_jY_[1],width$0=match$1[2],ty=match$1[1];
            switch(ty)
             {case 0:return break_same_line(state,n);
              case 1:return break_new_line(state,off,width$0);
              case 2:return break_new_line(state,off,width$0);
              case 3:
               return state[9] < size
                       ?break_new_line(state,off,width$0)
                       :break_same_line(state,n);
              case 4:
               return state[11]
                       ?break_same_line(state,n)
                       :state[9] < size
                         ?break_new_line(state,off,width$0)
                         :((state[6] - width$0 | 0) + off | 0) < state[10]
                           ?break_new_line(state,off,width$0)
                           :break_same_line(state,n);
              default:return break_same_line(state,n)}}
          return 0;
         case 2:
          var
           off$0=param[2],
           n$0=param[1],
           insertion_point=state[6] - state[9] | 0,
           _jZ_=state[3];
          if(_jZ_)
           {var
             match$2=_jZ_[1],
             tabs$0=match$2[1],
             find=
              function(n,param)
               {var param$0=param;
                for(;;)
                 {if(param$0)
                   {var l=param$0[2],x=param$0[1];
                    if(caml_greaterequal(x,n))return x;
                    var param$0=l;
                    continue}
                  throw Not_found}},
             _j0_=tabs$0[1];
            if(_j0_)
             {var x=_j0_[1];
              try
               {var _j1_=find(insertion_point,tabs$0[1]),x$0=_j1_}
              catch(_j2_)
               {_j2_ = caml_wrap_exception(_j2_);
                if(_j2_ !== Not_found)throw _j2_;
                var x$0=x}
              var tab=x$0}
            else
             var tab=insertion_point;
            var offset=tab - insertion_point | 0;
            return 0 <= offset
                    ?break_same_line(state,offset + n$0 | 0)
                    :break_new_line(state,tab + off$0 | 0,state[6])}
          return 0;
         case 3:
          var
           ty$0=param[2],
           off$1=param[1],
           insertion_point$0=state[6] - state[9] | 0;
          if(state[8] < insertion_point$0)pp_force_break_line(state);
          var
           offset$0=state[9] - off$1 | 0,
           bl_type=1 === ty$0?1:state[9] < size?ty$0:5;
          state[2] = [0,[0,bl_type,offset$0],state[2]];
          return 0;
         case 4:var tbox=param[1];state[3] = [0,tbox,state[3]];return 0;
         default:
          var tag_name$0=param[1],marker$0=caml_call1(state[24],tag_name$0);
          pp_output_string(state,marker$0);
          state[5] = [0,tag_name$0,state[5]];
          return 0}}
    function advance_loop(state)
     {for(;;)
       {var _jO_=state[28][2];
        if(_jO_)
         {var
           x=_jO_[1],
           size=x[1],
           len=x[3],
           tok=x[2],
           _jP_=size < 0?1:0,
           _jQ_=_jP_?(state[13] - state[12] | 0) < state[9]?1:0:_jP_,
           _jR_=1 - _jQ_;
          if(_jR_)
           {take_queue(state[28]);
            var size$0=0 <= size?size:pp_infinity;
            format_pp_token(state,size$0,tok);
            state[12] = len + state[12] | 0;
            continue}
          return _jR_}
        throw Empty_queue}}
    function advance_left(state)
     {try
       {var _jM_=advance_loop(state);return _jM_}
      catch(_jN_)
       {_jN_ = caml_wrap_exception(_jN_);
        if(_jN_ === Empty_queue)return 0;
        throw _jN_}}
    function enqueue_advance(state,tok)
     {pp_enqueue(state,tok);return advance_left(state)}
    function enqueue_string_as(state,size,s)
     {return enqueue_advance(state,[0,size,[0,s],size])}
    var q_elem=[0,-1,_b6_,0],scan_stack_bottom=[0,[0,-1,q_elem],0];
    function clear_scan_stack(state){state[1] = scan_stack_bottom;return 0}
    function set_size(state,ty)
     {var _jI_=state[1];
      if(_jI_)
       {var
         match=_jI_[1],
         queue_elem=match[2],
         left_tot=match[1],
         size=queue_elem[1],
         t=_jI_[2],
         tok=queue_elem[2];
        if(left_tot < state[12])return clear_scan_stack(state);
        if(typeof tok !== "number")
         switch(tok[0])
          {case 3:
            var
             _jK_=1 - ty,
             _jL_=
              _jK_?(queue_elem[1] = state[13] + size | 0,state[1] = t,0):_jK_;
            return _jL_;
           case 1:
           case 2:
            var
             _jJ_=
              ty?(queue_elem[1] = state[13] + size | 0,state[1] = t,0):ty;
            return _jJ_
           }
        return 0}
      return 0}
    function scan_push(state,b,tok)
     {pp_enqueue(state,tok);
      if(b)set_size(state,1);
      state[1] = [0,[0,state[13],tok],state[1]];
      return 0}
    function pp_open_box_gen(state,indent,br_ty)
     {state[14] = state[14] + 1 | 0;
      if(state[14] < state[15])
       {var elem=[0,- state[13] | 0,[3,indent,br_ty],0];
        return scan_push(state,0,elem)}
      var _jG_=state[14] === state[15]?1:0;
      if(_jG_)
       {var _jH_=state[16],len=caml_ml_string_length(_jH_);
        return enqueue_string_as(state,len,_jH_)}
      return _jG_}
    function pp_close_box(state,param)
     {var _jE_=1 < state[14]?1:0;
      if(_jE_)
       {if(state[14] < state[15])
         {pp_enqueue(state,[0,0,1,0]);set_size(state,1);set_size(state,0)}
        state[14] = state[14] - 1 | 0;
        var _jF_=0}
      else
       var _jF_=_jE_;
      return _jF_}
    function pp_open_tag(state,tag_name)
     {if(state[22])
       {state[4] = [0,tag_name,state[4]];caml_call1(state[26],tag_name)}
      var _jD_=state[23];
      return _jD_?pp_enqueue(state,[0,0,[5,tag_name],0]):_jD_}
    function pp_close_tag(state,param)
     {if(state[23])pp_enqueue(state,[0,0,5,0]);
      var _jA_=state[22];
      if(_jA_)
       {var _jB_=state[4];
        if(_jB_)
         {var tags=_jB_[2],tag_name=_jB_[1];
          caml_call1(state[27],tag_name);
          state[4] = tags;
          return 0}
        var _jC_=0}
      else
       var _jC_=_jA_;
      return _jC_}
    function pp_set_print_tags(state,b){state[22] = b;return 0}
    function pp_set_mark_tags(state,b){state[23] = b;return 0}
    function pp_get_print_tags(state,param){return state[22]}
    function pp_get_mark_tags(state,param){return state[23]}
    function pp_set_tags(state,b)
     {pp_set_print_tags(state,b);return pp_set_mark_tags(state,b)}
    function pp_get_formatter_tag_functions(state,param)
     {return [0,state[24],state[25],state[26],state[27]]}
    function pp_set_formatter_tag_functions(state,param)
     {var pct=param[4],pot=param[3],mct=param[2],mot=param[1];
      state[24] = mot;
      state[25] = mct;
      state[26] = pot;
      state[27] = pct;
      return 0}
    function pp_rinit(state)
     {state[12] = 1;
      state[13] = 1;
      var _jz_=state[28];
      _jz_[1] = 0;
      _jz_[2] = 0;
      clear_scan_stack(state);
      state[2] = 0;
      state[3] = 0;
      state[4] = 0;
      state[5] = 0;
      state[10] = 0;
      state[14] = 0;
      state[9] = state[6];
      return pp_open_box_gen(state,0,3)}
    function pp_flush_queue(state,b)
     {var _jy_=state[4];
      iter(function(param){return pp_close_tag(state,0)},_jy_);
      for(;;)
       {if(1 < state[14]){pp_close_box(state,0);continue}
        state[13] = pp_infinity;
        advance_left(state);
        if(b)pp_output_newline(state);
        return pp_rinit(state)}}
    function pp_print_as_size(state,size,s)
     {var _jx_=state[14] < state[15]?1:0;
      return _jx_?enqueue_string_as(state,size,s):_jx_}
    function pp_print_as(state,isize,s)
     {return pp_print_as_size(state,isize,s)}
    function pp_print_string(state,s)
     {return pp_print_as(state,caml_ml_string_length(s),s)}
    function pp_print_int(state,i)
     {return pp_print_string(state,caml_new_string("" + i))}
    function pp_print_float(state,f)
     {return pp_print_string(state,string_of_float(f))}
    function pp_print_bool(state,b)
     {return pp_print_string(state,string_of_bool(b))}
    function pp_print_char(state,c){return pp_print_as(state,1,make$0(1,c))}
    function pp_open_hbox(state,param){return pp_open_box_gen(state,0,0)}
    function pp_open_vbox(state,indent)
     {return pp_open_box_gen(state,indent,1)}
    function pp_open_hvbox(state,indent)
     {return pp_open_box_gen(state,indent,2)}
    function pp_open_hovbox(state,indent)
     {return pp_open_box_gen(state,indent,3)}
    function pp_open_box(state,indent){return pp_open_box_gen(state,indent,4)}
    function pp_print_newline(state,param)
     {pp_flush_queue(state,1);return caml_call1(state[18],0)}
    function pp_print_flush(state,param)
     {pp_flush_queue(state,0);return caml_call1(state[18],0)}
    function pp_force_newline(state,param)
     {var _jw_=state[14] < state[15]?1:0;
      return _jw_?enqueue_advance(state,[0,0,3,0]):_jw_}
    function pp_print_if_newline(state,param)
     {var _jv_=state[14] < state[15]?1:0;
      return _jv_?enqueue_advance(state,[0,0,4,0]):_jv_}
    function pp_print_break(state,width,offset)
     {var _ju_=state[14] < state[15]?1:0;
      if(_ju_)
       {var elem=[0,- state[13] | 0,[1,width,offset],width];
        return scan_push(state,1,elem)}
      return _ju_}
    function pp_print_space(state,param){return pp_print_break(state,1,0)}
    function pp_print_cut(state,param){return pp_print_break(state,0,0)}
    function pp_open_tbox(state,param)
     {state[14] = state[14] + 1 | 0;
      var _jt_=state[14] < state[15]?1:0;
      if(_jt_)
       {var elem=[0,0,[4,[0,[0,0]]],0];return enqueue_advance(state,elem)}
      return _jt_}
    function pp_close_tbox(state,param)
     {var _jq_=1 < state[14]?1:0;
      if(_jq_)
       {var _jr_=state[14] < state[15]?1:0;
        if(_jr_)
         {var elem=[0,0,2,0];
          enqueue_advance(state,elem);
          state[14] = state[14] - 1 | 0;
          var _js_=0}
        else
         var _js_=_jr_}
      else
       var _js_=_jq_;
      return _js_}
    function pp_print_tbreak(state,width,offset)
     {var _jp_=state[14] < state[15]?1:0;
      if(_jp_)
       {var elem=[0,- state[13] | 0,[2,width,offset],width];
        return scan_push(state,1,elem)}
      return _jp_}
    function pp_print_tab(state,param){return pp_print_tbreak(state,0,0)}
    function pp_set_tab(state,param)
     {var _jo_=state[14] < state[15]?1:0;
      if(_jo_){var elem=[0,0,0,0];return enqueue_advance(state,elem)}
      return _jo_}
    function pp_set_max_boxes(state,n)
     {var _jm_=1 < n?1:0,_jn_=_jm_?(state[15] = n,0):_jm_;return _jn_}
    function pp_get_max_boxes(state,param){return state[15]}
    function pp_over_max_boxes(state,param)
     {return state[14] === state[15]?1:0}
    function pp_set_ellipsis_text(state,s){state[16] = s;return 0}
    function pp_get_ellipsis_text(state,param){return state[16]}
    function pp_limit(n){return n < 1000000010?n:1000000009}
    function pp_set_max_indent(state,n$0)
     {var n$1=state[6] - n$0 | 0,_jl_=1 <= n$1?1:0;
      if(_jl_)
       {var n=pp_limit(n$1);
        state[7] = n;
        state[8] = state[6] - state[7] | 0;
        return pp_rinit(state)}
      return _jl_}
    function pp_get_max_indent(state,param){return state[8]}
    function pp_set_margin(state,n)
     {var _jk_=1 <= n?1:0;
      if(_jk_)
       {var n$0=pp_limit(n);
        state[6] = n$0;
        var
         new_max_indent=
          state[8] <= state[6]
           ?state[8]
           :max(max(state[6] - state[7] | 0,state[6] / 2 | 0),1);
        return pp_set_max_indent(state,new_max_indent)}
      return _jk_}
    function pp_get_margin(state,param){return state[6]}
    function pp_set_formatter_out_functions(state,param)
     {var j=param[5],i=param[4],h=param[3],g=param[2],f=param[1];
      state[17] = f;
      state[18] = g;
      state[19] = h;
      state[20] = i;
      state[21] = j;
      return 0}
    function pp_get_formatter_out_functions(state,param)
     {return [0,state[17],state[18],state[19],state[20],state[21]]}
    function pp_set_formatter_output_functions(state,f,g)
     {state[17] = f;state[18] = g;return 0}
    function pp_get_formatter_output_functions(state,param)
     {return [0,state[17],state[18]]}
    function display_newline(state,param)
     {return caml_call3(state[17],cst$66,0,1)}
    var blank_line=make$0(80,32);
    function display_indent(state,n)
     {var n$0=n;
      for(;;)
       {var _jj_=0 < n$0?1:0;
        if(_jj_)
         {if(80 < n$0)
           {caml_call3(state[17],blank_line,0,80);
            var n$1=n$0 - 80 | 0,n$0=n$1;
            continue}
          return caml_call3(state[17],blank_line,0,n$0)}
        return _jj_}}
    function pp_set_formatter_out_channel(state,oc)
     {state[17]
      =
      function(_jg_,_jh_,_ji_){return output_substring(oc,_jg_,_jh_,_ji_)};
      state[18] = function(param){return caml_ml_flush(oc)};
      state[19] = function(_jf_){return display_newline(state,_jf_)};
      state[20] = function(_je_){return display_indent(state,_je_)};
      state[21] = function(_jd_){return display_indent(state,_jd_)};
      return 0}
    function default_pp_mark_open_tag(s)
     {return symbol(cst$68,symbol(s,cst$67))}
    function default_pp_mark_close_tag(s)
     {return symbol(cst$70,symbol(s,cst$69))}
    function default_pp_print_open_tag(_jc_){return 0}
    function default_pp_print_close_tag(_jb_){return 0}
    function pp_make_formatter(f,g,h,i,j)
     {var pp_queue=[0,0,0],sys_tok=[0,-1,_b7_,0];
      add_queue(sys_tok,pp_queue);
      var sys_scan_stack=[0,[0,1,sys_tok],scan_stack_bottom];
      return [0,
              sys_scan_stack,
              0,
              0,
              0,
              0,
              78,
              10,
              68,
              78,
              0,
              1,
              1,
              1,
              1,
              max_int,
              cst$71,
              f,
              g,
              h,
              i,
              j,
              0,
              0,
              default_pp_mark_open_tag,
              default_pp_mark_close_tag,
              default_pp_print_open_tag,
              default_pp_print_close_tag,
              pp_queue]}
    function formatter_of_out_functions(out_funs)
     {return pp_make_formatter
              (out_funs[1],out_funs[2],out_funs[3],out_funs[4],out_funs[5])}
    function make_formatter(output,flush)
     {function _i5_(_ja_){return 0}
      function _i6_(_i$_){return 0}
      var
       ppf=
        pp_make_formatter(output,flush,function(_i__){return 0},_i6_,_i5_);
      ppf[19] = function(_i9_){return display_newline(ppf,_i9_)};
      ppf[20] = function(_i8_){return display_indent(ppf,_i8_)};
      ppf[21] = function(_i7_){return display_indent(ppf,_i7_)};
      return ppf}
    function formatter_of_out_channel(oc)
     {function _i1_(param){return caml_ml_flush(oc)}
      return make_formatter
              (function(_i2_,_i3_,_i4_)
                {return output_substring(oc,_i2_,_i3_,_i4_)},
               _i1_)}
    function formatter_of_buffer(b)
     {function _iW_(_i0_){return 0}
      return make_formatter
              (function(_iX_,_iY_,_iZ_)
                {return add_substring(b,_iX_,_iY_,_iZ_)},
               _iW_)}
    var pp_buffer_size=512;
    function pp_make_buffer(param){return create$1(pp_buffer_size)}
    var
     stdbuf=pp_make_buffer(0),
     std_formatter=formatter_of_out_channel(stdout),
     err_formatter=formatter_of_out_channel(stderr),
     str_formatter=formatter_of_buffer(stdbuf);
    function flush_buffer_formatter(buf,ppf)
     {pp_flush_queue(ppf,0);var s=contents(buf);reset(buf);return s}
    function flush_str_formatter(param)
     {return flush_buffer_formatter(stdbuf,str_formatter)}
    function make_symbolic_output_buffer(param){return [0,0]}
    function clear_symbolic_output_buffer(sob){sob[1] = 0;return 0}
    function get_symbolic_output_buffer(sob){return rev(sob[1])}
    function flush_symbolic_output_buffer(sob)
     {var items=get_symbolic_output_buffer(sob);
      clear_symbolic_output_buffer(sob);
      return items}
    function add_symbolic_output_item(sob,item)
     {sob[1] = [0,item,sob[1]];return 0}
    function formatter_of_symbolic_output_buffer(sob)
     {function f(s,i,n){return add_symbolic_output_item(sob,[0,sub$0(s,i,n)])}
      function g(_iV_){return add_symbolic_output_item(sob,0)}
      function h(_iU_){return add_symbolic_output_item(sob,1)}
      function i(n){return add_symbolic_output_item(sob,[1,n])}
      function j(n){return add_symbolic_output_item(sob,[2,n])}
      return pp_make_formatter(f,g,h,i,j)}
    function open_hbox(_iT_){return pp_open_hbox(std_formatter,_iT_)}
    function open_vbox(_iS_){return pp_open_vbox(std_formatter,_iS_)}
    function open_hvbox(_iR_){return pp_open_hvbox(std_formatter,_iR_)}
    function open_hovbox(_iQ_){return pp_open_hovbox(std_formatter,_iQ_)}
    function open_box(_iP_){return pp_open_box(std_formatter,_iP_)}
    function close_box(_iO_){return pp_close_box(std_formatter,_iO_)}
    function open_tag(_iN_){return pp_open_tag(std_formatter,_iN_)}
    function close_tag(_iM_){return pp_close_tag(std_formatter,_iM_)}
    function print_as(_iK_,_iL_){return pp_print_as(std_formatter,_iK_,_iL_)}
    function print_string$0(_iJ_){return pp_print_string(std_formatter,_iJ_)}
    function print_int$0(_iI_){return pp_print_int(std_formatter,_iI_)}
    function print_float$0(_iH_){return pp_print_float(std_formatter,_iH_)}
    function print_char$0(_iG_){return pp_print_char(std_formatter,_iG_)}
    function print_bool(_iF_){return pp_print_bool(std_formatter,_iF_)}
    function print_break(_iD_,_iE_)
     {return pp_print_break(std_formatter,_iD_,_iE_)}
    function print_cut(_iC_){return pp_print_cut(std_formatter,_iC_)}
    function print_space(_iB_){return pp_print_space(std_formatter,_iB_)}
    function force_newline(_iA_){return pp_force_newline(std_formatter,_iA_)}
    function print_flush(_iz_){return pp_print_flush(std_formatter,_iz_)}
    function print_newline$0(_iy_)
     {return pp_print_newline(std_formatter,_iy_)}
    function print_if_newline(_ix_)
     {return pp_print_if_newline(std_formatter,_ix_)}
    function open_tbox(_iw_){return pp_open_tbox(std_formatter,_iw_)}
    function close_tbox(_iv_){return pp_close_tbox(std_formatter,_iv_)}
    function print_tbreak(_it_,_iu_)
     {return pp_print_tbreak(std_formatter,_it_,_iu_)}
    function set_tab(_is_){return pp_set_tab(std_formatter,_is_)}
    function print_tab(_ir_){return pp_print_tab(std_formatter,_ir_)}
    function set_margin(_iq_){return pp_set_margin(std_formatter,_iq_)}
    function get_margin(_ip_){return std_formatter[6]}
    function set_max_indent(_io_)
     {return pp_set_max_indent(std_formatter,_io_)}
    function get_max_indent(_in_){return std_formatter[8]}
    function set_max_boxes(_im_){return pp_set_max_boxes(std_formatter,_im_)}
    function get_max_boxes(_il_){return std_formatter[15]}
    function over_max_boxes(_ik_)
     {return pp_over_max_boxes(std_formatter,_ik_)}
    function set_ellipsis_text(_ij_)
     {return pp_set_ellipsis_text(std_formatter,_ij_)}
    function get_ellipsis_text(_ii_){return std_formatter[16]}
    function set_formatter_out_channel(_ih_)
     {return pp_set_formatter_out_channel(std_formatter,_ih_)}
    function set_formatter_out_functions(_ig_)
     {return pp_set_formatter_out_functions(std_formatter,_ig_)}
    function get_formatter_out_functions(_if_)
     {return pp_get_formatter_out_functions(std_formatter,_if_)}
    function set_formatter_output_functions(_id_,_ie_)
     {return pp_set_formatter_output_functions(std_formatter,_id_,_ie_)}
    function get_formatter_output_functions(_ic_)
     {return pp_get_formatter_output_functions(std_formatter,_ic_)}
    function set_formatter_tag_functions(_ib_)
     {return pp_set_formatter_tag_functions(std_formatter,_ib_)}
    function get_formatter_tag_functions(_ia_)
     {return pp_get_formatter_tag_functions(std_formatter,_ia_)}
    function set_print_tags(_h$_)
     {return pp_set_print_tags(std_formatter,_h$_)}
    function get_print_tags(_h__){return std_formatter[22]}
    function set_mark_tags(_h9_){return pp_set_mark_tags(std_formatter,_h9_)}
    function get_mark_tags(_h8_){return std_formatter[23]}
    function set_tags(_h7_){return pp_set_tags(std_formatter,_h7_)}
    function pp_print_list(opt,pp_v,ppf,param)
     {var opt$0=opt,param$0=param;
      for(;;)
       {if(opt$0)var sth=opt$0[1],pp_sep=sth;else var pp_sep=pp_print_cut;
        if(param$0)
         {var _h5_=param$0[2],_h6_=param$0[1];
          if(_h5_)
           {caml_call2(pp_v,ppf,_h6_);
            caml_call2(pp_sep,ppf,0);
            var opt$1=[0,pp_sep],opt$0=opt$1,param$0=_h5_;
            continue}
          return caml_call2(pp_v,ppf,_h6_)}
        return 0}}
    function pp_print_text(ppf,s)
     {var len=caml_ml_string_length(s),left=[0,0],right=[0,0];
      function flush(param)
       {pp_print_string(ppf,sub$0(s,left[1],right[1] - left[1] | 0));
        right[1]++;
        left[1] = right[1];
        return 0}
      for(;;)
       {if(right[1] !== len)
         {var match=caml_string_get(s,right[1]);
          if(10 === match)
           {flush(0);pp_force_newline(ppf,0)}
          else
           if(32 === match){flush(0);pp_print_space(ppf,0)}else right[1]++;
          continue}
        var _h4_=left[1] !== len?1:0;
        return _h4_?flush(0):_h4_}}
    function compute_tag(output,tag_acc)
     {var buf=create$1(16),ppf=formatter_of_buffer(buf);
      caml_call2(output,ppf,tag_acc);
      pp_print_flush(ppf,0);
      var len=buf[2];
      return 2 <= len?sub$2(buf,1,len - 2 | 0):contents(buf)}
    function output_formatting_lit(ppf,fmting_lit)
     {if(typeof fmting_lit === "number")
       switch(fmting_lit)
        {case 0:return pp_close_box(ppf,0);
         case 1:return pp_close_tag(ppf,0);
         case 2:return pp_print_flush(ppf,0);
         case 3:return pp_force_newline(ppf,0);
         case 4:return pp_print_newline(ppf,0);
         case 5:return pp_print_char(ppf,64);
         default:return pp_print_char(ppf,37)}
      else
       switch(fmting_lit[0])
        {case 0:
          var offset=fmting_lit[3],width=fmting_lit[2];
          return pp_print_break(ppf,width,offset);
         case 1:return 0;
         default:
          var c=fmting_lit[1];
          pp_print_char(ppf,64);
          return pp_print_char(ppf,c)}}
    function output_acc$0(ppf,acc)
     {if(typeof acc === "number")
       return 0;
      else
       switch(acc[0])
        {case 0:
          var f=acc[2],p=acc[1];
          output_acc$0(ppf,p);
          return output_formatting_lit(ppf,f);
         case 1:
          var _hU_=acc[2],_hV_=acc[1];
          if(0 === _hU_[0])
           {var acc$0=_hU_[1];
            output_acc$0(ppf,_hV_);
            return pp_open_tag(ppf,compute_tag(output_acc$0,acc$0))}
          var acc$1=_hU_[1];
          output_acc$0(ppf,_hV_);
          var
           match=open_box_of_string(compute_tag(output_acc$0,acc$1)),
           bty=match[2],
           indent=match[1];
          return pp_open_box_gen(ppf,indent,bty);
         case 2:
          var _hW_=acc[1];
          if(typeof _hW_ === "number")
           var switch$1=1;
          else
           if(0 === _hW_[0])
            {var _hX_=_hW_[2];
             if(typeof _hX_ === "number")
              var switch$2=1;
             else
              if(1 === _hX_[0])
               var
                s$0=acc[2],
                size=_hX_[2],
                p$1=_hW_[1],
                switch$0=0,
                switch$1=0,
                switch$2=0;
              else
               var switch$2=1;
             if(switch$2)var switch$1=1}
           else
            var switch$1=1;
          if(switch$1)var s=acc[2],p$0=_hW_,switch$0=2;
          break;
         case 3:
          var _hY_=acc[1];
          if(typeof _hY_ === "number")
           var switch$3=1;
          else
           if(0 === _hY_[0])
            {var _hZ_=_hY_[2];
             if(typeof _hZ_ === "number")
              var switch$4=1;
             else
              if(1 === _hZ_[0])
               var
                c$0=acc[2],
                size$0=_hZ_[2],
                p$3=_hY_[1],
                switch$0=1,
                switch$3=0,
                switch$4=0;
              else
               var switch$4=1;
             if(switch$4)var switch$3=1}
           else
            var switch$3=1;
          if(switch$3)var c=acc[2],p$2=_hY_,switch$0=3;
          break;
         case 4:
          var _h0_=acc[1];
          if(typeof _h0_ === "number")
           var switch$5=1;
          else
           if(0 === _h0_[0])
            {var _h1_=_h0_[2];
             if(typeof _h1_ === "number")
              var switch$6=1;
             else
              if(1 === _h1_[0])
               var
                s$0=acc[2],
                size=_h1_[2],
                p$1=_h0_[1],
                switch$0=0,
                switch$5=0,
                switch$6=0;
              else
               var switch$6=1;
             if(switch$6)var switch$5=1}
           else
            var switch$5=1;
          if(switch$5)var s=acc[2],p$0=_h0_,switch$0=2;
          break;
         case 5:
          var _h2_=acc[1];
          if(typeof _h2_ === "number")
           var switch$7=1;
          else
           if(0 === _h2_[0])
            {var _h3_=_h2_[2];
             if(typeof _h3_ === "number")
              var switch$8=1;
             else
              if(1 === _h3_[0])
               var
                c$0=acc[2],
                size$0=_h3_[2],
                p$3=_h2_[1],
                switch$0=1,
                switch$7=0,
                switch$8=0;
              else
               var switch$8=1;
             if(switch$8)var switch$7=1}
           else
            var switch$7=1;
          if(switch$7)var c=acc[2],p$2=_h2_,switch$0=3;
          break;
         case 6:
          var f$0=acc[2],p$4=acc[1];
          output_acc$0(ppf,p$4);
          return caml_call1(f$0,ppf);
         case 7:
          var p$5=acc[1];output_acc$0(ppf,p$5);return pp_print_flush(ppf,0);
         default:
          var msg=acc[2],p$6=acc[1];
          output_acc$0(ppf,p$6);
          return invalid_arg(msg)}
      switch(switch$0)
       {case 0:output_acc$0(ppf,p$1);return pp_print_as_size(ppf,size,s$0);
        case 1:
         output_acc$0(ppf,p$3);
         return pp_print_as_size(ppf,size$0,make$0(1,c$0));
        case 2:output_acc$0(ppf,p$0);return pp_print_string(ppf,s);
        default:output_acc$0(ppf,p$2);return pp_print_char(ppf,c)}}
    function strput_acc$0(ppf,acc)
     {if(typeof acc === "number")
       return 0;
      else
       switch(acc[0])
        {case 0:
          var f=acc[2],p=acc[1];
          strput_acc$0(ppf,p);
          return output_formatting_lit(ppf,f);
         case 1:
          var _hI_=acc[2],_hJ_=acc[1];
          if(0 === _hI_[0])
           {var acc$0=_hI_[1];
            strput_acc$0(ppf,_hJ_);
            return pp_open_tag(ppf,compute_tag(strput_acc$0,acc$0))}
          var acc$1=_hI_[1];
          strput_acc$0(ppf,_hJ_);
          var
           match=open_box_of_string(compute_tag(strput_acc$0,acc$1)),
           bty=match[2],
           indent=match[1];
          return pp_open_box_gen(ppf,indent,bty);
         case 2:
          var _hK_=acc[1];
          if(typeof _hK_ === "number")
           var switch$1=1;
          else
           if(0 === _hK_[0])
            {var _hL_=_hK_[2];
             if(typeof _hL_ === "number")
              var switch$2=1;
             else
              if(1 === _hL_[0])
               var
                s$0=acc[2],
                size=_hL_[2],
                p$1=_hK_[1],
                switch$0=0,
                switch$1=0,
                switch$2=0;
              else
               var switch$2=1;
             if(switch$2)var switch$1=1}
           else
            var switch$1=1;
          if(switch$1)var s=acc[2],p$0=_hK_,switch$0=2;
          break;
         case 3:
          var _hM_=acc[1];
          if(typeof _hM_ === "number")
           var switch$3=1;
          else
           if(0 === _hM_[0])
            {var _hN_=_hM_[2];
             if(typeof _hN_ === "number")
              var switch$4=1;
             else
              if(1 === _hN_[0])
               var
                c$0=acc[2],
                size$0=_hN_[2],
                p$3=_hM_[1],
                switch$0=1,
                switch$3=0,
                switch$4=0;
              else
               var switch$4=1;
             if(switch$4)var switch$3=1}
           else
            var switch$3=1;
          if(switch$3)var c=acc[2],p$2=_hM_,switch$0=3;
          break;
         case 4:
          var _hO_=acc[1];
          if(typeof _hO_ === "number")
           var switch$5=1;
          else
           if(0 === _hO_[0])
            {var _hP_=_hO_[2];
             if(typeof _hP_ === "number")
              var switch$6=1;
             else
              if(1 === _hP_[0])
               var
                s$0=acc[2],
                size=_hP_[2],
                p$1=_hO_[1],
                switch$0=0,
                switch$5=0,
                switch$6=0;
              else
               var switch$6=1;
             if(switch$6)var switch$5=1}
           else
            var switch$5=1;
          if(switch$5)var s=acc[2],p$0=_hO_,switch$0=2;
          break;
         case 5:
          var _hQ_=acc[1];
          if(typeof _hQ_ === "number")
           var switch$7=1;
          else
           if(0 === _hQ_[0])
            {var _hR_=_hQ_[2];
             if(typeof _hR_ === "number")
              var switch$8=1;
             else
              if(1 === _hR_[0])
               var
                c$0=acc[2],
                size$0=_hR_[2],
                p$3=_hQ_[1],
                switch$0=1,
                switch$7=0,
                switch$8=0;
              else
               var switch$8=1;
             if(switch$8)var switch$7=1}
           else
            var switch$7=1;
          if(switch$7)var c=acc[2],p$2=_hQ_,switch$0=3;
          break;
         case 6:
          var _hS_=acc[1];
          if(typeof _hS_ !== "number" && 0 === _hS_[0])
           {var _hT_=_hS_[2];
            if(typeof _hT_ !== "number" && 1 === _hT_[0])
             {var f$1=acc[2],size$1=_hT_[2],p$4=_hS_[1];
              strput_acc$0(ppf,p$4);
              return pp_print_as_size(ppf,size$1,caml_call1(f$1,0))}}
          var f$0=acc[2];
          strput_acc$0(ppf,_hS_);
          return pp_print_string(ppf,caml_call1(f$0,0));
         case 7:
          var p$5=acc[1];strput_acc$0(ppf,p$5);return pp_print_flush(ppf,0);
         default:
          var msg=acc[2],p$6=acc[1];
          strput_acc$0(ppf,p$6);
          return invalid_arg(msg)}
      switch(switch$0)
       {case 0:strput_acc$0(ppf,p$1);return pp_print_as_size(ppf,size,s$0);
        case 1:
         strput_acc$0(ppf,p$3);
         return pp_print_as_size(ppf,size$0,make$0(1,c$0));
        case 2:strput_acc$0(ppf,p$0);return pp_print_string(ppf,s);
        default:strput_acc$0(ppf,p$2);return pp_print_char(ppf,c)}}
    function kfprintf$0(k,ppf,param)
     {var fmt=param[1],_hH_=0;
      return make_printf
              (function(ppf,acc)
                {output_acc$0(ppf,acc);return caml_call1(k,ppf)},
               ppf,
               _hH_,
               fmt)}
    function ikfprintf$0(k,ppf,param)
     {var fmt=param[1];return make_iprintf(k,ppf,fmt)}
    function fprintf$0(ppf)
     {function _hE_(_hG_){return 0}
      return function(_hF_){return kfprintf$0(_hE_,ppf,_hF_)}}
    function ifprintf$0(ppf)
     {function _hB_(_hD_){return 0}
      return function(_hC_){return ikfprintf$0(_hB_,ppf,_hC_)}}
    function printf$0(fmt){return caml_call1(fprintf$0(std_formatter),fmt)}
    function eprintf$0(fmt){return caml_call1(fprintf$0(err_formatter),fmt)}
    function ksprintf$0(k,param)
     {var fmt=param[1],b=pp_make_buffer(0),ppf=formatter_of_buffer(b);
      function k$0(param,acc)
       {strput_acc$0(ppf,acc);
        return caml_call1(k,flush_buffer_formatter(b,ppf))}
      return make_printf(k$0,0,0,fmt)}
    function sprintf$0(fmt){return ksprintf$0(function(s){return s},fmt)}
    function kasprintf(k,param)
     {var fmt=param[1],b=pp_make_buffer(0),ppf=formatter_of_buffer(b);
      function k$0(ppf,acc)
       {output_acc$0(ppf,acc);
        return caml_call1(k,flush_buffer_formatter(b,ppf))}
      return make_printf(k$0,ppf,0,fmt)}
    function asprintf(fmt){return kasprintf(function(s){return s},fmt)}
    at_exit(print_flush);
    function pp_set_all_formatter_output_functions(state,f,g,h,i)
     {pp_set_formatter_output_functions(state,f,g);
      state[19] = h;
      state[20] = i;
      return 0}
    function pp_get_all_formatter_output_functions(state,param)
     {return [0,state[17],state[18],state[19],state[20]]}
    function set_all_formatter_output_functions(_hx_,_hy_,_hz_,_hA_)
     {return pp_set_all_formatter_output_functions
              (std_formatter,_hx_,_hy_,_hz_,_hA_)}
    function get_all_formatter_output_functions(_hw_)
     {return pp_get_all_formatter_output_functions(std_formatter,_hw_)}
    function bprintf$0(b,param)
     {var fmt=param[1];
      function k(ppf,acc){output_acc$0(ppf,acc);return pp_flush_queue(ppf,0)}
      return make_printf(k,formatter_of_buffer(b),0,fmt)}
    var
     Format=
      [0,
       pp_open_box,
       open_box,
       pp_close_box,
       close_box,
       pp_open_hbox,
       open_hbox,
       pp_open_vbox,
       open_vbox,
       pp_open_hvbox,
       open_hvbox,
       pp_open_hovbox,
       open_hovbox,
       pp_print_string,
       print_string$0,
       pp_print_as,
       print_as,
       pp_print_int,
       print_int$0,
       pp_print_float,
       print_float$0,
       pp_print_char,
       print_char$0,
       pp_print_bool,
       print_bool,
       pp_print_space,
       print_space,
       pp_print_cut,
       print_cut,
       pp_print_break,
       print_break,
       pp_force_newline,
       force_newline,
       pp_print_if_newline,
       print_if_newline,
       pp_print_flush,
       print_flush,
       pp_print_newline,
       print_newline$0,
       pp_set_margin,
       set_margin,
       pp_get_margin,
       get_margin,
       pp_set_max_indent,
       set_max_indent,
       pp_get_max_indent,
       get_max_indent,
       pp_set_max_boxes,
       set_max_boxes,
       pp_get_max_boxes,
       get_max_boxes,
       pp_over_max_boxes,
       over_max_boxes,
       pp_open_tbox,
       open_tbox,
       pp_close_tbox,
       close_tbox,
       pp_set_tab,
       set_tab,
       pp_print_tab,
       print_tab,
       pp_print_tbreak,
       print_tbreak,
       pp_set_ellipsis_text,
       set_ellipsis_text,
       pp_get_ellipsis_text,
       get_ellipsis_text,
       pp_open_tag,
       open_tag,
       pp_close_tag,
       close_tag,
       pp_set_tags,
       set_tags,
       pp_set_print_tags,
       set_print_tags,
       pp_set_mark_tags,
       set_mark_tags,
       pp_get_print_tags,
       get_print_tags,
       pp_get_mark_tags,
       get_mark_tags,
       pp_set_formatter_out_channel,
       set_formatter_out_channel,
       pp_set_formatter_output_functions,
       set_formatter_output_functions,
       pp_get_formatter_output_functions,
       get_formatter_output_functions,
       pp_set_formatter_out_functions,
       set_formatter_out_functions,
       pp_get_formatter_out_functions,
       get_formatter_out_functions,
       pp_set_formatter_tag_functions,
       set_formatter_tag_functions,
       pp_get_formatter_tag_functions,
       get_formatter_tag_functions,
       formatter_of_out_channel,
       std_formatter,
       err_formatter,
       formatter_of_buffer,
       stdbuf,
       str_formatter,
       flush_str_formatter,
       make_formatter,
       formatter_of_out_functions,
       make_symbolic_output_buffer,
       clear_symbolic_output_buffer,
       get_symbolic_output_buffer,
       flush_symbolic_output_buffer,
       add_symbolic_output_item,
       formatter_of_symbolic_output_buffer,
       pp_print_list,
       pp_print_text,
       fprintf$0,
       printf$0,
       eprintf$0,
       sprintf$0,
       asprintf,
       ifprintf$0,
       kfprintf$0,
       ikfprintf$0,
       ksprintf$0,
       kasprintf,
       bprintf$0,
       ksprintf$0,
       set_all_formatter_output_functions,
       get_all_formatter_output_functions,
       pp_set_all_formatter_output_functions,
       pp_get_all_formatter_output_functions];
    caml_register_global(681,Format,"Format");
    var null_char=0;
    function next_char(ib)
     {try
       {var c=caml_call1(ib[7],0);
        ib[2] = c;
        ib[3] = 1;
        ib[4] = ib[4] + 1 | 0;
        if(10 === c)ib[5] = ib[5] + 1 | 0;
        return c}
      catch(_hv_)
       {_hv_ = caml_wrap_exception(_hv_);
        if(_hv_ === End_of_file)
         {ib[2] = null_char;ib[3] = 0;ib[1] = 1;return null_char}
        throw _hv_}}
    function peek_char(ib){return ib[3]?ib[2]:next_char(ib)}
    function checked_peek_char(ib)
     {var c=peek_char(ib);if(ib[1])throw End_of_file;return c}
    function end_of_input(ib){peek_char(ib);return ib[1]}
    function beginning_of_input(ib){return 0 === ib[4]?1:0}
    function name_of_input(ib)
     {var _hu_=ib[9];
      if(typeof _hu_ === "number")
       return 0 === _hu_?cst_unnamed_function:cst_unnamed_character_string;
      else
       {if(0 === _hu_[0])return cst_unnamed_Pervasives_input_channel;
        var fname=_hu_[1];
        return fname}}
    function char_count(ib){return ib[3]?ib[4] - 1 | 0:ib[4]}
    function reset_token(ib){return reset(ib[8])}
    function invalidate_current_char(ib){ib[3] = 0;return 0}
    function token_string(ib)
     {var token_buffer=ib[8],tok=contents(token_buffer);
      clear$1(token_buffer);
      ib[6] = ib[6] + 1 | 0;
      return tok}
    function skip_char(width,ib){invalidate_current_char(ib);return width}
    function ignore_char(width,ib){return skip_char(width - 1 | 0,ib)}
    function store_char(width,ib,c)
     {add_char(ib[8],c);return ignore_char(width,ib)}
    var default_token_buffer_size=1024;
    function create$3(iname,next)
     {return [0,
              0,
              null_char,
              0,
              0,
              0,
              0,
              next,
              create$1(default_token_buffer_size),
              iname]}
    function from_string$1(s)
     {var i=[0,0],len=caml_ml_string_length(s);
      function next(param)
       {if(len <= i[1])throw End_of_file;
        var c=caml_string_get(s,i[1]);
        i[1]++;
        return c}
      return create$3(1,next)}
    var _b8_=0;
    function from_function$0(_ht_){return create$3(_b8_,_ht_)}
    var len=1024;
    function scan_close_at_end(ic)
     {caml_ml_close_channel(ic);throw End_of_file}
    function scan_raise_at_end(ic){throw End_of_file}
    function from_ic(scan_close_ic,iname,ic)
     {var buf=caml_create_bytes(1024),i=[0,0],lim=[0,0],eof=[0,0];
      function next(param)
       {if(i[1] < lim[1]){var c=caml_bytes_get(buf,i[1]);i[1]++;return c}
        if(eof[1])throw End_of_file;
        lim[1] = input(ic,buf,0,len);
        return 0 === lim[1]
                ?(eof[1] = 1,caml_call1(scan_close_ic,ic))
                :(i[1] = 1,caml_bytes_get(buf,0))}
      return create$3(iname,next)}
    var stdib=from_ic(scan_raise_at_end,[1,cst$72,stdin],stdin);
    function open_in_file(open_in,fname)
     {if(caml_string_notequal(fname,cst$73))
       {var ic=caml_call1(open_in,fname);
        return from_ic(scan_close_at_end,[1,fname,ic],ic)}
      return stdib}
    function from_file(_hs_){return open_in_file(open_in,_hs_)}
    function from_file_bin(_hr_){return open_in_file(open_in_bin,_hr_)}
    function from_channel$0(ic){return from_ic(scan_raise_at_end,[0,ic],ic)}
    function close_in(ib)
     {var _hq_=ib[9];
      if(typeof _hq_ === "number")
       return 0;
      else
       {if(0 === _hq_[0]){var ic=_hq_[1];return caml_ml_close_channel(ic)}
        var ic$0=_hq_[2];
        return caml_ml_close_channel(ic$0)}}
    var memo=[0,0];
    function memo_from_ic(scan_close_ic,ic)
     {try
       {var _ho_=assq(ic,memo[1]);return _ho_}
      catch(_hp_)
       {_hp_ = caml_wrap_exception(_hp_);
        if(_hp_ === Not_found)
         {var ib=from_ic(scan_close_ic,[0,ic],ic);
          memo[1] = [0,[0,ic,ib],memo[1]];
          return ib}
        throw _hp_}}
    function memo_from_channel(_hn_)
     {return memo_from_ic(scan_raise_at_end,_hn_)}
    var Scan_failure=[248,cst_Scanf_Scan_failure,caml_fresh_oo_id(0)];
    function bad_input(s){throw [0,Scan_failure,s]}
    function bad_input_escape(c)
     {return bad_input(caml_call1(sprintf(_b9_),c))}
    function bad_token_length(message)
     {return bad_input(caml_call1(sprintf(_b__),message))}
    function bad_float(param)
     {return bad_input(cst_no_dot_or_exponent_part_found_in_float_token)}
    function bad_hex_float(param)
     {return bad_input(cst_not_a_valid_float_in_hexadecimal_notation)}
    function character_mismatch(c,ci)
     {return bad_input(caml_call2(sprintf(_ca_),c,ci))}
    function check_this_char(ib,c)
     {var ci=checked_peek_char(ib);
      return ci === c?invalidate_current_char(ib):character_mismatch(c,ci)}
    function check_char(ib,c$0)
     {if(10 === c$0)
       {var ci=checked_peek_char(ib);
        return 10 === ci
                ?invalidate_current_char(ib)
                :13 === ci
                  ?(invalidate_current_char(ib),check_this_char(ib,10))
                  :character_mismatch(10,ci)}
      if(32 === c$0)
       for(;;)
        {var c=peek_char(ib),_hl_=1 - ib[1];
         if(_hl_)
          {var
            _hm_=c - 9 | 0,
            switch$0=
             4 < _hm_ >>> 0?23 === _hm_?1:0:1 < (_hm_ - 2 | 0) >>> 0?1:0;
           if(switch$0){invalidate_current_char(ib);continue}
           return 0}
         return _hl_}
      return check_this_char(ib,c$0)}
    function token_char(ib){return caml_string_get(token_string(ib),0)}
    function token_bool(ib)
     {var s=token_string(ib);
      return caml_string_notequal(s,cst_false$2)
              ?caml_string_notequal(s,cst_true$2)
                ?bad_input(caml_call1(sprintf(_cb_),s))
                :1
              :0}
    function integer_conversion_of_char(param)
     {var switcher=param - 88 | 0;
      if(! (32 < switcher >>> 0))
       switch(switcher)
        {case 10:return 0;
         case 12:return 1;
         case 17:return 2;
         case 23:return 3;
         case 29:return 4;
         case 0:
         case 32:return 5
         }
      throw [0,Assert_failure,_cc_]}
    function token_int_literal(conv,ib)
     {switch(conv)
       {case 0:var tok=symbol(cst_0b,token_string(ib));break;
        case 3:var tok=symbol(cst_0o,token_string(ib));break;
        case 4:var tok=symbol(cst_0u,token_string(ib));break;
        case 5:var tok=symbol(cst_0x,token_string(ib));break;
        default:var tok=token_string(ib)}
      var l=caml_ml_string_length(tok);
      if(0 !== l)
       if(43 === caml_string_get(tok,0))return sub$0(tok,1,l - 1 | 0);
      return tok}
    function token_float(ib){return caml_float_of_string(token_string(ib))}
    function scan_decimal_digit_star(width,ib)
     {var width$0=width;
      for(;;)
       {if(0 === width$0)return width$0;
        var c=peek_char(ib);
        if(ib[1])return width$0;
        if(58 <= c)
         {if(95 === c)
           {var width$1=ignore_char(width$0,ib),width$0=width$1;continue}}
        else
         if(48 <= c)
          {var width$2=store_char(width$0,ib,c),width$0=width$2;continue}
        return width$0}}
    function scan_unsigned_decimal_int(width,ib)
     {if(0 === width)return bad_token_length(cst_decimal_digits);
      var c=checked_peek_char(ib),switcher=c - 48 | 0;
      if(9 < switcher >>> 0)return bad_input(caml_call1(sprintf(_cd_),c));
      var width$0=store_char(width,ib,c);
      return scan_decimal_digit_star(width$0,ib)}
    function scan_digit_plus(basis,digitp,width$2,ib)
     {if(0 === width$2)return bad_token_length(cst_digits);
      var c$0=checked_peek_char(ib);
      if(caml_call1(digitp,c$0))
       {var width$3=store_char(width$2,ib,c$0),width=width$3;
        for(;;)
         {if(0 === width)return width;
          var c=peek_char(ib);
          if(ib[1])return width;
          if(caml_call1(digitp,c))
           {var width$0=store_char(width,ib,c),width=width$0;continue}
          if(95 === c)
           {var width$1=ignore_char(width,ib),width=width$1;continue}
          return width}}
      return bad_input(caml_call2(sprintf(_ce_),c$0,basis))}
    function is_binary_digit(param)
     {var switcher=param - 48 | 0;return 1 < switcher >>> 0?0:1}
    function scan_binary_int(_hj_,_hk_)
     {return scan_digit_plus(cst_binary,is_binary_digit,_hj_,_hk_)}
    function is_octal_digit(param)
     {var switcher=param - 48 | 0;return 7 < switcher >>> 0?0:1}
    function scan_octal_int(_hh_,_hi_)
     {return scan_digit_plus(cst_octal,is_octal_digit,_hh_,_hi_)}
    function is_hexa_digit(param)
     {var
       _hg_=param - 48 | 0,
       switch$0=
        22 < _hg_ >>> 0
         ?5 < (_hg_ - 49 | 0) >>> 0?0:1
         :6 < (_hg_ - 10 | 0) >>> 0?1:0;
      return switch$0?1:0}
    function scan_hexadecimal_int(_he_,_hf_)
     {return scan_digit_plus(cst_hexadecimal,is_hexa_digit,_he_,_hf_)}
    function scan_sign(width,ib)
     {var c=checked_peek_char(ib),switcher=c - 43 | 0;
      if(! (2 < switcher >>> 0))
       switch(switcher)
        {case 0:return store_char(width,ib,c);
         case 1:break;
         default:return store_char(width,ib,c)}
      return width}
    function scan_optionally_signed_decimal_int(width,ib)
     {var width$0=scan_sign(width,ib);
      return scan_unsigned_decimal_int(width$0,ib)}
    function scan_int_conversion(conv,width$1,ib)
     {switch(conv)
       {case 0:return scan_binary_int(width$1,ib);
        case 1:return scan_optionally_signed_decimal_int(width$1,ib);
        case 2:
         var width$0=scan_sign(width$1,ib),c=checked_peek_char(ib);
         if(48 === c)
          {var width=store_char(width$0,ib,c);
           if(0 === width)return width;
           var c$0=peek_char(ib);
           if(ib[1])return width;
           if(99 <= c$0)
            {if(111 === c$0)
              return scan_octal_int(store_char(width,ib,c$0),ib);
             var switch$0=120 === c$0?1:0}
           else
            if(88 === c$0)
             var switch$0=1;
            else
             {if(98 <= c$0)
               return scan_binary_int(store_char(width,ib,c$0),ib);
              var switch$0=0}
           return switch$0
                   ?scan_hexadecimal_int(store_char(width,ib,c$0),ib)
                   :scan_decimal_digit_star(width,ib)}
         return scan_unsigned_decimal_int(width$0,ib);
        case 3:return scan_octal_int(width$1,ib);
        case 4:return scan_unsigned_decimal_int(width$1,ib);
        default:return scan_hexadecimal_int(width$1,ib)}}
    function scan_fractional_part(width,ib)
     {if(0 === width)return width;
      var c=peek_char(ib);
      if(ib[1])return width;
      var switcher=c - 48 | 0;
      return 9 < switcher >>> 0
              ?width
              :scan_decimal_digit_star(store_char(width,ib,c),ib)}
    function scan_exponent_part(width,ib)
     {if(0 === width)return width;
      var c=peek_char(ib);
      if(ib[1])return width;
      if(69 !== c)if(101 !== c)return width;
      return scan_optionally_signed_decimal_int(store_char(width,ib,c),ib)}
    function scan_float(width$1,precision,ib)
     {var
       width=scan_sign(width$1,ib),
       width$0=scan_decimal_digit_star(width,ib);
      if(0 === width$0)return [0,width$0,precision];
      var c=peek_char(ib);
      if(ib[1])return [0,width$0,precision];
      if(46 === c)
       {var
         width$2=store_char(width$0,ib,c),
         precision$0=min(width$2,precision),
         width$3=
          width$2
          -
          (precision$0 - scan_fractional_part(precision$0,ib) | 0)
          |
          0;
        return [0,scan_exponent_part(width$3,ib),precision$0]}
      return [0,scan_exponent_part(width$0,ib),precision]}
    function check_case_insensitive_string(width,ib,error,str)
     {function lowercase(c)
       {var switcher=c - 65 | 0;
        return 25 < switcher >>> 0?c:char_of_int((c - 65 | 0) + 97 | 0)}
      var
       len=caml_ml_string_length(str),
       width$0=[0,width],
       _hb_=len - 1 | 0,
       _ha_=0;
      if(! (_hb_ < 0))
       {var i=_ha_;
        for(;;)
         {var c=peek_char(ib),_hc_=lowercase(caml_string_get(str,i));
          if(lowercase(c) !== _hc_)caml_call1(error,0);
          if(0 === width$0[1])caml_call1(error,0);
          width$0[1] = store_char(width$0[1],ib,c);
          var _hd_=i + 1 | 0;
          if(_hb_ !== i){var i=_hd_;continue}
          break}}
      return width$0[1]}
    function scan_hex_float(width,precision,ib)
     {var _gZ_=0 === width?1:0,_g0_=_gZ_ || end_of_input(ib);
      if(_g0_)bad_hex_float(0);
      var
       width$0=scan_sign(width,ib),
       _g1_=0 === width$0?1:0,
       _g2_=_g1_ || end_of_input(ib);
      if(_g2_)bad_hex_float(0);
      var c=peek_char(ib);
      if(78 <= c)
       {var switcher=c - 79 | 0;
        if(30 < switcher >>> 0)
         {if(! (32 <= switcher))
           {var
             width$1=store_char(width$0,ib,c),
             _g3_=0 === width$1?1:0,
             _g4_=_g3_ || end_of_input(ib);
            if(_g4_)bad_hex_float(0);
            return check_case_insensitive_string
                    (width$1,ib,bad_hex_float,cst_an)}
          var switch$0=0}
        else
         var switch$0=26 === switcher?1:0}
      else
       {if(48 === c)
         {var
           width$3=store_char(width$0,ib,c),
           _g7_=0 === width$3?1:0,
           _g8_=_g7_ || end_of_input(ib);
          if(_g8_)bad_hex_float(0);
          var
           width$4=
            check_case_insensitive_string(width$3,ib,bad_hex_float,cst_x$2);
          if(0 !== width$4)
           if(! end_of_input(ib))
            {var
              match=peek_char(ib),
              _g9_=match - 46 | 0,
              switch$1=
               34 < _g9_ >>> 0?66 === _g9_?1:0:32 < (_g9_ - 1 | 0) >>> 0?1:0,
              width$5=switch$1?width$4:scan_hexadecimal_int(width$4,ib);
             if(0 !== width$5)
              if(! end_of_input(ib))
               {var c$0=peek_char(ib);
                if(46 === c$0)
                 {var width$6=store_char(width$5,ib,c$0);
                  if(0 === width$6)
                   var switch$2=0;
                  else
                   if(end_of_input(ib))
                    var switch$2=0;
                   else
                    {var match$0=peek_char(ib);
                     if(80 === match$0)
                      var switch$3=0;
                     else
                      if(112 === match$0)
                       var switch$3=0;
                      else
                       var
                        precision$0=min(width$6,precision),
                        width$10=
                         width$6
                         -
                         (precision$0 - scan_hexadecimal_int(precision$0,ib) | 0)
                         |
                         0,
                        switch$3=1;
                     if(! switch$3)var width$10=width$6;
                     var width$7=width$10,switch$2=1}
                  if(! switch$2)var width$7=width$6;
                  var width$8=width$7}
                else
                 var width$8=width$5;
                if(0 !== width$8)
                 if(! end_of_input(ib))
                  {var c$1=peek_char(ib);
                   if(80 !== c$1)if(112 !== c$1)return width$8;
                   var
                    width$9=store_char(width$8,ib,c$1),
                    _g__=0 === width$9?1:0,
                    _g$_=_g__ || end_of_input(ib);
                   if(_g$_)bad_hex_float(0);
                   return scan_optionally_signed_decimal_int(width$9,ib)}
                return width$8}
             return width$5}
          return width$4}
        var switch$0=73 === c?1:0}
      if(switch$0)
       {var
         width$2=store_char(width$0,ib,c),
         _g5_=0 === width$2?1:0,
         _g6_=_g5_ || end_of_input(ib);
        if(_g6_)bad_hex_float(0);
        return check_case_insensitive_string
                (width$2,ib,bad_hex_float,cst_nfinity)}
      return bad_hex_float(0)}
    function scan_caml_float_rest(width,precision,ib)
     {var _gV_=0 === width?1:0,_gW_=_gV_ || end_of_input(ib);
      if(_gW_)bad_float(0);
      var
       width$0=scan_decimal_digit_star(width,ib),
       _gX_=0 === width$0?1:0,
       _gY_=_gX_ || end_of_input(ib);
      if(_gY_)bad_float(0);
      var c=peek_char(ib),switcher=c - 69 | 0;
      if(32 < switcher >>> 0)
       {if(-23 === switcher)
         {var
           width$1=store_char(width$0,ib,c),
           precision$0=min(width$1,precision),
           width_precision=scan_fractional_part(precision$0,ib),
           frac_width=precision$0 - width_precision | 0,
           width$2=width$1 - frac_width | 0;
          return scan_exponent_part(width$2,ib)}}
      else
       {var switcher$0=switcher - 1 | 0;
        if(30 < switcher$0 >>> 0)return scan_exponent_part(width$0,ib)}
      return bad_float(0)}
    function scan_caml_float(width,precision,ib)
     {var _gH_=0 === width?1:0,_gI_=_gH_ || end_of_input(ib);
      if(_gI_)bad_float(0);
      var
       width$0=scan_sign(width,ib),
       _gJ_=0 === width$0?1:0,
       _gK_=_gJ_ || end_of_input(ib);
      if(_gK_)bad_float(0);
      var c=peek_char(ib);
      if(49 <= c)
       {if(! (58 <= c))
         {var
           width$1=store_char(width$0,ib,c),
           _gL_=0 === width$1?1:0,
           _gM_=_gL_ || end_of_input(ib);
          if(_gM_)bad_float(0);
          return scan_caml_float_rest(width$1,precision,ib)}}
      else
       if(48 <= c)
        {var
          width$2=store_char(width$0,ib,c),
          _gN_=0 === width$2?1:0,
          _gO_=_gN_ || end_of_input(ib);
         if(_gO_)bad_float(0);
         var c$0=peek_char(ib);
         if(88 !== c$0)
          if(120 !== c$0)return scan_caml_float_rest(width$2,precision,ib);
         var
          width$3=store_char(width$2,ib,c$0),
          _gP_=0 === width$3?1:0,
          _gQ_=_gP_ || end_of_input(ib);
         if(_gQ_)bad_float(0);
         var
          width$4=scan_hexadecimal_int(width$3,ib),
          _gR_=0 === width$4?1:0,
          _gS_=_gR_ || end_of_input(ib);
         if(_gS_)bad_float(0);
         var c$1=peek_char(ib),switcher=c$1 - 80 | 0;
         if(32 < switcher >>> 0)
          if(-34 === switcher)
           {var width$5=store_char(width$4,ib,c$1);
            if(0 === width$5)
             var switch$1=0;
            else
             if(end_of_input(ib))
              var switch$1=0;
             else
              {var match=peek_char(ib);
               if(80 === match)
                var switch$2=0;
               else
                if(112 === match)
                 var switch$2=0;
                else
                 var
                  precision$0=min(width$5,precision),
                  width$10=
                   width$5
                   -
                   (precision$0 - scan_hexadecimal_int(precision$0,ib) | 0)
                   |
                   0,
                  switch$2=1;
               if(! switch$2)var width$10=width$5;
               var width$6=width$10,switch$1=1}
            if(! switch$1)var width$6=width$5;
            var width$7=width$6,switch$0=0}
          else
           var switch$0=1;
         else
          {var switcher$0=switcher - 1 | 0;
           if(30 < switcher$0 >>> 0)
            var width$7=width$4,switch$0=0;
           else
            var switch$0=1}
         var width$8=switch$0?bad_float(0):width$7;
         if(0 !== width$8)
          if(! end_of_input(ib))
           {var c$2=peek_char(ib);
            if(80 !== c$2)if(112 !== c$2)return width$8;
            var
             width$9=store_char(width$8,ib,c$2),
             _gT_=0 === width$9?1:0,
             _gU_=_gT_ || end_of_input(ib);
            if(_gU_)bad_hex_float(0);
            return scan_optionally_signed_decimal_int(width$9,ib)}
         return width$8}
      return bad_float(0)}
    function scan_string(stp,width,ib)
     {var width$0=width;
      for(;;)
       {if(0 === width$0)return width$0;
        var c=peek_char(ib);
        if(ib[1])return width$0;
        if(stp)
         {var c$0=stp[1];
          if(c === c$0)return skip_char(width$0,ib);
          var width$1=store_char(width$0,ib,c),width$0=width$1;
          continue}
        var
         _gG_=c - 9 | 0,
         switch$0=4 < _gG_ >>> 0?23 === _gG_?1:0:1 < (_gG_ - 2 | 0) >>> 0?1:0;
        if(switch$0)return width$0;
        var width$2=store_char(width$0,ib,c),width$0=width$2;
        continue}}
    function scan_char(width,ib)
     {return store_char(width,ib,checked_peek_char(ib))}
    function hexadecimal_value_of_char(d)
     {return 97 <= d?d - 87 | 0:65 <= d?d - 55 | 0:d - 48 | 0}
    function check_next_char(message,width,ib)
     {if(0 === width)return bad_token_length(message);
      var c=peek_char(ib);
      return ib[1]?bad_input(caml_call1(sprintf(_b$_),message)):c}
    function check_next_char_for_char(_gE_,_gF_)
     {return check_next_char(cst_a_Char,_gE_,_gF_)}
    function check_next_char_for_string(_gC_,_gD_)
     {return check_next_char(cst_a_String,_gC_,_gD_)}
    function scan_backslash_char(width,ib)
     {var c0=check_next_char_for_char(width,ib);
      if(40 <= c0)
       if(58 <= c0)
        {var switcher$0=c0 - 92 | 0;
         if(28 < switcher$0 >>> 0)
          var switch$0=0;
         else
          switch(switcher$0)
           {case 28:
             var
              get_digit=
               function(param)
                {var
                  c=next_char(ib),
                  _gB_=c - 48 | 0,
                  switch$0=
                   22 < _gB_ >>> 0
                    ?5 < (_gB_ - 49 | 0) >>> 0?0:1
                    :6 < (_gB_ - 10 | 0) >>> 0?1:0;
                 return switch$0?c:bad_input_escape(c)},
              c1=get_digit(0),
              c2=get_digit(0),
              _gx_=hexadecimal_value_of_char(c2),
              c$0=(16 * hexadecimal_value_of_char(c1) | 0) + _gx_ | 0;
             if(0 <= c$0)
              if(255 < c$0)
               var switch$1=0;
              else
               var _gz_=char_of_int(c$0),switch$1=1;
             else
              var switch$1=0;
             if(! switch$1)
              var _gz_=bad_input(caml_call2(sprintf(_cg_),c1,c2));
             return store_char(width - 2 | 0,ib,_gz_);
            case 0:
            case 6:
            case 18:
            case 22:
            case 24:var switch$0=1;break;
            default:var switch$0=0}}
       else
        {if(48 <= c0)
          {var
            get_digit$0=
             function(param)
              {var c=next_char(ib),switcher=c - 48 | 0;
               return 9 < switcher >>> 0?bad_input_escape(c):c},
            c1$0=get_digit$0(0),
            c2$0=get_digit$0(0),
            c=
             ((100 * (c0 - 48 | 0) | 0) + (10 * (c1$0 - 48 | 0) | 0) | 0)
             +
             (c2$0 - 48 | 0)
             |
             0;
           if(0 <= c)
            if(255 < c)var switch$2=0;else var _gA_=char_of_int(c),switch$2=1;
           else
            var switch$2=0;
           if(! switch$2)
            var _gA_=bad_input(caml_call3(sprintf(_cf_),c0,c1$0,c2$0));
           return store_char(width - 2 | 0,ib,_gA_)}
         var switch$0=0}
      else
       var switch$0=34 === c0?1:39 <= c0?1:0;
      if(switch$0)
       {if(110 <= c0)
         if(117 <= c0)
          var switch$3=0;
         else
          {var switcher=c0 - 110 | 0;
           switch(switcher)
            {case 0:var _gy_=10,switch$3=1;break;
             case 4:var _gy_=13,switch$3=1;break;
             case 6:var _gy_=9,switch$3=1;break;
             default:var switch$3=0}}
        else
         if(98 === c0)var _gy_=8,switch$3=1;else var switch$3=0;
        if(! switch$3)var _gy_=c0;
        return store_char(width,ib,_gy_)}
      return bad_input_escape(c0)}
    function scan_caml_char(width,ib)
     {function find_stop(width)
       {var c=check_next_char_for_char(width,ib);
        return 39 === c?ignore_char(width,ib):character_mismatch(39,c)}
      var c=checked_peek_char(ib);
      if(39 === c)
       {var
         width$0=ignore_char(width,ib),
         c$0=check_next_char_for_char(width$0,ib);
        return 92 === c$0
                ?find_stop(scan_backslash_char(ignore_char(width$0,ib),ib))
                :find_stop(store_char(width$0,ib,c$0))}
      return character_mismatch(39,c)}
    function scan_caml_string(width,ib)
     {function find_stop$0(counter,width)
       {var width$0=width;
        for(;;)
         {var c=check_next_char_for_string(width$0,ib);
          if(34 === c)return ignore_char(width$0,ib);
          if(92 === c)
           {var
             width$1=ignore_char(width$0,ib),
             match=check_next_char_for_string(width$1,ib);
            if(10 === match)
             {var _gv_=ignore_char(width$1,ib);
              if(counter < 50)
               {var counter$0=counter + 1 | 0;
                return skip_spaces(counter$0,_gv_)}
              return caml_trampoline_return(skip_spaces,[0,_gv_])}
            if(13 === match)
             {var
               width$3=ignore_char(width$1,ib),
               match$0=check_next_char_for_string(width$3,ib);
              if(10 === match$0)
               {var _gw_=ignore_char(width$3,ib);
                if(counter < 50)
                 {var counter$1=counter + 1 | 0;
                  return skip_spaces(counter$1,_gw_)}
                return caml_trampoline_return(skip_spaces,[0,_gw_])}
              var width$5=store_char(width$3,ib,13),width$0=width$5;
              continue}
            var width$4=scan_backslash_char(width$1,ib),width$0=width$4;
            continue}
          var width$2=store_char(width$0,ib,c),width$0=width$2;
          continue}}
      function skip_spaces(counter,width)
       {var width$0=width;
        for(;;)
         {var match=check_next_char_for_string(width$0,ib);
          if(32 === match)
           {var width$1=ignore_char(width$0,ib),width$0=width$1;continue}
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return find_stop$0(counter$0,width$0)}
          return caml_trampoline_return(find_stop$0,[0,width$0])}}
      function find_stop(width){return caml_trampoline(find_stop$0(0,width))}
      var c=checked_peek_char(ib);
      return 34 === c
              ?find_stop(ignore_char(width,ib))
              :character_mismatch(34,c)}
    function scan_chars_in_char_set(char_set,scan_indic,width,ib)
     {function scan_chars(i,stp)
       {var i$0=i;
        for(;;)
         {var c=peek_char(ib),_gr_=0 < i$0?1:0;
          if(_gr_)
           {var _gs_=1 - ib[1];
            if(_gs_)
             var _gt_=is_in_char_set(char_set,c),_gu_=_gt_?c !== stp?1:0:_gt_;
            else
             var _gu_=_gs_}
          else
           var _gu_=_gr_;
          if(_gu_)
           {store_char(max_int,ib,c);var i$1=i$0 - 1 | 0,i$0=i$1;continue}
          return _gu_}}
      if(scan_indic)
       {var c=scan_indic[1];
        scan_chars(width,c);
        var _gq_=1 - ib[1];
        if(_gq_)
         {var ci=peek_char(ib);
          return c === ci?invalidate_current_char(ib):character_mismatch(c,ci)}
        return _gq_}
      return scan_chars(width,-1)}
    function scanf_bad_input(ib,x)
     {if(x[1] === Scan_failure)
       var s=x[2];
      else
       {if(x[1] !== Failure)throw x;var s=x[2]}
      var i=char_count(ib);
      return bad_input(caml_call2(sprintf(_ci_),i,s))}
    function get_counter(ib,counter)
     {switch(counter)
       {case 0:return ib[5];case 1:return char_count(ib);default:return ib[6]}}
    function width_of_pad_opt(pad_opt)
     {if(pad_opt){var width=pad_opt[1];return width}return max_int}
    function stopper_of_formatting_lit(fmting)
     {if(6 === fmting)return _cj_;
      var
       str=string_of_formatting_lit(fmting),
       stp=caml_string_get(str,1),
       sub_str=sub$0(str,2,caml_ml_string_length(str) - 2 | 0);
      return [0,stp,sub_str]}
    function take_format_readers$0(counter,k,fmt)
     {var fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k,0);
       else
        switch(fmt$0[0])
         {case 0:var fmt$1=fmt$0[1],fmt$0=fmt$1;continue;
          case 1:var fmt$2=fmt$0[1],fmt$0=fmt$2;continue;
          case 2:var fmt$3=fmt$0[2],fmt$0=fmt$3;continue;
          case 3:var fmt$4=fmt$0[2],fmt$0=fmt$4;continue;
          case 4:var fmt$5=fmt$0[4],fmt$0=fmt$5;continue;
          case 5:var fmt$6=fmt$0[4],fmt$0=fmt$6;continue;
          case 6:var fmt$7=fmt$0[4],fmt$0=fmt$7;continue;
          case 7:var fmt$8=fmt$0[4],fmt$0=fmt$8;continue;
          case 8:var fmt$9=fmt$0[4],fmt$0=fmt$9;continue;
          case 9:var fmt$10=fmt$0[2],fmt$0=fmt$10;continue;
          case 10:var fmt$11=fmt$0[1],fmt$0=fmt$11;continue;
          case 11:var fmt$12=fmt$0[2],fmt$0=fmt$12;continue;
          case 12:var fmt$13=fmt$0[2],fmt$0=fmt$13;continue;
          case 13:var fmt$14=fmt$0[3],fmt$0=fmt$14;continue;
          case 14:
           var rest=fmt$0[3],fmtty=fmt$0[2],_go_=erase_rel(symm(fmtty));
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return take_fmtty_format_readers$0(counter$0,k,_go_,rest)}
           return caml_trampoline_return
                   (take_fmtty_format_readers$0,[0,k,_go_,rest]);
          case 15:var fmt$15=fmt$0[1],fmt$0=fmt$15;continue;
          case 16:var fmt$16=fmt$0[1],fmt$0=fmt$16;continue;
          case 17:var fmt$17=fmt$0[2],fmt$0=fmt$17;continue;
          case 18:
           var _gp_=fmt$0[1];
           if(0 === _gp_[0])
            {var
              rest$0=fmt$0[2],
              match=_gp_[1],
              fmt$18=match[1],
              fmt$19=concat_fmt(fmt$18,rest$0),
              fmt$0=fmt$19;
             continue}
           var
            rest$1=fmt$0[2],
            match$0=_gp_[1],
            fmt$20=match$0[1],
            fmt$21=concat_fmt(fmt$20,rest$1),
            fmt$0=fmt$21;
           continue;
          case 19:
           var fmt_rest=fmt$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_format_readers(new_k,fmt_rest)};
          case 20:var fmt$22=fmt$0[3],fmt$0=fmt$22;continue;
          case 21:var fmt$23=fmt$0[2],fmt$0=fmt$23;continue;
          case 22:var fmt$24=fmt$0[1],fmt$0=fmt$24;continue;
          case 23:
           var rest$2=fmt$0[2],ign=fmt$0[1];
           if(typeof ign === "number")
            switch(ign)
             {case 0:var fmt$0=rest$2;continue;
              case 1:var fmt$0=rest$2;continue;
              case 2:
               return function(reader)
                {function new_k(readers_rest)
                  {return caml_call1(k,[0,reader,readers_rest])}
                 return take_format_readers(new_k,rest$2)};
              default:var fmt$0=rest$2;continue}
           else
            switch(ign[0])
             {case 0:var fmt$0=rest$2;continue;
              case 1:var fmt$0=rest$2;continue;
              case 2:var fmt$0=rest$2;continue;
              case 3:var fmt$0=rest$2;continue;
              case 4:var fmt$0=rest$2;continue;
              case 5:var fmt$0=rest$2;continue;
              case 6:var fmt$0=rest$2;continue;
              case 7:var fmt$0=rest$2;continue;
              case 8:var fmt$0=rest$2;continue;
              case 9:
               var fmtty$0=ign[2];
               if(counter < 50)
                {var counter$1=counter + 1 | 0;
                 return take_fmtty_format_readers$0
                         (counter$1,k,fmtty$0,rest$2)}
               return caml_trampoline_return
                       (take_fmtty_format_readers$0,[0,k,fmtty$0,rest$2]);
              case 10:var fmt$0=rest$2;continue;
              default:var fmt$0=rest$2;continue}
          default:var fmt$25=fmt$0[3],fmt$0=fmt$25;continue}}
    function take_fmtty_format_readers$0(counter,k,fmtty,fmt)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        {if(counter < 50)
          {var counter$0=counter + 1 | 0;
           return take_format_readers$0(counter$0,k,fmt)}
         return caml_trampoline_return(take_format_readers$0,[0,k,fmt])}
       else
        switch(fmtty$0[0])
         {case 0:var fmtty$1=fmtty$0[1],fmtty$0=fmtty$1;continue;
          case 1:var fmtty$2=fmtty$0[1],fmtty$0=fmtty$2;continue;
          case 2:var fmtty$3=fmtty$0[1],fmtty$0=fmtty$3;continue;
          case 3:var fmtty$4=fmtty$0[1],fmtty$0=fmtty$4;continue;
          case 4:var fmtty$5=fmtty$0[1],fmtty$0=fmtty$5;continue;
          case 5:var fmtty$6=fmtty$0[1],fmtty$0=fmtty$6;continue;
          case 6:var fmtty$7=fmtty$0[1],fmtty$0=fmtty$7;continue;
          case 7:var fmtty$8=fmtty$0[1],fmtty$0=fmtty$8;continue;
          case 8:var fmtty$9=fmtty$0[2],fmtty$0=fmtty$9;continue;
          case 9:
           var
            rest=fmtty$0[3],
            ty2=fmtty$0[2],
            ty1=fmtty$0[1],
            ty=trans(symm(ty1),ty2),
            fmtty$10=concat_fmtty(ty,rest),
            fmtty$0=fmtty$10;
           continue;
          case 10:var fmtty$11=fmtty$0[1],fmtty$0=fmtty$11;continue;
          case 11:var fmtty$12=fmtty$0[1],fmtty$0=fmtty$12;continue;
          case 12:var fmtty$13=fmtty$0[1],fmtty$0=fmtty$13;continue;
          case 13:
           var fmt_rest=fmtty$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_fmtty_format_readers(new_k,fmt_rest,fmt)};
          default:
           var fmt_rest$0=fmtty$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_fmtty_format_readers(new_k,fmt_rest$0,fmt)}}}
    function take_format_readers(k,fmt)
     {return caml_trampoline(take_format_readers$0(0,k,fmt))}
    function take_fmtty_format_readers(k,fmtty,fmt)
     {return caml_trampoline(take_fmtty_format_readers$0(0,k,fmtty,fmt))}
    function pad_prec_scanf(ib,fmt,readers,pad,prec,scan,token)
     {if(typeof pad === "number")
       {if(typeof prec === "number")
         {if(0 === prec)
           {caml_call3(scan,max_int,max_int,ib);
            var x=caml_call1(token,ib);
            return [0,x,make_scanf(ib,fmt,readers)]}
          return invalid_arg(cst_scanf_bad_conversion)}
        var p=prec[1];
        caml_call3(scan,max_int,p,ib);
        var x$0=caml_call1(token,ib);
        return [0,x$0,make_scanf(ib,fmt,readers)]}
      else
       {if(0 === pad[0])
         {if(0 === pad[1])return invalid_arg(cst_scanf_bad_conversion$0);
          var _gn_=pad[2];
          if(typeof prec === "number")
           {if(0 === prec)
             {caml_call3(scan,_gn_,max_int,ib);
              var x$1=caml_call1(token,ib);
              return [0,x$1,make_scanf(ib,fmt,readers)]}
            return invalid_arg(cst_scanf_bad_conversion$1)}
          var p$0=prec[1];
          caml_call3(scan,_gn_,p$0,ib);
          var x$2=caml_call1(token,ib);
          return [0,x$2,make_scanf(ib,fmt,readers)]}
        return invalid_arg(cst_scanf_bad_conversion$2)}}
    function make_scanf(ib,fmt,readers)
     {var fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return 0;
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1];
           scan_char(0,ib);
           var c=token_char(ib);
           return [0,c,make_scanf(ib,rest,readers)];
          case 1:
           var rest$0=fmt$0[1];
           scan_caml_char(0,ib);
           var c$0=token_char(ib);
           return [0,c$0,make_scanf(ib,rest$0,readers)];
          case 2:
           var _f__=fmt$0[2],_f$_=fmt$0[1];
           if(typeof _f__ !== "number")
            switch(_f__[0])
             {case 17:
               var
                rest$1=_f__[2],
                fmting_lit=_f__[1],
                match=stopper_of_formatting_lit(fmting_lit),
                str=match[2],
                stp=match[1],
                scan$0=
                 function(width,param,ib)
                  {return scan_string([0,stp],width,ib)},
                str_rest=[11,str,rest$1];
               return pad_prec_scanf
                       (ib,str_rest,readers,_f$_,0,scan$0,token_string);
              case 18:
               var _ga_=_f__[1];
               if(0 === _ga_[0])
                {var
                  rest$2=_f__[2],
                  match$0=_ga_[1],
                  fmt$1=match$0[1],
                  scan$1=
                   function(width,param,ib){return scan_string(_ck_,width,ib)};
                 return pad_prec_scanf
                         (ib,
                          concat_fmt(fmt$1,rest$2),
                          readers,
                          _f$_,
                          0,
                          scan$1,
                          token_string)}
               var
                rest$3=_f__[2],
                match$1=_ga_[1],
                fmt$2=match$1[1],
                scan$2=
                 function(width,param,ib){return scan_string(_cl_,width,ib)};
               return pad_prec_scanf
                       (ib,
                        concat_fmt(fmt$2,rest$3),
                        readers,
                        _f$_,
                        0,
                        scan$2,
                        token_string)
              }
           var scan=function(width,param,ib){return scan_string(0,width,ib)};
           return pad_prec_scanf(ib,_f__,readers,_f$_,0,scan,token_string);
          case 3:
           var
            rest$4=fmt$0[2],
            pad=fmt$0[1],
            scan$3=function(width,param,ib){return scan_caml_string(width,ib)};
           return pad_prec_scanf(ib,rest$4,readers,pad,0,scan$3,token_string);
          case 4:
           var
            rest$5=fmt$0[4],
            prec=fmt$0[3],
            pad$0=fmt$0[2],
            iconv=fmt$0[1],
            conv=integer_conversion_of_char(char_of_iconv(iconv)),
            scan$4=
             function(width,param,ib)
              {return scan_int_conversion(conv,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$5,
                    readers,
                    pad$0,
                    prec,
                    scan$4,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv,ib))});
          case 5:
           var
            rest$6=fmt$0[4],
            prec$0=fmt$0[3],
            pad$1=fmt$0[2],
            iconv$0=fmt$0[1],
            conv$0=integer_conversion_of_char(char_of_iconv(iconv$0)),
            scan$5=
             function(width,param,ib)
              {return scan_int_conversion(conv$0,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$6,
                    readers,
                    pad$1,
                    prec$0,
                    scan$5,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv$0,ib))});
          case 6:
           var
            rest$7=fmt$0[4],
            prec$1=fmt$0[3],
            pad$2=fmt$0[2],
            iconv$1=fmt$0[1],
            conv$1=integer_conversion_of_char(char_of_iconv(iconv$1)),
            scan$6=
             function(width,param,ib)
              {return scan_int_conversion(conv$1,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$7,
                    readers,
                    pad$2,
                    prec$1,
                    scan$6,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv$1,ib))});
          case 7:
           var
            rest$8=fmt$0[4],
            prec$2=fmt$0[3],
            pad$3=fmt$0[2],
            iconv$2=fmt$0[1],
            conv$2=integer_conversion_of_char(char_of_iconv(iconv$2)),
            scan$7=
             function(width,param,ib)
              {return scan_int_conversion(conv$2,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$8,
                    readers,
                    pad$3,
                    prec$2,
                    scan$7,
                    function(ib)
                     {return caml_int64_of_string(token_int_literal(conv$2,ib))});
          case 8:
           var _gb_=fmt$0[1];
           if(15 === _gb_)
            {var rest$9=fmt$0[4],prec$3=fmt$0[3],pad$4=fmt$0[2];
             return pad_prec_scanf
                     (ib,rest$9,readers,pad$4,prec$3,scan_caml_float,token_float)}
           if(16 <= _gb_)
            {var rest$10=fmt$0[4],prec$4=fmt$0[3],pad$5=fmt$0[2];
             return pad_prec_scanf
                     (ib,rest$10,readers,pad$5,prec$4,scan_hex_float,token_float)}
           var rest$11=fmt$0[4],prec$5=fmt$0[3],pad$6=fmt$0[2];
           return pad_prec_scanf
                   (ib,rest$11,readers,pad$6,prec$5,scan_float,token_float);
          case 9:
           var
            rest$12=fmt$0[2],
            pad$7=fmt$0[1],
            scan$8=
             function(param,_gm_,ib)
              {var
                c=checked_peek_char(ib),
                m=
                 102 === c
                  ?5
                  :116 === c?4:bad_input(caml_call1(sprintf(_ch_),c));
               return scan_string(0,m,ib)};
           return pad_prec_scanf(ib,rest$12,readers,pad$7,0,scan$8,token_bool);
          case 10:
           var rest$13=fmt$0[1];
           if(end_of_input(ib)){var fmt$0=rest$13;continue}
           return bad_input(cst_end_of_input_not_found);
          case 11:
           var rest$14=fmt$0[2],str$0=fmt$0[1];
           iter$1(function(_gl_){return check_char(ib,_gl_)},str$0);
           var fmt$0=rest$14;
           continue;
          case 12:
           var rest$15=fmt$0[2],chr=fmt$0[1];
           check_char(ib,chr);
           var fmt$0=rest$15;
           continue;
          case 13:
           var rest$16=fmt$0[3],fmtty=fmt$0[2],pad_opt=fmt$0[1];
           scan_caml_string(width_of_pad_opt(pad_opt),ib);
           var s=token_string(ib);
           try
            {var _gc_=format_of_string_fmtty(s,fmtty),fmt$3=_gc_}
           catch(exn)
            {exn = caml_wrap_exception(exn);
             if(exn[1] !== Failure)throw exn;
             var msg=exn[2],fmt$3=bad_input(msg)}
           return [0,fmt$3,make_scanf(ib,rest$16,readers)];
          case 14:
           var rest$17=fmt$0[3],fmtty$0=fmt$0[2],pad_opt$0=fmt$0[1];
           scan_caml_string(width_of_pad_opt(pad_opt$0),ib);
           var s$0=token_string(ib);
           try
            {var
              match$2=fmt_ebb_of_string(0,s$0),
              fmt$6=match$2[1],
              match$3=fmt_ebb_of_string(0,s$0),
              fmt$7=match$3[1],
              fmt$8=type_format(fmt$7,erase_rel(symm(fmtty$0))),
              _ge_=type_format(fmt$6,erase_rel(fmtty$0)),
              fmt$5=_ge_,
              fmt$4=fmt$8}
           catch(exn)
            {exn = caml_wrap_exception(exn);
             if(exn[1] !== Failure)throw exn;
             var
              msg$0=exn[2],
              _gd_=bad_input(msg$0),
              fmt$5=_gd_[1],
              fmt$4=_gd_[2]}
           return [0,
                   [0,fmt$5,s$0],
                   make_scanf(ib,concat_fmt(fmt$4,rest$17),readers)];
          case 15:return invalid_arg(cst_scanf_bad_conversion_a);
          case 16:return invalid_arg(cst_scanf_bad_conversion_t);
          case 17:
           var
            rest$18=fmt$0[2],
            formatting_lit=fmt$0[1],
            _gf_=string_of_formatting_lit(formatting_lit);
           iter$1(function(_gk_){return check_char(ib,_gk_)},_gf_);
           var fmt$0=rest$18;
           continue;
          case 18:
           var _gg_=fmt$0[1];
           if(0 === _gg_[0])
            {var rest$19=fmt$0[2],match$4=_gg_[1],fmt$9=match$4[1];
             check_char(ib,64);
             check_char(ib,123);
             var fmt$10=concat_fmt(fmt$9,rest$19),fmt$0=fmt$10;
             continue}
           var rest$20=fmt$0[2],match$5=_gg_[1],fmt$11=match$5[1];
           check_char(ib,64);
           check_char(ib,91);
           var fmt$12=concat_fmt(fmt$11,rest$20),fmt$0=fmt$12;
           continue;
          case 19:
           var fmt_rest=fmt$0[1];
           if(readers)
            {var
              readers_rest=readers[2],
              reader=readers[1],
              x=caml_call1(reader,ib);
             return [0,x,make_scanf(ib,fmt_rest,readers_rest)]}
           return invalid_arg(cst_scanf_missing_reader);
          case 20:
           var _gh_=fmt$0[3],_gi_=fmt$0[2],_gj_=fmt$0[1];
           if(typeof _gh_ !== "number" && 17 === _gh_[0])
            {var
              rest$21=_gh_[2],
              fmting_lit$0=_gh_[1],
              match$6=stopper_of_formatting_lit(fmting_lit$0),
              str$1=match$6[2],
              stp$0=match$6[1],
              width$0=width_of_pad_opt(_gj_);
             scan_chars_in_char_set(_gi_,[0,stp$0],width$0,ib);
             var s$2=token_string(ib),str_rest$0=[11,str$1,rest$21];
             return [0,s$2,make_scanf(ib,str_rest$0,readers)]}
           var width=width_of_pad_opt(_gj_);
           scan_chars_in_char_set(_gi_,0,width,ib);
           var s$1=token_string(ib);
           return [0,s$1,make_scanf(ib,_gh_,readers)];
          case 21:
           var
            rest$22=fmt$0[2],
            counter=fmt$0[1],
            count=get_counter(ib,counter);
           return [0,count,make_scanf(ib,rest$22,readers)];
          case 22:
           var rest$23=fmt$0[1],c$1=checked_peek_char(ib);
           return [0,c$1,make_scanf(ib,rest$23,readers)];
          case 23:
           var
            rest$24=fmt$0[2],
            ign=fmt$0[1],
            match$7=param_format_of_ignored_format(ign,rest$24),
            fmt$13=match$7[1],
            match$8=make_scanf(ib,fmt$13,readers);
           if(match$8){var arg_rest=match$8[2];return arg_rest}
           throw [0,Assert_failure,_cm_];
          default:
           return invalid_arg(cst_scanf_bad_conversion_custom_converter)}}
    function kscanf(ib,ef,param)
     {var str=param[2],fmt=param[1];
      function apply(f,args)
       {var f$0=f,args$0=args;
        for(;;)
         {if(args$0)
           {var
             r=args$0[2],
             x=args$0[1],
             f$1=caml_call1(f$0,x),
             f$0=f$1,
             args$0=r;
            continue}
          return f$0}}
      function k(readers,f)
       {reset_token(ib);
        try
         {var _f9_=[0,make_scanf(ib,fmt,readers)],_f8_=_f9_}
        catch(exc)
         {exc = caml_wrap_exception(exc);
          if(exc[1] === Scan_failure)
           var switch$0=0;
          else
           if(exc[1] === Failure)
            var switch$0=0;
           else
            if(exc === End_of_file)
             var switch$0=0;
            else
             {if(exc[1] !== Invalid_argument)throw exc;
              var
               msg=exc[2],
               _f7_=
                invalid_arg
                 (symbol
                   (msg,symbol(cst_in_format,symbol(escaped$1(str),cst$74)))),
               switch$0=1}
          if(! switch$0)var _f7_=[1,exc];
          var _f8_=_f7_}
        if(0 === _f8_[0]){var args=_f8_[1];return apply(f,args)}
        var exc=_f8_[1];
        return caml_call2(ef,ib,exc)}
      return take_format_readers(k,fmt)}
    function bscanf(ib,fmt){return kscanf(ib,scanf_bad_input,fmt)}
    function ksscanf(s,ef,fmt){return kscanf(from_string$1(s),ef,fmt)}
    function sscanf(s,fmt)
     {return kscanf(from_string$1(s),scanf_bad_input,fmt)}
    function scanf(fmt){return kscanf(stdib,scanf_bad_input,fmt)}
    function bscanf_format(ib,format,f)
     {scan_caml_string(max_int,ib);
      var str=token_string(ib);
      try
       {var _f6_=format_of_string_format(str,format),fmt=_f6_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] !== Failure)throw exn;
        var msg=exn[2],fmt=bad_input(msg)}
      return caml_call1(f,fmt)}
    function sscanf_format(s,format,f)
     {return bscanf_format(from_string$1(s),format,f)}
    function format_from_string(s,fmt)
     {var l=caml_ml_string_length(s);
      function _f5_(x){return x}
      var b=create$1(l + 2 | 0);
      add_char(b,34);
      var _f3_=l - 1 | 0,_f2_=0;
      if(! (_f3_ < 0))
       {var i=_f2_;
        for(;;)
         {var c=caml_string_get(s,i);
          if(34 === c)add_char(b,92);
          add_char(b,c);
          var _f4_=i + 1 | 0;
          if(_f3_ !== i){var i=_f4_;continue}
          break}}
      add_char(b,34);
      return sscanf_format(contents(b),fmt,_f5_)}
    function unescaped(s)
     {function _f1_(x){return x}
      return caml_call1(sscanf(symbol(cst$76,symbol(s,cst$75)),_cn_),_f1_)}
    function kfscanf(ic,ef,fmt){return kscanf(memo_from_channel(ic),ef,fmt)}
    function fscanf(ic,fmt)
     {return kscanf(memo_from_channel(ic),scanf_bad_input,fmt)}
    var
     Scanf=
      [0,
       [0,
        stdib,
        from_file,
        from_file_bin,
        close_in,
        from_file,
        from_file_bin,
        from_string$1,
        from_function$0,
        from_channel$0,
        end_of_input,
        beginning_of_input,
        name_of_input,
        stdib],
       Scan_failure,
       bscanf,
       sscanf,
       scanf,
       kscanf,
       ksscanf,
       bscanf_format,
       sscanf_format,
       format_from_string,
       unescaped,
       fscanf,
       kfscanf];
    caml_register_global(682,Scanf,"Scanf");
    var register=caml_register_named_value;
    function register_exception(name,exn)
     {var slot=caml_obj_tag(exn) === 248?exn:exn[1];
      return caml_register_named_value(name,slot)}
    var Callback=[0,register,register_exception];
    caml_register_global(683,Callback,"Callback");
    function copy$6(o){var o$0=o.slice();return caml_set_oo_id(o$0)}
    var params$0=[0,1,1,1,3,16],initial_object_size=2,dummy_item=0;
    function public_method_label(s)
     {var accu=[0,0],_fY_=caml_ml_string_length(s) - 1 | 0,_fX_=0;
      if(! (_fY_ < 0))
       {var i=_fX_;
        for(;;)
         {var _fZ_=caml_string_get(s,i);
          accu[1] = (223 * accu[1] | 0) + _fZ_ | 0;
          var _f0_=i + 1 | 0;
          if(_fY_ !== i){var i=_f0_;continue}
          break}}
      accu[1] = accu[1] & 2147483647;
      var tag=1073741823 < accu[1]?accu[1] + 2147483648 | 0:accu[1];
      return tag}
    var
     compare$6=caml_string_compare,
     Vars=caml_call1(Map[1],[0,compare$6]),
     compare$7=caml_string_compare,
     Meths=caml_call1(Map[1],[0,compare$7]),
     compare$8=caml_int_compare,
     Labs=caml_call1(Map[1],[0,compare$8]),
     dummy_table=[0,0,[0,dummy_item],Meths[1],Labs[1],0,0,Vars[1],0],
     table_count=[0,0],
     dummy_met=caml_obj_block(0,0);
    function fit_size(n){return 2 < n?fit_size((n + 1 | 0) / 2 | 0) * 2 | 0:n}
    function new_table(pub_labels)
     {table_count[1]++;
      var
       len=pub_labels.length - 1,
       methods=caml_make_vect((len * 2 | 0) + 2 | 0,dummy_met);
      caml_check_bound(methods,0)[1] = len;
      var _fR_=((fit_size(len) * 32 | 0) / 8 | 0) - 1 | 0;
      caml_check_bound(methods,1)[2] = _fR_;
      var _fT_=len - 1 | 0,_fS_=0;
      if(! (_fT_ < 0))
       {var i=_fS_;
        for(;;)
         {var
           _fV_=(i * 2 | 0) + 3 | 0,
           _fU_=caml_check_bound(pub_labels,i)[1 + i];
          caml_check_bound(methods,_fV_)[1 + _fV_] = _fU_;
          var _fW_=i + 1 | 0;
          if(_fT_ !== i){var i=_fW_;continue}
          break}}
      return [0,initial_object_size,methods,Meths[1],Labs[1],0,0,Vars[1],0]}
    function resize$1(array,new_size)
     {var old_size=array[2].length - 1,_fP_=old_size < new_size?1:0;
      if(_fP_)
       {var new_buck=caml_make_vect(new_size,dummy_met);
        blit$1(array[2],0,new_buck,0,old_size);
        array[2] = new_buck;
        var _fQ_=0}
      else
       var _fQ_=_fP_;
      return _fQ_}
    var method_count=[0,0],inst_var_count=[0,0];
    function new_method(table)
     {var index=table[2].length - 1;
      resize$1(table,index + 1 | 0);
      return index}
    function get_method_label(table,name)
     {try
       {var _fN_=caml_call2(Meths[27],name,table[3]);return _fN_}
      catch(_fO_)
       {_fO_ = caml_wrap_exception(_fO_);
        if(_fO_ === Not_found)
         {var label=new_method(table);
          table[3] = caml_call3(Meths[4],name,label,table[3]);
          table[4] = caml_call3(Labs[4],label,1,table[4]);
          return label}
        throw _fO_}}
    function get_method_labels(table,names)
     {return map$2(function(_fM_){return get_method_label(table,_fM_)},names)}
    function set_method(table,label,element)
     {method_count[1]++;
      return caml_call2(Labs[27],label,table[4])
              ?(resize$1(table,label + 1 | 0),
                caml_check_bound(table[2],label)[1 + label]
                =
                element,
                0)
              :(table[6] = [0,[0,label,element],table[6]],0)}
    function get_method(table,label)
     {try
       {var _fK_=assoc(label,table[6]);return _fK_}
      catch(_fL_)
       {_fL_ = caml_wrap_exception(_fL_);
        if(_fL_ === Not_found)
         return caml_check_bound(table[2],label)[1 + label];
        throw _fL_}}
    function to_list$0(arr){return arr === 0?0:to_list(arr)}
    function narrow(table,vars,virt_meths,concr_meths)
     {var
       vars$0=to_list$0(vars),
       virt_meths$0=to_list$0(virt_meths),
       concr_meths$0=to_list$0(concr_meths),
       virt_meth_labs=
        map(function(_fJ_){return get_method_label(table,_fJ_)},virt_meths$0),
       concr_meth_labs=
        map(function(_fI_){return get_method_label(table,_fI_)},concr_meths$0);
      table[5]
      =
      [0,
       [0,table[3],table[4],table[6],table[7],virt_meth_labs,vars$0],
       table[5]];
      var _fz_=Vars[1],_fA_=table[7];
      function _fB_(lab,info,tvars)
       {return mem(lab,vars$0)?caml_call3(Vars[4],lab,info,tvars):tvars}
      table[7] = caml_call3(Vars[13],_fB_,_fA_,_fz_);
      var by_name=[0,Meths[1]],by_label=[0,Labs[1]];
      iter2
       (function(met,label)
         {by_name[1] = caml_call3(Meths[4],met,label,by_name[1]);
          var _fE_=by_label[1];
          try
           {var _fG_=caml_call2(Labs[27],label,table[4]),_fF_=_fG_}
          catch(_fH_)
           {_fH_ = caml_wrap_exception(_fH_);
            if(_fH_ !== Not_found)throw _fH_;
            var _fF_=1}
          by_label[1] = caml_call3(Labs[4],label,_fF_,_fE_);
          return 0},
        concr_meths$0,
        concr_meth_labs);
      iter2
       (function(met,label)
         {by_name[1] = caml_call3(Meths[4],met,label,by_name[1]);
          by_label[1] = caml_call3(Labs[4],label,0,by_label[1]);
          return 0},
        virt_meths$0,
        virt_meth_labs);
      table[3] = by_name[1];
      table[4] = by_label[1];
      var _fC_=0,_fD_=table[6];
      table[6]
      =
      fold_right
       (function(met,hm)
         {var lab=met[1];return mem(lab,virt_meth_labs)?hm:[0,met,hm]},
        _fD_,
        _fC_);
      return 0}
    function widen(table)
     {var
       match=hd(table[5]),
       vars=match[6],
       virt_meths=match[5],
       saved_vars=match[4],
       saved_hidden_meths=match[3],
       by_label=match[2],
       by_name=match[1];
      table[5] = tl(table[5]);
      table[7]
      =
      fold_left
       (function(s,v)
         {var _fy_=caml_call2(Vars[27],v,table[7]);
          return caml_call3(Vars[4],v,_fy_,s)},
        saved_vars,
        vars);
      table[3] = by_name;
      table[4] = by_label;
      var _fx_=table[6];
      table[6]
      =
      fold_right
       (function(met,hm)
         {var lab=met[1];return mem(lab,virt_meths)?hm:[0,met,hm]},
        _fx_,
        saved_hidden_meths);
      return 0}
    function new_slot(table)
     {var index=table[1];table[1] = index + 1 | 0;return index}
    function new_variable(table,name)
     {try
       {var _fv_=caml_call2(Vars[27],name,table[7]);return _fv_}
      catch(_fw_)
       {_fw_ = caml_wrap_exception(_fw_);
        if(_fw_ === Not_found)
         {var index=new_slot(table);
          if(caml_string_notequal(name,cst$77))
           table[7] = caml_call3(Vars[4],name,index,table[7]);
          return index}
        throw _fw_}}
    function to_array(arr){return caml_equal(arr,0)?[0]:arr}
    function new_methods_variables(table,meths,vals)
     {var
       meths$0=to_array(meths),
       nmeths=meths$0.length - 1,
       nvals=vals.length - 1,
       res=caml_make_vect(nmeths + nvals | 0,0),
       _fn_=nmeths - 1 | 0,
       _fm_=0;
      if(! (_fn_ < 0))
       {var i$0=_fm_;
        for(;;)
         {var
           _ft_=
            get_method_label(table,caml_check_bound(meths$0,i$0)[1 + i$0]);
          caml_check_bound(res,i$0)[1 + i$0] = _ft_;
          var _fu_=i$0 + 1 | 0;
          if(_fn_ !== i$0){var i$0=_fu_;continue}
          break}}
      var _fp_=nvals - 1 | 0,_fo_=0;
      if(! (_fp_ < 0))
       {var i=_fo_;
        for(;;)
         {var
           _fr_=i + nmeths | 0,
           _fq_=new_variable(table,caml_check_bound(vals,i)[1 + i]);
          caml_check_bound(res,_fr_)[1 + _fr_] = _fq_;
          var _fs_=i + 1 | 0;
          if(_fp_ !== i){var i=_fs_;continue}
          break}}
      return res}
    function get_variable(table,name)
     {try
       {var _fk_=caml_call2(Vars[27],name,table[7]);return _fk_}
      catch(_fl_)
       {_fl_ = caml_wrap_exception(_fl_);
        if(_fl_ === Not_found)throw [0,Assert_failure,_co_];
        throw _fl_}}
    function get_variables(table,names)
     {return map$2(function(_fj_){return get_variable(table,_fj_)},names)}
    function add_initializer(table,f){table[8] = [0,f,table[8]];return 0}
    function create_table(public_methods)
     {if(public_methods === 0)return new_table([0]);
      var
       tags=map$2(public_method_label,public_methods),
       table=new_table(tags);
      iteri$2
       (function(i,met)
         {var lab=(i * 2 | 0) + 2 | 0;
          table[3] = caml_call3(Meths[4],met,lab,table[3]);
          table[4] = caml_call3(Labs[4],lab,1,table[4]);
          return 0},
        public_methods);
      return table}
    function init_class(table)
     {inst_var_count[1] = (inst_var_count[1] + table[1] | 0) - 1 | 0;
      table[8] = rev(table[8]);
      return resize$1
              (table,
               3 + ((caml_check_bound(table[2],1)[2] * 16 | 0) / 32 | 0) | 0)}
    function inherits(cla,vals,virt_meths,concr_meths,param,top)
     {var env=param[4],super$0=param[2];
      narrow(cla,vals,virt_meths,concr_meths);
      var init=top?caml_call2(super$0,cla,env):caml_call1(super$0,cla);
      widen(cla);
      var
       _fe_=0,
       _ff_=to_array(concr_meths),
       _fg_=
        [0,
         map$2
          (function(nm){return get_method(cla,get_method_label(cla,nm))},_ff_),
         _fe_],
       _fh_=to_array(vals);
      return caml_array_concat
              ([0,
                [0,init],
                [0,
                 map$2(function(_fi_){return get_variable(cla,_fi_)},_fh_),
                 _fg_]])}
    function make_class(pub_meths,class_init)
     {var table=create_table(pub_meths),env_init=caml_call1(class_init,table);
      init_class(table);
      return [0,caml_call1(env_init,0),class_init,env_init,0]}
    function make_class_store(pub_meths,class_init,init_table)
     {var table=create_table(pub_meths),env_init=caml_call1(class_init,table);
      init_class(table);
      init_table[2] = class_init;
      init_table[1] = env_init;
      return 0}
    function dummy_class(loc)
     {function undef(param){throw [0,Undefined_recursive_module,loc]}
      return [0,undef,undef,undef,0]}
    function create_object(table)
     {var obj=caml_obj_block(248,table[1]);
      obj[1] = table[2];
      return caml_set_oo_id(obj)}
    function create_object_opt(obj_0,table)
     {if(obj_0)return obj_0;
      var obj=caml_obj_block(248,table[1]);
      obj[1] = table[2];
      return caml_set_oo_id(obj)}
    function iter_f(obj,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],f=param$0[1];
          caml_call1(f,obj);
          var param$0=l;
          continue}
        return 0}}
    function run_initializers(obj,table)
     {var inits=table[8],_fd_=0 !== inits?1:0;
      return _fd_?iter_f(obj,inits):_fd_}
    function run_initializers_opt(obj_0,obj,table)
     {if(obj_0)return obj;
      var inits=table[8];
      if(0 !== inits)iter_f(obj,inits);
      return obj}
    function create_object_and_run_initializers(obj_0,table)
     {if(obj_0)return obj_0;
      var obj=create_object(table);
      run_initializers(obj,table);
      return obj}
    function get_data$0(param)
     {if(param)return param[2];throw [0,Assert_failure,_cs_]}
    function build_path(n,keys,tables)
     {var res=[0,0,0,0],r=[0,res],_e$_=0;
      if(! (n < 0))
       {var i=_e$_;
        for(;;)
         {var _fb_=r[1];
          r[1] = [0,caml_check_bound(keys,i)[1 + i],_fb_,0];
          var _fc_=i + 1 | 0;
          if(n !== i){var i=_fc_;continue}
          break}}
      var _fa_=r[1];
      if(tables){tables[2] = _fa_;return res}
      throw [0,Assert_failure,_cp_]}
    function lookup_tables(root,keys)
     {var tables$2=get_data$0(root);
      if(tables$2)
       {var i$1=keys.length - 1 - 1 | 0,i=i$1,tables=tables$2;
        a:
        for(;;)
         {if(0 <= i)
           {var key=caml_check_bound(keys,i)[1 + i],tables$0=tables;
            for(;;)
             {if(tables$0)
               {if(tables$0[1] === key)
                 {var tables$1=get_data$0(tables$0);
                  if(tables$1)
                   {var i$0=i - 1 | 0,i=i$0,tables=tables$1;continue a}
                  throw [0,Assert_failure,_cu_]}
                if(tables$0)
                 {var _e__=tables$0[3];
                  if(_e__){var tables$0=_e__;continue}
                  var v=[0,key,0,0];
                  if(tables$0)
                   {tables$0[3] = v;return build_path(i - 1 | 0,keys,v)}
                  throw [0,Assert_failure,_cq_]}
                throw [0,Assert_failure,_ct_]}
              throw [0,Assert_failure,_cr_]}}
          return tables}}
      return build_path(keys.length - 1 - 1 | 0,keys,root)}
    function new_cache(table)
     {var n=new_method(table);
      if(0 === (n % 2 | 0))
       var switch$0=0;
      else
       if((2 + ((caml_check_bound(table[2],1)[2] * 16 | 0) / 32 | 0) | 0) < n)
        var switch$0=0;
       else
        var n$0=new_method(table),switch$0=1;
      if(! switch$0)var n$0=n;
      caml_check_bound(table[2],n$0)[1 + n$0] = 0;
      return n$0}
    function set_methods(table,methods)
     {var len=methods.length - 1,i=[0,0];
      for(;;)
       {if(i[1] < len)
         {var
           _e4_=i[1],
           label=caml_check_bound(methods,_e4_)[1 + _e4_],
           next=
            function(param)
             {i[1]++;
              var _e9_=i[1];
              return caml_check_bound(methods,_e9_)[1 + _e9_]},
           clo=next(0);
          if(typeof clo === "number")
           switch(clo)
            {case 0:
              var
               x=next(0),
               clo$0=function(x){return function(obj){return x}}(x);
              break;
             case 1:
              var
               n=next(0),
               clo$0=function(n){return function(obj){return obj[1 + n]}}(n);
              break;
             case 2:
              var
               e=next(0),
               n$0=next(0),
               clo$0=
                function(e,n){return function(obj){return obj[1 + e][1 + n]}}
                 (e,n$0);
              break;
             case 3:
              var
               n$1=next(0),
               clo$0=
                function(n)
                  {return function(obj){return caml_call1(obj[1][1 + n],obj)}}
                 (n$1);
              break;
             case 4:
              var
               n$2=next(0),
               clo$0=
                function(n){return function(obj,x){obj[1 + n] = x;return 0}}
                 (n$2);
              break;
             case 5:
              var
               f=next(0),
               x$0=next(0),
               clo$0=
                function(f,x){return function(obj){return caml_call1(f,x)}}
                 (f,x$0);
              break;
             case 6:
              var
               f$0=next(0),
               n$3=next(0),
               clo$0=
                function(f,n)
                  {return function(obj){return caml_call1(f,obj[1 + n])}}
                 (f$0,n$3);
              break;
             case 7:
              var
               f$1=next(0),
               e$0=next(0),
               n$4=next(0),
               clo$0=
                function(f,e,n)
                  {return function(obj)
                    {return caml_call1(f,obj[1 + e][1 + n])}}
                 (f$1,e$0,n$4);
              break;
             case 8:
              var
               f$2=next(0),
               n$5=next(0),
               clo$0=
                function(f,n)
                  {return function(obj)
                    {return caml_call1(f,caml_call1(obj[1][1 + n],obj))}}
                 (f$2,n$5);
              break;
             case 9:
              var
               f$3=next(0),
               x$1=next(0),
               y=next(0),
               clo$0=
                function(f,x,y)
                  {return function(obj){return caml_call2(f,x,y)}}
                 (f$3,x$1,y);
              break;
             case 10:
              var
               f$4=next(0),
               x$2=next(0),
               n$6=next(0),
               clo$0=
                function(f,x,n)
                  {return function(obj){return caml_call2(f,x,obj[1 + n])}}
                 (f$4,x$2,n$6);
              break;
             case 11:
              var
               f$5=next(0),
               x$3=next(0),
               e$1=next(0),
               n$7=next(0),
               clo$0=
                function(f,x,e,n)
                  {return function(obj)
                    {return caml_call2(f,x,obj[1 + e][1 + n])}}
                 (f$5,x$3,e$1,n$7);
              break;
             case 12:
              var
               f$6=next(0),
               x$4=next(0),
               n$8=next(0),
               clo$0=
                function(f,x,n)
                  {return function(obj)
                    {return caml_call2(f,x,caml_call1(obj[1][1 + n],obj))}}
                 (f$6,x$4,n$8);
              break;
             case 13:
              var
               f$7=next(0),
               n$9=next(0),
               x$5=next(0),
               clo$0=
                function(f,n,x)
                  {return function(obj){return caml_call2(f,obj[1 + n],x)}}
                 (f$7,n$9,x$5);
              break;
             case 14:
              var
               f$8=next(0),
               e$2=next(0),
               n$10=next(0),
               x$6=next(0),
               clo$0=
                function(f,e,n,x)
                  {return function(obj)
                    {return caml_call2(f,obj[1 + e][1 + n],x)}}
                 (f$8,e$2,n$10,x$6);
              break;
             case 15:
              var
               f$9=next(0),
               n$11=next(0),
               x$7=next(0),
               clo$0=
                function(f,n,x)
                  {return function(obj)
                    {return caml_call2(f,caml_call1(obj[1][1 + n],obj),x)}}
                 (f$9,n$11,x$7);
              break;
             case 16:
              var
               n$12=next(0),
               x$8=next(0),
               clo$0=
                function(n,x)
                  {return function(obj)
                    {return caml_call2(obj[1][1 + n],obj,x)}}
                 (n$12,x$8);
              break;
             case 17:
              var
               n$13=next(0),
               m=next(0),
               clo$0=
                function(n,m)
                  {return function(obj)
                    {return caml_call2(obj[1][1 + n],obj,obj[1 + m])}}
                 (n$13,m);
              break;
             case 18:
              var
               n$14=next(0),
               e$3=next(0),
               m$0=next(0),
               clo$0=
                function(n,e,m)
                  {return function(obj)
                    {return caml_call2(obj[1][1 + n],obj,obj[1 + e][1 + m])}}
                 (n$14,e$3,m$0);
              break;
             case 19:
              var
               n$15=next(0),
               m$1=next(0),
               clo$0=
                function(n,m)
                  {return function(obj)
                    {var _e7_=caml_call1(obj[1][1 + m],obj);
                     return caml_call2(obj[1][1 + n],obj,_e7_)}}
                 (n$15,m$1);
              break;
             case 20:
              var m$2=next(0),x$9=next(0);
              new_cache(table);
              var
               clo$0=
                function(m,x)
                  {return function(obj)
                    {return caml_call1(caml_get_public_method(x,m,0),x)}}
                 (m$2,x$9);
              break;
             case 21:
              var m$3=next(0),n$16=next(0);
              new_cache(table);
              var
               clo$0=
                function(m,n)
                  {return function(obj)
                    {var _e6_=obj[1 + n];
                     return caml_call1(caml_get_public_method(_e6_,m,0),_e6_)}}
                 (m$3,n$16);
              break;
             case 22:
              var m$4=next(0),e$4=next(0),n$17=next(0);
              new_cache(table);
              var
               clo$0=
                function(m,e,n)
                  {return function(obj)
                    {var _e5_=obj[1 + e][1 + n];
                     return caml_call1(caml_get_public_method(_e5_,m,0),_e5_)}}
                 (m$4,e$4,n$17);
              break;
             default:
              var m$5=next(0),n$18=next(0);
              new_cache(table);
              var
               clo$0=
                function(m,n)
                  {return function(obj)
                    {var _e8_=caml_call1(obj[1][1 + n],obj);
                     return caml_call1(caml_get_public_method(_e8_,m,0),_e8_)}}
                 (m$5,n$18)}
          else
           var clo$0=clo;
          set_method(table,label,clo$0);
          i[1]++;
          continue}
        return 0}}
    function stats$0(param)
     {return [0,table_count[1],method_count[1],inst_var_count[1]]}
    var
     CamlinternalOO=
      [0,
       public_method_label,
       new_method,
       new_variable,
       new_methods_variables,
       get_variable,
       get_variables,
       get_method_label,
       get_method_labels,
       get_method,
       set_method,
       set_methods,
       narrow,
       widen,
       add_initializer,
       dummy_table,
       create_table,
       init_class,
       inherits,
       make_class,
       make_class_store,
       dummy_class,
       copy$6,
       create_object,
       create_object_opt,
       run_initializers,
       run_initializers_opt,
       create_object_and_run_initializers,
       lookup_tables,
       params$0,
       stats$0];
    caml_register_global(684,CamlinternalOO,"CamlinternalOO");
    var Oo=[0,copy$6,public_method_label,public_method_label];
    caml_register_global(685,Oo,"Oo");
    var
     update_mod=runtime.caml_CamlinternalMod_update_mod,
     init_mod=runtime.caml_CamlinternalMod_init_mod,
     CamlinternalMod=[0,init_mod,update_mod];
    caml_register_global(686,CamlinternalMod,"CamlinternalMod");
    var
     initial_buffer=caml_create_bytes(32),
     buffer=[0,initial_buffer],
     bufpos=[0,0];
    function reset_buffer(param)
     {buffer[1] = initial_buffer;bufpos[1] = 0;return 0}
    function store(c)
     {if(caml_ml_bytes_length(buffer[1]) <= bufpos[1])
       {var newbuffer=caml_create_bytes(2 * bufpos[1] | 0);
        blit(buffer[1],0,newbuffer,0,bufpos[1]);
        buffer[1] = newbuffer}
      caml_bytes_set(buffer[1],bufpos[1],c);
      bufpos[1]++;
      return 0}
    function get_string(param)
     {var s=sub_string(buffer[1],0,bufpos[1]);
      buffer[1] = initial_buffer;
      return s}
    function make_lexer(keywords)
     {var kwd_table=caml_call2(Hashtbl[1],0,17);
      iter
       (function(s){return caml_call3(Hashtbl[5],kwd_table,s,[0,s])},keywords);
      function ident_or_keyword(id)
       {try
         {var _e2_=caml_call2(Hashtbl[6],kwd_table,id);return _e2_}
        catch(_e3_)
         {_e3_ = caml_wrap_exception(_e3_);
          if(_e3_ === Not_found)return [1,id];
          throw _e3_}}
      function keyword_or_error(c)
       {var s=make$0(1,c);
        try
         {var _e0_=caml_call2(Hashtbl[6],kwd_table,s);return _e0_}
        catch(_e1_)
         {_e1_ = caml_wrap_exception(_e1_);
          if(_e1_ === Not_found)
           throw [0,Error,symbol(cst_Illegal_character,s)];
          throw _e1_}}
      function end_exponent_part(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _eZ_=match[1],switcher=_eZ_ - 48 | 0;
            if(! (9 < switcher >>> 0)){junk(strm);store(_eZ_);continue}}
          return [0,[3,caml_float_of_string(get_string(0))]]}}
      function exponent_part(strm)
       {var match=peek$0(strm);
        if(match)
         {var _eY_=match[1],switch$0=43 === _eY_?0:45 === _eY_?0:1;
          if(! switch$0)
           {junk(strm);store(_eY_);return end_exponent_part(strm)}}
        return end_exponent_part(strm)}
      function number(s)
       {for(;;)
         {var match=peek$0(s);
          if(match)
           {var _eV_=match[1];
            if(58 <= _eV_)
             {var switch$0=69 === _eV_?0:101 === _eV_?0:1;
              if(! switch$0){junk(s);store(69);return exponent_part(s)}}
            else
             {if(46 === _eV_)
               {junk(s);
                store(46);
                for(;;)
                 {var match$0=peek$0(s);
                  if(match$0)
                   {var _eW_=match$0[1],_eX_=_eW_ - 69 | 0;
                    if(32 < _eX_ >>> 0)
                     {var switcher=_eX_ + 21 | 0;
                      if(! (9 < switcher >>> 0)){junk(s);store(_eW_);continue}}
                    else
                     {var switcher$0=_eX_ - 1 | 0;
                      if(30 < switcher$0 >>> 0)
                       {junk(s);store(69);return exponent_part(s)}}}
                  return [0,[3,caml_float_of_string(get_string(0))]]}}
              if(48 <= _eV_){junk(s);store(_eV_);continue}}}
          return [0,[2,caml_int_of_string(get_string(0))]]}}
      function ident2(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _eT_=match[1];
            if(94 <= _eT_)
             var
              _eU_=_eT_ - 95 | 0,
              switch$0=30 < _eU_ >>> 0?32 <= _eU_?1:0:29 === _eU_?0:1;
            else
             if(65 <= _eT_)
              var switch$0=92 === _eT_?0:1;
             else
              if(33 <= _eT_)
               switch(_eT_ - 33 | 0)
                {case 0:
                 case 2:
                 case 3:
                 case 4:
                 case 5:
                 case 9:
                 case 10:
                 case 12:
                 case 14:
                 case 25:
                 case 27:
                 case 28:
                 case 29:
                 case 30:
                 case 31:var switch$0=0;break;
                 default:var switch$0=1}
              else
               var switch$0=1;
            if(! switch$0){junk(strm);store(_eT_);continue}}
          return [0,ident_or_keyword(get_string(0))]}}
      function neg_number(s)
       {var match=peek$0(s);
        if(match)
         {var _eS_=match[1],switcher=_eS_ - 48 | 0;
          if(! (9 < switcher >>> 0))
           {junk(s);reset_buffer(0);store(45);store(_eS_);return number(s)}}
        reset_buffer(0);
        store(45);
        return ident2(s)}
      function ident(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _eQ_=match[1];
            if(91 <= _eQ_)
             var
              _eR_=_eQ_ - 95 | 0,
              switch$0=27 < _eR_ >>> 0?97 <= _eR_?0:1:1 === _eR_?1:0;
            else
             var
              switch$0=
               48 <= _eQ_?6 < (_eQ_ - 58 | 0) >>> 0?0:1:39 === _eQ_?0:1;
            if(! switch$0){junk(strm);store(_eQ_);continue}}
          return [0,ident_or_keyword(get_string(0))]}}
      function next_token$0(counter,strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _eG_=match[1];
            if(124 <= _eG_)
             var switch$0=127 <= _eG_?192 <= _eG_?1:0:125 === _eG_?0:2;
            else
             {var _eH_=_eG_ - 65 | 0;
              if(57 < _eH_ >>> 0)
               if(58 <= _eH_)
                var switch$0=0;
               else
                {var switcher=_eH_ + 65 | 0;
                 switch(switcher)
                  {case 34:
                    junk(strm);
                    reset_buffer(0);
                    for(;;)
                     {var match$1=peek$0(strm);
                      if(match$1)
                       {var _eJ_=match$1[1];
                        if(34 === _eJ_){junk(strm);return [0,[4,get_string(0)]]}
                        if(92 === _eJ_)
                         {junk(strm);
                          try
                           {var c$0=escape(strm)}
                          catch(_eP_)
                           {_eP_ = caml_wrap_exception(_eP_);
                            if(_eP_ === Failure$0)throw [0,Error,cst$80];
                            throw _eP_;
                            var _eM_=_eP_}
                          store(c$0);
                          continue}
                        junk(strm);
                        store(_eJ_);
                        continue}
                      throw Failure$0}
                   case 39:
                    junk(strm);
                    try
                     {var match$2=peek$0(strm);
                      if(! match$2)throw Failure$0;
                      var _eK_=match$2[1];
                      if(92 === _eK_)
                       {junk(strm);
                        try
                         {var _eL_=escape(strm)}
                        catch(_eO_)
                         {_eO_ = caml_wrap_exception(_eO_);
                          if(_eO_ === Failure$0)throw [0,Error,cst$81];
                          throw _eO_}
                        var c=_eL_}
                      else
                       {junk(strm);var c=_eK_}}
                    catch(_eN_)
                     {_eN_ = caml_wrap_exception(_eN_);
                      if(_eN_ === Failure$0)throw [0,Error,cst$78];
                      throw _eN_}
                    var match$0=peek$0(strm);
                    if(match$0)
                     if(39 === match$0[1]){junk(strm);return [0,[5,c]]}
                    throw [0,Error,cst$79];
                   case 40:
                    junk(strm);
                    if(counter < 50)
                     {var counter$0=counter + 1 | 0;
                      return maybe_comment(counter$0,strm)}
                    return caml_trampoline_return(maybe_comment,[0,strm]);
                   case 45:junk(strm);return neg_number(strm);
                   case 9:
                   case 10:
                   case 12:
                   case 13:
                   case 26:
                   case 32:junk(strm);continue;
                   case 48:
                   case 49:
                   case 50:
                   case 51:
                   case 52:
                   case 53:
                   case 54:
                   case 55:
                   case 56:
                   case 57:
                    junk(strm);reset_buffer(0);store(_eG_);return number(strm);
                   case 33:
                   case 35:
                   case 36:
                   case 37:
                   case 38:
                   case 42:
                   case 43:
                   case 47:
                   case 58:
                   case 60:
                   case 61:
                   case 62:
                   case 63:
                   case 64:var switch$0=2;break;
                   default:var switch$0=0}}
              else
               {var _eI_=_eH_ - 26 | 0;
                if(5 < _eI_ >>> 0)
                 var switch$0=1;
                else
                 switch(_eI_)
                  {case 4:var switch$0=1;break;
                   case 1:
                   case 3:var switch$0=2;break;
                   default:var switch$0=0}}}
            switch(switch$0)
             {case 0:junk(strm);return [0,keyword_or_error(_eG_)];
              case 1:
               junk(strm);reset_buffer(0);store(_eG_);return ident(strm);
              default:
               junk(strm);reset_buffer(0);store(_eG_);return ident2(strm)}}
          return 0}}
      function maybe_comment(counter,strm)
       {var match=peek$0(strm);
        if(match)
         if(42 === match[1])
          {junk(strm);
           comment(strm);
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return next_token$0(counter$0,strm)}
           return caml_trampoline_return(next_token$0,[0,strm])}
        return [0,keyword_or_error(40)]}
      function next_token(strm){return caml_trampoline(next_token$0(0,strm))}
      function escape(strm)
       {var match=peek$0(strm);
        if(match)
         {var _eD_=match[1];
          if(58 <= _eD_)
           {var switcher=_eD_ - 110 | 0;
            if(! (6 < switcher >>> 0))
             switch(switcher)
              {case 0:junk(strm);return 10;
               case 4:junk(strm);return 13;
               case 6:junk(strm);return 9
               }}
          else
           if(48 <= _eD_)
            {junk(strm);
             var match$0=peek$0(strm);
             if(match$0)
              {var _eE_=match$0[1],switcher$0=_eE_ - 48 | 0;
               if(! (9 < switcher$0 >>> 0))
                {junk(strm);
                 var match$1=peek$0(strm);
                 if(match$1)
                  {var _eF_=match$1[1],switcher$1=_eF_ - 48 | 0;
                   if(! (9 < switcher$1 >>> 0))
                    {junk(strm);
                     return chr
                             ((((_eD_ - 48 | 0) * 100 | 0)
                               +
                               ((_eE_ - 48 | 0) * 10 | 0)
                               |
                               0)
                              +
                              (_eF_ - 48 | 0)
                              |
                              0)}}
                 throw [0,Error,cst$83]}}
             throw [0,Error,cst$82]}
          junk(strm);
          return _eD_}
        throw Failure$0}
      function comment(strm)
       {a:
        for(;;)
         {var match=peek$0(strm);
          if(match)
           {var switcher=match[1] - 40 | 0;
            if(! (2 < switcher >>> 0))
             switch(switcher)
              {case 0:
                junk(strm);
                var match$0=peek$0(strm);
                if(match$0)
                 {if(42 === match$0[1]){junk(strm);comment(strm);continue}
                  junk(strm);
                  continue}
                throw Failure$0;
               case 1:break;
               default:
                junk(strm);
                for(;;)
                 {var match$1=peek$0(strm);
                  if(match$1)
                   {var _eC_=match$1[1];
                    if(41 === _eC_){junk(strm);return 0}
                    if(42 === _eC_){junk(strm);continue}
                    junk(strm);
                    continue a}
                  throw Failure$0}}
            junk(strm);
            continue}
          throw Failure$0}}
      return function(input)
       {return from(function(count){return next_token(input)})}}
    var Genlex=[0,make_lexer];
    caml_register_global(687,Genlex,"Genlex");
    function MakeSeeded$0(H)
     {var prng=[246,function(_eB_){return caml_call1(_b2_[2],0)}];
      function create(opt,initial_size)
       {if(opt)
         var sth=opt[1],random=sth;
        else
         var random=caml_call1(Hashtbl[17],0);
        var x=16;
        for(;;)
         {if(! (initial_size <= x))
           if(! (max_array_length < (x * 2 | 0)))
            {var x$0=x * 2 | 0,x=x$0;continue}
          if(random)
           var
            _ez_=caml_obj_tag(prng),
            _eA_=250 === _ez_?prng[1]:246 === _ez_?force_lazy_block(prng):prng,
            seed=caml_call1(_b2_[4],_eA_);
          else
           var seed=0;
          return [0,0,caml_make_vect(x,0),seed,x]}}
      function clear(h)
       {h[1] = 0;
        var len=h[2].length - 1,_ex_=len - 1 | 0,_ew_=0;
        if(! (_ex_ < 0))
         {var i=_ew_;
          for(;;)
           {caml_check_bound(h[2],i)[1 + i] = 0;
            var _ey_=i + 1 | 0;
            if(_ex_ !== i){var i=_ey_;continue}
            break}}
        return 0}
      function reset(h)
       {var len=h[2].length - 1;
        return len === h[4]
                ?clear(h)
                :(h[1] = 0,h[2] = caml_make_vect(h[4],0),0)}
      function copy(init)
       {var _et_=init[4],_eu_=init[3],_ev_=copy$1(init[2]);
        return [0,init[1],_ev_,_eu_,_et_]}
      function key_index(h,hkey){return hkey & (h[2].length - 1 - 1 | 0)}
      function clean(h)
       {function do_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var rest=param$0[3],c=param$0[2],hkey=param$0[1];
              if(caml_call1(H[7],c))return [0,hkey,c,do_bucket(rest)];
              h[1] = h[1] - 1 | 0;
              var param$0=rest;
              continue}
            return 0}}
        var d=h[2],_eq_=d.length - 1 - 1 | 0,_ep_=0;
        if(! (_eq_ < 0))
         {var i=_ep_;
          for(;;)
           {var _er_=do_bucket(caml_check_bound(d,i)[1 + i]);
            caml_check_bound(d,i)[1 + i] = _er_;
            var _es_=i + 1 | 0;
            if(_eq_ !== i){var i=_es_;continue}
            break}}
        return 0}
      function resize(h)
       {var odata=h[2],osize=odata.length - 1,nsize=osize * 2 | 0;
        clean(h);
        var
         _ej_=nsize < max_array_length?1:0,
         _ek_=_ej_?(osize >>> 1 | 0) <= h[1]?1:0:_ej_;
        if(_ek_)
         {var ndata=caml_make_vect(nsize,0);
          h[2] = ndata;
          var
           insert_bucket=
            function(param)
             {if(param)
               {var rest=param[3],data=param[2],hkey=param[1];
                insert_bucket(rest);
                var nidx=key_index(h,hkey);
                ndata[1 + nidx]
                =
                [0,hkey,data,caml_check_bound(ndata,nidx)[1 + nidx]];
                return 0}
              return 0},
           _em_=osize - 1 | 0,
           _el_=0;
          if(! (_em_ < 0))
           {var i=_el_;
            for(;;)
             {insert_bucket(caml_check_bound(odata,i)[1 + i]);
              var _eo_=i + 1 | 0;
              if(_em_ !== i){var i=_eo_;continue}
              break}}
          var _en_=0}
        else
         var _en_=_ek_;
        return _en_}
      function add(h,key,info)
       {var
         hkey=caml_call2(H[2],h[3],key),
         i=key_index(h,hkey),
         container=caml_call2(H[1],key,info),
         bucket=[0,hkey,container,caml_check_bound(h[2],i)[1 + i]];
        caml_check_bound(h[2],i)[1 + i] = bucket;
        h[1] = h[1] + 1 | 0;
        var _ei_=h[2].length - 1 << 1 < h[1]?1:0;
        return _ei_?resize(h):_ei_}
      function remove(h,key)
       {var hkey=caml_call2(H[2],h[3],key);
        function remove_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var next=param$0[3],c=param$0[2],hk=param$0[1];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                switch(match)
                 {case 0:h[1] = h[1] - 1 | 0;return next;
                  case 1:return [0,hk,c,remove_bucket(next)];
                  default:h[1] = h[1] - 1 | 0;var param$0=next;continue}}
              return [0,hk,c,remove_bucket(next)]}
            return 0}}
        var
         i=key_index(h,hkey),
         _eh_=remove_bucket(caml_check_bound(h[2],i)[1 + i]);
        caml_check_bound(h[2],i)[1 + i] = _eh_;
        return 0}
      function find(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _eg_=key_index(h,hkey),
         param$0=caml_check_bound(h[2],_eg_)[1 + _eg_],
         param=param$0;
        for(;;)
         {if(param)
           {var rest=param[3],c=param[2],hk=param[1];
            if(hkey === hk)
             {var match=caml_call2(H[3],c,key);
              switch(match)
               {case 0:
                 var match$0=caml_call1(H[4],c);
                 if(match$0){var d=match$0[1];return d}
                 var param=rest;
                 continue;
                case 1:var param=rest;continue;
                default:var param=rest;continue}}
            var param=rest;
            continue}
          throw Not_found}}
      function find_opt(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _ef_=key_index(h,hkey),
         param$0=caml_check_bound(h[2],_ef_)[1 + _ef_],
         param=param$0;
        for(;;)
         {if(param)
           {var rest=param[3],c=param[2],hk=param[1];
            if(hkey === hk)
             {var match=caml_call2(H[3],c,key);
              switch(match)
               {case 0:
                 var d=caml_call1(H[4],c);
                 if(d)return d;
                 var param=rest;
                 continue;
                case 1:var param=rest;continue;
                default:var param=rest;continue}}
            var param=rest;
            continue}
          return 0}}
      function find_all(h,key)
       {var hkey=caml_call2(H[2],h[3],key);
        function find_in_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var rest=param$0[3],c=param$0[2],hk=param$0[1];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                switch(match)
                 {case 0:
                   var match$0=caml_call1(H[4],c);
                   if(match$0)
                    {var d=match$0[1];return [0,d,find_in_bucket(rest)]}
                   var param$0=rest;
                   continue;
                  case 1:var param$0=rest;continue;
                  default:var param$0=rest;continue}}
              var param$0=rest;
              continue}
            return 0}}
        var _ee_=key_index(h,hkey);
        return find_in_bucket(caml_check_bound(h[2],_ee_)[1 + _ee_])}
      function replace(h,key,info)
       {var hkey=caml_call2(H[2],h[3],key);
        function replace_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var next=param$0[3],c=param$0[2],hk=param$0[1];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                if(0 === match)return caml_call3(H[6],c,key,info);
                var param$0=next;
                continue}
              var param$0=next;
              continue}
            throw Not_found}}
        var i=key_index(h,hkey),l=caml_check_bound(h[2],i)[1 + i];
        try
         {var _ec_=replace_bucket(l);return _ec_}
        catch(_ed_)
         {_ed_ = caml_wrap_exception(_ed_);
          if(_ed_ === Not_found)
           {var container=caml_call2(H[1],key,info);
            caml_check_bound(h[2],i)[1 + i] = [0,hkey,container,l];
            h[1] = h[1] + 1 | 0;
            var _eb_=h[2].length - 1 << 1 < h[1]?1:0;
            return _eb_?resize(h):_eb_}
          throw _ed_}}
      function mem(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _ea_=key_index(h,hkey),
         param$0=caml_check_bound(h[2],_ea_)[1 + _ea_],
         param=param$0;
        for(;;)
         {if(param)
           {var rest=param[3],c=param[2],hk=param[1];
            if(hk === hkey)
             {var match=caml_call2(H[3],c,key);
              if(0 === match)return 1;
              var param=rest;
              continue}
            var param=rest;
            continue}
          return 0}}
      function iter(f,h)
       {var d$0=h[2],_d__=d$0.length - 1 - 1 | 0,_d9_=0;
        if(! (_d__ < 0))
         {var i=_d9_;
          a:
          for(;;)
           {var param$0=caml_check_bound(d$0,i)[1 + i],param=param$0;
            for(;;)
             {if(param)
               {var
                 rest=param[3],
                 c=param[2],
                 match=caml_call1(H[5],c),
                 match$0=caml_call1(H[4],c);
                if(match)
                 if(match$0)
                  {var d=match$0[1],k=match[1];
                   caml_call2(f,k,d);
                   var switch$0=1}
                 else
                  var switch$0=0;
                else
                 var switch$0=0;
                var param=rest;
                continue}
              var _d$_=i + 1 | 0;
              if(_d__ !== i){var i=_d$_;continue a}
              break}
            break}}
        return 0}
      function fold(f,h,init)
       {var d$0=h[2],accu$1=[0,init],_d6_=d$0.length - 1 - 1 | 0,_d5_=0;
        if(! (_d6_ < 0))
         {var i=_d5_;
          a:
          for(;;)
           {var
             _d7_=accu$1[1],
             b$0=caml_check_bound(d$0,i)[1 + i],
             b=b$0,
             accu=_d7_;
            for(;;)
             {if(b)
               {var
                 rest=b[3],
                 c=b[2],
                 match=caml_call1(H[5],c),
                 match$0=caml_call1(H[4],c);
                if(match)
                 if(match$0)
                  var
                   d=match$0[1],
                   k=match[1],
                   accu$0=caml_call3(f,k,d,accu),
                   switch$0=1;
                 else
                  var switch$0=0;
                else
                 var switch$0=0;
                if(! switch$0)var accu$0=accu;
                var b=rest,accu=accu$0;
                continue}
              accu$1[1] = accu;
              var _d8_=i + 1 | 0;
              if(_d6_ !== i){var i=_d8_;continue a}
              break}
            break}}
        return accu$1[1]}
      function filter_map_inplace(f,h)
       {function do_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var
               rest=param$0[3],
               c=param$0[2],
               hk=param$0[1],
               match=caml_call1(H[5],c),
               match$0=caml_call1(H[4],c);
              if(match)
               if(match$0)
                {var d=match$0[1],k=match[1],match$1=caml_call2(f,k,d);
                 if(match$1)
                  {var new_d=match$1[1];
                   caml_call3(H[6],c,k,new_d);
                   return [0,hk,c,do_bucket(rest)]}
                 var param$0=rest;
                 continue}
              var param$0=rest;
              continue}
            return 0}}
        var d=h[2],_d2_=d.length - 1 - 1 | 0,_d1_=0;
        if(! (_d2_ < 0))
         {var i=_d1_;
          for(;;)
           {var _d3_=do_bucket(caml_check_bound(d,i)[1 + i]);
            caml_check_bound(d,i)[1 + i] = _d3_;
            var _d4_=i + 1 | 0;
            if(_d2_ !== i){var i=_d4_;continue}
            break}}
        return 0}
      function length(h){return h[1]}
      function bucket_length(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {if(param$0)
           {var
             param$1=param$0[3],
             accu$1=accu$0 + 1 | 0,
             accu$0=accu$1,
             param$0=param$1;
            continue}
          return accu$0}}
      function stats(h)
       {var
         _dY_=h[2],
         _dZ_=0,
         mbl=
          fold_left$0
           (function(m,b){return max(m,bucket_length(0,b))},_dZ_,_dY_),
         histo=caml_make_vect(mbl + 1 | 0,0),
         _d0_=h[2];
        iter$2
         (function(b)
           {var l=bucket_length(0,b);
            histo[1 + l] = caml_check_bound(histo,l)[1 + l] + 1 | 0;
            return 0},
          _d0_);
        return [0,h[1],h[2].length - 1,mbl,histo]}
      function bucket_length_alive(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {if(param$0)
           {var rest=param$0[3],c=param$0[2];
            if(caml_call1(H[7],c))
             {var accu$1=accu$0 + 1 | 0,accu$0=accu$1,param$0=rest;continue}
            var param$0=rest;
            continue}
          return accu$0}}
      function stats_alive(h)
       {var
         size=[0,0],
         _dV_=h[2],
         _dW_=0,
         mbl=
          fold_left$0
           (function(m,b){return max(m,bucket_length_alive(0,b))},_dW_,_dV_),
         histo=caml_make_vect(mbl + 1 | 0,0),
         _dX_=h[2];
        iter$2
         (function(b)
           {var l=bucket_length_alive(0,b);
            size[1] = size[1] + l | 0;
            histo[1 + l] = caml_check_bound(histo,l)[1 + l] + 1 | 0;
            return 0},
          _dX_);
        return [0,size[1],h[2].length - 1,mbl,histo]}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              clean,
              stats_alive]}
    function create$4(param){return caml_call1(_E_[1],1)}
    function get_key(t){return caml_call2(_E_[3],t,0)}
    function get_key_copy(t){return caml_call2(_E_[4],t,0)}
    function set_key(t,k){return caml_call3(_E_[5],t,0,k)}
    function unset_key(t){return caml_call2(_E_[6],t,0)}
    function check_key(t){return caml_call2(_E_[7],t,0)}
    function blit_key(t1,t2){return caml_call5(_E_[8],t1,0,t2,0,1)}
    function get_data$1(t){return caml_call1(_E_[9],t)}
    function get_data_copy(t){return caml_call1(_E_[10],t)}
    function set_data(t,d){return caml_call2(_E_[11],t,d)}
    function unset_data(t){return caml_call1(_E_[12],t)}
    function check_data(t){return caml_call1(_E_[13],t)}
    function blit_data(t1,t2){return caml_call2(_E_[14],t1,t2)}
    function MakeSeeded$1(H)
     {function create(k,d)
       {var c=create$4(0);set_data(c,d);set_key(c,k);return c}
      var hash=H[2];
      function equal(c,k)
       {var match=get_key(c);
        if(match){var k$0=match[1];return caml_call2(H[1],k,k$0)?0:1}
        return 2}
      function set_key_data(c,k,d)
       {unset_data(c);set_key(c,k);return set_data(c,d)}
      return MakeSeeded$0
              ([0,create,hash,equal,get_data$1,get_key,set_key_data,check_key])}
    function Make$1(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded$1([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       clean=include[17],
       stats_alive=include[18],
       _dU_=include[1];
      function create(sz){return caml_call2(_dU_,_cv_,sz)}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              clean,
              stats_alive]}
    function create$5(param){return caml_call1(_E_[1],2)}
    function get_key1(t){return caml_call2(_E_[3],t,0)}
    function get_key1_copy(t){return caml_call2(_E_[4],t,0)}
    function set_key1(t,k){return caml_call3(_E_[5],t,0,k)}
    function unset_key1(t){return caml_call2(_E_[6],t,0)}
    function check_key1(t){return caml_call2(_E_[7],t,0)}
    function get_key2(t){return caml_call2(_E_[3],t,1)}
    function get_key2_copy(t){return caml_call2(_E_[4],t,1)}
    function set_key2(t,k){return caml_call3(_E_[5],t,1,k)}
    function unset_key2(t){return caml_call2(_E_[6],t,1)}
    function check_key2(t){return caml_call2(_E_[7],t,1)}
    function blit_key1(t1,t2){return caml_call5(_E_[8],t1,0,t2,0,1)}
    function blit_key2(t1,t2){return caml_call5(_E_[8],t1,1,t2,1,1)}
    function blit_key12(t1,t2){return caml_call5(_E_[8],t1,0,t2,0,2)}
    function get_data$2(t){return caml_call1(_E_[9],t)}
    function get_data_copy$0(t){return caml_call1(_E_[10],t)}
    function set_data$0(t,d){return caml_call2(_E_[11],t,d)}
    function unset_data$0(t){return caml_call1(_E_[12],t)}
    function check_data$0(t){return caml_call1(_E_[13],t)}
    function blit_data$0(t1,t2){return caml_call2(_E_[14],t1,t2)}
    function MakeSeeded$2(H1,H2)
     {function create(param,d)
       {var k2=param[2],k1=param[1],c=create$5(0);
        set_data$0(c,d);
        set_key1(c,k1);
        set_key2(c,k2);
        return c}
      function hash(seed,param)
       {var
         k2=param[2],
         k1=param[1],
         _dT_=caml_call2(H2[2],seed,k2) * 65599 | 0;
        return caml_call2(H1[2],seed,k1) + _dT_ | 0}
      function equal(c,param)
       {var k2=param[2],k1=param[1],match=get_key1(c),match$0=get_key2(c);
        if(match)
         if(match$0)
          {var k2$0=match$0[1],k1$0=match[1];
           if(caml_call2(H1[1],k1,k1$0))if(caml_call2(H2[1],k2,k2$0))return 0;
           return 1}
        return 2}
      function get_key(c)
       {var match=get_key1(c),match$0=get_key2(c);
        if(match)
         if(match$0){var k2=match$0[1],k1=match[1];return [0,[0,k1,k2]]}
        return 0}
      function set_key_data(c,param,d)
       {var k2=param[2],k1=param[1];
        unset_data$0(c);
        set_key1(c,k1);
        set_key2(c,k2);
        return set_data$0(c,d)}
      function check_key(c)
       {var _dS_=check_key1(c);return _dS_?check_key2(c):_dS_}
      return MakeSeeded$0
              ([0,create,hash,equal,get_data$2,get_key,set_key_data,check_key])}
    function Make$2(H1,H2)
     {var equal=H2[1];
      function hash(seed,x){return caml_call1(H2[2],x)}
      var equal$0=H1[1],_dQ_=[0,equal,hash];
      function hash$0(seed,x){return caml_call1(H1[2],x)}
      var
       include=MakeSeeded$2([0,equal$0,hash$0],_dQ_),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       clean=include[17],
       stats_alive=include[18],
       _dR_=include[1];
      function create(sz){return caml_call2(_dR_,_cw_,sz)}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              clean,
              stats_alive]}
    function create$6(n){return caml_call1(_E_[1],n)}
    function length$6(k){return caml_call1(_E_[2],k)}
    function get_key$0(t,n){return caml_call2(_E_[3],t,n)}
    function get_key_copy$0(t,n){return caml_call2(_E_[4],t,n)}
    function set_key$0(t,n,k){return caml_call3(_E_[5],t,n,k)}
    function unset_key$0(t,n){return caml_call2(_E_[6],t,n)}
    function check_key$0(t,n){return caml_call2(_E_[7],t,n)}
    function blit_key$0(t1,o1,t2,o2,l)
     {return caml_call5(_E_[8],t1,o1,t2,o2,l)}
    function get_data$3(t){return caml_call1(_E_[9],t)}
    function get_data_copy$1(t){return caml_call1(_E_[10],t)}
    function set_data$1(t,d){return caml_call2(_E_[11],t,d)}
    function unset_data$1(t){return caml_call1(_E_[12],t)}
    function check_data$1(t){return caml_call1(_E_[13],t)}
    function blit_data$1(t1,t2){return caml_call2(_E_[14],t1,t2)}
    function MakeSeeded$3(H)
     {function create(k,d)
       {var c=create$6(k.length - 1);
        set_data$1(c,d);
        var _dO_=k.length - 1 - 1 | 0,_dN_=0;
        if(! (_dO_ < 0))
         {var i=_dN_;
          for(;;)
           {set_key$0(c,i,caml_check_bound(k,i)[1 + i]);
            var _dP_=i + 1 | 0;
            if(_dO_ !== i){var i=_dP_;continue}
            break}}
        return c}
      function hash(seed,k)
       {var h=[0,0],_dJ_=k.length - 1 - 1 | 0,_dI_=0;
        if(! (_dJ_ < 0))
         {var i=_dI_;
          for(;;)
           {var _dK_=h[1],_dL_=caml_check_bound(k,i)[1 + i];
            h[1] = (caml_call2(H[2],seed,_dL_) * 65599 | 0) + _dK_ | 0;
            var _dM_=i + 1 | 0;
            if(_dJ_ !== i){var i=_dM_;continue}
            break}}
        return h[1]}
      function equal(c,k)
       {var len=k.length - 1,len$0=length$6(c);
        if(len !== len$0)return 1;
        var i$1=len - 1 | 0,i=i$1;
        for(;;)
         {if(0 <= i)
           {var match=get_key$0(c,i);
            if(match)
             {var ki=match[1],_dH_=caml_check_bound(k,i)[1 + i];
              if(caml_call2(H[1],_dH_,ki)){var i$0=i - 1 | 0,i=i$0;continue}
              return 1}
            return 2}
          return 0}}
      function get_key(c)
       {var len=length$6(c);
        if(0 === len)return [0,[0]];
        var match=get_key$0(c,0);
        if(match)
         {var k0=match[1],a=caml_make_vect(len,k0),i$1=len - 1 | 0,i=i$1;
          for(;;)
           {if(1 <= i)
             {var match$0=get_key$0(c,i);
              if(match$0)
               {var ki=match$0[1];
                caml_check_bound(a,i)[1 + i] = ki;
                var i$0=i - 1 | 0,i=i$0;
                continue}
              return 0}
            return [0,a]}}
        return 0}
      function set_key_data(c,k,d)
       {unset_data$1(c);
        var _dF_=k.length - 1 - 1 | 0,_dE_=0;
        if(! (_dF_ < 0))
         {var i=_dE_;
          for(;;)
           {set_key$0(c,i,caml_check_bound(k,i)[1 + i]);
            var _dG_=i + 1 | 0;
            if(_dF_ !== i){var i=_dG_;continue}
            break}}
        return set_data$1(c,d)}
      function check_key(c)
       {var i$1=length$6(c) - 1 | 0,i=i$1;
        for(;;)
         {var _dB_=i < 0?1:0;
          if(_dB_)
           var _dC_=_dB_;
          else
           {var _dD_=check_key$0(c,i);
            if(_dD_){var i$0=i - 1 | 0,i=i$0;continue}
            var _dC_=_dD_}
          return _dC_}}
      return MakeSeeded$0
              ([0,create,hash,equal,get_data$3,get_key,set_key_data,check_key])}
    function Make$3(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded$3([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       clean=include[17],
       stats_alive=include[18],
       _dA_=include[1];
      function create(sz){return caml_call2(_dA_,_cx_,sz)}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              clean,
              stats_alive]}
    var
     Ephemeron=
      [0,
       [0,
        create$4,
        get_key,
        get_key_copy,
        set_key,
        unset_key,
        check_key,
        blit_key,
        get_data$1,
        get_data_copy,
        set_data,
        unset_data,
        check_data,
        blit_data,
        Make$1,
        MakeSeeded$1],
       [0,
        create$5,
        get_key1,
        get_key1_copy,
        set_key1,
        unset_key1,
        check_key1,
        get_key2,
        get_key2_copy,
        set_key2,
        unset_key2,
        check_key2,
        blit_key1,
        blit_key2,
        blit_key12,
        get_data$2,
        get_data_copy$0,
        set_data$0,
        unset_data$0,
        check_data$0,
        blit_data$0,
        Make$2,
        MakeSeeded$2],
       [0,
        create$6,
        get_key$0,
        get_key_copy$0,
        set_key$0,
        unset_key$0,
        check_key$0,
        blit_key$0,
        get_data$3,
        get_data_copy$1,
        set_data$1,
        unset_data$1,
        check_data$1,
        blit_data$1,
        Make$3,
        MakeSeeded$3],
       [0,
        function(_dz_)
         {return MakeSeeded$0
                  ([0,_dz_[3],_dz_[1],_dz_[2],_dz_[5],_dz_[4],_dz_[6],_dz_[7]])}]];
    caml_register_global(688,Ephemeron,"Ephemeron");
    function generic_basename(is_dir_sep,current_dir_name,name)
     {if(caml_string_equal(name,cst$84))return current_dir_name;
      var n$3=caml_ml_string_length(name) - 1 | 0,n=n$3;
      for(;;)
       {if(0 <= n)
         {if(caml_call2(is_dir_sep,name,n)){var n$0=n - 1 | 0,n=n$0;continue}
          var p=n + 1 | 0,n$1=n;
          for(;;)
           {if(0 <= n$1)
             {if(caml_call2(is_dir_sep,name,n$1))
               return sub$0(name,n$1 + 1 | 0,(p - n$1 | 0) - 1 | 0);
              var n$2=n$1 - 1 | 0,n$1=n$2;
              continue}
            return sub$0(name,0,p)}}
        return sub$0(name,0,1)}}
    function generic_dirname(is_dir_sep,current_dir_name,name)
     {if(caml_string_equal(name,cst$85))return current_dir_name;
      var n$5=caml_ml_string_length(name) - 1 | 0,n=n$5;
      for(;;)
       {if(0 <= n)
         {if(caml_call2(is_dir_sep,name,n)){var n$0=n - 1 | 0,n=n$0;continue}
          var n$1=n;
          for(;;)
           {if(0 <= n$1)
             {if(caml_call2(is_dir_sep,name,n$1))
               {var n$3=n$1;
                for(;;)
                 {if(0 <= n$3)
                   {if(caml_call2(is_dir_sep,name,n$3))
                     {var n$4=n$3 - 1 | 0,n$3=n$4;continue}
                    return sub$0(name,0,n$3 + 1 | 0)}
                  return sub$0(name,0,1)}}
              var n$2=n$1 - 1 | 0,n$1=n$2;
              continue}
            return current_dir_name}}
        return sub$0(name,0,1)}}
    function is_dir_sep(s,i){return 47 === caml_string_get(s,i)?1:0}
    function is_relative(n)
     {var
       _dx_=caml_ml_string_length(n) < 1?1:0,
       _dy_=_dx_ || (47 !== caml_string_get(n,0)?1:0);
      return _dy_}
    function is_implicit(n)
     {var _ds_=is_relative(n);
      if(_ds_)
       {var
         _dt_=caml_ml_string_length(n) < 2?1:0,
         _du_=_dt_ || caml_string_notequal(sub$0(n,0,2),cst$87);
        if(_du_)
         var
          _dv_=caml_ml_string_length(n) < 3?1:0,
          _dw_=_dv_ || caml_string_notequal(sub$0(n,0,3),cst$86);
        else
         var _dw_=_du_}
      else
       var _dw_=_ds_;
      return _dw_}
    function check_suffix(name,suff)
     {var
       _dq_=caml_ml_string_length(suff) <= caml_ml_string_length(name)?1:0,
       _dr_=
        _dq_
         ?caml_string_equal
           (sub$0
             (name,
              caml_ml_string_length(name) - caml_ml_string_length(suff) | 0,
              caml_ml_string_length(suff)),
            suff)
         :_dq_;
      return _dr_}
    try
     {var _cF_=caml_sys_getenv(cst_TMPDIR),_cy_=_cF_}
    catch(_dp_)
     {_dp_ = caml_wrap_exception(_dp_);
      if(_dp_ !== Not_found)throw _dp_;
      var _cy_=cst_tmp}
    function quote(s)
     {var l=caml_ml_string_length(s),b=create$1(l + 20 | 0);
      add_char(b,39);
      var _dn_=l - 1 | 0,_dm_=0;
      if(! (_dn_ < 0))
       {var i=_dm_;
        for(;;)
         {if(39 === caml_string_get(s,i))
           add_string(b,quotequote);
          else
           add_char(b,caml_string_get(s,i));
          var _do_=i + 1 | 0;
          if(_dn_ !== i){var i=_do_;continue}
          break}}
      add_char(b,39);
      return contents(b)}
    function basename(_dl_)
     {return generic_basename(is_dir_sep,current_dir_name,_dl_)}
    function dirname(_dk_)
     {return generic_dirname(is_dir_sep,current_dir_name,_dk_)}
    function is_dir_sep$0(s,i)
     {var c=caml_string_get(s,i),_dh_=47 === c?1:0;
      if(_dh_)
       var _di_=_dh_;
      else
       var _dj_=92 === c?1:0,_di_=_dj_ || (58 === c?1:0);
      return _di_}
    function is_relative$0(n)
     {var
       _db_=caml_ml_string_length(n) < 1?1:0,
       _dc_=_db_ || (47 !== caml_string_get(n,0)?1:0);
      if(_dc_)
       {var
         _dd_=caml_ml_string_length(n) < 1?1:0,
         _de_=_dd_ || (92 !== caml_string_get(n,0)?1:0);
        if(_de_)
         var
          _df_=caml_ml_string_length(n) < 2?1:0,
          _dg_=_df_ || (58 !== caml_string_get(n,1)?1:0);
        else
         var _dg_=_de_}
      else
       var _dg_=_dc_;
      return _dg_}
    function is_implicit$0(n)
     {var _c4_=is_relative$0(n);
      if(_c4_)
       {var
         _c5_=caml_ml_string_length(n) < 2?1:0,
         _c6_=_c5_ || caml_string_notequal(sub$0(n,0,2),cst$91);
        if(_c6_)
         {var
           _c7_=caml_ml_string_length(n) < 2?1:0,
           _c8_=_c7_ || caml_string_notequal(sub$0(n,0,2),cst$90);
          if(_c8_)
           {var
             _c9_=caml_ml_string_length(n) < 3?1:0,
             _c__=_c9_ || caml_string_notequal(sub$0(n,0,3),cst$89);
            if(_c__)
             var
              _c$_=caml_ml_string_length(n) < 3?1:0,
              _da_=_c$_ || caml_string_notequal(sub$0(n,0,3),cst$88);
            else
             var _da_=_c__}
          else
           var _da_=_c8_}
        else
         var _da_=_c6_}
      else
       var _da_=_c4_;
      return _da_}
    function check_suffix$0(name,suff)
     {var _c1_=caml_ml_string_length(suff) <= caml_ml_string_length(name)?1:0;
      if(_c1_)
       var
        s=
         sub$0
          (name,
           caml_ml_string_length(name) - caml_ml_string_length(suff) | 0,
           caml_ml_string_length(suff)),
        _c2_=lowercase_ascii$1(suff),
        _c3_=caml_string_equal(lowercase_ascii$1(s),_c2_);
      else
       var _c3_=_c1_;
      return _c3_}
    try
     {var _cE_=caml_sys_getenv(cst_TEMP),temp_dir_name=_cE_}
    catch(_c0_)
     {_c0_ = caml_wrap_exception(_c0_);
      if(_c0_ !== Not_found)throw _c0_;
      var temp_dir_name=cst$92}
    function quote$0(s)
     {var l=caml_ml_string_length(s),b=create$1(l + 20 | 0);
      add_char(b,34);
      function add_bs(n)
       {var _cY_=1;
        if(! (n < 1))
         {var j=_cY_;
          for(;;)
           {add_char(b,92);
            var _cZ_=j + 1 | 0;
            if(n !== j){var j=_cZ_;continue}
            break}}
        return 0}
      function loop$0(counter,i)
       {var i$0=i;
        for(;;)
         {if(i$0 === l)return add_char(b,34);
          var c=caml_string_get(s,i$0);
          if(34 === c)
           {var _cW_=0;
            if(counter < 50)
             {var counter$1=counter + 1 | 0;
              return loop_bs(counter$1,_cW_,i$0)}
            return caml_trampoline_return(loop_bs,[0,_cW_,i$0])}
          if(92 === c)
           {var _cX_=0;
            if(counter < 50)
             {var counter$0=counter + 1 | 0;
              return loop_bs(counter$0,_cX_,i$0)}
            return caml_trampoline_return(loop_bs,[0,_cX_,i$0])}
          add_char(b,c);
          var i$1=i$0 + 1 | 0,i$0=i$1;
          continue}}
      function loop_bs(counter,n,i)
       {var n$0=n,i$0=i;
        for(;;)
         {if(i$0 === l){add_char(b,34);return add_bs(n$0)}
          var match=caml_string_get(s,i$0);
          if(34 === match)
           {add_bs((2 * n$0 | 0) + 1 | 0);
            add_char(b,34);
            var _cV_=i$0 + 1 | 0;
            if(counter < 50)
             {var counter$1=counter + 1 | 0;return loop$0(counter$1,_cV_)}
            return caml_trampoline_return(loop$0,[0,_cV_])}
          if(92 === match)
           {var i$1=i$0 + 1 | 0,n$1=n$0 + 1 | 0,n$0=n$1,i$0=i$1;continue}
          add_bs(n$0);
          if(counter < 50)
           {var counter$0=counter + 1 | 0;return loop$0(counter$0,i$0)}
          return caml_trampoline_return(loop$0,[0,i$0])}}
      function loop(i){return caml_trampoline(loop$0(0,i))}
      loop(0);
      return contents(b)}
    function drive_and_path(s)
     {var _cR_=2 <= caml_ml_string_length(s)?1:0;
      if(_cR_)
       var
        param=caml_string_get(s,0),
        switch$0=91 <= param?25 < (param - 97 | 0) >>> 0?0:1:65 <= param?1:0,
        _cS_=switch$0?1:0,
        _cT_=_cS_?58 === caml_string_get(s,1)?1:0:_cS_;
      else
       var _cT_=_cR_;
      if(_cT_)
       {var _cU_=sub$0(s,2,caml_ml_string_length(s) - 2 | 0);
        return [0,sub$0(s,0,2),_cU_]}
      return [0,cst$93,s]}
    function dirname$0(s)
     {var
       match=drive_and_path(s),
       path=match[2],
       drive=match[1],
       dir=generic_dirname(is_dir_sep$0,current_dir_name$0,path);
      return symbol(drive,dir)}
    function basename$0(s)
     {var match=drive_and_path(s),path=match[2];
      return generic_basename(is_dir_sep$0,current_dir_name$0,path)}
    function basename$1(_cQ_)
     {return generic_basename(is_dir_sep$0,current_dir_name$1,_cQ_)}
    function dirname$1(_cP_)
     {return generic_dirname(is_dir_sep$0,current_dir_name$1,_cP_)}
    if(caml_string_notequal(os_type,cst_Cygwin))
     if(caml_string_notequal(os_type,cst_Win32))
      var
       current_dir_name$2=current_dir_name,
       parent_dir_name$2=parent_dir_name,
       dir_sep$2=dir_sep,
       is_dir_sep$1=is_dir_sep,
       is_relative$1=is_relative,
       is_implicit$1=is_implicit,
       check_suffix$1=check_suffix,
       temp_dir_name$0=_cy_,
       quote$1=quote,
       basename$2=basename,
       dirname$2=dirname,
       switch$0=1;
     else
      var
       _cD_=
        [0,
         current_dir_name$0,
         parent_dir_name$0,
         dir_sep$0,
         is_dir_sep$0,
         is_relative$0,
         is_implicit$0,
         check_suffix$0,
         temp_dir_name,
         quote$0,
         basename$0,
         dirname$0],
       switch$0=0;
    else
     var
      _cD_=
       [0,
        current_dir_name$1,
        parent_dir_name$1,
        dir_sep$1,
        is_dir_sep$0,
        is_relative$0,
        is_implicit$0,
        check_suffix$0,
        _cy_,
        quote,
        basename$1,
        dirname$1],
      switch$0=0;
    if(! switch$0)
     var
      current_dir_name$2=_cD_[1],
      parent_dir_name$2=_cD_[2],
      dir_sep$2=_cD_[3],
      is_dir_sep$1=is_dir_sep$0,
      is_relative$1=is_relative$0,
      is_implicit$1=is_implicit$0,
      check_suffix$1=check_suffix$0,
      temp_dir_name$0=_cD_[8],
      quote$1=_cD_[9],
      basename$2=_cD_[10],
      dirname$2=_cD_[11];
    function concat$2(dirname,filename)
     {var l=caml_ml_string_length(dirname);
      if(0 !== l)
       if(! is_dir_sep$1(dirname,l - 1 | 0))
        return symbol(dirname,symbol(dir_sep$2,filename));
      return symbol(dirname,filename)}
    function chop_suffix(name,suff)
     {var n=caml_ml_string_length(name) - caml_ml_string_length(suff) | 0;
      return 0 <= n?sub$0(name,0,n):invalid_arg(cst_Filename_chop_suffix)}
    function extension_len(name)
     {var i$4=caml_ml_string_length(name) - 1 | 0,i$1=i$4;
      for(;;)
       {if(0 <= i$1)
         if(! is_dir_sep$1(name,i$1))
          {if(46 === caml_string_get(name,i$1))
            {var i$2=i$1 - 1 | 0,i=i$2;
             for(;;)
              {if(0 <= i)
                if(! is_dir_sep$1(name,i))
                 {if(46 === caml_string_get(name,i))
                   {var i$0=i - 1 | 0,i=i$0;continue}
                  return caml_ml_string_length(name) - i$1 | 0}
               return 0}}
           var i$3=i$1 - 1 | 0,i$1=i$3;
           continue}
        return 0}}
    function extension(name)
     {var l=extension_len(name);
      return 0 === l?cst$94:sub$0(name,caml_ml_string_length(name) - l | 0,l)}
    function chop_extension(name)
     {var l=extension_len(name);
      return 0 === l
              ?invalid_arg(cst_Filename_chop_extension)
              :sub$0(name,0,caml_ml_string_length(name) - l | 0)}
    function remove_extension(name)
     {var l=extension_len(name);
      return 0 === l?name:sub$0(name,0,caml_ml_string_length(name) - l | 0)}
    var prng$0=[246,function(_cO_){return caml_call1(_b2_[2],0)}];
    function temp_file_name(temp_dir,prefix,suffix)
     {var
       _cM_=caml_obj_tag(prng$0),
       _cN_=
        250 === _cM_?prng$0[1]:246 === _cM_?force_lazy_block(prng$0):prng$0,
       rnd=caml_call1(_b2_[4],_cN_) & 16777215;
      return concat$2(temp_dir,caml_call3(sprintf(_cz_),prefix,rnd,suffix))}
    var current_temp_dir_name=[0,temp_dir_name$0];
    function set_temp_dir_name(s){current_temp_dir_name[1] = s;return 0}
    function get_temp_dir_name(param){return current_temp_dir_name[1]}
    function temp_file(opt,prefix,suffix)
     {if(opt)
       var sth=opt[1],temp_dir=sth;
      else
       var temp_dir=current_temp_dir_name[1];
      function try_name(counter)
       {var counter$0=counter;
        for(;;)
         {var name=temp_file_name(temp_dir,prefix,suffix);
          try
           {runtime.caml_sys_close(caml_sys_open(name,_cA_,384));return name}
          catch(e)
           {e = caml_wrap_exception(e);
            if(e[1] === Sys_error)
             {if(1000 <= counter$0)throw e;
              var counter$1=counter$0 + 1 | 0,counter$0=counter$1;
              continue}
            throw e}}}
      return try_name(0)}
    function open_temp_file(opt,_cK_,_cJ_,prefix,suffix)
     {if(opt)var sth=opt[1],mode=sth;else var mode=_cB_;
      if(_cK_)var sth$0=_cK_[1],perms=sth$0;else var perms=384;
      if(_cJ_)
       var sth$1=_cJ_[1],temp_dir=sth$1;
      else
       var temp_dir=current_temp_dir_name[1];
      function try_name(counter)
       {var counter$0=counter;
        for(;;)
         {var name=temp_file_name(temp_dir,prefix,suffix);
          try
           {var _cL_=[0,name,open_out_gen([0,1,[0,3,[0,5,mode]]],perms,name)];
            return _cL_}
          catch(e)
           {e = caml_wrap_exception(e);
            if(e[1] === Sys_error)
             {if(1000 <= counter$0)throw e;
              var counter$1=counter$0 + 1 | 0,counter$0=counter$1;
              continue}
            throw e}}}
      return try_name(0)}
    var
     Filename=
      [0,
       current_dir_name$2,
       parent_dir_name$2,
       dir_sep$2,
       concat$2,
       is_relative$1,
       is_implicit$1,
       check_suffix$1,
       chop_suffix,
       extension,
       remove_extension,
       chop_extension,
       basename$2,
       dirname$2,
       temp_file,
       open_temp_file,
       get_temp_dir_name,
       set_temp_dir_name,
       temp_dir_name$0,
       quote$1];
    caml_register_global(689,Filename,"Filename");
    function add$1(x,y){return [254,x[1] + y[1],x[2] + y[2]]}
    function sub$3(x,y){return [254,x[1] - y[1],x[2] - y[2]]}
    function neg(x){return [254,- x[1],- x[2]]}
    function conj(x){return [254,x[1],- x[2]]}
    function mul(x,y)
     {return [254,x[1] * y[1] - x[2] * y[2],x[1] * y[2] + x[2] * y[1]]}
    function div(x,y)
     {if(Math.abs(y[2]) <= Math.abs(y[1]))
       {var r=y[2] / y[1],d=y[1] + r * y[2];
        return [254,(x[1] + r * x[2]) / d,(x[2] - r * x[1]) / d]}
      var r$0=y[1] / y[2],d$0=y[2] + r$0 * y[1];
      return [254,(r$0 * x[1] + x[2]) / d$0,(r$0 * x[2] - x[1]) / d$0]}
    function inv(x){return div(one$2,x)}
    function norm2(x){return x[1] * x[1] + x[2] * x[2]}
    function norm(x)
     {var r=Math.abs(x[1]),i=Math.abs(x[2]);
      if(r == 0.)return i;
      if(i == 0.)return r;
      if(i <= r){var q=i / r;return r * Math.sqrt(1. + q * q)}
      var q$0=r / i;
      return i * Math.sqrt(1. + q$0 * q$0)}
    function arg(x){return Math.atan2(x[2],x[1])}
    function polar(n,a){return [254,Math.cos(a) * n,Math.sin(a) * n]}
    function sqrt(x)
     {if(x[1] == 0.)if(x[2] == 0.)return _cC_;
      var r=Math.abs(x[1]),i=Math.abs(x[2]);
      if(i <= r)
       var
        q=i / r,
        w=Math.sqrt(r) * Math.sqrt(0.5 * (1. + Math.sqrt(1. + q * q)));
      else
       var
        q$0=r / i,
        w=Math.sqrt(i) * Math.sqrt(0.5 * (q$0 + Math.sqrt(1. + q$0 * q$0)));
      if(0. <= x[1])return [254,w,0.5 * x[2] / w];
      var w$0=0. <= x[2]?w:- w;
      return [254,0.5 * i / w,w$0]}
    function exp(x)
     {var e=Math.exp(x[1]);return [254,e * Math.cos(x[2]),e * Math.sin(x[2])]}
    function log(x)
     {var _cI_=Math.atan2(x[2],x[1]);return [254,Math.log(norm(x)),_cI_]}
    function pow(x,y){return exp(mul(y,log(x)))}
    var
     Complex=
      [0,
       zero$2,
       one$2,
       i,
       neg,
       conj,
       add$1,
       sub$3,
       mul,
       inv,
       div,
       sqrt,
       norm2,
       norm,
       arg,
       polar,
       exp,
       log,
       pow];
    caml_register_global(690,Complex,"Complex");
    var
     ArrayLabels=
      [0,
       init$2,
       create_matrix,
       create_matrix,
       append$0,
       concat$1,
       sub$1,
       copy$1,
       fill$0,
       blit$1,
       to_list,
       of_list,
       iter$2,
       map$2,
       iteri$2,
       mapi$2,
       fold_left$0,
       fold_right$0,
       iter2$0,
       map2$0,
       exists$0,
       for_all$0,
       mem$0,
       memq$0,
       make_float,
       sort,
       fast_sort$0,
       fast_sort$0,
       Floatarray];
    caml_register_global(691,ArrayLabels,"ArrayLabels");
    var
     ListLabels=
      [0,
       length,
       hd,
       compare_lengths,
       compare_length_with,
       cons,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       flatten,
       flatten,
       iter,
       iteri,
       map,
       mapi,
       rev_map,
       fold_left,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_all,
       find_all,
       partition,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       fast_sort,
       fast_sort,
       fast_sort,
       sort_uniq,
       merge];
    caml_register_global(692,ListLabels,"ListLabels");
    var
     BytesLabels=
      [0,
       make,
       init$0,
       empty,
       copy,
       of_string,
       to_string,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit$0,
       concat,
       cat,
       iter$0,
       iteri$0,
       map$0,
       mapi$0,
       trim,
       escaped$0,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase$0,
       lowercase$0,
       capitalize,
       uncapitalize,
       uppercase_ascii$0,
       lowercase_ascii$0,
       capitalize_ascii,
       uncapitalize_ascii,
       compare$1,
       equal$1,
       unsafe_to_string,
       unsafe_of_string];
    caml_register_global(693,BytesLabels,"BytesLabels");
    var
     StringLabels=
      [0,
       make$0,
       init$1,
       copy$0,
       sub$0,
       fill,
       blit$0,
       concat$0,
       iter$1,
       iteri$1,
       map$1,
       mapi$1,
       trim$0,
       escaped$1,
       index$0,
       index_opt$0,
       rindex$0,
       rindex_opt$0,
       index_from$0,
       index_from_opt$0,
       rindex_from$0,
       rindex_from_opt$0,
       contains$0,
       contains_from$0,
       rcontains_from$0,
       uppercase$1,
       lowercase$1,
       capitalize$0,
       uncapitalize$0,
       uppercase_ascii$1,
       lowercase_ascii$1,
       capitalize_ascii$0,
       uncapitalize_ascii$0,
       compare$2,
       equal$2,
       split_on_char];
    caml_register_global(694,StringLabels,"StringLabels");
    var MoreLabels=[0,Hashtbl,Map,Set];
    caml_register_global(695,MoreLabels,"MoreLabels");
    var StdLabels=[0,0,0,0,0];
    caml_register_global(696,StdLabels,"StdLabels");
    var enabled=caml_spacetime_enabled(0);
    function if_spacetime_enabled(f){return enabled?caml_call1(f,0):0}
    function create$7(path)
     {if(caml_spacetime_enabled(0))
       {var channel=open_out(path),t=[0,channel,0];
        caml_spacetime_only_works_for_native_code(t[1]);
        return t}
      return [0,stdout,1]}
    function save_event(time,t,event_name)
     {return if_spacetime_enabled
              (function(param)
                {return caml_spacetime_only_works_for_native_code
                         (time,t[1],event_name)})}
    function save_and_close(time,t)
     {return if_spacetime_enabled
              (function(param)
                {if(t[2])failwith(cst_Series_is_closed);
                 caml_spacetime_only_works_for_native_code(time,t[1]);
                 close_out(t[1]);
                 t[2] = 1;
                 return 0})}
    var Series=[0,create$7,save_event,save_and_close];
    function take$0(time,param)
     {var channel=param[1],closed=param[2];
      return if_spacetime_enabled
              (function(param)
                {if(closed)failwith(cst_Series_is_closed$0);
                 runtime.caml_gc_minor(0);
                 return caml_spacetime_only_works_for_native_code
                         (time,channel)})}
    var Snapshot=[0,take$0];
    function save_event_for_automatic_snapshots(event_name)
     {return if_spacetime_enabled
              (function(param)
                {return caml_spacetime_only_works_for_native_code(event_name)})}
    var
     Spacetime=
      [0,enabled,Series,Snapshot,save_event_for_automatic_snapshots];
    caml_register_global(697,Spacetime,"Spacetime");
    var CamlinternalBigarray=[0];
    caml_register_global(698,CamlinternalBigarray,"CamlinternalBigarray");
    return}
  (function(){return this}()));


//# 1 "../.js/unix/unix.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_check_bound=runtime.caml_check_bound,
     caml_ml_bytes_length=runtime.caml_ml_bytes_length,
     caml_ml_open_descriptor_in=runtime.caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out=runtime.caml_ml_open_descriptor_out,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_new_string=runtime.caml_new_string,
     caml_register_global=runtime.caml_register_global,
     caml_string_equal=runtime.caml_string_equal,
     caml_sys_exit=runtime.caml_sys_exit,
     caml_wrap_exception=runtime.caml_wrap_exception,
     unix_inet_addr_of_string=runtime.unix_inet_addr_of_string;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_close_process_full=caml_new_string("close_process_full"),
     cst_close_process=caml_new_string("close_process"),
     cst_close_process_out=caml_new_string("close_process_out"),
     cst_close_process_in=caml_new_string("close_process_in"),
     cst$9=caml_new_string(""),
     shell=caml_new_string("/bin/sh"),
     cst_c$0=caml_new_string("-c"),
     cst_c=caml_new_string("-c"),
     cst_bin_sh$0=caml_new_string("/bin/sh"),
     cst_bin_sh$1=caml_new_string("/bin/sh"),
     cst$8=caml_new_string(""),
     cst_udp$1=caml_new_string("udp"),
     cst_tcp$1=caml_new_string("tcp"),
     cst$5=caml_new_string(""),
     cst$7=caml_new_string(""),
     cst_tcp=caml_new_string("tcp"),
     cst_udp=caml_new_string("udp"),
     cst_udp$0=caml_new_string("udp"),
     cst_tcp$0=caml_new_string("tcp"),
     cst$6=caml_new_string(""),
     cst_0_0_0_0$0=caml_new_string("0.0.0.0"),
     cst_127_0_0_1$0=caml_new_string("127.0.0.1"),
     cst_Unix_sendto=caml_new_string("Unix.sendto"),
     cst_Unix_send=caml_new_string("Unix.send"),
     cst_Unix_recvfrom=caml_new_string("Unix.recvfrom"),
     cst_Unix_recv=caml_new_string("Unix.recv"),
     cst_Unix_single_write=caml_new_string("Unix.single_write"),
     cst_Unix_write=caml_new_string("Unix.write"),
     cst_Unix_read=caml_new_string("Unix.read"),
     cst$4=caml_new_string(""),
     cst_execvpe=caml_new_string("execvpe"),
     cst_bin_sh=caml_new_string("/bin/sh"),
     cst_PATH=caml_new_string("PATH"),
     cst_bin_usr_bin=caml_new_string("/bin:/usr/bin"),
     cst$1=caml_new_string(': "'),
     cst_failed=caml_new_string('" failed'),
     cst_on=caml_new_string(' on "'),
     cst$2=caml_new_string('"'),
     cst$3=caml_new_string(": "),
     cst_E2BIG=caml_new_string("E2BIG"),
     cst_EACCES=caml_new_string("EACCES"),
     cst_EAGAIN=caml_new_string("EAGAIN"),
     cst_EBADF=caml_new_string("EBADF"),
     cst_EBUSY=caml_new_string("EBUSY"),
     cst_ECHILD=caml_new_string("ECHILD"),
     cst_EDEADLK=caml_new_string("EDEADLK"),
     cst_EDOM=caml_new_string("EDOM"),
     cst_EEXIST=caml_new_string("EEXIST"),
     cst_EFAULT=caml_new_string("EFAULT"),
     cst_EFBIG=caml_new_string("EFBIG"),
     cst_EINTR=caml_new_string("EINTR"),
     cst_EINVAL=caml_new_string("EINVAL"),
     cst_EIO=caml_new_string("EIO"),
     cst_EISDIR=caml_new_string("EISDIR"),
     cst_EMFILE=caml_new_string("EMFILE"),
     cst_EMLINK=caml_new_string("EMLINK"),
     cst_ENAMETOOLONG=caml_new_string("ENAMETOOLONG"),
     cst_ENFILE=caml_new_string("ENFILE"),
     cst_ENODEV=caml_new_string("ENODEV"),
     cst_ENOENT=caml_new_string("ENOENT"),
     cst_ENOEXEC=caml_new_string("ENOEXEC"),
     cst_ENOLCK=caml_new_string("ENOLCK"),
     cst_ENOMEM=caml_new_string("ENOMEM"),
     cst_ENOSPC=caml_new_string("ENOSPC"),
     cst_ENOSYS=caml_new_string("ENOSYS"),
     cst_ENOTDIR=caml_new_string("ENOTDIR"),
     cst_ENOTEMPTY=caml_new_string("ENOTEMPTY"),
     cst_ENOTTY=caml_new_string("ENOTTY"),
     cst_ENXIO=caml_new_string("ENXIO"),
     cst_EPERM=caml_new_string("EPERM"),
     cst_EPIPE=caml_new_string("EPIPE"),
     cst_ERANGE=caml_new_string("ERANGE"),
     cst_EROFS=caml_new_string("EROFS"),
     cst_ESPIPE=caml_new_string("ESPIPE"),
     cst_ESRCH=caml_new_string("ESRCH"),
     cst_EXDEV=caml_new_string("EXDEV"),
     cst_EWOULDBLOCK=caml_new_string("EWOULDBLOCK"),
     cst_EINPROGRESS=caml_new_string("EINPROGRESS"),
     cst_EALREADY=caml_new_string("EALREADY"),
     cst_ENOTSOCK=caml_new_string("ENOTSOCK"),
     cst_EDESTADDRREQ=caml_new_string("EDESTADDRREQ"),
     cst_EMSGSIZE=caml_new_string("EMSGSIZE"),
     cst_EPROTOTYPE=caml_new_string("EPROTOTYPE"),
     cst_ENOPROTOOPT=caml_new_string("ENOPROTOOPT"),
     cst_EPROTONOSUPPORT=caml_new_string("EPROTONOSUPPORT"),
     cst_ESOCKTNOSUPPORT=caml_new_string("ESOCKTNOSUPPORT"),
     cst_EOPNOTSUPP=caml_new_string("EOPNOTSUPP"),
     cst_EPFNOSUPPORT=caml_new_string("EPFNOSUPPORT"),
     cst_EAFNOSUPPORT=caml_new_string("EAFNOSUPPORT"),
     cst_EADDRINUSE=caml_new_string("EADDRINUSE"),
     cst_EADDRNOTAVAIL=caml_new_string("EADDRNOTAVAIL"),
     cst_ENETDOWN=caml_new_string("ENETDOWN"),
     cst_ENETUNREACH=caml_new_string("ENETUNREACH"),
     cst_ENETRESET=caml_new_string("ENETRESET"),
     cst_ECONNABORTED=caml_new_string("ECONNABORTED"),
     cst_ECONNRESET=caml_new_string("ECONNRESET"),
     cst_ENOBUFS=caml_new_string("ENOBUFS"),
     cst_EISCONN=caml_new_string("EISCONN"),
     cst_ENOTCONN=caml_new_string("ENOTCONN"),
     cst_ESHUTDOWN=caml_new_string("ESHUTDOWN"),
     cst_ETOOMANYREFS=caml_new_string("ETOOMANYREFS"),
     cst_ETIMEDOUT=caml_new_string("ETIMEDOUT"),
     cst_ECONNREFUSED=caml_new_string("ECONNREFUSED"),
     cst_EHOSTDOWN=caml_new_string("EHOSTDOWN"),
     cst_EHOSTUNREACH=caml_new_string("EHOSTUNREACH"),
     cst_ELOOP=caml_new_string("ELOOP"),
     cst_EOVERFLOW=caml_new_string("EOVERFLOW"),
     cst_Unix_Unix_error=caml_new_string("Unix.Unix_error"),
     cst=caml_new_string(""),
     cst$0=caml_new_string(""),
     cst_Unix_Unix_error$0=caml_new_string("Unix.Unix_error"),
     cst_0_0_0_0=caml_new_string("0.0.0.0"),
     cst_127_0_0_1=caml_new_string("127.0.0.1"),
     cst$10=caml_new_string("::"),
     cst_1=caml_new_string("::1"),
     Pervasives=global_data.Pervasives,
     Sys_error=global_data.Sys_error,
     Hashtbl=global_data.Hashtbl,
     Not_found=global_data.Not_found,
     Invalid_argument=global_data.Invalid_argument,
     List=global_data.List,
     Failure=global_data.Failure,
     Array=global_data.Array,
     Bytes=global_data.Bytes,
     Filename=global_data.Filename,
     String=global_data.String,
     Sys=global_data.Sys,
     Printf=global_data.Printf,
     Callback=global_data.Callback,
     Printexc=global_data.Printexc,
     Unix_error=[248,cst_Unix_Unix_error,runtime.caml_fresh_oo_id(0)];
    caml_call2(Callback[2],cst_Unix_Unix_error$0,[0,Unix_error,0,cst$0,cst]);
    var
     _p_=[0,1],
     _q_=[0,1],
     _o_=[0,1],
     _l_=[0,1],
     _m_=[0,1],
     _n_=[0,1],
     _j_=[0,1],
     _k_=[0,1],
     _i_=[0,1],
     _h_=[0,1],
     _e_=[0,0],
     _f_=[0,0],
     _g_=[0,0],
     _d_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _c_=
      [0,
       [11,caml_new_string("EUNKNOWNERR "),[4,0,0,0,0]],
       caml_new_string("EUNKNOWNERR %d")],
     _b_=
      [0,
       [11,
        caml_new_string("Unix.Unix_error(Unix."),
        [2,
         0,
         [11,
          caml_new_string(", "),
          [3,0,[11,caml_new_string(", "),[3,0,[12,41,0]]]]]]],
       caml_new_string("Unix.Unix_error(Unix.%s, %S, %S)")];
    function _a_(param)
     {if(param[1] === Unix_error)
       {var s=param[4],s$0=param[3],e=param[2];
        if(typeof e === "number")
         {var _dx_=e;
          if(34 <= _dx_)
           switch(_dx_)
            {case 34:var msg=cst_ESPIPE;break;
             case 35:var msg=cst_ESRCH;break;
             case 36:var msg=cst_EXDEV;break;
             case 37:var msg=cst_EWOULDBLOCK;break;
             case 38:var msg=cst_EINPROGRESS;break;
             case 39:var msg=cst_EALREADY;break;
             case 40:var msg=cst_ENOTSOCK;break;
             case 41:var msg=cst_EDESTADDRREQ;break;
             case 42:var msg=cst_EMSGSIZE;break;
             case 43:var msg=cst_EPROTOTYPE;break;
             case 44:var msg=cst_ENOPROTOOPT;break;
             case 45:var msg=cst_EPROTONOSUPPORT;break;
             case 46:var msg=cst_ESOCKTNOSUPPORT;break;
             case 47:var msg=cst_EOPNOTSUPP;break;
             case 48:var msg=cst_EPFNOSUPPORT;break;
             case 49:var msg=cst_EAFNOSUPPORT;break;
             case 50:var msg=cst_EADDRINUSE;break;
             case 51:var msg=cst_EADDRNOTAVAIL;break;
             case 52:var msg=cst_ENETDOWN;break;
             case 53:var msg=cst_ENETUNREACH;break;
             case 54:var msg=cst_ENETRESET;break;
             case 55:var msg=cst_ECONNABORTED;break;
             case 56:var msg=cst_ECONNRESET;break;
             case 57:var msg=cst_ENOBUFS;break;
             case 58:var msg=cst_EISCONN;break;
             case 59:var msg=cst_ENOTCONN;break;
             case 60:var msg=cst_ESHUTDOWN;break;
             case 61:var msg=cst_ETOOMANYREFS;break;
             case 62:var msg=cst_ETIMEDOUT;break;
             case 63:var msg=cst_ECONNREFUSED;break;
             case 64:var msg=cst_EHOSTDOWN;break;
             case 65:var msg=cst_EHOSTUNREACH;break;
             case 66:var msg=cst_ELOOP;break;
             default:var msg=cst_EOVERFLOW}
          else
           switch(_dx_)
            {case 0:var msg=cst_E2BIG;break;
             case 1:var msg=cst_EACCES;break;
             case 2:var msg=cst_EAGAIN;break;
             case 3:var msg=cst_EBADF;break;
             case 4:var msg=cst_EBUSY;break;
             case 5:var msg=cst_ECHILD;break;
             case 6:var msg=cst_EDEADLK;break;
             case 7:var msg=cst_EDOM;break;
             case 8:var msg=cst_EEXIST;break;
             case 9:var msg=cst_EFAULT;break;
             case 10:var msg=cst_EFBIG;break;
             case 11:var msg=cst_EINTR;break;
             case 12:var msg=cst_EINVAL;break;
             case 13:var msg=cst_EIO;break;
             case 14:var msg=cst_EISDIR;break;
             case 15:var msg=cst_EMFILE;break;
             case 16:var msg=cst_EMLINK;break;
             case 17:var msg=cst_ENAMETOOLONG;break;
             case 18:var msg=cst_ENFILE;break;
             case 19:var msg=cst_ENODEV;break;
             case 20:var msg=cst_ENOENT;break;
             case 21:var msg=cst_ENOEXEC;break;
             case 22:var msg=cst_ENOLCK;break;
             case 23:var msg=cst_ENOMEM;break;
             case 24:var msg=cst_ENOSPC;break;
             case 25:var msg=cst_ENOSYS;break;
             case 26:var msg=cst_ENOTDIR;break;
             case 27:var msg=cst_ENOTEMPTY;break;
             case 28:var msg=cst_ENOTTY;break;
             case 29:var msg=cst_ENXIO;break;
             case 30:var msg=cst_EPERM;break;
             case 31:var msg=cst_EPIPE;break;
             case 32:var msg=cst_ERANGE;break;
             default:var msg=cst_EROFS}}
        else
         var x=e[1],msg=caml_call2(Printf[4],_c_,x);
        return [0,caml_call4(Printf[4],_b_,msg,s$0,s)]}
      return 0}
    caml_call1(Printexc[8],_a_);
    function handle_unix_error(f,arg)
     {try
       {var _dw_=caml_call1(f,arg);return _dw_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Unix_error)
         {var
           arg$0=exn[4],
           fun_name=exn[3],
           err=exn[2],
           _du_=caml_check_bound(Sys[1],0)[1];
          caml_call1(Pervasives[37],_du_);
          caml_call1(Pervasives[37],cst$1);
          caml_call1(Pervasives[37],fun_name);
          caml_call1(Pervasives[37],cst_failed);
          if(0 < caml_ml_string_length(arg$0))
           {caml_call1(Pervasives[37],cst_on);
            caml_call1(Pervasives[37],arg$0);
            caml_call1(Pervasives[37],cst$2)}
          caml_call1(Pervasives[37],cst$3);
          var _dv_=runtime.unix_error_message(err);
          caml_call1(Pervasives[41],_dv_);
          return caml_call1(Pervasives[87],2)}
        throw exn}}
    function execvpe(name,args,env)
     {try
       {var _do_=runtime.unix_execvpe(name,args,env);return _do_}
      catch(_dp_)
       {_dp_ = caml_wrap_exception(_dp_);
        if(_dp_[1] === Unix_error)
         {var _dn_=_dp_[2];
          if(typeof _dn_ === "number")
           if(25 === _dn_)
            {var
              exec=
               function(file)
                {try
                  {var _ds_=runtime.unix_execve(file,args,env);return _ds_}
                 catch(_dt_)
                  {_dt_ = caml_wrap_exception(_dt_);
                   if(_dt_[1] === Unix_error)
                    {var _dr_=_dt_[2];
                     if(typeof _dr_ === "number")
                      if(21 === _dr_)
                       {var
                         argc=args.length - 1,
                         args$0=
                          0 === argc?args:caml_call3(Array[7],args,1,argc - 1 | 0),
                         new_args=caml_call2(Array[5],[0,cst_bin_sh,file],args$0);
                        return runtime.unix_execve
                                (caml_check_bound(new_args,0)[1],new_args,env)}}
                   throw _dt_}};
             if(caml_call2(String[22],name,47))return exec(name);
             try
              {var _dm_=runtime.caml_sys_unsafe_getenv(cst_PATH),_dl_=_dm_}
             catch(_dq_)
              {_dq_ = caml_wrap_exception(_dq_);
               if(_dq_ !== Not_found)throw _dq_;
               var _dl_=cst_bin_usr_bin}
             var
              param$0=caml_call2(String[35],58,_dl_),
              eacces=0,
              param=param$0;
             for(;;)
              {if(param)
                {var
                  rem=param[2],
                  dir=param[1],
                  dir$0=caml_string_equal(dir,cst$4)?Filename[1]:dir;
                 try
                  {var _dj_=exec(caml_call2(Filename[4],dir$0,name));
                   return _dj_}
                 catch(exn)
                  {exn = caml_wrap_exception(exn);
                   if(exn[1] === Unix_error)
                    {var err=exn[2];
                     if(typeof err === "number")
                      {var _di_=err - 62 | 0;
                       if(4 < _di_ >>> 0)
                        if(-35 <= _di_)
                         var switch$0=0;
                        else
                         {var switcher=_di_ + 62 | 0;
                          switch(switcher)
                           {case 1:var eacces=1,param=rem;continue;
                            case 14:
                            case 17:
                            case 19:
                            case 20:
                            case 26:var switch$0=1;break;
                            default:var switch$0=0}}
                       else
                        var switch$0=2 < (_di_ - 1 | 0) >>> 0?1:0;
                       if(switch$0){var param=rem;continue}}
                     throw exn}
                   throw exn}}
               var _dk_=eacces?1:20;
               throw [0,Unix_error,_dk_,cst_execvpe,name]}}}
        throw _dp_}}
    var stdin=0,stdout=1,stderr=2;
    function read(fd,buf,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(buf) - len | 0) < ofs))
         return runtime.unix_read(fd,buf,ofs,len);
      return caml_call1(Pervasives[1],cst_Unix_read)}
    function write(fd,buf,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(buf) - len | 0) < ofs))
         return runtime.unix_write(fd,buf,ofs,len);
      return caml_call1(Pervasives[1],cst_Unix_write)}
    function single_write(fd,buf,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(buf) - len | 0) < ofs))
         return runtime.unix_single_write(fd,buf,ofs,len);
      return caml_call1(Pervasives[1],cst_Unix_single_write)}
    function write_substring(fd,buf,ofs,len)
     {return write(fd,caml_call1(Bytes[43],buf),ofs,len)}
    function single_write_substring(fd,buf,ofs,len)
     {return single_write(fd,caml_call1(Bytes[43],buf),ofs,len)}
    function map_file(fd,opt,kind,layout,shared,dims)
     {if(opt)var sth=opt[1],pos=sth;else var pos=_d_;
      return runtime.caml_unix_map_file_bytecode
              (fd,kind,layout,shared,dims,pos)}
    function pause(param)
     {var sigs=runtime.unix_sigprocmask(1,0);
      return runtime.unix_sigsuspend(sigs)}
    function sleep(duration){return runtime.unix_sleep(duration)}
    var
     inet_addr_any=unix_inet_addr_of_string(cst_0_0_0_0),
     inet_addr_loopback=unix_inet_addr_of_string(cst_127_0_0_1);
    try
     {var _z_=unix_inet_addr_of_string(cst$10),inet_addr_any$0=_z_}
    catch(_dh_)
     {_dh_ = caml_wrap_exception(_dh_);
      if(_dh_[1] !== Failure)throw _dh_;
      var inet_addr_any$0=inet_addr_any}
    try
     {var _y_=unix_inet_addr_of_string(cst_1),inet6_addr_loopback=_y_}
    catch(_dg_)
     {_dg_ = caml_wrap_exception(_dg_);
      if(_dg_[1] !== Failure)throw _dg_;
      var inet6_addr_loopback=inet_addr_loopback}
    function domain_of_sockaddr(param)
     {if(0 === param[0])return 0;
      var a=param[1];
      return 16 === caml_ml_string_length(a)?2:1}
    function recv(fd,buf,ofs,len,flags)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(buf) - len | 0) < ofs))
         return runtime.unix_recv(fd,buf,ofs,len,flags);
      return caml_call1(Pervasives[1],cst_Unix_recv)}
    function recvfrom(fd,buf,ofs,len,flags)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(buf) - len | 0) < ofs))
         return runtime.unix_recvfrom(fd,buf,ofs,len,flags);
      return caml_call1(Pervasives[1],cst_Unix_recvfrom)}
    function send(fd,buf,ofs,len,flags)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(buf) - len | 0) < ofs))
         return runtime.unix_send(fd,buf,ofs,len,flags);
      return caml_call1(Pervasives[1],cst_Unix_send)}
    function sendto(fd,buf,ofs,len,flags,addr)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(buf) - len | 0) < ofs))
         return runtime.unix_sendto(fd,buf,ofs,len,flags,addr);
      return caml_call1(Pervasives[1],cst_Unix_sendto)}
    function send_substring(fd,buf,ofs,len,flags)
     {return send(fd,caml_call1(Bytes[43],buf),ofs,len,flags)}
    function sendto_substring(fd,buf,ofs,len,flags,addr)
     {return sendto(fd,caml_call1(Bytes[43],buf),ofs,len,flags,addr)}
    function getsockopt(fd,opt){return runtime.unix_getsockopt(0,fd,opt)}
    function setsockopt(fd,opt,v){return runtime.unix_setsockopt(0,fd,opt,v)}
    function getsockopt_int(fd,opt){return runtime.unix_getsockopt(1,fd,opt)}
    function setsockopt_int(fd,opt,v)
     {return runtime.unix_setsockopt(1,fd,opt,v)}
    function getsockopt_optint(fd,opt)
     {return runtime.unix_getsockopt(2,fd,opt)}
    function setsockopt_optint(fd,opt,v)
     {return runtime.unix_setsockopt(2,fd,opt,v)}
    function getsockopt_float(fd,opt)
     {return runtime.unix_getsockopt(3,fd,opt)}
    function setsockopt_float(fd,opt,v)
     {return runtime.unix_setsockopt(3,fd,opt,v)}
    function getsockopt_error(fd){return runtime.unix_getsockopt(4,fd,0)}
    function getaddrinfo(node,service,opts)
     {try
       {var
         _c8_=runtime.unix_getaddrinfo(node,service,opts),
         _c9_=caml_call1(List[9],_c8_);
        return _c9_}
      catch(_c__)
       {_c__ = caml_wrap_exception(_c__);
        if(_c__[1] === Invalid_argument)
         {var
           opt_socktype=[0,0],
           opt_protocol=[0,0],
           opt_passive=[0,0],
           _cV_=
            function(param)
             {if(typeof param === "number")
               {if(2 === param){opt_passive[1] = 1;return 0}}
              else
               switch(param[0])
                {case 1:var s=param[1];opt_socktype[1] = [0,s];return 0;
                 case 2:var p=param[1];opt_protocol[1] = p;return 0
                 }
              return 0};
          caml_call2(List[15],_cV_,opts);
          var
           get_port=
            function(ty,kind)
             {if(caml_string_equal(service,cst$5))return [0,[0,ty,0],0];
              try
               {var _dd_=[0,[0,ty,runtime.caml_int_of_string(service)],0];
                return _dd_}
              catch(_de_)
               {_de_ = caml_wrap_exception(_de_);
                if(_de_[1] === Failure)
                 try
                  {var
                    _dc_=
                     [0,[0,ty,runtime.unix_getservbyname(service,kind)[3]],0];
                   return _dc_}
                 catch(_df_)
                  {_df_ = caml_wrap_exception(_df_);
                   if(_df_ === Not_found)return 0;
                   throw _df_}
                throw _de_}},
           _cW_=opt_socktype[1];
          if(_cW_)
           var
            _cX_=_cW_[1],
            _cY_=
             1 === _cX_
              ?get_port(1,cst_udp)
              :0 === _cX_
                ?get_port(0,cst_tcp)
                :caml_string_equal(service,cst$7)?[0,[0,_cX_,0],0]:0,
            ports=_cY_;
          else
           var
            _c6_=get_port(1,cst_udp$0),
            _c7_=get_port(0,cst_tcp$0),
            ports=caml_call2(Pervasives[25],_c7_,_c6_);
          if(caml_string_equal(node,cst$6))
           var
            addresses=
             caml_call2(List[31],2,opts)
              ?[0,[0,inet_addr_any,cst_0_0_0_0$0],0]
              :[0,[0,inet_addr_loopback,cst_127_0_0_1$0],0];
          else
           try
            {var
              _c5_=[0,[0,unix_inet_addr_of_string(node),node],0],
              addresses=_c5_}
           catch(_da_)
            {_da_ = caml_wrap_exception(_da_);
             if(_da_[1] !== Failure)throw _da_;
             try
              {var
                he=runtime.unix_gethostbyname(node),
                _c2_=caml_call1(Array[11],he[4]),
                _c3_=function(a){return [0,a,he[1]]},
                _c4_=caml_call2(List[17],_c3_,_c2_),
                _c1_=_c4_}
             catch(_db_)
              {_db_ = caml_wrap_exception(_db_);
               if(_db_ !== Not_found)throw _db_;
               var _c1_=0}
             var addresses=_c1_}
          var
           _cZ_=
            function(param)
             {var port=param[2],ty=param[1];
              function _c$_(param)
               {var name=param[2],addr=param[1];
                return [0,1,ty,opt_protocol[1],[1,addr,port],name]}
              return caml_call2(List[17],_c$_,addresses)},
           _c0_=caml_call2(List[17],_cZ_,ports);
          return caml_call1(List[14],_c0_)}
        throw _c__}}
    function getnameinfo(addr,opts)
     {try
       {var _cR_=runtime.unix_getnameinfo(addr,opts);return _cR_}
      catch(_cS_)
       {_cS_ = caml_wrap_exception(_cS_);
        if(_cS_[1] === Invalid_argument)
         {if(0 === addr[0]){var f=addr[1];return [0,cst$8,f]}
          var p=addr[2],a=addr[1];
          try
           {if(caml_call2(List[31],1,opts))throw Not_found;
            var _cQ_=runtime.unix_gethostbyaddr(a)[1],hostname=_cQ_}
          catch(_cU_)
           {_cU_ = caml_wrap_exception(_cU_);
            if(_cU_ !== Not_found)throw _cU_;
            if(caml_call2(List[31],2,opts))throw Not_found;
            var hostname=runtime.unix_string_of_inet_addr(a)}
          try
           {if(caml_call2(List[31],3,opts))throw Not_found;
            var
             kind=caml_call2(List[31],4,opts)?cst_udp$1:cst_tcp$1,
             _cP_=runtime.unix_getservbyport(p,kind)[1],
             service=_cP_}
          catch(_cT_)
           {_cT_ = caml_wrap_exception(_cT_);
            if(_cT_ !== Not_found)throw _cT_;
            var service=caml_call1(Pervasives[21],p)}
          return [0,hostname,service]}
        throw _cS_}}
    function waitpid_non_intr(pid)
     {for(;;)
       try
        {var _cN_=runtime.unix_waitpid(0,pid);return _cN_}
       catch(_cO_)
        {_cO_ = caml_wrap_exception(_cO_);
         if(_cO_[1] === Unix_error)
          {var _cM_=_cO_[2];
           if(typeof _cM_ === "number")if(11 === _cM_)continue}
         throw _cO_}}
    function system(cmd)
     {var id=runtime.unix_fork(0);
      if(0 === id)
       try
        {var _cK_=runtime.unix_execv(cst_bin_sh$1,[0,cst_bin_sh$0,cst_c,cmd]);
         return _cK_}
       catch(_cL_){return caml_sys_exit(127)}
      return waitpid_non_intr(id)[2]}
    function file_descr_not_standard(fd)
     {var fd$0=fd;
      for(;;)
       {if(3 <= fd$0)return fd$0;
        var fd$1=runtime.unix_dup(0,fd$0),fd$0=fd$1;
        continue}}
    function safe_close(fd)
     {try
       {var _cI_=runtime.unix_close(fd);return _cI_}
      catch(_cJ_)
       {_cJ_ = caml_wrap_exception(_cJ_);
        if(_cJ_[1] === Unix_error)return 0;
        throw _cJ_}}
    function perform_redirections(new_stdin,new_stdout,new_stderr)
     {var
       new_stdin$0=file_descr_not_standard(new_stdin),
       new_stdout$0=file_descr_not_standard(new_stdout),
       new_stderr$0=file_descr_not_standard(new_stderr);
      runtime.unix_dup2(_e_,new_stdin$0,0);
      runtime.unix_dup2(_f_,new_stdout$0,1);
      runtime.unix_dup2(_g_,new_stderr$0,2);
      safe_close(new_stdin$0);
      safe_close(new_stdout$0);
      return safe_close(new_stderr$0)}
    function create_process(cmd,args,new_stdin,new_stdout,new_stderr)
     {var id=runtime.unix_fork(0);
      if(0 === id)
       try
        {perform_redirections(new_stdin,new_stdout,new_stderr);
         var _cG_=runtime.unix_execvp(cmd,args);
         return _cG_}
       catch(_cH_){return caml_sys_exit(127)}
      return id}
    function create_process_env(cmd,args,env,new_stdin,new_stdout,new_stderr)
     {var id=runtime.unix_fork(0);
      if(0 === id)
       try
        {perform_redirections(new_stdin,new_stdout,new_stderr);
         var _cE_=execvpe(cmd,args,env);
         return _cE_}
       catch(_cF_){return caml_sys_exit(127)}
      return id}
    var popen_processes=caml_call2(Hashtbl[1],0,7);
    function open_proc(cmd,envopt,proc,input,output,error)
     {var id=runtime.unix_fork(0);
      if(0 === id)
       {perform_redirections(input,output,error);
        var argv=[0,shell,cst_c$0,cmd];
        try
         {if(envopt)
           var env=envopt[1],_cC_=runtime.unix_execve(shell,argv,env);
          else
           var _cC_=runtime.unix_execv(shell,argv);
          return _cC_}
        catch(_cD_){return caml_sys_exit(127)}}
      return caml_call3(Hashtbl[5],popen_processes,proc,id)}
    function open_process_in(cmd)
     {var
       match=runtime.unix_pipe(_h_,0),
       in_write=match[2],
       in_read=match[1],
       inchan=caml_ml_open_descriptor_in(in_read);
      try
       {open_proc(cmd,0,[1,inchan],stdin,in_write,stderr)}
      catch(e)
       {e = caml_wrap_exception(e);
        caml_call1(Pervasives[81],inchan);
        runtime.unix_close(in_write);
        throw e}
      runtime.unix_close(in_write);
      return inchan}
    function open_process_out(cmd)
     {var
       match=runtime.unix_pipe(_i_,0),
       out_write=match[2],
       out_read=match[1],
       outchan=caml_ml_open_descriptor_out(out_write);
      try
       {open_proc(cmd,0,[2,outchan],out_read,stdout,stderr)}
      catch(e)
       {e = caml_wrap_exception(e);
        caml_call1(Pervasives[64],outchan);
        runtime.unix_close(out_read);
        throw e}
      runtime.unix_close(out_read);
      return outchan}
    function open_process(cmd)
     {var match=runtime.unix_pipe(_j_,0),in_write=match[2],in_read=match[1];
      try
       {var match$0=runtime.unix_pipe(_k_,0)}
      catch(e)
       {e = caml_wrap_exception(e);
        runtime.unix_close(in_read);
        runtime.unix_close(in_write);
        throw e}
      var
       out_write=match$0[2],
       out_read=match$0[1],
       inchan=caml_ml_open_descriptor_in(in_read),
       outchan=caml_ml_open_descriptor_out(out_write);
      try
       {open_proc(cmd,0,[0,inchan,outchan],out_read,in_write,stderr)}
      catch(e)
       {e = caml_wrap_exception(e);
        runtime.unix_close(out_read);
        runtime.unix_close(out_write);
        runtime.unix_close(in_read);
        runtime.unix_close(in_write);
        throw e}
      runtime.unix_close(out_read);
      runtime.unix_close(in_write);
      return [0,inchan,outchan]}
    function open_process_full(cmd,env)
     {var match=runtime.unix_pipe(_l_,0),in_write=match[2],in_read=match[1];
      try
       {var match$0=runtime.unix_pipe(_m_,0)}
      catch(e)
       {e = caml_wrap_exception(e);
        runtime.unix_close(in_read);
        runtime.unix_close(in_write);
        throw e}
      var out_write=match$0[2],out_read=match$0[1];
      try
       {var match$1=runtime.unix_pipe(_n_,0)}
      catch(e)
       {e = caml_wrap_exception(e);
        runtime.unix_close(in_read);
        runtime.unix_close(in_write);
        runtime.unix_close(out_read);
        runtime.unix_close(out_write);
        throw e}
      var
       err_write=match$1[2],
       err_read=match$1[1],
       inchan=caml_ml_open_descriptor_in(in_read),
       outchan=caml_ml_open_descriptor_out(out_write),
       errchan=caml_ml_open_descriptor_in(err_read);
      try
       {open_proc
         (cmd,[0,env],[3,inchan,outchan,errchan],out_read,in_write,err_write)}
      catch(e)
       {e = caml_wrap_exception(e);
        runtime.unix_close(out_read);
        runtime.unix_close(out_write);
        runtime.unix_close(in_read);
        runtime.unix_close(in_write);
        runtime.unix_close(err_read);
        runtime.unix_close(err_write);
        throw e}
      runtime.unix_close(out_read);
      runtime.unix_close(in_write);
      runtime.unix_close(err_write);
      return [0,inchan,outchan,errchan]}
    function find_proc_id(fun_name,proc)
     {try
       {var pid=caml_call2(Hashtbl[6],popen_processes,proc);
        caml_call2(Hashtbl[10],popen_processes,proc);
        return pid}
      catch(_cB_)
       {_cB_ = caml_wrap_exception(_cB_);
        if(_cB_ === Not_found)throw [0,Unix_error,3,fun_name,cst$9];
        throw _cB_}}
    function close_process_in(inchan)
     {var pid=find_proc_id(cst_close_process_in,[1,inchan]);
      caml_call1(Pervasives[81],inchan);
      return waitpid_non_intr(pid)[2]}
    function close_process_out(outchan)
     {var pid=find_proc_id(cst_close_process_out,[2,outchan]);
      try
       {caml_call1(Pervasives[64],outchan)}
      catch(_cA_)
       {_cA_ = caml_wrap_exception(_cA_);if(_cA_[1] !== Sys_error)throw _cA_}
      return waitpid_non_intr(pid)[2]}
    function close_process(param)
     {var
       outchan=param[2],
       inchan=param[1],
       pid=find_proc_id(cst_close_process,[0,inchan,outchan]);
      caml_call1(Pervasives[81],inchan);
      try
       {caml_call1(Pervasives[64],outchan)}
      catch(_cz_)
       {_cz_ = caml_wrap_exception(_cz_);if(_cz_[1] !== Sys_error)throw _cz_}
      return waitpid_non_intr(pid)[2]}
    function close_process_full(param)
     {var
       errchan=param[3],
       outchan=param[2],
       inchan=param[1],
       pid=find_proc_id(cst_close_process_full,[3,inchan,outchan,errchan]);
      caml_call1(Pervasives[81],inchan);
      try
       {caml_call1(Pervasives[64],outchan)}
      catch(_cy_)
       {_cy_ = caml_wrap_exception(_cy_);if(_cy_[1] !== Sys_error)throw _cy_}
      caml_call1(Pervasives[81],errchan);
      return waitpid_non_intr(pid)[2]}
    function open_connection(sockaddr)
     {var sock=runtime.unix_socket(_o_,domain_of_sockaddr(sockaddr),0,0);
      try
       {runtime.unix_connect(sock,sockaddr);
        var
         _cw_=caml_ml_open_descriptor_out(sock),
         _cx_=[0,caml_ml_open_descriptor_in(sock),_cw_];
        return _cx_}
      catch(exn)
       {exn = caml_wrap_exception(exn);runtime.unix_close(sock);throw exn}}
    function shutdown_connection(inchan)
     {return runtime.unix_shutdown(runtime.caml_channel_descriptor(inchan),1)}
    function accept_non_intr(s)
     {for(;;)
       try
        {var _cu_=runtime.unix_accept(_p_,s);return _cu_}
       catch(_cv_)
        {_cv_ = caml_wrap_exception(_cv_);
         if(_cv_[1] === Unix_error)
          {var _ct_=_cv_[2];
           if(typeof _ct_ === "number")if(11 === _ct_)continue}
         throw _cv_}}
    function establish_server(server_fun,sockaddr)
     {var sock=runtime.unix_socket(_q_,domain_of_sockaddr(sockaddr),0,0);
      runtime.unix_setsockopt(0,sock,2,1);
      runtime.unix_bind(sock,sockaddr);
      runtime.unix_listen(sock,5);
      for(;;)
       {var match=accept_non_intr(sock),s=match[1],id=runtime.unix_fork(0);
        if(0 === id)
         {if(0 !== runtime.unix_fork(0))caml_sys_exit(0);
          runtime.unix_close(sock);
          var
           inchan=caml_ml_open_descriptor_in(s),
           outchan=caml_ml_open_descriptor_out(s);
          caml_call2(server_fun,inchan,outchan);
          caml_call1(Pervasives[87],0)}
        else
         {runtime.unix_close(s);waitpid_non_intr(id)}
        continue}}
    function setsid(_cs_){return runtime.unix_setsid(_cs_)}
    function tcflow(_cr_,_cq_){return runtime.unix_tcflow(_cr_,_cq_)}
    function tcflush(_cp_,_co_){return runtime.unix_tcflush(_cp_,_co_)}
    function tcdrain(_cn_){return runtime.unix_tcdrain(_cn_)}
    function tcsendbreak(_cm_,_cl_)
     {return runtime.unix_tcsendbreak(_cm_,_cl_)}
    function tcsetattr(_ck_,_cj_,_ci_)
     {return runtime.unix_tcsetattr(_ck_,_cj_,_ci_)}
    function tcgetattr(_ch_){return runtime.unix_tcgetattr(_ch_)}
    function getservbyport(_cg_,_cf_)
     {return runtime.unix_getservbyport(_cg_,_cf_)}
    function getservbyname(_ce_,_cd_)
     {return runtime.unix_getservbyname(_ce_,_cd_)}
    function getprotobynumber(_cc_)
     {return runtime.unix_getprotobynumber(_cc_)}
    function getprotobyname(_cb_){return runtime.unix_getprotobyname(_cb_)}
    function gethostbyaddr(_ca_){return runtime.unix_gethostbyaddr(_ca_)}
    function gethostbyname(_b$_){return runtime.unix_gethostbyname(_b$_)}
    function gethostname(_b__){return runtime.unix_gethostname(_b__)}
    function getpeername(_b9_){return runtime.unix_getpeername(_b9_)}
    function getsockname(_b8_){return runtime.unix_getsockname(_b8_)}
    function shutdown(_b7_,_b6_){return runtime.unix_shutdown(_b7_,_b6_)}
    function listen(_b5_,_b4_){return runtime.unix_listen(_b5_,_b4_)}
    function connect(_b3_,_b2_){return runtime.unix_connect(_b3_,_b2_)}
    function bind(_b1_,_b0_){return runtime.unix_bind(_b1_,_b0_)}
    function accept(_bZ_,_bY_){return runtime.unix_accept(_bZ_,_bY_)}
    function socketpair(_bX_,_bW_,_bV_,_bU_)
     {return runtime.unix_socketpair(_bX_,_bW_,_bV_,_bU_)}
    function socket(_bT_,_bS_,_bR_,_bQ_)
     {return runtime.unix_socket(_bT_,_bS_,_bR_,_bQ_)}
    function string_of_inet_addr(_bP_)
     {return runtime.unix_string_of_inet_addr(_bP_)}
    function inet_addr_of_string(_bO_){return unix_inet_addr_of_string(_bO_)}
    function getgrgid(_bN_){return runtime.unix_getgrgid(_bN_)}
    function getpwuid(_bM_){return runtime.unix_getpwuid(_bM_)}
    function getgrnam(_bL_){return runtime.unix_getgrnam(_bL_)}
    function getpwnam(_bK_){return runtime.unix_getpwnam(_bK_)}
    function getlogin(_bJ_){return runtime.unix_getlogin(_bJ_)}
    function initgroups(_bI_,_bH_){return runtime.unix_initgroups(_bI_,_bH_)}
    function setgroups(_bG_){return runtime.unix_setgroups(_bG_)}
    function getgroups(_bF_){return runtime.unix_getgroups(_bF_)}
    function setgid(_bE_){return runtime.unix_setgid(_bE_)}
    function getegid(_bD_){return runtime.unix_getegid(_bD_)}
    function getgid(_bC_){return runtime.unix_getgid(_bC_)}
    function setuid(_bB_){return runtime.unix_setuid(_bB_)}
    function geteuid(_bA_){return runtime.unix_geteuid(_bA_)}
    function getuid(_bz_){return runtime.unix_getuid(_bz_)}
    function setitimer(_by_,_bx_){return runtime.unix_setitimer(_by_,_bx_)}
    function getitimer(_bw_){return runtime.unix_getitimer(_bw_)}
    function utimes(_bv_,_bu_,_bt_)
     {return runtime.unix_utimes(_bv_,_bu_,_bt_)}
    function times(_bs_){return runtime.unix_times(_bs_)}
    function _r_(_br_){return runtime.unix_sleep(_br_)}
    function alarm(_bq_){return runtime.unix_alarm(_bq_)}
    var
     mktime=runtime.unix_mktime,
     localtime=runtime.unix_localtime,
     gmtime=runtime.unix_gmtime;
    function gettimeofday(_bp_){return runtime.unix_gettimeofday(_bp_)}
    function time(_bo_){return runtime.unix_time(_bo_)}
    function sigsuspend(_bn_){return runtime.unix_sigsuspend(_bn_)}
    function sigpending(_bm_){return runtime.unix_sigpending(_bm_)}
    function sigprocmask(_bl_,_bk_)
     {return runtime.unix_sigprocmask(_bl_,_bk_)}
    function kill(_bj_,_bi_){return runtime.unix_kill(_bj_,_bi_)}
    function lockf(_bh_,_bg_,_bf_){return runtime.unix_lockf(_bh_,_bg_,_bf_)}
    function select(_be_,_bd_,_bc_,_bb_)
     {return runtime.unix_select(_be_,_bd_,_bc_,_bb_)}
    function readlink(_ba_){return runtime.unix_readlink(_ba_)}
    function has_symlink(_a$_){return runtime.unix_has_symlink(_a$_)}
    function symlink(_a__,_a9_,_a8_)
     {return runtime.unix_symlink(_a__,_a9_,_a8_)}
    function mkfifo(_a7_,_a6_){return runtime.unix_mkfifo(_a7_,_a6_)}
    function pipe(_a5_,_a4_){return runtime.unix_pipe(_a5_,_a4_)}
    function closedir(_a3_){return runtime.unix_closedir(_a3_)}
    function rewinddir(_a2_){return runtime.unix_rewinddir(_a2_)}
    function readdir(_a1_){return runtime.unix_readdir(_a1_)}
    function opendir(_a0_){return runtime.unix_opendir(_a0_)}
    function chroot(_aZ_){return runtime.unix_chroot(_aZ_)}
    function getcwd(_aY_){return runtime.unix_getcwd(_aY_)}
    function chdir(_aX_){return runtime.unix_chdir(_aX_)}
    function rmdir(_aW_){return runtime.unix_rmdir(_aW_)}
    function mkdir(_aV_,_aU_){return runtime.unix_mkdir(_aV_,_aU_)}
    function clear_close_on_exec(_aT_)
     {return runtime.unix_clear_close_on_exec(_aT_)}
    function set_close_on_exec(_aS_)
     {return runtime.unix_set_close_on_exec(_aS_)}
    function clear_nonblock(_aR_){return runtime.unix_clear_nonblock(_aR_)}
    function set_nonblock(_aQ_){return runtime.unix_set_nonblock(_aQ_)}
    function dup2(_aP_,_aO_,_aN_){return runtime.unix_dup2(_aP_,_aO_,_aN_)}
    function dup(_aM_,_aL_){return runtime.unix_dup(_aM_,_aL_)}
    function access(_aK_,_aJ_){return runtime.unix_access(_aK_,_aJ_)}
    function umask(_aI_){return runtime.unix_umask(_aI_)}
    function fchown(_aH_,_aG_,_aF_)
     {return runtime.unix_fchown(_aH_,_aG_,_aF_)}
    function chown(_aE_,_aD_,_aC_){return runtime.unix_chown(_aE_,_aD_,_aC_)}
    function fchmod(_aB_,_aA_){return runtime.unix_fchmod(_aB_,_aA_)}
    function chmod(_az_,_ay_){return runtime.unix_chmod(_az_,_ay_)}
    function link(_ax_,_aw_){return runtime.unix_link(_ax_,_aw_)}
    function rename(_av_,_au_){return runtime.unix_rename(_av_,_au_)}
    function unlink(_at_){return runtime.unix_unlink(_at_)}
    function _s_(_as_){return runtime.unix_fstat_64(_as_)}
    function _t_(_ar_){return runtime.unix_lstat_64(_ar_)}
    function _u_(_aq_){return runtime.unix_stat_64(_aq_)}
    function _v_(_ap_,_ao_){return runtime.unix_ftruncate_64(_ap_,_ao_)}
    function _w_(_an_,_am_){return runtime.unix_truncate_64(_an_,_am_)}
    var
     LargeFile=
      [0,
       function(_al_,_ak_,_aj_){return runtime.unix_lseek_64(_al_,_ak_,_aj_)},
       _w_,
       _v_,
       _u_,
       _t_,
       _s_];
    function isatty(_ai_){return runtime.unix_isatty(_ai_)}
    function fstat(_ah_){return runtime.unix_fstat(_ah_)}
    function lstat(_ag_){return runtime.unix_lstat(_ag_)}
    function stat(_af_){return runtime.unix_stat(_af_)}
    function ftruncate(_ae_,_ad_){return runtime.unix_ftruncate(_ae_,_ad_)}
    function truncate(_ac_,_ab_){return runtime.unix_truncate(_ac_,_ab_)}
    function lseek(_aa_,_$_,___){return runtime.unix_lseek(_aa_,_$_,___)}
    function descr_of_out_channel(_Z_)
     {return runtime.caml_channel_descriptor(_Z_)}
    function descr_of_in_channel(_Y_)
     {return runtime.caml_channel_descriptor(_Y_)}
    var
     out_channel_of_descr=caml_ml_open_descriptor_out,
     in_channel_of_descr=caml_ml_open_descriptor_in;
    function close(_X_){return runtime.unix_close(_X_)}
    function openfile(_W_,_V_,_U_){return runtime.unix_open(_W_,_V_,_U_)}
    function nice(_T_){return runtime.unix_nice(_T_)}
    function getppid(_S_){return runtime.unix_getppid(_S_)}
    function getpid(_R_){return runtime.unix_getpid(_R_)}
    function waitpid(_Q_,_P_){return runtime.unix_waitpid(_Q_,_P_)}
    function wait(_O_){return runtime.unix_wait(_O_)}
    function fork(_N_){return runtime.unix_fork(_N_)}
    function execvp(_M_,_L_){return runtime.unix_execvp(_M_,_L_)}
    function execve(_K_,_J_,_I_){return runtime.unix_execve(_K_,_J_,_I_)}
    function execv(_H_,_G_){return runtime.unix_execv(_H_,_G_)}
    function putenv(_F_,_E_){return runtime.unix_putenv(_F_,_E_)}
    function unsafe_getenv(_D_){return runtime.caml_sys_unsafe_getenv(_D_)}
    var getenv=runtime.caml_sys_getenv;
    function _x_(_C_){return runtime.unix_environment_unsafe(_C_)}
    function environment(_B_){return runtime.unix_environment(_B_)}
    function error_message(_A_){return runtime.unix_error_message(_A_)}
    var
     include=
      [0,
       Unix_error,
       error_message,
       handle_unix_error,
       environment,
       _x_,
       getenv,
       unsafe_getenv,
       putenv,
       execv,
       execve,
       execvp,
       execvpe,
       fork,
       wait,
       waitpid,
       system,
       getpid,
       getppid,
       nice,
       stdin,
       stdout,
       stderr,
       openfile,
       close,
       read,
       write,
       single_write,
       write_substring,
       single_write_substring,
       in_channel_of_descr,
       out_channel_of_descr,
       descr_of_in_channel,
       descr_of_out_channel,
       lseek,
       truncate,
       ftruncate,
       stat,
       lstat,
       fstat,
       isatty,
       LargeFile,
       map_file,
       unlink,
       rename,
       link,
       chmod,
       fchmod,
       chown,
       fchown,
       umask,
       access,
       dup,
       dup2,
       set_nonblock,
       clear_nonblock,
       set_close_on_exec,
       clear_close_on_exec,
       mkdir,
       rmdir,
       chdir,
       getcwd,
       chroot,
       opendir,
       readdir,
       rewinddir,
       closedir,
       pipe,
       mkfifo,
       create_process,
       create_process_env,
       open_process_in,
       open_process_out,
       open_process,
       open_process_full,
       close_process_in,
       close_process_out,
       close_process,
       close_process_full,
       symlink,
       has_symlink,
       readlink,
       select,
       lockf,
       kill,
       sigprocmask,
       sigpending,
       sigsuspend,
       pause,
       time,
       gettimeofday,
       gmtime,
       localtime,
       mktime,
       alarm,
       sleep,
       _r_,
       times,
       utimes,
       getitimer,
       setitimer,
       getuid,
       geteuid,
       setuid,
       getgid,
       getegid,
       setgid,
       getgroups,
       setgroups,
       initgroups,
       getlogin,
       getpwnam,
       getgrnam,
       getpwuid,
       getgrgid,
       inet_addr_of_string,
       string_of_inet_addr,
       inet_addr_any,
       inet_addr_loopback,
       inet_addr_any$0,
       inet6_addr_loopback,
       socket,
       domain_of_sockaddr,
       socketpair,
       accept,
       bind,
       connect,
       listen,
       shutdown,
       getsockname,
       getpeername,
       recv,
       recvfrom,
       send,
       send_substring,
       sendto,
       sendto_substring,
       getsockopt,
       setsockopt,
       getsockopt_int,
       setsockopt_int,
       getsockopt_optint,
       setsockopt_optint,
       getsockopt_float,
       setsockopt_float,
       getsockopt_error,
       open_connection,
       shutdown_connection,
       establish_server,
       gethostname,
       gethostbyname,
       gethostbyaddr,
       getprotobyname,
       getprotobynumber,
       getservbyname,
       getservbyport,
       getaddrinfo,
       getnameinfo,
       tcgetattr,
       tcsetattr,
       tcsendbreak,
       tcdrain,
       tcflush,
       tcflow,
       setsid];
    caml_register_global(146,include,"Unix");
    var
     UnixLabels=
      [0,
       Unix_error,
       error_message,
       handle_unix_error,
       environment,
       getenv,
       unsafe_getenv,
       putenv,
       execv,
       execve,
       execvp,
       execvpe,
       fork,
       wait,
       waitpid,
       system,
       getpid,
       getppid,
       nice,
       stdin,
       stdout,
       stderr,
       openfile,
       close,
       read,
       write,
       single_write,
       write_substring,
       single_write_substring,
       in_channel_of_descr,
       out_channel_of_descr,
       descr_of_in_channel,
       descr_of_out_channel,
       lseek,
       truncate,
       ftruncate,
       stat,
       lstat,
       fstat,
       isatty,
       LargeFile,
       map_file,
       unlink,
       rename,
       link,
       chmod,
       fchmod,
       chown,
       fchown,
       umask,
       access,
       dup,
       dup2,
       set_nonblock,
       clear_nonblock,
       set_close_on_exec,
       clear_close_on_exec,
       mkdir,
       rmdir,
       chdir,
       getcwd,
       chroot,
       opendir,
       readdir,
       rewinddir,
       closedir,
       pipe,
       mkfifo,
       create_process,
       create_process_env,
       open_process_in,
       open_process_out,
       open_process,
       open_process_full,
       close_process_in,
       close_process_out,
       close_process,
       close_process_full,
       symlink,
       has_symlink,
       readlink,
       select,
       lockf,
       kill,
       sigprocmask,
       sigpending,
       sigsuspend,
       pause,
       time,
       gettimeofday,
       gmtime,
       localtime,
       mktime,
       alarm,
       sleep,
       times,
       utimes,
       getitimer,
       setitimer,
       getuid,
       geteuid,
       setuid,
       getgid,
       getegid,
       setgid,
       getgroups,
       setgroups,
       initgroups,
       getlogin,
       getpwnam,
       getgrnam,
       getpwuid,
       getgrgid,
       inet_addr_of_string,
       string_of_inet_addr,
       inet_addr_any,
       inet_addr_loopback,
       inet_addr_any$0,
       inet6_addr_loopback,
       socket,
       domain_of_sockaddr,
       socketpair,
       accept,
       bind,
       connect,
       listen,
       shutdown,
       getsockname,
       getpeername,
       recv,
       recvfrom,
       send,
       send_substring,
       sendto,
       sendto_substring,
       getsockopt,
       setsockopt,
       getsockopt_int,
       setsockopt_int,
       getsockopt_optint,
       setsockopt_optint,
       getsockopt_float,
       setsockopt_float,
       getsockopt_error,
       open_connection,
       shutdown_connection,
       establish_server,
       gethostname,
       gethostbyname,
       gethostbyaddr,
       getprotobyname,
       getprotobynumber,
       getservbyname,
       getservbyport,
       getaddrinfo,
       getnameinfo,
       tcgetattr,
       tcsetattr,
       tcsendbreak,
       tcdrain,
       tcflush,
       tcflow,
       setsid];
    caml_register_global(147,UnixLabels,"UnixLabels");
    return}
  (function(){return this}()));


//# 1 "../.js/str/str.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_bytes_get=runtime.caml_bytes_get,
     caml_bytes_set=runtime.caml_bytes_set,
     caml_check_bound=runtime.caml_check_bound,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_make_vect=runtime.caml_make_vect,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_new_string=runtime.caml_new_string,
     caml_string_equal=runtime.caml_string_equal,
     caml_string_get=runtime.caml_string_get,
     caml_trampoline=runtime.caml_trampoline,
     caml_trampoline_return=runtime.caml_trampoline_return,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst=caml_new_string(""),
     cst$0=caml_new_string(""),
     cst$5=caml_new_string(""),
     cst$4=caml_new_string(""),
     cst$3=caml_new_string(""),
     cst_Str_matched_group=caml_new_string("Str.matched_group"),
     cst_Str_group_end=caml_new_string("Str.group_end"),
     cst_Str_group_beginning=caml_new_string("Str.group_beginning"),
     cst_group_not_closed_by=caml_new_string("\\( group not closed by \\)"),
     cst_class_not_closed_by=caml_new_string("[ class not closed by ]"),
     cst_spurious_in_regular_expression=
      caml_new_string("spurious \\) in regular expression"),
     cst_too_many_r_or_r_where_r_is_nullable=
      caml_new_string("too many r* or r+ where r is nullable"),
     cst$1=caml_new_string(""),
     cst$2=caml_new_string(""),
     List=global_data.List,
     String=global_data.String,
     Not_found=global_data.Not_found,
     Pervasives=global_data.Pervasives,
     Bytes=global_data.Bytes,
     Assert_failure=global_data.Assert_failure,
     Buffer=global_data.Buffer,
     Char=global_data.Char,
     Array=global_data.Array,
     Map=global_data.Map,
     _b_=[0,92],
     _c_=[0,caml_new_string("str.ml"),520,10],
     _a_=[0,caml_new_string("str.ml"),213,11];
    function string_before(s,n){return caml_call3(String[4],s,0,n)}
    function string_after(s,n)
     {return caml_call3(String[4],s,n,caml_ml_string_length(s) - n | 0)}
    function first_chars(s,n){return caml_call3(String[4],s,0,n)}
    function last_chars(s,n)
     {return caml_call3(String[4],s,caml_ml_string_length(s) - n | 0,n)}
    var full=caml_call2(Bytes[1],32,255);
    function make_empty(param){return caml_call2(Bytes[1],32,0)}
    function add(s,i)
     {var _ao_=caml_bytes_get(s,i >>> 3 | 0) | 1 << (i & 7);
      return caml_bytes_set(s,i >>> 3 | 0,caml_call1(Char[1],_ao_))}
    function singleton(c){var s=make_empty(0);add(s,c);return s}
    function complement(s)
     {var r=caml_create_bytes(32),i=0;
      for(;;)
       {var _am_=caml_bytes_get(s,i) ^ 255;
        caml_bytes_set(r,i,caml_call1(Char[1],_am_));
        var _an_=i + 1 | 0;
        if(31 !== i){var i=_an_;continue}
        return r}}
    function union(s1,s2)
     {var r=caml_create_bytes(32),i=0;
      for(;;)
       {var _aj_=caml_bytes_get(s2,i),_ak_=caml_bytes_get(s1,i) | _aj_;
        caml_bytes_set(r,i,caml_call1(Char[1],_ak_));
        var _al_=i + 1 | 0;
        if(31 !== i){var i=_al_;continue}
        return r}}
    function disjoint(s1,s2)
     {try
       {var i=0;
        for(;;)
         {var _ag_=caml_bytes_get(s2,i);
          if(0 !== (caml_bytes_get(s1,i) & _ag_))throw Pervasives[3];
          var _ah_=i + 1 | 0;
          if(31 !== i){var i=_ah_;continue}
          var _af_=1;
          return _af_}}
      catch(_ai_)
       {_ai_ = caml_wrap_exception(_ai_);
        if(_ai_ === Pervasives[3])return 0;
        throw _ai_}}
    function iter(fn,s)
     {var i=0;
      for(;;)
       {var c=caml_bytes_get(s,i);
        if(0 !== c)
         {var j=0;
          for(;;)
           {if(0 !== (c & 1 << j))
             caml_call1(fn,caml_call1(Char[1],(i << 3) + j | 0));
            var _ae_=j + 1 | 0;
            if(7 !== j){var j=_ae_;continue}
            break}}
        var _ad_=i + 1 | 0;
        if(31 !== i){var i=_ad_;continue}
        return 0}}
    function fold_case(s)
     {var r=make_empty(0);
      iter
       (function(c)
         {add(r,caml_call1(Char[3],c));return add(r,caml_call1(Char[4],c))},
        s);
      return r}
    var
     op_CHAR=0,
     op_CHARNORM=1,
     op_STRING=2,
     op_STRINGNORM=3,
     op_CHARCLASS=4,
     op_BOL=5,
     op_EOL=6,
     op_WORDBOUNDARY=7,
     op_BEGGROUP=8,
     op_ENDGROUP=9,
     op_REFGROUP=10,
     op_ACCEPT=11,
     op_SIMPLEOPT=12,
     op_SIMPLESTAR=13,
     op_SIMPLEPLUS=14,
     op_GOTO=15,
     op_PUSHBACK=16,
     op_SETMARK=17,
     op_CHECKPROGRESS=18;
    function instr(opc,arg){return opc | arg << 8}
    function displ(dest,from){return (dest - from | 0) - 1 | 0}
    function is_nullable(param)
     {var param$0=param;
      for(;;)
       if(typeof param$0 === "number")
        switch(param$0){case 0:return 1;case 1:return 1;default:return 1}
       else
        switch(param$0[0])
         {case 0:return 0;
          case 1:var s=param$0[1];return caml_string_equal(s,cst);
          case 2:return 0;
          case 3:var rl=param$0[1];return caml_call2(List[27],is_nullable,rl);
          case 4:
           var r2=param$0[2],r1=param$0[1],_ac_=is_nullable(r1);
           if(_ac_)return _ac_;
           var param$0=r2;
           continue;
          case 5:return 1;
          case 6:var param$1=param$0[1],param$0=param$1;continue;
          case 7:return 1;
          case 8:var param$2=param$0[2],param$0=param$2;continue;
          default:return 1}}
    function first$0(counter,param)
     {var param$0=param;
      for(;;)
       if(typeof param$0 === "number")
        switch(param$0)
         {case 0:return full;case 1:return full;default:return full}
       else
        switch(param$0[0])
         {case 0:var c=param$0[1];return singleton(c);
          case 1:
           var s=param$0[1];
           return caml_string_equal(s,cst$0)
                   ?full
                   :singleton(caml_string_get(s,0));
          case 2:
           var cmpl=param$0[2],cl=param$0[1];return cmpl?complement(cl):cl;
          case 3:
           var rl=param$0[1];
           if(counter < 50)
            {var counter$0=counter + 1 | 0;return first_seq$0(counter$0,rl)}
           return caml_trampoline_return(first_seq$0,[0,rl]);
          case 4:
           var r2=param$0[2],r1=param$0[1],_ab_=first(r2);
           return union(first(r1),_ab_);
          case 5:return full;
          case 6:var param$1=param$0[1],param$0=param$1;continue;
          case 7:return full;
          case 8:var param$2=param$0[2],param$0=param$2;continue;
          default:return full}}
    function first_seq$0(counter,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var ___=param$0[1];
          if(typeof ___ === "number")
           {var param$1=param$0[2],param$0=param$1;continue}
          else
           switch(___[0])
            {case 5:
              var rl=param$0[2],r=___[1],_$_=first_seq(rl);
              return union(first(r),_$_);
             case 7:
              var rl$0=param$0[2],r$0=___[1],_aa_=first_seq(rl$0);
              return union(first(r$0),_aa_);
             default:
              if(counter < 50)
               {var counter$0=counter + 1 | 0;return first$0(counter$0,___)}
              return caml_trampoline_return(first$0,[0,___])}}
        return full}}
    function first(param){return caml_trampoline(first$0(0,param))}
    function first_seq(param){return caml_trampoline(first_seq$0(0,param))}
    function charclass_of_regexp(fold_case$0,re)
     {if(typeof re === "number")
       var switch$0=0;
      else
       switch(re[0])
        {case 0:var c=re[1],match=[0,singleton(c),0],switch$0=1;break;
         case 2:
          var compl$0=re[2],cl=re[1],match=[0,cl,compl$0],switch$0=1;break;
         default:var switch$0=0}
      if(switch$0)
       {var
         compl=match[2],
         cl1=match[1],
         cl2=fold_case$0?fold_case(cl1):cl1,
         _Z_=compl?complement(cl2):cl2;
        return caml_call1(Bytes[6],_Z_)}
      throw [0,Assert_failure,_a_]}
    var t=caml_create_bytes(256),i=0;
    for(;;)
     {var _d_=caml_call1(Char[1],i);
      caml_bytes_set(t,i,caml_call1(Char[3],_d_));
      var _e_=i + 1 | 0;
      if(255 !== i){var i=_e_;continue}
      var
       fold_case_table=caml_call1(Bytes[6],t),
       compare=runtime.caml_string_compare,
       StringMap=caml_call1(Map[1],[0,compare]),
       compile=
        function(fold_case$0,re)
         {var
           prog=[0,caml_make_vect(32,0)],
           progpos=[0,0],
           cpool=[0,StringMap[1]],
           cpoolpos=[0,0],
           numgroups=[0,1],
           numregs=[0,0];
          function emit_instr(opc,arg)
           {if(prog[1].length - 1 <= progpos[1])
             {var newlen=[0,prog[1].length - 1];
              for(;;)
               {if(newlen[1] <= progpos[1])
                 {newlen[1] = newlen[1] * 2 | 0;continue}
                var nprog=caml_make_vect(newlen[1],0);
                caml_call5(Array[10],prog[1],0,nprog,0,prog[1].length - 1);
                prog[1] = nprog;
                break}}
            var _X_=instr(opc,arg),_Y_=progpos[1];
            caml_check_bound(prog[1],_Y_)[1 + _Y_] = _X_;
            progpos[1]++;
            return 0}
          function emit_hole(param)
           {var p=progpos[1];emit_instr(op_CHAR,0);return p}
          function patch_instr(pos,opc,dest)
           {var _W_=instr(opc,displ(dest,pos));
            caml_check_bound(prog[1],pos)[1 + pos] = _W_;
            return 0}
          function cpool_index(s)
           {try
             {var _U_=caml_call2(StringMap[27],s,cpool[1]);return _U_}
            catch(_V_)
             {_V_ = caml_wrap_exception(_V_);
              if(_V_ === Not_found)
               {var p=cpoolpos[1];
                cpool[1] = caml_call3(StringMap[4],s,p,cpool[1]);
                cpoolpos[1]++;
                return p}
              throw _V_}}
          function allocate_register_if_nullable(r)
           {if(is_nullable(r))
             {var n=numregs[1];
              if(64 <= n)
               caml_call1
                (Pervasives[2],cst_too_many_r_or_r_where_r_is_nullable);
              numregs[1]++;
              return n}
            return -1}
          function emit_seq_code(param)
           {var param$0=param;
            for(;;)
             {if(param$0)
               {var _N_=param$0[1];
                if(typeof _N_ !== "number")
                 switch(_N_[0])
                  {case 5:
                    var _O_=_N_[1];
                    if(typeof _O_ === "number")
                     var switch$0=0;
                    else
                     switch(_O_[0])
                      {case 0:
                       case 2:
                        var rl$0=param$0[2],_P_=first_seq(rl$0);
                        if(disjoint_modulo_case(first(_O_),_P_))
                         {emit_instr
                           (op_SIMPLESTAR,
                            cpool_index(charclass_of_regexp(fold_case$0,_O_)));
                          var param$0=rl$0;
                          continue}
                        var switch$0=1;
                        break;
                       default:var switch$0=0}
                    break;
                   case 6:
                    var _Q_=_N_[1];
                    if(typeof _Q_ === "number")
                     var switch$1=0;
                    else
                     switch(_Q_[0])
                      {case 0:
                       case 2:
                        var rl$1=param$0[2],_R_=first_seq(rl$1);
                        if(disjoint_modulo_case(first(_Q_),_R_))
                         {emit_instr
                           (op_SIMPLEPLUS,
                            cpool_index(charclass_of_regexp(fold_case$0,_Q_)));
                          var param$0=rl$1;
                          continue}
                        var switch$1=1;
                        break;
                       default:var switch$1=0}
                    break;
                   case 7:
                    var _S_=_N_[1];
                    if(typeof _S_ === "number")
                     var switch$2=0;
                    else
                     switch(_S_[0])
                      {case 0:
                       case 2:
                        var rl$2=param$0[2],_T_=first_seq(rl$2);
                        if(disjoint_modulo_case(first(_S_),_T_))
                         {emit_instr
                           (op_SIMPLEOPT,
                            cpool_index(charclass_of_regexp(fold_case$0,_S_)));
                          var param$0=rl$2;
                          continue}
                        var switch$2=1;
                        break;
                       default:var switch$2=0}
                    break
                   }
                var rl=param$0[2];
                emit_code(_N_);
                var param$0=rl;
                continue}
              return 0}}
          function emit_code(param)
           {if(typeof param === "number")
             switch(param)
              {case 0:return emit_instr(op_BOL,0);
               case 1:return emit_instr(op_EOL,0);
               default:return emit_instr(op_WORDBOUNDARY,0)}
            else
             switch(param[0])
              {case 0:
                var c=param[1];
                return fold_case$0
                        ?emit_instr(op_CHARNORM,caml_call1(Char[3],c))
                        :emit_instr(op_CHAR,c);
               case 1:
                var s=param[1],match=caml_ml_string_length(s);
                if(0 === match)return 0;
                if(1 === match)
                 {if(fold_case$0)
                   {var _K_=caml_string_get(s,0);
                    return emit_instr(op_CHARNORM,caml_call1(Char[3],_K_))}
                  return emit_instr(op_CHAR,caml_string_get(s,0))}
                try
                 {var i=caml_call2(String[14],s,0);
                  emit_code([1,string_before(s,i)]);
                  emit_instr(op_CHAR,0);
                  var _L_=emit_code([1,string_after(s,i + 1 | 0)]);
                  return _L_}
                catch(_M_)
                 {_M_ = caml_wrap_exception(_M_);
                  if(_M_ === Not_found)
                   return fold_case$0
                           ?emit_instr
                             (op_STRINGNORM,cpool_index(caml_call1(String[26],s)))
                           :emit_instr(op_STRING,cpool_index(s));
                  throw _M_}
               case 2:
                var
                 compl=param[2],
                 cl=param[1],
                 cl1=fold_case$0?fold_case(cl):cl,
                 cl2=compl?complement(cl1):cl1;
                return emit_instr
                        (op_CHARCLASS,cpool_index(caml_call1(Bytes[6],cl2)));
               case 3:var rl=param[1];return emit_seq_code(rl);
               case 4:
                var r2=param[2],r1=param[1],pos_pushback=emit_hole(0);
                emit_code(r1);
                var pos_goto_end=emit_hole(0),lbl1=progpos[1];
                emit_code(r2);
                var lbl2=progpos[1];
                patch_instr(pos_pushback,op_PUSHBACK,lbl1);
                return patch_instr(pos_goto_end,op_GOTO,lbl2);
               case 5:
                var
                 r=param[1],
                 regno=allocate_register_if_nullable(r),
                 lbl1$0=emit_hole(0);
                if(0 <= regno)emit_instr(op_SETMARK,regno);
                emit_code(r);
                if(0 <= regno)emit_instr(op_CHECKPROGRESS,regno);
                emit_instr(op_GOTO,displ(lbl1$0,progpos[1]));
                var lbl2$0=progpos[1];
                return patch_instr(lbl1$0,op_PUSHBACK,lbl2$0);
               case 6:
                var
                 r$0=param[1],
                 regno$0=allocate_register_if_nullable(r$0),
                 lbl1$1=progpos[1];
                emit_code(r$0);
                if(0 <= regno$0)emit_instr(op_CHECKPROGRESS,regno$0);
                var pos_pushback$0=emit_hole(0);
                if(0 <= regno$0)emit_instr(op_SETMARK,regno$0);
                emit_instr(op_GOTO,displ(lbl1$1,progpos[1]));
                var lbl2$1=progpos[1];
                return patch_instr(pos_pushback$0,op_PUSHBACK,lbl2$1);
               case 7:
                var r$1=param[1],pos_pushback$1=emit_hole(0);
                emit_code(r$1);
                var lbl=progpos[1];
                return patch_instr(pos_pushback$1,op_PUSHBACK,lbl);
               case 8:
                var r$2=param[2],n=param[1];
                emit_instr(op_BEGGROUP,n);
                emit_code(r$2);
                emit_instr(op_ENDGROUP,n);
                numgroups[1]
                =
                caml_call2(Pervasives[5],numgroups[1],n + 1 | 0);
                return 0;
               default:
                var n$0=param[1];
                emit_instr(op_REFGROUP,n$0);
                numgroups[1]
                =
                caml_call2(Pervasives[5],numgroups[1],n$0 + 1 | 0);
                return 0}}
          function disjoint_modulo_case(c1,c2)
           {if(fold_case$0)
             {var _J_=fold_case(c2);return disjoint(fold_case(c1),_J_)}
            return disjoint(c1,c2)}
          emit_code(re);
          emit_instr(op_ACCEPT,0);
          var start=first(re),start$0=fold_case$0?fold_case(start):start;
          if(runtime.caml_bytes_equal(start,full))
           var start_pos=-1;
          else
           {var r=caml_call2(Bytes[1],256,0);
            iter(function(c){return caml_bytes_set(r,c,1)},start$0);
            var start_pos=cpool_index(caml_call1(Bytes[6],r))}
          var constantpool=caml_make_vect(cpoolpos[1],cst$1),_F_=cpool[1];
          function _G_(str,idx)
           {caml_check_bound(constantpool,idx)[1 + idx] = str;return 0}
          caml_call2(StringMap[12],_G_,_F_);
          var
           _H_=numregs[1],
           _I_=numgroups[1],
           fold_case_table$0=fold_case$0?fold_case_table:cst$2;
          return [0,
                  caml_call3(Array[7],prog[1],0,progpos[1]),
                  constantpool,
                  fold_case_table$0,
                  _I_,
                  _H_,
                  start_pos]},
       flush=
        function(buf)
         {var s=caml_call1(Buffer[2],buf[1]);
          caml_call1(Buffer[8],buf[1]);
          var match=caml_ml_string_length(s);
          if(0 === match)return 0;
          if(1 === match)
           {var _E_=buf[2];buf[2] = [0,[0,caml_string_get(s,0)],_E_];return 0}
          buf[2] = [0,[1,s],buf[2]];
          return 0},
       dotclass=complement(singleton(10)),
       parse=
        function(s)
         {var len=caml_ml_string_length(s),group_counter=[0,1];
          function regexp0(i)
           {var match=regexp1(i),j=match[2],r=match[1],r1=r,i$0=j;
            for(;;)
             {if((i$0 + 2 | 0) <= len)
               if(92 === caml_string_get(s,i$0))
                if(124 === caml_string_get(s,i$0 + 1 | 0))
                 {var
                   match$0=regexp1(i$0 + 2 | 0),
                   i$1=match$0[2],
                   r2=match$0[1],
                   r1$0=[4,r1,r2],
                   r1=r1$0,
                   i$0=i$1;
                  continue}
              return [0,r1,i$0]}}
          function regexp1(i)
           {var sb=[0,caml_call1(Buffer[1],16),0],i$0=i;
            a:
            for(;;)
             {if(! (len <= i$0))
               {if((i$0 + 2 | 0) <= len)
                 if(92 === caml_string_get(s,i$0))
                  var
                   c$0=caml_string_get(s,i$0 + 1 | 0),
                   _B_=124 === c$0?1:0,
                   _C_=_B_ || (41 === c$0?1:0),
                   switch$0=_C_?0:1;
                 else
                  var switch$0=1;
                else
                 var switch$0=1;
                if(switch$0)
                 {var c$1=caml_string_get(s,i$0);
                  if(36 === c$1)
                   var match=[0,1,i$0 + 1 | 0];
                  else
                   {if(91 <= c$1)
                     if(95 <= c$1)
                      var switch$1=0;
                     else
                      {var switcher$0=c$1 - 91 | 0;
                       switch(switcher$0)
                        {case 0:
                          var i$4=i$0 + 1 | 0;
                          if(i$4 < len)
                           if(94 === caml_string_get(s,i$4))
                            var
                             match$3=regexpclass1(i$4 + 1 | 0),
                             j$3=match$3[2],
                             c$4=match$3[1],
                             match$1=[0,c$4,1,j$3],
                             switch$2=1;
                           else
                            var switch$2=0;
                          else
                           var switch$2=0;
                          if(! switch$2)
                           var
                            match$4=regexpclass1(i$4),
                            j$4=match$4[2],
                            c$5=match$4[1],
                            match$1=[0,c$5,0,j$4];
                          var
                           j$1=match$1[3],
                           compl=match$1[2],
                           c$2=match$1[1],
                           match=[0,[2,c$2,compl],j$1],
                           switch$1=1;
                          break;
                         case 1:
                          var i$5=i$0 + 1 | 0;
                          if(len <= i$5)
                           var _D_=[0,_b_,i$5];
                          else
                           {var c$3=caml_string_get(s,i$5);
                            if(58 <= c$3)
                             if(98 === c$3)
                              var _D_=[0,2,i$5 + 1 | 0],switch$3=2;
                             else
                              var switch$3=124 === c$3?1:0;
                            else
                             {var switcher$1=c$3 - 40 | 0;
                              if(1 < switcher$1 >>> 0)
                               if(9 <= switcher$1)
                                var _D_=[0,[9,c$3 - 48 | 0],i$5 + 1 | 0],switch$3=2;
                               else
                                var switch$3=0;
                              else
                               if(0 === switcher$1)
                                {var group_no=group_counter[1];
                                 group_counter[1]++;
                                 var
                                  match$2=regexp0(i$5 + 1 | 0),
                                  j$2=match$2[2],
                                  r$4=match$2[1];
                                 if((j$2 + 1 | 0) < len)
                                  if(92 === caml_string_get(s,j$2))
                                   if(41 === caml_string_get(s,j$2 + 1 | 0))
                                    var
                                     _D_=[0,[8,group_no,r$4],j$2 + 2 | 0],
                                     switch$3=2,
                                     switch$4=0;
                                   else
                                    var switch$4=1;
                                  else
                                   var switch$4=1;
                                 else
                                  var switch$4=1;
                                 if(switch$4)
                                  var
                                   _D_=caml_call1(Pervasives[2],cst_group_not_closed_by),
                                   switch$3=2}
                               else
                                var switch$3=1}
                            switch(switch$3)
                             {case 0:var _D_=[0,[0,c$3],i$5 + 1 | 0];break;
                              case 1:throw [0,Assert_failure,_c_]
                              }}
                          var match=_D_,switch$1=1;
                          break;
                         case 2:var switch$1=0;break;
                         default:var match=[0,0,i$0 + 1 | 0],switch$1=1}}
                    else
                     if(46 === c$1)
                      var match=[0,[2,dotclass,0],i$0 + 1 | 0],switch$1=1;
                     else
                      var switch$1=0;
                    if(! switch$1)var match=[0,[0,c$1],i$0 + 1 | 0]}
                  var j=match[2],r=match[1],r$0=r,j$0=j;
                  for(;;)
                   {if(! (len <= j$0))
                     {var
                       match$0=caml_string_get(s,j$0),
                       switcher=match$0 - 42 | 0;
                      if(! (1 < switcher >>> 0))
                       {if(0 === switcher)
                         {var i$2=j$0 + 1 | 0,r$2=[5,r$0],r$0=r$2,j$0=i$2;continue}
                        var i$3=j$0 + 1 | 0,r$3=[6,r$0],r$0=r$3,j$0=i$3;
                        continue}
                      if(21 === switcher)
                       {var i$1=j$0 + 1 | 0,r$1=[7,r$0],r$0=r$1,j$0=i$1;continue}}
                    if(typeof r$0 === "number")
                     var switch$5=0;
                    else
                     if(0 === r$0[0])
                      {var c=r$0[1];caml_call2(Buffer[10],sb[1],c);var switch$5=1}
                     else
                      var switch$5=0;
                    if(! switch$5){flush(sb);sb[2] = [0,r$0,sb[2]]}
                    var i$0=j$0;
                    continue a}}}
              flush(sb);
              return [0,[3,caml_call1(List[9],sb[2])],i$0]}}
          function regexpclass1(start)
           {var c=make_empty(0),i$0=start;
            for(;;)
             {if(len <= i$0)caml_call1(Pervasives[2],cst_class_not_closed_by);
              if(93 === caml_string_get(s,i$0))
               if(start < i$0){var j=i$0 + 1 | 0;return [0,c,j]}
              var c1=caml_string_get(s,i$0);
              if((i$0 + 2 | 0) < len)
               if(45 === caml_string_get(s,i$0 + 1 | 0))
                if(93 !== caml_string_get(s,i$0 + 2 | 0))
                 {var c2=caml_string_get(s,i$0 + 2 | 0);
                  if(! (c2 < c1))
                   {var i=c1;
                    for(;;)
                     {add(c,caml_call1(Char[1],i));
                      var _A_=i + 1 | 0;
                      if(c2 !== i){var i=_A_;continue}
                      break}}
                  var i$2=i$0 + 3 | 0,i$0=i$2;
                  continue}
              add(c,c1);
              var i$1=i$0 + 1 | 0,i$0=i$1;
              continue}}
          var match=regexp0(0),j=match[2],r=match[1];
          return j === len
                  ?r
                  :caml_call1
                    (Pervasives[2],cst_spurious_in_regular_expression)},
       regexp=function(e){return compile(0,parse(e))},
       regexp_case_fold=function(e){return compile(1,parse(e))},
       quote=
        function(s)
         {var
           len=caml_ml_string_length(s),
           buf=caml_create_bytes(2 * len | 0),
           pos=[0,0],
           _w_=len - 1 | 0,
           _v_=0;
          if(! (_w_ < 0))
           {var i=_v_;
            for(;;)
             {var c=caml_string_get(s,i),_x_=c - 63 | 0;
              if(31 < _x_ >>> 0)
               {var _y_=_x_ + 27 | 0;
                if(10 < _y_ >>> 0)
                 var switch$0=0;
                else
                 switch(_y_)
                  {case 0:
                   case 6:
                   case 7:
                   case 10:var switch$0=1;break;
                   default:var switch$0=0}}
              else
               var switch$0=26 < (_x_ - 1 | 0) >>> 0?1:0;
              if(switch$0)
               {caml_bytes_set(buf,pos[1],92);
                caml_bytes_set(buf,pos[1] + 1 | 0,c);
                pos[1] = pos[1] + 2 | 0}
              else
               {caml_bytes_set(buf,pos[1],c);pos[1] = pos[1] + 1 | 0}
              var _z_=i + 1 | 0;
              if(_w_ !== i){var i=_z_;continue}
              break}}
          return caml_call3(Bytes[8],buf,0,pos[1])},
       regexp_string=function(s){return compile(0,[1,s])},
       regexp_string_case_fold=function(s){return compile(1,[1,s])},
       last_search_result=[0,[0]],
       string_match=
        function(re,s,pos)
         {var res=runtime.re_string_match(re,s,pos);
          last_search_result[1] = res;
          return 0 < res.length - 1?1:0},
       string_partial_match=
        function(re,s,pos)
         {var res=runtime.re_partial_match(re,s,pos);
          last_search_result[1] = res;
          return 0 < res.length - 1?1:0},
       search_forward=
        function(re,s,pos)
         {var res=runtime.re_search_forward(re,s,pos);
          last_search_result[1] = res;
          if(0 === res.length - 1)throw Not_found;
          return caml_check_bound(res,0)[1]},
       search_backward=
        function(re,s,pos)
         {var res=runtime.re_search_backward(re,s,pos);
          last_search_result[1] = res;
          if(0 === res.length - 1)throw Not_found;
          return caml_check_bound(res,0)[1]},
       group_beginning=
        function(n)
         {var n2=n + n | 0;
          if(0 <= n)
           if(! (last_search_result[1].length - 1 <= n2))
            {var pos=caml_check_bound(last_search_result[1],n2)[1 + n2];
             if(-1 === pos)throw Not_found;
             return pos}
          return caml_call1(Pervasives[1],cst_Str_group_beginning)},
       group_end=
        function(n)
         {var n2=n + n | 0;
          if(0 <= n)
           if(! (last_search_result[1].length - 1 <= n2))
            {var
              _u_=n2 + 1 | 0,
              pos=caml_check_bound(last_search_result[1],_u_)[1 + _u_];
             if(-1 === pos)throw Not_found;
             return pos}
          return caml_call1(Pervasives[1],cst_Str_group_end)},
       matched_group=
        function(n,txt)
         {var n2=n + n | 0;
          if(0 <= n)
           if(! (last_search_result[1].length - 1 <= n2))
            {var
              b=caml_check_bound(last_search_result[1],n2)[1 + n2],
              _t_=n2 + 1 | 0,
              e=caml_check_bound(last_search_result[1],_t_)[1 + _t_];
             if(-1 === b)throw Not_found;
             return caml_call3(String[4],txt,b,e - b | 0)}
          return caml_call1(Pervasives[1],cst_Str_matched_group)},
       match_beginning=function(param){return group_beginning(0)},
       match_end=function(param){return group_end(0)},
       matched_string=function(txt){return matched_group(0,txt)},
       replace_matched=
        function(repl,matched)
         {return runtime.re_replacement_text
                  (repl,last_search_result[1],matched)},
       substitute_first=
        function(expr,repl_fun,text)
         {try
           {var
             pos=search_forward(expr,text,0),
             _o_=[0,string_after(text,match_end(0)),0],
             _p_=[0,caml_call1(repl_fun,text),_o_],
             _q_=[0,string_before(text,pos),_p_],
             _r_=caml_call2(String[7],cst$3,_q_);
            return _r_}
          catch(_s_)
           {_s_ = caml_wrap_exception(_s_);
            if(_s_ === Not_found)return text;
            throw _s_}},
       opt_search_forward=
        function(re,s,pos)
         {try
           {var _m_=[0,search_forward(re,s,pos)];return _m_}
          catch(_n_)
           {_n_ = caml_wrap_exception(_n_);
            if(_n_ === Not_found)return 0;
            throw _n_}},
       global_substitute=
        function(expr,repl_fun,text)
         {var accu=0,start=0,last_was_empty=0;
          for(;;)
           {var startpos=last_was_empty?start + 1 | 0:start;
            if(caml_ml_string_length(text) < startpos)
             var _k_=[0,string_after(text,start),accu];
            else
             {var match=opt_search_forward(expr,text,startpos);
              if(match)
               {var
                 pos=match[1],
                 start$0=match_end(0),
                 repl_text=caml_call1(repl_fun,text),
                 last_was_empty$0=start$0 === pos?1:0,
                 accu$0=
                  [0,
                   repl_text,
                   [0,caml_call3(String[4],text,start,pos - start | 0),accu]],
                 accu=accu$0,
                 start=start$0,
                 last_was_empty=last_was_empty$0;
                continue}
              var _k_=[0,string_after(text,start),accu]}
            var _l_=caml_call1(List[9],_k_);
            return caml_call2(String[7],cst$4,_l_)}},
       global_replace=
        function(expr,repl,text)
         {return global_substitute
                  (expr,function(_j_){return replace_matched(repl,_j_)},text)},
       replace_first=
        function(expr,repl,text)
         {return substitute_first
                  (expr,function(_i_){return replace_matched(repl,_i_)},text)},
       opt_search_forward_progress=
        function(expr,text,start)
         {var match=opt_search_forward(expr,text,start);
          if(match)
           {var pos=match[1];
            return start < match_end(0)
                    ?[0,pos]
                    :start < caml_ml_string_length(text)
                      ?opt_search_forward(expr,text,start + 1 | 0)
                      :0}
          return 0},
       bounded_split=
        function(expr,text,num)
         {var
           start=string_match(expr,text,0)?match_end(0):0,
           accu=0,
           start$0=start,
           n=num;
          for(;;)
           {if(caml_ml_string_length(text) <= start$0)
             var _h_=accu;
            else
             if(1 === n)
              var _h_=[0,string_after(text,start$0),accu];
             else
              {var match=opt_search_forward_progress(expr,text,start$0);
               if(match)
                {var
                  pos=match[1],
                  n$0=n - 1 | 0,
                  start$1=match_end(0),
                  accu$0=
                   [0,
                    caml_call3(String[4],text,start$0,pos - start$0 | 0),
                    accu],
                  accu=accu$0,
                  start$0=start$1,
                  n=n$0;
                 continue}
               var _h_=[0,string_after(text,start$0),accu]}
            return caml_call1(List[9],_h_)}},
       split=function(expr,text){return bounded_split(expr,text,0)},
       bounded_split_delim=
        function(expr,text,num)
         {if(caml_string_equal(text,cst$5))return 0;
          var accu=0,start=0,n=num;
          for(;;)
           {if(caml_ml_string_length(text) < start)
             var _g_=accu;
            else
             if(1 === n)
              var _g_=[0,string_after(text,start),accu];
             else
              {var match=opt_search_forward_progress(expr,text,start);
               if(match)
                {var
                  pos=match[1],
                  n$0=n - 1 | 0,
                  start$0=match_end(0),
                  accu$0=
                   [0,caml_call3(String[4],text,start,pos - start | 0),accu],
                  accu=accu$0,
                  start=start$0,
                  n=n$0;
                 continue}
               var _g_=[0,string_after(text,start),accu]}
            return caml_call1(List[9],_g_)}},
       split_delim=
        function(expr,text){return bounded_split_delim(expr,text,0)},
       bounded_full_split=
        function(expr,text,num)
         {var accu=0,start=0,n=num;
          for(;;)
           {if(caml_ml_string_length(text) <= start)
             var _f_=accu;
            else
             if(1 === n)
              var _f_=[0,[0,string_after(text,start)],accu];
             else
              {var match=opt_search_forward_progress(expr,text,start);
               if(match)
                {var pos=match[1],s=matched_string(text);
                 if(start < pos)
                  {var
                    n$0=n - 1 | 0,
                    start$0=match_end(0),
                    accu$0=
                     [0,
                      [1,s],
                      [0,
                       [0,caml_call3(String[4],text,start,pos - start | 0)],
                       accu]],
                    accu=accu$0,
                    start=start$0,
                    n=n$0;
                   continue}
                 var
                  n$1=n - 1 | 0,
                  start$1=match_end(0),
                  accu$1=[0,[1,s],accu],
                  accu=accu$1,
                  start=start$1,
                  n=n$1;
                 continue}
               var _f_=[0,[0,string_after(text,start)],accu]}
            return caml_call1(List[9],_f_)}},
       full_split=function(expr,text){return bounded_full_split(expr,text,0)},
       Str=
        [0,
         regexp,
         regexp_case_fold,
         quote,
         regexp_string,
         regexp_string_case_fold,
         string_match,
         search_forward,
         search_backward,
         string_partial_match,
         matched_string,
         match_beginning,
         match_end,
         matched_group,
         group_beginning,
         group_end,
         global_replace,
         replace_first,
         global_substitute,
         substitute_first,
         replace_matched,
         split,
         bounded_split,
         split_delim,
         bounded_split_delim,
         full_split,
         bounded_full_split,
         string_before,
         string_after,
         first_chars,
         last_chars];
      runtime.caml_register_global(27,Str,"Str");
      return}}
  (function(){return this}()));


//# 1 "../.js/menhirLib/menhirLib.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_bytes_set=runtime.caml_bytes_set,
     caml_bytes_unsafe_get=runtime.caml_bytes_unsafe_get,
     caml_check_bound=runtime.caml_check_bound,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_div=runtime.caml_div,
     caml_equal=runtime.caml_equal,
     caml_make_vect=runtime.caml_make_vect,
     caml_mod=runtime.caml_mod,
     caml_mul=runtime.caml_mul,
     caml_new_string=runtime.caml_new_string,
     caml_obj_tag=runtime.caml_obj_tag,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call7(f,a0,a1,a2,a3,a4,a5,a6)
     {return f.length == 7
              ?f(a0,a1,a2,a3,a4,a5,a6)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_feed_outgoing_transition_does_not_exist=
      caml_new_string("feed: outgoing transition does not exist"),
     cst_Current_LR_1_state=caml_new_string("Current LR(1) state: "),
     cst_some_initial_state=caml_new_string("<some initial state>"),
     arrow=caml_new_string(" -> "),
     dot=caml_new_string("."),
     space=caml_new_string(" "),
     newline=caml_new_string("\n"),
     cst_force_reduction_this_reduction_is_not_permitted_in_this_state=
      caml_new_string
       ("force_reduction: this reduction is not permitted in this state"),
     cst_resume_expects_HandlingError_Shifting_AboutToReduce=
      caml_new_string
       ("resume expects HandlingError | Shifting | AboutToReduce"),
     cst_offer_expects_InputNeeded=
      caml_new_string("offer expects InputNeeded"),
     cst=caml_new_string(""),
     Pervasives=global_data.Pervasives,
     Printf=global_data.Printf,
     Assert_failure=global_data.Assert_failure,
     List=global_data.List,
     Array=global_data.Array,
     Char=global_data.Char,
     Bytes=global_data.Bytes,
     Sys=global_data.Sys,
     Lexing=global_data.Lexing,
     CamlinternalLazy=global_data.CamlinternalLazy,
     _J_=
      [0,
       [11,
        caml_new_string("Handling error in state "),
        [4,0,0,0,[12,10,[10,0]]]],
       caml_new_string("Handling error in state %d\n%!")],
     _I_=
      [0,
       [11,caml_new_string("Resuming error handling\n"),[10,0]],
       caml_new_string("Resuming error handling\n%!")],
     _H_=
      [0,
       [11,caml_new_string("Initiating error handling\n"),[10,0]],
       caml_new_string("Initiating error handling\n%!")],
     _G_=
      [0,
       [11,
        caml_new_string("Lookahead token is now "),
        [2,
         0,
         [11,
          caml_new_string(" ("),
          [4,0,0,0,[12,45,[4,0,0,0,[11,caml_new_string(")\n"),[10,0]]]]]]]],
       caml_new_string("Lookahead token is now %s (%d-%d)\n%!")],
     _F_=[0,[2,0,[12,10,[10,0]]],caml_new_string("%s\n%!")],
     _E_=
      [0,
       [11,
        caml_new_string("Shifting ("),
        [2,0,[11,caml_new_string(") to state "),[4,0,0,0,[12,10,[10,0]]]]]],
       caml_new_string("Shifting (%s) to state %d\n%!")],
     _D_=
      [0,
       [11,
        caml_new_string("State "),
        [4,0,0,0,[11,caml_new_string(":\n"),[10,0]]]],
       caml_new_string("State %d:\n%!")],
     _C_=[0,caml_new_string("lib/pack/menhirLib.ml"),3408,4],
     _B_=[0,caml_new_string("lib/pack/menhirLib.ml"),3393,8],
     _A_=[0,caml_new_string("lib/pack/menhirLib.ml"),3347,4],
     _z_=[0,caml_new_string("lib/pack/menhirLib.ml"),3156,4],
     _y_=[0,caml_new_string("lib/pack/menhirLib.ml"),3069,4],
     _x_=[0,caml_new_string("lib/pack/menhirLib.ml"),3063,4],
     _w_=[0,caml_new_string("lib/pack/menhirLib.ml"),3044,4],
     _v_=[0,caml_new_string("lib/pack/menhirLib.ml"),2734,2],
     _u_=[0,caml_new_string("lib/pack/menhirLib.ml"),2730,2],
     _t_=[0,caml_new_string("lib/pack/menhirLib.ml"),2726,2],
     _s_=[0,caml_new_string("lib/pack/menhirLib.ml"),2701,2],
     _r_=[0,caml_new_string("lib/pack/menhirLib.ml"),2653,2],
     _q_=[0,caml_new_string("lib/pack/menhirLib.ml"),2655,2],
     _n_=[0,caml_new_string("lib/pack/menhirLib.ml"),2571,10],
     _p_=[0,caml_new_string("lib/pack/menhirLib.ml"),2490,2],
     _o_=[0,caml_new_string("lib/pack/menhirLib.ml"),2493,6],
     _m_=[0,caml_new_string("lib/pack/menhirLib.ml"),2394,6],
     _l_=[0,caml_new_string("lib/pack/menhirLib.ml"),2276,4],
     _k_=[0,caml_new_string("lib/pack/menhirLib.ml"),2325,4],
     _j_=[0,caml_new_string("lib/pack/menhirLib.ml"),2173,2],
     _i_=[0,caml_new_string("lib/pack/menhirLib.ml"),1992,6],
     _f_=[0,caml_new_string("lib/pack/menhirLib.ml"),1976,6],
     _g_=
      [0,
       [11,caml_new_string("before '"),[2,0,[12,39,0]]],
       caml_new_string("before '%s'")],
     _h_=
      [0,
       [11,
        caml_new_string("after '"),
        [2,0,[11,caml_new_string("' and before '"),[2,0,[12,39,0]]]]],
       caml_new_string("after '%s' and before '%s'")],
     _a_=[0,caml_new_string("lib/pack/menhirLib.ml"),1378,4],
     _b_=[0,caml_new_string("lib/pack/menhirLib.ml"),1397,4],
     _d_=[0,caml_new_string("lib/pack/menhirLib.ml"),1695,8],
     _e_=[0,caml_new_string("lib/pack/menhirLib.ml"),1883,6],
     _c_=[0,caml_new_string("lib/pack/menhirLib.ml"),1670,4];
    function take(n,input)
     {if(0 !== n)
       if(input)
        {var xs=input[2],x=input[1],xs$0=take(n - 1 | 0,xs);
         return xs === xs$0?input:[0,x,xs$0]}
      return 0}
    function drop(n,xs)
     {var n$0=n,xs$0=xs;
      for(;;)
       {if(0 === n$0)return xs$0;
        if(xs$0){var xs$1=xs$0[2],n$1=n$0 - 1 | 0,n$0=n$1,xs$0=xs$1;continue}
        return 0}}
    function uniq1(cmp,x,ys)
     {var cmp$0=cmp,ys$0=ys;
      for(;;)
       {if(ys$0)
         {var ys$1=ys$0[2],y=ys$0[1];
          if(0 === caml_call2(cmp$0,x,y))
           {var cmp$1=runtime.caml_compare,cmp$0=cmp$1,ys$0=ys$1;continue}
          return [0,y,uniq1(cmp$0,y,ys$1)]}
        return 0}}
    function uniq(cmp,xs)
     {if(xs){var xs$0=xs[2],x=xs[1];return [0,x,uniq1(cmp,x,xs$0)]}return 0}
    function weed(cmp,xs){return uniq(cmp,caml_call2(List[48],cmp,xs))}
    function length(xs)
     {var
       _bZ_=caml_obj_tag(xs),
       _b0_=
        250 === _bZ_?xs[1]:246 === _bZ_?caml_call1(CamlinternalLazy[2],xs):xs;
      if(_b0_){var xs$0=_b0_[2];return 1 + length(xs$0) | 0}
      return 0}
    function foldr(f,xs,accu)
     {var
       _bX_=caml_obj_tag(xs),
       _bY_=
        250 === _bX_?xs[1]:246 === _bX_?caml_call1(CamlinternalLazy[2],xs):xs;
      if(_bY_)
       {var xs$0=_bY_[2],x=_bY_[1];return caml_call2(f,x,foldr(f,xs$0,accu))}
      return accu}
    function traditional2revised
     (get_raw_token,get_startp,get_endp,parser,lexer)
     {var lexbuf=caml_call1(Lexing[3],cst);
      function lexer$0(lexbuf)
       {var token=caml_call1(lexer,0);
        lexbuf[11] = caml_call1(get_startp,token);
        lexbuf[12] = caml_call1(get_endp,token);
        return caml_call1(get_raw_token,token)}
      return caml_call2(parser,lexer$0,lexbuf)}
    function revised2traditional(make_token,parser,lexer,lexbuf)
     {function lexer$0(param)
       {var token=caml_call1(lexer,lexbuf);
        return caml_call3(make_token,token,lexbuf[11],lexbuf[12])}
      return caml_call1(parser,lexer$0)}
    function traditional2revised$0(parser)
     {function _bT_(param){var endp=param[3];return endp}
      function _bU_(param){var startp=param[2];return startp}
      function _bV_(param){var token=param[1];return token}
      return function(_bW_)
       {return traditional2revised(_bV_,_bU_,_bT_,parser,_bW_)}}
    function revised2traditional$0(parser)
     {function _bQ_(token,startp,endp){return [0,token,startp,endp]}
      return function(_bR_,_bS_)
       {return revised2traditional(_bQ_,parser,_bR_,_bS_)}}
    var
     Simplified=[0,traditional2revised$0,revised2traditional$0],
     Convert=[0,traditional2revised,revised2traditional,Simplified],
     IncrementalEngine=[0],
     EngineTypes=[0];
    function show(f,buffer)
     {var _bM_=buffer[1];
      if(typeof _bM_ === "number")
       throw [0,Assert_failure,_f_];
      else
       {if(0 === _bM_[0])
         {var invalid=_bM_[1],_bN_=caml_call1(f,invalid);
          return caml_call2(Printf[4],_g_,_bN_)}
        var
         invalid$0=_bM_[2],
         valid=_bM_[1],
         _bO_=caml_call1(f,invalid$0),
         _bP_=caml_call1(f,valid);
        return caml_call3(Printf[4],_h_,_bP_,_bO_)}}
    function last(buffer)
     {var _bL_=buffer[1];
      if(typeof _bL_ === "number")
       throw [0,Assert_failure,_i_];
      else
       var invalid=0 === _bL_[0]?_bL_[1]:_bL_[2];
      return invalid}
    function wrap(lexer)
     {var buffer=[0,0];
      return [0,
              buffer,
              function(lexbuf)
               {var
                 token=caml_call1(lexer,lexbuf),
                 x=[0,lexbuf[11],lexbuf[12]],
                 _bJ_=buffer[1];
                if(typeof _bJ_ === "number")
                 var _bK_=[0,x],switch$0=1;
                else
                 if(0 === _bJ_[0])
                  var x1=_bJ_[1],switch$0=0;
                 else
                  var x1=_bJ_[2],switch$0=0;
                if(! switch$0)var _bK_=[1,x1,x];
                buffer[1] = _bK_;
                return token}]}
    function make(x){return [0,x,caml_make_vect(16384,x),0]}
    function ensure(a,i)
     {if(0 <= i)
       {var table=a[2],length$1=table.length - 1,_bG_=length$1 <= i?1:0;
        if(_bG_)
         {var length$2=2 * length$1 | 0,length=length$2,_bH_=a[1];
          for(;;)
           {if(! (i < length))
             {var length$0=2 * length | 0,length=length$0;continue}
            var table$0=caml_make_vect(length,_bH_);
            caml_call5(Array[10],table,0,table$0,0,length$1);
            a[2] = table$0;
            var _bI_=0;
            break}}
        else
         var _bI_=_bG_;
        return _bI_}
      throw [0,Assert_failure,_j_]}
    function get(a,i){ensure(a,i);return a[2][1 + i]}
    function set(a,i,x)
     {ensure(a,i);
      a[2][1 + i] = x;
      var _bE_=a[3] <= i?1:0,_bF_=_bE_?(a[3] = i + 1 | 0,0):_bE_;
      return _bF_}
    function extent(a){return a[3]}
    function domain(a){return caml_call3(Array[7],a[2],0,a[3])}
    function pack(a)
     {var m=a.length - 1,_bq_=1;
      function _br_(k$1,v)
       {if(0 <= v)
         {var k=1,max=2;
          for(;;)
           {if(0 < max)
             if(! (v < max))
              {var max$0=caml_mul(max,max),k$0=2 * k | 0,k=k$0,max=max$0;
               continue}
            var _bD_=k;
            break}}
        else
         var _bD_=Sys[10];
        return caml_call2(Pervasives[5],k$1,_bD_)}
      var k=caml_call3(Array[17],_br_,_bq_,a);
      if(8 < k)
       {if(0 === (k % 8 | 0))
         {var
           w=k / 8 | 0,
           n=caml_mul(m,w),
           s=caml_create_bytes(n),
           _bt_=m - 1 | 0,
           _bs_=0;
          if(! (_bt_ < 0))
           {var i=_bs_;
            for(;;)
             {var v=[0,caml_check_bound(a,i)[1 + i]],_bu_=1;
              if(! (w < 1))
               {var x=_bu_;
                for(;;)
                 {caml_bytes_set
                   (s,
                    caml_mul(i + 1 | 0,w) - x | 0,
                    caml_call1(Char[1],v[1] & 255));
                  v[1] = v[1] >>> 8 | 0;
                  var _bw_=x + 1 | 0;
                  if(w !== x){var x=_bw_;continue}
                  break}}
              var _bv_=i + 1 | 0;
              if(_bt_ !== i){var i=_bv_;continue}
              break}}
          return [0,k,caml_call1(Bytes[42],s)]}
        throw [0,Assert_failure,_k_]}
      if(0 === caml_mod(8,k))
       {var
         w$0=caml_div(8,k),
         n$0=0 === caml_mod(m,w$0)?caml_div(m,w$0):caml_div(m,w$0) + 1 | 0,
         s$0=caml_create_bytes(n$0),
         i$0=[0,0],
         _by_=n$0 - 1 | 0,
         _bx_=0;
        if(! (_by_ < 0))
         {var j=_bx_;
          for(;;)
           {var c=[0,0],_bz_=1;
            if(! (w$0 < 1))
             {var x$0=_bz_;
              for(;;)
               {var ii=i$0[1];
                if(ii === m)
                 var _bB_=0;
                else
                 {var v$0=caml_check_bound(a,ii)[1 + ii];
                  i$0[1] = ii + 1 | 0;
                  var _bB_=v$0}
                c[1] = c[1] << k | _bB_;
                var _bC_=x$0 + 1 | 0;
                if(w$0 !== x$0){var x$0=_bC_;continue}
                break}}
            caml_bytes_set(s$0,j,caml_call1(Char[1],c[1]));
            var _bA_=j + 1 | 0;
            if(_by_ !== j){var j=_bA_;continue}
            break}}
        return [0,k,caml_call1(Bytes[42],s$0)]}
      throw [0,Assert_failure,_l_]}
    function get1(s,i)
     {var
       c=caml_bytes_unsafe_get(s,i >>> 3 | 0),
       c$0=c >>> (caml_call1(Pervasives[9],i) & 7) | 0,
       c$1=c$0 & 1;
      return c$1}
    function get$0(param,i)
     {var s=param[2],k=param[1],switcher=k - 1 | 0;
      if(! (15 < switcher >>> 0))
       switch(switcher)
        {case 0:return get1(s,i);
         case 1:
          var
           c=caml_bytes_unsafe_get(s,i >>> 2 | 0),
           c$0=c >>> (2 * (caml_call1(Pervasives[9],i) & 3) | 0) | 0,
           c$1=c$0 & 3;
          return c$1;
         case 3:
          var
           c$2=caml_bytes_unsafe_get(s,i >>> 1 | 0),
           c$3=c$2 >>> (4 * (caml_call1(Pervasives[9],i) & 1) | 0) | 0,
           c$4=c$3 & 15;
          return c$4;
         case 7:return caml_bytes_unsafe_get(s,i);
         case 15:
          var j$0=2 * i | 0;
          return (caml_bytes_unsafe_get(s,j$0) << 8)
                 +
                 caml_bytes_unsafe_get(s,j$0 + 1 | 0)
                 |
                 0
         }
      if(32 === k)
       {var j=4 * i | 0;
        return (((((caml_bytes_unsafe_get(s,j) << 8)
                   +
                   caml_bytes_unsafe_get(s,j + 1 | 0)
                   |
                   0)
                  <<
                  8)
                 +
                 caml_bytes_unsafe_get(s,j + 2 | 0)
                 |
                 0)
                <<
                8)
               +
               caml_bytes_unsafe_get(s,j + 3 | 0)
               |
               0}
      throw [0,Assert_failure,_m_]}
    function unflatten1(param,i,j)
     {var data=param[2],n=param[1];return get1(data,caml_mul(n,i) + j | 0)}
    function decode(displacement)
     {return 0 === (displacement & 1)
              ?displacement >>> 1 | 0
              :- (displacement >>> 1 | 0) | 0}
    function compress(equal,insignificant,dummy,m,n,t)
     {if(t.length - 1 === m)
       {var _bj_=m - 1 | 0,_bi_=0;
        if(! (_bj_ < 0))
         {var i=_bi_;
          for(;;)
           {if(caml_check_bound(t,i)[1 + i].length - 1 !== n)
             throw [0,Assert_failure,_o_];
            var _bm_=i + 1 | 0;
            if(_bj_ !== i){var i=_bm_;continue}
            break}}
        var
         sparse=
          function(i,line)
           {var j$2=n - 1 | 0,j=j$2,rank=0,row=0;
            for(;;)
             {if(0 <= j)
               {var x=caml_check_bound(line,j)[1 + j];
                if(caml_call1(insignificant,x))
                 {var j$0=j - 1 | 0,j=j$0;continue}
                var
                 row$0=[0,[0,j,x],row],
                 rank$0=1 + rank | 0,
                 j$1=j - 1 | 0,
                 j=j$1,
                 rank=rank$0,
                 row=row$0;
                continue}
              return [0,i,rank,row]}},
         rows=caml_call2(Array[16],sparse,t),
         _bk_=
          function(param,_bp_)
           {var rank2=_bp_[2],rank1=param[2];
            return runtime.caml_int_compare(rank2,rank1)};
        caml_call2(Array[27],_bk_,rows);
        var
         displacement=caml_make_vect(m,0),
         data=make(dummy),
         _bl_=
          function(param$1)
           {var row$1=param$1[3],i=param$1[1];
            if(row$1)
             {var match$0=row$1[1],j$0=match$0[1],k$1=- j$0 | 0,k=k$1;
              a:
              for(;;)
               {var d=data[3],param=row$1;
                for(;;)
                 {if(param)
                   {var row=param[2],match=param[1],x=match[2],j=match[1];
                    if(! (0 <= (k + j | 0)))throw [0,Assert_failure,_n_];
                    if(d <= (k + j | 0))
                     var _bn_=1;
                    else
                     {var y=get(data,k + j | 0);
                      if(caml_call1(insignificant,y))
                       var switch$0=0;
                      else
                       if(caml_call2(equal,x,y))
                        var switch$0=0;
                       else
                        var _bn_=0,switch$0=1;
                      if(! switch$0){var param=row;continue}}}
                  else
                   var _bn_=1;
                  if(! _bn_){var k$0=k + 1 | 0,k=k$0;continue a}
                  var k$2=k;
                  break}
                break}}
            else
             var k$2=0;
            var param$0=row$1;
            for(;;)
             {if(param$0)
               {var
                 row$0=param$0[2],
                 match$1=param$0[1],
                 x$0=match$1[2],
                 j$1=match$1[1];
                set(data,k$2 + j$1 | 0,x$0);
                var param$0=row$0;
                continue}
              var _bo_=0 <= k$2?k$2 << 1:((- k$2 | 0) << 1) + 1 | 0;
              caml_check_bound(displacement,i)[1 + i] = _bo_;
              return 0}};
        caml_call2(Array[13],_bl_,rows);
        return [0,displacement,domain(data)]}
      throw [0,Assert_failure,_p_]}
    function get$1(param,i,j)
     {var data=param[2],displacement=param[1];
      if(0 <= i)
       if(i < displacement.length - 1)
        {var k=decode(caml_check_bound(displacement,i)[1 + i]);
         if(0 <= (k + j | 0))
          if((k + j | 0) < data.length - 1)
           {var _bh_=k + j | 0;return caml_check_bound(data,_bh_)[1 + _bh_]}
         throw [0,Assert_failure,_q_]}
      throw [0,Assert_failure,_r_]}
    function getget(get_displacement,get_data,param,i,j)
     {var
       data=param[2],
       displacement=param[1],
       k=decode(caml_call2(get_displacement,displacement,i));
      return caml_call2(get_data,data,k + j | 0)}
    function make$0(a)
     {var n=a.length - 1,size=[0,0];
      function _ba_(i)
       {var s=size[1];
        if(i < n)size[1] = s + (caml_check_bound(a,i)[1 + i].length - 1) | 0;
        return s}
      var entry=caml_call2(Array[2],n + 1 | 0,_ba_),_bb_=size[1];
      if(caml_check_bound(entry,n)[1 + n] === _bb_)
       {var
         i=[0,0],
         j=[0,0],
         _bc_=
          function(param)
           {for(;;)
             {var
               _bd_=i[1],
               _be_=caml_check_bound(a,_bd_)[1 + _bd_].length - 1;
              if(j[1] === _be_){i[1] = i[1] + 1 | 0;j[1] = 0;continue}
              var
               _bf_=j[1],
               _bg_=i[1],
               x=
                caml_check_bound(caml_check_bound(a,_bg_)[1 + _bg_],_bf_)
                 [1 + _bf_];
              j[1] = j[1] + 1 | 0;
              return x}},
         data=caml_call2(Array[2],size[1],_bc_);
        return [0,data,entry]}
      throw [0,Assert_failure,_s_]}
    function length$0(param){var entry=param[2];return entry.length - 1}
    function row_length(param,i)
     {var entry=param[2],_a$_=i + 1 | 0,_a__=caml_check_bound(entry,i)[1 + i];
      return caml_check_bound(entry,_a$_)[1 + _a$_] - _a__ | 0}
    function row_length_via(get_entry,i)
     {var _a9_=caml_call1(get_entry,i);
      return caml_call1(get_entry,i + 1 | 0) - _a9_ | 0}
    function read(la,i,j)
     {var entry=la[2],data=la[1];
      if(0 <= j)
       if(j < row_length(la,i))
        {var _a8_=caml_check_bound(entry,i)[1 + i] + j | 0;
         return caml_check_bound(data,_a8_)[1 + _a8_]}
      throw [0,Assert_failure,_t_]}
    function read_via(get_data,get_entry,i,j)
     {if(0 <= j)
       if(j < row_length_via(get_entry,i))
        return caml_call1(get_data,caml_call1(get_entry,i) + j | 0);
      throw [0,Assert_failure,_u_]}
    function write(la,i,j,v)
     {var entry=la[2],data=la[1];
      if(0 <= j)
       if(j < row_length(la,i))
        {var _a7_=caml_check_bound(entry,i)[1 + i] + j | 0;
         caml_check_bound(data,_a7_)[1 + _a7_] = v;
         return 0}
      throw [0,Assert_failure,_v_]}
    function read_interval_via(get_data,i,j)
     {if(i === j)return 0;
      var _a6_=read_interval_via(get_data,i + 1 | 0,j);
      return [0,caml_call1(get_data,i),_a6_]}
    function read_row_via(get_data,get_entry,i)
     {var _a5_=caml_call1(get_entry,i + 1 | 0);
      return read_interval_via(get_data,caml_call1(get_entry,i),_a5_)}
    function read_row(param,i)
     {var entry=param[2],data=param[1];
      function _a2_(_a4_){return caml_check_bound(entry,_a4_)[1 + _a4_]}
      return read_row_via
              (function(_a3_){return caml_check_bound(data,_a3_)[1 + _a3_]},
               _a2_,
               i)}
    var TableFormat=[0],InspectionTableFormat=[0];
    function Symbols(T){return [0]}
    var
     StaticVersion=[0,0],
     _K_=
      [0,
       function(T)
        {function number(s){return s}
         var _aF_=T[1],_aG_=T[3],_aH_=T[2],error_value=0;
         function foreach_terminal(f,accu$0)
          {var match=T[5],n=match[1],i=0,accu=accu$0;
           for(;;)
            {if(i === n)return accu;
             var accu$1=caml_call2(f,i,accu),i$0=i + 1 | 0,i=i$0,accu=accu$1;
             continue}}
         function non_start_production(i)
          {if(T[9] <= i)if((i - T[9] | 0) < T[10].length - 1)return 0;
           throw [0,Assert_failure,_A_]}
         function production_index(i){non_start_production(i);return i}
         function find_production(i){non_start_production(i);return i}
         function default_reduction(state,defred,nodefred,env)
          {var code=get$0(T[4],state);
           return 0 === code
                   ?caml_call1(nodefred,env)
                   :caml_call2(defred,env,code - 1 | 0)}
         function is_start(prod){return prod < T[9]?1:0}
         function unmarshal2(table,i,j){return getget(get$0,get$0,table,i,j)}
         function action(state,terminal,value,shift,reduce,fail,env)
          {var c=unflatten1(T[5],state,terminal);
           if(1 === c)
            {var
              action=unmarshal2(T[6],state,terminal),
              opcode=action & 3,
              param=action >>> 2 | 0;
             if(2 <= opcode)
              {var please_discard=2 === opcode?1:0;
               return caml_call5
                       (shift,env,please_discard,terminal,value,param)}
             return caml_call2(reduce,env,param)}
           if(0 === c)return caml_call1(fail,env);
           throw [0,Assert_failure,_B_]}
         function goto_nt(state,nt)
          {var code=unmarshal2(T[8],state,nt);return code - 1 | 0}
         function goto_prod(state,prod)
          {return goto_nt(state,get$0(T[7],prod))}
         function maybe_goto_nt(state,nt)
          {var code=unmarshal2(T[8],state,nt);
           if(0 <= code)return 0 === code?0:[0,code - 1 | 0];
           throw [0,Assert_failure,_C_]}
         var _aI_=T[11];
         function semantic_action(prod)
          {var _a1_=prod - T[9] | 0;
           return caml_check_bound(T[10],_a1_)[1 + _a1_]}
         function may_reduce(state,prod)
          {var _aR_=0;
           function _aS_(param)
            {var _aT_=0;
             return foreach_terminal
                     (function(t,accu)
                       {if(accu)return accu;
                        var _aU_=0;
                        function _aV_(param){return 0}
                        function _aW_(param,prod$0){return prod === prod$0?1:0}
                        return action
                                (state,
                                 t,
                                 0,
                                 function(param,_a0_,_aZ_,_aY_,_aX_){return 0},
                                 _aW_,
                                 _aV_,
                                 _aU_)},
                      _aT_)}
           return default_reduction
                   (state,
                    function(param,prod$0){return prod === prod$0?1:0},
                    _aS_,
                    _aR_)}
         var log=T[12]?1:0;
         function state(state)
          {return T[12]?caml_call3(Printf[1],Pervasives[28],_D_,state):0}
         function shift(terminal,state)
          {var _aP_=T[12];
           if(_aP_)
            {var
              match=_aP_[1],
              terminals=match[1],
              _aQ_=caml_check_bound(terminals,terminal)[1 + terminal];
             return caml_call4(Printf[1],Pervasives[28],_E_,_aQ_,state)}
           return 0}
         function reduce_or_accept(prod)
          {var _aN_=T[12];
           if(_aN_)
            {var
              match=_aN_[1],
              productions=match[2],
              _aO_=caml_check_bound(productions,prod)[1 + prod];
             return caml_call3(Printf[1],Pervasives[28],_F_,_aO_)}
           return 0}
         function lookahead_token(token,startp,endp)
          {var _aJ_=T[12];
           if(_aJ_)
            {var
              match=_aJ_[1],
              terminals=match[1],
              _aK_=endp[4],
              _aL_=startp[4],
              _aM_=caml_check_bound(terminals,token)[1 + token];
             return caml_call5(Printf[1],Pervasives[28],_G_,_aM_,_aL_,_aK_)}
           return 0}
         function initiating_error_handling(param)
          {return T[12]?caml_call2(Printf[1],Pervasives[28],_H_):0}
         function resuming_error_handling(param)
          {return T[12]?caml_call2(Printf[1],Pervasives[28],_I_):0}
         function handling_error(state)
          {return T[12]?caml_call3(Printf[1],Pervasives[28],_J_,state):0}
         var
          Log=
           [0,
            state,
            shift,
            reduce_or_accept,
            lookahead_token,
            initiating_error_handling,
            resuming_error_handling,
            handling_error];
         return [0,
                 number,
                 _aF_,
                 _aG_,
                 _aH_,
                 error_value,
                 foreach_terminal,
                 production_index,
                 find_production,
                 default_reduction,
                 action,
                 goto_nt,
                 goto_prod,
                 maybe_goto_nt,
                 is_start,
                 _aI_,
                 semantic_action,
                 may_reduce,
                 log,
                 Log]}],
     _L_=
      [0,
       Symbols,
       function(TT,IT,ET,_al_)
        {function read_packed_linearized(param,i)
          {var entry=param[2],data=param[1];
           function _aC_(_aE_){return get$0(entry,_aE_)}
           return read_row_via(function(_aD_){return get$0(data,_aD_)},_aC_,i)}
         function decode_symbol(symbol)
          {if(0 < symbol)
            {var kind=symbol & 1,symbol$0=symbol >>> 1 | 0;
             return 0 === kind
                     ?caml_call1(IT[1],symbol$0 - 1 | 0)
                     :caml_call1(IT[2],symbol$0)}
           throw [0,Assert_failure,_w_]}
         function n2i(nt)
          {var answer=TT[9] + nt | 0;
           if(caml_equal(caml_call1(IT[2],answer),[0,[1,nt]]))return answer;
           throw [0,Assert_failure,_x_]}
         function t2i(answer)
          {if(caml_equal(caml_call1(IT[1],answer),[0,[0,answer]]))
            return answer;
           throw [0,Assert_failure,_y_]}
         function compare_terminals(t1,t2)
          {var _aB_=t2i(t2);return t2i(t1) - _aB_ | 0}
         function compare_nonterminals(nt1,nt2)
          {var _aA_=n2i(nt2);return n2i(nt1) - _aA_ | 0}
         function compare_symbols(symbol1,symbol2)
          {var _av_=symbol1[1];
           if(0 === _av_[0])
            {var _aw_=symbol2[1],_ax_=_av_[1];
             if(0 === _aw_[0])
              {var t2=_aw_[1];return compare_terminals(_ax_,t2)}
             return -1}
           var _ay_=symbol2[1],_az_=_av_[1];
           if(0 === _ay_[0])return 1;
           var nt2=_ay_[1];
           return compare_nonterminals(_az_,nt2)}
         function compare_productions(prod1,prod2){return prod1 - prod2 | 0}
         function compare_items(param,_au_)
          {var
            index2=_au_[2],
            prod2=_au_[1],
            index1=param[2],
            prod1=param[1],
            c=prod1 - prod2 | 0;
           return 0 === c?index1 - index2 | 0:c}
         function incoming_symbol(s)
          {var
            core=get$0(IT[4],s),
            symbol=decode_symbol(get$0(IT[6],core)),
            symbol$0=symbol[1];
           return symbol$0}
         function lhs(prod)
          {var _at_=get$0(TT[7],prod);return caml_call1(IT[2],_at_)}
         function rhs(prod)
          {var _as_=read_packed_linearized(IT[3],prod);
           return caml_call2(List[17],decode_symbol,_as_)}
         function export$0(t){return [0,t >>> 10 | 0,t % 1024 | 0]}
         function items(s)
          {var core=get$0(IT[4],s),_ar_=read_packed_linearized(IT[5],core);
           return caml_call2(List[17],export$0,_ar_)}
         function decode_bool(i)
          {if(0 !== i)if(1 !== i)throw [0,Assert_failure,_z_];
           return 1 === i?1:0}
         function nullable(nt)
          {var _aq_=n2i(nt);return decode_bool(get1(IT[7],_aq_))}
         function first(nt,t)
          {var _ao_=t2i(t),_ap_=n2i(nt);
           return decode_bool(unflatten1(IT[8],_ap_,_ao_))}
         function xfirst(symbol,t)
          {var _an_=symbol[1];
           if(0 === _an_[0])
            {var t$0=_an_[1];return 0 === compare_terminals(t,t$0)?1:0}
           var nt=_an_[1];
           return first(nt,t)}
         function foldij(i,j,f,accu)
          {var i$0=i,accu$0=accu;
           for(;;)
            {if(i$0 === j)return accu$0;
             var
              accu$1=caml_call2(f,i$0,accu$0),
              i$1=i$0 + 1 | 0,
              i$0=i$1,
              accu$0=accu$1;
             continue}}
         function foreach_terminal(f,accu)
          {var match=TT[5],n=match[1];
           return foldij
                   (0,
                    n,
                    function(i,accu)
                     {return caml_call2(f,caml_call1(IT[1],i),accu)},
                    accu)}
         function foreach_terminal_but_error(f,accu)
          {var match=TT[5],n=match[1];
           return foldij
                   (0,
                    n,
                    function(i,accu)
                     {return i === TT[2]
                              ?accu
                              :caml_call2(f,caml_call1(IT[1],i),accu)},
                    accu)}
         function feed_failure(param)
          {return caml_call1
                   (Pervasives[1],cst_feed_outgoing_transition_does_not_exist)}
         function reduce(env,prod){return feed_failure(0)}
         function initiate(env){return feed_failure(0)}
         function feed(symbol,startp,semv,endp,env)
          {if(0 === symbol[0])
            {var
              terminal=symbol[1],
              terminal$0=t2i(terminal),
              source$0=env[4],
              _am_=
               function(env,please_discard,terminal,semv,target)
                {var stack=[0,source$0,semv,startp,endp,env[3]];
                 return [0,env[1],env[2],stack,target]};
             return caml_call7
                     (ET[10],source$0,terminal$0,semv,_am_,reduce,initiate,env)}
           var
            nt=symbol[1],
            nt$0=n2i(nt),
            source=env[4],
            match=caml_call2(ET[13],source,nt$0);
           if(match)
            {var target=match[1],stack=[0,source,semv,startp,endp,env[3]];
             return [0,env[1],env[2],stack,target]}
           return feed_failure(0)}
         return [0,
                 compare_terminals,
                 compare_nonterminals,
                 compare_symbols,
                 compare_productions,
                 compare_items,
                 incoming_symbol,
                 items,
                 lhs,
                 rhs,
                 nullable,
                 first,
                 xfirst,
                 foreach_terminal,
                 foreach_terminal_but_error,
                 feed]}],
     _M_=
      [0,
       make$0,
       read,
       write,
       length$0,
       row_length,
       read_row,
       row_length_via,
       read_via,
       read_row_via],
     _N_=[0,compress,get$1,getget],
     _O_=[0,pack,get$0,get1,unflatten1],
     _P_=[0,make,get,set,extent,domain],
     _Q_=
      [0,
       function(I,User)
        {function print_symbols(i,symbols)
          {var i$0=i,symbols$0=symbols;
           for(;;)
            {if(0 === i$0)
              {caml_call1(User[1],dot);
               caml_call1(User[1],space);
               var i$0=-1;
               continue}
             if(symbols$0)
              {var symbols$1=symbols$0[2],symbol=symbols$0[1];
               caml_call1(User[2],symbol);
               caml_call1(User[1],space);
               var i$1=i$0 - 1 | 0,i$0=i$1,symbols$0=symbols$1;
               continue}
             return 0}}
         function print_element_as_symbol(element)
          {var s=element[1],_ak_=[0,caml_call1(I[29],s)];
           return caml_call1(User[2],_ak_)}
         var _ae_=User[3];
         if(_ae_)
          var print_element=_ae_[1],print_element$0=print_element;
         else
          var print_element$0=print_element_as_symbol;
         function _af_(env)
          {var match=caml_call1(I[13],env),match$0=caml_call1(I[21],env);
           if(match)
            if(match$0)
             {var env$0=match$0[1],element=match[1];
              _af_(env$0);
              caml_call1(User[1],space);
              return caml_call1(print_element$0,element)}
           return 0}
         function print_stack(env)
          {_af_(env);return caml_call1(User[1],newline)}
         function print_item(param)
          {var i=param[2],prod=param[1],_aj_=caml_call1(I[31],prod);
           caml_call1(User[2],_aj_);
           caml_call1(User[1],arrow);
           print_symbols(i,caml_call1(I[32],prod));
           return caml_call1(User[1],newline)}
         function print_symbols$0(symbols){return print_symbols(-1,symbols)}
         function print_production(prod){return print_item([0,prod,-1])}
         function print_current_state(env)
          {caml_call1(User[1],cst_Current_LR_1_state);
           var match=caml_call1(I[13],env);
           if(match)
            {var
              match$0=match[1],
              current=match$0[1],
              _ag_=caml_call1(I[9],current),
              _ah_=caml_call1(Pervasives[21],_ag_);
             caml_call1(User[1],_ah_);
             caml_call1(User[1],newline);
             var _ai_=caml_call1(I[30],current);
             return caml_call2(List[15],print_item,_ai_)}
           caml_call1(User[1],cst_some_initial_state);
           return caml_call1(User[1],newline)}
         function print_env(env)
          {print_stack(env);
           print_current_state(env);
           return caml_call1(User[1],newline)}
         return [0,
                 print_symbols$0,
                 print_element_as_symbol,
                 print_stack,
                 print_item,
                 print_production,
                 print_current_state,
                 print_env]}],
     _R_=[0,wrap,show,last],
     MenhirLib=
      [0,
       [0,take,drop,uniq,weed,length,foldr],
       Convert,
       IncrementalEngine,
       EngineTypes,
       [0,
        function(T)
         {var
           number=T[1],
           production_index=T[7],
           find_production=T[8],
           Error=T[15],
           log=T[18],
           Log=T[19];
          function check_for_default_reduction(env)
           {return caml_call4
                    (T[9],env[4],announce_reduce,check_for_error_token,env)}
          function run(env,please_discard)
           {if(log)caml_call1(Log[1],env[4]);
            return please_discard?[0,env]:check_for_default_reduction(env)}
          function check_for_error_token(env)
           {if(env[1]){if(log)caml_call1(Log[6],0);return [3,env]}
            var
             match=env[2],
             token=match[1],
             _ac_=caml_call1(T[3],token),
             _ad_=caml_call1(T[2],token);
            return caml_call7
                    (T[10],env[4],_ad_,_ac_,shift,announce_reduce,initiate,env)}
          function shift(env,please_discard,terminal,value,s)
           {if(log)caml_call2(Log[2],terminal,s);
            var
             match=env[2],
             endp=match[3],
             startp=match[2],
             stack=[0,env[4],value,startp,endp,env[3]],
             new_env=[0,env[1],env[2],stack,s];
            return [1,env,new_env,please_discard]}
          function announce_reduce(env,prod)
           {if(caml_call1(T[14],prod))
             {if(log)caml_call1(Log[3],prod);var v=env[3][2];return [4,v]}
            return [2,env,prod]}
          function initiate(env)
           {if(log)caml_call1(Log[5],0);
            var env$0=[0,1,env[2],env[3],env[4]];
            return [3,env$0]}
          function reduce(env,prod)
           {if(log)caml_call1(Log[3],prod);
            try
             {var stack=caml_call2(T[16],prod,env)}
            catch(_ab_)
             {_ab_ = caml_wrap_exception(_ab_);
              if(_ab_ === Error)return initiate(env);
              throw _ab_}
            var
             current=caml_call2(T[12],stack[1],prod),
             env$0=[0,env[1],env[2],stack,current];
            return run(env$0,0)}
          function error_shift(env,please_discard,terminal,value,s)
           {if(caml_equal(terminal,T[4]))
             if(caml_equal(value,T[5]))
              {if(log)caml_call1(Log[7],env[4]);
               return shift(env,please_discard,terminal,value,s)}
            throw [0,Assert_failure,_b_]}
          function error_reduce(env,prod)
           {if(log)caml_call1(Log[7],env[4]);return reduce(env,prod)}
          function error_fail(env)
           {var cell=env[3],next=cell[5];
            if(next === cell)return 0;
            var env$0=[0,env[1],env[2],next,cell[1]];
            return [3,env$0]}
          function start(s,initial)
           {var empty=[];
            runtime.caml_update_dummy(empty,[0,s,T[5],initial,initial,empty]);
            var env=[0,0,[0,0,initial,initial],empty,s];
            return run(env,1)}
          function offer(param)
           {if(typeof param !== "number" && 0 === param[0])
             {var env=param[1];
              return function(triple)
               {if(log)
                 {var
                   endp=triple[3],
                   startp=triple[2],
                   token=triple[1],
                   _aa_=caml_call1(T[2],token);
                  caml_call3(Log[4],_aa_,startp,endp)}
                var env$0=[0,0,triple,env[3],env[4]];
                return check_for_default_reduction(env$0)}}
            return caml_call1(Pervasives[1],cst_offer_expects_InputNeeded)}
          function resume(param)
           {if(typeof param !== "number")
             switch(param[0])
              {case 1:
                var please_discard=param[3],env=param[2];
                return run(env,please_discard);
               case 2:
                var prod=param[2],env$0=param[1];return reduce(env$0,prod);
               case 3:
                var env$1=param[1];
                if(env$1[1])
                 return caml_call7
                         (T[10],
                          env$1[4],
                          T[4],
                          T[5],
                          error_shift,
                          error_reduce,
                          error_fail,
                          env$1);
                throw [0,Assert_failure,_a_]
               }
            return caml_call1
                    (Pervasives[1],
                     cst_resume_expects_HandlingError_Shifting_AboutToReduce)}
          function lexer_lexbuf_to_supplier(lexer,lexbuf,param)
           {var
             token=caml_call1(lexer,lexbuf),
             startp=lexbuf[11],
             endp=lexbuf[12];
            return [0,token,startp,endp]}
          function loop(read,checkpoint)
           {var checkpoint$0=checkpoint;
            for(;;)
             if(typeof checkpoint$0 === "number")
              throw Error;
             else
              switch(checkpoint$0[0])
               {case 0:
                 var
                  triple=caml_call1(read,0),
                  checkpoint$1=caml_call1(offer(checkpoint$0),triple),
                  checkpoint$0=checkpoint$1;
                 continue;
                case 4:var v=checkpoint$0[1];return v;
                default:
                 var
                  checkpoint$2=resume(checkpoint$0),
                  checkpoint$0=checkpoint$2;
                 continue}}
          function entry(s,lexer,lexbuf)
           {var initial=lexbuf[12],___=start(s,initial);
            return loop
                    (function(_$_)
                      {return lexer_lexbuf_to_supplier(lexer,lexbuf,_$_)},
                     ___)}
          function loop_handle(succeed,fail,read,checkpoint)
           {var checkpoint$0=checkpoint;
            for(;;)
             {if(typeof checkpoint$0 !== "number")
               switch(checkpoint$0[0])
                {case 0:
                  var
                   triple=caml_call1(read,0),
                   checkpoint$1=caml_call1(offer(checkpoint$0),triple),
                   checkpoint$0=checkpoint$1;
                  continue;
                 case 4:var v=checkpoint$0[1];return caml_call1(succeed,v);
                 case 3:break;
                 default:
                  var
                   checkpoint$2=resume(checkpoint$0),
                   checkpoint$0=checkpoint$2;
                  continue}
              return caml_call1(fail,checkpoint$0)}}
          function loop_handle_undo(succeed,fail,read,checkpoint$2)
           {if(typeof checkpoint$2 === "number")
             var switch$0=0;
            else
             if(0 === checkpoint$2[0])
              var _Z_=1,switch$0=1;
             else
              var switch$0=0;
            if(! switch$0)var _Z_=0;
            if(_Z_)
             {var param$2=[0,checkpoint$2,checkpoint$2],param=param$2;
              for(;;)
               {var checkpoint=param[2],inputneeded=param[1];
                if(typeof checkpoint !== "number")
                 switch(checkpoint[0])
                  {case 0:
                    var
                     triple=caml_call1(read,0),
                     checkpoint$0=caml_call1(offer(checkpoint),triple),
                     param$0=[0,checkpoint,checkpoint$0],
                     param=param$0;
                    continue;
                   case 4:var v=checkpoint[1];return caml_call1(succeed,v);
                   case 3:break;
                   default:
                    var
                     checkpoint$1=resume(checkpoint),
                     param$1=[0,inputneeded,checkpoint$1],
                     param=param$1;
                    continue}
                return caml_call2(fail,inputneeded,checkpoint)}}
            throw [0,Assert_failure,_c_]}
          function shifts(checkpoint)
           {var checkpoint$0=checkpoint;
            for(;;)
             {if(typeof checkpoint$0 !== "number")
               switch(checkpoint$0[0])
                {case 1:var env=checkpoint$0[1];return [0,env];
                 case 2:
                  var
                   checkpoint$1=resume(checkpoint$0),
                   checkpoint$0=checkpoint$1;
                  continue;
                 case 3:return 0
                 }
              throw [0,Assert_failure,_d_]}}
          function acceptable(checkpoint,token,pos)
           {var
             triple=[0,token,pos,pos],
             checkpoint$0=caml_call1(offer(checkpoint),triple),
             match=shifts(checkpoint$0);
            return match?1:0}
          function _S_(cell,current)
           {return [246,
                    function(param)
                     {var next=cell[5];
                      if(next === cell)return 0;
                      var element=[0,current,cell[2],cell[3],cell[4]];
                      return [0,element,_S_(next,cell[1])]}]}
          function stack(env){return _S_(env[3],env[4])}
          function top(env)
           {var cell=env[3],next=cell[5];
            return next === cell?0:[0,[0,env[4],cell[2],cell[3],cell[4]]]}
          function equal(env1,env2)
           {var _W_=env1[3] === env2[3]?1:0;
            if(_W_)
             var
              _X_=caml_call1(number,env2[4]),
              _Y_=caml_call1(number,env1[4]) === _X_?1:0;
            else
             var _Y_=_W_;
            return _Y_}
          function current_state_number(env){return caml_call1(number,env[4])}
          function positions(param)
           {var match=param[2],endp=match[3],startp=match[2];
            return [0,startp,endp]}
          function state_has_default_reduction(state)
           {var _T_=0;
            function _U_(env){return 0}
            function _V_(env,prod){return 1}
            return caml_call4(T[9],state,_V_,_U_,_T_)}
          function env_has_default_reduction(env)
           {return state_has_default_reduction(env[4])}
          function pop(env)
           {var cell=env[3],next=cell[5];
            return next === cell?0:[0,[0,env[1],env[2],next,cell[1]]]}
          function force_reduction(prod,env)
           {if(caml_call2(T[17],env[4],prod))
             {if(caml_call1(T[14],prod))throw [0,Assert_failure,_e_];
              var
               stack=caml_call2(T[16],prod,env),
               current=caml_call2(T[12],stack[1],prod);
              return [0,env[1],env[2],stack,current]}
            return caml_call1
                    (Pervasives[1],
                     cst_force_reduction_this_reduction_is_not_permitted_in_this_state)}
          function input_needed(env){return [0,env]}
          function pop_many(i,env)
           {var i$0=i,env$0=env;
            for(;;)
             {if(0 === i$0)return [0,env$0];
              var match=pop(env$0);
              if(match)
               {var env$1=match[1],i$1=i$0 - 1 | 0,i$0=i$1,env$0=env$1;
                continue}
              return 0}}
          function get(i,env)
           {var match=pop_many(i,env);
            if(match){var env$0=match[1];return top(env$0)}
            return 0}
          return [0,
                  Error,
                  entry,
                  offer,
                  resume,
                  lexer_lexbuf_to_supplier,
                  loop,
                  loop_handle,
                  loop_handle_undo,
                  shifts,
                  acceptable,
                  number,
                  production_index,
                  find_production,
                  stack,
                  top,
                  pop_many,
                  get,
                  current_state_number,
                  equal,
                  positions,
                  env_has_default_reduction,
                  state_has_default_reduction,
                  pop,
                  force_reduction,
                  input_needed,
                  start]}],
       _R_,
       _Q_,
       _P_,
       _O_,
       _N_,
       _M_,
       TableFormat,
       InspectionTableFormat,
       _L_,
       _K_,
       StaticVersion];
    runtime.caml_register_global(58,MenhirLib,"MenhirLib");
    return}
  (function(){return this}()));


//# 1 "../.js/js_of_ocaml/js_of_ocaml.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_float_of_string=runtime.caml_float_of_string,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_int_of_string=runtime.caml_int_of_string,
     caml_js_from_array=runtime.caml_js_from_array,
     caml_js_from_string=runtime.caml_js_from_string,
     caml_js_get=runtime.caml_js_get,
     caml_js_html_escape=runtime.caml_js_html_escape,
     caml_js_set=runtime.caml_js_set,
     caml_js_to_byte_string=runtime.caml_js_to_byte_string,
     caml_js_to_string=runtime.caml_js_to_string,
     caml_js_wrap_callback=runtime.caml_js_wrap_callback,
     caml_js_wrap_meth_callback=runtime.caml_js_wrap_meth_callback,
     caml_jsbytes_of_string=runtime.caml_jsbytes_of_string,
     caml_list_of_js_array=runtime.caml_list_of_js_array,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_new_string=runtime.caml_new_string,
     caml_register_global=runtime.caml_register_global,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_array=runtime.caml_string_of_array,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_parseFloat=caml_new_string("parseFloat"),
     cst_parseInt=caml_new_string("parseInt"),
     cst_Js_of_ocaml_Js_Error=caml_new_string("Js_of_ocaml__Js.Error"),
     cst_jsError=caml_new_string("jsError"),
     cst_can_t_retrieve_file_name_not_implemented=
      caml_new_string("can't retrieve file name: not implemented"),
     cst_endings=caml_new_string("endings"),
     cst_type=caml_new_string("type"),
     cst_loadstart=caml_new_string("loadstart"),
     cst_progress=caml_new_string("progress"),
     cst_abort=caml_new_string("abort"),
     cst_error=caml_new_string("error"),
     cst_load=caml_new_string("load"),
     cst_loadend=caml_new_string("loadend"),
     cst_a$1=caml_new_string("a"),
     cst_area$1=caml_new_string("area"),
     cst_audio$1=caml_new_string("audio"),
     cst_base$1=caml_new_string("base"),
     cst_blockquote$1=caml_new_string("blockquote"),
     cst_body$1=caml_new_string("body"),
     cst_br$1=caml_new_string("br"),
     cst_button$1=caml_new_string("button"),
     cst_canvas$1=caml_new_string("canvas"),
     cst_caption$1=caml_new_string("caption"),
     cst_col$1=caml_new_string("col"),
     cst_colgroup$1=caml_new_string("colgroup"),
     cst_del$1=caml_new_string("del"),
     cst_div$1=caml_new_string("div"),
     cst_dl$1=caml_new_string("dl"),
     cst_embed$1=caml_new_string("embed"),
     cst_fieldset$1=caml_new_string("fieldset"),
     cst_form$1=caml_new_string("form"),
     cst_frame$1=caml_new_string("frame"),
     cst_frameset$1=caml_new_string("frameset"),
     cst_h1$1=caml_new_string("h1"),
     cst_h2$1=caml_new_string("h2"),
     cst_h3$1=caml_new_string("h3"),
     cst_h4$1=caml_new_string("h4"),
     cst_h5$1=caml_new_string("h5"),
     cst_h6$1=caml_new_string("h6"),
     cst_head$1=caml_new_string("head"),
     cst_hr$1=caml_new_string("hr"),
     cst_html$1=caml_new_string("html"),
     cst_iframe$1=caml_new_string("iframe"),
     cst_img$1=caml_new_string("img"),
     cst_input$2=caml_new_string("input"),
     cst_ins$1=caml_new_string("ins"),
     cst_label$1=caml_new_string("label"),
     cst_legend$1=caml_new_string("legend"),
     cst_li$1=caml_new_string("li"),
     cst_link$1=caml_new_string("link"),
     cst_map$1=caml_new_string("map"),
     cst_meta$1=caml_new_string("meta"),
     cst_object$1=caml_new_string("object"),
     cst_ol$1=caml_new_string("ol"),
     cst_optgroup$1=caml_new_string("optgroup"),
     cst_option$1=caml_new_string("option"),
     cst_p$1=caml_new_string("p"),
     cst_param$1=caml_new_string("param"),
     cst_pre$1=caml_new_string("pre"),
     cst_q$1=caml_new_string("q"),
     cst_script$1=caml_new_string("script"),
     cst_select$2=caml_new_string("select"),
     cst_style$1=caml_new_string("style"),
     cst_table$1=caml_new_string("table"),
     cst_tbody$1=caml_new_string("tbody"),
     cst_td$1=caml_new_string("td"),
     cst_textarea$1=caml_new_string("textarea"),
     cst_tfoot$1=caml_new_string("tfoot"),
     cst_th$1=caml_new_string("th"),
     cst_thead$1=caml_new_string("thead"),
     cst_title$1=caml_new_string("title"),
     cst_tr$1=caml_new_string("tr"),
     cst_ul$1=caml_new_string("ul"),
     cst_video$1=caml_new_string("video"),
     cst_KeyH=caml_new_string("KeyH"),
     cst_Digit6=caml_new_string("Digit6"),
     cst_BrowserRefresh=caml_new_string("BrowserRefresh"),
     cst_Backslash=caml_new_string("Backslash"),
     cst_AltLeft=caml_new_string("AltLeft"),
     cst_AltRight=caml_new_string("AltRight"),
     cst_ArrowDown=caml_new_string("ArrowDown"),
     cst_ArrowLeft=caml_new_string("ArrowLeft"),
     cst_ArrowRight=caml_new_string("ArrowRight"),
     cst_ArrowUp=caml_new_string("ArrowUp"),
     cst_Backquote=caml_new_string("Backquote"),
     cst_Backspace=caml_new_string("Backspace"),
     cst_BracketLeft=caml_new_string("BracketLeft"),
     cst_BracketRight=caml_new_string("BracketRight"),
     cst_BrowserBack=caml_new_string("BrowserBack"),
     cst_BrowserFavorites=caml_new_string("BrowserFavorites"),
     cst_BrowserForward=caml_new_string("BrowserForward"),
     cst_BrowserHome=caml_new_string("BrowserHome"),
     cst_Delete=caml_new_string("Delete"),
     cst_BrowserSearch=caml_new_string("BrowserSearch"),
     cst_BrowserStop=caml_new_string("BrowserStop"),
     cst_CapsLock=caml_new_string("CapsLock"),
     cst_Comma=caml_new_string("Comma"),
     cst_ContextMenu=caml_new_string("ContextMenu"),
     cst_ControlLeft=caml_new_string("ControlLeft"),
     cst_ControlRight=caml_new_string("ControlRight"),
     cst_Digit0=caml_new_string("Digit0"),
     cst_Digit1=caml_new_string("Digit1"),
     cst_Digit2=caml_new_string("Digit2"),
     cst_Digit3=caml_new_string("Digit3"),
     cst_Digit4=caml_new_string("Digit4"),
     cst_Digit5=caml_new_string("Digit5"),
     cst_F6=caml_new_string("F6"),
     cst_F1=caml_new_string("F1"),
     cst_Digit7=caml_new_string("Digit7"),
     cst_Digit8=caml_new_string("Digit8"),
     cst_Digit9=caml_new_string("Digit9"),
     cst_End=caml_new_string("End"),
     cst_Enter=caml_new_string("Enter"),
     cst_Equal=caml_new_string("Equal"),
     cst_Escape=caml_new_string("Escape"),
     cst_F10=caml_new_string("F10"),
     cst_F11=caml_new_string("F11"),
     cst_F12=caml_new_string("F12"),
     cst_F2=caml_new_string("F2"),
     cst_F3=caml_new_string("F3"),
     cst_F4=caml_new_string("F4"),
     cst_F5=caml_new_string("F5"),
     cst_KeyA=caml_new_string("KeyA"),
     cst_F7=caml_new_string("F7"),
     cst_F8=caml_new_string("F8"),
     cst_F9=caml_new_string("F9"),
     cst_Home=caml_new_string("Home"),
     cst_Insert=caml_new_string("Insert"),
     cst_IntlBackslash=caml_new_string("IntlBackslash"),
     cst_IntlYen=caml_new_string("IntlYen"),
     cst_KeyB=caml_new_string("KeyB"),
     cst_KeyC=caml_new_string("KeyC"),
     cst_KeyD=caml_new_string("KeyD"),
     cst_KeyE=caml_new_string("KeyE"),
     cst_KeyF=caml_new_string("KeyF"),
     cst_KeyG=caml_new_string("KeyG"),
     cst_Numpad4=caml_new_string("Numpad4"),
     cst_KeyX=caml_new_string("KeyX"),
     cst_KeyP=caml_new_string("KeyP"),
     cst_KeyI=caml_new_string("KeyI"),
     cst_KeyJ=caml_new_string("KeyJ"),
     cst_KeyK=caml_new_string("KeyK"),
     cst_KeyL=caml_new_string("KeyL"),
     cst_KeyM=caml_new_string("KeyM"),
     cst_KeyN=caml_new_string("KeyN"),
     cst_KeyO=caml_new_string("KeyO"),
     cst_KeyQ=caml_new_string("KeyQ"),
     cst_KeyR=caml_new_string("KeyR"),
     cst_KeyS=caml_new_string("KeyS"),
     cst_KeyT=caml_new_string("KeyT"),
     cst_KeyU=caml_new_string("KeyU"),
     cst_KeyV=caml_new_string("KeyV"),
     cst_KeyW=caml_new_string("KeyW"),
     cst_MetaRight=caml_new_string("MetaRight"),
     cst_KeyY=caml_new_string("KeyY"),
     cst_KeyZ=caml_new_string("KeyZ"),
     cst_MediaPlayPause=caml_new_string("MediaPlayPause"),
     cst_MediaStop=caml_new_string("MediaStop"),
     cst_MediaTrackNext=caml_new_string("MediaTrackNext"),
     cst_MediaTrackPrevious=caml_new_string("MediaTrackPrevious"),
     cst_MetaLeft=caml_new_string("MetaLeft"),
     cst_Minus=caml_new_string("Minus"),
     cst_NumLock=caml_new_string("NumLock"),
     cst_Numpad0=caml_new_string("Numpad0"),
     cst_Numpad1=caml_new_string("Numpad1"),
     cst_Numpad2=caml_new_string("Numpad2"),
     cst_Numpad3=caml_new_string("Numpad3"),
     cst_PageUp=caml_new_string("PageUp"),
     cst_NumpadDivide=caml_new_string("NumpadDivide"),
     cst_Numpad5=caml_new_string("Numpad5"),
     cst_Numpad6=caml_new_string("Numpad6"),
     cst_Numpad7=caml_new_string("Numpad7"),
     cst_Numpad8=caml_new_string("Numpad8"),
     cst_Numpad9=caml_new_string("Numpad9"),
     cst_NumpadAdd=caml_new_string("NumpadAdd"),
     cst_NumpadDecimal=caml_new_string("NumpadDecimal"),
     cst_NumpadEnter=caml_new_string("NumpadEnter"),
     cst_NumpadEqual=caml_new_string("NumpadEqual"),
     cst_NumpadMultiply=caml_new_string("NumpadMultiply"),
     cst_NumpadSubtract=caml_new_string("NumpadSubtract"),
     cst_OSLeft=caml_new_string("OSLeft"),
     cst_OSRight=caml_new_string("OSRight"),
     cst_PageDown=caml_new_string("PageDown"),
     cst_ShiftRight=caml_new_string("ShiftRight"),
     cst_Pause=caml_new_string("Pause"),
     cst_Period=caml_new_string("Period"),
     cst_PrintScreen=caml_new_string("PrintScreen"),
     cst_Quote=caml_new_string("Quote"),
     cst_ScrollLock=caml_new_string("ScrollLock"),
     cst_Semicolon=caml_new_string("Semicolon"),
     cst_ShiftLeft=caml_new_string("ShiftLeft"),
     cst_Slash=caml_new_string("Slash"),
     cst_Space=caml_new_string("Space"),
     cst_Tab=caml_new_string("Tab"),
     cst_VolumeDown=caml_new_string("VolumeDown"),
     cst_VolumeMute=caml_new_string("VolumeMute"),
     cst_VolumeUp=caml_new_string("VolumeUp"),
     cst_mouseout$0=caml_new_string("mouseout"),
     cst_mouseover$0=caml_new_string("mouseover"),
     cst_video$0=caml_new_string("video"),
     cst_audio$0=caml_new_string("audio"),
     cst_ul$0=caml_new_string("ul"),
     cst_tr$0=caml_new_string("tr"),
     cst_title$0=caml_new_string("title"),
     cst_thead$0=caml_new_string("thead"),
     cst_th$0=caml_new_string("th"),
     cst_tfoot$0=caml_new_string("tfoot"),
     cst_textarea$0=caml_new_string("textarea"),
     cst_td$0=caml_new_string("td"),
     cst_tbody$0=caml_new_string("tbody"),
     cst_table$0=caml_new_string("table"),
     cst_style$0=caml_new_string("style"),
     cst_select$1=caml_new_string("select"),
     cst_script$0=caml_new_string("script"),
     cst_q$0=caml_new_string("q"),
     cst_pre$0=caml_new_string("pre"),
     cst_param$0=caml_new_string("param"),
     cst_p$0=caml_new_string("p"),
     cst_option$0=caml_new_string("option"),
     cst_optgroup$0=caml_new_string("optgroup"),
     cst_ol$0=caml_new_string("ol"),
     cst_object$0=caml_new_string("object"),
     cst_meta$0=caml_new_string("meta"),
     cst_map$0=caml_new_string("map"),
     cst_link$0=caml_new_string("link"),
     cst_li$0=caml_new_string("li"),
     cst_legend$0=caml_new_string("legend"),
     cst_label$0=caml_new_string("label"),
     cst_ins$0=caml_new_string("ins"),
     cst_input$1=caml_new_string("input"),
     cst_img$0=caml_new_string("img"),
     cst_iframe$0=caml_new_string("iframe"),
     cst_html$0=caml_new_string("html"),
     cst_hr$0=caml_new_string("hr"),
     cst_head$0=caml_new_string("head"),
     cst_h6$0=caml_new_string("h6"),
     cst_h5$0=caml_new_string("h5"),
     cst_h4$0=caml_new_string("h4"),
     cst_h3$0=caml_new_string("h3"),
     cst_h2$0=caml_new_string("h2"),
     cst_h1$0=caml_new_string("h1"),
     cst_frame$0=caml_new_string("frame"),
     cst_frameset$0=caml_new_string("frameset"),
     cst_form$0=caml_new_string("form"),
     cst_embed$0=caml_new_string("embed"),
     cst_fieldset$0=caml_new_string("fieldset"),
     cst_dl$0=caml_new_string("dl"),
     cst_div$0=caml_new_string("div"),
     cst_del$0=caml_new_string("del"),
     cst_colgroup$0=caml_new_string("colgroup"),
     cst_col$0=caml_new_string("col"),
     cst_caption$0=caml_new_string("caption"),
     cst_canvas$0=caml_new_string("canvas"),
     cst_button$0=caml_new_string("button"),
     cst_br$0=caml_new_string("br"),
     cst_body$0=caml_new_string("body"),
     cst_blockquote$0=caml_new_string("blockquote"),
     cst_base$0=caml_new_string("base"),
     cst_area$0=caml_new_string("area"),
     cst_a$0=caml_new_string("a"),
     cst_canvas=caml_new_string("canvas"),
     cst_video=caml_new_string("video"),
     cst_audio=caml_new_string("audio"),
     cst_iframe=caml_new_string("iframe"),
     cst_frame=caml_new_string("frame"),
     cst_frameset=caml_new_string("frameset"),
     cst_address=caml_new_string("address"),
     cst_noscript=caml_new_string("noscript"),
     cst_dt=caml_new_string("dt"),
     cst_dd=caml_new_string("dd"),
     cst_abbr=caml_new_string("abbr"),
     cst_var=caml_new_string("var"),
     cst_kbd=caml_new_string("kbd"),
     cst_samp=caml_new_string("samp"),
     cst_code=caml_new_string("code"),
     cst_dfn=caml_new_string("dfn"),
     cst_cite=caml_new_string("cite"),
     cst_strong=caml_new_string("strong"),
     cst_em=caml_new_string("em"),
     cst_small=caml_new_string("small"),
     cst_big=caml_new_string("big"),
     cst_b=caml_new_string("b"),
     cst_i=caml_new_string("i"),
     cst_tt=caml_new_string("tt"),
     cst_span=caml_new_string("span"),
     cst_sup=caml_new_string("sup"),
     cst_sub=caml_new_string("sub"),
     cst_td=caml_new_string("td"),
     cst_th=caml_new_string("th"),
     cst_tr=caml_new_string("tr"),
     cst_tbody=caml_new_string("tbody"),
     cst_tfoot=caml_new_string("tfoot"),
     cst_thead=caml_new_string("thead"),
     cst_colgroup=caml_new_string("colgroup"),
     cst_col=caml_new_string("col"),
     cst_caption=caml_new_string("caption"),
     cst_table=caml_new_string("table"),
     cst_script=caml_new_string("script"),
     cst_area=caml_new_string("area"),
     cst_map=caml_new_string("map"),
     cst_param=caml_new_string("param"),
     cst_object=caml_new_string("object"),
     cst_img=caml_new_string("img"),
     cst_a=caml_new_string("a"),
     cst_del=caml_new_string("del"),
     cst_ins=caml_new_string("ins"),
     cst_hr=caml_new_string("hr"),
     cst_br=caml_new_string("br"),
     cst_pre=caml_new_string("pre"),
     cst_blockquote=caml_new_string("blockquote"),
     cst_q=caml_new_string("q"),
     cst_h6=caml_new_string("h6"),
     cst_h5=caml_new_string("h5"),
     cst_h4=caml_new_string("h4"),
     cst_h3=caml_new_string("h3"),
     cst_h2=caml_new_string("h2"),
     cst_h1=caml_new_string("h1"),
     cst_p=caml_new_string("p"),
     cst_embed=caml_new_string("embed"),
     cst_div=caml_new_string("div"),
     cst_li=caml_new_string("li"),
     cst_dl=caml_new_string("dl"),
     cst_ol=caml_new_string("ol"),
     cst_ul=caml_new_string("ul"),
     cst_legend=caml_new_string("legend"),
     cst_fieldset=caml_new_string("fieldset"),
     cst_label=caml_new_string("label"),
     cst_button=caml_new_string("button"),
     cst_textarea=caml_new_string("textarea"),
     cst_input$0=caml_new_string("input"),
     cst_select$0=caml_new_string("select"),
     cst_option=caml_new_string("option"),
     cst_optgroup=caml_new_string("optgroup"),
     cst_form=caml_new_string("form"),
     cst_body=caml_new_string("body"),
     cst_style=caml_new_string("style"),
     cst_base=caml_new_string("base"),
     cst_meta=caml_new_string("meta"),
     cst_title=caml_new_string("title"),
     cst_link=caml_new_string("link"),
     cst_head=caml_new_string("head"),
     cst_html=caml_new_string("html"),
     cst_click=caml_new_string("click"),
     cst_dblclick=caml_new_string("dblclick"),
     cst_mousedown=caml_new_string("mousedown"),
     cst_mouseup=caml_new_string("mouseup"),
     cst_mouseover=caml_new_string("mouseover"),
     cst_mousemove=caml_new_string("mousemove"),
     cst_mouseout=caml_new_string("mouseout"),
     cst_keypress=caml_new_string("keypress"),
     cst_keydown=caml_new_string("keydown"),
     cst_keyup=caml_new_string("keyup"),
     cst_mousewheel=caml_new_string("mousewheel"),
     cst_DOMMouseScroll=caml_new_string("DOMMouseScroll"),
     cst_touchstart=caml_new_string("touchstart"),
     cst_touchmove=caml_new_string("touchmove"),
     cst_touchend=caml_new_string("touchend"),
     cst_touchcancel=caml_new_string("touchcancel"),
     cst_dragstart=caml_new_string("dragstart"),
     cst_dragend=caml_new_string("dragend"),
     cst_dragenter=caml_new_string("dragenter"),
     cst_dragover=caml_new_string("dragover"),
     cst_dragleave=caml_new_string("dragleave"),
     cst_drag=caml_new_string("drag"),
     cst_drop=caml_new_string("drop"),
     cst_hashchange=caml_new_string("hashchange"),
     cst_change=caml_new_string("change"),
     cst_input=caml_new_string("input"),
     cst_timeupdate=caml_new_string("timeupdate"),
     cst_submit=caml_new_string("submit"),
     cst_scroll=caml_new_string("scroll"),
     cst_focus=caml_new_string("focus"),
     cst_blur=caml_new_string("blur"),
     cst_load$0=caml_new_string("load"),
     cst_unload=caml_new_string("unload"),
     cst_beforeunload=caml_new_string("beforeunload"),
     cst_resize=caml_new_string("resize"),
     cst_orientationchange=caml_new_string("orientationchange"),
     cst_popstate=caml_new_string("popstate"),
     cst_error$0=caml_new_string("error"),
     cst_abort$0=caml_new_string("abort"),
     cst_select=caml_new_string("select"),
     cst_online=caml_new_string("online"),
     cst_offline=caml_new_string("offline"),
     cst_checking=caml_new_string("checking"),
     cst_noupdate=caml_new_string("noupdate"),
     cst_downloading=caml_new_string("downloading"),
     cst_progress$0=caml_new_string("progress"),
     cst_updateready=caml_new_string("updateready"),
     cst_cached=caml_new_string("cached"),
     cst_obsolete=caml_new_string("obsolete"),
     cst_DOMContentLoaded=caml_new_string("DOMContentLoaded"),
     cst_animationstart=caml_new_string("animationstart"),
     cst_animationend=caml_new_string("animationend"),
     cst_animationiteration=caml_new_string("animationiteration"),
     cst_animationcancel=caml_new_string("animationcancel"),
     cst_canplay=caml_new_string("canplay"),
     cst_canplaythrough=caml_new_string("canplaythrough"),
     cst_durationchange=caml_new_string("durationchange"),
     cst_emptied=caml_new_string("emptied"),
     cst_ended=caml_new_string("ended"),
     cst_gotpointercapture=caml_new_string("gotpointercapture"),
     cst_loadeddata=caml_new_string("loadeddata"),
     cst_loadedmetadata=caml_new_string("loadedmetadata"),
     cst_loadstart$0=caml_new_string("loadstart"),
     cst_lostpointercapture=caml_new_string("lostpointercapture"),
     cst_pause=caml_new_string("pause"),
     cst_play=caml_new_string("play"),
     cst_playing=caml_new_string("playing"),
     cst_pointerenter=caml_new_string("pointerenter"),
     cst_pointercancel=caml_new_string("pointercancel"),
     cst_pointerdown=caml_new_string("pointerdown"),
     cst_pointerleave=caml_new_string("pointerleave"),
     cst_pointermove=caml_new_string("pointermove"),
     cst_pointerout=caml_new_string("pointerout"),
     cst_pointerover=caml_new_string("pointerover"),
     cst_pointerup=caml_new_string("pointerup"),
     cst_ratechange=caml_new_string("ratechange"),
     cst_seeked=caml_new_string("seeked"),
     cst_seeking=caml_new_string("seeking"),
     cst_stalled=caml_new_string("stalled"),
     cst_suspend=caml_new_string("suspend"),
     cst_volumechange=caml_new_string("volumechange"),
     cst_waiting=caml_new_string("waiting"),
     cst_Js_of_ocaml_Dom_html_Canvas_not_available=
      caml_new_string("Js_of_ocaml__Dom_html.Canvas_not_available"),
     cst_checkbox=caml_new_string("checkbox"),
     cst_file=caml_new_string("file"),
     cst_password=caml_new_string("password"),
     cst_radio=caml_new_string("radio"),
     cst_reset=caml_new_string("reset"),
     cst_submit$0=caml_new_string("submit"),
     cst_text=caml_new_string("text"),
     cst_readystatechange=caml_new_string("readystatechange"),
     cst_loadstart$1=caml_new_string("loadstart"),
     cst_progress$1=caml_new_string("progress"),
     cst_abort$1=caml_new_string("abort"),
     cst_error$1=caml_new_string("error"),
     cst_load$1=caml_new_string("load"),
     cst_timeout=caml_new_string("timeout"),
     cst_loadend$0=caml_new_string("loadend"),
     cst_Worker_onmessage_is_undefined$0=
      caml_new_string("Worker.onmessage is undefined"),
     cst_Worker_onmessage_is_undefined=
      caml_new_string("Worker.onmessage is undefined"),
     cst_Worker_import_scripts_is_undefined=
      caml_new_string("Worker.import_scripts is undefined"),
     cst_webglcontextlost=caml_new_string("webglcontextlost"),
     cst_webglcontextrestored=caml_new_string("webglcontextrestored"),
     cst_webglcontextcreationerror=
      caml_new_string("webglcontextcreationerror"),
     cst_g=caml_new_string("g"),
     cst=caml_new_string("[\\][()\\\\|+*.?{}^$]"),
     cst$37=caml_new_string(""),
     cst$13=caml_new_string(""),
     cst$21=caml_new_string(""),
     cst$14=caml_new_string("#"),
     cst$15=caml_new_string("?"),
     cst$20=caml_new_string(""),
     cst$16=caml_new_string("/"),
     cst$17=caml_new_string("/"),
     cst$19=caml_new_string(":"),
     cst$18=caml_new_string(""),
     cst_http$1=caml_new_string("http://"),
     cst$22=caml_new_string(""),
     cst$30=caml_new_string(""),
     cst$23=caml_new_string("#"),
     cst$24=caml_new_string("?"),
     cst$29=caml_new_string(""),
     cst$25=caml_new_string("/"),
     cst$26=caml_new_string("/"),
     cst$28=caml_new_string(":"),
     cst$27=caml_new_string(""),
     cst_https$1=caml_new_string("https://"),
     cst$31=caml_new_string(""),
     cst$36=caml_new_string(""),
     cst$32=caml_new_string("#"),
     cst$33=caml_new_string("?"),
     cst$35=caml_new_string(""),
     cst$34=caml_new_string("/"),
     cst_file$2=caml_new_string("file://"),
     cst$12=caml_new_string(""),
     cst$11=caml_new_string(""),
     cst$10=caml_new_string(""),
     cst$9=caml_new_string(""),
     cst$8=caml_new_string(""),
     cst$7=caml_new_string(""),
     cst$6=caml_new_string(""),
     cst$4=caml_new_string("="),
     cst$5=caml_new_string("&"),
     cst$2=caml_new_string(""),
     cst$3=caml_new_string(""),
     cst_file$0=caml_new_string("file"),
     cst_file$1=caml_new_string("file:"),
     cst_http=caml_new_string("http"),
     cst_http$0=caml_new_string("http:"),
     cst_https=caml_new_string("https"),
     cst_https$0=caml_new_string("https:"),
     cst$1=caml_new_string(" "),
     cst_2B=caml_new_string("%2B"),
     cst_Js_of_ocaml_Url_Local_exn=
      caml_new_string("Js_of_ocaml__Url.Local_exn"),
     cst$0=caml_new_string("+"),
     cst_Js_of_ocaml_Url_Not_an_http_protocol=
      caml_new_string("Js_of_ocaml__Url.Not_an_http_protocol"),
     cst_Hh_Tt_Tt_Pp_Ss_0_9a_zA_Z_0_9a_zA_Z_0_9A_Fa_f_0_9=
      caml_new_string
       ("^([Hh][Tt][Tt][Pp][Ss]?)://([0-9a-zA-Z.-]+|\\[[0-9a-zA-Z.-]+\\]|\\[[0-9A-Fa-f:.]+\\])?(:([0-9]+))?(/([^\\?#]*)(\\?([^#]*))?(#(.*))?)?$"),
     cst_Ff_Ii_Ll_Ee=
      caml_new_string
       ("^([Ff][Ii][Ll][Ee])://([^\\?#]*)(\\?([^#]*))?(#(.*))?$"),
     s=caml_new_string("3.5.2"),
     git_version=caml_new_string(""),
     cst$38=caml_new_string(""),
     cst$41=caml_new_string("+"),
     cst_Jstable_keys=caml_new_string("Jstable.keys"),
     dummy_string=caml_new_string(""),
     cst_is_not_a_valid_length$0=caml_new_string(" is not a valid length"),
     cst_d_d_deg_grad_rad_turns=
      caml_new_string("^(\\d*(?:\\.\\d*))(deg|grad|rad|turns)$"),
     cst_length_conversion_error$0=
      caml_new_string("length conversion error: "),
     cst_deg$0=caml_new_string("deg"),
     cst_grad$0=caml_new_string("grad"),
     cst_rad$0=caml_new_string("rad"),
     cst_turns$0=caml_new_string("turns"),
     cst_deg=caml_new_string("deg"),
     cst_grad=caml_new_string("grad"),
     cst_rad=caml_new_string("rad"),
     cst_turns=caml_new_string("turns"),
     cst_is_not_a_valid_length=caml_new_string(" is not a valid length"),
     cst_0$0=caml_new_string("0"),
     cst_d_d_s_S=caml_new_string("^(\\d*(?:\\.\\d*)?)\\s*(\\S*)$"),
     cst_length_conversion_error=caml_new_string("length conversion error: "),
     cst_pc$0=caml_new_string("pc"),
     cst_ch$0=caml_new_string("ch"),
     cst_cm$0=caml_new_string("cm"),
     cst_em$1=caml_new_string("em"),
     cst_ex$0=caml_new_string("ex"),
     cst_gd$0=caml_new_string("gd"),
     cst_in$0=caml_new_string("in"),
     cst_mm$0=caml_new_string("mm"),
     cst_pt$0=caml_new_string("pt"),
     cst_px$0=caml_new_string("px"),
     cst_rem$0=caml_new_string("rem"),
     cst_vh$0=caml_new_string("vh"),
     cst_vm$0=caml_new_string("vm"),
     cst_vw$0=caml_new_string("vw"),
     cst_0=caml_new_string("0"),
     cst_em$0=caml_new_string("em"),
     cst_ex=caml_new_string("ex"),
     cst_px=caml_new_string("px"),
     cst_gd=caml_new_string("gd"),
     cst_rem=caml_new_string("rem"),
     cst_vw=caml_new_string("vw"),
     cst_vh=caml_new_string("vh"),
     cst_vm=caml_new_string("vm"),
     cst_ch=caml_new_string("ch"),
     cst_mm=caml_new_string("mm"),
     cst_cm=caml_new_string("cm"),
     cst_in=caml_new_string("in"),
     cst_pt=caml_new_string("pt"),
     cst_pc=caml_new_string("pc"),
     cst$40=caml_new_string("): "),
     cst_color_conversion_error$0=caml_new_string("color conversion error ("),
     cst$39=caml_new_string("): "),
     cst_color_conversion_error=caml_new_string("color conversion error ("),
     cst_is_not_a_valid_color$0=caml_new_string(" is not a valid color"),
     cst_rgba_d_d_d_d_d=
      caml_new_string
       ("(rgba?)\\((?:(\\d*),(\\d*),(\\d*)(?:,(\\d*(?:\\.\\d*)?))?)\\)"),
     cst_rgba_d_d_d_d_d$0=
      caml_new_string
       ("(rgba?)\\((?:(\\d*)%,(\\d*)%,(\\d*)%(?:,(\\d*(?:\\.\\d*)?))?)\\)"),
     cst_hsla_d_d_d_d_d=
      caml_new_string
       ("(hsla?)\\((?:(\\d*),(\\d*)%,(\\d*)%(?:,(\\d*(?:\\.\\d*)?))?)\\)"),
     cst_rgb=caml_new_string("rgb"),
     cst_rgba=caml_new_string("rgba"),
     cst_rgb$0=caml_new_string("rgb"),
     cst_rgba$0=caml_new_string("rgba"),
     cst_hsl=caml_new_string("hsl"),
     cst_hsla=caml_new_string("hsla"),
     cst_rgb_s_d_s_d_s_d=
      caml_new_string("^rgb\\(\\s*\\d*,\\s*\\d*,\\s*\\d*\\)$"),
     cst_rgb_s_d_s_d_s_d$0=
      caml_new_string("^rgb\\(\\s*\\d*%,\\s*\\d*%,\\s*\\d*%\\)$"),
     cst_rgba_s_d_s_d_s_d_d_d=
      caml_new_string("^rgba\\(\\s*\\d*,\\s*\\d*,\\s*\\d*,\\d*\\.?\\d*\\)$"),
     cst_rgba_s_d_s_d_s_d_d_d$0=
      caml_new_string
       ("^rgba\\(\\s*\\d*%,\\s*\\d*%,\\s*\\d*%,\\d*\\.?\\d*\\)$"),
     cst_hsl_s_d_s_d_s_d=
      caml_new_string("^hsl\\(\\s*\\d*,\\s*\\d*%,\\s*\\d*%\\)$"),
     cst_hsla_s_d_s_d_s_d_d_d=
      caml_new_string("^hsla\\(\\s*\\d*,\\s*\\d*%,\\s*\\d*%,\\d*\\.?\\d*\\)$"),
     cst_is_not_a_valid_color=caml_new_string(" is not a valid color"),
     cst_is_out_of_valid_range=caml_new_string(" is out of valid range"),
     partial=[8,0,0,0,[12,41,0]],
     partial$0=[12,41,0],
     cst_lightgrey$0=caml_new_string("lightgrey"),
     cst_darkslategray$0=caml_new_string("darkslategray"),
     cst_cornsilk$0=caml_new_string("cornsilk"),
     cst_blue$0=caml_new_string("blue"),
     cst_aliceblue$0=caml_new_string("aliceblue"),
     cst_antiquewhite$0=caml_new_string("antiquewhite"),
     cst_aqua$0=caml_new_string("aqua"),
     cst_aquamarine$0=caml_new_string("aquamarine"),
     cst_azure$0=caml_new_string("azure"),
     cst_beige$0=caml_new_string("beige"),
     cst_bisque$0=caml_new_string("bisque"),
     cst_black$0=caml_new_string("black"),
     cst_blanchedalmond$0=caml_new_string("blanchedalmond"),
     cst_blueviolet$0=caml_new_string("blueviolet"),
     cst_brown$0=caml_new_string("brown"),
     cst_burlywood$0=caml_new_string("burlywood"),
     cst_cadetblue$0=caml_new_string("cadetblue"),
     cst_chartreuse$0=caml_new_string("chartreuse"),
     cst_chocolate$0=caml_new_string("chocolate"),
     cst_coral$0=caml_new_string("coral"),
     cst_cornflowerblue$0=caml_new_string("cornflowerblue"),
     cst_darkkhaki$0=caml_new_string("darkkhaki"),
     cst_crimson$0=caml_new_string("crimson"),
     cst_cyan$0=caml_new_string("cyan"),
     cst_darkblue$0=caml_new_string("darkblue"),
     cst_darkcyan$0=caml_new_string("darkcyan"),
     cst_darkgoldenrod$0=caml_new_string("darkgoldenrod"),
     cst_darkgray$0=caml_new_string("darkgray"),
     cst_darkgreen$0=caml_new_string("darkgreen"),
     cst_darkgrey$0=caml_new_string("darkgrey"),
     cst_darkmagenta$0=caml_new_string("darkmagenta"),
     cst_darkolivegreen$0=caml_new_string("darkolivegreen"),
     cst_darkorange$0=caml_new_string("darkorange"),
     cst_darkorchid$0=caml_new_string("darkorchid"),
     cst_darkred$0=caml_new_string("darkred"),
     cst_darksalmon$0=caml_new_string("darksalmon"),
     cst_darkseagreen$0=caml_new_string("darkseagreen"),
     cst_darkslateblue$0=caml_new_string("darkslateblue"),
     cst_greenyellow$0=caml_new_string("greenyellow"),
     cst_floralwhite$0=caml_new_string("floralwhite"),
     cst_darkslategrey$0=caml_new_string("darkslategrey"),
     cst_darkturquoise$0=caml_new_string("darkturquoise"),
     cst_darkviolet$0=caml_new_string("darkviolet"),
     cst_deeppink$0=caml_new_string("deeppink"),
     cst_deepskyblue$0=caml_new_string("deepskyblue"),
     cst_dimgray$0=caml_new_string("dimgray"),
     cst_dimgrey$0=caml_new_string("dimgrey"),
     cst_dodgerblue$0=caml_new_string("dodgerblue"),
     cst_firebrick$0=caml_new_string("firebrick"),
     cst_forestgreen$0=caml_new_string("forestgreen"),
     cst_fuchsia$0=caml_new_string("fuchsia"),
     cst_gainsboro$0=caml_new_string("gainsboro"),
     cst_ghostwhite$0=caml_new_string("ghostwhite"),
     cst_gold$0=caml_new_string("gold"),
     cst_goldenrod$0=caml_new_string("goldenrod"),
     cst_gray$0=caml_new_string("gray"),
     cst_green$0=caml_new_string("green"),
     cst_lavenderblush$0=caml_new_string("lavenderblush"),
     cst_grey$0=caml_new_string("grey"),
     cst_honeydew$0=caml_new_string("honeydew"),
     cst_hotpink$0=caml_new_string("hotpink"),
     cst_indianred$0=caml_new_string("indianred"),
     cst_indigo$0=caml_new_string("indigo"),
     cst_ivory$0=caml_new_string("ivory"),
     cst_khaki$0=caml_new_string("khaki"),
     cst_lavender$0=caml_new_string("lavender"),
     cst_lawngreen$0=caml_new_string("lawngreen"),
     cst_lemonchiffon$0=caml_new_string("lemonchiffon"),
     cst_lightblue$0=caml_new_string("lightblue"),
     cst_lightcoral$0=caml_new_string("lightcoral"),
     cst_lightcyan$0=caml_new_string("lightcyan"),
     cst_lightgoldenrodyellow$0=caml_new_string("lightgoldenrodyellow"),
     cst_lightgray$0=caml_new_string("lightgray"),
     cst_lightgreen$0=caml_new_string("lightgreen"),
     cst_paleturquoise$0=caml_new_string("paleturquoise"),
     cst_mediumslateblue$0=caml_new_string("mediumslateblue"),
     cst_limegreen$0=caml_new_string("limegreen"),
     cst_lightpink$0=caml_new_string("lightpink"),
     cst_lightsalmon$0=caml_new_string("lightsalmon"),
     cst_lightseagreen$0=caml_new_string("lightseagreen"),
     cst_lightskyblue$0=caml_new_string("lightskyblue"),
     cst_lightslategray$0=caml_new_string("lightslategray"),
     cst_lightslategrey$0=caml_new_string("lightslategrey"),
     cst_lightsteelblue$0=caml_new_string("lightsteelblue"),
     cst_lightyellow$0=caml_new_string("lightyellow"),
     cst_lime$0=caml_new_string("lime"),
     cst_linen$0=caml_new_string("linen"),
     cst_magenta$0=caml_new_string("magenta"),
     cst_maroon$0=caml_new_string("maroon"),
     cst_mediumaquamarine$0=caml_new_string("mediumaquamarine"),
     cst_mediumblue$0=caml_new_string("mediumblue"),
     cst_mediumorchid$0=caml_new_string("mediumorchid"),
     cst_mediumpurple$0=caml_new_string("mediumpurple"),
     cst_mediumseagreen$0=caml_new_string("mediumseagreen"),
     cst_navy$0=caml_new_string("navy"),
     cst_mediumspringgreen$0=caml_new_string("mediumspringgreen"),
     cst_mediumturquoise$0=caml_new_string("mediumturquoise"),
     cst_mediumvioletred$0=caml_new_string("mediumvioletred"),
     cst_midnightblue$0=caml_new_string("midnightblue"),
     cst_mintcream$0=caml_new_string("mintcream"),
     cst_mistyrose$0=caml_new_string("mistyrose"),
     cst_moccasin$0=caml_new_string("moccasin"),
     cst_navajowhite$0=caml_new_string("navajowhite"),
     cst_oldlace$0=caml_new_string("oldlace"),
     cst_olive$0=caml_new_string("olive"),
     cst_olivedrab$0=caml_new_string("olivedrab"),
     cst_orange$0=caml_new_string("orange"),
     cst_orangered$0=caml_new_string("orangered"),
     cst_orchid$0=caml_new_string("orchid"),
     cst_palegoldenrod$0=caml_new_string("palegoldenrod"),
     cst_palegreen$0=caml_new_string("palegreen"),
     cst_skyblue$0=caml_new_string("skyblue"),
     cst_rosybrown$0=caml_new_string("rosybrown"),
     cst_palevioletred$0=caml_new_string("palevioletred"),
     cst_papayawhip$0=caml_new_string("papayawhip"),
     cst_peachpuff$0=caml_new_string("peachpuff"),
     cst_peru$0=caml_new_string("peru"),
     cst_pink$0=caml_new_string("pink"),
     cst_plum$0=caml_new_string("plum"),
     cst_powderblue$0=caml_new_string("powderblue"),
     cst_purple$0=caml_new_string("purple"),
     cst_red$0=caml_new_string("red"),
     cst_royalblue$0=caml_new_string("royalblue"),
     cst_saddlebrown$0=caml_new_string("saddlebrown"),
     cst_salmon$0=caml_new_string("salmon"),
     cst_sandybrown$0=caml_new_string("sandybrown"),
     cst_seagreen$0=caml_new_string("seagreen"),
     cst_seashell$0=caml_new_string("seashell"),
     cst_sienna$0=caml_new_string("sienna"),
     cst_silver$0=caml_new_string("silver"),
     cst_thistle$0=caml_new_string("thistle"),
     cst_slateblue$0=caml_new_string("slateblue"),
     cst_slategray$0=caml_new_string("slategray"),
     cst_slategrey$0=caml_new_string("slategrey"),
     cst_snow$0=caml_new_string("snow"),
     cst_springgreen$0=caml_new_string("springgreen"),
     cst_steelblue$0=caml_new_string("steelblue"),
     cst_tan$0=caml_new_string("tan"),
     cst_teal$0=caml_new_string("teal"),
     cst_tomato$0=caml_new_string("tomato"),
     cst_turquoise$0=caml_new_string("turquoise"),
     cst_violet$0=caml_new_string("violet"),
     cst_wheat$0=caml_new_string("wheat"),
     cst_white$0=caml_new_string("white"),
     cst_whitesmoke$0=caml_new_string("whitesmoke"),
     cst_yellow$0=caml_new_string("yellow"),
     cst_yellowgreen$0=caml_new_string("yellowgreen"),
     cst_is_not_a_valid_color_name=
      caml_new_string(" is not a valid color name"),
     cst_aliceblue=caml_new_string("aliceblue"),
     cst_antiquewhite=caml_new_string("antiquewhite"),
     cst_aqua=caml_new_string("aqua"),
     cst_aquamarine=caml_new_string("aquamarine"),
     cst_azure=caml_new_string("azure"),
     cst_beige=caml_new_string("beige"),
     cst_bisque=caml_new_string("bisque"),
     cst_black=caml_new_string("black"),
     cst_blanchedalmond=caml_new_string("blanchedalmond"),
     cst_blue=caml_new_string("blue"),
     cst_blueviolet=caml_new_string("blueviolet"),
     cst_brown=caml_new_string("brown"),
     cst_burlywood=caml_new_string("burlywood"),
     cst_cadetblue=caml_new_string("cadetblue"),
     cst_chartreuse=caml_new_string("chartreuse"),
     cst_chocolate=caml_new_string("chocolate"),
     cst_coral=caml_new_string("coral"),
     cst_cornflowerblue=caml_new_string("cornflowerblue"),
     cst_cornsilk=caml_new_string("cornsilk"),
     cst_crimson=caml_new_string("crimson"),
     cst_cyan=caml_new_string("cyan"),
     cst_darkblue=caml_new_string("darkblue"),
     cst_darkcyan=caml_new_string("darkcyan"),
     cst_darkgoldenrod=caml_new_string("darkgoldenrod"),
     cst_darkgray=caml_new_string("darkgray"),
     cst_darkgreen=caml_new_string("darkgreen"),
     cst_darkgrey=caml_new_string("darkgrey"),
     cst_darkkhaki=caml_new_string("darkkhaki"),
     cst_darkmagenta=caml_new_string("darkmagenta"),
     cst_darkolivegreen=caml_new_string("darkolivegreen"),
     cst_darkorange=caml_new_string("darkorange"),
     cst_darkorchid=caml_new_string("darkorchid"),
     cst_darkred=caml_new_string("darkred"),
     cst_darksalmon=caml_new_string("darksalmon"),
     cst_darkseagreen=caml_new_string("darkseagreen"),
     cst_darkslateblue=caml_new_string("darkslateblue"),
     cst_darkslategray=caml_new_string("darkslategray"),
     cst_darkslategrey=caml_new_string("darkslategrey"),
     cst_darkturquoise=caml_new_string("darkturquoise"),
     cst_darkviolet=caml_new_string("darkviolet"),
     cst_deeppink=caml_new_string("deeppink"),
     cst_deepskyblue=caml_new_string("deepskyblue"),
     cst_dimgray=caml_new_string("dimgray"),
     cst_dimgrey=caml_new_string("dimgrey"),
     cst_dodgerblue=caml_new_string("dodgerblue"),
     cst_firebrick=caml_new_string("firebrick"),
     cst_floralwhite=caml_new_string("floralwhite"),
     cst_forestgreen=caml_new_string("forestgreen"),
     cst_fuchsia=caml_new_string("fuchsia"),
     cst_gainsboro=caml_new_string("gainsboro"),
     cst_ghostwhite=caml_new_string("ghostwhite"),
     cst_gold=caml_new_string("gold"),
     cst_goldenrod=caml_new_string("goldenrod"),
     cst_gray=caml_new_string("gray"),
     cst_grey=caml_new_string("grey"),
     cst_green=caml_new_string("green"),
     cst_greenyellow=caml_new_string("greenyellow"),
     cst_honeydew=caml_new_string("honeydew"),
     cst_hotpink=caml_new_string("hotpink"),
     cst_indianred=caml_new_string("indianred"),
     cst_indigo=caml_new_string("indigo"),
     cst_ivory=caml_new_string("ivory"),
     cst_khaki=caml_new_string("khaki"),
     cst_lavender=caml_new_string("lavender"),
     cst_lavenderblush=caml_new_string("lavenderblush"),
     cst_lawngreen=caml_new_string("lawngreen"),
     cst_lemonchiffon=caml_new_string("lemonchiffon"),
     cst_lightblue=caml_new_string("lightblue"),
     cst_lightcoral=caml_new_string("lightcoral"),
     cst_lightcyan=caml_new_string("lightcyan"),
     cst_lightgoldenrodyellow=caml_new_string("lightgoldenrodyellow"),
     cst_lightgray=caml_new_string("lightgray"),
     cst_lightgreen=caml_new_string("lightgreen"),
     cst_lightgrey=caml_new_string("lightgrey"),
     cst_lightpink=caml_new_string("lightpink"),
     cst_lightsalmon=caml_new_string("lightsalmon"),
     cst_lightseagreen=caml_new_string("lightseagreen"),
     cst_lightskyblue=caml_new_string("lightskyblue"),
     cst_lightslategray=caml_new_string("lightslategray"),
     cst_lightslategrey=caml_new_string("lightslategrey"),
     cst_lightsteelblue=caml_new_string("lightsteelblue"),
     cst_lightyellow=caml_new_string("lightyellow"),
     cst_lime=caml_new_string("lime"),
     cst_limegreen=caml_new_string("limegreen"),
     cst_linen=caml_new_string("linen"),
     cst_magenta=caml_new_string("magenta"),
     cst_maroon=caml_new_string("maroon"),
     cst_mediumaquamarine=caml_new_string("mediumaquamarine"),
     cst_mediumblue=caml_new_string("mediumblue"),
     cst_mediumorchid=caml_new_string("mediumorchid"),
     cst_mediumpurple=caml_new_string("mediumpurple"),
     cst_mediumseagreen=caml_new_string("mediumseagreen"),
     cst_mediumslateblue=caml_new_string("mediumslateblue"),
     cst_mediumspringgreen=caml_new_string("mediumspringgreen"),
     cst_mediumturquoise=caml_new_string("mediumturquoise"),
     cst_mediumvioletred=caml_new_string("mediumvioletred"),
     cst_midnightblue=caml_new_string("midnightblue"),
     cst_mintcream=caml_new_string("mintcream"),
     cst_mistyrose=caml_new_string("mistyrose"),
     cst_moccasin=caml_new_string("moccasin"),
     cst_navajowhite=caml_new_string("navajowhite"),
     cst_navy=caml_new_string("navy"),
     cst_oldlace=caml_new_string("oldlace"),
     cst_olive=caml_new_string("olive"),
     cst_olivedrab=caml_new_string("olivedrab"),
     cst_orange=caml_new_string("orange"),
     cst_orangered=caml_new_string("orangered"),
     cst_orchid=caml_new_string("orchid"),
     cst_palegoldenrod=caml_new_string("palegoldenrod"),
     cst_palegreen=caml_new_string("palegreen"),
     cst_paleturquoise=caml_new_string("paleturquoise"),
     cst_palevioletred=caml_new_string("palevioletred"),
     cst_papayawhip=caml_new_string("papayawhip"),
     cst_peachpuff=caml_new_string("peachpuff"),
     cst_peru=caml_new_string("peru"),
     cst_pink=caml_new_string("pink"),
     cst_plum=caml_new_string("plum"),
     cst_powderblue=caml_new_string("powderblue"),
     cst_purple=caml_new_string("purple"),
     cst_red=caml_new_string("red"),
     cst_rosybrown=caml_new_string("rosybrown"),
     cst_royalblue=caml_new_string("royalblue"),
     cst_saddlebrown=caml_new_string("saddlebrown"),
     cst_salmon=caml_new_string("salmon"),
     cst_sandybrown=caml_new_string("sandybrown"),
     cst_seagreen=caml_new_string("seagreen"),
     cst_seashell=caml_new_string("seashell"),
     cst_sienna=caml_new_string("sienna"),
     cst_silver=caml_new_string("silver"),
     cst_skyblue=caml_new_string("skyblue"),
     cst_slateblue=caml_new_string("slateblue"),
     cst_slategray=caml_new_string("slategray"),
     cst_slategrey=caml_new_string("slategrey"),
     cst_snow=caml_new_string("snow"),
     cst_springgreen=caml_new_string("springgreen"),
     cst_steelblue=caml_new_string("steelblue"),
     cst_tan=caml_new_string("tan"),
     cst_teal=caml_new_string("teal"),
     cst_thistle=caml_new_string("thistle"),
     cst_tomato=caml_new_string("tomato"),
     cst_turquoise=caml_new_string("turquoise"),
     cst_violet=caml_new_string("violet"),
     cst_wheat=caml_new_string("wheat"),
     cst_white=caml_new_string("white"),
     cst_whitesmoke=caml_new_string("whitesmoke"),
     cst_yellow=caml_new_string("yellow"),
     cst_yellowgreen=caml_new_string("yellowgreen"),
     cst_vkern$0=caml_new_string("vkern"),
     cst_view$0=caml_new_string("view"),
     cst_use$0=caml_new_string("use"),
     cst_tspan$0=caml_new_string("tspan"),
     cst_tref$0=caml_new_string("tref"),
     cst_title$3=caml_new_string("title"),
     cst_textpath$0=caml_new_string("textpath"),
     cst_text$1=caml_new_string("text"),
     cst_symbol$0=caml_new_string("symbol"),
     cst_switch$0=caml_new_string("switch"),
     cst_svg$0=caml_new_string("svg"),
     cst_style$3=caml_new_string("style"),
     cst_stop$0=caml_new_string("stop"),
     cst_set$0=caml_new_string("set"),
     cst_script$3=caml_new_string("script"),
     cst_rect$0=caml_new_string("rect"),
     cst_radialgradient$0=caml_new_string("radialgradient"),
     cst_polyline$0=caml_new_string("polyline"),
     cst_polygon$0=caml_new_string("polygon"),
     cst_pattern$0=caml_new_string("pattern"),
     cst_path$0=caml_new_string("path"),
     cst_mpath$0=caml_new_string("mpath"),
     cst_missing_glyph$0=caml_new_string("missing-glyph"),
     cst_metadata$0=caml_new_string("metadata"),
     cst_mask$0=caml_new_string("mask"),
     cst_lineargradient$0=caml_new_string("lineargradient"),
     cst_line$0=caml_new_string("line"),
     cst_image$0=caml_new_string("image"),
     cst_hkern$0=caml_new_string("hkern"),
     cst_glyphref$0=caml_new_string("glyphref"),
     cst_glyph$0=caml_new_string("glyph"),
     cst_g$1=caml_new_string("g"),
     cst_foreignobject=caml_new_string("foreignobject"),
     cst_font_face_uri$0=caml_new_string("font-face-uri"),
     cst_font_face_src$0=caml_new_string("font-face-src"),
     cst_font_face_name$0=caml_new_string("font-face-name"),
     cst_font_face_format$0=caml_new_string("font-face-format"),
     cst_font_face$0=caml_new_string("font-face"),
     cst_font$0=caml_new_string("font"),
     cst_filter$0=caml_new_string("filter"),
     cst_ellipse$0=caml_new_string("ellipse"),
     cst_desc$0=caml_new_string("desc"),
     cst_defs$0=caml_new_string("defs"),
     cst_cursor$0=caml_new_string("cursor"),
     cst_clippath$0=caml_new_string("clippath"),
     cst_circle$0=caml_new_string("circle"),
     cst_animatetransform$0=caml_new_string("animatetransform"),
     cst_animatemotion$0=caml_new_string("animatemotion"),
     cst_animatecolor$0=caml_new_string("animatecolor"),
     cst_animate$0=caml_new_string("animate"),
     cst_altglyphitem$0=caml_new_string("altglyphitem"),
     cst_altglyphdef$0=caml_new_string("altglyphdef"),
     cst_altglyph$0=caml_new_string("altglyph"),
     cst_a$3=caml_new_string("a"),
     cst_vkern=caml_new_string("vkern"),
     cst_view=caml_new_string("view"),
     cst_use=caml_new_string("use"),
     cst_tspan=caml_new_string("tspan"),
     cst_tref=caml_new_string("tref"),
     cst_title$2=caml_new_string("title"),
     cst_textpath=caml_new_string("textpath"),
     cst_text$0=caml_new_string("text"),
     cst_symbol=caml_new_string("symbol"),
     cst_switch=caml_new_string("switch"),
     cst_svg=caml_new_string("svg"),
     cst_style$2=caml_new_string("style"),
     cst_stop=caml_new_string("stop"),
     cst_set=caml_new_string("set"),
     cst_script$2=caml_new_string("script"),
     cst_rect=caml_new_string("rect"),
     cst_radialgradient=caml_new_string("radialgradient"),
     cst_polyline=caml_new_string("polyline"),
     cst_polygon=caml_new_string("polygon"),
     cst_pattern=caml_new_string("pattern"),
     cst_path=caml_new_string("path"),
     cst_mpath=caml_new_string("mpath"),
     cst_missing_glyph=caml_new_string("missing-glyph"),
     cst_metadata=caml_new_string("metadata"),
     cst_mask=caml_new_string("mask"),
     cst_lineargradient=caml_new_string("lineargradient"),
     cst_line=caml_new_string("line"),
     cst_image=caml_new_string("image"),
     cst_hkern=caml_new_string("hkern"),
     cst_glyphref=caml_new_string("glyphref"),
     cst_glyph=caml_new_string("glyph"),
     cst_g$0=caml_new_string("g"),
     cst_foreignObject=caml_new_string("foreignObject"),
     cst_font_face_uri=caml_new_string("font-face-uri"),
     cst_font_face_src=caml_new_string("font-face-src"),
     cst_font_face_name=caml_new_string("font-face-name"),
     cst_font_face_format=caml_new_string("font-face-format"),
     cst_font_face=caml_new_string("font-face"),
     cst_font=caml_new_string("font"),
     cst_filter=caml_new_string("filter"),
     cst_ellipse=caml_new_string("ellipse"),
     cst_desc=caml_new_string("desc"),
     cst_defs=caml_new_string("defs"),
     cst_cursor=caml_new_string("cursor"),
     cst_clippath=caml_new_string("clippath"),
     cst_circle=caml_new_string("circle"),
     cst_animatetransform=caml_new_string("animatetransform"),
     cst_animatemotion=caml_new_string("animatemotion"),
     cst_animatecolor=caml_new_string("animatecolor"),
     cst_animate=caml_new_string("animate"),
     cst_altglyphitem=caml_new_string("altglyphitem"),
     cst_altglyphdef=caml_new_string("altglyphdef"),
     cst_altglyph=caml_new_string("altglyph"),
     cst_a$2=caml_new_string("a"),
     cst_Js_of_ocaml_Dom_svg_SVGError=
      caml_new_string("Js_of_ocaml__Dom_svg.SVGError"),
     String=global_data.String,
     Char=global_data.Char,
     Pervasives=global_data.Pervasives,
     Callback=global_data.Callback,
     Printexc=global_data.Printexc,
     Assert_failure=global_data.Assert_failure,
     Not_found=global_data.Not_found,
     List=global_data.List,
     Array=global_data.Array,
     Uchar=global_data.Uchar,
     Printf=global_data.Printf,
     Failure=global_data.Failure,
     Invalid_argument=global_data.Invalid_argument,
     Js_of_ocaml=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
    caml_register_global(1627,Js_of_ocaml,"Js_of_ocaml__");
    var
     Poly=[0],
     _d_=[0,caml_new_string("lib/js_of_ocaml/dom.ml"),351,67],
     _e_=[0,caml_new_string("transparent")],
     _f_=[0,caml_new_string("native")],
     _j_=[0,caml_new_string("lib/js_of_ocaml/dom_html.ml"),2790,58],
     _i_=[0,caml_new_string("lib/js_of_ocaml/dom_html.ml"),2789,61],
     _h_=
      [0,
       [11,
        caml_new_string("getElementById_exn: "),
        [3,0,[11,caml_new_string(" not found"),0]]],
       caml_new_string("getElementById_exn: %S not found")],
     _l_=[0,caml_new_string("lib/js_of_ocaml/form.ml"),177,13],
     _k_=[0,1],
     _m_=[0,caml_new_string("lib/js_of_ocaml/xmlHttpRequest.ml"),129,75],
     _n_=[0,caml_new_string("lib/js_of_ocaml/regexp.ml"),34,64],
     _o_=[0,caml_new_string(""),0],
     _ci_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _cj_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _ck_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _cl_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _b6_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _b7_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _b8_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _b9_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _b__=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _b$_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _ca_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _cb_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _cc_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _cd_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _ce_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _cf_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _cg_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _ch_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _b5_=
      caml_list_of_js_array
       ([caml_new_string("aliceblue"),
         caml_new_string("antiquewhite"),
         caml_new_string("aqua"),
         caml_new_string("aquamarine"),
         caml_new_string("azure"),
         caml_new_string("beige"),
         caml_new_string("bisque"),
         caml_new_string("black"),
         caml_new_string("blanchedalmond"),
         caml_new_string("blue"),
         caml_new_string("blueviolet"),
         caml_new_string("brown"),
         caml_new_string("burlywood"),
         caml_new_string("cadetblue"),
         caml_new_string("chartreuse"),
         caml_new_string("chocolate"),
         caml_new_string("coral"),
         caml_new_string("cornflowerblue"),
         caml_new_string("cornsilk"),
         caml_new_string("crimson"),
         caml_new_string("cyan"),
         caml_new_string("darkblue"),
         caml_new_string("darkcyan"),
         caml_new_string("darkgoldenrod"),
         caml_new_string("darkgray"),
         caml_new_string("darkgreen"),
         caml_new_string("darkgrey"),
         caml_new_string("darkkhaki"),
         caml_new_string("darkmagenta"),
         caml_new_string("darkolivegreen"),
         caml_new_string("darkorange"),
         caml_new_string("darkorchid"),
         caml_new_string("darkred"),
         caml_new_string("darksalmon"),
         caml_new_string("darkseagreen"),
         caml_new_string("darkslateblue"),
         caml_new_string("darkslategray"),
         caml_new_string("darkslategrey"),
         caml_new_string("darkturquoise"),
         caml_new_string("darkviolet"),
         caml_new_string("deeppink"),
         caml_new_string("deepskyblue"),
         caml_new_string("dimgray"),
         caml_new_string("dimgrey"),
         caml_new_string("dodgerblue"),
         caml_new_string("firebrick"),
         caml_new_string("floralwhite"),
         caml_new_string("forestgreen"),
         caml_new_string("fuchsia"),
         caml_new_string("gainsboro"),
         caml_new_string("ghostwhite"),
         caml_new_string("gold"),
         caml_new_string("goldenrod"),
         caml_new_string("gray"),
         caml_new_string("green"),
         caml_new_string("greenyellow"),
         caml_new_string("grey"),
         caml_new_string("honeydew"),
         caml_new_string("hotpink"),
         caml_new_string("indianred"),
         caml_new_string("indigo"),
         caml_new_string("ivory"),
         caml_new_string("khaki"),
         caml_new_string("lavender"),
         caml_new_string("lavenderblush"),
         caml_new_string("lawngreen"),
         caml_new_string("lemonchiffon"),
         caml_new_string("lightblue"),
         caml_new_string("lightcoral"),
         caml_new_string("lightcyan"),
         caml_new_string("lightgoldenrodyellow"),
         caml_new_string("lightgray"),
         caml_new_string("lightgreen"),
         caml_new_string("lightgrey"),
         caml_new_string("lightpink"),
         caml_new_string("lightsalmon"),
         caml_new_string("lightseagreen"),
         caml_new_string("lightskyblue"),
         caml_new_string("lightslategray"),
         caml_new_string("lightslategrey"),
         caml_new_string("lightsteelblue"),
         caml_new_string("lightyellow"),
         caml_new_string("lime"),
         caml_new_string("limegreen"),
         caml_new_string("linen"),
         caml_new_string("magenta"),
         caml_new_string("maroon"),
         caml_new_string("mediumaquamarine"),
         caml_new_string("mediumblue"),
         caml_new_string("mediumorchid"),
         caml_new_string("mediumpurple"),
         caml_new_string("mediumseagreen"),
         caml_new_string("mediumslateblue"),
         caml_new_string("mediumspringgreen"),
         caml_new_string("mediumturquoise"),
         caml_new_string("mediumvioletred"),
         caml_new_string("midnightblue"),
         caml_new_string("mintcream"),
         caml_new_string("mistyrose"),
         caml_new_string("moccasin"),
         caml_new_string("navajowhite"),
         caml_new_string("navy"),
         caml_new_string("oldlace"),
         caml_new_string("olive"),
         caml_new_string("olivedrab"),
         caml_new_string("orange"),
         caml_new_string("orangered"),
         caml_new_string("orchid"),
         caml_new_string("palegoldenrod"),
         caml_new_string("palegreen"),
         caml_new_string("paleturquoise"),
         caml_new_string("palevioletred"),
         caml_new_string("papayawhip"),
         caml_new_string("peachpuff"),
         caml_new_string("peru"),
         caml_new_string("pink"),
         caml_new_string("plum"),
         caml_new_string("powderblue"),
         caml_new_string("purple"),
         caml_new_string("red"),
         caml_new_string("rosybrown"),
         caml_new_string("royalblue"),
         caml_new_string("saddlebrown"),
         caml_new_string("salmon"),
         caml_new_string("sandybrown"),
         caml_new_string("seagreen"),
         caml_new_string("seashell"),
         caml_new_string("sienna"),
         caml_new_string("silver"),
         caml_new_string("skyblue"),
         caml_new_string("slateblue"),
         caml_new_string("slategray"),
         caml_new_string("slategrey"),
         caml_new_string("snow"),
         caml_new_string("springgreen"),
         caml_new_string("steelblue"),
         caml_new_string("tan"),
         caml_new_string("teal"),
         caml_new_string("thistle"),
         caml_new_string("tomato"),
         caml_new_string("turquoise"),
         caml_new_string("violet"),
         caml_new_string("wheat"),
         caml_new_string("white"),
         caml_new_string("whitesmoke"),
         caml_new_string("yellow"),
         caml_new_string("yellowgreen")]),
     _b4_=
      [0,
       [12,35,[4,8,[0,2,2],0,[4,8,[0,2,2],0,[4,8,[0,2,2],0,0]]]],
       caml_new_string("#%02X%02X%02X")],
     _bY_=
      [0,
       [11,
        caml_new_string("rgb("),
        [4,0,0,0,[12,44,[4,0,0,0,[12,44,[4,0,0,0,[12,41,0]]]]]]],
       caml_new_string("rgb(%d,%d,%d)")],
     _bZ_=
      [0,
       [11,
        caml_new_string("rgb("),
        [4,
         0,
         0,
         0,
         [12,37,[12,44,[4,0,0,0,[12,37,[12,44,[4,0,0,0,[12,37,[12,41,0]]]]]]]]]],
       caml_new_string("rgb(%d%%,%d%%,%d%%)")],
     _b0_=
      [0,
       [11,
        caml_new_string("rgba("),
        [4,
         0,
         0,
         0,
         [12,44,[4,0,0,0,[12,44,[4,0,0,0,[12,44,[8,0,0,0,[12,41,0]]]]]]]]],
       caml_new_string("rgba(%d,%d,%d,%f)")],
     _b1_=
      [0,
       [11,
        caml_new_string("rgba("),
        [4,
         0,
         0,
         0,
         [12,
          37,
          [12,44,[4,0,0,0,[12,37,[12,44,[4,0,0,0,[12,37,[12,44,partial]]]]]]]]]],
       caml_new_string("rgba(%d%%,%d%%,%d%%,%f)")],
     _b2_=
      [0,
       [11,
        caml_new_string("hsl("),
        [4,
         0,
         0,
         0,
         [12,44,[4,0,0,0,[12,37,[12,44,[4,0,0,0,[12,37,[12,41,0]]]]]]]]],
       caml_new_string("hsl(%d,%d%%,%d%%)")],
     _b3_=
      [0,
       [11,
        caml_new_string("hsla("),
        [4,
         0,
         0,
         0,
         [12,
          44,
          [4,
           0,
           0,
           0,
           [12,37,[12,44,[4,0,0,0,[12,37,[12,44,[8,0,0,0,partial$0]]]]]]]]]],
       caml_new_string("hsla(%d,%d%%,%d%%,%f)")],
     _v_=[0,240,248,255],
     _w_=[0,250,235,215],
     _x_=[0,0,255,255],
     _y_=[0,127,255,212],
     _z_=[0,240,255,255],
     _A_=[0,245,245,220],
     _B_=[0,255,228,196],
     _C_=[0,0,0,0],
     _D_=[0,255,235,205],
     _E_=[0,0,0,255],
     _F_=[0,138,43,226],
     _G_=[0,165,42,42],
     _H_=[0,222,184,135],
     _I_=[0,95,158,160],
     _J_=[0,127,255,0],
     _K_=[0,210,105,30],
     _L_=[0,255,127,80],
     _M_=[0,100,149,237],
     _N_=[0,255,248,220],
     _O_=[0,220,20,60],
     _P_=[0,0,255,255],
     _Q_=[0,0,0,139],
     _R_=[0,0,139,139],
     _S_=[0,184,134,11],
     _T_=[0,169,169,169],
     _U_=[0,0,100,0],
     _V_=[0,169,169,169],
     _W_=[0,189,183,107],
     _X_=[0,139,0,139],
     _Y_=[0,85,107,47],
     _Z_=[0,255,140,0],
     ___=[0,153,50,204],
     _$_=[0,139,0,0],
     _aa_=[0,233,150,122],
     _ab_=[0,143,188,143],
     _ac_=[0,72,61,139],
     _ad_=[0,47,79,79],
     _ae_=[0,47,79,79],
     _af_=[0,0,206,209],
     _ag_=[0,148,0,211],
     _ah_=[0,255,20,147],
     _ai_=[0,0,191,255],
     _aj_=[0,105,105,105],
     _ak_=[0,105,105,105],
     _al_=[0,30,144,255],
     _am_=[0,178,34,34],
     _an_=[0,255,250,240],
     _ao_=[0,34,139,34],
     _ap_=[0,255,0,255],
     _aq_=[0,220,220,220],
     _ar_=[0,248,248,255],
     _as_=[0,255,215,0],
     _at_=[0,218,165,32],
     _au_=[0,128,128,128],
     _av_=[0,128,128,128],
     _aw_=[0,0,128,0],
     _ax_=[0,173,255,47],
     _ay_=[0,240,255,240],
     _az_=[0,255,105,180],
     _aA_=[0,205,92,92],
     _aB_=[0,75,0,130],
     _aC_=[0,255,255,240],
     _aD_=[0,240,230,140],
     _aE_=[0,230,230,250],
     _aF_=[0,255,240,245],
     _aG_=[0,124,252,0],
     _aH_=[0,255,250,205],
     _aI_=[0,173,216,230],
     _aJ_=[0,240,128,128],
     _aK_=[0,224,255,255],
     _aL_=[0,250,250,210],
     _aM_=[0,211,211,211],
     _aN_=[0,144,238,144],
     _aO_=[0,211,211,211],
     _aP_=[0,255,182,193],
     _aQ_=[0,255,160,122],
     _aR_=[0,32,178,170],
     _aS_=[0,135,206,250],
     _aT_=[0,119,136,153],
     _aU_=[0,119,136,153],
     _aV_=[0,176,196,222],
     _aW_=[0,255,255,224],
     _aX_=[0,0,255,0],
     _aY_=[0,50,205,50],
     _aZ_=[0,250,240,230],
     _a0_=[0,255,0,255],
     _a1_=[0,128,0,0],
     _a2_=[0,102,205,170],
     _a3_=[0,0,0,205],
     _a4_=[0,186,85,211],
     _a5_=[0,147,112,219],
     _a6_=[0,60,179,113],
     _a7_=[0,123,104,238],
     _a8_=[0,0,250,154],
     _a9_=[0,72,209,204],
     _a__=[0,199,21,133],
     _a$_=[0,25,25,112],
     _ba_=[0,245,255,250],
     _bb_=[0,255,228,225],
     _bc_=[0,255,228,181],
     _bd_=[0,255,222,173],
     _be_=[0,0,0,128],
     _bf_=[0,253,245,230],
     _bg_=[0,128,128,0],
     _bh_=[0,107,142,35],
     _bi_=[0,255,165,0],
     _bj_=[0,255,69,0],
     _bk_=[0,218,112,214],
     _bl_=[0,238,232,170],
     _bm_=[0,152,251,152],
     _bn_=[0,175,238,238],
     _bo_=[0,219,112,147],
     _bp_=[0,255,239,213],
     _bq_=[0,255,218,185],
     _br_=[0,205,133,63],
     _bs_=[0,255,192,203],
     _bt_=[0,221,160,221],
     _bu_=[0,176,224,230],
     _bv_=[0,128,0,128],
     _bw_=[0,255,0,0],
     _bx_=[0,188,143,143],
     _by_=[0,65,105,225],
     _bz_=[0,139,69,19],
     _bA_=[0,250,128,114],
     _bB_=[0,244,164,96],
     _bC_=[0,46,139,87],
     _bD_=[0,255,245,238],
     _bE_=[0,160,82,45],
     _bF_=[0,192,192,192],
     _bG_=[0,135,206,235],
     _bH_=[0,106,90,205],
     _bI_=[0,112,128,144],
     _bJ_=[0,112,128,144],
     _bK_=[0,255,250,250],
     _bL_=[0,0,255,127],
     _bM_=[0,70,130,180],
     _bN_=[0,210,180,140],
     _bO_=[0,0,128,128],
     _bP_=[0,216,191,216],
     _bQ_=[0,255,99,71],
     _bR_=[0,64,224,208],
     _bS_=[0,238,130,238],
     _bT_=[0,245,222,179],
     _bU_=[0,255,255,255],
     _bV_=[0,245,245,245],
     _bW_=[0,255,255,0],
     _bX_=[0,154,205,50];
    function symbol(x,y){return x < y?1:0}
    function symbol$0(x,y){return x <= y?1:0}
    function symbol$1(x,y){return x !== y?1:0}
    function symbol$2(x,y){return x === y?1:0}
    function symbol$3(x,y){return y < x?1:0}
    function symbol$4(x,y){return y <= x?1:0}
    var compare=runtime.caml_int_compare;
    function equal(x,y){return x === y?1:0}
    function max(x,y){return y <= x?x:y}
    function min(x,y){return x <= y?x:y}
    var
     Int_replace_polymorphic_compare=
      [0,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       compare,
       equal,
       max,
       min],
     make=String[1],
     init=String[2],
     copy=String[3],
     sub=String[4],
     fill=String[5],
     blit=String[6],
     concat=String[7],
     iter=String[8],
     iteri=String[9],
     map=String[10],
     mapi=String[11],
     trim=String[12],
     escaped=String[13],
     index=String[14],
     index_opt=String[15],
     rindex=String[16],
     rindex_opt=String[17],
     index_from=String[18],
     index_from_opt=String[19],
     rindex_from=String[20],
     rindex_from_opt=String[21],
     contains=String[22],
     contains_from=String[23],
     rcontains_from=String[24],
     uppercase=String[25],
     lowercase=String[26],
     capitalize=String[27],
     uncapitalize=String[28],
     uppercase_ascii=String[29],
     lowercase_ascii=String[30],
     capitalize_ascii=String[31],
     uncapitalize_ascii=String[32],
     compare$0=String[33],
     split_on_char=String[35],
     equal$0=runtime.caml_string_equal,
     String$0=
      [0,
       make,
       init,
       copy,
       sub,
       fill,
       blit,
       concat,
       iter,
       iteri,
       map,
       mapi,
       trim,
       escaped,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase,
       lowercase,
       capitalize,
       uncapitalize,
       uppercase_ascii,
       lowercase_ascii,
       capitalize_ascii,
       uncapitalize_ascii,
       compare$0,
       split_on_char,
       equal$0],
     chr=Char[1],
     escaped$0=Char[2],
     lowercase$0=Char[3],
     uppercase$0=Char[4],
     lowercase_ascii$0=Char[5],
     uppercase_ascii$0=Char[6],
     compare$1=Char[7];
    function equal$1(x,y){return x === y?1:0}
    var
     Char$0=
      [0,
       chr,
       escaped$0,
       lowercase$0,
       uppercase$0,
       lowercase_ascii$0,
       uppercase_ascii$0,
       compare$1,
       equal$1],
     symbol$5=Int_replace_polymorphic_compare[1],
     symbol$6=Int_replace_polymorphic_compare[2],
     symbol$7=Int_replace_polymorphic_compare[3],
     symbol$8=Int_replace_polymorphic_compare[4],
     symbol$9=Int_replace_polymorphic_compare[5],
     symbol$10=Int_replace_polymorphic_compare[6],
     compare$2=Int_replace_polymorphic_compare[7],
     equal$2=Int_replace_polymorphic_compare[8],
     max$0=Int_replace_polymorphic_compare[9],
     min$0=Int_replace_polymorphic_compare[10],
     Js_of_ocaml_Import=
      [0,
       Poly,
       Int_replace_polymorphic_compare,
       String$0,
       Char$0,
       symbol$5,
       symbol$6,
       symbol$7,
       symbol$8,
       symbol$9,
       symbol$10,
       compare$2,
       equal$2,
       max$0,
       min$0];
    caml_register_global(1630,Js_of_ocaml_Import,"Js_of_ocaml__Import");
    var
     global=joo_global_object,
     Unsafe=[0,global],
     no_handler=null,
     t37=undefined;
    function return$0(_gG_){return _gG_}
    function map$0(x,f){return x == no_handler?no_handler:caml_call1(f,x)}
    function bind(x,f){return x == no_handler?no_handler:caml_call1(f,x)}
    function test(x){return 1 - (x == no_handler?1:0)}
    function iter$0(x,f)
     {var _gF_=1 - (x == no_handler?1:0);return _gF_?caml_call1(f,x):_gF_}
    function case$0(x,f,g)
     {return x == no_handler?caml_call1(f,0):caml_call1(g,x)}
    function get(x,f){return x == no_handler?caml_call1(f,0):x}
    function option(x){if(x){var x$0=x[1];return x$0}return no_handler}
    function to_option(x)
     {function _gE_(x){return [0,x]}
      return case$0(x,function(param){return 0},_gE_)}
    var
     Opt=
      [0,
       no_handler,
       return$0,
       map$0,
       bind,
       test,
       iter$0,
       case$0,
       get,
       option,
       to_option];
    function return$1(_gD_){return _gD_}
    function map$1(x,f){return x === t37?t37:caml_call1(f,x)}
    function bind$0(x,f){return x === t37?t37:caml_call1(f,x)}
    function test$0(x){return x !== t37?1:0}
    function iter$1(x,f)
     {var _gC_=x !== t37?1:0;return _gC_?caml_call1(f,x):_gC_}
    function case$1(x,f,g){return x === t37?caml_call1(f,0):caml_call1(g,x)}
    function get$0(x,f){return x === t37?caml_call1(f,0):x}
    function option$0(x){if(x){var x$0=x[1];return x$0}return t37}
    function to_option$0(x)
     {function _gB_(x){return [0,x]}
      return case$1(x,function(param){return 0},_gB_)}
    var
     Optdef=
      [0,
       t37,
       return$1,
       map$1,
       bind$0,
       test$0,
       iter$1,
       case$1,
       get$0,
       option$0,
       to_option$0];
    function coerce(x,f,g)
     {function _gz_(param){return caml_call1(g,x)}
      var _gA_=caml_call1(f,x);
      return caml_call2(Opt[8],_gA_,_gz_)}
    function coerce_opt(x,f,g)
     {function _gx_(param){return caml_call1(g,x)}
      var _gy_=caml_call2(Opt[4],x,f);
      return caml_call2(Opt[8],_gy_,_gx_)}
    var
     true$0=true,
     false$0=false,
     string_constr=Unsafe[1].String,
     regExp_withFlags=Unsafe[1].RegExp,
     object_constructor=Unsafe[1].Object;
    function object_keys(o){return object_constructor.keys(o)}
    var
     array_length=Unsafe[1].Array,
     array_get=caml_js_get,
     array_set=caml_js_set;
    function array_map(f,a)
     {return a.map
              (caml_js_wrap_callback
                (function(x,idx,param){return caml_call1(f,x)}))}
    function array_mapi(f,a)
     {return a.map
              (caml_js_wrap_callback
                (function(x,idx,param){return caml_call2(f,idx,x)}))}
    function str_array(_gw_){return _gw_}
    function match_result(_gv_){return _gv_}
    var
     date_ms=Unsafe[1].Date,
     math=Unsafe[1].Math,
     Error=[248,cst_Js_of_ocaml_Js_Error,caml_fresh_oo_id(0)],
     error_constr=Unsafe[1].Error;
    caml_call2(Callback[2],cst_jsError,[0,Error,{}]);
    function raise_js_error(exn){throw exn}
    var JSON=Unsafe[1].JSON;
    function decodeURI(s){return Unsafe[1].decodeURI(s)}
    function decodeURIComponent(s){return Unsafe[1].decodeURIComponent(s)}
    function encodeURI(s){return Unsafe[1].encodeURI(s)}
    function encodeURIComponent(s){return Unsafe[1].encodeURIComponent(s)}
    function escape(s){return Unsafe[1].escape(s)}
    function unescape(s){return Unsafe[1].unescape(s)}
    function isNaN(i){return Unsafe[1].isNaN(i) | 0}
    function parseInt(s)
     {var s$0=Unsafe[1].parseInt(s);
      return isNaN(s$0)?caml_call1(Pervasives[2],cst_parseInt):s$0}
    function parseFloat(s)
     {var s$0=Unsafe[1].parseFloat(s);
      return isNaN(s$0)?caml_call1(Pervasives[2],cst_parseFloat):s$0}
    function _a_(param)
     {if(param[1] === Error)
       {var e=param[2];return [0,caml_js_to_string(e.toString())]}
      return 0}
    caml_call1(Printexc[8],_a_);
    function _b_(e)
     {return e instanceof array_length?0:[0,caml_js_to_string(e.toString())]}
    caml_call1(Printexc[8],_b_);
    function string_of_error(e){return caml_js_to_string(e.toString())}
    function export_js(field,x)
     {return runtime.caml_js_export_var(0)[field] = x}
    function export$0(field,x){return export_js(field.toString(),x)}
    function export_all(obj)
     {var keys=object_keys(obj);
      return keys.forEach
              (caml_js_wrap_callback
                (function(key,param,_gu_){return export_js(key,obj[key])}))}
    function _c_(_gt_){return _gt_}
    var
     Js_of_ocaml_Js=
      [0,
       no_handler,
       function(_gs_){return _gs_},
       t37,
       _c_,
       Opt,
       Optdef,
       true$0,
       false$0,
       string_constr,
       regExp_withFlags,
       regExp_withFlags,
       regExp_withFlags,
       object_keys,
       array_length,
       array_length,
       array_get,
       array_set,
       array_map,
       array_mapi,
       str_array,
       match_result,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       math,
       error_constr,
       string_of_error,
       raise_js_error,
       Error,
       JSON,
       decodeURI,
       decodeURIComponent,
       encodeURI,
       encodeURIComponent,
       escape,
       unescape,
       isNaN,
       parseInt,
       parseFloat,
       coerce,
       coerce_opt,
       export$0,
       export_all,
       Unsafe];
    caml_register_global(1634,Js_of_ocaml_Js,"Js_of_ocaml__Js");
    function list_of_nodeList(nodeList)
     {var length=nodeList.length,acc=0,i=0;
      for(;;)
       {if(caml_call2(symbol$5,i,length))
         {var _gr_=nodeList.item(i),match=caml_call1(Opt[10],_gr_);
          if(match)
           {var e=match[1],i$0=i + 1 | 0,acc$0=[0,e,acc],acc=acc$0,i=i$0;
            continue}
          var i$1=i + 1 | 0,i=i$1;
          continue}
        return caml_call1(List[9],acc)}}
    var
     disconnected=1,
     preceding=2,
     following=4,
     contains$0=8,
     contained_by=16,
     implementation_specific=32;
    function has(t,mask){return caml_call2(symbol$8,t & mask,mask)}
    function add(x,y){return x | y}
    var
     DocumentPosition=
      [0,
       disconnected,
       preceding,
       following,
       contains$0,
       contained_by,
       implementation_specific,
       has,
       add,
       add];
    function appendChild(p,n){p.appendChild(n);return 0}
    function removeChild(p,n){p.removeChild(n);return 0}
    function replaceChild(p,n,o){p.replaceChild(n,o);return 0}
    function insertBefore(p,n,o){p.insertBefore(n,o);return 0}
    function nodeType(e)
     {var match=e.nodeType;
      if(0 !== match)
       {var switcher=match - 1 | 0;
        switch(switcher)
         {case 0:return [0,e];case 1:return [1,e];case 2:case 3:return [2,e]}}
      return [3,e]}
    function cast(e,t){return e.nodeType === t?e:no_handler}
    function element(e){return cast(e,1)}
    function text(e)
     {if(3 !== e.nodeType)if(4 !== e.nodeType)return no_handler;return e}
    function attr(e){return cast(e,2)}
    function handler(f)
     {return function(e)
       {if(caml_call1(Opt[5],e))
         {var res=caml_call1(f,e);
          if(1 - (res | 0))e.preventDefault();
          return res}
        var e$0=event,res$0=caml_call1(f,e$0);
        if(1 - (res$0 | 0))e$0.returnValue = res$0;
        return res$0}}
    function full_handler(f)
     {return runtime.caml_js_wrap_meth_callback_unsafe
              (function(this$0,e)
                {if(caml_call1(Opt[5],e))
                  {var res=caml_call2(f,this$0,e);
                   if(1 - (res | 0))e.preventDefault();
                   return res}
                 var e$0=event,res$0=caml_call2(f,this$0,e$0);
                 if(1 - (res$0 | 0))e$0.returnValue = res$0;
                 return res$0})}
    function invoke_handler(f,this$0,event){return f.call(this$0,event)}
    function eventTarget(e)
     {function _go_(param)
       {function _gq_(param){throw Not_found}
        return caml_call2(Opt[8],e.srcElement,_gq_)}
      var target=caml_call2(Opt[8],e.target,_go_);
      if(target instanceof Unsafe[1].Node)
       {if(3 === target.nodeType)
         {var _gp_=function(param){throw [0,Assert_failure,_d_]};
          return caml_call2(Opt[8],target.parentNode,_gp_)}
        return target}
      return target}
    var make$0=caml_js_from_string,Event=[0,make$0];
    function addEventListenerWithOptions(e,typ,capture,once,passive,h)
     {if(e.addEventListener === t37)
       {var
         ev="on".concat(typ),
         callback=
          function(e)
           {var _gl_=[0,h,e,[0]];
            return function(_gm_,_gn_)
             {return runtime.caml_js_call(_gl_,_gm_,_gn_)}};
        e.attachEvent(ev,callback);
        return function(param){return e.detachEvent(ev,callback)}}
      var opts={};
      function iter(t,f){if(t){var b=t[1];return caml_call1(f,b)}return 0}
      iter(capture,function(b){return opts.capture = b});
      iter(once,function(b){return opts.once = b});
      iter(passive,function(b){return opts.passive = b});
      e.addEventListener(typ,h,opts);
      return function(param){return e.removeEventListener(typ,h,opts)}}
    function addEventListener(e,typ,h,capt)
     {return addEventListenerWithOptions(e,typ,[0,capt],0,0,h)}
    function removeEventListener(id){return caml_call1(id,0)}
    function preventDefault(ev)
     {return caml_call1(Optdef[5],ev.preventDefault)
              ?ev.preventDefault()
              :ev.returnValue = ! ! 0}
    function createCustomEvent(bubbles,cancelable,detail,typ)
     {function opt_iter(f,param)
       {if(param){var x=param[1];return caml_call1(f,x)}return 0}
      var opts={};
      opt_iter(function(x){return opts.bubbles = ! ! x},bubbles);
      opt_iter(function(x){return opts.cancelable = ! ! x},cancelable);
      opt_iter(function(x){return opts.detail = x},detail);
      var constr=Unsafe[1].CustomEvent;
      return new constr(typ,opts)}
    var
     Js_of_ocaml_Dom=
      [0,
       DocumentPosition,
       insertBefore,
       replaceChild,
       removeChild,
       appendChild,
       list_of_nodeList,
       nodeType,
       [0,element,text,attr],
       no_handler,
       handler,
       full_handler,
       invoke_handler,
       eventTarget,
       Event,
       addEventListenerWithOptions,
       addEventListener,
       removeEventListener,
       preventDefault,
       createCustomEvent];
    caml_register_global(1638,Js_of_ocaml_Dom,"Js_of_ocaml__Dom");
    var
     arrayBuffer=Unsafe[1].ArrayBuffer,
     int8Array_inBuffer=Unsafe[1].Int8Array,
     uint8Array_fromBuffer=Unsafe[1].Uint8Array,
     int16Array_inBuffer=Unsafe[1].Int16Array,
     uint16Array_inBuffer=Unsafe[1].Uint16Array,
     int32Array_inBuffer=Unsafe[1].Int32Array,
     uint32Array_inBuffer=Unsafe[1].Uint32Array,
     float32Array_inBuffer=Unsafe[1].Float32Array,
     float64Array_inBuffer=Unsafe[1].Float64Array,
     set=caml_js_set,
     get$1=caml_js_get,
     unsafe_get=caml_js_get,
     dataView=Unsafe[1].DataView;
    function of_arrayBuffer(ab)
     {var uint8=new uint8Array_fromBuffer(ab);
      return caml_string_of_array(uint8)}
    var
     Js_of_ocaml_Typed_array=
      [0,
       arrayBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       uint8Array_fromBuffer,
       uint8Array_fromBuffer,
       uint8Array_fromBuffer,
       uint8Array_fromBuffer,
       uint8Array_fromBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       set,
       get$1,
       unsafe_get,
       dataView,
       dataView,
       [0,
        runtime.bigstring_to_array_buffer,
        runtime.bigstring_to_typed_array,
        runtime.bigstring_of_array_buffer,
        runtime.bigstring_of_typed_array],
       [0,of_arrayBuffer,caml_string_of_array]];
    caml_register_global
     (1639,Js_of_ocaml_Typed_array,"Js_of_ocaml__Typed_array");
    var blob_constr=Unsafe[1].Blob;
    function filter_map(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var q=param$0[2],v=param$0[1],match=caml_call1(f,v);
          if(match){var v$0=match[1];return [0,v$0,filter_map(f,q)]}
          var param$0=q;
          continue}
        return 0}}
    function blob_raw(contentType,endings,a)
     {var _gh_=0;
      if(endings)
       var _gi_=116179762 <= endings[1]?_e_:_f_,_gj_=_gi_;
      else
       var _gj_=0;
      var
       _gk_=[0,[0,cst_type,contentType],[0,[0,cst_endings,_gj_],_gh_]],
       options=
        filter_map
         (function(param)
           {var v=param[2],name=param[1];
            if(v){var v$0=v[1];return [0,[0,name,v$0.toString()]]}
            return 0},
          _gk_),
       options$0=
        options?runtime.caml_js_object(caml_call1(Array[12],options)):t37;
      return new blob_constr(caml_js_from_array(a),options$0)}
    function blob_from_string(contentType,endings,s)
     {return blob_raw(contentType,endings,[0,s.toString()])}
    function blob_from_any(contentType,endings,l)
     {function _gf_(param)
       {var _gg_=param[1];
        if(155580615 === _gg_){var s=param[2];return s}
        if(486041214 <= _gg_)
         {if(1037850489 <= _gg_){var a=param[2];return a}
          var a$0=param[2];
          return a$0}
        if(288368849 <= _gg_){var s$0=param[2];return s$0.toString()}
        var b=param[2];
        return b}
      var l$0=caml_call2(List[17],_gf_,l);
      return blob_raw(contentType,endings,caml_call1(Array[12],l$0))}
    function filename(file)
     {var match=caml_call1(Optdef[10],file.name);
      if(match){var name=match[1];return name}
      var match$0=caml_call1(Optdef[10],file.fileName);
      if(match$0){var name$0=match$0[1];return name$0}
      return caml_call1
              (Pervasives[2],cst_can_t_retrieve_file_name_not_implemented)}
    var doc_constr=Unsafe[1].Document;
    function document(e){return e instanceof doc_constr?e:no_handler}
    function blob(e){return e instanceof blob_constr?e:no_handler}
    function string(e){return typeof e === "string"?e:no_handler}
    function arrayBuffer$0(e){return e instanceof arrayBuffer?e:no_handler}
    var
     loadstart=caml_call1(Event[1],cst_loadstart),
     progress=caml_call1(Event[1],cst_progress),
     abort=caml_call1(Event[1],cst_abort),
     error=caml_call1(Event[1],cst_error),
     load=caml_call1(Event[1],cst_load),
     loadend=caml_call1(Event[1],cst_loadend),
     ReaderEvent=[0,loadstart,progress,abort,error,load,loadend],
     fileReader=Unsafe[1].FileReader,
     Js_of_ocaml_File=
      [0,
       blob_from_string,
       blob_from_any,
       [0,document,blob,function(_ge_){return _ge_},string,arrayBuffer$0],
       ReaderEvent,
       filename,
       fileReader,
       addEventListener];
    caml_register_global(1641,Js_of_ocaml_File,"Js_of_ocaml__File");
    var
     onIE=runtime.caml_js_on_ie(0) | 0,
     click=caml_call1(Event[1],cst_click),
     dblclick=caml_call1(Event[1],cst_dblclick),
     mousedown=caml_call1(Event[1],cst_mousedown),
     mouseup=caml_call1(Event[1],cst_mouseup),
     mouseover=caml_call1(Event[1],cst_mouseover),
     mousemove=caml_call1(Event[1],cst_mousemove),
     mouseout=caml_call1(Event[1],cst_mouseout),
     keypress=caml_call1(Event[1],cst_keypress),
     keydown=caml_call1(Event[1],cst_keydown),
     keyup=caml_call1(Event[1],cst_keyup),
     mousewheel=caml_call1(Event[1],cst_mousewheel),
     DOMMouseScroll=caml_call1(Event[1],cst_DOMMouseScroll),
     touchstart=caml_call1(Event[1],cst_touchstart),
     touchmove=caml_call1(Event[1],cst_touchmove),
     touchend=caml_call1(Event[1],cst_touchend),
     touchcancel=caml_call1(Event[1],cst_touchcancel),
     dragstart=caml_call1(Event[1],cst_dragstart),
     dragend=caml_call1(Event[1],cst_dragend),
     dragenter=caml_call1(Event[1],cst_dragenter),
     dragover=caml_call1(Event[1],cst_dragover),
     dragleave=caml_call1(Event[1],cst_dragleave),
     drag=caml_call1(Event[1],cst_drag),
     drop=caml_call1(Event[1],cst_drop),
     hashchange=caml_call1(Event[1],cst_hashchange),
     change=caml_call1(Event[1],cst_change),
     input=caml_call1(Event[1],cst_input),
     timeupdate=caml_call1(Event[1],cst_timeupdate),
     submit=caml_call1(Event[1],cst_submit),
     scroll=caml_call1(Event[1],cst_scroll),
     focus=caml_call1(Event[1],cst_focus),
     blur=caml_call1(Event[1],cst_blur),
     load$0=caml_call1(Event[1],cst_load$0),
     unload=caml_call1(Event[1],cst_unload),
     beforeunload=caml_call1(Event[1],cst_beforeunload),
     resize=caml_call1(Event[1],cst_resize),
     orientationchange=caml_call1(Event[1],cst_orientationchange),
     popstate=caml_call1(Event[1],cst_popstate),
     error$0=caml_call1(Event[1],cst_error$0),
     abort$0=caml_call1(Event[1],cst_abort$0),
     select=caml_call1(Event[1],cst_select),
     online=caml_call1(Event[1],cst_online),
     offline=caml_call1(Event[1],cst_offline),
     checking=caml_call1(Event[1],cst_checking),
     noupdate=caml_call1(Event[1],cst_noupdate),
     downloading=caml_call1(Event[1],cst_downloading),
     progress$0=caml_call1(Event[1],cst_progress$0),
     updateready=caml_call1(Event[1],cst_updateready),
     cached=caml_call1(Event[1],cst_cached),
     obsolete=caml_call1(Event[1],cst_obsolete),
     domContentLoaded=caml_call1(Event[1],cst_DOMContentLoaded),
     animationstart=caml_call1(Event[1],cst_animationstart),
     animationend=caml_call1(Event[1],cst_animationend),
     animationiteration=caml_call1(Event[1],cst_animationiteration),
     animationcancel=caml_call1(Event[1],cst_animationcancel),
     canplay=caml_call1(Event[1],cst_canplay),
     canplaythrough=caml_call1(Event[1],cst_canplaythrough),
     durationchange=caml_call1(Event[1],cst_durationchange),
     emptied=caml_call1(Event[1],cst_emptied),
     ended=caml_call1(Event[1],cst_ended),
     gotpointercapture=caml_call1(Event[1],cst_gotpointercapture),
     loadeddata=caml_call1(Event[1],cst_loadeddata),
     loadedmetadata=caml_call1(Event[1],cst_loadedmetadata),
     loadstart$0=caml_call1(Event[1],cst_loadstart$0),
     lostpointercapture=caml_call1(Event[1],cst_lostpointercapture),
     pause=caml_call1(Event[1],cst_pause),
     play=caml_call1(Event[1],cst_play),
     playing=caml_call1(Event[1],cst_playing),
     pointerenter=caml_call1(Event[1],cst_pointerenter),
     pointercancel=caml_call1(Event[1],cst_pointercancel),
     pointerdown=caml_call1(Event[1],cst_pointerdown),
     pointerleave=caml_call1(Event[1],cst_pointerleave),
     pointermove=caml_call1(Event[1],cst_pointermove),
     pointerout=caml_call1(Event[1],cst_pointerout),
     pointerover=caml_call1(Event[1],cst_pointerover),
     pointerup=caml_call1(Event[1],cst_pointerup),
     ratechange=caml_call1(Event[1],cst_ratechange),
     seeked=caml_call1(Event[1],cst_seeked),
     seeking=caml_call1(Event[1],cst_seeking),
     stalled=caml_call1(Event[1],cst_stalled),
     suspend=caml_call1(Event[1],cst_suspend),
     volumechange=caml_call1(Event[1],cst_volumechange),
     waiting=caml_call1(Event[1],cst_waiting),
     make$1=Event[1],
     Event$0=
      [0,
       click,
       dblclick,
       mousedown,
       mouseup,
       mouseover,
       mousemove,
       mouseout,
       keypress,
       keydown,
       keyup,
       mousewheel,
       DOMMouseScroll,
       touchstart,
       touchmove,
       touchend,
       touchcancel,
       dragstart,
       dragend,
       dragenter,
       dragover,
       dragleave,
       drag,
       drop,
       hashchange,
       change,
       input,
       timeupdate,
       submit,
       scroll,
       focus,
       blur,
       load$0,
       unload,
       beforeunload,
       resize,
       orientationchange,
       popstate,
       error$0,
       abort$0,
       select,
       online,
       offline,
       checking,
       noupdate,
       downloading,
       progress$0,
       updateready,
       cached,
       obsolete,
       domContentLoaded,
       animationstart,
       animationend,
       animationiteration,
       animationcancel,
       canplay,
       canplaythrough,
       durationchange,
       emptied,
       ended,
       gotpointercapture,
       loadeddata,
       loadedmetadata,
       loadstart$0,
       lostpointercapture,
       pause,
       play,
       playing,
       pointerenter,
       pointercancel,
       pointerdown,
       pointerleave,
       pointermove,
       pointerout,
       pointerover,
       pointerup,
       ratechange,
       seeked,
       seeking,
       stalled,
       suspend,
       volumechange,
       waiting,
       make$1],
     d="2d";
    function location_origin(loc)
     {function _gc_(o){return o}
      function _gd_(param)
       {var protocol=loc.protocol,hostname=loc.hostname,port=loc.port;
        if(caml_call2(symbol$8,protocol.length,0))
         if(caml_call2(symbol$8,hostname.length,0))return "";
        var origin=protocol.concat("//",hostname);
        return caml_call2(symbol$9,port.length,0)
                ?origin.concat(":",loc.port)
                :origin}
      return caml_call3(Optdef[7],loc.origin,_gd_,_gc_)}
    var _g_=Unsafe[1],document$0=_g_.document;
    function getElementById(id)
     {function _f$_(pnode){return pnode}
      function _ga_(param){throw Not_found}
      var _gb_=document$0.getElementById(id.toString());
      return caml_call3(Opt[7],_gb_,_ga_,_f$_)}
    function getElementById_exn(id)
     {function _f7_(pnode){return pnode}
      function _f8_(param)
       {var _f__=caml_call2(Printf[4],_h_,id);
        return caml_call1(Pervasives[2],_f__)}
      var _f9_=document$0.getElementById(id.toString());
      return caml_call3(Opt[7],_f9_,_f8_,_f7_)}
    function getElementById_opt(id)
     {var _f6_=document$0.getElementById(id.toString());
      return caml_call1(Opt[10],_f6_)}
    function getElementById_coerce(id,coerce)
     {function _f2_(e)
       {var _f5_=caml_call1(coerce,e);return caml_call1(Opt[10],_f5_)}
      function _f3_(param){return 0}
      var _f4_=document$0.getElementById(id.toString());
      return caml_call3(Opt[7],_f4_,_f3_,_f2_)}
    function opt_iter(x,f){if(x){var v=x[1];return caml_call1(f,v)}return 0}
    function createElement(doc,name)
     {return doc.createElement(name.toString())}
    function unsafeCreateElement(doc,name){return createElement(doc,name)}
    var createElementSyntax=[0,785140586];
    function unsafeCreateElementEx(type,name,doc,elt)
     {for(;;)
       {if(0 === type)if(0 === name)return createElement(doc,elt);
        var _fW_=createElementSyntax[1];
        if(785140586 === _fW_)
         {try
           {var
             el=document$0.createElement('<input name="x">'),
             _fZ_=el.tagName.toLowerCase() === "input"?1:0,
             _f0_=_fZ_?el.name === "x"?1:0:_fZ_,
             _fX_=_f0_}
          catch(_f1_){var _fX_=0}
          var _fY_=_fX_?982028505:-1003883683;
          createElementSyntax[1] = _fY_;
          continue}
        if(982028505 <= _fW_)
         {var a=new array_length();
          a.push("<",elt.toString());
          opt_iter
           (type,
            function(t){a.push(' type="',caml_js_html_escape(t),'"');return 0});
          opt_iter
           (name,
            function(n){a.push(' name="',caml_js_html_escape(n),'"');return 0});
          a.push(">");
          return doc.createElement(a.join(""))}
        var res=createElement(doc,elt);
        opt_iter(type,function(t){return res.type = t});
        opt_iter(name,function(n){return res.name = n});
        return res}}
    function createHtml(doc){return unsafeCreateElement(doc,cst_html)}
    function createHead(doc){return unsafeCreateElement(doc,cst_head)}
    function createLink(doc){return unsafeCreateElement(doc,cst_link)}
    function createTitle(doc){return unsafeCreateElement(doc,cst_title)}
    function createMeta(doc){return unsafeCreateElement(doc,cst_meta)}
    function createBase(doc){return unsafeCreateElement(doc,cst_base)}
    function createStyle(doc){return unsafeCreateElement(doc,cst_style)}
    function createBody(doc){return unsafeCreateElement(doc,cst_body)}
    function createForm(doc){return unsafeCreateElement(doc,cst_form)}
    function createOptgroup(doc){return unsafeCreateElement(doc,cst_optgroup)}
    function createOption(doc){return unsafeCreateElement(doc,cst_option)}
    function createSelect(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_select$0)}
    function createInput(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_input$0)}
    function createTextarea(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_textarea)}
    function createButton(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_button)}
    function createLabel(doc){return unsafeCreateElement(doc,cst_label)}
    function createFieldset(doc){return unsafeCreateElement(doc,cst_fieldset)}
    function createLegend(doc){return unsafeCreateElement(doc,cst_legend)}
    function createUl(doc){return unsafeCreateElement(doc,cst_ul)}
    function createOl(doc){return unsafeCreateElement(doc,cst_ol)}
    function createDl(doc){return unsafeCreateElement(doc,cst_dl)}
    function createLi(doc){return unsafeCreateElement(doc,cst_li)}
    function createDiv(doc){return unsafeCreateElement(doc,cst_div)}
    function createEmbed(doc){return unsafeCreateElement(doc,cst_embed)}
    function createP(doc){return unsafeCreateElement(doc,cst_p)}
    function createH1(doc){return unsafeCreateElement(doc,cst_h1)}
    function createH2(doc){return unsafeCreateElement(doc,cst_h2)}
    function createH3(doc){return unsafeCreateElement(doc,cst_h3)}
    function createH4(doc){return unsafeCreateElement(doc,cst_h4)}
    function createH5(doc){return unsafeCreateElement(doc,cst_h5)}
    function createH6(doc){return unsafeCreateElement(doc,cst_h6)}
    function createQ(doc){return unsafeCreateElement(doc,cst_q)}
    function createBlockquote(doc)
     {return unsafeCreateElement(doc,cst_blockquote)}
    function createPre(doc){return unsafeCreateElement(doc,cst_pre)}
    function createBr(doc){return unsafeCreateElement(doc,cst_br)}
    function createHr(doc){return unsafeCreateElement(doc,cst_hr)}
    function createIns(doc){return unsafeCreateElement(doc,cst_ins)}
    function createDel(doc){return unsafeCreateElement(doc,cst_del)}
    function createA(doc){return unsafeCreateElement(doc,cst_a)}
    function createImg(doc){return unsafeCreateElement(doc,cst_img)}
    function createObject(doc){return unsafeCreateElement(doc,cst_object)}
    function createParam(doc){return unsafeCreateElement(doc,cst_param)}
    function createMap(doc){return unsafeCreateElement(doc,cst_map)}
    function createArea(doc){return unsafeCreateElement(doc,cst_area)}
    function createScript(doc){return unsafeCreateElement(doc,cst_script)}
    function createTable(doc){return unsafeCreateElement(doc,cst_table)}
    function createCaption(doc){return unsafeCreateElement(doc,cst_caption)}
    function createCol(doc){return unsafeCreateElement(doc,cst_col)}
    function createColgroup(doc){return unsafeCreateElement(doc,cst_colgroup)}
    function createThead(doc){return unsafeCreateElement(doc,cst_thead)}
    function createTfoot(doc){return unsafeCreateElement(doc,cst_tfoot)}
    function createTbody(doc){return unsafeCreateElement(doc,cst_tbody)}
    function createTr(doc){return unsafeCreateElement(doc,cst_tr)}
    function createTh(doc){return unsafeCreateElement(doc,cst_th)}
    function createTd(doc){return unsafeCreateElement(doc,cst_td)}
    function createSub(doc){return createElement(doc,cst_sub)}
    function createSup(doc){return createElement(doc,cst_sup)}
    function createSpan(doc){return createElement(doc,cst_span)}
    function createTt(doc){return createElement(doc,cst_tt)}
    function createI(doc){return createElement(doc,cst_i)}
    function createB(doc){return createElement(doc,cst_b)}
    function createBig(doc){return createElement(doc,cst_big)}
    function createSmall(doc){return createElement(doc,cst_small)}
    function createEm(doc){return createElement(doc,cst_em)}
    function createStrong(doc){return createElement(doc,cst_strong)}
    function createCite(doc){return createElement(doc,cst_cite)}
    function createDfn(doc){return createElement(doc,cst_dfn)}
    function createCode(doc){return createElement(doc,cst_code)}
    function createSamp(doc){return createElement(doc,cst_samp)}
    function createKbd(doc){return createElement(doc,cst_kbd)}
    function createVar(doc){return createElement(doc,cst_var)}
    function createAbbr(doc){return createElement(doc,cst_abbr)}
    function createDd(doc){return createElement(doc,cst_dd)}
    function createDt(doc){return createElement(doc,cst_dt)}
    function createNoscript(doc){return createElement(doc,cst_noscript)}
    function createAddress(doc){return createElement(doc,cst_address)}
    function createFrameset(doc){return unsafeCreateElement(doc,cst_frameset)}
    function createFrame(doc){return unsafeCreateElement(doc,cst_frame)}
    function createIframe(doc){return unsafeCreateElement(doc,cst_iframe)}
    function createAudio(doc){return unsafeCreateElement(doc,cst_audio)}
    function createVideo(doc){return unsafeCreateElement(doc,cst_video)}
    var
     Canvas_not_available=
      [248,cst_Js_of_ocaml_Dom_html_Canvas_not_available,caml_fresh_oo_id(0)];
    function createCanvas(doc)
     {var c=unsafeCreateElement(doc,cst_canvas);
      if(1 - caml_call1(Opt[5],c.getContext))throw Canvas_not_available;
      return c}
    var
     html_element=Unsafe[1].HTMLElement,
     element$0=
      html_element === t37
       ?function(e){return e.innerHTML === t37?no_handler:e}
       :function(e){return e instanceof html_element?e:no_handler};
    function unsafeCoerce(tag,e)
     {var _fV_=tag.toString();
      return e.tagName.toLowerCase() === _fV_?e:no_handler}
    function a(e){return unsafeCoerce(cst_a$0,e)}
    function area(e){return unsafeCoerce(cst_area$0,e)}
    function base(e){return unsafeCoerce(cst_base$0,e)}
    function blockquote(e){return unsafeCoerce(cst_blockquote$0,e)}
    function body(e){return unsafeCoerce(cst_body$0,e)}
    function br(e){return unsafeCoerce(cst_br$0,e)}
    function button(e){return unsafeCoerce(cst_button$0,e)}
    function canvas(e){return unsafeCoerce(cst_canvas$0,e)}
    function caption(e){return unsafeCoerce(cst_caption$0,e)}
    function col(e){return unsafeCoerce(cst_col$0,e)}
    function colgroup(e){return unsafeCoerce(cst_colgroup$0,e)}
    function del(e){return unsafeCoerce(cst_del$0,e)}
    function div(e){return unsafeCoerce(cst_div$0,e)}
    function dl(e){return unsafeCoerce(cst_dl$0,e)}
    function fieldset(e){return unsafeCoerce(cst_fieldset$0,e)}
    function embed(e){return unsafeCoerce(cst_embed$0,e)}
    function form(e){return unsafeCoerce(cst_form$0,e)}
    function frameset(e){return unsafeCoerce(cst_frameset$0,e)}
    function frame(e){return unsafeCoerce(cst_frame$0,e)}
    function h1(e){return unsafeCoerce(cst_h1$0,e)}
    function h2(e){return unsafeCoerce(cst_h2$0,e)}
    function h3(e){return unsafeCoerce(cst_h3$0,e)}
    function h4(e){return unsafeCoerce(cst_h4$0,e)}
    function h5(e){return unsafeCoerce(cst_h5$0,e)}
    function h6(e){return unsafeCoerce(cst_h6$0,e)}
    function head(e){return unsafeCoerce(cst_head$0,e)}
    function hr(e){return unsafeCoerce(cst_hr$0,e)}
    function html(e){return unsafeCoerce(cst_html$0,e)}
    function iframe(e){return unsafeCoerce(cst_iframe$0,e)}
    function img(e){return unsafeCoerce(cst_img$0,e)}
    function input$0(e){return unsafeCoerce(cst_input$1,e)}
    function ins(e){return unsafeCoerce(cst_ins$0,e)}
    function label(e){return unsafeCoerce(cst_label$0,e)}
    function legend(e){return unsafeCoerce(cst_legend$0,e)}
    function li(e){return unsafeCoerce(cst_li$0,e)}
    function link(e){return unsafeCoerce(cst_link$0,e)}
    function map$2(e){return unsafeCoerce(cst_map$0,e)}
    function meta(e){return unsafeCoerce(cst_meta$0,e)}
    function object(e){return unsafeCoerce(cst_object$0,e)}
    function ol(e){return unsafeCoerce(cst_ol$0,e)}
    function optgroup(e){return unsafeCoerce(cst_optgroup$0,e)}
    function option$1(e){return unsafeCoerce(cst_option$0,e)}
    function p(e){return unsafeCoerce(cst_p$0,e)}
    function param(e){return unsafeCoerce(cst_param$0,e)}
    function pre(e){return unsafeCoerce(cst_pre$0,e)}
    function q(e){return unsafeCoerce(cst_q$0,e)}
    function script(e){return unsafeCoerce(cst_script$0,e)}
    function select$0(e){return unsafeCoerce(cst_select$1,e)}
    function style(e){return unsafeCoerce(cst_style$0,e)}
    function table(e){return unsafeCoerce(cst_table$0,e)}
    function tbody(e){return unsafeCoerce(cst_tbody$0,e)}
    function td(e){return unsafeCoerce(cst_td$0,e)}
    function textarea(e){return unsafeCoerce(cst_textarea$0,e)}
    function tfoot(e){return unsafeCoerce(cst_tfoot$0,e)}
    function th(e){return unsafeCoerce(cst_th$0,e)}
    function thead(e){return unsafeCoerce(cst_thead$0,e)}
    function title(e){return unsafeCoerce(cst_title$0,e)}
    function tr(e){return unsafeCoerce(cst_tr$0,e)}
    function ul(e){return unsafeCoerce(cst_ul$0,e)}
    function audio(e){return unsafeCoerce(cst_audio$0,e)}
    function video(e){return unsafeCoerce(cst_video$0,e)}
    function unsafeCoerceEvent(constr,ev)
     {if(constr !== t37)if(ev instanceof constr)return ev;return no_handler}
    function mouseEvent(ev){return unsafeCoerceEvent(Unsafe[1].MouseEvent,ev)}
    function keyboardEvent(ev)
     {return unsafeCoerceEvent(Unsafe[1].KeyboardEvent,ev)}
    function wheelEvent(ev){return unsafeCoerceEvent(Unsafe[1].WheelEvent,ev)}
    function mouseScrollEvent(ev)
     {return unsafeCoerceEvent(Unsafe[1].MouseScrollEvent,ev)}
    function popStateEvent(ev)
     {return unsafeCoerceEvent(Unsafe[1].PopStateEvent,ev)}
    function eventRelatedTarget(e)
     {function _fS_(param)
       {var match=caml_js_to_string(e.type);
        if(caml_string_notequal(match,cst_mouseout$0))
         {if(caml_string_notequal(match,cst_mouseover$0))return no_handler;
          var _fT_=function(param){throw [0,Assert_failure,_i_]};
          return caml_call2(Optdef[8],e.fromElement,_fT_)}
        function _fU_(param){throw [0,Assert_failure,_j_]}
        return caml_call2(Optdef[8],e.toElement,_fU_)}
      return caml_call2(Optdef[8],e.relatedTarget,_fS_)}
    function eventAbsolutePosition(e)
     {var body=document$0.body,html=document$0.documentElement;
      return [0,
              (e.clientX + body.scrollLeft | 0) + html.scrollLeft | 0,
              (e.clientY + body.scrollTop | 0) + html.scrollTop | 0]}
    function eventAbsolutePosition$0(e)
     {function _fO_(x)
       {function _fQ_(y){return [0,x,y]}
        function _fR_(param){return eventAbsolutePosition(e)}
        return caml_call3(Optdef[7],e.pageY,_fR_,_fQ_)}
      function _fP_(param){return eventAbsolutePosition(e)}
      return caml_call3(Optdef[7],e.pageX,_fP_,_fO_)}
    function elementClientPosition(e)
     {var
       r=e.getBoundingClientRect(),
       body=document$0.body,
       html=document$0.documentElement;
      return [0,
              ((r.left | 0) - body.clientLeft | 0) - html.clientLeft | 0,
              ((r.top | 0) - body.clientTop | 0) - html.clientTop | 0]}
    function getDocumentScroll(param)
     {var body=document$0.body,html=document$0.documentElement;
      return [0,
              body.scrollLeft + html.scrollLeft | 0,
              body.scrollTop + html.scrollTop | 0]}
    function buttonPressed(ev)
     {function _fM_(x){return x}
      function _fN_(param)
       {var match=ev.button,switcher=match - 1 | 0;
        if(! (3 < switcher >>> 0))
         switch(switcher)
          {case 0:return 1;case 1:return 3;case 2:break;default:return 2}
        return 0}
      return caml_call3(Optdef[7],ev.which,_fN_,_fM_)}
    function addMousewheelEventListenerWithOptions(e,capture,once,passive,h)
     {var d=createDiv(document$0);
      d.setAttribute("onmousewheel","return;");
      if(typeof d.onmousewheel === "function")
       {var
         _fI_=
          handler
           (function(e)
             {function _fK_(param){return 0}
              var
               dx=
                (- caml_call2(Optdef[8],e.wheelDeltaX,_fK_) | 0) / 40 | 0;
              function _fL_(param){return e.wheelDelta}
              var
               dy=
                (- caml_call2(Optdef[8],e.wheelDeltaY,_fL_) | 0) / 40 | 0;
              return caml_call3(h,e,dx,dy)});
        return addEventListenerWithOptions
                (e,Event$0[11],capture,once,passive,_fI_)}
      var
       _fJ_=
        handler
         (function(e)
           {var d=e.detail;
            return e.axis === e.HORIZONTAL
                    ?caml_call3(h,e,d,0)
                    :caml_call3(h,e,0,d)});
      return addEventListenerWithOptions
              (e,Event$0[12],capture,once,passive,_fJ_)}
    function addMousewheelEventListener(e,h,capt)
     {return addMousewheelEventListenerWithOptions(e,[0,capt],0,0,h)}
    function f(v)
     {var
       match=caml_js_to_string(v),
       switch$0=caml_string_compare(match,cst_KeyH);
      if(0 <= switch$0)
       {if(! (0 < switch$0))return 8;
        var switch$1=caml_string_compare(match,cst_Numpad4);
        if(0 <= switch$1)
         {if(! (0 < switch$1))return 72;
          var switch$2=caml_string_compare(match,cst_PageUp);
          if(0 <= switch$2)
           {if(! (0 < switch$2))return 98;
            var switch$3=caml_string_compare(match,cst_ShiftRight);
            if(0 <= switch$3)
             {if(! (0 < switch$3))return 91;
              if(! caml_string_notequal(match,cst_Slash))return 55;
              if(! caml_string_notequal(match,cst_Space))return 41;
              if(! caml_string_notequal(match,cst_Tab))return 39;
              if(! caml_string_notequal(match,cst_VolumeDown))return 103;
              if(! caml_string_notequal(match,cst_VolumeMute))return 102;
              if(! caml_string_notequal(match,cst_VolumeUp))return 104}
            else
             {if(! caml_string_notequal(match,cst_Pause))return 123;
              if(! caml_string_notequal(match,cst_Period))return 54;
              if(! caml_string_notequal(match,cst_PrintScreen))return 120;
              if(! caml_string_notequal(match,cst_Quote))return 50;
              if(! caml_string_notequal(match,cst_ScrollLock))return 119;
              if(! caml_string_notequal(match,cst_Semicolon))return 49;
              if(! caml_string_notequal(match,cst_ShiftLeft))return 90}}
          else
           {var switch$4=caml_string_compare(match,cst_NumpadDivide);
            if(0 <= switch$4)
             {if(! (0 < switch$4))return 84;
              if(! caml_string_notequal(match,cst_NumpadEnter))return 83;
              if(! caml_string_notequal(match,cst_NumpadEqual))return 82;
              if(! caml_string_notequal(match,cst_NumpadMultiply))return 78;
              if(! caml_string_notequal(match,cst_NumpadSubtract))return 79;
              if(! caml_string_notequal(match,cst_OSLeft))return 117;
              if(! caml_string_notequal(match,cst_OSRight))return 118;
              if(! caml_string_notequal(match,cst_PageDown))return 99}
            else
             {if(! caml_string_notequal(match,cst_Numpad5))return 73;
              if(! caml_string_notequal(match,cst_Numpad6))return 74;
              if(! caml_string_notequal(match,cst_Numpad7))return 75;
              if(! caml_string_notequal(match,cst_Numpad8))return 76;
              if(! caml_string_notequal(match,cst_Numpad9))return 77;
              if(! caml_string_notequal(match,cst_NumpadAdd))return 80;
              if(! caml_string_notequal(match,cst_NumpadDecimal))return 81}}}
        else
         {var switch$5=caml_string_compare(match,cst_KeyX);
          if(0 <= switch$5)
           {if(! (0 < switch$5))return 24;
            var switch$6=caml_string_compare(match,cst_MetaRight);
            if(0 <= switch$6)
             {if(! (0 < switch$6))return 89;
              if(! caml_string_notequal(match,cst_Minus))return 37;
              if(! caml_string_notequal(match,cst_NumLock))return 85;
              if(! caml_string_notequal(match,cst_Numpad0))return 68;
              if(! caml_string_notequal(match,cst_Numpad1))return 69;
              if(! caml_string_notequal(match,cst_Numpad2))return 70;
              if(! caml_string_notequal(match,cst_Numpad3))return 71}
            else
             {if(! caml_string_notequal(match,cst_KeyY))return 25;
              if(! caml_string_notequal(match,cst_KeyZ))return 26;
              if(! caml_string_notequal(match,cst_MediaPlayPause))return 107;
              if(! caml_string_notequal(match,cst_MediaStop))return 108;
              if(! caml_string_notequal(match,cst_MediaTrackNext))return 106;
              if(! caml_string_notequal(match,cst_MediaTrackPrevious))
               return 105;
              if(! caml_string_notequal(match,cst_MetaLeft))return 88}}
          else
           {var switch$7=caml_string_compare(match,cst_KeyP);
            if(0 <= switch$7)
             {if(! (0 < switch$7))return 16;
              if(! caml_string_notequal(match,cst_KeyQ))return 17;
              if(! caml_string_notequal(match,cst_KeyR))return 18;
              if(! caml_string_notequal(match,cst_KeyS))return 19;
              if(! caml_string_notequal(match,cst_KeyT))return 20;
              if(! caml_string_notequal(match,cst_KeyU))return 21;
              if(! caml_string_notequal(match,cst_KeyV))return 22;
              if(! caml_string_notequal(match,cst_KeyW))return 23}
            else
             {if(! caml_string_notequal(match,cst_KeyI))return 9;
              if(! caml_string_notequal(match,cst_KeyJ))return 10;
              if(! caml_string_notequal(match,cst_KeyK))return 11;
              if(! caml_string_notequal(match,cst_KeyL))return 12;
              if(! caml_string_notequal(match,cst_KeyM))return 13;
              if(! caml_string_notequal(match,cst_KeyN))return 14;
              if(! caml_string_notequal(match,cst_KeyO))return 15}}}}
      else
       {var switch$8=caml_string_compare(match,cst_Digit6);
        if(0 <= switch$8)
         {if(! (0 < switch$8))return 33;
          var switch$9=caml_string_compare(match,cst_F6);
          if(0 <= switch$9)
           {if(! (0 < switch$9))return 61;
            var switch$10=caml_string_compare(match,cst_KeyA);
            if(0 <= switch$10)
             {if(! (0 < switch$10))return 1;
              if(! caml_string_notequal(match,cst_KeyB))return 2;
              if(! caml_string_notequal(match,cst_KeyC))return 3;
              if(! caml_string_notequal(match,cst_KeyD))return 4;
              if(! caml_string_notequal(match,cst_KeyE))return 5;
              if(! caml_string_notequal(match,cst_KeyF))return 6;
              if(! caml_string_notequal(match,cst_KeyG))return 7}
            else
             {if(! caml_string_notequal(match,cst_F7))return 62;
              if(! caml_string_notequal(match,cst_F8))return 63;
              if(! caml_string_notequal(match,cst_F9))return 64;
              if(! caml_string_notequal(match,cst_Home))return 100;
              if(! caml_string_notequal(match,cst_Insert))return 44;
              if(! caml_string_notequal(match,cst_IntlBackslash))return 121;
              if(! caml_string_notequal(match,cst_IntlYen))return 122}}
          else
           {var switch$11=caml_string_compare(match,cst_F1);
            if(0 <= switch$11)
             {if(! (0 < switch$11))return 56;
              if(! caml_string_notequal(match,cst_F10))return 65;
              if(! caml_string_notequal(match,cst_F11))return 66;
              if(! caml_string_notequal(match,cst_F12))return 67;
              if(! caml_string_notequal(match,cst_F2))return 57;
              if(! caml_string_notequal(match,cst_F3))return 58;
              if(! caml_string_notequal(match,cst_F4))return 59;
              if(! caml_string_notequal(match,cst_F5))return 60}
            else
             {if(! caml_string_notequal(match,cst_Digit7))return 34;
              if(! caml_string_notequal(match,cst_Digit8))return 35;
              if(! caml_string_notequal(match,cst_Digit9))return 36;
              if(! caml_string_notequal(match,cst_End))return 101;
              if(! caml_string_notequal(match,cst_Enter))return 40;
              if(! caml_string_notequal(match,cst_Equal))return 38;
              if(! caml_string_notequal(match,cst_Escape))return 42}}}
        else
         {var switch$12=caml_string_compare(match,cst_BrowserRefresh);
          if(0 <= switch$12)
           {if(! (0 < switch$12))return 113;
            var switch$13=caml_string_compare(match,cst_Delete);
            if(0 <= switch$13)
             {if(! (0 < switch$13))return 45;
              if(! caml_string_notequal(match,cst_Digit0))return 27;
              if(! caml_string_notequal(match,cst_Digit1))return 28;
              if(! caml_string_notequal(match,cst_Digit2))return 29;
              if(! caml_string_notequal(match,cst_Digit3))return 30;
              if(! caml_string_notequal(match,cst_Digit4))return 31;
              if(! caml_string_notequal(match,cst_Digit5))return 32}
            else
             {if(! caml_string_notequal(match,cst_BrowserSearch))return 110;
              if(! caml_string_notequal(match,cst_BrowserStop))return 114;
              if(! caml_string_notequal(match,cst_CapsLock))return 46;
              if(! caml_string_notequal(match,cst_Comma))return 53;
              if(! caml_string_notequal(match,cst_ContextMenu))return 109;
              if(! caml_string_notequal(match,cst_ControlLeft))return 86;
              if(! caml_string_notequal(match,cst_ControlRight))return 87}}
          else
           {var switch$14=caml_string_compare(match,cst_Backslash);
            if(0 <= switch$14)
             {if(! (0 < switch$14))return 52;
              if(! caml_string_notequal(match,cst_Backspace))return 43;
              if(! caml_string_notequal(match,cst_BracketLeft))return 47;
              if(! caml_string_notequal(match,cst_BracketRight))return 48;
              if(! caml_string_notequal(match,cst_BrowserBack))return 116;
              if(! caml_string_notequal(match,cst_BrowserFavorites))
               return 112;
              if(! caml_string_notequal(match,cst_BrowserForward))return 115;
              if(! caml_string_notequal(match,cst_BrowserHome))return 111}
            else
             {if(! caml_string_notequal(match,cst_AltLeft))return 92;
              if(! caml_string_notequal(match,cst_AltRight))return 93;
              if(! caml_string_notequal(match,cst_ArrowDown))return 97;
              if(! caml_string_notequal(match,cst_ArrowLeft))return 94;
              if(! caml_string_notequal(match,cst_ArrowRight))return 95;
              if(! caml_string_notequal(match,cst_ArrowUp))return 96;
              if(! caml_string_notequal(match,cst_Backquote))return 51}}}}
      return 0}
    function try_key_code_left(param)
     {if(19 <= param)
       {if(91 === param)return 88}
      else
       if(16 <= param)
        {var switcher=param - 16 | 0;
         switch(switcher){case 0:return 90;case 1:return 86;default:return 92}}
      return 0}
    function try_key_code_right(param)
     {if(19 <= param)
       {if(91 === param)return 89}
      else
       if(16 <= param)
        {var switcher=param - 16 | 0;
         switch(switcher){case 0:return 91;case 1:return 87;default:return 93}}
      return 0}
    function try_key_code_numpad(param)
     {if(47 <= param)
       {var switcher=param - 96 | 0;
        if(! (15 < switcher >>> 0))
         switch(switcher)
          {case 0:return 68;
           case 1:return 69;
           case 2:return 70;
           case 3:return 71;
           case 4:return 72;
           case 5:return 73;
           case 6:return 74;
           case 7:return 75;
           case 8:return 76;
           case 9:return 77;
           case 10:return 78;
           case 11:return 80;
           case 12:break;
           case 13:return 79;
           case 14:return 81;
           default:return 84}}
      else
       if(12 <= param)
        {var switcher$0=param - 12 | 0;
         switch(switcher$0)
          {case 0:return 73;
           case 1:return 83;
           case 21:return 77;
           case 22:return 71;
           case 23:return 69;
           case 24:return 75;
           case 25:return 72;
           case 26:return 76;
           case 27:return 74;
           case 28:return 70;
           case 33:return 68;
           case 34:return 81
           }}
      return 0}
    function try_key_code_normal(param)
     {var switcher=param - 8 | 0;
      if(! (214 < switcher >>> 0))
       {var _fH_=switcher;
        if(67 <= _fH_)
         switch(_fH_)
          {case 67:return 11;
           case 68:return 12;
           case 69:return 13;
           case 70:return 14;
           case 71:return 15;
           case 72:return 16;
           case 73:return 17;
           case 74:return 18;
           case 75:return 19;
           case 76:return 20;
           case 77:return 21;
           case 78:return 22;
           case 79:return 23;
           case 80:return 24;
           case 81:return 25;
           case 82:return 26;
           case 85:return 109;
           case 104:return 56;
           case 105:return 57;
           case 106:return 58;
           case 107:return 59;
           case 108:return 60;
           case 109:return 61;
           case 110:return 62;
           case 111:return 63;
           case 112:return 64;
           case 113:return 65;
           case 114:return 66;
           case 115:return 67;
           case 137:return 119;
           case 178:return 49;
           case 179:return 38;
           case 180:return 53;
           case 181:return 37;
           case 182:return 54;
           case 183:return 55;
           case 184:return 51;
           case 211:return 47;
           case 212:return 52;
           case 213:return 48;
           case 214:return 50
           }
        else
         switch(_fH_)
          {case 0:return 43;
           case 1:return 39;
           case 5:return 40;
           case 11:return 123;
           case 12:return 46;
           case 19:return 42;
           case 24:return 41;
           case 25:return 98;
           case 26:return 99;
           case 27:return 101;
           case 28:return 100;
           case 29:return 94;
           case 30:return 96;
           case 31:return 95;
           case 32:return 97;
           case 34:return 120;
           case 37:return 44;
           case 38:return 45;
           case 40:return 27;
           case 41:return 28;
           case 42:return 29;
           case 43:return 30;
           case 44:return 31;
           case 45:return 32;
           case 46:return 33;
           case 47:return 34;
           case 48:return 35;
           case 49:return 36;
           case 57:return 1;
           case 58:return 2;
           case 59:return 3;
           case 60:return 4;
           case 61:return 5;
           case 62:return 6;
           case 63:return 7;
           case 64:return 8;
           case 65:return 9;
           case 66:return 10
           }}
      return 0}
    function make_unidentified(param){return 0}
    function run_next(value,f,v){return 0 === v?caml_call1(f,value):v}
    function symbol$11(x,f){return caml_call1(f,x)}
    function of_event(evt)
     {var _fA_=evt.keyCode;
      function _fB_(_fG_){return run_next(_fA_,try_key_code_normal,_fG_)}
      var match=evt.location,switcher=match - 1 | 0;
      if(2 < switcher >>> 0)
       var _fC_=make_unidentified;
      else
       switch(switcher)
        {case 0:
          var
           _fx_=evt.keyCode,
           _fC_=function(_fE_){return run_next(_fx_,try_key_code_left,_fE_)};
          break;
         case 1:
          var
           _fy_=evt.keyCode,
           _fC_=function(_fD_){return run_next(_fy_,try_key_code_right,_fD_)};
          break;
         default:
          var
           _fz_=evt.keyCode,
           _fC_=function(_fF_){return run_next(_fz_,try_key_code_numpad,_fF_)}}
      var value=evt.code;
      return symbol$11
              (symbol$11
                (symbol$11
                  (0,
                   function(v)
                    {return 0 === v
                             ?caml_call3(Optdef[7],value,make_unidentified,f)
                             :v}),
                 _fC_),
               _fB_)}
    function char_of_int(value)
     {if(caml_call2(symbol$5,0,value))
       try
        {var _fv_=[0,caml_call1(Uchar[8],value)];return _fv_}
       catch(_fw_){return 0}
      return 0}
    function empty_string(param){return ""}
    function none(param){return 0}
    function of_event$0(evt)
     {var key=caml_call2(Optdef[8],evt.key,empty_string),match=key.length;
      return 0 === match
              ?caml_call3(Optdef[7],evt.charCode,none,char_of_int)
              :1 === match?char_of_int(key.charCodeAt(0) | 0):0}
    function element$1(_fu_){return _fu_}
    function tagged(e)
     {var tag=caml_js_to_byte_string(e.tagName.toLowerCase());
      if(caml_call2(symbol$8,caml_ml_string_length(tag),0))return [61,e];
      var match=runtime.caml_bytes_unsafe_get(tag,0),switcher=match - 97 | 0;
      if(! (21 < switcher >>> 0))
       switch(switcher)
        {case 0:
          return caml_string_notequal(tag,cst_a$1)
                  ?caml_string_notequal(tag,cst_area$1)
                    ?caml_string_notequal(tag,cst_audio$1)?[61,e]:[2,e]
                    :[1,e]
                  :[0,e];
         case 1:
          return caml_string_notequal(tag,cst_base$1)
                  ?caml_string_notequal(tag,cst_blockquote$1)
                    ?caml_string_notequal(tag,cst_body$1)
                      ?caml_string_notequal(tag,cst_br$1)
                        ?caml_string_notequal(tag,cst_button$1)?[61,e]:[7,e]
                        :[6,e]
                      :[5,e]
                    :[4,e]
                  :[3,e];
         case 2:
          return caml_string_notequal(tag,cst_canvas$1)
                  ?caml_string_notequal(tag,cst_caption$1)
                    ?caml_string_notequal(tag,cst_col$1)
                      ?caml_string_notequal(tag,cst_colgroup$1)?[61,e]:[11,e]
                      :[10,e]
                    :[9,e]
                  :[8,e];
         case 3:
          return caml_string_notequal(tag,cst_del$1)
                  ?caml_string_notequal(tag,cst_div$1)
                    ?caml_string_notequal(tag,cst_dl$1)?[61,e]:[14,e]
                    :[13,e]
                  :[12,e];
         case 4:return caml_string_notequal(tag,cst_embed$1)?[61,e]:[15,e];
         case 5:
          return caml_string_notequal(tag,cst_fieldset$1)
                  ?caml_string_notequal(tag,cst_form$1)
                    ?caml_string_notequal(tag,cst_frame$1)
                      ?caml_string_notequal(tag,cst_frameset$1)?[61,e]:[18,e]
                      :[19,e]
                    :[17,e]
                  :[16,e];
         case 7:
          return caml_string_notequal(tag,cst_h1$1)
                  ?caml_string_notequal(tag,cst_h2$1)
                    ?caml_string_notequal(tag,cst_h3$1)
                      ?caml_string_notequal(tag,cst_h4$1)
                        ?caml_string_notequal(tag,cst_h5$1)
                          ?caml_string_notequal(tag,cst_h6$1)
                            ?caml_string_notequal(tag,cst_head$1)
                              ?caml_string_notequal(tag,cst_hr$1)
                                ?caml_string_notequal(tag,cst_html$1)?[61,e]:[28,e]
                                :[27,e]
                              :[26,e]
                            :[25,e]
                          :[24,e]
                        :[23,e]
                      :[22,e]
                    :[21,e]
                  :[20,e];
         case 8:
          return caml_string_notequal(tag,cst_iframe$1)
                  ?caml_string_notequal(tag,cst_img$1)
                    ?caml_string_notequal(tag,cst_input$2)
                      ?caml_string_notequal(tag,cst_ins$1)?[61,e]:[32,e]
                      :[31,e]
                    :[30,e]
                  :[29,e];
         case 11:
          return caml_string_notequal(tag,cst_label$1)
                  ?caml_string_notequal(tag,cst_legend$1)
                    ?caml_string_notequal(tag,cst_li$1)
                      ?caml_string_notequal(tag,cst_link$1)?[61,e]:[36,e]
                      :[35,e]
                    :[34,e]
                  :[33,e];
         case 12:
          return caml_string_notequal(tag,cst_map$1)
                  ?caml_string_notequal(tag,cst_meta$1)?[61,e]:[38,e]
                  :[37,e];
         case 14:
          return caml_string_notequal(tag,cst_object$1)
                  ?caml_string_notequal(tag,cst_ol$1)
                    ?caml_string_notequal(tag,cst_optgroup$1)
                      ?caml_string_notequal(tag,cst_option$1)?[61,e]:[42,e]
                      :[41,e]
                    :[40,e]
                  :[39,e];
         case 15:
          return caml_string_notequal(tag,cst_p$1)
                  ?caml_string_notequal(tag,cst_param$1)
                    ?caml_string_notequal(tag,cst_pre$1)?[61,e]:[45,e]
                    :[44,e]
                  :[43,e];
         case 16:return caml_string_notequal(tag,cst_q$1)?[61,e]:[46,e];
         case 18:
          return caml_string_notequal(tag,cst_script$1)
                  ?caml_string_notequal(tag,cst_select$2)
                    ?caml_string_notequal(tag,cst_style$1)?[61,e]:[49,e]
                    :[48,e]
                  :[47,e];
         case 19:
          return caml_string_notequal(tag,cst_table$1)
                  ?caml_string_notequal(tag,cst_tbody$1)
                    ?caml_string_notequal(tag,cst_td$1)
                      ?caml_string_notequal(tag,cst_textarea$1)
                        ?caml_string_notequal(tag,cst_tfoot$1)
                          ?caml_string_notequal(tag,cst_th$1)
                            ?caml_string_notequal(tag,cst_thead$1)
                              ?caml_string_notequal(tag,cst_title$1)
                                ?caml_string_notequal(tag,cst_tr$1)?[61,e]:[58,e]
                                :[57,e]
                              :[56,e]
                            :[55,e]
                          :[54,e]
                        :[53,e]
                      :[52,e]
                    :[51,e]
                  :[50,e];
         case 20:return caml_string_notequal(tag,cst_ul$1)?[61,e]:[59,e];
         case 21:return caml_string_notequal(tag,cst_video$1)?[61,e]:[60,e]
         }
      return [61,e]}
    function opt_tagged(e)
     {function _fs_(e){return [0,tagged(e)]}
      function _ft_(param){return 0}
      return caml_call3(Opt[7],e,_ft_,_fs_)}
    function taggedEvent(ev)
     {function _fd_(ev){return [0,ev]}
      function _fe_(param)
       {function _fg_(ev){return [1,ev]}
        function _fh_(param)
         {function _fj_(ev){return [2,ev]}
          function _fk_(param)
           {function _fm_(ev){return [3,ev]}
            function _fn_(param)
             {function _fp_(ev){return [4,ev]}
              function _fq_(param){return [5,ev]}
              var _fr_=popStateEvent(ev);
              return caml_call3(Opt[7],_fr_,_fq_,_fp_)}
            var _fo_=mouseScrollEvent(ev);
            return caml_call3(Opt[7],_fo_,_fn_,_fm_)}
          var _fl_=wheelEvent(ev);
          return caml_call3(Opt[7],_fl_,_fk_,_fj_)}
        var _fi_=keyboardEvent(ev);
        return caml_call3(Opt[7],_fi_,_fh_,_fg_)}
      var _ff_=mouseEvent(ev);
      return caml_call3(Opt[7],_ff_,_fe_,_fd_)}
    function opt_taggedEvent(ev)
     {function _fb_(ev){return [0,taggedEvent(ev)]}
      function _fc_(param){return 0}
      return caml_call3(Opt[7],ev,_fc_,_fb_)}
    function stopPropagation(ev)
     {function _e$_(param){return ev.stopPropagation()}
      function _fa_(param){return ev.cancelBubble = true$0}
      return caml_call3(Optdef[7],ev.stopPropagation,_fa_,_e$_)}
    var
     requestAnimationFrame=
      runtime.caml_js_pure_expr
       (function(param)
         {var
           l=
            [0,
             _g_.requestAnimationFrame,
             [0,
              _g_.mozRequestAnimationFrame,
              [0,
               _g_.webkitRequestAnimationFrame,
               [0,
                _g_.oRequestAnimationFrame,
                [0,_g_.msRequestAnimationFrame,0]]]]];
          try
           {var
             _e8_=function(c){return caml_call1(Optdef[5],c)},
             req=caml_call2(List[33],_e8_,l),
             _e9_=function(callback){return req(callback)};
            return _e9_}
          catch(_e__)
           {_e__ = caml_wrap_exception(_e__);
            if(_e__ === Not_found)
             {var
               now=function(param){return new date_ms().getTime()},
               last=[0,now(0)];
              return function(callback)
               {var
                 t=now(0),
                 dt=last[1] + 16.6666666666666679 - t,
                 dt$0=dt < 0.?0.:dt;
                last[1] = t;
                _g_.setTimeout(callback,dt$0);
                return 0}}
            throw _e__}});
    function hasPushState(param)
     {return caml_call1(Optdef[5],_g_.history.pushState)}
    function hasPlaceholder(param)
     {var i=createInput(0,0,document$0);
      return caml_call1(Optdef[5],i.placeholder)}
    function hasRequired(param)
     {var i=createInput(0,0,document$0);
      return caml_call1(Optdef[5],i.required)}
    var overflow_limit=2147483000.;
    function setTimeout(callback,d)
     {var id=[0,0];
      function loop(step,param)
       {if(2147483000. < step)
         var step$0=overflow_limit,remain=step - 2147483000.;
        else
         var step$0=step,remain=0.;
        var cb=remain == 0.?callback:function(_e7_){return loop(remain,_e7_)};
        id[1] = [0,_g_.setTimeout(caml_js_wrap_callback(cb),step$0)];
        return 0}
      loop(d,0);
      return id}
    function clearTimeout(id)
     {var _e6_=id[1];
      if(_e6_){var x=_e6_[1];id[1] = 0;return _g_.clearTimeout(x)}
      return 0}
    function js_array_of_collection(c){return [].slice.call(c)}
    var
     Js_of_ocaml_Dom_html=
      [0,
       d,
       document$0,
       getElementById_opt,
       getElementById_exn,
       getElementById_coerce,
       getElementById,
       location_origin,
       _g_,
       no_handler,
       handler,
       full_handler,
       invoke_handler,
       eventTarget,
       eventRelatedTarget,
       Event$0,
       addEventListenerWithOptions,
       addEventListener,
       removeEventListener,
       addMousewheelEventListenerWithOptions,
       addMousewheelEventListener,
       createCustomEvent,
       buttonPressed,
       eventAbsolutePosition$0,
       elementClientPosition,
       getDocumentScroll,
       [0,of_event,try_key_code_normal],
       [0,of_event$0],
       createHtml,
       createHead,
       createLink,
       createTitle,
       createMeta,
       createBase,
       createStyle,
       createBody,
       createForm,
       createOptgroup,
       createOption,
       createSelect,
       createInput,
       createTextarea,
       createButton,
       createLabel,
       createFieldset,
       createLegend,
       createUl,
       createOl,
       createDl,
       createLi,
       createDiv,
       createEmbed,
       createP,
       createH1,
       createH2,
       createH3,
       createH4,
       createH5,
       createH6,
       createQ,
       createBlockquote,
       createPre,
       createBr,
       createHr,
       createIns,
       createDel,
       createA,
       createImg,
       createObject,
       createParam,
       createMap,
       createArea,
       createScript,
       createTable,
       createCaption,
       createCol,
       createColgroup,
       createThead,
       createTfoot,
       createTbody,
       createTr,
       createTh,
       createTd,
       createSub,
       createSup,
       createSpan,
       createTt,
       createI,
       createB,
       createBig,
       createSmall,
       createEm,
       createStrong,
       createCite,
       createDfn,
       createCode,
       createSamp,
       createKbd,
       createVar,
       createAbbr,
       createDd,
       createDt,
       createNoscript,
       createAddress,
       createFrameset,
       createFrame,
       createIframe,
       createAudio,
       createVideo,
       Canvas_not_available,
       createCanvas,
       element$1,
       tagged,
       opt_tagged,
       taggedEvent,
       opt_taggedEvent,
       stopPropagation,
       [0,
        element$0,
        a,
        area,
        audio,
        base,
        blockquote,
        body,
        br,
        button,
        canvas,
        caption,
        col,
        colgroup,
        del,
        div,
        embed,
        dl,
        fieldset,
        form,
        frameset,
        frame,
        h1,
        h2,
        h3,
        h4,
        h5,
        h6,
        head,
        hr,
        html,
        iframe,
        img,
        input$0,
        ins,
        label,
        legend,
        li,
        link,
        map$2,
        meta,
        object,
        ol,
        optgroup,
        option$1,
        p,
        param,
        pre,
        q,
        script,
        select$0,
        style,
        table,
        tbody,
        td,
        textarea,
        tfoot,
        th,
        thead,
        title,
        tr,
        ul,
        video,
        mouseEvent,
        keyboardEvent,
        wheelEvent,
        mouseScrollEvent,
        popStateEvent],
       setTimeout,
       clearTimeout,
       js_array_of_collection,
       requestAnimationFrame,
       runtime.caml_js_html_entities,
       onIE,
       hasPushState,
       hasPlaceholder,
       hasRequired];
    caml_register_global(1644,Js_of_ocaml_Dom_html,"Js_of_ocaml__Dom_html");
    var formData=Unsafe[1].FormData,formData_form=Unsafe[1].FormData;
    function filter_map$0(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var q=param$0[2],v=param$0[1],match=caml_call1(f,v);
          if(match){var v$0=match[1];return [0,v$0,filter_map$0(f,q)]}
          var param$0=q;
          continue}
        return 0}}
    function have_content(elt)
     {var
       _e4_=caml_call2(symbol$9,elt.name.length,0),
       _e5_=_e4_?1 - (elt.disabled | 0):_e4_;
      return _e5_}
    function form_elements(get,form)
     {var length=form.elements.length;
      function _eS_(i)
       {var _e3_=form.elements.item(i);return caml_call1(Opt[10],_e3_)}
      var
       _eT_=caml_call2(Array[2],length,_eS_),
       elements=caml_call1(Array[11],_eT_);
      function _eU_(param)
       {if(param)
         {var v=param[1],match$3=tagged(v);
          switch(match$3[0])
           {case 31:
             var v$0=match$3[1];
             if(get)var sth=get[1],get$0=sth;else var get$0=0;
             if(have_content(v$0))
              {var
                name$1=caml_js_to_string(v$0.name),
                value=v$0.value,
                match=caml_js_to_byte_string(v$0.type.toLowerCase());
               if(caml_string_notequal(match,cst_checkbox))
                {if(! caml_string_notequal(match,cst_file))
                  {if(get$0)return [0,[0,name$1,[0,-976970511,value]],0];
                   var match$0=caml_call1(Optdef[10],v$0.files);
                   if(match$0)
                    {var list=match$0[1];
                     if(caml_call2(symbol$8,list.length,0))
                      return [0,[0,name$1,[0,-976970511,""]],0];
                     var match$1=caml_call1(Optdef[10],v$0.multiple);
                     if(match$1)
                      if(0 !== match$1[1])
                       {var
                         _eZ_=function(i){return list.item(i)},
                         _e0_=caml_call2(Array[2],list.length,_eZ_),
                         _e1_=caml_call1(Array[11],_e0_);
                        return filter_map$0
                                (function(f)
                                  {var match=caml_call1(Opt[10],f);
                                   if(match)
                                    {var file=match[1];return [0,[0,name$1,[0,781515420,file]]]}
                                   return 0},
                                 _e1_)}
                     var _eY_=list.item(0),match$2=caml_call1(Opt[10],_eY_);
                     if(match$2)
                      {var file=match$2[1];
                       return [0,[0,name$1,[0,781515420,file]],0]}
                     return 0}
                   return 0}
                 if(caml_string_notequal(match,cst_password))
                  if(caml_string_notequal(match,cst_radio))
                   {if(caml_string_notequal(match,cst_reset))
                     if(caml_string_notequal(match,cst_submit$0))
                      {if(caml_string_notequal(match,cst_text))
                        return [0,[0,name$1,[0,-976970511,value]],0];
                       var switch$0=1,switch$1=0}
                     else
                      var switch$1=1;
                    else
                     var switch$1=1;
                    if(switch$1)return 0}
                  else
                   var switch$0=0;
                 else
                  var switch$0=1;
                 if(switch$0)return [0,[0,name$1,[0,-976970511,value]],0]}
               return v$0.checked | 0?[0,[0,name$1,[0,-976970511,value]],0]:0}
             return 0;
            case 48:
             var v$1=match$3[1];
             if(have_content(v$1))
              {var name$0=caml_js_to_string(v$1.name);
               if(v$1.multiple | 0)
                {var
                  _eW_=
                   function(i)
                    {var _e2_=v$1.options.item(i);
                     return caml_call1(Opt[10],_e2_)},
                  options=caml_call2(Array[2],v$1.options.length,_eW_),
                  _eX_=caml_call1(Array[11],options);
                 return filter_map$0
                         (function(param)
                           {if(param)
                             {var e=param[1];
                              return e.selected | 0
                                      ?[0,[0,name$0,[0,-976970511,e.value]]]
                                      :0}
                            return 0},
                          _eX_)}
               return [0,[0,name$0,[0,-976970511,v$1.value]],0]}
             return 0;
            case 53:
             var v$2=match$3[1];
             if(have_content(v$2))
              {var name=caml_js_to_string(v$2.name);
               return [0,[0,name,[0,-976970511,v$2.value]],0]}
             return 0;
            default:return 0}}
        return 0}
      var
       _eV_=caml_call2(List[17],_eU_,elements),
       contents=caml_call1(List[14],_eV_);
      return contents}
    function append(form_contents,form_elt)
     {if(891486873 <= form_contents[1])
       {var list=form_contents[2];list[1] = [0,form_elt,list[1]];return 0}
      var f=form_contents[2],_eQ_=form_elt[2],_eR_=form_elt[1];
      if(781515420 <= _eQ_[1])
       {var file=_eQ_[2];return f.append(_eR_.toString(),file)}
      var s=_eQ_[2];
      return f.append(_eR_.toString(),s)}
    function empty_form_contents(param)
     {var match=caml_call1(Optdef[10],formData);
      if(match){var constr=match[1];return [0,808620462,new constr()]}
      return [0,891486873,[0,0]]}
    function post_form_contents(form)
     {var contents=empty_form_contents(0),_eN_=form_elements(0,form);
      function _eO_(_eP_){return append(contents,_eP_)}
      caml_call2(List[15],_eO_,_eN_);
      return contents}
    function get_form_contents(form)
     {var _eJ_=form_elements(_k_,form);
      function _eK_(param)
       {var _eL_=param[2],_eM_=param[1];
        if(typeof _eL_ !== "number")
         if(-976970511 === _eL_[1])
          {var s=_eL_[2];return [0,_eM_,caml_js_to_string(s)]}
        throw [0,Assert_failure,_l_]}
      return caml_call2(List[17],_eK_,_eJ_)}
    var
     Js_of_ocaml_Form=
      [0,
       formData,
       formData_form,
       append,
       post_form_contents,
       get_form_contents,
       empty_form_contents,
       form_elements];
    caml_register_global(1645,Js_of_ocaml_Form,"Js_of_ocaml__Form");
    var
     readystatechange=caml_call1(Event[1],cst_readystatechange),
     loadstart$1=caml_call1(Event[1],cst_loadstart$1),
     progress$1=caml_call1(Event[1],cst_progress$1),
     abort$1=caml_call1(Event[1],cst_abort$1),
     error$1=caml_call1(Event[1],cst_error$1),
     load$1=caml_call1(Event[1],cst_load$1),
     timeout=caml_call1(Event[1],cst_timeout),
     loadend$0=caml_call1(Event[1],cst_loadend$0),
     Event$1=
      [0,
       readystatechange,
       loadstart$1,
       progress$1,
       abort$1,
       error$1,
       load$1,
       timeout,
       loadend$0];
    function create(param)
     {var
       xmlHttpRequest=Unsafe[1].XMLHttpRequest,
       activeXObject=Unsafe[1].activeXObject;
      try
       {var _eE_=new xmlHttpRequest();return _eE_}
      catch(_eF_)
       {try
         {var _eD_=new activeXObject("Msxml2.XMLHTTP");return _eD_}
        catch(_eG_)
         {try
           {var _eC_=new activeXObject("Msxml3.XMLHTTP");return _eC_}
          catch(_eH_)
           {try
             {var _eB_=new activeXObject("Microsoft.XMLHTTP");return _eB_}
            catch(_eI_){throw [0,Assert_failure,_m_]}}}}}
    var Js_of_ocaml_XmlHttpRequest=[0,create,Event$1];
    caml_register_global
     (1646,Js_of_ocaml_XmlHttpRequest,"Js_of_ocaml__XmlHttpRequest");
    var worker=Unsafe[1].Worker;
    function create$0(script){return new worker(script.toString())}
    function import_scripts(scripts)
     {if(Unsafe[1].importScripts === t37)
       caml_call1(Pervasives[1],cst_Worker_import_scripts_is_undefined);
      var
       _ez_=caml_call1(Array[12],scripts),
       _eA_=caml_call2(Array[15],caml_js_from_string,_ez_);
      return runtime.caml_js_fun_call(Unsafe[1].importScripts,_eA_)}
    function set_onmessage(handler)
     {if(Unsafe[1].onmessage === t37)
       caml_call1(Pervasives[1],cst_Worker_onmessage_is_undefined);
      function js_handler(ev){return caml_call1(handler,ev.data)}
      return Unsafe[1].onmessage = caml_js_wrap_callback(js_handler)}
    function post_message(msg)
     {if(Unsafe[1].postMessage === t37)
       caml_call1(Pervasives[1],cst_Worker_onmessage_is_undefined$0);
      return Unsafe[1].postMessage(msg)}
    var
     Js_of_ocaml_Worker=
      [0,create$0,import_scripts,set_onmessage,post_message];
    caml_register_global(1647,Js_of_ocaml_Worker,"Js_of_ocaml__Worker");
    var webSocket=Unsafe[1].WebSocket;
    function is_supported(param){return caml_call1(Optdef[5],webSocket)}
    var Js_of_ocaml_WebSockets=[0,webSocket,webSocket,webSocket,is_supported];
    caml_register_global
     (1648,Js_of_ocaml_WebSockets,"Js_of_ocaml__WebSockets");
    var
     defaultContextAttributes=
      {"alpha":true$0,
       "depth":true$0,
       "stencil":false$0,
       "antialias":true$0,
       "premultipliedAlpha":false$0,
       "preserveDrawingBuffer":false$0,
       "preferLowPowerToHighPerformance":false$0,
       "failIfMajorPerformanceCaveat":false$0},
     webglcontextlost=caml_call1(Event$0[83],cst_webglcontextlost),
     webglcontextrestored=caml_call1(Event$0[83],cst_webglcontextrestored),
     webglcontextcreationerror=
      caml_call1(Event$0[83],cst_webglcontextcreationerror),
     Event$2=
      [0,webglcontextlost,webglcontextrestored,webglcontextcreationerror];
    function getContext(c)
     {var ctx=c.getContext("webgl");
      return caml_call1(Opt[5],ctx)?ctx:c.getContext("experimental-webgl")}
    function getContextWithAttributes(c,attribs)
     {var ctx=c.getContext("webgl",attribs);
      return caml_call1(Opt[5],ctx)
              ?ctx
              :c.getContext("experimental-webgl",attribs)}
    var
     Js_of_ocaml_WebGL=
      [0,defaultContextAttributes,Event$2,getContext,getContextWithAttributes];
    caml_register_global(1649,Js_of_ocaml_WebGL,"Js_of_ocaml__WebGL");
    function regexp(s)
     {return new regExp_withFlags(caml_jsbytes_of_string(s),"g")}
    function regexp_case_fold(s)
     {return new regExp_withFlags(caml_jsbytes_of_string(s),"gi")}
    function regexp_with_flag(s,f)
     {var _ey_=caml_call2(Pervasives[16],cst_g,f).toString();
      return new regExp_withFlags(caml_jsbytes_of_string(s),_ey_)}
    function blunt_str_array_get(a,i)
     {function _ex_(param){throw [0,Assert_failure,_n_]}
      return caml_js_to_byte_string(caml_call2(Optdef[8],a[i],_ex_))}
    function string_match(r,s,i)
     {r.lastIndex = i;
      var
       _ev_=r.exec(caml_jsbytes_of_string(s)),
       _ew_=caml_call2(Opt[3],_ev_,match_result);
      return caml_call1(Opt[10],_ew_)}
    function search_forward(r,s,i)
     {r.lastIndex = i;
      function _es_(res){return [0,res.index,res]}
      var
       _et_=r.exec(caml_jsbytes_of_string(s)),
       _eu_=caml_call2(Opt[3],_et_,_es_);
      return caml_call1(Opt[10],_eu_)}
    function matched_string(r){return blunt_str_array_get(r,0)}
    function matched_group(r,i)
     {var _er_=caml_call2(Optdef[3],r[i],caml_js_to_byte_string);
      return caml_call1(Optdef[10],_er_)}
    var quote_repl_re=new regExp_withFlags("[$]","g");
    function quote_repl(s)
     {return caml_jsbytes_of_string(s).replace(quote_repl_re,"$$$$")}
    function global_replace(r,s,s_by)
     {r.lastIndex = 0;
      var _eq_=quote_repl(s_by);
      return caml_js_to_byte_string(caml_jsbytes_of_string(s).replace(r,_eq_))}
    function replace_first(r,s,s_by)
     {var
       match=r.ignoreCase | 0,
       match$0=r.multiline | 0,
       flags=0 === match?0 === match$0?"":"m":0 === match$0?"i":"mi",
       r$0=new regExp_withFlags(r.source,flags),
       _ep_=quote_repl(s_by);
      return caml_js_to_byte_string
              (caml_jsbytes_of_string(s).replace(r$0,_ep_))}
    function list_of_js_array(a)
     {var idx$1=a.length - 1 | 0,accu=0,idx=idx$1;
      for(;;)
       {if(caml_call2(symbol$5,idx,0))return accu;
        var
         idx$0=idx - 1 | 0,
         accu$0=[0,blunt_str_array_get(a,idx),accu],
         accu=accu$0,
         idx=idx$0;
        continue}}
    function split(r,s)
     {r.lastIndex = 0;
      return list_of_js_array(caml_jsbytes_of_string(s).split(r))}
    function bounded_split(r,s,i)
     {r.lastIndex = 0;
      return list_of_js_array(caml_jsbytes_of_string(s).split(r,i))}
    var quote_re=regexp(cst);
    function quote(s)
     {return caml_js_to_byte_string
              (caml_jsbytes_of_string(s).replace(quote_re,"\\$&"))}
    function regexp_string(s){return regexp(quote(s))}
    function regexp_string_case_fold(s){return regexp_case_fold(quote(s))}
    var
     Js_of_ocaml_Regexp=
      [0,
       regexp,
       regexp_case_fold,
       regexp_with_flag,
       quote,
       regexp_string,
       regexp_string_case_fold,
       string_match,
       search_forward,
       search_forward,
       matched_string,
       matched_group,
       global_replace,
       replace_first,
       split,
       bounded_split];
    caml_register_global(1650,Js_of_ocaml_Regexp,"Js_of_ocaml__Regexp");
    var Local_exn=[248,cst_Js_of_ocaml_Url_Local_exn,caml_fresh_oo_id(0)];
    function interrupt(param){throw Local_exn}
    var
     plus_re=regexp_string(cst$0),
     plus_re_js_string=new regExp_withFlags("\\+","g");
    function urldecode_js_string_string(s)
     {plus_re_js_string.lastIndex = 0;
      return caml_js_to_byte_string
              (unescape(s.replace(plus_re_js_string," ")))}
    function urldecode(s)
     {return caml_js_to_byte_string
              (unescape
                (caml_jsbytes_of_string(global_replace(plus_re,s,cst$1))))}
    function urlencode(opt,s)
     {if(opt)var sth=opt[1],with_plus=sth;else var with_plus=1;
      if(with_plus)
       {var s$0=caml_js_to_byte_string(escape(caml_jsbytes_of_string(s)));
        return global_replace(plus_re,s$0,cst_2B)}
      return caml_js_to_byte_string(escape(caml_jsbytes_of_string(s)))}
    var
     Not_an_http_protocol=
      [248,cst_Js_of_ocaml_Url_Not_an_http_protocol,caml_fresh_oo_id(0)],
     default_http_port=80,
     default_https_port=443;
    function path_of_path_string(s)
     {var l=caml_ml_string_length(s);
      function aux(i)
       {try
         {var _en_=caml_call3(String$0[18],s,i,47),j=_en_}
        catch(_eo_)
         {_eo_ = caml_wrap_exception(_eo_);
          if(_eo_ !== Not_found)throw _eo_;
          var j=l}
        var word=caml_call3(String$0[4],s,i,j - i | 0);
        return caml_call2(symbol$10,j,l)?[0,word,0]:[0,word,aux(j + 1 | 0)]}
      var a=aux(0);
      if(a)
       if(! caml_string_notequal(a[1],cst$2))
        {var _em_=a[2];
         if(! _em_)return 0;
         if(! caml_string_notequal(_em_[1],cst$3))if(! _em_[2])return _o_}
      return a}
    function encode_arguments(l)
     {function _eh_(param)
       {var
         v=param[2],
         n=param[1],
         _ej_=urlencode(0,v),
         _ek_=caml_call2(Pervasives[16],cst$4,_ej_),
         _el_=urlencode(0,n);
        return caml_call2(Pervasives[16],_el_,_ek_)}
      var _ei_=caml_call2(List[17],_eh_,l);
      return caml_call2(String$0[7],cst$5,_ei_)}
    function decode_arguments_js_string(s)
     {var arr=s.split(caml_call2(String$0[1],1,38).toString()),len=arr.length;
      function aux(acc,idx)
       {var idx$0=idx;
        for(;;)
         {if(caml_call2(symbol$5,idx$0,0))return acc;
          try
           {var
             _d$_=idx$0 - 1 | 0,
             _ea_=
              function(s)
               {function _ef_(param)
                 {var
                   y=param[2],
                   x=param[1],
                   _eg_=urldecode_js_string_string(y);
                  return [0,urldecode_js_string_string(x),_eg_]}
                var index=s.indexOf(caml_call2(String$0[1],1,61).toString());
                if(caml_call2(symbol$5,index,0))
                 var _ee_=t37;
                else
                 var
                  _ed_=s.slice(index + 1 | 0),
                  _ee_=[0,s.slice(0,index),_ed_];
                return caml_call3(Optdef[7],_ee_,interrupt,_ef_)},
             _eb_=
              aux
               ([0,caml_call3(Optdef[7],arr[idx$0],interrupt,_ea_),acc],_d$_);
            return _eb_}
          catch(_ec_)
           {_ec_ = caml_wrap_exception(_ec_);
            if(_ec_ === Local_exn)
             {var idx$1=idx$0 - 1 | 0,idx$0=idx$1;continue}
            throw _ec_}}}
      return aux(0,len - 1 | 0)}
    function decode_arguments(s)
     {return decode_arguments_js_string(caml_jsbytes_of_string(s))}
    var
     url_re=
      new
       regExp_withFlags
       (caml_jsbytes_of_string
         (cst_Hh_Tt_Tt_Pp_Ss_0_9a_zA_Z_0_9a_zA_Z_0_9A_Fa_f_0_9)),
     file_re=new regExp_withFlags(caml_jsbytes_of_string(cst_Ff_Ii_Ll_Ee));
    function url_of_js_string(s)
     {function _dS_(res)
       {var
         prot_string=caml_call2(Optdef[8],res[1],interrupt),
         match=caml_js_to_byte_string(prot_string.toLowerCase());
        if(caml_string_notequal(match,cst_file$0))
         if(caml_string_notequal(match,cst_file$1))
          {if(caml_string_notequal(match,cst_http))
            if(caml_string_notequal(match,cst_http$0))
             {if(caml_string_notequal(match,cst_https))
               if(caml_string_notequal(match,cst_https$0))
                var switch$0=1,switch$1=0;
               else
                var switch$1=1;
              else
               var switch$1=1;
              if(switch$1)var ssl=1,switch$0=2}
            else
             var switch$0=0;
           else
            var switch$0=0;
           switch(switch$0)
            {case 0:var ssl=0,switch$2=1;break;
             case 1:var switch$2=0;break;
             default:var switch$2=1}
           if(switch$2)
            {var
              _d2_=function(param){return caml_jsbytes_of_string(cst$7)},
              path_str=
               urldecode_js_string_string(caml_call2(Optdef[8],res[6],_d2_)),
              _d3_=function(param){return caml_jsbytes_of_string(cst$8)},
              _d4_=
               urldecode_js_string_string(caml_call2(Optdef[8],res[10],_d3_)),
              _d5_=function(param){return caml_jsbytes_of_string(cst$9)},
              _d6_=
               decode_arguments_js_string(caml_call2(Optdef[8],res[8],_d5_)),
              _d7_=path_of_path_string(path_str),
              _d8_=function(param){return caml_jsbytes_of_string(cst$10)},
              s=caml_js_to_byte_string(caml_call2(Optdef[8],res[4],_d8_)),
              _d9_=
               caml_string_notequal(s,cst$6)?caml_int_of_string(s):ssl?443:80,
              url=
               [0,
                urldecode_js_string_string
                 (caml_call2(Optdef[8],res[2],interrupt)),
                _d9_,
                _d7_,
                path_str,
                _d6_,
                _d4_],
              _d__=ssl?[1,url]:[0,url];
             return [0,_d__]}}
        throw Not_an_http_protocol}
      function _dT_(param)
       {function _dV_(res)
         {var
           path_str=
            urldecode_js_string_string(caml_call2(Optdef[8],res[2],interrupt));
          function _dY_(param){return caml_jsbytes_of_string(cst$11)}
          var _dZ_=caml_js_to_byte_string(caml_call2(Optdef[8],res[6],_dY_));
          function _d0_(param){return caml_jsbytes_of_string(cst$12)}
          var
           _d1_=
            decode_arguments_js_string(caml_call2(Optdef[8],res[4],_d0_));
          return [0,[2,[0,path_of_path_string(path_str),path_str,_d1_,_dZ_]]]}
        function _dW_(param){return 0}
        var _dX_=file_re.exec(s);
        return caml_call3(Opt[7],_dX_,_dW_,_dV_)}
      var _dU_=url_re.exec(s);
      return caml_call3(Opt[7],_dU_,_dT_,_dS_)}
    function url_of_string(s)
     {return url_of_js_string(caml_jsbytes_of_string(s))}
    function string_of_url(param)
     {switch(param[0])
       {case 0:
         var
          match=param[1],
          frag=match[6],
          args=match[5],
          path=match[3],
          port=match[2],
          host=match[1];
         if(caml_string_notequal(frag,cst$13))
          var
           _df_=urlencode(0,frag),
           _dg_=caml_call2(Pervasives[16],cst$14,_df_);
         else
          var _dg_=cst$21;
         if(args)
          var
           _dh_=encode_arguments(args),
           _di_=caml_call2(Pervasives[16],cst$15,_dh_);
         else
          var _di_=cst$20;
         var
          _dj_=caml_call2(Pervasives[16],_di_,_dg_),
          _dk_=function(x){return urlencode(0,x)},
          _dl_=caml_call2(List[17],_dk_,path),
          _dm_=caml_call2(String$0[7],cst$16,_dl_),
          _dn_=caml_call2(Pervasives[16],_dm_,_dj_),
          _do_=caml_call2(Pervasives[16],cst$17,_dn_);
         if(80 === port)
          var _dp_=cst$18;
         else
          var
           _dt_=caml_call1(Pervasives[21],port),
           _dp_=caml_call2(Pervasives[16],cst$19,_dt_);
         var
          _dq_=caml_call2(Pervasives[16],_dp_,_do_),
          _dr_=urlencode(0,host),
          _ds_=caml_call2(Pervasives[16],_dr_,_dq_);
         return caml_call2(Pervasives[16],cst_http$1,_ds_);
        case 1:
         var
          match$0=param[1],
          frag$0=match$0[6],
          args$0=match$0[5],
          path$0=match$0[3],
          port$0=match$0[2],
          host$0=match$0[1];
         if(caml_string_notequal(frag$0,cst$22))
          var
           _du_=urlencode(0,frag$0),
           _dv_=caml_call2(Pervasives[16],cst$23,_du_);
         else
          var _dv_=cst$30;
         if(args$0)
          var
           _dw_=encode_arguments(args$0),
           _dx_=caml_call2(Pervasives[16],cst$24,_dw_);
         else
          var _dx_=cst$29;
         var
          _dy_=caml_call2(Pervasives[16],_dx_,_dv_),
          _dz_=function(x){return urlencode(0,x)},
          _dA_=caml_call2(List[17],_dz_,path$0),
          _dB_=caml_call2(String$0[7],cst$25,_dA_),
          _dC_=caml_call2(Pervasives[16],_dB_,_dy_),
          _dD_=caml_call2(Pervasives[16],cst$26,_dC_);
         if(443 === port$0)
          var _dE_=cst$27;
         else
          var
           _dI_=caml_call1(Pervasives[21],port$0),
           _dE_=caml_call2(Pervasives[16],cst$28,_dI_);
         var
          _dF_=caml_call2(Pervasives[16],_dE_,_dD_),
          _dG_=urlencode(0,host$0),
          _dH_=caml_call2(Pervasives[16],_dG_,_dF_);
         return caml_call2(Pervasives[16],cst_https$1,_dH_);
        default:
         var
          match$1=param[1],
          frag$1=match$1[4],
          args$1=match$1[3],
          path$1=match$1[1];
         if(caml_string_notequal(frag$1,cst$31))
          var
           _dJ_=urlencode(0,frag$1),
           _dK_=caml_call2(Pervasives[16],cst$32,_dJ_);
         else
          var _dK_=cst$36;
         if(args$1)
          var
           _dL_=encode_arguments(args$1),
           _dM_=caml_call2(Pervasives[16],cst$33,_dL_);
         else
          var _dM_=cst$35;
         var
          _dN_=caml_call2(Pervasives[16],_dM_,_dK_),
          _dO_=function(x){return urlencode(0,x)},
          _dP_=caml_call2(List[17],_dO_,path$1),
          _dQ_=caml_call2(String$0[7],cst$34,_dP_),
          _dR_=caml_call2(Pervasives[16],_dQ_,_dN_);
         return caml_call2(Pervasives[16],cst_file$2,_dR_)}}
    var _p_=caml_call1(Optdef[2],_g_.location);
    if(caml_call1(Optdef[5],_p_))
     var _q_=_g_.location;
    else
     var
      t29="",
      t40=function(param,_de_){return 0},
      t39=function(param,_dd_){return 0},
      t38=function(param){return 0},
      _q_=
       {"href":t29,
        "protocol":t29,
        "host":t29,
        "hostname":t29,
        "port":t29,
        "pathname":t29,
        "search":t29,
        "hash":t29,
        "origin":t37,
        "reload":caml_js_wrap_meth_callback(t38),
        "replace":caml_js_wrap_meth_callback(t39),
        "assign":caml_js_wrap_meth_callback(t40)};
    var
     host=urldecode_js_string_string(_q_.hostname),
     protocol=urldecode_js_string_string(_q_.protocol),
     _r_=0,
     port=
      function(param)
        {try
          {var _db_=[0,caml_int_of_string(caml_js_to_byte_string(_q_.port))];
           return _db_}
         catch(_dc_)
          {_dc_ = caml_wrap_exception(_dc_);
           if(_dc_[1] === Failure)return 0;
           throw _dc_}}
       (_r_),
     path_string=urldecode_js_string_string(_q_.pathname),
     path=path_of_path_string(path_string),
     _s_=_q_.search.charAt(0) === "?"?_q_.search.slice(1):_q_.search,
     arguments$0=decode_arguments_js_string(_s_);
    function get_fragment(param)
     {function _c9_(res){return caml_js_to_string(res[1])}
      function _c__(param){return cst$37}
      var _c$_=new regExp_withFlags("#(.*)"),_da_=_q_.href.match(_c$_);
      return caml_call3(Opt[7],_da_,_c__,_c9_)}
    function set_fragment(s)
     {return _q_.hash = caml_jsbytes_of_string(urlencode(0,s))}
    function get$2(param){return url_of_js_string(_q_.href)}
    function set$0(u)
     {return _q_.href = caml_jsbytes_of_string(string_of_url(u))}
    var
     as_string=urldecode_js_string_string(_q_.href),
     Js_of_ocaml_Url=
      [0,
       urldecode,
       urlencode,
       default_http_port,
       default_https_port,
       path_of_path_string,
       encode_arguments,
       decode_arguments,
       url_of_string,
       string_of_url,
       [0,
        host,
        port,
        protocol,
        path_string,
        path,
        arguments$0,
        get_fragment,
        set_fragment,
        get$2,
        set$0,
        as_string]];
    caml_register_global(1653,Js_of_ocaml_Url,"Js_of_ocaml__Url");
    var Js_of_ocaml_Lib_version=[0,s,git_version];
    caml_register_global
     (1654,Js_of_ocaml_Lib_version,"Js_of_ocaml__Lib_version");
    function update_file(name,content)
     {var oc=caml_call1(Pervasives[48],name);
      caml_call2(Pervasives[54],oc,content);
      return caml_call1(Pervasives[64],oc)}
    function set_channel_flusher(out_channel,f)
     {var
       f$0=
        caml_js_wrap_callback
         (function(s){return caml_call1(f,caml_js_to_byte_string(s))});
      return runtime.caml_ml_set_channel_output(out_channel,f$0)}
    function set_channel_filler(in_channel,f)
     {var f$0=caml_js_wrap_callback(f);
      return runtime.caml_ml_set_channel_refill(in_channel,f$0)}
    function mount(path,f)
     {return runtime.caml_mount_autoload
              (path,
               caml_js_wrap_callback
                (function(prefix,path){return caml_call2(f,prefix,path)}))}
    var unmount=runtime.caml_unmount;
    if(caml_call2(String$0[35],git_version,cst$38))
     var js_of_ocaml_version=s;
    else
     var
      _cm_=caml_call2(Pervasives[16],cst$41,git_version),
      js_of_ocaml_version=caml_call2(Pervasives[16],s,_cm_);
    var
     _t_=runtime.caml_create_file,
     _u_=runtime.caml_read_file_content,
     Js_of_ocaml_Sys_js=
      [0,
       set_channel_flusher,
       set_channel_filler,
       function(_c8_){return runtime.caml_list_mount_point(_c8_)},
       unmount,
       mount,
       _u_,
       _t_,
       update_file,
       js_of_ocaml_version];
    caml_register_global(1655,Js_of_ocaml_Sys_js,"Js_of_ocaml__Sys_js");
    function empty_resize_observer_options(param){return {}}
    var resizeObserver=Unsafe[1].ResizeObserver;
    function is_supported$0(param)
     {return caml_call1(Optdef[5],resizeObserver)}
    function observe(node,f,box,param)
     {var obs=new resizeObserver(caml_js_wrap_callback(f));
      if(box)
       {var box$0=box[1],opts={};opts.box = box$0;obs.observe(node,opts)}
      else
       obs.observe(node);
      return obs}
    var
     Js_of_ocaml_ResizeObserver=
      [0,empty_resize_observer_options,resizeObserver,is_supported$0,observe];
    caml_register_global
     (1656,Js_of_ocaml_ResizeObserver,"Js_of_ocaml__ResizeObserver");
    function empty_mutation_observer_init(param){return {}}
    var mutationObserver=Unsafe[1].MutationObserver;
    function is_supported$1(param)
     {return caml_call1(Optdef[5],mutationObserver)}
    function observe$0
     (node,
      f,
      child_list,
      attributes,
      character_data,
      subtree,
      attribute_old_value,
      character_data_old_value,
      attribute_filter,
      param)
     {function opt_iter(x,f)
       {if(x){var x$0=x[1];return caml_call1(f,x$0)}return 0}
      var obs=new mutationObserver(caml_js_wrap_callback(f)),cfg={};
      opt_iter(child_list,function(v){return cfg.childList = v});
      opt_iter(attributes,function(v){return cfg.attributes = v});
      opt_iter(character_data,function(v){return cfg.characterData = v});
      opt_iter(subtree,function(v){return cfg.subtree = v});
      opt_iter
       (attribute_old_value,function(v){return cfg.attributeOldValue = v});
      opt_iter
       (character_data_old_value,
        function(v){return cfg.characterDataOldValue = v});
      opt_iter
       (attribute_filter,
        function(l)
         {return cfg.attributeFilter
                 =
                 caml_js_from_array(caml_call1(Array[12],l))});
      obs.observe(node,cfg);
      return obs}
    var
     Js_of_ocaml_MutationObserver=
      [0,
       empty_mutation_observer_init,
       mutationObserver,
       is_supported$1,
       observe$0];
    caml_register_global
     (1657,Js_of_ocaml_MutationObserver,"Js_of_ocaml__MutationObserver");
    var obj=Unsafe[1].Object;
    function create$1(param){return new obj()}
    function add$0(t,k,v){return t[k.concat("_")] = v}
    function remove(t,k){return delete t[k.concat("_")]}
    function find(t,k){return t[k.concat("_")]}
    function keys(t)
     {var
       key_array=Unsafe[1].Object.keys(t),
       res=[0,0],
       _c4_=key_array.length - 1 | 0,
       _c3_=0;
      if(! (_c4_ < 0))
       {var i=_c3_;
        for(;;)
         {var
           _c5_=
            function(param){return caml_call1(Pervasives[2],cst_Jstable_keys)},
           key=caml_call2(Optdef[8],key_array[i],_c5_),
           _c6_=res[1];
          res[1] = [0,key.substring(0,key.length - 1 | 0),_c6_];
          var _c7_=i + 1 | 0;
          if(_c4_ !== i){var i=_c7_;continue}
          break}}
      return caml_call1(List[9],res[1])}
    var Js_of_ocaml_Jstable=[0,create$1,add$0,remove,find,keys];
    caml_register_global(1658,Js_of_ocaml_Jstable,"Js_of_ocaml__Jstable");
    var json=runtime.caml_json(0);
    function reviver(this$0,key,value)
     {return typeof value == typeof "foo"?caml_js_to_byte_string(value):value}
    var input_reviver=caml_js_wrap_meth_callback(reviver);
    function unsafe_input(s){return json.parse(s,input_reviver)}
    var mlString_constr=dummy_string.constructor;
    function output_reviver(key,value)
     {return value instanceof mlString_constr
              ?caml_jsbytes_of_string(value)
              :value}
    function output(obj){return json.stringify(obj,output_reviver)}
    var Js_of_ocaml_Json=[0,output,unsafe_input];
    caml_register_global(1659,Js_of_ocaml_Json,"Js_of_ocaml__Json");
    function string_of_name(param)
     {var _c2_=param;
      if(74 <= _c2_)
       {if(111 <= _c2_)
         switch(_c2_)
          {case 111:return cst_palevioletred;
           case 112:return cst_papayawhip;
           case 113:return cst_peachpuff;
           case 114:return cst_peru;
           case 115:return cst_pink;
           case 116:return cst_plum;
           case 117:return cst_powderblue;
           case 118:return cst_purple;
           case 119:return cst_red;
           case 120:return cst_rosybrown;
           case 121:return cst_royalblue;
           case 122:return cst_saddlebrown;
           case 123:return cst_salmon;
           case 124:return cst_sandybrown;
           case 125:return cst_seagreen;
           case 126:return cst_seashell;
           case 127:return cst_sienna;
           case 128:return cst_silver;
           case 129:return cst_skyblue;
           case 130:return cst_slateblue;
           case 131:return cst_slategray;
           case 132:return cst_slategrey;
           case 133:return cst_snow;
           case 134:return cst_springgreen;
           case 135:return cst_steelblue;
           case 136:return cst_tan;
           case 137:return cst_teal;
           case 138:return cst_thistle;
           case 139:return cst_tomato;
           case 140:return cst_turquoise;
           case 141:return cst_violet;
           case 142:return cst_wheat;
           case 143:return cst_white;
           case 144:return cst_whitesmoke;
           case 145:return cst_yellow;
           default:return cst_yellowgreen}
        switch(_c2_)
         {case 74:return cst_lightpink;
          case 75:return cst_lightsalmon;
          case 76:return cst_lightseagreen;
          case 77:return cst_lightskyblue;
          case 78:return cst_lightslategray;
          case 79:return cst_lightslategrey;
          case 80:return cst_lightsteelblue;
          case 81:return cst_lightyellow;
          case 82:return cst_lime;
          case 83:return cst_limegreen;
          case 84:return cst_linen;
          case 85:return cst_magenta;
          case 86:return cst_maroon;
          case 87:return cst_mediumaquamarine;
          case 88:return cst_mediumblue;
          case 89:return cst_mediumorchid;
          case 90:return cst_mediumpurple;
          case 91:return cst_mediumseagreen;
          case 92:return cst_mediumslateblue;
          case 93:return cst_mediumspringgreen;
          case 94:return cst_mediumturquoise;
          case 95:return cst_mediumvioletred;
          case 96:return cst_midnightblue;
          case 97:return cst_mintcream;
          case 98:return cst_mistyrose;
          case 99:return cst_moccasin;
          case 100:return cst_navajowhite;
          case 101:return cst_navy;
          case 102:return cst_oldlace;
          case 103:return cst_olive;
          case 104:return cst_olivedrab;
          case 105:return cst_orange;
          case 106:return cst_orangered;
          case 107:return cst_orchid;
          case 108:return cst_palegoldenrod;
          case 109:return cst_palegreen;
          default:return cst_paleturquoise}}
      if(37 <= _c2_)
       switch(_c2_)
        {case 37:return cst_darkslategrey;
         case 38:return cst_darkturquoise;
         case 39:return cst_darkviolet;
         case 40:return cst_deeppink;
         case 41:return cst_deepskyblue;
         case 42:return cst_dimgray;
         case 43:return cst_dimgrey;
         case 44:return cst_dodgerblue;
         case 45:return cst_firebrick;
         case 46:return cst_floralwhite;
         case 47:return cst_forestgreen;
         case 48:return cst_fuchsia;
         case 49:return cst_gainsboro;
         case 50:return cst_ghostwhite;
         case 51:return cst_gold;
         case 52:return cst_goldenrod;
         case 53:return cst_gray;
         case 54:return cst_grey;
         case 55:return cst_green;
         case 56:return cst_greenyellow;
         case 57:return cst_honeydew;
         case 58:return cst_hotpink;
         case 59:return cst_indianred;
         case 60:return cst_indigo;
         case 61:return cst_ivory;
         case 62:return cst_khaki;
         case 63:return cst_lavender;
         case 64:return cst_lavenderblush;
         case 65:return cst_lawngreen;
         case 66:return cst_lemonchiffon;
         case 67:return cst_lightblue;
         case 68:return cst_lightcoral;
         case 69:return cst_lightcyan;
         case 70:return cst_lightgoldenrodyellow;
         case 71:return cst_lightgray;
         case 72:return cst_lightgreen;
         default:return cst_lightgrey}
      switch(_c2_)
       {case 0:return cst_aliceblue;
        case 1:return cst_antiquewhite;
        case 2:return cst_aqua;
        case 3:return cst_aquamarine;
        case 4:return cst_azure;
        case 5:return cst_beige;
        case 6:return cst_bisque;
        case 7:return cst_black;
        case 8:return cst_blanchedalmond;
        case 9:return cst_blue;
        case 10:return cst_blueviolet;
        case 11:return cst_brown;
        case 12:return cst_burlywood;
        case 13:return cst_cadetblue;
        case 14:return cst_chartreuse;
        case 15:return cst_chocolate;
        case 16:return cst_coral;
        case 17:return cst_cornflowerblue;
        case 18:return cst_cornsilk;
        case 19:return cst_crimson;
        case 20:return cst_cyan;
        case 21:return cst_darkblue;
        case 22:return cst_darkcyan;
        case 23:return cst_darkgoldenrod;
        case 24:return cst_darkgray;
        case 25:return cst_darkgreen;
        case 26:return cst_darkgrey;
        case 27:return cst_darkkhaki;
        case 28:return cst_darkmagenta;
        case 29:return cst_darkolivegreen;
        case 30:return cst_darkorange;
        case 31:return cst_darkorchid;
        case 32:return cst_darkred;
        case 33:return cst_darksalmon;
        case 34:return cst_darkseagreen;
        case 35:return cst_darkslateblue;
        default:return cst_darkslategray}}
    function name_of_string(s)
     {var switch$0=caml_string_compare(s,cst_lightgrey$0);
      if(0 <= switch$0)
       {if(! (0 < switch$0))return 73;
        var switch$1=caml_string_compare(s,cst_paleturquoise$0);
        if(0 <= switch$1)
         {if(! (0 < switch$1))return 110;
          var switch$2=caml_string_compare(s,cst_skyblue$0);
          if(0 <= switch$2)
           {if(! (0 < switch$2))return 129;
            var switch$3=caml_string_compare(s,cst_thistle$0);
            if(0 <= switch$3)
             {if(! (0 < switch$3))return 138;
              if(! caml_string_notequal(s,cst_tomato$0))return 139;
              if(! caml_string_notequal(s,cst_turquoise$0))return 140;
              if(! caml_string_notequal(s,cst_violet$0))return 141;
              if(! caml_string_notequal(s,cst_wheat$0))return 142;
              if(! caml_string_notequal(s,cst_white$0))return 143;
              if(! caml_string_notequal(s,cst_whitesmoke$0))return 144;
              if(! caml_string_notequal(s,cst_yellow$0))return 145;
              if(! caml_string_notequal(s,cst_yellowgreen$0))return 146}
            else
             {if(! caml_string_notequal(s,cst_slateblue$0))return 130;
              if(! caml_string_notequal(s,cst_slategray$0))return 131;
              if(! caml_string_notequal(s,cst_slategrey$0))return 132;
              if(! caml_string_notequal(s,cst_snow$0))return 133;
              if(! caml_string_notequal(s,cst_springgreen$0))return 134;
              if(! caml_string_notequal(s,cst_steelblue$0))return 135;
              if(! caml_string_notequal(s,cst_tan$0))return 136;
              if(! caml_string_notequal(s,cst_teal$0))return 137}}
          else
           {var switch$4=caml_string_compare(s,cst_rosybrown$0);
            if(0 <= switch$4)
             {if(! (0 < switch$4))return 120;
              if(! caml_string_notequal(s,cst_royalblue$0))return 121;
              if(! caml_string_notequal(s,cst_saddlebrown$0))return 122;
              if(! caml_string_notequal(s,cst_salmon$0))return 123;
              if(! caml_string_notequal(s,cst_sandybrown$0))return 124;
              if(! caml_string_notequal(s,cst_seagreen$0))return 125;
              if(! caml_string_notequal(s,cst_seashell$0))return 126;
              if(! caml_string_notequal(s,cst_sienna$0))return 127;
              if(! caml_string_notequal(s,cst_silver$0))return 128}
            else
             {if(! caml_string_notequal(s,cst_palevioletred$0))return 111;
              if(! caml_string_notequal(s,cst_papayawhip$0))return 112;
              if(! caml_string_notequal(s,cst_peachpuff$0))return 113;
              if(! caml_string_notequal(s,cst_peru$0))return 114;
              if(! caml_string_notequal(s,cst_pink$0))return 115;
              if(! caml_string_notequal(s,cst_plum$0))return 116;
              if(! caml_string_notequal(s,cst_powderblue$0))return 117;
              if(! caml_string_notequal(s,cst_purple$0))return 118;
              if(! caml_string_notequal(s,cst_red$0))return 119}}}
        else
         {var switch$5=caml_string_compare(s,cst_mediumslateblue$0);
          if(0 <= switch$5)
           {if(! (0 < switch$5))return 92;
            var switch$6=caml_string_compare(s,cst_navy$0);
            if(0 <= switch$6)
             {if(! (0 < switch$6))return 101;
              if(! caml_string_notequal(s,cst_oldlace$0))return 102;
              if(! caml_string_notequal(s,cst_olive$0))return 103;
              if(! caml_string_notequal(s,cst_olivedrab$0))return 104;
              if(! caml_string_notequal(s,cst_orange$0))return 105;
              if(! caml_string_notequal(s,cst_orangered$0))return 106;
              if(! caml_string_notequal(s,cst_orchid$0))return 107;
              if(! caml_string_notequal(s,cst_palegoldenrod$0))return 108;
              if(! caml_string_notequal(s,cst_palegreen$0))return 109}
            else
             {if(! caml_string_notequal(s,cst_mediumspringgreen$0))return 93;
              if(! caml_string_notequal(s,cst_mediumturquoise$0))return 94;
              if(! caml_string_notequal(s,cst_mediumvioletred$0))return 95;
              if(! caml_string_notequal(s,cst_midnightblue$0))return 96;
              if(! caml_string_notequal(s,cst_mintcream$0))return 97;
              if(! caml_string_notequal(s,cst_mistyrose$0))return 98;
              if(! caml_string_notequal(s,cst_moccasin$0))return 99;
              if(! caml_string_notequal(s,cst_navajowhite$0))return 100}}
          else
           {var switch$7=caml_string_compare(s,cst_limegreen$0);
            if(0 <= switch$7)
             {if(! (0 < switch$7))return 83;
              if(! caml_string_notequal(s,cst_linen$0))return 84;
              if(! caml_string_notequal(s,cst_magenta$0))return 85;
              if(! caml_string_notequal(s,cst_maroon$0))return 86;
              if(! caml_string_notequal(s,cst_mediumaquamarine$0))return 87;
              if(! caml_string_notequal(s,cst_mediumblue$0))return 88;
              if(! caml_string_notequal(s,cst_mediumorchid$0))return 89;
              if(! caml_string_notequal(s,cst_mediumpurple$0))return 90;
              if(! caml_string_notequal(s,cst_mediumseagreen$0))return 91}
            else
             {if(! caml_string_notequal(s,cst_lightpink$0))return 74;
              if(! caml_string_notequal(s,cst_lightsalmon$0))return 75;
              if(! caml_string_notequal(s,cst_lightseagreen$0))return 76;
              if(! caml_string_notequal(s,cst_lightskyblue$0))return 77;
              if(! caml_string_notequal(s,cst_lightslategray$0))return 78;
              if(! caml_string_notequal(s,cst_lightslategrey$0))return 79;
              if(! caml_string_notequal(s,cst_lightsteelblue$0))return 80;
              if(! caml_string_notequal(s,cst_lightyellow$0))return 81;
              if(! caml_string_notequal(s,cst_lime$0))return 82}}}}
      else
       {var switch$8=caml_string_compare(s,cst_darkslategray$0);
        if(0 <= switch$8)
         {if(! (0 < switch$8))return 36;
          var switch$9=caml_string_compare(s,cst_greenyellow$0);
          if(0 <= switch$9)
           {if(! (0 < switch$9))return 56;
            var switch$10=caml_string_compare(s,cst_lavenderblush$0);
            if(0 <= switch$10)
             {if(! (0 < switch$10))return 64;
              if(! caml_string_notequal(s,cst_lawngreen$0))return 65;
              if(! caml_string_notequal(s,cst_lemonchiffon$0))return 66;
              if(! caml_string_notequal(s,cst_lightblue$0))return 67;
              if(! caml_string_notequal(s,cst_lightcoral$0))return 68;
              if(! caml_string_notequal(s,cst_lightcyan$0))return 69;
              if(! caml_string_notequal(s,cst_lightgoldenrodyellow$0))
               return 70;
              if(! caml_string_notequal(s,cst_lightgray$0))return 71;
              if(! caml_string_notequal(s,cst_lightgreen$0))return 72}
            else
             {if(! caml_string_notequal(s,cst_grey$0))return 54;
              if(! caml_string_notequal(s,cst_honeydew$0))return 57;
              if(! caml_string_notequal(s,cst_hotpink$0))return 58;
              if(! caml_string_notequal(s,cst_indianred$0))return 59;
              if(! caml_string_notequal(s,cst_indigo$0))return 60;
              if(! caml_string_notequal(s,cst_ivory$0))return 61;
              if(! caml_string_notequal(s,cst_khaki$0))return 62;
              if(! caml_string_notequal(s,cst_lavender$0))return 63}}
          else
           {var switch$11=caml_string_compare(s,cst_floralwhite$0);
            if(0 <= switch$11)
             {if(! (0 < switch$11))return 46;
              if(! caml_string_notequal(s,cst_forestgreen$0))return 47;
              if(! caml_string_notequal(s,cst_fuchsia$0))return 48;
              if(! caml_string_notequal(s,cst_gainsboro$0))return 49;
              if(! caml_string_notequal(s,cst_ghostwhite$0))return 50;
              if(! caml_string_notequal(s,cst_gold$0))return 51;
              if(! caml_string_notequal(s,cst_goldenrod$0))return 52;
              if(! caml_string_notequal(s,cst_gray$0))return 53;
              if(! caml_string_notequal(s,cst_green$0))return 55}
            else
             {if(! caml_string_notequal(s,cst_darkslategrey$0))return 37;
              if(! caml_string_notequal(s,cst_darkturquoise$0))return 38;
              if(! caml_string_notequal(s,cst_darkviolet$0))return 39;
              if(! caml_string_notequal(s,cst_deeppink$0))return 40;
              if(! caml_string_notequal(s,cst_deepskyblue$0))return 41;
              if(! caml_string_notequal(s,cst_dimgray$0))return 42;
              if(! caml_string_notequal(s,cst_dimgrey$0))return 43;
              if(! caml_string_notequal(s,cst_dodgerblue$0))return 44;
              if(! caml_string_notequal(s,cst_firebrick$0))return 45}}}
        else
         {var switch$12=caml_string_compare(s,cst_cornsilk$0);
          if(0 <= switch$12)
           {if(! (0 < switch$12))return 18;
            var switch$13=caml_string_compare(s,cst_darkkhaki$0);
            if(0 <= switch$13)
             {if(! (0 < switch$13))return 27;
              if(! caml_string_notequal(s,cst_darkmagenta$0))return 28;
              if(! caml_string_notequal(s,cst_darkolivegreen$0))return 29;
              if(! caml_string_notequal(s,cst_darkorange$0))return 30;
              if(! caml_string_notequal(s,cst_darkorchid$0))return 31;
              if(! caml_string_notequal(s,cst_darkred$0))return 32;
              if(! caml_string_notequal(s,cst_darksalmon$0))return 33;
              if(! caml_string_notequal(s,cst_darkseagreen$0))return 34;
              if(! caml_string_notequal(s,cst_darkslateblue$0))return 35}
            else
             {if(! caml_string_notequal(s,cst_crimson$0))return 19;
              if(! caml_string_notequal(s,cst_cyan$0))return 20;
              if(! caml_string_notequal(s,cst_darkblue$0))return 21;
              if(! caml_string_notequal(s,cst_darkcyan$0))return 22;
              if(! caml_string_notequal(s,cst_darkgoldenrod$0))return 23;
              if(! caml_string_notequal(s,cst_darkgray$0))return 24;
              if(! caml_string_notequal(s,cst_darkgreen$0))return 25;
              if(! caml_string_notequal(s,cst_darkgrey$0))return 26}}
          else
           {var switch$14=caml_string_compare(s,cst_blue$0);
            if(0 <= switch$14)
             {if(! (0 < switch$14))return 9;
              if(! caml_string_notequal(s,cst_blueviolet$0))return 10;
              if(! caml_string_notequal(s,cst_brown$0))return 11;
              if(! caml_string_notequal(s,cst_burlywood$0))return 12;
              if(! caml_string_notequal(s,cst_cadetblue$0))return 13;
              if(! caml_string_notequal(s,cst_chartreuse$0))return 14;
              if(! caml_string_notequal(s,cst_chocolate$0))return 15;
              if(! caml_string_notequal(s,cst_coral$0))return 16;
              if(! caml_string_notequal(s,cst_cornflowerblue$0))return 17}
            else
             {if(! caml_string_notequal(s,cst_aliceblue$0))return 0;
              if(! caml_string_notequal(s,cst_antiquewhite$0))return 1;
              if(! caml_string_notequal(s,cst_aqua$0))return 2;
              if(! caml_string_notequal(s,cst_aquamarine$0))return 3;
              if(! caml_string_notequal(s,cst_azure$0))return 4;
              if(! caml_string_notequal(s,cst_beige$0))return 5;
              if(! caml_string_notequal(s,cst_bisque$0))return 6;
              if(! caml_string_notequal(s,cst_black$0))return 7;
              if(! caml_string_notequal(s,cst_blanchedalmond$0))return 8}}}}
      throw [0,
             Invalid_argument,
             caml_call2(Pervasives[16],s,cst_is_not_a_valid_color_name)]}
    function rgb_of_name(param)
     {var _c1_=param;
      if(74 <= _c1_)
       {if(111 <= _c1_)
         switch(_c1_)
          {case 111:return _bo_;
           case 112:return _bp_;
           case 113:return _bq_;
           case 114:return _br_;
           case 115:return _bs_;
           case 116:return _bt_;
           case 117:return _bu_;
           case 118:return _bv_;
           case 119:return _bw_;
           case 120:return _bx_;
           case 121:return _by_;
           case 122:return _bz_;
           case 123:return _bA_;
           case 124:return _bB_;
           case 125:return _bC_;
           case 126:return _bD_;
           case 127:return _bE_;
           case 128:return _bF_;
           case 129:return _bG_;
           case 130:return _bH_;
           case 131:return _bI_;
           case 132:return _bJ_;
           case 133:return _bK_;
           case 134:return _bL_;
           case 135:return _bM_;
           case 136:return _bN_;
           case 137:return _bO_;
           case 138:return _bP_;
           case 139:return _bQ_;
           case 140:return _bR_;
           case 141:return _bS_;
           case 142:return _bT_;
           case 143:return _bU_;
           case 144:return _bV_;
           case 145:return _bW_;
           default:return _bX_}
        switch(_c1_)
         {case 74:return _aP_;
          case 75:return _aQ_;
          case 76:return _aR_;
          case 77:return _aS_;
          case 78:return _aT_;
          case 79:return _aU_;
          case 80:return _aV_;
          case 81:return _aW_;
          case 82:return _aX_;
          case 83:return _aY_;
          case 84:return _aZ_;
          case 85:return _a0_;
          case 86:return _a1_;
          case 87:return _a2_;
          case 88:return _a3_;
          case 89:return _a4_;
          case 90:return _a5_;
          case 91:return _a6_;
          case 92:return _a7_;
          case 93:return _a8_;
          case 94:return _a9_;
          case 95:return _a__;
          case 96:return _a$_;
          case 97:return _ba_;
          case 98:return _bb_;
          case 99:return _bc_;
          case 100:return _bd_;
          case 101:return _be_;
          case 102:return _bf_;
          case 103:return _bg_;
          case 104:return _bh_;
          case 105:return _bi_;
          case 106:return _bj_;
          case 107:return _bk_;
          case 108:return _bl_;
          case 109:return _bm_;
          default:return _bn_}}
      if(37 <= _c1_)
       switch(_c1_)
        {case 37:return _ae_;
         case 38:return _af_;
         case 39:return _ag_;
         case 40:return _ah_;
         case 41:return _ai_;
         case 42:return _aj_;
         case 43:return _ak_;
         case 44:return _al_;
         case 45:return _am_;
         case 46:return _an_;
         case 47:return _ao_;
         case 48:return _ap_;
         case 49:return _aq_;
         case 50:return _ar_;
         case 51:return _as_;
         case 52:return _at_;
         case 53:return _au_;
         case 54:return _av_;
         case 55:return _aw_;
         case 56:return _ax_;
         case 57:return _ay_;
         case 58:return _az_;
         case 59:return _aA_;
         case 60:return _aB_;
         case 61:return _aC_;
         case 62:return _aD_;
         case 63:return _aE_;
         case 64:return _aF_;
         case 65:return _aG_;
         case 66:return _aH_;
         case 67:return _aI_;
         case 68:return _aJ_;
         case 69:return _aK_;
         case 70:return _aL_;
         case 71:return _aM_;
         case 72:return _aN_;
         default:return _aO_}
      switch(_c1_)
       {case 0:return _v_;
        case 1:return _w_;
        case 2:return _x_;
        case 3:return _y_;
        case 4:return _z_;
        case 5:return _A_;
        case 6:return _B_;
        case 7:return _C_;
        case 8:return _D_;
        case 9:return _E_;
        case 10:return _F_;
        case 11:return _G_;
        case 12:return _H_;
        case 13:return _I_;
        case 14:return _J_;
        case 15:return _K_;
        case 16:return _L_;
        case 17:return _M_;
        case 18:return _N_;
        case 19:return _O_;
        case 20:return _P_;
        case 21:return _Q_;
        case 22:return _R_;
        case 23:return _S_;
        case 24:return _T_;
        case 25:return _U_;
        case 26:return _V_;
        case 27:return _W_;
        case 28:return _X_;
        case 29:return _Y_;
        case 30:return _Z_;
        case 31:return ___;
        case 32:return _$_;
        case 33:return _aa_;
        case 34:return _ab_;
        case 35:return _ac_;
        default:return _ad_}}
    function rgb(a,r,g,b)
     {if(a){var a$0=a[1];return [3,[0,r,g,b,a$0]]}return [1,[0,r,g,b]]}
    function hsl(a,h,s,l)
     {if(a){var a$0=a[1];return [6,[0,h,s,l,a$0]]}return [5,[0,h,s,l]]}
    function string_of_t(param)
     {switch(param[0])
       {case 0:var n=param[1];return string_of_name(n);
        case 1:
         var match=param[1],b=match[3],g=match[2],r=match[1];
         return caml_call4(Printf[4],_bY_,r,g,b);
        case 2:
         var match$0=param[1],b$0=match$0[3],g$0=match$0[2],r$0=match$0[1];
         return caml_call4(Printf[4],_bZ_,r$0,g$0,b$0);
        case 3:
         var
          match$1=param[1],
          a=match$1[4],
          b$1=match$1[3],
          g$1=match$1[2],
          r$1=match$1[1];
         return caml_call5(Printf[4],_b0_,r$1,g$1,b$1,a);
        case 4:
         var
          match$2=param[1],
          a$0=match$2[4],
          b$2=match$2[3],
          g$2=match$2[2],
          r$2=match$2[1];
         return caml_call5(Printf[4],_b1_,r$2,g$2,b$2,a$0);
        case 5:
         var match$3=param[1],l=match$3[3],s=match$3[2],h=match$3[1];
         return caml_call4(Printf[4],_b2_,h,s,l);
        default:
         var
          match$4=param[1],
          a$1=match$4[4],
          l$0=match$4[3],
          s$0=match$4[2],
          h$0=match$4[1];
         return caml_call5(Printf[4],_b3_,h$0,s$0,l$0,a$1)}}
    function hex_of_rgb(param)
     {var blue=param[3],green=param[2],red=param[1];
      function in_range(i)
       {var
         _cY_=caml_call2(symbol$5,i,0),
         _cZ_=_cY_ || caml_call2(symbol$9,i,255);
        if(_cZ_)
         {var _c0_=caml_call1(Pervasives[21],i);
          throw [0,
                 Invalid_argument,
                 caml_call2(Pervasives[16],_c0_,cst_is_out_of_valid_range)]}
        return _cZ_}
      in_range(red);
      in_range(green);
      in_range(blue);
      return caml_call4(Printf[4],_b4_,red,green,blue)}
    function js_t_of_js_string(s)
     {var
       rgb_re=
        new regExp_withFlags(caml_jsbytes_of_string(cst_rgb_s_d_s_d_s_d)),
       rgb_pct_re=
        new regExp_withFlags(caml_jsbytes_of_string(cst_rgb_s_d_s_d_s_d$0)),
       rgba_re=
        new regExp_withFlags(caml_jsbytes_of_string(cst_rgba_s_d_s_d_s_d_d_d)),
       rgba_pct_re=
        new
         regExp_withFlags
         (caml_jsbytes_of_string(cst_rgba_s_d_s_d_s_d_d_d$0)),
       hsl_re=
        new regExp_withFlags(caml_jsbytes_of_string(cst_hsl_s_d_s_d_s_d)),
       hsla_re=
        new regExp_withFlags(caml_jsbytes_of_string(cst_hsla_s_d_s_d_s_d_d_d));
      if(! (rgb_re.test(s) | 0))
       if(! (rgba_re.test(s) | 0))
        if(! (rgb_pct_re.test(s) | 0))
         if(! (rgba_pct_re.test(s) | 0))
          if(! (hsl_re.test(s) | 0))
           if(! (hsla_re.test(s) | 0))
            {if(caml_call2(List[31],caml_js_to_string(s),_b5_))return s;
             throw [0,
                    Invalid_argument,
                    caml_call2
                     (Pervasives[16],
                      caml_js_to_string(s),
                      cst_is_not_a_valid_color)]}
      return s}
    function js(c)
     {if(0 === c[0]){var n=c[1];return string_of_name(n).toString()}
      return string_of_t(c).toString()}
    function ml(c)
     {var s=caml_js_to_string(c);
      try
       {var _cO_=[0,name_of_string(s)];return _cO_}
      catch(_cP_)
       {_cP_ = caml_wrap_exception(_cP_);
        if(_cP_[1] === Invalid_argument)
         {var
           fail=
            function(param)
             {throw [0,
                     Invalid_argument,
                     caml_call2(Pervasives[16],s,cst_is_not_a_valid_color$0)]},
           re_rgb=regexp(cst_rgba_d_d_d_d_d),
           re_rgb_pct=regexp(cst_rgba_d_d_d_d_d$0),
           re_hsl=regexp(cst_hsla_d_d_d_d_d),
           i_of_s_o=
            function(param)
             {if(param)
               {var i=param[1];
                try
                 {var _cW_=caml_int_of_string(i);return _cW_}
                catch(_cX_)
                 {_cX_ = caml_wrap_exception(_cX_);
                  if(_cX_[1] === Invalid_argument)
                   var s=_cX_[2];
                  else
                   {if(_cX_[1] !== Failure)throw _cX_;var s=_cX_[2]}
                  var
                   _cU_=caml_call2(Pervasives[16],cst$39,s),
                   _cV_=caml_call2(Pervasives[16],i,_cU_);
                  throw [0,
                         Invalid_argument,
                         caml_call2(Pervasives[16],cst_color_conversion_error,_cV_)]}}
              return fail(0)},
           f_of_s=
            function(f)
             {try
               {var _cS_=caml_float_of_string(f);return _cS_}
              catch(_cT_)
               {_cT_ = caml_wrap_exception(_cT_);
                if(_cT_[1] === Invalid_argument)
                 var s=_cT_[2];
                else
                 {if(_cT_[1] !== Failure)throw _cT_;var s=_cT_[2]}
                var
                 _cQ_=caml_call2(Pervasives[16],cst$40,s),
                 _cR_=caml_call2(Pervasives[16],f,_cQ_);
                throw [0,
                       Invalid_argument,
                       caml_call2(Pervasives[16],cst_color_conversion_error$0,_cR_)]}},
           match=string_match(re_rgb,s,0);
          if(match)
           {var
             r=match[1],
             red=matched_group(r,2),
             green=matched_group(r,3),
             blue=matched_group(r,4),
             alpha=matched_group(r,5),
             match$0=matched_group(r,1);
            if(match$0)
             {var _cw_=match$0[1];
              if(! caml_string_notequal(_cw_,cst_rgb))
               {if(alpha)return fail(0);
                var _cA_=i_of_s_o(blue),_cB_=i_of_s_o(green);
                return [1,[0,i_of_s_o(red),_cB_,_cA_]]}
              if(! caml_string_notequal(_cw_,cst_rgba))
               {if(alpha)
                 {var
                   a=alpha[1],
                   _cx_=f_of_s(a),
                   _cy_=i_of_s_o(blue),
                   _cz_=i_of_s_o(green);
                  return [3,[0,i_of_s_o(red),_cz_,_cy_,_cx_]]}
                return fail(0)}}
            return fail(0)}
          var match$1=string_match(re_rgb_pct,s,0);
          if(match$1)
           {var
             r$0=match$1[1],
             red$0=matched_group(r$0,2),
             green$0=matched_group(r$0,3),
             blue$0=matched_group(r$0,4),
             alpha$0=matched_group(r$0,5),
             match$2=matched_group(r$0,1);
            if(match$2)
             {var _cC_=match$2[1];
              if(! caml_string_notequal(_cC_,cst_rgb$0))
               {if(alpha$0)return fail(0);
                var _cG_=i_of_s_o(blue$0),_cH_=i_of_s_o(green$0);
                return [2,[0,i_of_s_o(red$0),_cH_,_cG_]]}
              if(! caml_string_notequal(_cC_,cst_rgba$0))
               {if(alpha$0)
                 {var
                   a$0=alpha$0[1],
                   _cD_=f_of_s(a$0),
                   _cE_=i_of_s_o(blue$0),
                   _cF_=i_of_s_o(green$0);
                  return [4,[0,i_of_s_o(red$0),_cF_,_cE_,_cD_]]}
                return fail(0)}}
            return fail(0)}
          var match$3=string_match(re_hsl,s,0);
          if(match$3)
           {var
             r$1=match$3[1],
             red$1=matched_group(r$1,2),
             green$1=matched_group(r$1,3),
             blue$1=matched_group(r$1,4),
             alpha$1=matched_group(r$1,5),
             match$4=matched_group(r$1,1);
            if(match$4)
             {var _cI_=match$4[1];
              if(! caml_string_notequal(_cI_,cst_hsl))
               {if(alpha$1)return fail(0);
                var _cM_=i_of_s_o(blue$1),_cN_=i_of_s_o(green$1);
                return [5,[0,i_of_s_o(red$1),_cN_,_cM_]]}
              if(! caml_string_notequal(_cI_,cst_hsla))
               {if(alpha$1)
                 {var
                   a$1=alpha$1[1],
                   _cJ_=f_of_s(a$1),
                   _cK_=i_of_s_o(blue$1),
                   _cL_=i_of_s_o(green$1);
                  return [6,[0,i_of_s_o(red$1),_cL_,_cK_,_cJ_]]}
                return fail(0)}}
            return fail(0)}
          return fail(0)}
        throw _cP_}}
    function string_of_t$0(param)
     {if(typeof param === "number")
       return cst_0;
      else
       switch(param[0])
        {case 0:var f=param[1];return caml_call3(Printf[4],_b6_,f,cst_em$0);
         case 1:var f$0=param[1];return caml_call3(Printf[4],_b7_,f$0,cst_ex);
         case 2:var f$1=param[1];return caml_call3(Printf[4],_b8_,f$1,cst_px);
         case 3:var f$2=param[1];return caml_call3(Printf[4],_b9_,f$2,cst_gd);
         case 4:
          var f$3=param[1];return caml_call3(Printf[4],_b__,f$3,cst_rem);
         case 5:var f$4=param[1];return caml_call3(Printf[4],_b$_,f$4,cst_vw);
         case 6:var f$5=param[1];return caml_call3(Printf[4],_ca_,f$5,cst_vh);
         case 7:var f$6=param[1];return caml_call3(Printf[4],_cb_,f$6,cst_vm);
         case 8:var f$7=param[1];return caml_call3(Printf[4],_cc_,f$7,cst_ch);
         case 9:var f$8=param[1];return caml_call3(Printf[4],_cd_,f$8,cst_mm);
         case 10:
          var f$9=param[1];return caml_call3(Printf[4],_ce_,f$9,cst_cm);
         case 11:
          var f$10=param[1];return caml_call3(Printf[4],_cf_,f$10,cst_in);
         case 12:
          var f$11=param[1];return caml_call3(Printf[4],_cg_,f$11,cst_pt);
         default:
          var f$12=param[1];return caml_call3(Printf[4],_ch_,f$12,cst_pc)}}
    function js$0(t){return string_of_t$0(t).toString()}
    function ml$0(t)
     {var s=caml_js_to_string(t);
      if(caml_call2(String$0[35],s,cst_0$0))return 0;
      function fail(param)
       {throw [0,
               Invalid_argument,
               caml_call2(Pervasives[16],s,cst_is_not_a_valid_length)]}
      var re=regexp(cst_d_d_s_S),match=string_match(re,s,0);
      if(match)
       {var r=match[1],match$0=matched_group(r,1);
        if(match$0)
         {var f=match$0[1];
          try
           {var _cu_=caml_float_of_string(f)}
          catch(exn)
           {exn = caml_wrap_exception(exn);
            if(exn[1] === Invalid_argument)
             {var s$0=exn[2];
              throw [0,
                     Invalid_argument,
                     caml_call2(Pervasives[16],cst_length_conversion_error,s$0)]}
            throw exn}
          var f$0=_cu_}
        else
         var f$0=fail(0);
        var match$1=matched_group(r,2);
        if(match$1)
         {var _cv_=match$1[1],switch$0=caml_string_compare(_cv_,cst_pc$0);
          if(0 <= switch$0)
           {if(! (0 < switch$0))return [13,f$0];
            if(! caml_string_notequal(_cv_,cst_pt$0))return [12,f$0];
            if(! caml_string_notequal(_cv_,cst_px$0))return [2,f$0];
            if(! caml_string_notequal(_cv_,cst_rem$0))return [4,f$0];
            if(! caml_string_notequal(_cv_,cst_vh$0))return [6,f$0];
            if(! caml_string_notequal(_cv_,cst_vm$0))return [7,f$0];
            if(! caml_string_notequal(_cv_,cst_vw$0))return [5,f$0]}
          else
           {if(! caml_string_notequal(_cv_,cst_ch$0))return [8,f$0];
            if(! caml_string_notequal(_cv_,cst_cm$0))return [10,f$0];
            if(! caml_string_notequal(_cv_,cst_em$1))return [0,f$0];
            if(! caml_string_notequal(_cv_,cst_ex$0))return [1,f$0];
            if(! caml_string_notequal(_cv_,cst_gd$0))return [3,f$0];
            if(! caml_string_notequal(_cv_,cst_in$0))return [11,f$0];
            if(! caml_string_notequal(_cv_,cst_mm$0))return [9,f$0]}
          return fail(0)}
        return fail(0)}
      return fail(0)}
    var Length=[0,string_of_t$0,js$0,ml$0];
    function string_of_t$1(param)
     {switch(param[0])
       {case 0:var f=param[1];return caml_call3(Printf[4],_ci_,f,cst_deg);
        case 1:
         var f$0=param[1];return caml_call3(Printf[4],_cj_,f$0,cst_grad);
        case 2:var f$1=param[1];return caml_call3(Printf[4],_ck_,f$1,cst_rad);
        default:
         var f$2=param[1];return caml_call3(Printf[4],_cl_,f$2,cst_turns)}}
    function js$1(t){return string_of_t$1(t).toString()}
    function ml$1(j)
     {var s=caml_js_to_string(j),re=regexp(cst_d_d_deg_grad_rad_turns);
      function fail(param)
       {throw [0,
               Invalid_argument,
               caml_call2(Pervasives[16],s,cst_is_not_a_valid_length$0)]}
      var match=string_match(re,s,0);
      if(match)
       {var r=match[1],match$0=matched_group(r,1);
        if(match$0)
         {var f=match$0[1];
          try
           {var _cs_=caml_float_of_string(f)}
          catch(exn)
           {exn = caml_wrap_exception(exn);
            if(exn[1] === Invalid_argument)
             {var s$0=exn[2];
              throw [0,
                     Invalid_argument,
                     caml_call2(Pervasives[16],cst_length_conversion_error$0,s$0)]}
            throw exn}
          var f$0=_cs_}
        else
         var f$0=fail(0);
        var match$1=matched_group(r,2);
        if(match$1)
         {var _ct_=match$1[1];
          if(! caml_string_notequal(_ct_,cst_deg$0))return [0,f$0];
          if(! caml_string_notequal(_ct_,cst_grad$0))return [1,f$0];
          if(! caml_string_notequal(_ct_,cst_rad$0))return [2,f$0];
          if(! caml_string_notequal(_ct_,cst_turns$0))return [3,f$0]}
        return fail(0)}
      return fail(0)}
    var
     Angle=[0,string_of_t$1,js$1,ml$1],
     Js_of_ocaml_CSS=
      [0,
       [0,
        string_of_name,
        rgb_of_name,
        hex_of_rgb,
        rgb,
        hsl,
        string_of_t,
        js,
        ml,
        js_t_of_js_string],
       Length,
       Angle];
    caml_register_global(1661,Js_of_ocaml_CSS,"Js_of_ocaml__CSS");
    function listen(opt,target,typ,cb)
     {if(opt)var sth=opt[1],capture=sth;else var capture=0;
      var _cr_=! ! capture;
      return addEventListener
              (target,
               typ,
               full_handler(function(n,e){return ! ! caml_call2(cb,n,e)}),
               _cr_)}
    var Js_of_ocaml_Dom_events=[0,Event$0,listen,removeEventListener];
    caml_register_global
     (1662,Js_of_ocaml_Dom_events,"Js_of_ocaml__Dom_events");
    var
     xmlns="http://www.w3.org/2000/svg",
     SVGError=[248,cst_Js_of_ocaml_Dom_svg_SVGError,caml_fresh_oo_id(0)];
    function createElement$0(doc,name)
     {return doc.createElementNS(xmlns,name.toString())}
    function unsafeCreateElement$0(doc,name){return createElement$0(doc,name)}
    function createA$0(doc){return unsafeCreateElement$0(doc,cst_a$2)}
    function createAltGlyph(doc)
     {return unsafeCreateElement$0(doc,cst_altglyph)}
    function createAltGlyphDef(doc)
     {return unsafeCreateElement$0(doc,cst_altglyphdef)}
    function createAltGlyphItem(doc)
     {return unsafeCreateElement$0(doc,cst_altglyphitem)}
    function createAnimate(doc){return unsafeCreateElement$0(doc,cst_animate)}
    function createAnimateColor(doc)
     {return unsafeCreateElement$0(doc,cst_animatecolor)}
    function createAnimateMotion(doc)
     {return unsafeCreateElement$0(doc,cst_animatemotion)}
    function createAnimateTransform(doc)
     {return unsafeCreateElement$0(doc,cst_animatetransform)}
    function createCircle(doc){return unsafeCreateElement$0(doc,cst_circle)}
    function createClipPath(doc)
     {return unsafeCreateElement$0(doc,cst_clippath)}
    function createCursor(doc){return unsafeCreateElement$0(doc,cst_cursor)}
    function createDefs(doc){return unsafeCreateElement$0(doc,cst_defs)}
    function createDesc(doc){return unsafeCreateElement$0(doc,cst_desc)}
    function createEllipse(doc){return unsafeCreateElement$0(doc,cst_ellipse)}
    function createFilter(doc){return unsafeCreateElement$0(doc,cst_filter)}
    function createFont(doc){return unsafeCreateElement$0(doc,cst_font)}
    function createFontFace(doc)
     {return unsafeCreateElement$0(doc,cst_font_face)}
    function createFontFaceFormat(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_format)}
    function createFontFaceName(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_name)}
    function createFontFaceSrc(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_src)}
    function createFontFaceUri(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_uri)}
    function createForeignObject(doc)
     {return unsafeCreateElement$0(doc,cst_foreignObject)}
    function createG(doc){return unsafeCreateElement$0(doc,cst_g$0)}
    function createGlyph(doc){return unsafeCreateElement$0(doc,cst_glyph)}
    function createGlyphRef(doc)
     {return unsafeCreateElement$0(doc,cst_glyphref)}
    function createhkern(doc){return unsafeCreateElement$0(doc,cst_hkern)}
    function createImage(doc){return unsafeCreateElement$0(doc,cst_image)}
    function createLineElement(doc)
     {return unsafeCreateElement$0(doc,cst_line)}
    function createLinearElement(doc)
     {return unsafeCreateElement$0(doc,cst_lineargradient)}
    function createMask(doc){return unsafeCreateElement$0(doc,cst_mask)}
    function createMetaData(doc)
     {return unsafeCreateElement$0(doc,cst_metadata)}
    function createMissingGlyph(doc)
     {return unsafeCreateElement$0(doc,cst_missing_glyph)}
    function createMPath(doc){return unsafeCreateElement$0(doc,cst_mpath)}
    function createPath(doc){return unsafeCreateElement$0(doc,cst_path)}
    function createPattern(doc){return unsafeCreateElement$0(doc,cst_pattern)}
    function createPolygon(doc){return unsafeCreateElement$0(doc,cst_polygon)}
    function createPolyline(doc)
     {return unsafeCreateElement$0(doc,cst_polyline)}
    function createRadialgradient(doc)
     {return unsafeCreateElement$0(doc,cst_radialgradient)}
    function createRect(doc){return unsafeCreateElement$0(doc,cst_rect)}
    function createScript$0(doc)
     {return unsafeCreateElement$0(doc,cst_script$2)}
    function createSet(doc){return unsafeCreateElement$0(doc,cst_set)}
    function createStop(doc){return unsafeCreateElement$0(doc,cst_stop)}
    function createStyle$0(doc){return unsafeCreateElement$0(doc,cst_style$2)}
    function createSvg(doc){return unsafeCreateElement$0(doc,cst_svg)}
    function createSwitch(doc){return unsafeCreateElement$0(doc,cst_switch)}
    function createSymbol(doc){return unsafeCreateElement$0(doc,cst_symbol)}
    function createTextElement(doc)
     {return unsafeCreateElement$0(doc,cst_text$0)}
    function createTextpath(doc)
     {return unsafeCreateElement$0(doc,cst_textpath)}
    function createTitle$0(doc){return unsafeCreateElement$0(doc,cst_title$2)}
    function createTref(doc){return unsafeCreateElement$0(doc,cst_tref)}
    function createTspan(doc){return unsafeCreateElement$0(doc,cst_tspan)}
    function createUse(doc){return unsafeCreateElement$0(doc,cst_use)}
    function createView(doc){return unsafeCreateElement$0(doc,cst_view)}
    function createvkern(doc){return unsafeCreateElement$0(doc,cst_vkern)}
    var svg_element=Unsafe[1].SVGElement,document$1=Unsafe[1].document;
    function getElementById$0(id)
     {function _co_(e){if(e instanceof svg_element)return e;throw Not_found}
      function _cp_(param){throw Not_found}
      var _cq_=Unsafe[1].document.getElementById(id.toString());
      return caml_call3(Opt[7],_cq_,_cp_,_co_)}
    function element$2(e){return e instanceof svg_element?e:no_handler}
    function unsafeCoerce$0(e,tag)
     {var _cn_=tag.toString();
      return e.tagName.toLowerCase() === _cn_?e:no_handler}
    function a$0(e){return unsafeCoerce$0(e,cst_a$3)}
    function altGlyph(e){return unsafeCoerce$0(e,cst_altglyph$0)}
    function altGlyphDef(e){return unsafeCoerce$0(e,cst_altglyphdef$0)}
    function altGlyphItem(e){return unsafeCoerce$0(e,cst_altglyphitem$0)}
    function animate(e){return unsafeCoerce$0(e,cst_animate$0)}
    function animateColor(e){return unsafeCoerce$0(e,cst_animatecolor$0)}
    function animateMotion(e){return unsafeCoerce$0(e,cst_animatemotion$0)}
    function animateTransform(e)
     {return unsafeCoerce$0(e,cst_animatetransform$0)}
    function circle(e){return unsafeCoerce$0(e,cst_circle$0)}
    function clipPath(e){return unsafeCoerce$0(e,cst_clippath$0)}
    function cursor(e){return unsafeCoerce$0(e,cst_cursor$0)}
    function defs(e){return unsafeCoerce$0(e,cst_defs$0)}
    function desc(e){return unsafeCoerce$0(e,cst_desc$0)}
    function ellipse(e){return unsafeCoerce$0(e,cst_ellipse$0)}
    function filter(e){return unsafeCoerce$0(e,cst_filter$0)}
    function font(e){return unsafeCoerce$0(e,cst_font$0)}
    function fontFace(e){return unsafeCoerce$0(e,cst_font_face$0)}
    function fontFaceFormat(e)
     {return unsafeCoerce$0(e,cst_font_face_format$0)}
    function fontFaceName(e){return unsafeCoerce$0(e,cst_font_face_name$0)}
    function fontFaceSrc(e){return unsafeCoerce$0(e,cst_font_face_src$0)}
    function fontFaceUri(e){return unsafeCoerce$0(e,cst_font_face_uri$0)}
    function foreignObject(e){return unsafeCoerce$0(e,cst_foreignobject)}
    function g(e){return unsafeCoerce$0(e,cst_g$1)}
    function glyph(e){return unsafeCoerce$0(e,cst_glyph$0)}
    function glyphRef(e){return unsafeCoerce$0(e,cst_glyphref$0)}
    function hkern(e){return unsafeCoerce$0(e,cst_hkern$0)}
    function image(e){return unsafeCoerce$0(e,cst_image$0)}
    function lineElement(e){return unsafeCoerce$0(e,cst_line$0)}
    function linearElement(e){return unsafeCoerce$0(e,cst_lineargradient$0)}
    function mask(e){return unsafeCoerce$0(e,cst_mask$0)}
    function metaData(e){return unsafeCoerce$0(e,cst_metadata$0)}
    function missingGlyph(e){return unsafeCoerce$0(e,cst_missing_glyph$0)}
    function mPath(e){return unsafeCoerce$0(e,cst_mpath$0)}
    function path$0(e){return unsafeCoerce$0(e,cst_path$0)}
    function pattern(e){return unsafeCoerce$0(e,cst_pattern$0)}
    function polygon(e){return unsafeCoerce$0(e,cst_polygon$0)}
    function polyline(e){return unsafeCoerce$0(e,cst_polyline$0)}
    function radialgradient(e){return unsafeCoerce$0(e,cst_radialgradient$0)}
    function rect(e){return unsafeCoerce$0(e,cst_rect$0)}
    function script$0(e){return unsafeCoerce$0(e,cst_script$3)}
    function set$1(e){return unsafeCoerce$0(e,cst_set$0)}
    function stop(e){return unsafeCoerce$0(e,cst_stop$0)}
    function style$0(e){return unsafeCoerce$0(e,cst_style$3)}
    function svg(e){return unsafeCoerce$0(e,cst_svg$0)}
    function switch$0(e){return unsafeCoerce$0(e,cst_switch$0)}
    function symbol$12(e){return unsafeCoerce$0(e,cst_symbol$0)}
    function textElement(e){return unsafeCoerce$0(e,cst_text$1)}
    function textpath(e){return unsafeCoerce$0(e,cst_textpath$0)}
    function title$0(e){return unsafeCoerce$0(e,cst_title$3)}
    function tref(e){return unsafeCoerce$0(e,cst_tref$0)}
    function tspan(e){return unsafeCoerce$0(e,cst_tspan$0)}
    function use(e){return unsafeCoerce$0(e,cst_use$0)}
    function view(e){return unsafeCoerce$0(e,cst_view$0)}
    function vkern(e){return unsafeCoerce$0(e,cst_vkern$0)}
    var
     Js_of_ocaml_Dom_svg=
      [0,
       xmlns,
       SVGError,
       createElement$0,
       createA$0,
       createAltGlyph,
       createAltGlyphDef,
       createAltGlyphItem,
       createAnimate,
       createAnimateColor,
       createAnimateMotion,
       createAnimateTransform,
       createCircle,
       createClipPath,
       createCursor,
       createDefs,
       createDesc,
       createEllipse,
       createFilter,
       createFont,
       createFontFace,
       createFontFaceFormat,
       createFontFaceName,
       createFontFaceSrc,
       createFontFaceUri,
       createForeignObject,
       createG,
       createGlyph,
       createGlyphRef,
       createhkern,
       createImage,
       createLineElement,
       createLinearElement,
       createMask,
       createMetaData,
       createMissingGlyph,
       createMPath,
       createPath,
       createPattern,
       createPolygon,
       createPolyline,
       createRadialgradient,
       createRect,
       createScript$0,
       createSet,
       createStop,
       createStyle$0,
       createSvg,
       createSwitch,
       createSymbol,
       createTextElement,
       createTextpath,
       createTitle$0,
       createTref,
       createTspan,
       createUse,
       createView,
       createvkern,
       svg_element,
       document$1,
       getElementById$0,
       [0,
        element$2,
        a$0,
        altGlyph,
        altGlyphDef,
        altGlyphItem,
        animate,
        animateColor,
        animateMotion,
        animateTransform,
        circle,
        clipPath,
        cursor,
        defs,
        desc,
        ellipse,
        filter,
        font,
        fontFace,
        fontFaceFormat,
        fontFaceName,
        fontFaceSrc,
        fontFaceUri,
        foreignObject,
        g,
        glyph,
        glyphRef,
        hkern,
        image,
        lineElement,
        linearElement,
        mask,
        metaData,
        missingGlyph,
        mPath,
        path$0,
        pattern,
        polygon,
        polyline,
        radialgradient,
        rect,
        script$0,
        set$1,
        stop,
        style$0,
        svg,
        switch$0,
        symbol$12,
        textElement,
        textpath,
        title$0,
        tref,
        tspan,
        use,
        view,
        vkern]];
    caml_register_global(1663,Js_of_ocaml_Dom_svg,"Js_of_ocaml__Dom_svg");
    function withCredentials(b)
     {var init={};init.withCredentials = ! ! b;return init}
    var
     eventSource=Unsafe[1].EventSource,
     eventSource_options=Unsafe[1].EventSource,
     Js_of_ocaml_EventSource=
      [0,withCredentials,eventSource,eventSource_options,addEventListener];
    caml_register_global
     (1664,Js_of_ocaml_EventSource,"Js_of_ocaml__EventSource");
    var
     console=runtime.caml_js_get_console(0),
     Js_of_ocaml_Firebug=[0,console];
    caml_register_global(1665,Js_of_ocaml_Firebug,"Js_of_ocaml__Firebug");
    function empty_position_options(param){return {}}
    var
     x=Unsafe[1].navigator,
     geolocation=caml_call1(Optdef[5],x)?x.geolocation:x;
    function is_supported$2(param){return caml_call1(Optdef[5],geolocation)}
    var
     Js_of_ocaml_Geolocation=
      [0,empty_position_options,geolocation,is_supported$2];
    caml_register_global
     (1666,Js_of_ocaml_Geolocation,"Js_of_ocaml__Geolocation");
    function object_options(param){return {"localeMatcher":"best fit"}}
    function options(param)
     {return {"localeMatcher":"best fit",
              "usage":"sort",
              "sensitivity":"variant",
              "ignorePunctuation":false$0,
              "numeric":false$0,
              "caseFirst":"false"}}
    var Collator=[0,object_options,options];
    function options$0(param)
     {return {"localeMatcher":"best fit",
              "timeZone":t37,
              "hour12":t37,
              "hourCycle":t37,
              "formatMatcher":"best fit",
              "weekday":t37,
              "era":t37,
              "year":t37,
              "month":t37,
              "day":t37,
              "hour":t37,
              "minute":t37,
              "second":t37,
              "timeZoneName":t37}}
    var DateTimeFormat=[0,object_options,options$0];
    function options$1(param)
     {return {"localeMatcher":"best fit",
              "style":"decimal",
              "currency":t37,
              "currencyDisplay":t37,
              "useGrouping":true$0,
              "minimumIntegerDigits":t37,
              "minimumFractionDigits":t37,
              "maximumFractionDigits":t37,
              "minimumSignificantDigits":t37,
              "maximumSignificantDigits":t37}}
    var NumberFormat=[0,object_options,options$1];
    function options$2(param)
     {return {"localeMatcher":"best fit","type":"cardinal"}}
    var
     PluralRules=[0,object_options,options$2],
     intl=Unsafe[1].Intl,
     collator_constr=Unsafe[1].Intl.Collator,
     dateTimeFormat_constr=Unsafe[1].Intl.DateTimeFormat,
     numberFormat_constr=Unsafe[1].Intl.NumberFormat,
     pluralRules_constr=Unsafe[1].Intl.PluralRules;
    function is_supported$3(param){return caml_call1(Optdef[5],intl)}
    var
     Js_of_ocaml_Intl=
      [0,
       Collator,
       DateTimeFormat,
       NumberFormat,
       PluralRules,
       intl,
       collator_constr,
       dateTimeFormat_constr,
       numberFormat_constr,
       pluralRules_constr,
       is_supported$3];
    caml_register_global(1667,Js_of_ocaml_Intl,"Js_of_ocaml__Intl");
    var Js_of_ocaml$0=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
    caml_register_global(1668,Js_of_ocaml$0,"Js_of_ocaml");
    return}
  (function(){return this}()));


//# 1 ".server.eobjs/byte/range.cmo.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_new_string=runtime.caml_new_string;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    var
     global_data=runtime.caml_get_global_data(),
     partial=[11,caml_new_string("))"),0],
     norange=[0,caml_new_string("__internal"),[0,0,0],[0,0,0]],
     Lexing=global_data.Lexing,
     Printf=global_data.Printf,
     Pervasives=global_data.Pervasives,
     _c_=
      [0,
       [11,
        caml_new_string('("'),
        [2,
         0,
         [11,
          caml_new_string('", ('),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(", "),
            [4,
             0,
             0,
             0,
             [11,
              caml_new_string("), ("),
              [4,0,0,0,[11,caml_new_string(", "),[4,0,0,0,partial]]]]]]]]]],
       caml_new_string('("%s", (%d, %d), (%d, %d))')],
     _b_=
      [0,
       [2,
        0,
        [11,
         caml_new_string(":["),
         [4,
          0,
          0,
          0,
          [12,46,[4,0,0,0,[12,45,[4,0,0,0,[12,46,[4,0,0,0,[12,93,0]]]]]]]]]],
       caml_new_string("%s:[%d.%d-%d.%d]")],
     _a_=
      [0,
       [11,
        caml_new_string("merge_range called on different files: "),
        [2,0,[11,caml_new_string(" and "),[2,0,0]]]],
       caml_new_string("merge_range called on different files: %s and %s")];
    function line_of_pos(param){var l=param[1];return l}
    function col_of_pos(param){var c=param[2];return c}
    function mk_pos(line,col){return [0,line,col]}
    function file_of_range(param){var f=param[1];return f}
    function start_of_range(param){var s=param[2];return s}
    function end_of_range(param){var e=param[3];return e}
    function mk_range(f,s,e){return [0,f,s,e]}
    function valid_pos(param)
     {var c=param[2],l=param[1],_k_=0 <= l?1:0,_l_=_k_?0 <= c?1:0:_k_;
      return _l_}
    function merge_range(r1,r2)
     {var e2=r2[3],s2=r2[2],f=r2[1],e1=r1[3],s1=r1[2],f$0=r1[1];
      if(runtime.caml_string_notequal(f$0,f))
       {var _i_=caml_call3(Printf[4],_a_,f$0,f);
        return caml_call1(Pervasives[2],_i_)}
      if(valid_pos(s1))
       {if(valid_pos(s2))
         {var _j_=caml_call2(Pervasives[5],e1,e2);
          return [0,f$0,caml_call2(Pervasives[4],s1,s2),_j_]}
        return r1}
      return r2}
    function string_of_range(param)
     {var
       _h_=param[3],
       ec=_h_[2],
       el=_h_[1],
       match=param[2],
       sc=match[2],
       sl=match[1],
       f=param[1];
      return caml_call6(Printf[4],_b_,f,sl,sc,el,ec)}
    function ml_string_of_range(param)
     {var
       _g_=param[3],
       ec=_g_[2],
       el=_g_[1],
       match=param[2],
       sc=match[2],
       sl=match[1],
       f=param[1];
      return caml_call6(Printf[4],_c_,f,sl,sc,el,ec)}
    function pos_of_lexpos(p){return [0,p[2],p[4] - p[3] | 0]}
    function mk_lex_range(p1,p2)
     {var _e_=pos_of_lexpos(p2),_f_=pos_of_lexpos(p1);
      return [0,p1[1],_f_,_e_]}
    function lex_range(lexbuf)
     {var _d_=caml_call1(Lexing[10],lexbuf);
      return mk_lex_range(caml_call1(Lexing[9],lexbuf),_d_)}
    var
     Range=
      [0,
       line_of_pos,
       col_of_pos,
       mk_pos,
       file_of_range,
       start_of_range,
       end_of_range,
       mk_range,
       merge_range,
       string_of_range,
       ml_string_of_range,
       norange,
       pos_of_lexpos,
       mk_lex_range,
       lex_range];
    runtime.caml_register_global(7,Range,"Range");
    return}
  (function(){return this}()));


//# 1 ".server.eobjs/byte/ast.cmo.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     global_data=runtime.caml_get_global_data(),
     Range=global_data.Range;
    function no_loc(x){return [0,x,Range[11]]}
    var Ast=[0,no_loc];
    runtime.caml_register_global(1,Ast,"Ast");
    return}
  (function(){return this}()));


//# 1 ".server.eobjs/byte/parser.cmo.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_new_string=runtime.caml_new_string;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_Parser_MenhirBasics_Error=
      caml_new_string("Parser.MenhirBasics.Error"),
     default_reduction=
      [0,
       8,
       caml_new_string
        ("\0\0\x0f\x11X\0Y\x0e\0Z\0\0\0\0\0\r\f\x12\0\0\0\0\0\x10\0\0=\0\x14\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0F\0\0*\0\x15\0\x16\0\x01\0-\0\0\0\0\0\0[\0\0JA\x04\0\0\0\0\0\0\0S\0\0\0\0\0Q\0R\0\0\0\0\0\0\x0b\n5\0\0\0\0\0\0\0\0M\0\0TV\0\0\0NP\0\0\0\0O\0\0\0\0\0\0LC]\0;\0\x05\x07\0\0\0\x0002/\0\0\0\0\0.3\0\0\x001?\x004\0\0H\0\x06\0\0\0\0\0\b\x02\0D\x009\0\x03\0W")],
     error=
      [0,
       47,
       caml_new_string
        ('\x0f\xc0\x02"\x82\x14\0\0\b \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\xf8\0DPB\x80\0\0\0\0\0\0\0\0\0\0\0\n\x80\0\0\0\0\0\0\0\0\0\0\0\0\0@\0\0~\x02\x11\x14\x10\xa0\0\0\x01\x80\0\x01\xf8\x04DPB\x83\xf0\0\x88\xa0\x85\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0?\0\b\x8a\bP~\0\x11\x14\x10\xa0\0\0\x01\0\0\0\0\b\0\0\0\0\0\x01\x04\0\0\0\0\0\0\0\0\0?y\xf4qZ\x1f\x82\x04E\x04(\0\0\0\0\0\0\0\b\0\0\0\0\0\0\0\0\0\0\x07g>\x8e#C\xf0\0\x88\xa0\x85\0\x1f\xbc\xfa8\xad\x0f\xc0\x02"\x82\x14\0t\xb3\xe8\xe2$?\0\b\x8a\bP\x01\xfb\xcf\xa3\x8a\xd0\xfc\0"(!@\x07\xef>\x8e+C\xf0\0\x88\xa0\x85\0\x1f\xbc\xfa8\xad\x0f\xc0\x02"\x82\x14\0~\xf3\xe8\xe2\xb4?\0\b\x8a\bP\x01\xfb\xcf\xa3\x8a\xd0\0\0\0\0\0\x01\xf8\0DPB\x80\x0f\xde}\x1cV\x87\xe0\x01\x11A\n\0?y\xf4qZ\x1f\x80\x04E\x04(\0\xfd\xe7\xd1\xc5h~\0\x11\x14\x10\xa0\x03\xf7\x9fG\x15\xa1\xf8\0DPB\x80\x0f\xde}\x1cV\x87\xe0\x01\x11A\n\0?y\xf4qZ\x1f\x80\x04E\x04(\0\xfd\xe7\xd1\xc5h~\0\x11\x14\x10\xa0\x03\xf7\x9fG\x15\xa1\xf8\0DPB\x80\x0f\xde}\x1cV\x87\xe0\x01\x11A\n\0?y\xf4qZ\x1f\x80\x04E\x04(\0\0\0\0\0\0\x01\xfb\xcf\xa3\x8a\xd0\x03\xb1\x9fG\x11 \0\0\0\0\0\0\0\b\0\0\0\0\0\0\0\0\0\0:Y\xf4q\x12\0\0\0\0\0\0\0\xfd\xe7\xd1\xc5h\0\0\0\0\0\0\x03\xa1\x9fG\x15 \0\0\0\0\0\x06\xa0\0\0\x02\x10\0\0\0\0@\0\0\0\0 \0\0\x15\x02\0\0\0\0\0\0\0B\0\0\0\x02\0\0\0\0\0\0\0\0\0\0\0 \0\0\x01\x02\xa0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\0\0\0\0\0\0@\0\x06\xfc\n"8a@\0\0\x04\0\0\x03\xf0\0\x88\xa0\x85\0\x1d\x8c\xfa8\x89\0\0\0\b\0\0\0\0\0\0\0\0\0\0\0\x02\0\0\0\0\0\0\x04\0\xfc\0"(!@\x07\xc3>\x8e#C\xf1\0\x88\xa0\x85\0\0\0\0\0\0\0>\x19\xf4q\x12\0\0\0\0\0\0\0\0\0\x80\0\0~\0\x11\x14\x10\xa0\x03\xb1\x9fG\x11 \0\0\x01\0\0\x1b\xf0h\x88\xe1\x9d\0\0\0\x04\x80\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\xd0\xcf\xa3\x8c\x90\0\0\x02\0\0\x04\0\x80\0\0\0\0\x01\0\0\0\0\x07\xe2\x01\x11A\n\0\x04\0\0\0\0\xdf\x83\x04G\f(\0\x10\0\0\0\0\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x80\x1f\x80\x04E\x04(\0\xf8g\xd1\xc4H\0\0\0\0\0\0\0\0\0\0\0\0\x07C>\x8e"C\xf0@\x88\xa0\x85\0\0\x80\0\0\0\0>\x19\xf4q\x12\0\0\0\0\0\0?\0\b\x8a\bP\x01\xd2\xcf\xa3\x88\x90\x03\xa1\x9fG\x19 \x07\xc3>\x8e"@\x01\0\0\0\x02\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03~\x05\x11\x1c0\xa0\0\0\0\0\0\0\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x80\0\0\0\0\0\x01\0;\0\b\b\b\0\0\0 \x80\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05@\0\0\0\0\0\0\0\x10\0\0\0\0\x80\0\0\0\0\0\0`\0\0v\x01\x10\x10\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\0\0\0 \0\0\0\0\0\x04\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\x04\0\0\x01\x03\xb0\0\x80\x80\x80\0\0\0\0\0\0\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0B\0\0\0\0\x01\0\0\0\xa8\x10\0\0\0\0\0 \0\0\0\0\0\0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x80\0\0\0\0\0\0\xd4\0\0\0B\0\0\0\0\0\0\r\xf8\x10Dp\xc2\x80\0\0\0\0\0\0\0\0\0\0 \0\0\0\0\0\0')],
     action=
      [0,
       [0,
        16,
        caml_new_string
         ("\b\x8c\0\x1f\0\0\0\0\0\0\b\x8c\0\0\0\0\0\x1c\0\0\0!\b\x8c\0\x03\b\x8c\b\x8c\0\0\0\0\0\0\b\x8c\b\x8c\0*\0d\0,\0\0\0\x15\b\x8c\0\0\0r\0\0\x05\xc4\b\x8c\x006\b\x8c\x05\xc4\b\x8c\0\x80\b\x8c\0\xca\b\x8c\x01\x14\b\x8c\x01^\b\x8c\x01\xa8\0\0\b\x8c\x01\xf2\b\x8c\x02<\b\x8c\x02\x86\b\x8c\x02\xd0\b\x8c\x03\x1a\b\x8c\x03d\b\x8c\x03\xae\b\x8c\x03\xf8\b\x8c\x04B\b\x8c\x04\x8c\b\x8c\0\0\x04\xd6\x06\x0e\0\0\0\x94\0\0\x06\x0e\0\0\x05 \0\0\x05\xc4\0\0\x05d\0\x80\0\x94\x05d\0\x06\0\xaa\0\0\0\x1a\0\x1c\0\0\0\0\0\0\0\xb2\x006\x06j\0\xa6\b\x8c\x06\xb2\x006\0\0\0\xaa\0\xa4\b\x8c\x06\x0e\b\x8c\0\0\x05\xc4\0\0\0\xc2\b\x8c\x06\xee\x006\x05|\x006\0\0\0\0\0\0\x07*\0\xce\0&\0\xec\b\xe0\0\xee\x06j\0\xf0\0\0\0\xf4\x006\0\0\0\0\0\xc4\b\x8c\x06\xb2\0\0\0\0\b6\b\x8c\0\xf8\x07t\0\0\b\x8c\x06\xb2\x07\xb0\x07\xfa\0d\0&\0\0\0\0\0\0\x06j\0\0\0\xf6\0\0\0\0\0\xde\0\xd4\bv\0L\0\0\0\0\0\0\0\x1c\0\xfe\x01\x1c\0t\b\xec\0\0\0\0\x01\n\x01*\0\x94\0\0\0\0\x01,\0\0\0|\bv\0\0\x018\0\0\0J\x01 \x05d\x01>\x006\0\0\0\0\x01\f\0\0\x05d\0\0\x06j\0\0\x01\x0e\0\0")],
       [0,
        16,
        caml_new_string
         ('\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\n\0\x9d\0\x9d\0\x9d\0\x9d\0.\x01e\0\x9d\0\x9d\0\x9d\0f\0\x82\0&\0\x9d\0\x12\x01\x8a\0\x1a\0\x9d\0\x9d\0\x9d\x01i\x006\x01!\0\x9d\x01N\0\x9d\x01\x05\0\x9d\0\x9d\x01V\0\x9d\0a\0a\0a\0a\0a\0a\0^\0a\0a\0a\0a\0V\x01i\0a\0a\0a\0f\0\x82\x01r\0a\x01Z\x01\xaa\x02r\0a\0a\0a\x01)\x01N\x01e\0a\0Z\0a\x02\xce\0a\0a\0r\0a\0z\0\x91\0\x91\0\x91\0\x91\0\x91\x01\x19\0\x91\0\x91\0\x92\0\x91\x01i\x02\x8e\0\x91\0\x91\0\x91\0f\0\x82\x01\x1e\0\x91\x02>\x02\xa6\x01B\0\x91\0\x91\0\x91\x01F\x01i\x01R\0\x91\x01n\0\x91\x02\xba\0\x9a\0\x91\x01z\0\x91\0z\0Y\0Y\0Y\0Y\0Y\x01\x8e\0Y\0Y\0Y\0Y\x01\x92\x01\xae\0Y\0Y\0Y\0f\0\x82\x01\xd6\0Y\x01\xde\x01\xe6\x01\xee\0Y\0Y\0Y\x01\xf6\x02\x06\x02"\0Y\x02Z\0Y\x02f\0Y\0Y\x02j\0Y\0z\0]\0]\0]\0]\0]\x02\x86\0]\0]\0]\0]\x02\x8a\x02\x9e\0]\0]\0]\0f\0\x82\x02\xa2\0]\x02\xb2\x02\xc6\x02\xd2\0]\0]\0]\x02\xda\x02\xeb\x03\x03\0]\0\0\0]\0\0\0]\0]\0\0\0]\0z\0\x8d\0\x8d\0\x8d\0\x8d\0\x8d\0\0\0\x8d\0\x8d\0\x92\0\x8d\0\0\0\0\0\x8d\0\x8d\0\x8d\0f\0\x82\0\0\0\x8d\0\0\0\0\0\0\0\x8d\0\x8d\0\x8d\0\0\0\0\0\0\0\x8d\0\0\0\x8d\0\0\0\x9a\0\x8d\0\0\0\x8d\0z\0\x95\0\x95\0\x95\0\x95\0\x95\0\0\0\x95\0\x95\0\x92\0\x95\0\0\0\0\0\x95\0\x95\0\x95\0f\0\x82\0\0\0\x95\0\0\0\0\0\0\0\x95\0\x95\0\x95\0\0\0\0\0\0\0\x95\0\0\0\x95\0\0\0\x9a\0\x95\0\0\0\x95\0z\0\x8a\0\xa2\0\x81\0\xaa\0\x81\0\0\0\x81\0\x81\0\x92\0\x81\0\0\0\0\0\xbe\0\xc6\0\xce\0f\0\x82\0\0\0\x81\0\0\0\0\0\0\0\x81\0\xd6\0\xde\0\0\0\0\0\0\0\xe6\0\0\0\x81\0\0\0\x9a\0\x81\0\0\0\xee\0z\0\x8a\0\xa2\0i\0\xaa\0i\0\0\0i\0i\0\x92\0i\0\0\0\0\0i\0\xc6\0\xce\0f\0\x82\0\0\0i\0\0\0\0\0\0\0i\0\xd6\0\xde\0\0\0\0\0\0\0i\0\0\0i\0\0\0\x9a\0i\0\0\0i\0z\0\x8a\0\xa2\0q\0\xaa\0q\0\0\0q\0q\0\x92\0q\0\0\0\0\0q\0q\0q\0f\0\x82\0\0\0q\0\0\0\0\0\0\0q\0q\0q\0\0\0\0\0\0\0q\0\0\0q\0\0\0\x9a\0q\0\0\0q\0z\0\x8a\0\xa2\0m\0\xaa\0m\0\0\0m\0m\0\x92\0m\0\0\0\0\0m\0m\0m\0f\0\x82\0\0\0m\0\0\0\0\0\0\0m\0m\0m\0\0\0\0\0\0\0m\0\0\0m\0\0\0\x9a\0m\0\0\0m\0z\0\x8a\0\xa2\0y\0\xaa\0y\0\0\0y\0y\0\x92\0y\0\0\0\0\0y\0y\0y\0f\0\x82\0\0\0y\0\0\0\0\0\0\0y\0y\0y\0\0\0\0\0\0\0y\0\0\0y\0\0\0\x9a\0y\0\0\0y\0z\0\x8a\0\xa2\0u\0\xaa\0u\0\0\0u\0u\0\x92\0u\0\0\0\0\0u\0u\0u\0f\0\x82\0\0\0u\0\0\0\0\0\0\0u\0u\0u\0\0\0\0\0\0\0u\0\0\0u\0\0\0\x9a\0u\0\0\0u\0z\0\x8a\0\xa2\0e\0\xaa\0e\0\0\0e\0e\0\x92\0e\0\0\0\0\0e\0\xc6\0\xce\0f\0\x82\0\0\0e\0\0\0\0\0\0\0e\0\xd6\0\xde\0\0\0\0\0\0\0e\0\0\0e\0\0\0\x9a\0e\0\0\0e\0z\0\x8a\0\xa2\0}\0\xaa\0}\0\0\0}\0}\0\x92\0}\0\0\0\0\0\xbe\0\xc6\0\xce\0f\0\x82\0\0\0}\0\0\0\0\0\0\0}\0\xd6\0\xde\0\0\0\0\0\0\0\xe6\0\0\0}\0\0\0\x9a\0}\0\0\0}\0z\0\x8a\0\xa2\0\x89\0\xaa\0\x89\0\0\0\x89\0\x89\0\x92\0\xb6\0\0\0\0\0\xbe\0\xc6\0\xce\0f\0\x82\0\0\0\x89\0\0\0\0\0\0\0\xfe\0\xd6\0\xde\0\0\0\0\0\0\0\xe6\0\0\0\x89\0\0\0\x9a\0\x89\0\0\0\xee\0z\0\x8a\0\xa2\0\x85\0\xaa\0\x85\0\0\0\x85\0\x85\0\x92\0\xb6\0\0\0\0\0\xbe\0\xc6\0\xce\0f\0\x82\0\0\0\x85\0\0\0\0\0\0\0\x85\0\xd6\0\xde\0\0\0\0\0\0\0\xe6\0\0\0\x85\0\0\0\x9a\0\x85\0\0\0\xee\0z\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\x99\0\x99\0\x99\0f\0\x82\0\0\0\x99\0\0\0\0\0\0\0\x99\0\x99\0\x99\0\0\0\0\0\0\0\x99\0\0\0\x99\0\0\0\x99\0\x99\0\0\0\x99\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\0\0\xa1\0\xa1\0\xa1\0\xa1\0\0\0\0\0\xa1\0\xa1\0\xa1\0f\0\x82\0\0\0\xa1\0\0\0\0\0\0\0\xa1\0\xa1\0\xa1\0\0\x01>\0&\0\xa1\0\x12\0\xa1\0\x1a\0\xa1\0\xa1\0\0\0\xa1\0!\0!\0\xfd\0!\0!\0!\0!\0!\0!\0\0\0\0\0\0\0\0\0\0\0!\0!\0\0\0!\0\0\0\0\0\0\0!\0\0\x02b\0\0\0!\0\0\0\0\0\xdd\0!\0!\0!\0\0\0\0\0\0\0\0\0!\0!\0\0\0\0\0!\x01\xbe\0!\0\0\0!\0z\0\x8a\0\xa2\x01\xa6\0\xaa\x01\x11\0\0\0\xb2\x01\x11\0\x92\0\xb6\0\0\0\0\0\xbe\0\xc6\0\xce\0f\0\x82\0\0\0\xf6\0\0\0\0\0\0\0\xfe\0\xd6\0\xde\0\0\0\0\0\0\0\xe6\0\0\x017\0\0\0\x9a\x01\x06\0\0\0\xee\0z\0\x8a\0\xa2\x01m\0\xaa\x01\x16\0\0\x01&\0\0\0\x92\0\xb6\0\0\0\0\0\xbe\0\xc6\0\xce\0f\0\x82\0\0\0\xf6\0\0\0\0\0\0\0\xfe\0\xd6\0\xde\0\0\0\0\0\0\0\xe6\0\0\0\0\0\0\0\x9a\x01m\0\0\0\xee\x01v\x01\x8a\0\0\0\x06\0\x0e\0\x12\0\x16\0\x1a\0\x1e\0\0\0\0\0\0\0\0\0\0\x01Q\x01\x9a\0\0\0\xe5\0\0\0\0\0\0\0"\0\0\0\0\0\0\0:\0\0\0\0\0\0\0>\x01\xaa\x01\xce\0\0\0\0\0\0\0\0\x01\xd2\0F\0\0\0\0\0\0\0\0\0J\0\0\0N\0z\0\x8a\0\xa2\x02\x0e\0\xaa\x01\x82\0\0\x022\0\0\0\x92\0\xb6\0\0\0\0\0\xbe\0\xc6\0\xce\0f\0\x82\0\0\0\xf6\0\0\0\0\0\0\0\xfe\0\xd6\0\xde\0\0\0\0\0\0\0\xe6\0z\0\x8a\0\xa2\0\x9a\0\xaa\x01\xb6\0\xee\0\0\0\0\0\x92\0\xb6\0\0\0\0\0\xbe\0\xc6\0\xce\0f\0\x82\0\0\0\xf6\0\0\0\0\0\0\0\xfe\0\xd6\0\xde\0\0\0\0\0\0\0\xe6\0-\0-\0-\0\x9a\0-\0\0\0\xee\0\0\0\0\0-\0-\0\0\0\0\0-\0-\0-\0-\0-\0\0\0-\0\0\0\0\0\0\0-\0-\0-\0\0\0\0\0\0\0-\0\xd5\0\0\0\0\0-\0\0\0\0\0-\0M\0M\0M\x02&\0M\0\0\0\0\0\0\0\0\0M\0M\0\0\0\0\0M\0M\0M\0M\0M\0\0\0M\0\0\0\0\0\0\0M\0M\0M\0\0\0\0\0\0\0M\0I\0I\0I\0M\0I\0\0\0M\0\0\0\0\0I\0I\0\0\0\0\0I\0I\0I\0I\0I\0\0\0I\0\0\0\0\0\0\0I\0I\0I\0\0\0\0\0\0\0I\0\xd9\0\0\0\0\0I\0\0\0\0\0I\0z\0\x8a\0\xa2\0\xad\0\xaa\0\0\0\0\0\0\0\0\0\x92\0\xb6\0\0\0\0\0\xbe\0\xc6\0\xce\0f\0\x82\0\0\0\xf6\0\0\0\0\0\0\0\xfe\0\xd6\0\xde\0\0\0\0\0\0\0\xe6\0z\0\x8a\0\xa2\0\x9a\0\xaa\0\0\0\xee\0\0\0\0\0\x92\0\xb6\0\0\0\0\0\xbe\0\xc6\0\xce\x02\x1a\x02*\0\0\0\xf6\0\0\0\0\0\0\0\xfe\0\xd6\0\xde\x02n\x02v\0\x12\0\xe6\0\x1a\x02z\0\0\0\x9a\0\0\0\0\0\xee\0\x06\0\x0e\0\x12\0\x16\0\x1a\0\x1e\0\0\x02~\0\0\x01\x9e\0\0\0\xed\0\0\x002\0\xed\x02\x92\0\0\0\0\0"\0\0\0\0\0\0\0:\x02\x96\0\0\0\0\0>\0\0\0B\0\0\0\0\0\0\0\0\0\0\0F\0\0\0\0\0\0\0\0\0J\0\0\0N\0\x06\0\x0e\0\x12\0\x16\0\x1a\0\x1e\x02n\x02v\0\x12\0\xa9\0\x1a\x02z\0\0\0\0\0\0\0\0\0\0\0\0\0"\0\0\0\xf5\0\0\0:\0\0\x02~\0\0\0>\0\0\0B\0\0\0\0\0\0\x02\x92\0\0\0F\0\0\0\0\0\0\0\0\0J\x02\x96\0N')]],
     lhs=
      [0,
       8,
       caml_new_string
        ("\x02\x01\0\x1d\x1c\x1b\x1b\x1b\x1a\x1a\x1a\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x18\x18\x17\x16\x16\x16\x16\x16\x16\x16\x15\x14\x14\x13\x13\x12\x12\x11\x11\x10\x10\x0f\x0f\x0e\x0e\r\f\f\x0b\x0b\n\n\t\t\b\b\b\b\b\b\b\b\x07\x07\x06\x05\x05\x05\x05\x04\x03")],
     goto$0=
      [0,
       [0,
        16,
        caml_new_string
         ("\0j\0\0\0\0\0\0\0\0\0\f\0\0\0\0\0\x04\0\0\0\0\0R\0\0\x006\0\x84\0\0\0\0\0\0\0\x88\0\x8a\0\0\0\0\0\0\0\0\0\0\x008\0\0\0\0\0\0\0\0\0\x9a\0\0\0\x9c\0\0\0\xa0\0\0\0\xa8\0\0\0\xaa\0\0\0\xb4\0\0\0\xb6\0\0\0\0\0\xb8\0\0\0\xbc\0\0\0\xbe\0\0\0\xc0\0\0\0\xc6\0\0\0\xca\0\0\0\xcc\0\0\0\xce\0\0\0\xd4\0\0\0\xd6\0\0\0~\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0H\0\0\0\0\0\n\0\0\0\0\0\0\0\0\0\xd8\0\0\0\0\0\0\0\0\0\x1f\0\t\0\0\0\xda\0\0\0\x0e\0\0\0\0\0\0\0\xea\0\0\0\xec\0\0\0\0\0\0\0\0\0\xf0\0\0\0\x10\0\x16\0\xd8\0\0\0\0\0\0\0\0\0\0\0^\0\0\0n\0\0\0\x05\0\0\0\0\0\0\0\x14\0\0\0\0\0\0\0\xfa\0\0\0\0\0\0\0\0\0h\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\x01\x06\0\0\0\0\0\0\0\b\0\0\0\0\0\0\0\0\0\0\0\0\x01\b\0\0\0\0\0\0\0\0\x01\n\0\0\0\0\0\0\0V\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x98\0\0\0\0\0\0\0\0\0\0\0r\0\0\0\xde\0\0\0\0\0\0\0\0\0\x82\0\0\0,\0\0\0\0\0\0")],
       [0,
        8,
        caml_new_string
         ('{\x15{\x15\x94}\x80\x0b{\x15S\x15\x94\x98\x96Y\x81\x85\x81\x85Z\x86\x95\x86\x81\x85{\x15\xbf\x86\xc0K\x15\x15[bos\x7f\x1b\x1b\xb3\x81\x85G\x1c\x15\x86\xa7\xb9w\x8f\x1e\x1e\xab\xba\x92\x15\x15\xac\x15\x93S\xbc\x1b\xaeIY\x15\x88\xb3\x15Z\x15\x15CL\x1eMy\x8e\xa7\x15\x15\xbd\x15\xb6\xb0\x1e\x15\x15E\xbcD\x19\x15\x15\x15\xae\x15\x15\x15 "\x15$\x15\x15\x15&(\x15\x15S\x15*,/X135\x15\x157\x159;=q\x15?A\x15`\x8fr\xa7\xa1\xb8\x91\0fi\0m\0\0\0\0\x83\0\0\x8c\xb1')]],
     Range=global_data.Range,
     MenhirLib=global_data.MenhirLib,
     Error=[248,cst_Parser_MenhirBasics_Error,runtime.caml_fresh_oo_id(0)],
     _aB_=[1,1],
     _az_=[1,0],
     _U_=[1,1],
     _S_=[1,0],
     _n_=[2,0];
    function loc(startpos,endpos,elt)
     {return [0,elt,caml_call2(Range[13],startpos,endpos)]}
    function token2terminal(tok)
     {if(typeof tok === "number")
       switch(tok)
        {case 0:return 1;
         case 1:return 2;
         case 2:return 3;
         case 3:return 4;
         case 4:return 5;
         case 5:return 6;
         case 6:return 7;
         case 7:return 8;
         case 8:return 10;
         case 9:return 11;
         case 10:return 12;
         case 11:return 13;
         case 12:return 14;
         case 13:return 15;
         case 14:return 16;
         case 15:return 17;
         case 16:return 18;
         case 17:return 19;
         case 18:return 20;
         case 19:return 21;
         case 20:return 22;
         case 21:return 23;
         case 22:return 24;
         case 23:return 25;
         case 24:return 26;
         case 25:return 27;
         case 26:return 28;
         case 27:return 29;
         case 28:return 31;
         case 29:return 33;
         case 30:return 34;
         case 31:return 35;
         case 32:return 36;
         case 33:return 37;
         case 34:return 38;
         case 35:return 39;
         case 36:return 40;
         case 37:return 41;
         case 38:return 42;
         case 39:return 43;
         case 40:return 44;
         case 41:return 45;
         default:return 46}
      else
       switch(tok[0]){case 0:return 9;case 1:return 30;default:return 32}}
    var error_terminal=0;
    function token2value(tok)
     {if(typeof tok === "number")
       switch(tok)
        {case 0:return 0;
         case 1:return 0;
         case 2:return 0;
         case 3:return 0;
         case 4:return 0;
         case 5:return 0;
         case 6:return 0;
         case 7:return 0;
         case 8:return 0;
         case 9:return 0;
         case 10:return 0;
         case 11:return 0;
         case 12:return 0;
         case 13:return 0;
         case 14:return 0;
         case 15:return 0;
         case 16:return 0;
         case 17:return 0;
         case 18:return 0;
         case 19:return 0;
         case 20:return 0;
         case 21:return 0;
         case 22:return 0;
         case 23:return 0;
         case 24:return 0;
         case 25:return 0;
         case 26:return 0;
         case 27:return 0;
         case 28:return 0;
         case 29:return 0;
         case 30:return 0;
         case 31:return 0;
         case 32:return 0;
         case 33:return 0;
         case 34:return 0;
         case 35:return 0;
         case 36:return 0;
         case 37:return 0;
         case 38:return 0;
         case 39:return 0;
         case 40:return 0;
         case 41:return 0;
         default:return 0}
      else
       switch(tok[0])
        {case 0:var v=tok[1];return v;
         case 1:var v$0=tok[1];return v$0;
         default:var v$1=tok[1];return v$1}}
    var start=3;
    function _a_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_xs=menhir_stack[4],
       startpos_xs=menhir_stack[3],
       xs=menhir_stack[2],
       menhir_s=menhir_stack[1];
      return [0,menhir_s,xs,startpos_xs,endpos_xs,menhir_stack$0]}
    function _b_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _bd_=menhir_stack[5][5],
       match=_bd_[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       id=_bd_[2],
       endpos_init=menhir_stack[4],
       init=menhir_stack[2],
       v=[0,id,init];
      return [0,menhir_s,v,startpos_1,endpos_init,menhir_stack$0]}
    function _c_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_t=match[3],
       t=match[2],
       menhir_s=match[1],
       endpos_3=menhir_stack[4],
       r=[0,t],
       v=[0,r];
      return [0,menhir_s,v,startpos_t,endpos_3,menhir_stack$0]}
    function _d_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_1=menhir_stack[4],
       startpos_1=menhir_stack[3],
       menhir_s=menhir_stack[1],
       v=[0,0];
      return [0,menhir_s,v,startpos_1,endpos_1,menhir_stack$0]}
    function _e_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_1=menhir_stack[4],
       startpos_1=menhir_stack[3],
       menhir_s=menhir_stack[1];
      return [0,menhir_s,0,startpos_1,endpos_1,menhir_stack$0]}
    function _f_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_1=menhir_stack[4],
       startpos_1=menhir_stack[3],
       menhir_s=menhir_stack[1];
      return [0,menhir_s,1,startpos_1,endpos_1,menhir_stack$0]}
    function _g_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5],
       menhir_stack$0=match[5],
       startpos_s=match[3],
       s=match[2],
       menhir_s=match[1],
       endpos_2=menhir_stack[4];
      return [0,menhir_s,s,startpos_s,endpos_2,menhir_stack$0]}
    function _h_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_s=menhir_stack[4],
       startpos_s=menhir_stack[3],
       s=menhir_stack[2],
       menhir_s=menhir_stack[1],
       v=[0,s];
      return [0,menhir_s,v,startpos_s,endpos_s,menhir_stack$0]}
    function _i_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_s=menhir_env[4],
       startpos=menhir_stack[4];
      return [0,menhir_s,0,startpos,startpos,menhir_stack]}
    function _j_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _ba_=menhir_stack[5][5],
       _bb_=_ba_[5][5],
       _bc_=_bb_[5][5],
       match=_bc_[5][5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       ds=_bc_[2],
       e=_bb_[2],
       s=_ba_[2],
       endpos_b=menhir_stack[4],
       b=menhir_stack[2],
       v=loc(startpos_1,endpos_b,[5,ds,e,s,b]);
      return [0,menhir_s,v,startpos_1,endpos_b,menhir_stack$0]}
    function _k_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _a$_=menhir_stack[5][5],
       match=_a$_[5][5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       e=_a$_[2],
       endpos_b=menhir_stack[4],
       b=menhir_stack[2],
       v=loc(startpos_1,endpos_b,[6,e,b]);
      return [0,menhir_s,v,startpos_1,endpos_b,menhir_stack$0]}
    function _l_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _a__=menhir_stack[5],
       match=_a__[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       e=_a__[2],
       endpos_3=menhir_stack[4],
       v=loc(startpos_1,endpos_3,[2,[0,e]]);
      return [0,menhir_s,v,startpos_1,endpos_3,menhir_stack$0]}
    function _m_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       endpos_2=menhir_stack[4],
       v=loc(startpos_1,endpos_2,_n_);
      return [0,menhir_s,v,startpos_1,endpos_2,menhir_stack$0]}
    function _o_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_ifs=menhir_stack[4],
       startpos_ifs=menhir_stack[3],
       ifs=menhir_stack[2],
       menhir_s=menhir_stack[1];
      return [0,menhir_s,ifs,startpos_ifs,endpos_ifs,menhir_stack$0]}
    function _p_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _a9_=menhir_stack[5][5],
       match=_a9_[5][5],
       menhir_stack$0=match[5],
       startpos_e=match[3],
       e=match[2],
       menhir_s=match[1],
       xs=_a9_[2],
       endpos_5=menhir_stack[4],
       v=loc(startpos_e,endpos_5,[3,e,xs]);
      return [0,menhir_s,v,startpos_e,endpos_5,menhir_stack$0]}
    function _q_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _a8_=menhir_stack[5],
       match=_a8_[5][5],
       menhir_stack$0=match[5],
       startpos_p=match[3],
       p=match[2],
       menhir_s=match[1],
       e=_a8_[2],
       endpos_4=menhir_stack[4],
       v=loc(startpos_p,endpos_4,[0,p,e]);
      return [0,menhir_s,v,startpos_p,endpos_4,menhir_stack$0]}
    function _r_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5],
       menhir_stack$0=match[5],
       startpos_d=match[3],
       d=match[2],
       menhir_s=match[1],
       endpos_2=menhir_stack[4],
       v=loc(startpos_d,endpos_2,[1,d]);
      return [0,menhir_s,v,startpos_d,endpos_2,menhir_stack$0]}
    function _s_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_x=match[3],
       x=match[2],
       menhir_s=match[1],
       endpos_xs=menhir_stack[4],
       xs=menhir_stack[2],
       v=[0,x,xs];
      return [0,menhir_s,v,startpos_x,endpos_xs,menhir_stack$0]}
    function _t_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_x=menhir_stack[4],
       startpos_x=menhir_stack[3],
       x=menhir_stack[2],
       menhir_s=menhir_stack[1],
       v=[0,x,0];
      return [0,menhir_s,v,startpos_x,endpos_x,menhir_stack$0]}
    function _u_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _a7_=menhir_stack[5][5],
       match=_a7_[5],
       menhir_stack$0=match[5],
       startpos_x=match[3],
       x=match[2],
       menhir_s=match[1],
       y=_a7_[2],
       endpos_xs=menhir_stack[4],
       xs=menhir_stack[2],
       x$0=[0,x,y],
       v=[0,x$0,xs];
      return [0,menhir_s,v,startpos_x,endpos_xs,menhir_stack$0]}
    function _v_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5],
       menhir_stack$0=match[5],
       startpos_x=match[3],
       x=match[2],
       menhir_s=match[1],
       endpos_y=menhir_stack[4],
       y=menhir_stack[2],
       x$0=[0,x,y],
       v=[0,x$0,0];
      return [0,menhir_s,v,startpos_x,endpos_y,menhir_stack$0]}
    function _w_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_x=match[3],
       x=match[2],
       menhir_s=match[1],
       endpos_xs=menhir_stack[4],
       xs=menhir_stack[2],
       v=[0,x,xs];
      return [0,menhir_s,v,startpos_x,endpos_xs,menhir_stack$0]}
    function _x_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_x=menhir_stack[4],
       startpos_x=menhir_stack[3],
       x=menhir_stack[2],
       menhir_s=menhir_stack[1],
       v=[0,x,0];
      return [0,menhir_s,v,startpos_x,endpos_x,menhir_stack$0]}
    function _y_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_x=match[3],
       x=match[2],
       menhir_s=match[1],
       endpos_xs=menhir_stack[4],
       xs=menhir_stack[2],
       v=[0,x,xs];
      return [0,menhir_s,v,startpos_x,endpos_xs,menhir_stack$0]}
    function _z_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_x=menhir_stack[4],
       startpos_x=menhir_stack[3],
       x=menhir_stack[2],
       menhir_s=menhir_stack[1],
       v=[0,x,0];
      return [0,menhir_s,v,startpos_x,endpos_x,menhir_stack$0]}
    function _A_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5],
       menhir_stack$0=match[5],
       startpos_p=match[3],
       p=match[2],
       menhir_s=match[1],
       endpos_2=menhir_stack[4];
      return [0,menhir_s,p,startpos_p,endpos_2,menhir_stack$0]}
    function _B_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_x=menhir_stack[4],
       startpos_x=menhir_stack[3],
       x=menhir_stack[2],
       menhir_s=menhir_stack[1];
      return [0,menhir_s,x,startpos_x,endpos_x,menhir_stack$0]}
    function _C_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_s=menhir_env[4],
       startpos=menhir_stack[4];
      return [0,menhir_s,0,startpos,startpos,menhir_stack]}
    function _D_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_x=menhir_stack[4],
       startpos_x=menhir_stack[3],
       x=menhir_stack[2],
       menhir_s=menhir_stack[1];
      return [0,menhir_s,x,startpos_x,endpos_x,menhir_stack$0]}
    function _E_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_s=menhir_env[4],
       startpos=menhir_stack[4];
      return [0,menhir_s,0,startpos,startpos,menhir_stack]}
    function _F_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_x=menhir_stack[4],
       startpos_x=menhir_stack[3],
       x=menhir_stack[2],
       menhir_s=menhir_stack[1];
      return [0,menhir_s,x,startpos_x,endpos_x,menhir_stack$0]}
    function _G_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_s=menhir_env[4],
       startpos=menhir_stack[4];
      return [0,menhir_s,0,startpos,startpos,menhir_stack]}
    function _H_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_x=menhir_stack[4],
       startpos_x=menhir_stack[3],
       x=menhir_stack[2],
       menhir_s=menhir_stack[1];
      return [0,menhir_s,x,startpos_x,endpos_x,menhir_stack$0]}
    function _I_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_s=menhir_env[4],
       startpos=menhir_stack[4];
      return [0,menhir_s,0,startpos,startpos,menhir_stack]}
    function _J_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5],
       menhir_stack$0=match[5],
       startpos_x=match[3],
       x=match[2],
       menhir_s=match[1],
       endpos_xs=menhir_stack[4],
       xs=menhir_stack[2],
       v=[0,x,xs];
      return [0,menhir_s,v,startpos_x,endpos_xs,menhir_stack$0]}
    function _K_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_s=menhir_env[4],
       startpos=menhir_stack[4];
      return [0,menhir_s,0,startpos,startpos,menhir_stack]}
    function _L_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5],
       menhir_stack$0=match[5],
       startpos_x=match[3],
       x=match[2],
       menhir_s=match[1],
       endpos_xs=menhir_stack[4],
       xs=menhir_stack[2],
       v=[0,x,xs];
      return [0,menhir_s,v,startpos_x,endpos_xs,menhir_stack$0]}
    function _M_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_s=menhir_env[4],
       startpos=menhir_stack[4];
      return [0,menhir_s,0,startpos,startpos,menhir_stack]}
    function _N_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _a6_=menhir_stack[5],
       match=_a6_[5][5],
       menhir_stack$0=match[5],
       startpos_e=match[3],
       e=match[2],
       menhir_s=match[1],
       i=_a6_[2],
       endpos_4=menhir_stack[4],
       v=loc(startpos_e,endpos_4,[7,e,i]);
      return [0,menhir_s,v,startpos_e,endpos_4,menhir_stack$0]}
    function _O_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_id=menhir_stack[4],
       startpos_id=menhir_stack[3],
       id=menhir_stack[2],
       menhir_s=menhir_stack[1],
       v=loc(startpos_id,endpos_id,[6,id]);
      return [0,menhir_s,v,startpos_id,endpos_id,menhir_stack$0]}
    function _P_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _a4_=menhir_stack[5],
       _a5_=_a4_[5][5],
       match=_a5_[5][5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       e=_a5_[2],
       b1=_a4_[2],
       endpos_b2=menhir_stack[4],
       b2=menhir_stack[2],
       v=loc(startpos_1,endpos_b2,[4,e,b1,b2]);
      return [0,menhir_s,v,startpos_1,endpos_b2,menhir_stack$0]}
    function _Q_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _a2_=menhir_stack[5],
       _a3_=_a2_[5][5][5][5],
       match=_a3_[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       t=_a3_[2],
       xs=_a2_[2],
       endpos_7=menhir_stack[4],
       v=loc(startpos_1,endpos_7,[4,t,xs]);
      return [0,menhir_s,v,startpos_1,endpos_7,menhir_stack$0]}
    function _R_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_1=menhir_stack[4],
       startpos_1=menhir_stack[3],
       menhir_s=menhir_stack[1],
       v=loc(startpos_1,endpos_1,_S_);
      return [0,menhir_s,v,startpos_1,endpos_1,menhir_stack$0]}
    function _T_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_1=menhir_stack[4],
       startpos_1=menhir_stack[3],
       menhir_s=menhir_stack[1],
       v=loc(startpos_1,endpos_1,_U_);
      return [0,menhir_s,v,startpos_1,endpos_1,menhir_stack$0]}
    function _V_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5][5],
       menhir_stack$0=match[5],
       startpos_t=match[3],
       t=match[2],
       menhir_s=match[1],
       endpos_2=menhir_stack[4],
       t$0=[0,t],
       v=loc(startpos_t,endpos_2,[0,t$0]);
      return [0,menhir_s,v,startpos_t,endpos_2,menhir_stack$0]}
    function _W_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       endpos_2=menhir_stack[4],
       v=loc(startpos_1,endpos_2,[0,0]);
      return [0,menhir_s,v,startpos_1,endpos_2,menhir_stack$0]}
    function _X_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_s=menhir_stack[4],
       startpos_s=menhir_stack[3],
       s=menhir_stack[2],
       menhir_s=menhir_stack[1],
       v=loc(startpos_s,endpos_s,[3,s]);
      return [0,menhir_s,v,startpos_s,endpos_s,menhir_stack$0]}
    function _Y_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_i=menhir_stack[4],
       startpos_i=menhir_stack[3],
       i=menhir_stack[2],
       menhir_s=menhir_stack[1],
       v=loc(startpos_i,endpos_i,[2,i]);
      return [0,menhir_s,v,startpos_i,endpos_i,menhir_stack$0]}
    function _Z_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5],
       menhir_stack$0=match[5],
       startpos_e=match[3],
       e=match[2],
       menhir_s=match[1],
       endpos_2=menhir_stack[4];
      return [0,menhir_s,e,startpos_e,endpos_2,menhir_stack$0]}
    function ___(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_e=menhir_stack[4],
       startpos_e=menhir_stack[3],
       e=menhir_stack[2],
       menhir_s=menhir_stack[1],
       v=[0,e];
      return [0,menhir_s,v,startpos_e,endpos_e,menhir_stack$0]}
    function _$_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_s=menhir_env[4],
       startpos=menhir_stack[4];
      return [0,menhir_s,0,startpos,startpos,menhir_stack]}
    function _aa_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _a1_=menhir_stack[5],
       match=_a1_[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       e=_a1_[2],
       endpos_3=menhir_stack[4];
      return [0,menhir_s,e,startpos_1,endpos_3,menhir_stack$0]}
    function _ab_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       endpos_e=menhir_stack[4],
       e=menhir_stack[2],
       v=loc(startpos_1,endpos_e,[10,2,e]);
      return [0,menhir_s,v,startpos_1,endpos_e,menhir_stack$0]}
    function _ac_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       endpos_e=menhir_stack[4],
       e=menhir_stack[2],
       v=loc(startpos_1,endpos_e,[10,1,e]);
      return [0,menhir_s,v,startpos_1,endpos_e,menhir_stack$0]}
    function _ad_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       endpos_e=menhir_stack[4],
       e=menhir_stack[2],
       v=loc(startpos_1,endpos_e,[10,0,e]);
      return [0,menhir_s,v,startpos_1,endpos_e,menhir_stack$0]}
    function _ae_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_e1=match[3],
       e1=match[2],
       menhir_s=match[1],
       endpos_e2=menhir_stack[4],
       e2=menhir_stack[2],
       v=loc(startpos_e1,endpos_e2,[9,15,e1,e2]);
      return [0,menhir_s,v,startpos_e1,endpos_e2,menhir_stack$0]}
    function _af_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_e1=match[3],
       e1=match[2],
       menhir_s=match[1],
       endpos_e2=menhir_stack[4],
       e2=menhir_stack[2],
       v=loc(startpos_e1,endpos_e2,[9,14,e1,e2]);
      return [0,menhir_s,v,startpos_e1,endpos_e2,menhir_stack$0]}
    function _ag_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_e1=match[3],
       e1=match[2],
       menhir_s=match[1],
       endpos_e2=menhir_stack[4],
       e2=menhir_stack[2],
       v=loc(startpos_e1,endpos_e2,[9,13,e1,e2]);
      return [0,menhir_s,v,startpos_e1,endpos_e2,menhir_stack$0]}
    function _ah_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_e1=match[3],
       e1=match[2],
       menhir_s=match[1],
       endpos_e2=menhir_stack[4],
       e2=menhir_stack[2],
       v=loc(startpos_e1,endpos_e2,[9,12,e1,e2]);
      return [0,menhir_s,v,startpos_e1,endpos_e2,menhir_stack$0]}
    function _ai_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_e1=match[3],
       e1=match[2],
       menhir_s=match[1],
       endpos_e2=menhir_stack[4],
       e2=menhir_stack[2],
       v=loc(startpos_e1,endpos_e2,[9,11,e1,e2]);
      return [0,menhir_s,v,startpos_e1,endpos_e2,menhir_stack$0]}
    function _aj_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_e1=match[3],
       e1=match[2],
       menhir_s=match[1],
       endpos_e2=menhir_stack[4],
       e2=menhir_stack[2],
       v=loc(startpos_e1,endpos_e2,[9,10,e1,e2]);
      return [0,menhir_s,v,startpos_e1,endpos_e2,menhir_stack$0]}
    function _ak_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_e1=match[3],
       e1=match[2],
       menhir_s=match[1],
       endpos_e2=menhir_stack[4],
       e2=menhir_stack[2],
       v=loc(startpos_e1,endpos_e2,[9,9,e1,e2]);
      return [0,menhir_s,v,startpos_e1,endpos_e2,menhir_stack$0]}
    function _al_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_e1=match[3],
       e1=match[2],
       menhir_s=match[1],
       endpos_e2=menhir_stack[4],
       e2=menhir_stack[2],
       v=loc(startpos_e1,endpos_e2,[9,8,e1,e2]);
      return [0,menhir_s,v,startpos_e1,endpos_e2,menhir_stack$0]}
    function _am_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_e1=match[3],
       e1=match[2],
       menhir_s=match[1],
       endpos_e2=menhir_stack[4],
       e2=menhir_stack[2],
       v=loc(startpos_e1,endpos_e2,[9,7,e1,e2]);
      return [0,menhir_s,v,startpos_e1,endpos_e2,menhir_stack$0]}
    function _an_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_e1=match[3],
       e1=match[2],
       menhir_s=match[1],
       endpos_e2=menhir_stack[4],
       e2=menhir_stack[2],
       v=loc(startpos_e1,endpos_e2,[9,6,e1,e2]);
      return [0,menhir_s,v,startpos_e1,endpos_e2,menhir_stack$0]}
    function _ao_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_e1=match[3],
       e1=match[2],
       menhir_s=match[1],
       endpos_e2=menhir_stack[4],
       e2=menhir_stack[2],
       v=loc(startpos_e1,endpos_e2,[9,5,e1,e2]);
      return [0,menhir_s,v,startpos_e1,endpos_e2,menhir_stack$0]}
    function _ap_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_e1=match[3],
       e1=match[2],
       menhir_s=match[1],
       endpos_e2=menhir_stack[4],
       e2=menhir_stack[2],
       v=loc(startpos_e1,endpos_e2,[9,4,e1,e2]);
      return [0,menhir_s,v,startpos_e1,endpos_e2,menhir_stack$0]}
    function _aq_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_e1=match[3],
       e1=match[2],
       menhir_s=match[1],
       endpos_e2=menhir_stack[4],
       e2=menhir_stack[2],
       v=loc(startpos_e1,endpos_e2,[9,3,e1,e2]);
      return [0,menhir_s,v,startpos_e1,endpos_e2,menhir_stack$0]}
    function _ar_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_e1=match[3],
       e1=match[2],
       menhir_s=match[1],
       endpos_e2=menhir_stack[4],
       e2=menhir_stack[2],
       v=loc(startpos_e1,endpos_e2,[9,2,e1,e2]);
      return [0,menhir_s,v,startpos_e1,endpos_e2,menhir_stack$0]}
    function _as_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_e1=match[3],
       e1=match[2],
       menhir_s=match[1],
       endpos_e2=menhir_stack[4],
       e2=menhir_stack[2],
       v=loc(startpos_e1,endpos_e2,[9,1,e1,e2]);
      return [0,menhir_s,v,startpos_e1,endpos_e2,menhir_stack$0]}
    function _at_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_e1=match[3],
       e1=match[2],
       menhir_s=match[1],
       endpos_e2=menhir_stack[4],
       e2=menhir_stack[2],
       v=loc(startpos_e1,endpos_e2,[9,0,e1,e2]);
      return [0,menhir_s,v,startpos_e1,endpos_e2,menhir_stack$0]}
    function _au_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _aZ_=menhir_stack[5],
       _a0_=_aZ_[5][5],
       match=_a0_[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       t=_a0_[2],
       e=_aZ_[2],
       endpos_5=menhir_stack[4],
       v=loc(startpos_1,endpos_5,[5,t,e]);
      return [0,menhir_s,v,startpos_1,endpos_5,menhir_stack$0]}
    function _av_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _aX_=menhir_stack[5],
       _aY_=_aX_[5][5][5][5],
       match=_aY_[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       t=_aY_[2],
       xs=_aX_[2],
       endpos_7=menhir_stack[4],
       v=loc(startpos_1,endpos_7,[4,t,xs]);
      return [0,menhir_s,v,startpos_1,endpos_7,menhir_stack$0]}
    function _aw_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _aW_=menhir_stack[5],
       match=_aW_[5][5],
       menhir_stack$0=match[5],
       startpos_e=match[3],
       e=match[2],
       menhir_s=match[1],
       xs=_aW_[2],
       endpos_4=menhir_stack[4],
       v=loc(startpos_e,endpos_4,[8,e,xs]);
      return [0,menhir_s,v,startpos_e,endpos_4,menhir_stack$0]}
    function _ax_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _aV_=menhir_stack[5],
       match=_aV_[5][5],
       menhir_stack$0=match[5],
       startpos_e=match[3],
       e=match[2],
       menhir_s=match[1],
       i=_aV_[2],
       endpos_4=menhir_stack[4],
       v=loc(startpos_e,endpos_4,[7,e,i]);
      return [0,menhir_s,v,startpos_e,endpos_4,menhir_stack$0]}
    function _ay_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_1=menhir_stack[4],
       startpos_1=menhir_stack[3],
       menhir_s=menhir_stack[1],
       v=loc(startpos_1,endpos_1,_az_);
      return [0,menhir_s,v,startpos_1,endpos_1,menhir_stack$0]}
    function _aA_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_1=menhir_stack[4],
       startpos_1=menhir_stack[3],
       menhir_s=menhir_stack[1],
       v=loc(startpos_1,endpos_1,_aB_);
      return [0,menhir_s,v,startpos_1,endpos_1,menhir_stack$0]}
    function _aC_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5][5],
       menhir_stack$0=match[5],
       startpos_t=match[3],
       t=match[2],
       menhir_s=match[1],
       endpos_2=menhir_stack[4],
       t$0=[0,t],
       v=loc(startpos_t,endpos_2,[0,t$0]);
      return [0,menhir_s,v,startpos_t,endpos_2,menhir_stack$0]}
    function _aD_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       endpos_2=menhir_stack[4],
       v=loc(startpos_1,endpos_2,[0,0]);
      return [0,menhir_s,v,startpos_1,endpos_2,menhir_stack$0]}
    function _aE_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_s=menhir_stack[4],
       startpos_s=menhir_stack[3],
       s=menhir_stack[2],
       menhir_s=menhir_stack[1],
       v=loc(startpos_s,endpos_s,[3,s]);
      return [0,menhir_s,v,startpos_s,endpos_s,menhir_stack$0]}
    function _aF_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_i=menhir_stack[4],
       startpos_i=menhir_stack[3],
       i=menhir_stack[2],
       menhir_s=menhir_stack[1],
       v=loc(startpos_i,endpos_i,[2,i]);
      return [0,menhir_s,v,startpos_i,endpos_i,menhir_stack$0]}
    function _aG_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_id=menhir_stack[4],
       startpos_id=menhir_stack[3],
       id=menhir_stack[2],
       menhir_s=menhir_stack[1],
       v=loc(startpos_id,endpos_id,[6,id]);
      return [0,menhir_s,v,startpos_id,endpos_id,menhir_stack$0]}
    function _aH_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       endpos_ifs=menhir_stack[4],
       ifs=menhir_stack[2],
       v=[0,ifs,0];
      return [0,menhir_s,v,startpos_1,endpos_ifs,menhir_stack$0]}
    function _aI_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       endpos_b=menhir_stack[4],
       b=menhir_stack[2];
      return [0,menhir_s,b,startpos_1,endpos_b,menhir_stack$0]}
    function _aJ_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_s=menhir_env[4],
       startpos=menhir_stack[4];
      return [0,menhir_s,0,startpos,startpos,menhir_stack]}
    function _aK_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _aT_=menhir_stack[5][5],
       _aU_=_aT_[5][5],
       match=_aU_[5],
       menhir_stack$0=match[5],
       startpos_t=match[3],
       t=match[2],
       menhir_s=match[1],
       fname=_aU_[2],
       args=_aT_[2],
       endpos_body=menhir_stack[4],
       body=menhir_stack[2],
       frtyp=[0,t],
       v=[1,loc(startpos_t,endpos_body,[0,frtyp,fname,args,body])];
      return [0,menhir_s,v,startpos_t,endpos_body,menhir_stack$0]}
    function _aL_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _aR_=menhir_stack[5][5],
       _aS_=_aR_[5][5],
       match=_aS_[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       fname=_aS_[2],
       args=_aR_[2],
       endpos_body=menhir_stack[4],
       body=menhir_stack[2],
       v=[1,loc(startpos_1,endpos_body,[0,0,fname,args,body])];
      return [0,menhir_s,v,startpos_1,endpos_body,menhir_stack$0]}
    function _aM_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _aP_=menhir_stack[5],
       _aQ_=_aP_[5][5],
       match=_aQ_[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       name=_aQ_[2],
       init=_aP_[2],
       endpos_5=menhir_stack[4],
       v=[0,loc(startpos_1,endpos_5,[0,name,init])];
      return [0,menhir_s,v,startpos_1,endpos_5,menhir_stack$0]}
    function _aN_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _aO_=menhir_stack[5],
       match=_aO_[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       stmts=_aO_[2],
       endpos_3=menhir_stack[4];
      return [0,menhir_s,stmts,startpos_1,endpos_3,menhir_stack$0]}
    var
     semantic_action=
      [0,
       function(menhir_env)
        {var
          menhir_stack=menhir_env[3],
          menhir_stack$0=menhir_stack[5],
          endpos_xs=menhir_stack[4],
          startpos_xs=menhir_stack[3],
          xs=menhir_stack[2],
          menhir_s=menhir_stack[1];
         return [0,menhir_s,xs,startpos_xs,endpos_xs,menhir_stack$0]},
       _aN_,
       _aM_,
       _aL_,
       _aK_,
       _aJ_,
       _aI_,
       _aH_,
       _aG_,
       _aF_,
       _aE_,
       _aD_,
       _aC_,
       _aA_,
       _ay_,
       _ax_,
       _aw_,
       _av_,
       _au_,
       _at_,
       _as_,
       _ar_,
       _aq_,
       _ap_,
       _ao_,
       _an_,
       _am_,
       _al_,
       _ak_,
       _aj_,
       _ai_,
       _ah_,
       _ag_,
       _af_,
       _ae_,
       _ad_,
       _ac_,
       _ab_,
       _aa_,
       _$_,
       ___,
       _Z_,
       _Y_,
       _X_,
       _W_,
       _V_,
       _T_,
       _R_,
       _Q_,
       _P_,
       _O_,
       _N_,
       _M_,
       _L_,
       _K_,
       _J_,
       _I_,
       _H_,
       _G_,
       _F_,
       _E_,
       _D_,
       _C_,
       _B_,
       _A_,
       _z_,
       _y_,
       _x_,
       _w_,
       _v_,
       _u_,
       _t_,
       _s_,
       _r_,
       _q_,
       _p_,
       _o_,
       _m_,
       _l_,
       _k_,
       _j_,
       _i_,
       _h_,
       _g_,
       _f_,
       _e_,
       _d_,
       _c_,
       _b_,
       _a_],
     ET=
      caml_call1
       (MenhirLib[15][1],
        [0,
         token2terminal,
         error_terminal,
         token2value,
         default_reduction,
         error,
         action,
         lhs,
         goto$0,
         start,
         semantic_action,
         Error,
         0]),
     TI=caml_call1(MenhirLib[5][1],ET),
     entry=TI[2],
     offer=TI[3],
     resume=TI[4],
     lexer_lexbuf_to_supplier=TI[5],
     loop=TI[6],
     loop_handle=TI[7],
     loop_handle_undo=TI[8],
     shifts=TI[9],
     acceptable=TI[10],
     number=TI[11],
     production_index=TI[12],
     find_production=TI[13],
     stack=TI[14],
     top=TI[15],
     pop_many=TI[16],
     get=TI[17],
     current_state_number=TI[18],
     equal=TI[19],
     positions=TI[20],
     env_has_default_reduction=TI[21],
     state_has_default_reduction=TI[22],
     pop=TI[23],
     force_reduction=TI[24],
     input_needed=TI[25],
     start$0=TI[26];
    function stmt_top(lexer,lexbuf){return caml_call3(entry,189,lexer,lexbuf)}
    function prog(lexer,lexbuf){return caml_call3(entry,78,lexer,lexbuf)}
    function exp_top(lexer,lexbuf){return caml_call3(entry,0,lexer,lexbuf)}
    function stmt_top$0(initial_position)
     {return caml_call2(start$0,189,initial_position)}
    function prog$0(initial_position)
     {return caml_call2(start$0,78,initial_position)}
    function exp_top$0(initial_position)
     {return caml_call2(start$0,0,initial_position)}
    var
     Incremental=[0,stmt_top$0,prog$0,exp_top$0],
     Parser=
      [0,
       Error,
       stmt_top,
       prog,
       exp_top,
       [0,
        offer,
        resume,
        lexer_lexbuf_to_supplier,
        loop,
        loop_handle,
        loop_handle_undo,
        shifts,
        acceptable,
        number,
        production_index,
        find_production,
        stack,
        top,
        pop_many,
        get,
        current_state_number,
        equal,
        positions,
        env_has_default_reduction,
        state_has_default_reduction,
        pop,
        force_reduction,
        input_needed],
       Incremental];
    runtime.caml_register_global(13,Parser,"Parser");
    return}
  (function(){return this}()));


//# 1 ".server.eobjs/byte/lexer.cmo.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_bytes_set=runtime.caml_bytes_set,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_int_of_string=runtime.caml_int_of_string,
     caml_list_of_js_array=runtime.caml_list_of_js_array,
     caml_new_string=runtime.caml_new_string,
     caml_trampoline=runtime.caml_trampoline,
     caml_trampoline_return=runtime.caml_trampoline_return;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_Lexer_Lexer_error=caml_new_string("Lexer.Lexer_error"),
     reserved_words=
      caml_list_of_js_array
       ([[0,caml_new_string("null"),19],
         [0,caml_new_string("true"),4],
         [0,caml_new_string("false"),34],
         [0,caml_new_string("void"),2],
         [0,caml_new_string("bool"),7],
         [0,caml_new_string("int"),5],
         [0,caml_new_string("string"),3],
         [0,caml_new_string("new"),20],
         [0,caml_new_string("else"),38],
         [0,caml_new_string("if"),28],
         [0,caml_new_string("while"),0],
         [0,caml_new_string("for"),33],
         [0,caml_new_string("return"),14],
         [0,caml_new_string("var"),1],
         [0,caml_new_string("global"),32],
         [0,caml_new_string(";"),11],
         [0,caml_new_string(","),40],
         [0,caml_new_string("{"),26],
         [0,caml_new_string("}"),16],
         [0,caml_new_string("("),24],
         [0,caml_new_string(")"),13],
         [0,caml_new_string("["),25],
         [0,caml_new_string("]"),15],
         [0,caml_new_string("="),36],
         [0,caml_new_string("+"),17],
         [0,caml_new_string("-"),39],
         [0,caml_new_string("*"),8],
         [0,caml_new_string("=="),35],
         [0,caml_new_string("!="),21],
         [0,caml_new_string("<"),23],
         [0,caml_new_string("<="),22],
         [0,caml_new_string(">"),31],
         [0,caml_new_string(">="),30],
         [0,caml_new_string("&"),42],
         [0,caml_new_string("|"),18],
         [0,caml_new_string("[&]"),29],
         [0,caml_new_string("[|]"),27],
         [0,caml_new_string("<<"),10],
         [0,caml_new_string(">>"),9],
         [0,caml_new_string(">>>"),12],
         [0,caml_new_string("!"),41],
         [0,caml_new_string("~"),6]]),
     ocaml_lex_tables=
      [0,
       caml_new_string
        ("\0\0\xf6\xff\xf7\xff\x02\0\x05\0\b\0\x06\0\x07\0\x01\0\xf8\xff\x05\0\x15\0\x1f\0W\0\xfc\xff\xfd\xff\x10\0\xff\xff\xfe\xff\xa2\0\xb9\0\x01\0\x02\0\x1b\0\0\x01\xfb\xff\x02\0\xfc\xff\xfd\xff\xde\0\x07\0V\0\xfb\xff\xfc\xff\xfd\xff0\0-\0\xff\xff\xfe\xff\xd2\0\xfb\xff\xfc\xff\xfd\xff\xfe\xff\xff\xff\x18\x01\xf9\xff\xf3\0\xfb\xff\xfc\xff\xfd\xff\xfe\xff\xff\xff'\x01\xfa\xff"),
       caml_new_string
        ("\xff\xff\xff\xff\xff\xff\b\0\b\0\b\0\b\0\b\0\x07\0\xff\xff\x06\0\x05\0\x05\0\x04\0\xff\xff\xff\xff\t\0\xff\xff\xff\xff\xff\xff\x05\0\xff\xff\xff\xff\b\0\xff\xff\xff\xff\x03\0\xff\xff\xff\xff\x01\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\x02\0\x02\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x06\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"),
       caml_new_string
        ('\x01\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\xff\xff\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x19\0\0\0\xff\xff\0\0\0\0\xff\xff\xff\xff"\0\0\0\0\0\0\0\xff\xff\xff\xff\0\0\0\0(\0\0\0\0\0\0\0\0\0\0\0.\0\0\0\xff\xff\0\0\0\0\0\0\0\0\0\0\xff\xff\0\0'),
       caml_new_string
        ("\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\n\0\t\0\t\0\x1b\0\b\0\n\0\0\0\x1e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\n\0\x06\0\x0f\0\x0e\0\0\0\n\0\x02\0\x1e\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x16\0\x10\0\f\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x12\0\x02\0\x04\0\x07\0\x03\0\x02\0\x17\0\x02\0\x02\0\x02\0\x02\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x02\0&\0\x05\0%\0\x02\0\x02\0\x02\0!\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\x02\0\x02\0\x02\0\x02\0\0\0$\0\0\0\0\0\0\0\x15\0#\0\0\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\0\0\0\0\0\0\0\0\r\0\0\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\0\0,\0\0\0\0\0\0\0\0\0\0\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x11\0\0\0\0\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x1e\0\x1b\0\0\0\0\0\x1a\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\0\0\0\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x1e\0\0\0\x1c\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\0\0\0+\0\0\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\x001\0\0\0\0\0\0\0\0\x000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\0\0\0\0\0\0\0\0 \x006\x006\x006\x006\x006\x006\x006\x006\x006\x006\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x004\0\0\0\0\0\0\0\0\0\0\x003\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0)\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
       caml_new_string
        ("\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\b\0\x1a\0\0\0\n\0\xff\xff\x1e\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0\xff\xff\n\0\0\0\x1e\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\x03\0\x03\0\x04\0\x04\0\x06\0\x07\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\x17\0#\0\0\0$\0\0\0\x15\0\x16\0\x1f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\x1f\0\xff\xff\xff\xff\xff\xff\x05\0\x1f\0\xff\xff\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\f\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\xff\xff\xff\xff\xff\xff\xff\xff\r\0\xff\xff\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0'\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\xff\xff'\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\0\0\xff\xff\xff\xff\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x18\0\x18\0\xff\xff\xff\xff\x18\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\xff\xff\xff\xff\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x18\0\xff\xff\x18\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\xff\xff'\0\xff\xff\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0-\0\xff\xff\xff\xff\xff\xff\xff\xff-\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0\xff\xff\xff\xff\xff\xff\xff\xff\x1f\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff-\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff-\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff-\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff'\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x18\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff-\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"),
       caml_new_string(""),
       caml_new_string(""),
       caml_new_string(""),
       caml_new_string(""),
       caml_new_string(""),
       caml_new_string("")],
     Lexing=global_data.Lexing,
     Printf=global_data.Printf,
     Char=global_data.Char,
     Bytes=global_data.Bytes,
     Range=global_data.Range,
     Hashtbl=global_data.Hashtbl,
     List=global_data.List,
     Lexer_error=[248,cst_Lexer_Lexer_error,runtime.caml_fresh_oo_id(0)],
     _c_=
      [0,
       [11,caml_new_string("# can only be the 1st char in a line."),0],
       caml_new_string("# can only be the 1st char in a line.")],
     _d_=
      [0,
       [11,caml_new_string("Illegal directives"),0],
       caml_new_string("Illegal directives")],
     _e_=
      [0,
       [11,caml_new_string("Illegal directives"),0],
       caml_new_string("Illegal directives")],
     _f_=
      [0,
       [11,caml_new_string("Illegal directives"),0],
       caml_new_string("Illegal directives")],
     _g_=
      [0,
       [11,caml_new_string("Illegal directives"),0],
       caml_new_string("Illegal directives")],
     _h_=
      [0,
       [11,caml_new_string("comments are not closed"),0],
       caml_new_string("comments are not closed")],
     _i_=
      [0,
       [11,caml_new_string("String is not terminated"),0],
       caml_new_string("String is not terminated")],
     _j_=
      [0,
       [2,
        0,
        [11,caml_new_string(" is an illegal escaped character constant"),0]],
       caml_new_string("%s is an illegal escaped character constant")],
     _k_=
      [0,
       [2,
        0,
        [11,caml_new_string(" is an illegal escaped character constant"),0]],
       caml_new_string("%s is an illegal escaped character constant")],
     _a_=
      [0,
       [11,caml_new_string("Unexpected character: '"),[0,[12,39,0]]],
       caml_new_string("Unexpected character: '%c'")];
    function reset_lexbuf(filename,lnum,lexbuf)
     {lexbuf[12] = [0,filename,lnum,0,0];return 0}
    function newline(lexbuf)
     {var
       init=caml_call1(Lexing[10],lexbuf),
       _P_=init[4],
       _Q_=caml_call1(Lexing[8],lexbuf),
       _R_=caml_call1(Lexing[10],lexbuf)[2] + 1 | 0;
      lexbuf[12] = [0,init[1],_R_,_Q_,_P_];
      return 0}
    function unexpected_char(lexbuf,c)
     {var _O_=caml_call2(Printf[4],_a_,c);
      throw [0,Lexer_error,caml_call1(Range[14],lexbuf),_O_]}
    var symbol_table=caml_call2(Hashtbl[1],0,1024);
    function _b_(param)
     {var t=param[2],str=param[1];
      return caml_call3(Hashtbl[5],symbol_table,str,t)}
    caml_call2(List[15],_b_,reserved_words);
    function create_token(lexbuf)
     {var str=caml_call1(Lexing[5],lexbuf);
      try
       {var _M_=caml_call2(Hashtbl[6],symbol_table,str);return _M_}
      catch(_N_){return [2,str]}}
    var
     string_buffer=[0,caml_create_bytes(2048)],
     string_end=[0,0],
     start_lex=[0,caml_call1(Range[5],Range[11])];
    function start_pos_of_lexbuf(lexbuf)
     {var _L_=caml_call1(Lexing[9],lexbuf);return caml_call1(Range[12],_L_)}
    function lex_long_range(lexbuf)
     {var end_p=caml_call1(Lexing[10],lexbuf),_K_=caml_call1(Range[12],end_p);
      return caml_call3(Range[7],end_p[1],start_lex[1],_K_)}
    function reset_str(param){string_end[1] = 0;return 0}
    function add_str(ch)
     {var x=string_end[1],buffer=string_buffer[1];
      if(x === runtime.caml_ml_bytes_length(buffer))
       {var new_buffer=caml_create_bytes(x * 2 | 0);
        caml_call5(Bytes[11],buffer,0,new_buffer,0,x);
        caml_bytes_set(new_buffer,x,ch);
        string_buffer[1] = new_buffer;
        string_end[1] = x + 1 | 0;
        return 0}
      caml_bytes_set(buffer,x,ch);
      string_end[1] = x + 1 | 0;
      return 0}
    function get_str(param)
     {return caml_call3(Bytes[8],string_buffer[1],0,string_end[1])}
    var lnum=[0,1];
    function token$0(counter,lexbuf)
     {var _J_=0;
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return ocaml_lex_token_rec$0(counter$0,lexbuf,_J_)}
      return caml_trampoline_return(ocaml_lex_token_rec$0,[0,lexbuf,_J_])}
    function ocaml_lex_token_rec$0(counter,lexbuf,ocaml_lex_state)
     {var ocaml_lex_state$0=ocaml_lex_state;
      for(;;)
       {var
         ocaml_lex_state$1=
          caml_call3(Lexing[17],ocaml_lex_tables,ocaml_lex_state$0,lexbuf);
        if(9 < ocaml_lex_state$1 >>> 0)
         {caml_call1(lexbuf[1],lexbuf);
          var ocaml_lex_state$0=ocaml_lex_state$1;
          continue}
        switch(ocaml_lex_state$1)
         {case 0:return 37;
          case 1:
           start_lex[1] = start_pos_of_lexbuf(lexbuf);
           var _F_=0;
           if(counter < 50)
            {var counter$1=counter + 1 | 0;
             return comments$0(counter$1,_F_,lexbuf)}
           return caml_trampoline_return(comments$0,[0,_F_,lexbuf]);
          case 2:
           reset_str(0);
           start_lex[1] = start_pos_of_lexbuf(lexbuf);
           var _G_=0;
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return string$0(counter$0,_G_,lexbuf)}
           return caml_trampoline_return(string$0,[0,_G_,lexbuf]);
          case 3:
           var p=caml_call1(Lexing[9],lexbuf);
           if(0 === (p[4] - p[3] | 0))
            {var _H_=0;
             if(counter < 50)
              {var counter$2=counter + 1 | 0;
               return directive$0(counter$2,_H_,lexbuf)}
             return caml_trampoline_return(directive$0,[0,_H_,lexbuf])}
           var _I_=caml_call1(Printf[4],_c_);
           throw [0,Lexer_error,lex_long_range(lexbuf),_I_];
          case 4:return create_token(lexbuf);
          case 5:
           return [1,
                   runtime.caml_int64_of_string(caml_call1(Lexing[5],lexbuf))];
          case 6:
           if(counter < 50)
            {var counter$3=counter + 1 | 0;return token$0(counter$3,lexbuf)}
           return caml_trampoline_return(token$0,[0,lexbuf]);
          case 7:
           newline(lexbuf);
           if(counter < 50)
            {var counter$4=counter + 1 | 0;return token$0(counter$4,lexbuf)}
           return caml_trampoline_return(token$0,[0,lexbuf]);
          case 8:return create_token(lexbuf);
          default:
           var c=caml_call2(Lexing[15],lexbuf,lexbuf[5]);
           return unexpected_char(lexbuf,c)}}}
    function directive$0(counter,state,lexbuf)
     {var _E_=24;
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return ocaml_lex_directive_rec$0(counter$0,state,lexbuf,_E_)}
      return caml_trampoline_return
              (ocaml_lex_directive_rec$0,[0,state,lexbuf,_E_])}
    function ocaml_lex_directive_rec$0(counter,state,lexbuf,ocaml_lex_state)
     {var ocaml_lex_state$0=ocaml_lex_state;
      for(;;)
       {var
         ocaml_lex_state$1=
          caml_call3(Lexing[17],ocaml_lex_tables,ocaml_lex_state$0,lexbuf);
        if(4 < ocaml_lex_state$1 >>> 0)
         {caml_call1(lexbuf[1],lexbuf);
          var ocaml_lex_state$0=ocaml_lex_state$1;
          continue}
        switch(ocaml_lex_state$1)
         {case 0:
           if(counter < 50)
            {var counter$1=counter + 1 | 0;
             return directive$0(counter$1,state,lexbuf)}
           return caml_trampoline_return(directive$0,[0,state,lexbuf]);
          case 1:
           if(0 === state)
            {lnum[1] = caml_int_of_string(caml_call1(Lexing[5],lexbuf));
             var _w_=1;
             if(counter < 50)
              {var counter$2=counter + 1 | 0;
               return directive$0(counter$2,_w_,lexbuf)}
             return caml_trampoline_return(directive$0,[0,_w_,lexbuf])}
           if(2 === state)
            {var _x_=3;
             if(counter < 50)
              {var counter$3=counter + 1 | 0;
               return directive$0(counter$3,_x_,lexbuf)}
             return caml_trampoline_return(directive$0,[0,_x_,lexbuf])}
           var _y_=caml_call1(Printf[4],_d_);
           throw [0,Lexer_error,lex_long_range(lexbuf),_y_];
          case 2:
           if(1 === state)
            {reset_str(0);
             start_lex[1] = start_pos_of_lexbuf(lexbuf);
             var _z_=1;
             if(counter < 50)
              {var counter$0=counter + 1 | 0;
               return string$0(counter$0,_z_,lexbuf)}
             return caml_trampoline_return(string$0,[0,_z_,lexbuf])}
           var _A_=caml_call1(Printf[4],_e_);
           throw [0,Lexer_error,lex_long_range(lexbuf),_A_];
          case 3:
           if(2 !== state)
            if(3 !== state)
             {var _C_=caml_call1(Printf[4],_f_);
              throw [0,Lexer_error,lex_long_range(lexbuf),_C_]}
           var _B_=lnum[1];
           reset_lexbuf(get_str(0),_B_,lexbuf);
           if(counter < 50)
            {var counter$4=counter + 1 | 0;return token$0(counter$4,lexbuf)}
           return caml_trampoline_return(token$0,[0,lexbuf]);
          default:
           var _D_=caml_call1(Printf[4],_g_);
           throw [0,Lexer_error,lex_long_range(lexbuf),_D_]}}}
    function comments$0(counter,level,lexbuf)
     {var _v_=31;
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return ocaml_lex_comments_rec$0(counter$0,level,lexbuf,_v_)}
      return caml_trampoline_return
              (ocaml_lex_comments_rec$0,[0,level,lexbuf,_v_])}
    function ocaml_lex_comments_rec$0(counter,level,lexbuf,ocaml_lex_state)
     {var ocaml_lex_state$0=ocaml_lex_state;
      for(;;)
       {var
         ocaml_lex_state$1=
          caml_call3(Lexing[17],ocaml_lex_tables,ocaml_lex_state$0,lexbuf);
        if(4 < ocaml_lex_state$1 >>> 0)
         {caml_call1(lexbuf[1],lexbuf);
          var ocaml_lex_state$0=ocaml_lex_state$1;
          continue}
        switch(ocaml_lex_state$1)
         {case 0:
           if(0 === level)
            {if(counter < 50)
              {var counter$4=counter + 1 | 0;return token$0(counter$4,lexbuf)}
             return caml_trampoline_return(token$0,[0,lexbuf])}
           var _s_=level - 1 | 0;
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return comments$0(counter$0,_s_,lexbuf)}
           return caml_trampoline_return(comments$0,[0,_s_,lexbuf]);
          case 1:
           var _t_=level + 1 | 0;
           if(counter < 50)
            {var counter$1=counter + 1 | 0;
             return comments$0(counter$1,_t_,lexbuf)}
           return caml_trampoline_return(comments$0,[0,_t_,lexbuf]);
          case 2:
           if(counter < 50)
            {var counter$2=counter + 1 | 0;
             return comments$0(counter$2,level,lexbuf)}
           return caml_trampoline_return(comments$0,[0,level,lexbuf]);
          case 3:
           newline(lexbuf);
           if(counter < 50)
            {var counter$3=counter + 1 | 0;
             return comments$0(counter$3,level,lexbuf)}
           return caml_trampoline_return(comments$0,[0,level,lexbuf]);
          default:
           var _u_=caml_call1(Printf[4],_h_);
           throw [0,Lexer_error,lex_long_range(lexbuf),_u_]}}}
    function string$0(counter,in_directive,lexbuf)
     {var _r_=39;
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return ocaml_lex_string_rec$0(counter$0,in_directive,lexbuf,_r_)}
      return caml_trampoline_return
              (ocaml_lex_string_rec$0,[0,in_directive,lexbuf,_r_])}
    function ocaml_lex_string_rec$0
     (counter,in_directive,lexbuf,ocaml_lex_state)
     {var ocaml_lex_state$0=ocaml_lex_state;
      for(;;)
       {var
         ocaml_lex_state$1=
          caml_call3(Lexing[17],ocaml_lex_tables,ocaml_lex_state$0,lexbuf);
        if(4 < ocaml_lex_state$1 >>> 0)
         {caml_call1(lexbuf[1],lexbuf);
          var ocaml_lex_state$0=ocaml_lex_state$1;
          continue}
        switch(ocaml_lex_state$1)
         {case 0:
           if(0 === in_directive)return [0,get_str(0)];
           var _p_=2;
           if(counter < 50)
            {var counter$3=counter + 1 | 0;
             return directive$0(counter$3,_p_,lexbuf)}
           return caml_trampoline_return(directive$0,[0,_p_,lexbuf]);
          case 1:
           add_str(escaped(lexbuf));
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return string$0(counter$0,in_directive,lexbuf)}
           return caml_trampoline_return(string$0,[0,in_directive,lexbuf]);
          case 2:
           add_str(10);
           newline(lexbuf);
           if(counter < 50)
            {var counter$1=counter + 1 | 0;
             return string$0(counter$1,in_directive,lexbuf)}
           return caml_trampoline_return(string$0,[0,in_directive,lexbuf]);
          case 3:
           var _q_=caml_call1(Printf[4],_i_);
           throw [0,Lexer_error,lex_long_range(lexbuf),_q_];
          default:
           add_str(caml_call2(Lexing[6],lexbuf,0));
           if(counter < 50)
            {var counter$2=counter + 1 | 0;
             return string$0(counter$2,in_directive,lexbuf)}
           return caml_trampoline_return(string$0,[0,in_directive,lexbuf])}}}
    function token(lexbuf){return caml_trampoline(token$0(0,lexbuf))}
    function ocaml_lex_token_rec(lexbuf,ocaml_lex_state)
     {return caml_trampoline(ocaml_lex_token_rec$0(0,lexbuf,ocaml_lex_state))}
    function directive(state,lexbuf)
     {return caml_trampoline(directive$0(0,state,lexbuf))}
    function ocaml_lex_directive_rec(state,lexbuf,ocaml_lex_state)
     {return caml_trampoline
              (ocaml_lex_directive_rec$0(0,state,lexbuf,ocaml_lex_state))}
    function comments(level,lexbuf)
     {return caml_trampoline(comments$0(0,level,lexbuf))}
    function ocaml_lex_comments_rec(level,lexbuf,ocaml_lex_state)
     {return caml_trampoline
              (ocaml_lex_comments_rec$0(0,level,lexbuf,ocaml_lex_state))}
    function string(in_directive,lexbuf)
     {return caml_trampoline(string$0(0,in_directive,lexbuf))}
    function ocaml_lex_string_rec(in_directive,lexbuf,ocaml_lex_state)
     {return caml_trampoline
              (ocaml_lex_string_rec$0(0,in_directive,lexbuf,ocaml_lex_state))}
    function ocaml_lex_escaped_rec(lexbuf,ocaml_lex_state)
     {var ocaml_lex_state$0=ocaml_lex_state;
      for(;;)
       {var
         ocaml_lex_state$1=
          caml_call3(Lexing[17],ocaml_lex_tables,ocaml_lex_state$0,lexbuf);
        if(6 < ocaml_lex_state$1 >>> 0)
         {caml_call1(lexbuf[1],lexbuf);
          var ocaml_lex_state$0=ocaml_lex_state$1;
          continue}
        switch(ocaml_lex_state$1)
         {case 0:return 10;
          case 1:return 9;
          case 2:return 92;
          case 3:return 34;
          case 4:return 39;
          case 5:
           var x=caml_int_of_string(caml_call1(Lexing[5],lexbuf));
           if(255 < x)
            {var
              _l_=caml_call1(Lexing[5],lexbuf),
              _m_=caml_call2(Printf[4],_j_,_l_);
             throw [0,Lexer_error,lex_long_range(lexbuf),_m_]}
           return caml_call1(Char[1],x);
          default:
           var
            _n_=caml_call1(Lexing[5],lexbuf),
            _o_=caml_call2(Printf[4],_k_,_n_);
           throw [0,Lexer_error,lex_long_range(lexbuf),_o_]}}}
    function escaped(lexbuf){return ocaml_lex_escaped_rec(lexbuf,45)}
    var
     Lexer=
      [0,
       Lexer_error,
       reset_lexbuf,
       newline,
       unexpected_char,
       reserved_words,
       symbol_table,
       create_token,
       string_buffer,
       string_end,
       start_lex,
       start_pos_of_lexbuf,
       lex_long_range,
       reset_str,
       add_str,
       get_str,
       lnum,
       ocaml_lex_tables,
       token,
       ocaml_lex_token_rec,
       directive,
       ocaml_lex_directive_rec,
       comments,
       ocaml_lex_comments_rec,
       string,
       ocaml_lex_string_rec,
       escaped,
       ocaml_lex_escaped_rec];
    runtime.caml_register_global(20,Lexer,"Lexer");
    return}
  (function(){return this}()));


//# 1 ".server.eobjs/byte/server.cmo.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_equal=runtime.caml_equal,
     caml_new_string=runtime.caml_new_string,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    var
     global_data=runtime.caml_get_global_data(),
     cst=caml_new_string("\n"),
     Range=global_data.Range,
     Lexer=global_data.Lexer,
     Parser=global_data.Parser,
     Array=global_data.Array,
     List=global_data.List,
     Printf=global_data.Printf,
     Lexing=global_data.Lexing,
     Pervasives=global_data.Pervasives,
     End_of_file=global_data.End_of_file,
     String=global_data.String,
     Js_of_ocaml_Js=global_data.Js_of_ocaml__Js,
     _b_=
      [0,
       [11,caml_new_string("Parse error at: "),[2,0,[12,10,0]]],
       caml_new_string("Parse error at: %s\n")],
     _a_=
      [0,
       [11,
        caml_new_string("FILENAME "),
        [2,0,[11,caml_new_string(" \n\n\n"),0]]],
       caml_new_string("FILENAME %s \n\n\n")],
     I=0;
    function read_file(filename)
     {caml_call2(Printf[2],_a_,filename);
      var lines=[0,0],channel=caml_call1(Pervasives[67],filename);
      try
       {for(;;)
         {var _x_=lines[1];
          lines[1] = [0,caml_call1(Pervasives[71],channel),_x_];
          continue}}
      catch(_y_)
       {_y_ = caml_wrap_exception(_y_);
        if(_y_ === End_of_file)
         {caml_call1(Pervasives[81],channel);
          var _w_=caml_call1(List[9],lines[1]);
          return caml_call2(String[7],cst,_w_)}
        throw _y_}}
    function succeed(param){return 0}
    function recover_from_error(supplier)
     {for(;;)
       {var _u_=caml_call1(supplier,0),_v_=_u_[1];
        if(typeof _v_ === "number")
         {if(11 === _v_)return 0;
          if(26 === _v_)
           {var depth=1;
            for(;;)
             {if(0 === depth)return 0;
              var _s_=caml_call1(supplier,0),_t_=_s_[1];
              if(typeof _t_ === "number")
               {if(16 === _t_)
                 {var depth$0=depth - 1 | 0,depth=depth$0;continue}
                if(26 === _t_)
                 {var depth$1=depth + 1 | 0,depth=depth$1;continue}}
              var stop=_s_[3],start=_s_[2];
              if(caml_equal(start,stop))return 0;
              continue}}}
        var stop$0=_u_[3],start$0=_u_[2];
        if(caml_equal(start$0,stop$0))return 0;
        continue}}
    function fail(filename,lexbuf,backed_up,param)
     {var
       match=caml_call1(Range[14],lexbuf),
       b=match[3],
       a=match[2],
       supplier=caml_call2(Parser[5][3],Lexer[18],lexbuf);
      recover_from_error(supplier);
      function _p_(_q_,_r_){return fail(filename,lexbuf,_q_,_r_)}
      return [0,
              [0,filename,a,b],
              caml_call4(Parser[5][6],succeed,_p_,supplier,backed_up)]}
    function find_errors(filename)
     {var
       _l_=read_file(filename),
       lexbuf=caml_call1(Lexing[3],_l_),
       result=caml_call1(Parser[6][2],lexbuf[12]),
       supplier=caml_call2(Parser[5][3],Lexer[18],lexbuf);
      function _m_(_n_,_o_){return fail(filename,lexbuf,_n_,_o_)}
      return caml_call4(Parser[5][6],succeed,_m_,supplier,result)}
    function filter_map(l)
     {var l$0=l;
      for(;;)
       {if(l$0)
         {var _k_=l$0[1];
          if(_k_){var tl=l$0[2],x=_k_[1];return [0,x,filter_map(tl)]}
          var l$1=l$0[2],l$0=l$1;
          continue}
        return 0}}
    function print_error(loc)
     {var _j_=caml_call1(Range[9],loc);return caml_call2(Printf[2],_b_,_j_)}
    function js_of_range(loc)
     {function js_of_pos(pos)
       {var char$0=pos[2],line=pos[1];return {"line":line,"char":char$0}}
      var
       finish=loc[3],
       start=loc[2],
       file=loc[1],
       _h_=js_of_pos(finish),
       _i_=js_of_pos(start);
      return {"file":file.toString(),"start":_i_,"finish":_h_}}
    function main(files)
     {var
       _c_=caml_call1(Array[11],runtime.caml_js_to_array(files)),
       _d_=caml_call2(List[17],runtime.caml_js_to_string,_c_),
       _e_=caml_call2(List[17],find_errors,_d_),
       _f_=caml_call1(List[14],_e_),
       _g_=caml_call2(List[17],js_of_range,_f_);
      return runtime.caml_js_from_array(caml_call1(Array[12],_g_))}
    function t6(param,files){return main(files)}
    caml_call1
     (Js_of_ocaml_Js[49],{"compile":runtime.caml_js_wrap_meth_callback(t6)});
    var
     Server=
      [0,
       I,
       read_file,
       succeed,
       recover_from_error,
       fail,
       find_errors,
       filter_map,
       print_error,
       js_of_range,
       main];
    runtime.caml_register_global(31,Server,"Server");
    return}
  (function(){return this}()));


//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJzZXJ2ZXIuYmMuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiY2FtbF9pbnQ2NF9pc196ZXJvIiwieCIsImNhbWxfc3RyX3JlcGVhdCIsIm4iLCJzIiwiciIsImwiLCJjYW1sX2ludDY0X29mX2ludDMyIiwiY2FtbF9vYmpfZHVwIiwiYSIsIkFycmF5IiwiaSIsImNhbWxfaW50NjRfc3ViIiwieSIsInoxIiwiejIiLCJ6MyIsImNhbWxfaW50NjRfdWNvbXBhcmUiLCJjYW1sX2ludDY0X2xzbDEiLCJjYW1sX2ludDY0X2xzcjEiLCJjYW1sX2ludDY0X3VkaXZtb2QiLCJvZmZzZXQiLCJtb2R1bHVzIiwiZGl2aXNvciIsInF1b3RpZW50IiwiY2FtbF9pbnQ2NF90b19pbnQzMiIsImNhbWxfaW50NjRfaXNfbmVnYXRpdmUiLCJjYW1sX2ludDY0X25lZyIsInkxIiwieTIiLCJ5MyIsInJhd19hcnJheV9zdWIiLCJiIiwiaiIsImNhbWxfc3ViYXJyYXlfdG9fc3RyaW5nIiwibGVuIiwiZiIsIlN0cmluZyIsIm51bGwiLCJNYXRoIiwiY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyIsImNhbWxfanNieXRlc19vZl9zdHJpbmciLCJjYW1sX3JhaXNlX3dpdGhfYXJnIiwidGFnIiwiYXJnIiwiY2FtbF9pc19hc2NpaSIsImNhbWxfdXRmMTZfb2ZfdXRmOCIsInQiLCJjIiwiYzEiLCJjMiIsInYiLCJjYW1sX3RvX2pzX3N0cmluZyIsIk1sQnl0ZXMiLCJjb250ZW50cyIsImxlbmd0aCIsInRoaXMiLCJjb250ZW50IiwiY2FtbF9uZXdfc3RyaW5nIiwiY2FtbF9yYWlzZV93aXRoX3N0cmluZyIsIm1zZyIsImNhbWxfZ2xvYmFsX2RhdGEiLCJjYW1sX2ludmFsaWRfYXJndW1lbnQiLCJjYW1sX3BhcnNlX2Zvcm1hdCIsImZtdCIsImNhbWxfZmluaXNoX2Zvcm1hdHRpbmciLCJyYXdidWZmZXIiLCJidWZmZXIiLCJjYW1sX2ludDY0X2Zvcm1hdCIsIndiYXNlIiwiY3Z0YmwiLCJwIiwiY2FtbF9leHBtMV9mbG9hdCIsInoiLCJqb29fZ2xvYmFsX29iamVjdCIsImNhbWxfY3VycmVudF9kaXIiLCJjYW1sX21ha2VfcGF0aCIsIm5hbWUiLCJjb21wIiwibmNvbXAiLCJjYW1sX3JhaXNlX3N5c19lcnJvciIsImNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlIiwiY2FtbF9zdHJpbmdfb2ZfYXJyYXkiLCJjYW1sX3N0cmluZ19ib3VuZF9lcnJvciIsImNhbWxfYnl0ZXNfdW5zYWZlX2dldCIsImNhbWxfYnl0ZXNfZ2V0IiwiY2FtbF9jcmVhdGVfYnl0ZXMiLCJjYW1sX21sX2J5dGVzX2xlbmd0aCIsImNhbWxfY29udmVydF9zdHJpbmdfdG9fYXJyYXkiLCJjYW1sX2JsaXRfYnl0ZXMiLCJzMSIsImkxIiwiczIiLCJpMiIsIk1sRmlsZSIsIk1sRmFrZUZpbGUiLCJvbGQiLCJidWYiLCJwb3MiLCJjbGVuIiwibmV3X3N0ciIsIm9sZF9kYXRhIiwiTWxGYWtlRGV2aWNlIiwicm9vdCIsInJlcyIsIm5hbWVfc2xhc2giLCJSZWdFeHAiLCJzZWVuIiwibSIsIm9rIiwiZmlsZSIsIm1sc3RyaW5nIiwiY2FtbF9hcnJheV9vZl9zdHJpbmciLCJjYW1sX2J5dGVzX3Vuc2FmZV9zZXQiLCJjYW1sX2J5dGVzX3NldCIsIkJ1ZmZlciIsIk1sTm9kZUZpbGUiLCJmZCIsInJlcXVpcmUiLCJidWZfb2Zmc2V0IiwiTWxOb2RlRGV2aWNlIiwiY29uc3RzIiwia2V5IiwibyIsImNhbWxfcm9vdCIsImZzX25vZGVfc3VwcG9ydGVkIiwianNvb19tb3VudF9wb2ludCIsInJlc29sdmVfZnNfZGV2aWNlIiwicGF0aCIsImNhbWxfc3lzX2lzX2RpcmVjdG9yeSIsImNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQiLCJjYW1sX3V0Zjhfb2ZfdXRmMTYiLCJkIiwiY2FtbF9qc190b19zdHJpbmciLCJjYW1sX3JhaXNlX2NvbnN0YW50IiwiY2FtbF9yYWlzZV9ub3RfZm91bmQiLCJjYW1sX3N5c19nZXRlbnYiLCJnIiwidW5kZWZpbmVkIiwic2hpZnRfcmlnaHRfbmF0IiwibmF0MSIsIm9mczEiLCJsZW4xIiwibmF0MiIsIm9mczIiLCJuYml0cyIsIndyYXAiLCJNbE9iamVjdFRhYmxlIiwiTmFpdmVMb29rdXAiLCJvYmpzIiwiY2FtbF9mYWlsd2l0aCIsImNhbWxfc3lzX3JlbmFtZSIsIm9fcm9vdCIsIm5fcm9vdCIsImNhbWxfbG9nMTBfZmxvYXQiLCJjYW1sX3J1bnRpbWVfd2FybmluZ3MiLCJjYW1sX21sX2VuYWJsZV9ydW50aW1lX3dhcm5pbmdzIiwiYm9vbCIsImNhbWxfY2xhc3NpZnlfZmxvYXQiLCJpc0Zpbml0ZSIsImlzTmFOIiwiY2FtbF9tbF9yZWZpbGxfaW5wdXQiLCJjaGFuIiwic3RyIiwic3RyX2xlbiIsImNhbWxfbWxfY2hhbm5lbHMiLCJjYW1sX21sX21heV9yZWZpbGxfaW5wdXQiLCJjaGFuaWQiLCJjYW1sX2FycmF5X2JvdW5kX2Vycm9yIiwiY2FtbF9tbF9pbnB1dF9zY2FuX2xpbmUiLCJjYW1sX2djX21pbm9yIiwiY2FtbF9pbnQ2NF9vZl9ieXRlcyIsImNhbWxfYmFfdWludDhfZ2V0NjQiLCJiYSIsImkwIiwib2ZzIiwiYjEiLCJiMiIsImIzIiwiYjQiLCJiNSIsImI2IiwiYjciLCJiOCIsImNhbWxfaW50NjRfdG9fYnl0ZXMiLCJjYW1sX2ludDY0X21hcnNoYWwiLCJ3cml0ZXIiLCJzaXplcyIsImNhbWxfYmFfbnVtX2RpbXMiLCJjYW1sX211bCIsImNhbWxfaGFzaF9taXhfaW50IiwiaCIsImNhbWxfaGFzaF9taXhfc3RyaW5nX2FyciIsInciLCJjYW1sX3JldHVybl9leG5fY29uc3RhbnQiLCJjYW1sX25hbWVkX3ZhbHVlcyIsImNhbWxfbmFtZWRfdmFsdWUiLCJubSIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJlIiwiY2FtbF9jcmVhdGVfZmlsZSIsImNhbWxfZnNfaW5pdCIsInRtcCIsImNhbWxfbGlzdF9vZl9qc19hcnJheSIsImNhbWxfc2V0X3BhcnNlcl90cmFjZSIsInVuaXhfZ2V0dGltZW9mZGF5IiwiRGF0ZSIsIm51bV9kaWdpdHNfbmF0IiwibmF0IiwiY2FtbF9oYXNoX25hdCIsInJhd19hcnJheV9hcHBlbmRfb25lIiwiY2FtbF9jYWxsX2dlbiIsImFyZ3MiLCJhcmdzTGVuIiwiY2FtbF9qc193cmFwX2NhbGxiYWNrIiwiYXJndW1lbnRzIiwiY2FtbF9qc193cmFwX2NhbGxiYWNrX2FyZ3VtZW50cyIsImNhbWxfc3lzX2NoZGlyIiwiZGlyIiwiY2FtbF9nY19jb3VudGVycyIsImNhbWxfaGFzaF9taXhfc3RyaW5nX3N0ciIsImxvZzJfb2siLCJqc29vX2Zsb29yX2xvZzIiLCJJbmZpbml0eSIsImNhbWxfaW50MzJfYml0c19vZl9mbG9hdCIsImZsb2F0MzJhIiwiaW50MzJhIiwiY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkiLCJsbyIsIm1pIiwiaGkiLCJjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQiLCJzaWduIiwiZXhwIiwiayIsInIzIiwicjIiLCJyMSIsImNhbWxfYmFfc2VyaWFsaXplIiwic3oiLCJjb21wbGV4IiwiY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudCIsImtpbmQiLCJjYW1sX2JhX2NyZWF0ZV9idWZmZXIiLCJzaXplIiwidmlldyIsImRhdGEiLCJjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMiLCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMiLCJOYU4iLCJjYW1sX2JhX2dldF9zaXplIiwiZGltcyIsIm5fZGltcyIsImNhbWxfaW50NjRfY3JlYXRlX2xvX2hpIiwiY2FtbF9pbnQ2NF9oaTMyIiwiY2FtbF9pbnQ2NF9sbzMyIiwiTWxfQmlnYXJyYXkiLCJsYXlvdXQiLCJpbSIsInJlIiwidG90YWwiLCJrMSIsImsyIiwiTWxfQmlnYXJyYXlfY18xXzEiLCJjYW1sX2JhX2NyZWF0ZV91bnNhZmUiLCJzaXplX3Blcl9lbGVtZW50IiwiY2FtbF9iYV9kZXNlcmlhbGl6ZSIsInJlYWRlciIsIm51bV9kaW1zIiwic2l4dHkiLCJpbnQ2NCIsImNhbWxfYmFfY29tcGFyZSIsImNhbWxfaGFzaF9taXhfaW50NjQiLCJjYW1sX2hhc2hfbWl4X2Zsb2F0IiwidjAiLCJjYW1sX2JhX2hhc2giLCJudW1fZWx0cyIsImNhbWxfaW50MzJfdW5tYXJzaGFsIiwiY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsIiwiY2FtbF9pbnQ2NF91bm1hcnNoYWwiLCJjYW1sX2ludDY0X2NvbXBhcmUiLCJ4MyIsImNhbWxfaW50NjRfaGFzaCIsImNhbWxfY3VzdG9tX29wcyIsImNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbSIsImNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbSIsIm51bSIsImN1c3RvbSIsInN3YXAiLCJjYW1sX2NvbXBhcmVfdmFsX3RhZyIsIk51bWJlciIsImNhbWxfaW50X2NvbXBhcmUiLCJjYW1sX3N0cmluZ19jb21wYXJlIiwiY2FtbF9jb21wYXJlX3ZhbCIsInN0YWNrIiwidGFnX2EiLCJ0YWdfYiIsImNhbWxfZ3JlYXRlcnRoYW4iLCJkaXZfaGVscGVyIiwiZGl2X2RpZ2l0X25hdCIsIm5hdHEiLCJvZnNxIiwibmF0ciIsIm9mc3IiLCJyZW0iLCJudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXQiLCJzaGlmdF9sZWZ0X25hdCIsIk1sTmF0IiwiY3JlYXRlX25hdCIsImFyciIsInNldF90b196ZXJvX25hdCIsImluY3JfbmF0IiwiY2FycnlfaW4iLCJjYXJyeSIsImFkZF9uYXQiLCJsZW4yIiwibmF0X29mX2FycmF5IiwibXVsdF9kaWdpdF9uYXQiLCJuYXQzIiwib2ZzMyIsIngxIiwieDIiLCJkZWNyX25hdCIsImJvcnJvdyIsInN1Yl9uYXQiLCJjb21wYXJlX25hdCIsImRpdl9uYXQiLCJxdW8iLCJjYW1sX2JhX2JsaXQiLCJzcmMiLCJkc3QiLCJpc19kaWdpdF9pbnQiLCJjYW1sX3JhaXNlX3plcm9fZGl2aWRlIiwiY2FtbF9pbnQ2NF9kaXYiLCJxIiwiY2FtbF9qc19odG1sX2VudGl0aWVzIiwiZW50aXR5IiwidGVtcCIsImRvY3VtZW50IiwiY2FtbF9zdHJpbmdfdW5zYWZlX3NldCIsImNhbWxfaW50NjRfb2Zmc2V0IiwiY2FtbF9pbnQ2NF9vZl9mbG9hdCIsImNhbWxfbWxfY2hhbm5lbF9zaXplXzY0IiwiY2FtbF9iYV9zZXRfMiIsImNhbWxfYXJndiIsIm1haW4iLCJhcmd2IiwiYXJnczIiLCJjYW1sX2V4ZWN1dGFibGVfbmFtZSIsImNhbWxfYnl0ZXNfY29tcGFyZSIsImNhbWxfanNfZXZhbF9zdHJpbmciLCJldmFsIiwiY2FtbF9DYW1saW50ZXJuYWxNb2RfaW5pdF9tb2QiLCJsb2MiLCJzaGFwZSIsInVuZGVmX21vZHVsZSIsIl94IiwibG9vcCIsInN0cnVjdCIsImlkeCIsInNlcmlhbGl6ZV9uYXQiLCJjYW1sX21lbXByb2Zfc2V0IiwiX2NvbnRyb2wiLCJjYW1sX3N5c19leGl0IiwiY29kZSIsImNhbWxfanNfZnJvbV9hcnJheSIsImNhbWxfYmFfcmVzaGFwZSIsInZpbmQiLCJuZXdfZGltIiwiY2FtbF9vb19sYXN0X2lkIiwiY2FtbF9zZXRfb29faWQiLCJjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYSIsInN0cjEiLCJwb3MxIiwiYmEyIiwicG9zMiIsInNsaWNlIiwiY2FtbF9nZXRfZ2xvYmFsX2RhdGEiLCJjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkIiwiY2FtbF9iYV91aW50OF9nZXQxNiIsImNhbWxfY29tcGFyZSIsImNhbWxfZnJlc2hfb29faWQiLCJjYW1sX2ludDY0X3RvX2Zsb2F0IiwiY2FtbF9iYV9nZXRfMSIsImNhbWxfYmlnc3RyaW5nX21lbWNtcCIsImNhbWxfcmF3X2JhY2t0cmFjZV9sZW5ndGgiLCJjYW1sX2JhX3VpbnQ4X2dldDMyIiwiY2FtbF9vYmpfYmxvY2siLCJiaWdzdHJpbmdfdG9fYXJyYXlfYnVmZmVyIiwiYnMiLCJseG9yX2RpZ2l0X25hdCIsImNhbWxfZmluYWxfcmVsZWFzZSIsInJhd19hcnJheV9jb25zIiwiY2FtbF9qc190b19hcnJheSIsImNhbWxfYnl0ZXNfc2V0NjQiLCJpNjQiLCJjYW1sX2J5dGVzX3NldDE2IiwiaTE2IiwiY2FtbF9zdHJpbmdfc2V0MTYiLCJjYW1sX2ludDY0X2Jzd2FwIiwiY2FtbF9maWxsX2J5dGVzIiwiY2FtbF9maWxsX3N0cmluZyIsImNhbWxfZ2NfbWFqb3IiLCJjYW1sX2xleF9hcnJheSIsImNhbWxfbGV4X2VuZ2luZSIsInRibCIsInN0YXJ0X3N0YXRlIiwibGV4YnVmIiwibGV4X2J1ZmZlciIsImxleF9idWZmZXJfbGVuIiwibGV4X3N0YXJ0X3BvcyIsImxleF9jdXJyX3BvcyIsImxleF9sYXN0X3BvcyIsImxleF9sYXN0X2FjdGlvbiIsImxleF9lb2ZfcmVhY2hlZCIsImxleF9iYXNlIiwibGV4X2JhY2t0cmsiLCJsZXhfZGVmYXVsdCIsImxleF90cmFucyIsImxleF9jaGVjayIsInN0YXRlIiwiYmFzZSIsImJhY2t0cmsiLCJjYW1sX3N5c19maWxlX2V4aXN0cyIsImNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3QiLCJjYW1sX2FycmF5X3N1YiIsImEyIiwiY2FtbF9ieXRlc19lcXVhbCIsImNhbWxfc3lzX2NvbnN0X29zdHlwZV9jeWd3aW4iLCJjYW1sX2Nvc2hfZmxvYXQiLCJjYW1sX2VwaGVfa2V5X29mZnNldCIsImNhbWxfd2Vha19jaGVjayIsImNhbWxfZXBoZV9jaGVja19rZXkiLCJjYW1sX2hhc2hfbWl4X2ZpbmFsIiwiY2FtbF9sZXhfcnVuX21lbSIsIm1lbSIsImN1cnJfcG9zIiwiY2FtbF9sZXhfcnVuX3RhZyIsImNhbWxfbmV3X2xleF9lbmdpbmUiLCJsZXhfbWVtIiwibGV4X2Jhc2VfY29kZSIsImxleF9iYWNrdHJrX2NvZGUiLCJsZXhfZGVmYXVsdF9jb2RlIiwibGV4X3RyYW5zX2NvZGUiLCJsZXhfY2hlY2tfY29kZSIsImxleF9jb2RlIiwicGNfb2ZmIiwicHN0YXRlIiwiYmFzZV9jb2RlIiwiY2FtbF9iYV91aW50OF9zZXQ2NCIsImNhbWxfc3lzX2V4ZWN1dGFibGVfbmFtZSIsImNhbWxfbGVzc2VxdWFsIiwiY2FtbF9tbF9mbHVzaCIsIm91dHB1dCIsImNhbWxfbWxfc2Vla19vdXRfNjQiLCJjb21wYXJlX25hdF9yZWFsIiwiY2FtbF9nY19zZXQiLCJjYW1sX2pzX2dldCIsImNhbWxfZ2NfY29tcGFjdGlvbiIsImNhbWxfd2Vha19nZXQiLCJjYW1sX2VwaGVfZ2V0X2tleSIsIndpbl9jbGVhbnVwIiwiY2FtbF9zeXNfY2xvc2UiLCJjYW1sX21sX2Nsb3NlX2NoYW5uZWwiLCJjYW1sX2V4bl93aXRoX2pzX2JhY2t0cmFjZSIsImV4biIsImZvcmNlIiwiY2FtbF9zeXNfaXNhdHR5IiwiX2NoYW4iLCJpc19kaWdpdF96ZXJvIiwidW5peF9pbmV0X2FkZHJfb2Zfc3RyaW5nIiwiY2FtbF9qc19zZXQiLCJjYW1sX2FycmF5X2dldCIsImFycmF5IiwiaW5kZXgiLCJjYW1sX3NwYWNldGltZV9vbmx5X3dvcmtzX2Zvcl9uYXRpdmVfY29kZSIsImNhbWxfbWxfc2Vla19pbl82NCIsImNhbWxfbm90ZXF1YWwiLCJjYW1sX2ludDY0X3NoaWZ0X2xlZnQiLCJjYW1sX3N5c19jb25zdF9pbnRfc2l6ZSIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrIiwiY2FtbF9pc19qcyIsImNhbWxfYmFfZGltIiwiY2FtbF9iYV9kaW1fMSIsInVuaXhfbG9jYWx0aW1lIiwiZF9udW0iLCJqYW51YXJ5Zmlyc3QiLCJkb3kiLCJqYW4iLCJqdWwiLCJzdGRUaW1lem9uZU9mZnNldCIsImNhbWxfanNfbWV0aF9jYWxsIiwiY2FtbF93ZWFrX2NyZWF0ZSIsImNhbWxfZXBoZV9jcmVhdGUiLCJjYW1sX2pzX3RvX2J5dGVfc3RyaW5nIiwidW5peF9ta3RpbWUiLCJ0bSIsInRtMiIsImNhbWxfdHJhbXBvbGluZSIsImNhbWxfYnl0ZXNfZ2V0NjQiLCJjYW1sX3dlYWtfc2V0IiwiY2FtbF9zeXNfcmVtb3ZlIiwiY2FtbF9zdHJpbmdfZ2V0MzIiLCJjYW1sX2h5cG90X2Zsb2F0IiwiY2FtbF9qc19jYWxsIiwiY2FtbF9zeXNfY29uc3RfbWF4X3dvc2l6ZSIsImNhbWxfZXBoZV91bnNldF9rZXkiLCJjYW1sX2J5dGVzX2xlc3N0aGFuIiwiY2FtbF9nY19xdWlja19zdGF0IiwiY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSIsImNhbWxfbWxfaW5wdXRfaW50IiwiY2FtbF9hcnJheV9ibGl0IiwiYTEiLCJudGhfZGlnaXRfbmF0IiwiY2FtbF9mbG9hdF9vZl9zdHJpbmciLCJtMyIsIm1hbnRpc3NhIiwicGFyc2VJbnQiLCJleHBvbmVudCIsImNhbWxfc3lzX2dldGN3ZCIsImNhbWxfc3lzX2NvbnN0X2JpZ19lbmRpYW4iLCJjYW1sX2xpc3RfdG9fanNfYXJyYXkiLCJjYW1sX2xlZ2FjeV9jdXN0b21fY29kZSIsImNhbWxfbWxfc3RyaW5nX2xlbmd0aCIsImNhbWxfb3V0cHV0X3ZhbCIsIldyaXRlciIsInZhbHVlIiwiZmxhZ3MiLCJub19zaGFyaW5nIiwiY2xvc3VyZXMiLCJpbnRlcm5fb2JqX3RhYmxlIiwibWVtbyIsImV4aXN0aW5nX29mZnNldCIsImV4dGVybl9yZWMiLCJvcHMiLCJzel8zMl82NCIsImhlYWRlcl9wb3MiLCJvbGRfcG9zIiwidHlwZV9vZl92IiwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nIiwiY2FtbF9yYWlzZV9ub3RfYV9kaXIiLCJjYW1sX3N5c19zeXN0ZW1fY29tbWFuZCIsImNtZCIsImNhbWxfanNfZXJyb3Jfb2ZfZXhjZXB0aW9uIiwiZGVzZXJpYWxpemVfbmF0IiwiaW5pdGlhbGl6ZV9uYXQiLCJqc19wcmludF9zdGRvdXQiLCJjYW1sX2NvcHlzaWduX2Zsb2F0IiwiY2FtbF9iYV9zZXRfZ2VuZXJpYyIsImNhbWxfZXBoZV9zZXRfa2V5IiwiY2FtbF9zdHJpbmdfbGVzc2VxdWFsIiwiY2FtbF9zdHJpbmdfZ3JlYXRlcmVxdWFsIiwiY2FtbF9pbnQ2NF9hZGQiLCJjYW1sX25leHRhZnRlcl9mbG9hdCIsImJpdHMiLCJvbmUiLCJjYW1sX21sX3Bvc19pbiIsImNhbWxfaW50NjRfYW5kIiwiY2FtbF9zeXNfY29uc3Rfd29yZF9zaXplIiwiY2FtbF9zdGRfb3V0cHV0Iiwic2xlbiIsImpzX3ByaW50X3N0ZGVyciIsImNhbWxfc3lzX29wZW5faW50ZXJuYWwiLCJpbmZvIiwiY2FtbF9zeXNfb3BlbiIsIl9wZXJtcyIsIk1sQnl0ZXNSZWFkZXIiLCJjYW1sX2Zsb2F0X29mX2J5dGVzIiwiY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlciIsIl9tYWdpYyIsIl9ibG9ja19sZW4iLCJudW1fb2JqZWN0cyIsIl9zaXplXzMyIiwiX3NpemVfNjQiLCJvYmpfY291bnRlciIsImludGVybl9yZWMiLCJoZWFkZXIiLCJleHBlY3RlZF9zaXplIiwiY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzIiwiY2FtbF9qc19mcm9tX3N0cmluZyIsImNhbWxfYmFfc3ViIiwiY2hhbmdlZF9kaW0iLCJtdWwiLCJuZXdfZGltcyIsIm5ld19kYXRhIiwiY2FtbF9nY19mdWxsX21ham9yIiwiY2FtbF9ieXRlc19zZXQzMiIsImkzMiIsImNhbWxfaW50NjRfaXNfbWludXNfb25lIiwiY2FtbF9iYV91aW50OF9zZXQzMiIsImNhbWxfc3lzX2NvbnN0X29zdHlwZV91bml4IiwiY2FtbF9zaWduYml0X2Zsb2F0IiwiY2FtbF9tbF9zZWVrX291dCIsImNhbWxfcmVzdG9yZV9yYXdfYmFja3RyYWNlIiwiYnQiLCJjYW1sX2pzX3R5cGVvZiIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3Vuc2FmZSIsImNhbWxfYmFfZGltXzMiLCJjYW1sX2VwaGVfZGF0YV9vZmZzZXQiLCJjYW1sX2VwaGVfY2hlY2tfZGF0YSIsImNhbWxfYnl0ZXNfZ2V0MTYiLCJjYW1sX29ial9tYWtlX2ZvcndhcmQiLCJjYW1sX2pzX2Zyb21fYm9vbCIsImNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZSIsImNhbWxfY3JlYXRlX3N0cmluZyIsImNhbWxfbWQ1X3N0cmluZyIsImFkZCIsInh4IiwiZmYiLCJnZyIsImhoIiwiaWkiLCJtZDUiLCJjYW1sX21kNV9jaGFuIiwiY2hhbl9sZW4iLCJjYW1sX3dlYWtfZ2V0X2NvcHkiLCJjYW1sX21sX291dHB1dF9ieXRlcyIsInN0cmluZyIsImpzc3RyaW5nIiwiaWQiLCJjYW1sX21sX291dHB1dCIsImNhbWxfZXBoZV9nZXRfZGF0YSIsImNhbWxfdHJhbXBvbGluZV9yZXR1cm4iLCJjYW1sX2FycmF5X2FwcGVuZCIsImwxIiwibDIiLCJjYW1sX3N0cmluZ19vZl9ieXRlcyIsImNhbWxfbWxfc2V0X2NoYW5uZWxfcmVmaWxsIiwiY2FtbF9qc19leHByIiwiY2FtbF9pbnQ2NF9tdWwiLCJjYW1sX21sX3J1bnRpbWVfd2FybmluZ3NfZW5hYmxlZCIsIl91bml0IiwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnl0ZXMiLCJjYW1sX2hhc2hfdW5pdl9wYXJhbSIsImNvdW50IiwibGltaXQiLCJvYmoiLCJoYXNoX2FjY3UiLCJoYXNoX2F1eCIsImNhbWxfc3RyaW5nX2VxdWFsIiwicmF3X2FycmF5X2NvcHkiLCJjYW1sX291dHB1dF92YWx1ZV90b19idWZmZXIiLCJjYW1sX3B1cmVfanNfZXhwciIsImNhbWxfYmxpdF9zdHJpbmciLCJibGl0X25hdCIsImNhbWxfaW50NjRfdWx0IiwiY2FtbF9pbnQ2NF94b3IiLCJjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2J5dGVzIiwiYmExIiwiYnl0ZXMyIiwiY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZSIsImNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSIsImNhbWxfcGFyc2VfZGlnaXQiLCJjYW1sX2ludDY0X29mX3N0cmluZyIsImJhc2U2NCIsInRocmVzaG9sZCIsImNhbWxfbWFrZV92ZWN0IiwiaW5pdCIsImNhbWxfYmxpdF9zdHJpbmdfdG9fYmlnc3RyaW5nIiwiY2FtbF9tbF9zZWVrX2luIiwiY2FtbF9zeXNfcmVhZF9kaXJlY3RvcnkiLCJjYW1sX21sX291dHB1dF9jaGFyIiwiY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3dpbjMyIiwiY2FtbF9vYmpfaXNfYmxvY2siLCJjYW1sX21sX2lucHV0X2NoYXIiLCJjYW1sX2pzX3ZhciIsImNhbWxfdHJ1bmNfZmxvYXQiLCJjYW1sX2VwaGVfYmxpdF9kYXRhIiwiY2FtbF9pc19wcmludGFibGUiLCJjYW1sX2J5dGVzX2xlc3NlcXVhbCIsImNhbWxfZXF1YWwiLCJjYW1sX2ZpbmFsX3JlZ2lzdGVyX2NhbGxlZF93aXRob3V0X3ZhbHVlIiwiY2FtbF9zeXNfcmFuZG9tX3NlZWQiLCJub3ciLCJjYW1sX2JhX2dldF8yIiwid2luX2hhbmRsZV9mZCIsImNhbWxfYmFfdWludDhfc2V0MTYiLCJjYW1sX2pzX2RlbGV0ZSIsImNhbWxfaW50X29mX3N0cmluZyIsImNhbWxfbGlzdF9tb3VudF9wb2ludCIsInByZXYiLCJjYW1sX21hcnNoYWxfY29uc3RhbnRzIiwiY2FtbF9qc19lcXVhbHMiLCJiaWdzdHJpbmdfdG9fdHlwZWRfYXJyYXkiLCJjYW1sX2JhX3NsaWNlIiwibnVtX2luZHMiLCJzdWJfZGltcyIsImNhbWxfbWFyc2hhbF9kYXRhX3NpemUiLCJnZXQzMiIsImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmciLCJjYW1sX2lucHV0X3ZhbHVlIiwiY2FtbF9iYV9raW5kIiwiY2FtbF9qc19mdW5fY2FsbCIsImNhbWxfanNfcHVyZV9leHByIiwiY29tcGFyZV9kaWdpdHNfbmF0IiwiY2FtbF9tbF9pbnB1dCIsImNhbWxfaGFzaF9taXhfYmlnc3RyaW5nIiwiY2FtbF9yZWNvcmRfYmFja3RyYWNlIiwidW5peF9nbXRpbWUiLCJjYW1sX3N5c19jb25zdF9iYWNrZW5kX3R5cGUiLCJjYW1sX3N5c19nZXRfY29uZmlnIiwidW5peF90aW1lIiwiY2FtbF9tbF9vdXRfY2hhbm5lbHNfbGlzdCIsImJpZ3N0cmluZ19vZl9hcnJheV9idWZmZXIiLCJhYiIsInRhIiwiY2FtbF9tb2QiLCJjYW1sX2JhX2luaXQiLCJCaWdTdHJpbmdSZWFkZXIiLCJjYW1sX2JhX2dldF9nZW5lcmljIiwiY2FtbF9nZXRfZXhjZXB0aW9uX2JhY2t0cmFjZSIsImNhbWxfZm9ybWF0X2Zsb2F0IiwidG9GaXhlZCIsImRwIiwicHJlYyIsImNhbWxfbW91bnRfYXV0b2xvYWQiLCJjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhIiwiY2FtbF9ibGl0X2JpZ3N0cmluZ190b19iaWdzdHJpbmciLCJjYW1sX2RpdiIsImNhbWxfc3RyaW5nX2xlc3N0aGFuIiwiY2FtbF9zdHJpbmdfZ3JlYXRlcnRoYW4iLCJjYW1sX2VwaGVfZ2V0X2RhdGFfY29weSIsImNhbWxfc3lzX2dldF9hcmd2IiwiY2FtbF9qc190b19ib29sIiwiY2FtbF9lcGhlX2dldF9rZXlfY29weSIsImNhbWxfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3QiLCJjYW1sX2xlc3N0aGFuIiwiY2FtbF9yZWdpc3Rlcl9nbG9iYWwiLCJuYW1lX29wdCIsIm11bHRfbmF0IiwibGVuMyIsInNxdWFyZV9uYXQiLCJjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlIiwiY2FtbF9qc19mcm9tX2Zsb2F0IiwiY2FtbF9nY19zdGF0IiwiY2FtbF9zeXNfbW9kaWZ5X2FyZ3YiLCJjYW1sX21ldGhvZF9jYWNoZSIsImNhbWxfZ2V0X3B1YmxpY19tZXRob2QiLCJjYWNoZWlkIiwibWV0aHMiLCJsaSIsImNhbWxfanNfZ2V0X2NvbnNvbGUiLCJjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pbiIsImNoYW5uZWwiLCJiaWdzdHJpbmdfb2ZfdHlwZWRfYXJyYXkiLCJjYW1sX3JvdW5kX2Zsb2F0IiwiY2FtbF9vanNfbmV3X2FyciIsIkYiLCJjb21wbGVtZW50X25hdCIsImNhbWxfanNfcmVnZXhwcyIsImNhbWxfanNfaHRtbF9lc2NhcGUiLCJjYW1sX2JhX2RpbV8yIiwiY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfYXJndW1lbnRzIiwiY2FtbF9zaW5oX2Zsb2F0IiwiY2FtbF9sZGV4cF9mbG9hdCIsImNhbWxfanNfd3JhcF9jYWxsYmFja19zdHJpY3QiLCJhcml0eSIsImNhbWxfZ2V0X2N1cnJlbnRfY2FsbHN0YWNrIiwiY2FtbF9iYV9zZXRfMSIsImxhbmRfZGlnaXRfbmF0IiwiY2FtbF9pbnQ2NF9tb2QiLCJjYW1sX29ial9zZXRfdGFnIiwiY2FtbF9jcmVhdGVfZmlsZV9leHRlcm4iLCJjYW1sX2ludDMyX2Jzd2FwIiwid2luX3N0YXJ0dXAiLCJjYW1sX2JhX3NldF8zIiwiY2FtbF9qc19pbnN0YW5jZW9mIiwiY2FtbF9ibGl0X2JpZ3N0cmluZ190b19zdHJpbmciLCJudGhfZGlnaXRfbmF0X25hdGl2ZSIsInNldF9kaWdpdF9uYXRfbmF0aXZlIiwiZGlnaXQiLCJjYW1sX3N0cmluZ19zZXQ2NCIsImNhbWxfYmFfbWFwX2ZpbGUiLCJ2ZmQiLCJzaGFyZWQiLCJjYW1sX2JhX21hcF9maWxlX2J5dGVjb2RlIiwiYXJnbiIsImNhbWxfYmFfY3JlYXRlX2Zyb20iLCJkYXRhMSIsImRhdGEyIiwianN0eXAiLCJjYW1sX3RhbmhfZmxvYXQiLCJKU09OIiwicnhfb25lIiwicnhfdHdvIiwicnhfdGhyZWUiLCJyeF9mb3VyIiwicnhfZXNjYXBhYmxlIiwicnhfZGFuZ2Vyb3VzIiwidGhpc192YWx1ZSIsIkJvb2xlYW4iLCJnYXAiLCJpbmRlbnQiLCJtZXRhIiwicmVwIiwicXVvdGUiLCJob2xkZXIiLCJtaW5kIiwicGFydGlhbCIsIk9iamVjdCIsInJlcGxhY2VyIiwic3BhY2UiLCJFcnJvciIsInRleHQiLCJyZXZpdmVyIiwid2FsayIsIlN5bnRheEVycm9yIiwiY2FtbF9qc29uIiwiY2FtbF91bm1vdW50IiwiY2FtbF9tbF9wb3NfaW5fNjQiLCJjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZSIsIl9jaGFubmVsIiwiY2FtbF9zdHJpbmdfc2V0IiwiY2FtbF9tbF9wb3Nfb3V0IiwiY2FtbF9zcGFjZXRpbWVfZW5hYmxlZCIsImNhbWxfYnl0ZXNfbm90ZXF1YWwiLCJjYW1sX3J1bnRpbWVfcGFyYW1ldGVycyIsImNhbWxfanNfb2JqZWN0IiwiY2FtbF9iYV9jcmVhdGUiLCJkaW1zX21sIiwiY2FtbF93ZWFrX2JsaXQiLCJjYW1sX2Jzd2FwMTYiLCJjYW1sX2ZpbmFsX3JlZ2lzdGVyIiwiY2FtbF9tbF9zZXRfYmluYXJ5X21vZGUiLCJtb2RlIiwiY2FtbF9zdHJpbmdfZ2V0MTYiLCJjYW1sX2VwaGVfdW5zZXRfZGF0YSIsImNhbWxfb3V0cHV0X3ZhbHVlIiwiY2FtbF9iYV9nZXRfMyIsImNhbWxfZXBoZV9ibGl0X2tleSIsImNhbWxfY2hlY2tfYm91bmQiLCJjYW1sX2J5dGVzX29mX3N0cmluZyIsImNhbWxfaGFzaF9taXhfc3RyaW5nIiwiY2FtbF9oYXNoIiwic2VlZCIsInF1ZXVlIiwicmQiLCJ3ciIsImNhbWxfb2JqX3RhZyIsIkZ1bmN0aW9uIiwiY2FtbF9qc19leHBvcnRfdmFyIiwibW9kdWxlIiwiY2FtbF9ieXRlc19nZXQzMiIsImNhbWxfZnJleHBfZmxvYXQiLCJuZWciLCJjYW1sX3N0cmluZ19nZXQ2NCIsImNhbWxfbWxfcG9zX291dF82NCIsImNhbWxfc2V0X3N0YXRpY19lbnYiLCJjYW1sX2JhX2NoYW5nZV9sYXlvdXQiLCJjYW1sX2pzX25ldyIsImNhbWxfZm9ybWF0X2ludCIsImNhbWxfb2JqX3RydW5jYXRlIiwiaXNfZGlnaXRfb2RkIiwiY2FtbF9ydW50aW1lX3ZhcmlhbnQiLCJjYW1sX2FycmF5X2NvbmNhdCIsImNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dCIsImNhbWxfZXBoZV9zZXRfZGF0YSIsImNhbWxfbWFrZV9mbG9hdF92ZWN0IiwiY2FtbF9ncmVhdGVyZXF1YWwiLCJjYW1sX2dldF9leGNlcHRpb25fcmF3X2JhY2t0cmFjZSIsImNhbWxfbG9nMXBfZmxvYXQiLCJjYW1sX3N0cmluZ19nZXQiLCJjYW1sX2ludDY0X29yIiwiY2FtbF9sYXp5X21ha2VfZm9yd2FyZCIsImxvcl9kaWdpdF9uYXQiLCJjYW1sX2pzX29uX2llIiwidWEiLCJjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0IiwiY2FtbF9iYV9sYXlvdXQiLCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZSIsImNhbWxfYXJyYXlfc2V0IiwibmV3dmFsIiwiY2FtbF9ieXRlc19ncmVhdGVyZXF1YWwiLCJzZXRfZGlnaXRfbmF0IiwiY2FtbF91cGRhdGVfZHVtbXkiLCJjYW1sX0NhbWxpbnRlcm5hbE1vZF91cGRhdGVfbW9kIiwicmVhbCIsImNhbWxfbWxfb3V0cHV0X2ludCIsImNhbWxfb2JqX3dpdGhfdGFnIiwiY2FtbF9pbml0aWFsX3RpbWUiLCJjYW1sX3N5c190aW1lIiwiY2FtbF9tbF9jaGFubmVsX3NpemUiLCJjYW1sX3Jhd19iYWNrdHJhY2Vfc2xvdCIsImNhbWxfaW50NjRfaXNfbWluX2ludCIsImNhbWxfaGV4c3RyaW5nX29mX2Zsb2F0Iiwic3R5bGUiLCJleHBfc2lnbiIsInNpZ25fc3RyIiwiY3N0IiwieF9zdHIiLCJjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19zdHJpY3QiLCJjYW1sX2JhY2t0cmFjZV9zdGF0dXMiLCJjYW1sX2luc3RhbGxfc2lnbmFsX2hhbmRsZXIiLCJjYW1sX3N5c19hcmd2IiwiY2FtbF9iYV9maWxsIiwiY2FtbF9tb2RmX2Zsb2F0IiwiY2FtbF9nY19nZXQiLCJjYW1sX2Zsb2F0X2NvbXBhcmUiLCJjYW1sX3N0cmluZ19zZXQzMiIsImNhbWxfcGFyc2VfZW5naW5lIiwidGFibGVzIiwiZW52IiwiRVJSQ09ERSIsInRlc3RzaGlmdCIsInNoaWZ0Iiwic2hpZnRfcmVjb3ZlciIsInJlZHVjZSIsIlJFQURfVE9LRU4iLCJSQUlTRV9QQVJTRV9FUlJPUiIsIkdST1dfU1RBQ0tTXzEiLCJHUk9XX1NUQUNLU18yIiwiQ09NUFVURV9TRU1BTlRJQ19BQ1RJT04iLCJDQUxMX0VSUk9SX0ZVTkNUSU9OIiwiZW52X3Nfc3RhY2siLCJlbnZfdl9zdGFjayIsImVudl9zeW1iX3N0YXJ0X3N0YWNrIiwiZW52X3N5bWJfZW5kX3N0YWNrIiwiZW52X3N0YWNrc2l6ZSIsImVudl9zdGFja2Jhc2UiLCJlbnZfY3Vycl9jaGFyIiwiZW52X2x2YWwiLCJlbnZfc3ltYl9zdGFydCIsImVudl9zeW1iX2VuZCIsImVudl9hc3AiLCJlbnZfcnVsZV9sZW4iLCJlbnZfcnVsZV9udW1iZXIiLCJlbnZfc3AiLCJlbnZfc3RhdGUiLCJlbnZfZXJyZmxhZyIsInRibF90cmFuc2xfY29uc3QiLCJ0YmxfdHJhbnNsX2Jsb2NrIiwidGJsX2xocyIsInRibF9sZW4iLCJ0YmxfZGVmcmVkIiwidGJsX2Rnb3RvIiwidGJsX3NpbmRleCIsInRibF9yaW5kZXgiLCJ0YmxfZ2luZGV4IiwidGJsX3RhYmxlc2l6ZSIsInRibF90YWJsZSIsInRibF9jaGVjayIsIm4xIiwibjIiLCJzdGF0ZTEiLCJzcCIsImVycmZsYWciLCJhc3AiLCJjYW1sX2FycmF5X2ZpbGwiLCJjYW1sX3N0cmluZ19ub3RlcXVhbCIsImNhbWxfYnl0ZXNfZ3JlYXRlcnRoYW4iLCJjYW1sX21sX3NldF9jaGFubmVsX291dHB1dCIsImNhbWxfcmVhZF9maWxlX2NvbnRlbnQiLCJjYW1sX2pzX3RvX2Zsb2F0IiwiZXJyX25vX3ByZWQiLCJlcnJfbm9fc3VjYyIsIm9jYW1sX3ZlcnNpb24iLCJ6ZXJvJDAiLCJvbmUkMCIsIm1pbnVzX29uZSQwIiwibWluX2ludCQxIiwibWF4X2ludCQxIiwiZHVtbXlfcG9zIiwiemVyb19wb3MiLCJzdWJfZm9ybWF0IiwiZm9ybWF0dGluZ19saXQiLCJsb2NmbXQiLCJjdXJyZW50X2Rpcl9uYW1lIiwicGFyZW50X2Rpcl9uYW1lIiwiZGlyX3NlcCIsInF1b3RlcXVvdGUiLCJjdXJyZW50X2Rpcl9uYW1lJDAiLCJwYXJlbnRfZGlyX25hbWUkMCIsImRpcl9zZXAkMCIsImN1cnJlbnRfZGlyX25hbWUkMSIsInBhcmVudF9kaXJfbmFtZSQxIiwiZGlyX3NlcCQxIiwiemVybyQyIiwib25lJDIiLCJpIiwiZXJhc2VfcmVsIiwicmVzdCIsInJlc3QkMCIsInJlc3QkMSIsInJlc3QkMiIsInJlc3QkMyIsInJlc3QkNCIsInJlc3QkNSIsInJlc3QkNiIsInJlc3QkNyIsInR5IiwicmVzdCQ4IiwidHkxIiwicmVzdCQ5IiwicmVzdCQxMCIsInJlc3QkMTEiLCJyZXN0JDEyIiwicmVzdCQxMyIsImNvbmNhdF9mbXR0eSIsImZtdHR5MSIsImZtdHR5MiIsInR5MiIsImNvbmNhdF9mbXQiLCJmbXQxIiwiZm10MiIsInBhZCIsInBhZCQwIiwicHJlYyIsInBhZCQxIiwiaWNvbnYiLCJwcmVjJDAiLCJwYWQkMiIsImljb252JDAiLCJwcmVjJDEiLCJwYWQkMyIsImljb252JDEiLCJwcmVjJDIiLCJwYWQkNCIsImljb252JDIiLCJwcmVjJDMiLCJwYWQkNSIsImZjb252IiwicGFkJDYiLCJzdHIiLCJjaHIiLCJmbXR0eSIsInBhZCQ3IiwiZm10dHkkMCIsInBhZCQ4IiwicmVzdCQxNCIsInJlc3QkMTUiLCJyZXN0JDE2IiwiZm10aW5nX2xpdCIsInJlc3QkMTciLCJmbXRpbmdfZ2VuIiwicmVzdCQxOCIsInJlc3QkMTkiLCJjaGFyX3NldCIsIndpZHRoX29wdCIsInJlc3QkMjAiLCJjb3VudGVyIiwicmVzdCQyMSIsInJlc3QkMjIiLCJpZ24iLCJyZXN0JDIzIiwiZiIsImFyaXR5IiwiZmFpbHdpdGgiLCJzIiwiaW52YWxpZF9hcmciLCJtaW4iLCJ4IiwieSIsIm1heCIsImFicyIsImxub3QiLCJpbmZpbml0eSIsIm5lZ19pbmZpbml0eSIsIm5hbiIsIm1heF9mbG9hdCIsIm1pbl9mbG9hdCIsImVwc2lsb25fZmxvYXQiLCJtYXhfaW50IiwibWluX2ludCIsInN5bWJvbCIsInMxIiwiczIiLCJsMSIsImwyIiwiY2hhcl9vZl9pbnQiLCJuIiwic3RyaW5nX29mX2Jvb2wiLCJiIiwiYm9vbF9vZl9zdHJpbmciLCJib29sX29mX3N0cmluZ19vcHQiLCJzdHJpbmdfb2ZfaW50IiwiaW50X29mX3N0cmluZ19vcHQiLCJ2YWxpZF9mbG9hdF9sZXhlbSIsImwiLCJpJDAiLCJzdHJpbmdfb2ZfZmxvYXQiLCJmbG9hdF9vZl9zdHJpbmdfb3B0IiwidGwiLCJoZCIsInN0ZGluIiwic3Rkb3V0Iiwic3RkZXJyIiwib3Blbl9vdXRfZ2VuIiwibW9kZSIsInBlcm0iLCJuYW1lIiwiYyIsIm9wZW5fb3V0Iiwib3Blbl9vdXRfYmluIiwiZmx1c2hfYWxsIiwiaXRlciIsImEiLCJvdXRwdXRfYnl0ZXMiLCJvYyIsIm91dHB1dF9zdHJpbmciLCJvdXRwdXQiLCJvZnMiLCJsZW4iLCJvdXRwdXRfc3Vic3RyaW5nIiwib3V0cHV0X3ZhbHVlIiwiY2hhbiIsInYiLCJjbG9zZV9vdXQiLCJjbG9zZV9vdXRfbm9lcnIiLCJvcGVuX2luX2dlbiIsIm9wZW5faW4iLCJvcGVuX2luX2JpbiIsImlucHV0IiwiaWMiLCJ1bnNhZmVfcmVhbGx5X2lucHV0Iiwib2ZzJDAiLCJsZW4kMCIsInIiLCJsZW4kMSIsIm9mcyQxIiwicmVhbGx5X2lucHV0IiwicmVhbGx5X2lucHV0X3N0cmluZyIsImlucHV0X2xpbmUiLCJidWlsZF9yZXN1bHQiLCJidWYiLCJhY2N1IiwicmVzIiwiYmVnIiwiYWNjdSQwIiwiY2xvc2VfaW5fbm9lcnIiLCJwcmludF9jaGFyIiwicHJpbnRfc3RyaW5nIiwicHJpbnRfYnl0ZXMiLCJwcmludF9pbnQiLCJwcmludF9mbG9hdCIsInByaW50X2VuZGxpbmUiLCJwcmludF9uZXdsaW5lIiwicHJlcnJfY2hhciIsInByZXJyX3N0cmluZyIsInByZXJyX2J5dGVzIiwicHJlcnJfaW50IiwicHJlcnJfZmxvYXQiLCJwcmVycl9lbmRsaW5lIiwicHJlcnJfbmV3bGluZSIsInJlYWRfbGluZSIsInJlYWRfaW50IiwicmVhZF9pbnRfb3B0IiwicmVhZF9mbG9hdCIsInJlYWRfZmxvYXRfb3B0Iiwic3RyaW5nX29mX2Zvcm1hdCIsInN5bWJvbCQwIiwic3RyMiIsInN0cjEiLCJleGl0X2Z1bmN0aW9uIiwiYXRfZXhpdCIsImciLCJkb19hdF9leGl0IiwiZXhpdCIsInJldGNvZGUiLCJwYXJhbSQwIiwibCQwIiwibiQwIiwibCQxIiwibiQxIiwibDEkMCIsImwyJDAiLCJsMSQxIiwibDIkMSIsImluaXRfYXV4IiwiYWNjIiwiYWNjJDAiLCJwYXJhbSIsImFjY3UkMSIsImEyIiwiYTEiLCJwIiwicGFpciIsInJ5IiwicngiLCJjbXAiLCJtYXRjaCIsInQyIiwiaDIiLCJ0MSIsImgxIiwiY2hvcCIsImsiLCJrJDAiLCJrJDEiLCJzb3J0IiwieDIiLCJ4MSIsIngzIiwieDIkMCIsIngxJDAiLCJuMSIsIm4yIiwicmV2X3NvcnQiLCJjJDAiLCJjJDEiLCJjJDIiLCJjJDMiLCJjJDQiLCJjJDUiLCJjJDYiLCJhY2N1JDIiLCJlc2NhcGVkIiwicyQwIiwibG93ZXJjYXNlIiwidXBwZXJjYXNlIiwibG93ZXJjYXNlX2FzY2lpIiwidXBwZXJjYXNlX2FzY2lpIiwiY29tcGFyZSIsImMxIiwiYzIiLCJlcXVhbCIsIm1pbiQwIiwibWF4JDAiLCJsb19ib3VuZCIsImhpX2JvdW5kIiwiYm9tIiwicmVwIiwic3VjYyIsInUiLCJwcmVkIiwiaXNfdmFsaWQiLCJvZl9pbnQiLCJpc19jaGFyIiwib2ZfY2hhciIsInRvX2NoYXIiLCJ1bnNhZmVfdG9fY2hhciIsImVxdWFsJDAiLCJjb21wYXJlJDAiLCJoYXNoIiwic3ltYm9sJDEiLCJsZWZ0IiwicmlnaHQiLCJzcmNvZmYiLCJkc3RvZmYiLCJjcHlsZW4iLCJvZnMxIiwib2ZzMiIsInNlcCIsInNlcGxlbiIsImRzdCIsImlzX3NwYWNlIiwiaiIsImFwcGx5MSIsImluZGV4X3JlYyIsImxpbSIsImkkMSIsImluZGV4X3JlY19vcHQiLCJyaW5kZXhfcmVjIiwicmluZGV4X3JlY19vcHQiLCJpc19zcGFjZSQwIiwiaW5kZXhfcmVjJDAiLCJpbmRleF9yZWNfb3B0JDAiLCJyaW5kZXhfcmVjJDAiLCJyaW5kZXhfcmVjX29wdCQwIiwib3NfdHlwZSIsImJhY2tlbmRfdHlwZSIsInVuaXgiLCJ3aW4zMiIsImN5Z3dpbiIsIm1heF9hcnJheV9sZW5ndGgiLCJtYXhfc3RyaW5nX2xlbmd0aCIsImJpZ19lbmRpYW4iLCJzaXplIiwiaW50X3NpemUiLCJnZXRlbnZfb3B0IiwiaW50ZXJhY3RpdmUiLCJzZXRfc2lnbmFsIiwic2lnX251bSIsInNpZ19iZWgiLCJzaWdhYnJ0Iiwic2lnYWxybSIsInNpZ2ZwZSIsInNpZ2h1cCIsInNpZ2lsbCIsInNpZ2ludCIsInNpZ2tpbGwiLCJzaWdwaXBlIiwic2lncXVpdCIsInNpZ3NlZ3YiLCJzaWd0ZXJtIiwic2lndXNyMSIsInNpZ3VzcjIiLCJzaWdjaGxkIiwic2lnY29udCIsInNpZ3N0b3AiLCJzaWd0c3RwIiwic2lndHRpbiIsInNpZ3R0b3UiLCJzaWd2dGFscm0iLCJzaWdwcm9mIiwic2lnYnVzIiwic2lncG9sbCIsInNpZ3N5cyIsInNpZ3RyYXAiLCJzaWd1cmciLCJzaWd4Y3B1Iiwic2lneGZzeiIsImNhdGNoX2JyZWFrIiwib24iLCJtZXJnZSQwIiwib3JkZXIiLCJsaXN0IiwiaW5pdGxpc3QiLCJlMiIsIm1lcmdlMiIsInN3YXAiLCJhcnIiLCJ0bXAiLCJhcnJheSIsInFzb3J0IiwibG8iLCJoaSIsImxvJDAiLCJoaSQwIiwibWlkIiwicGl2b3QiLCJsbyQxIiwiaGkkMSIsInZhbF9pIiwidG9fYnVmZmVyIiwiYnVmZiIsImZsYWdzIiwiaGVhZGVyX3NpemUiLCJkYXRhX3NpemUiLCJ0b3RhbF9zaXplIiwiZnJvbV9ieXRlcyIsImZyb21fc3RyaW5nIiwiaXNfYmxvY2siLCJkb3VibGVfZmllbGQiLCJzZXRfZG91YmxlX2ZpZWxkIiwibWFyc2hhbCIsIm9iaiIsInVubWFyc2hhbCIsInBvcyIsImZpcnN0X25vbl9jb25zdGFudF9jb25zdHJ1Y3Rvcl90YWciLCJsYXN0X25vbl9jb25zdGFudF9jb25zdHJ1Y3Rvcl90YWciLCJsYXp5X3RhZyIsImNsb3N1cmVfdGFnIiwib2JqZWN0X3RhZyIsImluZml4X3RhZyIsImZvcndhcmRfdGFnIiwibm9fc2Nhbl90YWciLCJhYnN0cmFjdF90YWciLCJzdHJpbmdfdGFnIiwiZG91YmxlX3RhZyIsImRvdWJsZV9hcnJheV90YWciLCJjdXN0b21fdGFnIiwiaW50X3RhZyIsIm91dF9vZl9oZWFwX3RhZyIsInVuYWxpZ25lZF90YWciLCJleHRlbnNpb25fY29uc3RydWN0b3IiLCJzbG90IiwiZXh0ZW5zaW9uX25hbWUiLCJleHRlbnNpb25faWQiLCJsZW5ndGgkMCIsInN4Iiwic3kiLCJpbml0IiwibGEiLCJsYiIsInJlcyQwIiwidGwkMCIsImhkJDAiLCJtYXhzb24iLCJpMzEiLCJ0cmlja2xlZG93biIsImUiLCJ0cmlja2xlIiwiYnViYmxlZG93biIsImJ1YmJsZSIsImkkMiIsImUkMCIsImZhdGhlciIsIm1lcmdlIiwic3JjMW9mcyIsInNyYzFsZW4iLCJzcmMyIiwic3JjMm9mcyIsInNyYzJsZW4iLCJkc3RvZnMiLCJzcmMxciIsInNyYzJyIiwiczIkMSIsInMxJDEiLCJpMSIsImkyIiwiZCIsImkyJDAiLCJkJDAiLCJzMiQwIiwiaTEkMCIsImQkMSIsInMxJDAiLCJpc29ydHRvIiwic3Jjb2ZzIiwic29ydHRvIiwidCIsInplcm8iLCJvbmUiLCJtaW51c19vbmUiLCJzdWNjJDAiLCJwcmVkJDAiLCJhYnMkMCIsIm1pbl9pbnQkMCIsIm1heF9pbnQkMCIsImxvZ25vdCIsInRvX3N0cmluZyQwIiwib2Zfc3RyaW5nX29wdCIsImNvbXBhcmUkMyIsImVxdWFsJDMiLCJzdWNjJDEiLCJwcmVkJDEiLCJhYnMkMSIsImxvZ25vdCQwIiwidG9fc3RyaW5nJDEiLCJvZl9zdHJpbmdfb3B0JDAiLCJjb21wYXJlJDQiLCJlcXVhbCQ0IiwiemVybyQxIiwib25lJDEiLCJtaW51c19vbmUkMSIsInN1Y2MkMiIsInByZWQkMiIsImFicyQyIiwibWluX2ludCQyIiwibWF4X2ludCQyIiwibG9nbm90JDEiLCJ0b19zdHJpbmckMiIsIm9mX3N0cmluZ19vcHQkMSIsImNvbXBhcmUkNSIsImVxdWFsJDUiLCJlbmdpbmUiLCJ0YmwiLCJzdGF0ZSIsInJlc3VsdCIsIm5ld19lbmdpbmUiLCJmcm9tX2Z1bmN0aW9uIiwiYXV4X2J1ZmZlciIsImxleGJ1ZiIsInJlYWQiLCJuZXdsZW4iLCJuZXdidWYiLCJmcm9tX2NoYW5uZWwiLCJmcm9tX3N0cmluZyQwIiwibGV4ZW1lIiwic3ViX2xleGVtZSIsInN1Yl9sZXhlbWVfb3B0Iiwic3ViX2xleGVtZV9jaGFyIiwic3ViX2xleGVtZV9jaGFyX29wdCIsImxleGVtZV9jaGFyIiwibGV4ZW1lX3N0YXJ0IiwibGV4ZW1lX2VuZCIsImxleGVtZV9zdGFydF9wIiwibGV4ZW1lX2VuZF9wIiwibmV3X2xpbmUiLCJsY3AiLCJmbHVzaF9pbnB1dCIsImVudiIsImdyb3dfc3RhY2tzIiwib2xkc2l6ZSIsIm5ld3NpemUiLCJuZXdfcyIsIm5ld192IiwibmV3X3N0YXJ0IiwibmV3X2VuZCIsImNsZWFyX3BhcnNlciIsImN1cnJlbnRfbG9va2FoZWFkX2Z1biIsInl5cGFyc2UiLCJ0YWJsZXMiLCJzdGFydCIsImxleGVyIiwiaW5pdF9hc3AiLCJpbml0X3NwIiwiaW5pdF9zdGFja2Jhc2UiLCJpbml0X3N0YXRlIiwiaW5pdF9jdXJyX2NoYXIiLCJpbml0X2x2YWwiLCJpbml0X2VycmZsYWciLCJjbWQiLCJhcmciLCJhcmckMCIsImNtZCQwIiwiYXJnJDEiLCJleG4iLCJjdXJyX2NoYXIiLCJ0b2siLCJwZWVrX3ZhbCIsInN5bWJvbF9zdGFydF9wb3MiLCJzdCIsImVuIiwic3ltYm9sX2VuZF9wb3MiLCJyaHNfc3RhcnRfcG9zIiwicmhzX2VuZF9wb3MiLCJzeW1ib2xfc3RhcnQiLCJzeW1ib2xfZW5kIiwicmhzX3N0YXJ0IiwicmhzX2VuZCIsImlzX2N1cnJlbnRfbG9va2FoZWFkIiwicGFyc2VfZXJyb3IiLCJoZWlnaHQiLCJoIiwiY3JlYXRlIiwiaGwiLCJoJDAiLCJociIsImJhbCIsImxyIiwibHYiLCJsbCIsImxyciIsImxydiIsImxybCIsInJyIiwicnYiLCJybCIsInJsciIsInJsdiIsInJsbCIsImFkZCIsInNpbmdsZXRvbiIsImFkZF9taW5fZWxlbWVudCIsImFkZF9tYXhfZWxlbWVudCIsImpvaW4iLCJyaCIsImxoIiwibWluX2VsdCIsIm1pbl9lbHRfb3B0IiwibWF4X2VsdCIsIm1heF9lbHRfb3B0IiwicmVtb3ZlX21pbl9lbHQiLCJyJDAiLCJjb25jYXQiLCJzcGxpdCIsInByZXMiLCJwcmVzJDAiLCJlbXB0eSIsImlzX2VtcHR5IiwibWVtIiwicGFyYW0kMSIsInJlbW92ZSIsInVuaW9uIiwicjIiLCJ2MiIsInIxIiwidjEiLCJyMiQwIiwicjEkMCIsImludGVyIiwiZGlmZiIsImNvbnNfZW51bSIsInMkMSIsImUkMSIsImUyJDIiLCJlMSQyIiwiZTEiLCJlMiQwIiwiZTEkMCIsImUyJDEiLCJlMSQxIiwic3Vic2V0IiwiZm9sZCIsImZvcl9hbGwiLCJleGlzdHMiLCJmaWx0ZXIiLCJwdiIsInBhcnRpdGlvbiIsImxmIiwibHQiLCJyZiIsInJ0IiwiY2FyZGluYWwiLCJlbGVtZW50c19hdXgiLCJlbGVtZW50cyIsImZpbmQiLCJmaW5kX2ZpcnN0IiwidiQwIiwiZmluZF9maXJzdF9vcHQiLCJmaW5kX2xhc3QiLCJmaW5kX2xhc3Rfb3B0IiwiZmluZF9vcHQiLCJtYXAiLCJvZl9saXN0Iiwic3ViIiwibCQzIiwieDAiLCJsJDQiLCJ4MCQwIiwibCQ1IiwieDAkMSIsIm5sIiwibCQyIiwieDQiLCJsZCIsImxyZCIsInJkIiwicmxkIiwiZGF0YSIsIm0iLCJtaW5fYmluZGluZyIsIm1pbl9iaW5kaW5nX29wdCIsIm1heF9iaW5kaW5nIiwibWF4X2JpbmRpbmdfb3B0IiwicmVtb3ZlX21pbl9iaW5kaW5nIiwidXBkYXRlIiwiZGF0YSQwIiwibWFwaSIsIm0kMCIsImFkZF9taW5fYmluZGluZyIsImFkZF9tYXhfYmluZGluZyIsImNvbmNhdF9vcl9qb2luIiwiZDEiLCJkMiIsImQyJDAiLCJkMSQwIiwiZDIkMSIsImQxJDEiLCJwdmQiLCJtJDEiLCJtMSIsIm0yIiwiYmluZGluZ3NfYXV4IiwiYmluZGluZ3MiLCJjbGVhciIsImNvcHkkMiIsInB1c2giLCJwb3AiLCJ0b3AiLCJsZW5ndGgkMSIsIml0ZXIkMyIsImNyZWF0ZSQwIiwiY2xlYXIkMCIsInEiLCJjZWxsIiwicGVlayIsImNvbnRlbnQiLCJ0YWtlIiwiY29weSQzIiwicV9yZXMiLCJwcmV2IiwibmV4dCIsImlzX2VtcHR5JDAiLCJsZW5ndGgkMiIsIml0ZXIkNCIsImZvbGQkMCIsInRyYW5zZmVyIiwicTEiLCJxMiIsInJhaXNlX3VuZGVmaW5lZCIsImZvcmNlX2xhenlfYmxvY2siLCJibGsiLCJjbG9zdXJlIiwiZm9yY2VfdmFsX2xhenlfYmxvY2siLCJmb3JjZSIsImx6diIsImZvcmNlX3ZhbCIsImZyb21fZnVuIiwiZnJvbV92YWwiLCJpc192YWwiLCJjb3VudCIsImZpbGxfYnVmZiIsImdldF9kYXRhIiwiZDExIiwiYSQwIiwiYSQxIiwicGVla19kYXRhIiwicGVlayQwIiwianVua19kYXRhIiwianVuayIsIm5nZXRfZGF0YSIsImFsIiwibnBlZWsiLCJlbXB0eSQwIiwiaXRlciQ1Iiwic3RybSIsImZyb20iLCJvZl9saXN0JDAiLCJvZl9zdHJpbmckMCIsIm9mX2J5dGVzIiwib2ZfY2hhbm5lbCIsImlhcHAiLCJpY29ucyIsImlzaW5nIiwibGFwcCIsImxjb25zIiwibHNpbmciLCJzZW1wdHkiLCJzbGF6eSIsImR1bXAiLCJkdW1wX2RhdGEiLCJjcmVhdGUkMSIsImNvbnRlbnRzIiwidG9fYnl0ZXMiLCJzdWIkMiIsImJsaXQkMiIsInNyYyIsIm50aCQwIiwibGVuZ3RoJDMiLCJjbGVhciQxIiwicmVzZXQiLCJyZXNpemUiLCJtb3JlIiwibmV3X2xlbiIsIm5ld19idWZmZXIiLCJhZGRfY2hhciIsImFkZF91dGZfOF91Y2hhciIsInBvcyQwIiwicG9zJDEiLCJhZGRfdXRmXzE2YmVfdWNoYXIiLCJ1JDAiLCJhZGRfdXRmXzE2bGVfdWNoYXIiLCJhZGRfc3Vic3RyaW5nIiwib2Zmc2V0IiwibmV3X3Bvc2l0aW9uIiwiYWRkX3N1YmJ5dGVzIiwiYWRkX3N0cmluZyIsImFkZF9ieXRlcyIsImFkZF9idWZmZXIiLCJicyIsImFkZF9jaGFubmVsIiwib3V0cHV0X2J1ZmZlciIsImFkZF9zdWJzdGl0dXRlIiwibGltJDEiLCJwcmV2aW91cyIsImkkNyIsImN1cnJlbnQiLCJpJDgiLCJvcGVuaW5nIiwiaSQ2IiwibGltJDAiLCJpJDMiLCJzdG9wIiwiaSQ0IiwiaSQ1IiwiayQyIiwibmV4dF9pIiwiaWRlbnQiLCJpJDkiLCJpJDEwIiwiaSQxMSIsInRydW5jYXRlIiwiY3JlYXRlX2NoYXJfc2V0IiwiYWRkX2luX2NoYXJfc2V0Iiwic3RyX2luZCIsIm1hc2siLCJmcmVlemVfY2hhcl9zZXQiLCJyZXZfY2hhcl9zZXQiLCJjaGFyX3NldCQwIiwiaXNfaW5fY2hhcl9zZXQiLCJwYWRfb2ZfcGFkX29wdCIsInBhZF9vcHQiLCJ3aWR0aCIsInBhcmFtX2Zvcm1hdF9vZl9pZ25vcmVkX2Zvcm1hdCIsImZtdCIsInBhZF9vcHQkMCIsInBhZF9vcHQkMSIsInBhZF9vcHQkMiIsInBhZF9vcHQkMyIsInBhZF9vcHQkNCIsInByZWNfb3B0IiwicGFkX29wdCQ1IiwibmRlYyIsInBhZF9vcHQkNiIsInBhZF9vcHQkNyIsInBhZF9vcHQkOCIsImRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uIiwiYnVmZmVyX2NyZWF0ZSIsImluaXRfc2l6ZSIsImJ1ZmZlcl9jaGVja19zaXplIiwib3ZlcmhlYWQiLCJtaW5fbGVuIiwibmV3X3N0ciIsImJ1ZmZlcl9hZGRfY2hhciIsImJ1ZmZlcl9hZGRfc3RyaW5nIiwic3RyX2xlbiIsImJ1ZmZlcl9jb250ZW50cyIsImNoYXJfb2ZfaWNvbnYiLCJjaGFyX29mX2Zjb252IiwiYnByaW50X3BhZHR5IiwicGFkdHkiLCJicHJpbnRfaWdub3JlZF9mbGFnIiwiaWduX2ZsYWciLCJicHJpbnRfcGFkX29wdCIsImJwcmludF9wYWRkaW5nIiwicGFkdHkkMCIsImJwcmludF9wcmVjaXNpb24iLCJicHJpbnRfaWNvbnZfZmxhZyIsImJwcmludF9hbHRpbnRfZm10IiwiYnByaW50X2Zjb252X2ZsYWciLCJzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQiLCJzdHIkMCIsInN0cmluZ19vZl9mb3JtYXR0aW5nX2dlbiIsImZvcm1hdHRpbmdfZ2VuIiwiYnByaW50X2NoYXJfbGl0ZXJhbCIsImJwcmludF9zdHJpbmdfbGl0ZXJhbCIsImJwcmludF9mbXR0eSIsInN1Yl9mbXR0eSIsInN1Yl9mbXR0eSQwIiwiaW50X29mX2N1c3RvbV9hcml0eSIsInN0cmluZ19vZl9mbXQiLCJmbXQkMSIsImNociQwIiwiaXNfYWxvbmUkMCIsImlzX2Fsb25lIiwiaiQwIiwiaiQxIiwiZm10JDAiLCJzeW1tIiwiZm10dHlfcmVsX2RldCIsImRlIiwiZWQiLCJhZiIsImZhIiwiZGUkMCIsImVkJDAiLCJhZiQwIiwiZmEkMCIsImRlJDEiLCJlZCQxIiwiYWYkMSIsImZhJDEiLCJkZSQyIiwiZWQkMiIsImFmJDIiLCJmYSQyIiwiZGUkMyIsImVkJDMiLCJhZiQzIiwiZmEkMyIsImRlJDQiLCJlZCQ0IiwiYWYkNCIsImZhJDQiLCJkZSQ1IiwiZWQkNSIsImFmJDUiLCJmYSQ1IiwiZGUkNiIsImVkJDYiLCJhZiQ2IiwiZmEkNiIsImRlJDciLCJlZCQ3IiwiYWYkNyIsImZhJDciLCJkZSQ4IiwiZWQkOCIsImFmJDgiLCJmYSQ4IiwidHJhbnMiLCJqZCIsImRqIiwiZ2EiLCJhZyIsImRlJDkiLCJlZCQ5IiwiYWYkOSIsImZhJDkiLCJkZSQxMCIsImVkJDEwIiwiYWYkMTAiLCJmYSQxMCIsImRlJDExIiwiZWQkMTEiLCJhZiQxMSIsImZhJDExIiwiZGUkMTIiLCJlZCQxMiIsImFmJDEyIiwiZmEkMTIiLCJkZSQxMyIsImVkJDEzIiwiYWYkMTMiLCJmYSQxMyIsInJlc3QyIiwicmVzdDIkMCIsInJlc3QyJDEiLCJyZXN0MiQyIiwicmVzdDIkMyIsInJlc3QyJDQiLCJyZXN0MiQ1IiwicmVzdDIkNiIsInJlc3QyJDciLCJyZXN0MiQ4IiwidHkyMiIsInR5MjEiLCJmNCIsImYyIiwicmVzdDIkOSIsInJlc3QyJDEwIiwicmVzdDIkMTEiLCJyZXN0MiQxMiIsInJlc3QyJDEzIiwiZm10dHlfb2ZfcGFkZGluZ19mbXR0eSIsImZtdHR5X29mX2N1c3RvbSIsImFyaXR5JDAiLCJmbXR0eV9vZl9mbXQiLCJ0eV9yZXN0IiwicHJlY190eSIsImZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSIsInR5X3Jlc3QkMCIsInByZWNfdHkkMCIsInR5X3Jlc3QkMSIsInByZWNfdHkkMSIsInR5X3Jlc3QkMiIsInByZWNfdHkkMiIsInR5X3Jlc3QkMyIsInByZWNfdHkkMyIsImZtdHR5JDEiLCJmbXR0eSQyIiwiZm10dHkkMyIsInR5JDAiLCJmbXR0eSQ0IiwiZm10dHkkNSIsInR5cGVfcGFkZGluZyIsInciLCJ0eXBlX3BhZHByZWMiLCJ0eXBlX2Zvcm1hdCIsInR5cGVfZm9ybWF0X2dlbiIsInR5cGVfaWdub3JlZF9wYXJhbV9vbmUiLCJmbXR0eV9yZXN0IiwiZm10X3Jlc3QiLCJmbXR0eV9yZXN0JDAiLCJmbXRfcmVzdCQwIiwiZm10X3Jlc3QkMSIsImZtdHR5X3Jlc3QkMSIsImZtdCQyIiwiZm10X3Jlc3QkMiIsImZtdHR5X3Jlc3QkMiIsImZtdCQzIiwiZm10X3Jlc3QkMyIsImZtdHR5X3Jlc3QkMyIsImZtdCQ0IiwiZm10X3Jlc3QkNCIsImZtdHR5X3Jlc3QkNCIsImZtdCQ1IiwiZm10X3Jlc3QkNSIsImZtdHR5X3Jlc3QkNSIsImZtdHR5JDYiLCJmbXQkNiIsImZtdF9yZXN0JDYiLCJmbXR0eV9yZXN0JDYiLCJmbXR0eSQ3IiwiZm10JDciLCJmbXRfcmVzdCQ3IiwiZm10dHlfcmVzdCQ3IiwiZm10dHkkOCIsImZtdCQ4IiwiZm10X3Jlc3QkOCIsImZtdHR5X3Jlc3QkOCIsImZtdHR5JDkiLCJmbXQkOSIsImZtdF9yZXN0JDkiLCJmbXR0eSQxMCIsImZtdCQxMCIsImZtdF9yZXN0JDEwIiwiZm10dHkkMTEiLCJmbXQkMTEiLCJmbXRfcmVzdCQxMSIsImZtdHR5JDEyIiwiZm10JDEyIiwiZm10dHlfcmVzdCQ5IiwiZm10X3Jlc3QkMTIiLCJmbXR0eSQxMyIsImZtdCQxMyIsImZtdHR5X3Jlc3QkMTAiLCJzdWJfZm10dHkxIiwiZm10X3Jlc3QkMTMiLCJzdWJfZm10dHkkMSIsImZtdHR5JDE0IiwiZm10JDE0IiwiZm10dHlfcmVzdCQxMSIsImZtdF9yZXN0JDE0IiwiZm10dHkkMTUiLCJmbXQkMTUiLCJmbXR0eV9yZXN0JDEyIiwiZm10X3Jlc3QkMTUiLCJmbXR0eSQxNiIsImZtdCQxNiIsImZtdF9yZXN0JDE2IiwiZm10dHkkMTciLCJmbXQkMTciLCJmbXRfcmVzdCQxNyIsImZtdHR5MyIsImZtdDMiLCJzdHIkMSIsImZtdDEkMCIsImZtdHR5MiQwIiwiZm10MiQwIiwiZm10dHkzJDAiLCJmbXQzJDAiLCJmbXR0eV9yZXN0JDEzIiwiZm10X3Jlc3QkMTgiLCJmbXR0eSQxOCIsImZtdCQxOCIsImZtdHR5X3Jlc3QkMTQiLCJmbXRfcmVzdCQxOSIsImZtdHR5JDE5IiwiZm10JDE5IiwiZm10dHlfcmVzdCQxNSIsImZtdF9yZXN0JDIwIiwiZm10dHkkMjAiLCJmbXQkMjAiLCJmbXR0eV9yZXN0JDE2IiwiZm10dHkkMjEiLCJmbXQkMjEiLCJzdWJfZm10dHkkMiIsInN1Yl9mbXR0eSQzIiwidHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24iLCJmbXR0eSQyMiIsImZtdCQyMiIsInN1Yl9mbXR0eSQ0Iiwic3ViX2ZtdHR5X3Jlc3QiLCJzdWJfZm10dHlfcmVzdCQwIiwic3ViX2ZtdHR5X3Jlc3QkMSIsInN1Yl9mbXR0eV9yZXN0JDIiLCJzdWJfZm10dHlfcmVzdCQzIiwic3ViX2ZtdHR5X3Jlc3QkNCIsInN1Yl9mbXR0eV9yZXN0JDUiLCJzdWJfZm10dHlfcmVzdCQ2Iiwic3ViX2ZtdHR5X3Jlc3QkNyIsInN1Yl9mbXR0eV9yZXN0JDgiLCJzdWJfZm10dHlfcmVzdCQ5Iiwic3ViX2ZtdHR5X3Jlc3QkMTAiLCJzdWJfZm10dHlfcmVzdCQxMSIsInN1Yl9mbXR0eV9yZXN0JDEyIiwic3ViX2ZtdHR5X3Jlc3QkMTMiLCJzdWJfZm10dHlfcmVzdCQxNCIsInN1YjJfZm10dHkiLCJzdWJfZm10dHlfcmVzdCQxNSIsInN1YjJfZm10dHkkMCIsInN1Yl9mbXR0eV9yZXN0JDE2Iiwic3ViMl9mbXR0eSQxIiwic3ViMV9mbXR0eSIsInN1Yl9mbXR0eV9yZXN0JDE3Iiwic3ViMl9mbXR0eSQyIiwic3ViMV9mbXR0eSQwIiwic3ViX2ZtdHR5X3Jlc3QkMTgiLCJzdWJfZm10dHlfcmVzdCQxOSIsInN1Yl9mbXR0eV9yZXN0JDIwIiwic3ViX2ZtdHR5X3Jlc3QkMjEiLCJzdWJfZm10dHlfcmVzdCQyMiIsInN1Yl9mbXR0eV9yZXN0JDIzIiwic3ViX2ZtdHR5X3Jlc3QkMjQiLCJzdWJfZm10dHlfcmVzdCQyNSIsInN1Yl9mbXR0eV9yZXN0JDI2IiwicmVjYXN0IiwiZml4X3BhZGRpbmciLCJmaXhfaW50X3ByZWNpc2lvbiIsInJlcyQxIiwic3RyaW5nX3RvX2NhbWxfc3RyaW5nIiwiY29udmVydF9pbnQiLCJjb252ZXJ0X2ludDMyIiwiY29udmVydF9uYXRpdmVpbnQiLCJjb252ZXJ0X2ludDY0IiwiY29udmVydF9mbG9hdCIsInNpZ24iLCJzeW1iIiwic3RyaW5nX29mX2ZtdHR5IiwibWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24iLCJvIiwibWFrZV9wcmludGYiLCJwJDAiLCJwJDEiLCJtYWtlX3BhZGRpbmciLCJuZXdfYWNjIiwibWFrZV9wcmludGYkMCIsImFjYyQxIiwiYWNjJDIiLCJhY2MkMyIsImFjYyQ0IiwiayQzIiwia29jIiwia2FjYyIsImskNCIsIm1ha2VfaWdub3JlZF9wYXJhbSQwIiwibWFrZV9jdXN0b20kMCIsIm1ha2VfaW52YWxpZF9hcmciLCJtYWtlX2Zyb21fZm10dHkkMCIsIm1ha2VfZnJvbV9mbXR0eSIsIm1ha2VfY3VzdG9tIiwibWFrZV9pZ25vcmVkX3BhcmFtIiwiZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24iLCJtYWtlX2lwcmludGYiLCJtYWtlX2lwcmludGYkMCIsInJlc3QkMjQiLCJyZXN0JDI1IiwiZm5fb2ZfY3VzdG9tX2FyaXR5JDAiLCJmbl9vZl9jdXN0b21fYXJpdHkiLCJvdXRwdXRfYWNjIiwicCQyIiwicCQzIiwibXNnIiwicCQ0IiwiYnVmcHV0X2FjYyIsInN0cnB1dF9hY2MiLCJmYWlsd2l0aF9tZXNzYWdlIiwib3Blbl9ib3hfb2Zfc3RyaW5nIiwiaW52YWxpZF9ib3giLCJwYXJzZV9zcGFjZXMiLCJwYXJzZV9sd29yZCIsInBhcnNlX2ludCIsIndzdGFydCIsIndlbmQiLCJib3hfbmFtZSIsIm5zdGFydCIsIm5lbmQiLCJpbmRlbnQiLCJleHBfZW5kIiwiYm94X3R5cGUiLCJtYWtlX3BhZGRpbmdfZm10X2ViYiIsIm1ha2VfcGFkcHJlY19mbXRfZWJiIiwiZm10X2ViYl9vZl9zdHJpbmciLCJsZWdhY3lfYmVoYXZpb3IiLCJmbGFnIiwibGVnYWN5X2JlaGF2aW9yJDAiLCJpbnZhbGlkX2Zvcm1hdF9tZXNzYWdlIiwidW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IiwiZW5kX2luZCIsImludmFsaWRfZm9ybWF0X3dpdGhvdXQiLCJleHBlY3RlZF9jaGFyYWN0ZXIiLCJleHBlY3RlZCIsImFkZF9saXRlcmFsIiwibGl0X3N0YXJ0IiwicGFyc2UiLCJzdHJfaW5kJDIiLCJwYXJzZV9mbGFncyIsInN0cl9pbmQkMCIsInBhcnNlX3RhZyIsInBhcnNlX2dvb2RfYnJlYWsiLCJwYXJzZV9tYWdpY19zaXplIiwic3RyX2luZCQxIiwicGFyc2VfY29udmVyc2lvbiIsInBjdF9pbmQiLCJwbHVzIiwic3BhY2UiLCJwYWRwcmVjIiwicGx1c191c2VkIiwiaGFzaF91c2VkIiwic3BhY2VfdXNlZCIsImlnbl91c2VkIiwicGFkX3VzZWQiLCJwcmVjX3VzZWQiLCJnZXRfcGx1cyIsImdldF9oYXNoIiwiZ2V0X3NwYWNlIiwiZ2V0X2lnbiIsImdldF9wYWQiLCJnZXRfcHJlYyIsImdldF9wYWRwcmVjIiwiZ2V0X2ludF9wYWQiLCJpbmNvbXBhdGlibGVfZmxhZyIsImNoZWNrX25vXzAiLCJvcHRfb2ZfcGFkIiwid2lkdGgkMCIsIndpZHRoJDEiLCJnZXRfcGFkX29wdCIsImdldF9wYWRwcmVjX29wdCIsImZtdF9yZXN1bHQiLCJzdWJfZW5kIiwic2VhcmNoX3N1YmZvcm1hdF9lbmQiLCJzdWJfZm10IiwiaWdub3JlZCQyIiwiY291bnRlciQwIiwiaWdub3JlZCQ2IiwiaWdub3JlZCQ3IiwiYWRkX3JhbmdlIiwiZmFpbF9zaW5nbGVfcGVyY2VudCIsInBhcnNlX2NoYXJfc2V0X2NvbnRlbnQiLCJwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyJDAiLCJwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIiwicmV2ZXJzZSIsIm5leHRfaW5kIiwiY2hhcl9zZXQkMSIsImlnbm9yZWQkOSIsImNoYXJfZm9ybWF0IiwiZm10X3Jlc3QkMjEiLCJmbXRfcmVzdCQyMiIsInBhZCQ5IiwiZm10X3Jlc3QkMjMiLCJpZ25vcmVkJDEwIiwiZm10X3Jlc3QkMjQiLCJwYWQkMTAiLCJmbXRfcmVzdCQyNSIsInN1Yl9lbmQkMCIsInN1Yl9mbXQkMCIsImZtdF9yZXN0JDI2IiwiaWdub3JlZCQxMSIsImlnbm9yZWQkMyIsInN5bWIkMCIsImlnbm9yZWQkNSIsImNvbXB1dGVfaW50X2NvbnYiLCJpZ25vcmVkJDgiLCJwcmVjJDQiLCJzcGFjZSQxIiwicGx1cyQyIiwicGx1cyQzIiwic3BhY2UkMiIsImlnbm9yZWQkNCIsImlnbm9yZWQiLCJpZ25vcmVkJDAiLCJpZ25vcmVkJDEiLCJwbHVzJDAiLCJoYXNoJDAiLCJzcGFjZSQwIiwicGx1cyQxIiwiaWduJDAiLCJwYXJzZV9hZnRlcl9wcmVjaXNpb24iLCJtaW51cyIsInBhcnNlX2NvbnYiLCJwYXJzZV9hZnRlcl9wYWRkaW5nIiwicGFyc2VfbGl0ZXJhbCIsInBhcnNlX3Bvc2l0aXZlIiwibmV3X2luZCIsIm1pbnVzJDAiLCJzZXRfZmxhZyIsInN0cl9pbmQkMyIsInN0cl9pbmQkNCIsInN0cl9pbmQkNSIsImlzX29wZW5fdGFnIiwiaW5kIiwic3ViX3N0ciIsInN1Yl9mb3JtYXQkMCIsImZvcm1hdHRpbmckMCIsImZvcm1hdHRpbmciLCJzdHJfaW5kXzEiLCJwYXJzZV9pbnRlZ2VyIiwic3RyX2luZF8yIiwic3RyX2luZF8zIiwiZm9ybWF0dGluZ19saXQkMCIsInN0cl9pbmRfNCIsInN0cl9pbmRfNSIsInN1Yl9lbmQkMSIsInN1Yl9lbmQkMiIsInN0cl9pbmQkNiIsInN0cl9pbmQkNyIsIm9wdGlvbiIsInN1YmZtdCIsImZvcm1hdF9vZl9zdHJpbmdfZm10dHkiLCJmb3JtYXRfb2Zfc3RyaW5nX2Zvcm1hdCIsImtmcHJpbnRmIiwia2JwcmludGYiLCJpa2ZwcmludGYiLCJmcHJpbnRmIiwiYnByaW50ZiIsImlmcHJpbnRmIiwicHJpbnRmIiwiZXByaW50ZiIsImtzcHJpbnRmIiwic3ByaW50ZiIsImFzc29jMyIsInkyIiwieTEiLCJzcGxpdCQwIiwibWFrZV9zeW1saXN0IiwicHJlZml4Iiwic3VmZml4IiwiaGVscF9hY3Rpb24iLCJhZGRfaGVscCIsInNwZWNsaXN0IiwiYWRkMiIsInVzYWdlX2IiLCJlcnJtc2ciLCJkb2MiLCJzcGVjIiwia2V5IiwidXNhZ2Vfc3RyaW5nIiwidXNhZ2UiLCJib29sX29mX3N0cmluZ19vcHQkMCIsImludF9vZl9zdHJpbmdfb3B0JDAiLCJmbG9hdF9vZl9zdHJpbmdfb3B0JDAiLCJwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pY19hdXgiLCJhbGxvd19leHBhbmQiLCJhcmd2IiwiYW5vbmZ1biIsImluaXRwb3MiLCJjb252ZXJ0X2Vycm9yIiwiZXJyb3IiLCJwcm9nbmFtZSIsIm9wdCIsImFjdGlvbiIsImZvbGxvdyQwIiwia2V5d29yZCIsIm5vX2FyZyQwIiwiZm9sbG93Iiwibm9fYXJnIiwiZ2V0X2FyZyQwIiwiZ2V0X2FyZyIsImNvbnN1bWVfYXJnJDAiLCJjb25zdW1lX2FyZyIsInRyZWF0X2FjdGlvbiQwIiwidHJlYXRfYWN0aW9uIiwiZiQwIiwiZiQxIiwiciQxIiwiZiQyIiwiciQyIiwiYXJnJDIiLCJ4JDAiLCJmJDMiLCJhcmckMyIsIngkMSIsInIkMyIsImFyZyQ0IiwieCQyIiwic3BlY3MiLCJmJDQiLCJhcmckNSIsImYkNSIsImYkNiIsImFyZyQ2IiwibmV3YXJnIiwiYmVmb3JlIiwiYWZ0ZXIiLCJwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pYyIsInBhcnNlX2FyZ3ZfZHluYW1pYyIsInN0aCIsImN1cnJlbnQkMCIsInBhcnNlX2FyZ3YiLCJtc2ckMCIsIm1zZyQxIiwicGFyc2VfZHluYW1pYyIsInBhcnNlX2V4cGFuZCIsInNlY29uZF93b3JkIiwibG9vcCIsIm1heF9hcmdfbGVuIiwiY3VyIiwia3dkIiwicmVwbGFjZV9sZWFkaW5nX3RhYiIsInNlZW4iLCJhbGlnbiIsImxpbWl0IiwiY29tcGxldGVkIiwia3NkIiwiY3V0Y29sJDAiLCJzcGFjZXMkMCIsImN1dGNvbCIsImt3ZF9sZW4iLCJzcGFjZXMiLCJyZWFkX2F1eCIsInRyaW0iLCJmaWxlIiwid29yZHMiLCJzdGFzaCIsIndvcmQiLCJyZWFkX2FyZyIsInJlYWRfYXJnMCIsIndyaXRlX2F1eCIsImFyZ3MiLCJ3cml0ZV9hcmciLCJ3cml0ZV9hcmcwIiwicHJpbnRlcnMiLCJmaWVsZCIsIm90aGVyX2ZpZWxkcyIsImZpZWxkcyIsInRvX3N0cmluZyQzIiwiY29udiIsImNoYXIkMCIsImxpbmUiLCJjaGFyJDEiLCJsaW5lJDAiLCJmaWxlJDAiLCJjaGFyJDIiLCJsaW5lJDEiLCJmaWxlJDEiLCJjb25zdHJ1Y3RvciIsInByaW50IiwiZmN0IiwiY2F0Y2gkMCIsImNvbnZlcnRfcmF3X2JhY2t0cmFjZSIsImJ0IiwiZm9ybWF0X2JhY2t0cmFjZV9zbG90IiwiaW5mbyIsImlzX3JhaXNlIiwicHJpbnRfcmF3X2JhY2t0cmFjZSIsIm91dGNoYW4iLCJyYXdfYmFja3RyYWNlIiwiYmFja3RyYWNlIiwicHJpbnRfYmFja3RyYWNlIiwicmF3X2JhY2t0cmFjZV90b19zdHJpbmciLCJiYWNrdHJhY2Vfc2xvdF9pc19yYWlzZSIsImJhY2t0cmFjZV9zbG90X2lzX2lubGluZSIsImJhY2t0cmFjZV9zbG90X2xvY2F0aW9uIiwiYmFja3RyYWNlX3Nsb3RzIiwiZ2V0X2JhY2t0cmFjZSIsInJlZ2lzdGVyX3ByaW50ZXIiLCJmbiIsImV4bl9zbG90IiwiZXhuX3Nsb3RfaWQiLCJleG5fc2xvdF9uYW1lIiwidW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIiLCJzZXRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIiLCJwcmludF9zdGF0IiwiYWxsb2NhdGVkX2J5dGVzIiwibWEiLCJwcm8iLCJtaSIsImNyZWF0ZV9hbGFybSIsImRlbGV0ZV9hbGFybSIsInN0cmluZyIsImJ5dGVzIiwic3Vic3RyaW5nIiwic3ViYnl0ZXMiLCJmaWxlbmFtZSIsIm91dHB1dCQwIiwiZGlnZXN0IiwiaW5wdXQkMCIsImNoYXJfaGV4IiwidG9faGV4IiwiZnJvbV9oZXgiLCJkaWdpdCIsIm5ld19zdGF0ZSIsImFzc2lnbiIsInN0MSIsInN0MiIsImZ1bGxfaW5pdCIsInNlZWQiLCJzZWVkJDAiLCJtYWtlJDEiLCJtYWtlX3NlbGZfaW5pdCIsImNvcHkkNCIsImJpdHMiLCJjdXJ2YWwiLCJuZXd2YWwiLCJuZXd2YWwzMCIsImludCQwIiwiYm91bmQiLCJpbnQzMiIsImIxIiwiYjIiLCJpbnQ2NCIsImIzIiwibmF0aXZlaW50IiwiZmxvYXQkMCIsImJvb2wiLCJkZWZhdWx0JDAiLCJiaXRzJDAiLCJpbnQkMSIsImludDMyJDAiLCJuYXRpdmVpbnQkMCIsImludDY0JDAiLCJmbG9hdCQxIiwic2NhbGUiLCJib29sJDAiLCJmdWxsX2luaXQkMCIsImluaXQkMyIsInNlbGZfaW5pdCIsImdldF9zdGF0ZSIsInNldF9zdGF0ZSIsImhhc2hfcGFyYW0iLCJzZWVkZWRfaGFzaCIsIm9uZ29pbmdfdHJhdmVyc2FsIiwiZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCIsInBhcmFtcyIsInJhbmRvbWl6ZWRfZGVmYXVsdCIsInJhbmRvbWl6ZWQiLCJyYW5kb21pemUiLCJpc19yYW5kb21pemVkIiwicHJuZyIsImNyZWF0ZSQyIiwiaW5pdGlhbF9zaXplIiwicmFuZG9tIiwiY2xlYXIkMiIsInJlc2V0JDAiLCJjb3B5X2J1Y2tldGxpc3QiLCJrZXkkMCIsIm5leHQkMCIsImNvcHkkNSIsImxlbmd0aCQ0IiwicmVzaXplJDAiLCJpbmRleGZ1biIsIm9kYXRhIiwib3NpemUiLCJuc2l6ZSIsIm5kYXRhIiwibmRhdGFfdGFpbCIsImlucGxhY2UiLCJjZWxsJDAiLCJuaWR4IiwibWF0Y2gkMCIsImtleV9pbmRleCIsImFkZCQwIiwiYnVja2V0IiwiZmluZCQwIiwiazEiLCJuZXh0MSIsImsyIiwibmV4dDIiLCJrMyIsImQzIiwibmV4dDMiLCJmaW5kX29wdCQwIiwiZmluZF9hbGwkMCIsImZpbmRfaW5fYnVja2V0IiwicmVwbGFjZSIsIm1lbSQxIiwiaXRlciQ2IiwiZG9fYnVja2V0Iiwib2xkX3RyYXYiLCJmaWx0ZXJfbWFwX2lucGxhY2VfYnVja2V0IiwiZmlsdGVyX21hcF9pbnBsYWNlIiwiZm9sZCQxIiwiYiQwIiwiYnVja2V0X2xlbmd0aCIsInN0YXRzIiwibWJsIiwiaGlzdG8iLCJmaW5kX2FsbCIsImNvcHkiLCJsZW5ndGgiLCJzeiIsImxlbmd0aCQ1IiwiZmlsbCQxIiwiYXIiLCJlbXB0eWJ1Y2tldCIsImdldF9pbmRleCIsInN6JDAiLCJzeiQxIiwiY291bnRfYnVja2V0IiwiYWRkX2F1eCIsInNldHRlciIsImluZGV4IiwiYnVja2V0JDAiLCJoYXNoZXMiLCJuZXdzeiIsIm5ld2J1Y2tldCIsIm5ld2hhc2hlcyIsImhidWNrZXQiLCJwcmV2X2xlbiIsImxpdmUiLCJqJDIiLCJuZXd0Iiwib2IiLCJvaCIsInNldHRlciQwIiwibmIiLCJuaSIsImZpbmRfb3IiLCJpZm5vdGZvdW5kIiwiZmluZF9zaGFkb3ciLCJpZmZvdW5kIiwibGVucyIsInRvdGxlbiIsImFkZF9xdWV1ZSIsInRha2VfcXVldWUiLCJwcF9lbnF1ZXVlIiwidG9rZW4iLCJwcF9pbmZpbml0eSIsInBwX291dHB1dF9zdHJpbmciLCJwcF9vdXRwdXRfbmV3bGluZSIsImJyZWFrX25ld19saW5lIiwicmVhbF9pbmRlbnQiLCJicmVha19saW5lIiwiYnJlYWtfc2FtZV9saW5lIiwicHBfZm9yY2VfYnJlYWtfbGluZSIsImJsX3R5IiwicHBfc2tpcF90b2tlbiIsImZvcm1hdF9wcF90b2tlbiIsInRhYnMiLCJhZGRfdGFiIiwibHMiLCJscyQwIiwidGFncyIsInRhZ19uYW1lIiwibWFya2VyIiwib2ZmIiwib2ZmJDAiLCJpbnNlcnRpb25fcG9pbnQiLCJ0YWJzJDAiLCJ0YWIiLCJvZmYkMSIsImluc2VydGlvbl9wb2ludCQwIiwib2Zmc2V0JDAiLCJibF90eXBlIiwidGJveCIsInRhZ19uYW1lJDAiLCJtYXJrZXIkMCIsImFkdmFuY2VfbG9vcCIsInNpemUkMCIsImFkdmFuY2VfbGVmdCIsImVucXVldWVfYWR2YW5jZSIsImVucXVldWVfc3RyaW5nX2FzIiwicV9lbGVtIiwic2Nhbl9zdGFja19ib3R0b20iLCJjbGVhcl9zY2FuX3N0YWNrIiwic2V0X3NpemUiLCJxdWV1ZV9lbGVtIiwibGVmdF90b3QiLCJzY2FuX3B1c2giLCJwcF9vcGVuX2JveF9nZW4iLCJicl90eSIsImVsZW0iLCJwcF9jbG9zZV9ib3giLCJwcF9vcGVuX3RhZyIsInBwX2Nsb3NlX3RhZyIsInBwX3NldF9wcmludF90YWdzIiwicHBfc2V0X21hcmtfdGFncyIsInBwX2dldF9wcmludF90YWdzIiwicHBfZ2V0X21hcmtfdGFncyIsInBwX3NldF90YWdzIiwicHBfZ2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIiwicHBfc2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIiwicGN0IiwicG90IiwibWN0IiwibW90IiwicHBfcmluaXQiLCJwcF9mbHVzaF9xdWV1ZSIsInBwX3ByaW50X2FzX3NpemUiLCJwcF9wcmludF9hcyIsImlzaXplIiwicHBfcHJpbnRfc3RyaW5nIiwicHBfcHJpbnRfaW50IiwicHBfcHJpbnRfZmxvYXQiLCJwcF9wcmludF9ib29sIiwicHBfcHJpbnRfY2hhciIsInBwX29wZW5faGJveCIsInBwX29wZW5fdmJveCIsInBwX29wZW5faHZib3giLCJwcF9vcGVuX2hvdmJveCIsInBwX29wZW5fYm94IiwicHBfcHJpbnRfbmV3bGluZSIsInBwX3ByaW50X2ZsdXNoIiwicHBfZm9yY2VfbmV3bGluZSIsInBwX3ByaW50X2lmX25ld2xpbmUiLCJwcF9wcmludF9icmVhayIsInBwX3ByaW50X3NwYWNlIiwicHBfcHJpbnRfY3V0IiwicHBfb3Blbl90Ym94IiwicHBfY2xvc2VfdGJveCIsInBwX3ByaW50X3RicmVhayIsInBwX3ByaW50X3RhYiIsInBwX3NldF90YWIiLCJwcF9zZXRfbWF4X2JveGVzIiwicHBfZ2V0X21heF9ib3hlcyIsInBwX292ZXJfbWF4X2JveGVzIiwicHBfc2V0X2VsbGlwc2lzX3RleHQiLCJwcF9nZXRfZWxsaXBzaXNfdGV4dCIsInBwX2xpbWl0IiwicHBfc2V0X21heF9pbmRlbnQiLCJwcF9nZXRfbWF4X2luZGVudCIsInBwX3NldF9tYXJnaW4iLCJuZXdfbWF4X2luZGVudCIsInBwX2dldF9tYXJnaW4iLCJwcF9zZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMiLCJwcF9nZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMiLCJwcF9zZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMiLCJwcF9nZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMiLCJkaXNwbGF5X25ld2xpbmUiLCJibGFua19saW5lIiwiZGlzcGxheV9pbmRlbnQiLCJwcF9zZXRfZm9ybWF0dGVyX291dF9jaGFubmVsIiwiZGVmYXVsdF9wcF9tYXJrX29wZW5fdGFnIiwiZGVmYXVsdF9wcF9tYXJrX2Nsb3NlX3RhZyIsImRlZmF1bHRfcHBfcHJpbnRfb3Blbl90YWciLCJkZWZhdWx0X3BwX3ByaW50X2Nsb3NlX3RhZyIsInBwX21ha2VfZm9ybWF0dGVyIiwicHBfcXVldWUiLCJzeXNfdG9rIiwic3lzX3NjYW5fc3RhY2siLCJmb3JtYXR0ZXJfb2Zfb3V0X2Z1bmN0aW9ucyIsIm91dF9mdW5zIiwibWFrZV9mb3JtYXR0ZXIiLCJmbHVzaCIsInBwZiIsImZvcm1hdHRlcl9vZl9vdXRfY2hhbm5lbCIsImZvcm1hdHRlcl9vZl9idWZmZXIiLCJwcF9idWZmZXJfc2l6ZSIsInBwX21ha2VfYnVmZmVyIiwic3RkYnVmIiwic3RkX2Zvcm1hdHRlciIsImVycl9mb3JtYXR0ZXIiLCJzdHJfZm9ybWF0dGVyIiwiZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciIsImZsdXNoX3N0cl9mb3JtYXR0ZXIiLCJtYWtlX3N5bWJvbGljX291dHB1dF9idWZmZXIiLCJjbGVhcl9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIiwic29iIiwiZ2V0X3N5bWJvbGljX291dHB1dF9idWZmZXIiLCJmbHVzaF9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIiwiaXRlbXMiLCJhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0iLCJpdGVtIiwiZm9ybWF0dGVyX29mX3N5bWJvbGljX291dHB1dF9idWZmZXIiLCJvcGVuX2hib3giLCJvcGVuX3Zib3giLCJvcGVuX2h2Ym94Iiwib3Blbl9ob3Zib3giLCJvcGVuX2JveCIsImNsb3NlX2JveCIsIm9wZW5fdGFnIiwiY2xvc2VfdGFnIiwicHJpbnRfYXMiLCJwcmludF9zdHJpbmckMCIsInByaW50X2ludCQwIiwicHJpbnRfZmxvYXQkMCIsInByaW50X2NoYXIkMCIsInByaW50X2Jvb2wiLCJwcmludF9icmVhayIsInByaW50X2N1dCIsInByaW50X3NwYWNlIiwiZm9yY2VfbmV3bGluZSIsInByaW50X2ZsdXNoIiwicHJpbnRfbmV3bGluZSQwIiwicHJpbnRfaWZfbmV3bGluZSIsIm9wZW5fdGJveCIsImNsb3NlX3Rib3giLCJwcmludF90YnJlYWsiLCJzZXRfdGFiIiwicHJpbnRfdGFiIiwic2V0X21hcmdpbiIsImdldF9tYXJnaW4iLCJzZXRfbWF4X2luZGVudCIsImdldF9tYXhfaW5kZW50Iiwic2V0X21heF9ib3hlcyIsImdldF9tYXhfYm94ZXMiLCJvdmVyX21heF9ib3hlcyIsInNldF9lbGxpcHNpc190ZXh0IiwiZ2V0X2VsbGlwc2lzX3RleHQiLCJzZXRfZm9ybWF0dGVyX291dF9jaGFubmVsIiwic2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIiwiZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIiwic2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIiwiZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIiwic2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIiwiZ2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIiwic2V0X3ByaW50X3RhZ3MiLCJnZXRfcHJpbnRfdGFncyIsInNldF9tYXJrX3RhZ3MiLCJnZXRfbWFya190YWdzIiwic2V0X3RhZ3MiLCJwcF9wcmludF9saXN0IiwicHBfdiIsIm9wdCQwIiwicHBfc2VwIiwib3B0JDEiLCJwcF9wcmludF90ZXh0IiwiY29tcHV0ZV90YWciLCJ0YWdfYWNjIiwib3V0cHV0X2Zvcm1hdHRpbmdfbGl0Iiwib3V0cHV0X2FjYyQwIiwiYnR5IiwicCQ1IiwicCQ2Iiwic3RycHV0X2FjYyQwIiwic2l6ZSQxIiwia2ZwcmludGYkMCIsImlrZnByaW50ZiQwIiwiZnByaW50ZiQwIiwiaWZwcmludGYkMCIsInByaW50ZiQwIiwiZXByaW50ZiQwIiwia3NwcmludGYkMCIsInNwcmludGYkMCIsImthc3ByaW50ZiIsImFzcHJpbnRmIiwicHBfc2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyIsInBwX2dldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMiLCJzZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIiwiZ2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyIsImJwcmludGYkMCIsIm51bGxfY2hhciIsIm5leHRfY2hhciIsImliIiwicGVla19jaGFyIiwiY2hlY2tlZF9wZWVrX2NoYXIiLCJlbmRfb2ZfaW5wdXQiLCJiZWdpbm5pbmdfb2ZfaW5wdXQiLCJuYW1lX29mX2lucHV0IiwiZm5hbWUiLCJjaGFyX2NvdW50IiwicmVzZXRfdG9rZW4iLCJpbnZhbGlkYXRlX2N1cnJlbnRfY2hhciIsInRva2VuX3N0cmluZyIsInRva2VuX2J1ZmZlciIsInNraXBfY2hhciIsImlnbm9yZV9jaGFyIiwic3RvcmVfY2hhciIsImRlZmF1bHRfdG9rZW5fYnVmZmVyX3NpemUiLCJjcmVhdGUkMyIsImluYW1lIiwiZnJvbV9zdHJpbmckMSIsImZyb21fZnVuY3Rpb24kMCIsInNjYW5fY2xvc2VfYXRfZW5kIiwic2Nhbl9yYWlzZV9hdF9lbmQiLCJmcm9tX2ljIiwic2Nhbl9jbG9zZV9pYyIsImVvZiIsInN0ZGliIiwib3Blbl9pbl9maWxlIiwiZnJvbV9maWxlIiwiZnJvbV9maWxlX2JpbiIsImZyb21fY2hhbm5lbCQwIiwiY2xvc2VfaW4iLCJpYyQwIiwibWVtbyIsIm1lbW9fZnJvbV9pYyIsIm1lbW9fZnJvbV9jaGFubmVsIiwiYmFkX2lucHV0IiwiYmFkX2lucHV0X2VzY2FwZSIsImJhZF90b2tlbl9sZW5ndGgiLCJtZXNzYWdlIiwiYmFkX2Zsb2F0IiwiYmFkX2hleF9mbG9hdCIsImNoYXJhY3Rlcl9taXNtYXRjaCIsImNpIiwiY2hlY2tfdGhpc19jaGFyIiwiY2hlY2tfY2hhciIsInRva2VuX2NoYXIiLCJ0b2tlbl9ib29sIiwiaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIiLCJ0b2tlbl9pbnRfbGl0ZXJhbCIsInRva2VuX2Zsb2F0Iiwic2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIiLCJ3aWR0aCQyIiwic2Nhbl91bnNpZ25lZF9kZWNpbWFsX2ludCIsInNjYW5fZGlnaXRfcGx1cyIsImJhc2lzIiwiZGlnaXRwIiwid2lkdGgkMyIsImlzX2JpbmFyeV9kaWdpdCIsInNjYW5fYmluYXJ5X2ludCIsImlzX29jdGFsX2RpZ2l0Iiwic2Nhbl9vY3RhbF9pbnQiLCJpc19oZXhhX2RpZ2l0Iiwic2Nhbl9oZXhhZGVjaW1hbF9pbnQiLCJzY2FuX3NpZ24iLCJzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWxfaW50Iiwic2Nhbl9pbnRfY29udmVyc2lvbiIsInNjYW5fZnJhY3Rpb25hbF9wYXJ0Iiwic2Nhbl9leHBvbmVudF9wYXJ0Iiwic2Nhbl9mbG9hdCIsInByZWNpc2lvbiIsInByZWNpc2lvbiQwIiwiY2hlY2tfY2FzZV9pbnNlbnNpdGl2ZV9zdHJpbmciLCJzY2FuX2hleF9mbG9hdCIsIndpZHRoJDQiLCJ3aWR0aCQ1Iiwid2lkdGgkNiIsIndpZHRoJDEwIiwid2lkdGgkNyIsIndpZHRoJDgiLCJ3aWR0aCQ5Iiwic2Nhbl9jYW1sX2Zsb2F0X3Jlc3QiLCJ3aWR0aF9wcmVjaXNpb24iLCJmcmFjX3dpZHRoIiwic2Nhbl9jYW1sX2Zsb2F0Iiwic2Nhbl9zdHJpbmciLCJzdHAiLCJzY2FuX2NoYXIiLCJoZXhhZGVjaW1hbF92YWx1ZV9vZl9jaGFyIiwiY2hlY2tfbmV4dF9jaGFyIiwiY2hlY2tfbmV4dF9jaGFyX2Zvcl9jaGFyIiwiY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmciLCJzY2FuX2JhY2tzbGFzaF9jaGFyIiwiYzAiLCJnZXRfZGlnaXQiLCJnZXRfZGlnaXQkMCIsImMxJDAiLCJjMiQwIiwic2Nhbl9jYW1sX2NoYXIiLCJmaW5kX3N0b3AiLCJzY2FuX2NhbWxfc3RyaW5nIiwiZmluZF9zdG9wJDAiLCJza2lwX3NwYWNlcyIsInNjYW5fY2hhcnNfaW5fY2hhcl9zZXQiLCJzY2FuX2luZGljIiwic2Nhbl9jaGFycyIsInNjYW5mX2JhZF9pbnB1dCIsImdldF9jb3VudGVyIiwid2lkdGhfb2ZfcGFkX29wdCIsInN0b3BwZXJfb2ZfZm9ybWF0dGluZ19saXQiLCJmbXRpbmciLCJ0YWtlX2Zvcm1hdF9yZWFkZXJzJDAiLCJ0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzJDAiLCJyZWFkZXIiLCJuZXdfayIsInJlYWRlcnNfcmVzdCIsInRha2VfZm9ybWF0X3JlYWRlcnMiLCJmbXQkMjMiLCJmbXQkMjQiLCJmbXQkMjUiLCJ0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIiwicGFkX3ByZWNfc2NhbmYiLCJyZWFkZXJzIiwic2NhbiIsIm1ha2Vfc2NhbmYiLCJzY2FuJDAiLCJzdHJfcmVzdCIsInNjYW4kMSIsInNjYW4kMiIsInNjYW4kMyIsInNjYW4kNCIsImNvbnYkMCIsInNjYW4kNSIsImNvbnYkMSIsInNjYW4kNiIsImNvbnYkMiIsInNjYW4kNyIsInByZWMkNSIsInNjYW4kOCIsImZtdGluZ19saXQkMCIsInN0cCQwIiwicyQyIiwic3RyX3Jlc3QkMCIsImFyZ19yZXN0Iiwia3NjYW5mIiwiZWYiLCJhcHBseSIsImFyZ3MkMCIsImV4YyIsImJzY2FuZiIsImtzc2NhbmYiLCJzc2NhbmYiLCJzY2FuZiIsImJzY2FuZl9mb3JtYXQiLCJmb3JtYXQiLCJzc2NhbmZfZm9ybWF0IiwiZm9ybWF0X2Zyb21fc3RyaW5nIiwidW5lc2NhcGVkIiwia2ZzY2FuZiIsImZzY2FuZiIsInJlZ2lzdGVyIiwicmVnaXN0ZXJfZXhjZXB0aW9uIiwibyQwIiwicGFyYW1zJDAiLCJpbml0aWFsX29iamVjdF9zaXplIiwiZHVtbXlfaXRlbSIsInRhZyIsImNvbXBhcmUkNiIsImNvbXBhcmUkNyIsImNvbXBhcmUkOCIsImR1bW15X3RhYmxlIiwidGFibGVfY291bnQiLCJkdW1teV9tZXQiLCJmaXRfc2l6ZSIsIm5ld190YWJsZSIsInB1Yl9sYWJlbHMiLCJtZXRob2RzIiwicmVzaXplJDEiLCJuZXdfc2l6ZSIsIm9sZF9zaXplIiwibmV3X2J1Y2siLCJtZXRob2RfY291bnQiLCJpbnN0X3Zhcl9jb3VudCIsIm5ld19tZXRob2QiLCJ0YWJsZSIsImdldF9tZXRob2RfbGFiZWwiLCJsYWJlbCIsImdldF9tZXRob2RfbGFiZWxzIiwibmFtZXMiLCJzZXRfbWV0aG9kIiwiZWxlbWVudCIsImdldF9tZXRob2QiLCJ0b19saXN0JDAiLCJuYXJyb3ciLCJ2YXJzIiwidmlydF9tZXRocyIsImNvbmNyX21ldGhzIiwidmFycyQwIiwidmlydF9tZXRocyQwIiwiY29uY3JfbWV0aHMkMCIsInZpcnRfbWV0aF9sYWJzIiwiY29uY3JfbWV0aF9sYWJzIiwibGFiIiwidHZhcnMiLCJieV9uYW1lIiwiYnlfbGFiZWwiLCJtZXQiLCJobSIsIndpZGVuIiwic2F2ZWRfdmFycyIsInNhdmVkX2hpZGRlbl9tZXRocyIsIm5ld19zbG90IiwibmV3X3ZhcmlhYmxlIiwidG9fYXJyYXkiLCJuZXdfbWV0aG9kc192YXJpYWJsZXMiLCJtZXRocyIsInZhbHMiLCJtZXRocyQwIiwibm1ldGhzIiwibnZhbHMiLCJnZXRfdmFyaWFibGUiLCJnZXRfdmFyaWFibGVzIiwiYWRkX2luaXRpYWxpemVyIiwiY3JlYXRlX3RhYmxlIiwicHVibGljX21ldGhvZHMiLCJpbml0X2NsYXNzIiwiaW5oZXJpdHMiLCJjbGEiLCJzdXBlciQwIiwibm0iLCJtYWtlX2NsYXNzIiwicHViX21ldGhzIiwiY2xhc3NfaW5pdCIsImVudl9pbml0IiwibWFrZV9jbGFzc19zdG9yZSIsImluaXRfdGFibGUiLCJkdW1teV9jbGFzcyIsImxvYyIsInVuZGVmIiwiY3JlYXRlX29iamVjdCIsImNyZWF0ZV9vYmplY3Rfb3B0Iiwib2JqXzAiLCJpdGVyX2YiLCJydW5faW5pdGlhbGl6ZXJzIiwiaW5pdHMiLCJydW5faW5pdGlhbGl6ZXJzX29wdCIsImNyZWF0ZV9vYmplY3RfYW5kX3J1bl9pbml0aWFsaXplcnMiLCJnZXRfZGF0YSQwIiwiYnVpbGRfcGF0aCIsImtleXMiLCJsb29rdXBfdGFibGVzIiwicm9vdCIsInRhYmxlcyQyIiwidGFibGVzJDAiLCJ0YWJsZXMkMSIsIm5ld19jYWNoZSIsInNldF9tZXRob2RzIiwiY2xvIiwiY2xvJDAiLCJuJDIiLCJuJDMiLCJuJDQiLCJuJDUiLCJuJDYiLCJ4JDMiLCJuJDciLCJ4JDQiLCJuJDgiLCJmJDciLCJuJDkiLCJ4JDUiLCJmJDgiLCJlJDIiLCJuJDEwIiwieCQ2IiwiZiQ5IiwibiQxMSIsIngkNyIsIm4kMTIiLCJ4JDgiLCJuJDEzIiwibiQxNCIsImUkMyIsIm4kMTUiLCJtJDIiLCJ4JDkiLCJtJDMiLCJuJDE2IiwibSQ0IiwiZSQ0IiwibiQxNyIsIm0kNSIsIm4kMTgiLCJzdGF0cyQwIiwiaW5pdGlhbF9idWZmZXIiLCJidWZmZXIiLCJidWZwb3MiLCJyZXNldF9idWZmZXIiLCJzdG9yZSIsIm5ld2J1ZmZlciIsImdldF9zdHJpbmciLCJtYWtlX2xleGVyIiwia2V5d29yZHMiLCJrd2RfdGFibGUiLCJpZGVudF9vcl9rZXl3b3JkIiwiaWQiLCJrZXl3b3JkX29yX2Vycm9yIiwiZW5kX2V4cG9uZW50X3BhcnQiLCJleHBvbmVudF9wYXJ0IiwibnVtYmVyIiwiaWRlbnQyIiwibmVnX251bWJlciIsIm5leHRfdG9rZW4kMCIsImVzY2FwZSIsIm1heWJlX2NvbW1lbnQiLCJjb21tZW50IiwibmV4dF90b2tlbiIsImhrZXkiLCJjbGVhbiIsImluc2VydF9idWNrZXQiLCJjb250YWluZXIiLCJyZW1vdmVfYnVja2V0IiwiaGsiLCJyZXBsYWNlX2J1Y2tldCIsIm5ld19kIiwiYnVja2V0X2xlbmd0aF9hbGl2ZSIsInN0YXRzX2FsaXZlIiwiY3JlYXRlJDQiLCJnZXRfa2V5IiwiZ2V0X2tleV9jb3B5Iiwic2V0X2tleSIsInVuc2V0X2tleSIsImNoZWNrX2tleSIsImJsaXRfa2V5IiwiZ2V0X2RhdGEkMSIsImdldF9kYXRhX2NvcHkiLCJzZXRfZGF0YSIsInVuc2V0X2RhdGEiLCJjaGVja19kYXRhIiwiYmxpdF9kYXRhIiwic2V0X2tleV9kYXRhIiwiY3JlYXRlJDUiLCJnZXRfa2V5MSIsImdldF9rZXkxX2NvcHkiLCJzZXRfa2V5MSIsInVuc2V0X2tleTEiLCJjaGVja19rZXkxIiwiZ2V0X2tleTIiLCJnZXRfa2V5Ml9jb3B5Iiwic2V0X2tleTIiLCJ1bnNldF9rZXkyIiwiY2hlY2tfa2V5MiIsImJsaXRfa2V5MSIsImJsaXRfa2V5MiIsImJsaXRfa2V5MTIiLCJnZXRfZGF0YSQyIiwiZ2V0X2RhdGFfY29weSQwIiwic2V0X2RhdGEkMCIsInVuc2V0X2RhdGEkMCIsImNoZWNrX2RhdGEkMCIsImJsaXRfZGF0YSQwIiwiazIkMCIsImsxJDAiLCJjcmVhdGUkNiIsImxlbmd0aCQ2IiwiZ2V0X2tleSQwIiwiZ2V0X2tleV9jb3B5JDAiLCJzZXRfa2V5JDAiLCJ1bnNldF9rZXkkMCIsImNoZWNrX2tleSQwIiwiYmxpdF9rZXkkMCIsIm8xIiwibzIiLCJnZXRfZGF0YSQzIiwiZ2V0X2RhdGFfY29weSQxIiwic2V0X2RhdGEkMSIsInVuc2V0X2RhdGEkMSIsImNoZWNrX2RhdGEkMSIsImJsaXRfZGF0YSQxIiwia2kiLCJrMCIsImdlbmVyaWNfYmFzZW5hbWUiLCJpc19kaXJfc2VwIiwiZ2VuZXJpY19kaXJuYW1lIiwiaXNfcmVsYXRpdmUiLCJpc19pbXBsaWNpdCIsImNoZWNrX3N1ZmZpeCIsInN1ZmYiLCJxdW90ZSIsImJhc2VuYW1lIiwiZGlybmFtZSIsImlzX2Rpcl9zZXAkMCIsImlzX3JlbGF0aXZlJDAiLCJpc19pbXBsaWNpdCQwIiwiY2hlY2tfc3VmZml4JDAiLCJ0ZW1wX2Rpcl9uYW1lIiwicXVvdGUkMCIsImFkZF9icyIsImxvb3AkMCIsImxvb3BfYnMiLCJkcml2ZV9hbmRfcGF0aCIsImRpcm5hbWUkMCIsInBhdGgiLCJkcml2ZSIsImRpciIsImJhc2VuYW1lJDAiLCJiYXNlbmFtZSQxIiwiZGlybmFtZSQxIiwiY3VycmVudF9kaXJfbmFtZSQyIiwicGFyZW50X2Rpcl9uYW1lJDIiLCJkaXJfc2VwJDIiLCJpc19kaXJfc2VwJDEiLCJpc19yZWxhdGl2ZSQxIiwiaXNfaW1wbGljaXQkMSIsImNoZWNrX3N1ZmZpeCQxIiwidGVtcF9kaXJfbmFtZSQwIiwicXVvdGUkMSIsImJhc2VuYW1lJDIiLCJkaXJuYW1lJDIiLCJjb25jYXQkMiIsImNob3Bfc3VmZml4IiwiZXh0ZW5zaW9uX2xlbiIsImV4dGVuc2lvbiIsImNob3BfZXh0ZW5zaW9uIiwicmVtb3ZlX2V4dGVuc2lvbiIsInBybmckMCIsInRlbXBfZmlsZV9uYW1lIiwidGVtcF9kaXIiLCJybmQiLCJjdXJyZW50X3RlbXBfZGlyX25hbWUiLCJzZXRfdGVtcF9kaXJfbmFtZSIsImdldF90ZW1wX2Rpcl9uYW1lIiwidGVtcF9maWxlIiwidHJ5X25hbWUiLCJjb3VudGVyJDEiLCJvcGVuX3RlbXBfZmlsZSIsInN0aCQwIiwicGVybXMiLCJzdGgkMSIsImFkZCQxIiwic3ViJDMiLCJuZWciLCJjb25qIiwibXVsIiwiZGl2IiwiaW52Iiwibm9ybTIiLCJub3JtIiwicSQwIiwicG9sYXIiLCJzcXJ0IiwidyQwIiwiZXhwIiwibG9nIiwicG93IiwiZW5hYmxlZCIsImlmX3NwYWNldGltZV9lbmFibGVkIiwiY3JlYXRlJDciLCJjaGFubmVsIiwic2F2ZV9ldmVudCIsInRpbWUiLCJldmVudF9uYW1lIiwic2F2ZV9hbmRfY2xvc2UiLCJ0YWtlJDAiLCJjbG9zZWQiLCJzYXZlX2V2ZW50X2Zvcl9hdXRvbWF0aWNfc25hcHNob3RzIiwibm9yYW5nZSIsImxpbmVfb2ZfcG9zIiwibCIsImNvbF9vZl9wb3MiLCJjIiwibWtfcG9zIiwibGluZSIsImNvbCIsImZpbGVfb2ZfcmFuZ2UiLCJmIiwic3RhcnRfb2ZfcmFuZ2UiLCJzIiwiZW5kX29mX3JhbmdlIiwiZSIsIm1rX3JhbmdlIiwidmFsaWRfcG9zIiwibWVyZ2VfcmFuZ2UiLCJyMSIsInIyIiwiZTIiLCJzMiIsImUxIiwiczEiLCJmJDAiLCJzdHJpbmdfb2ZfcmFuZ2UiLCJlYyIsImVsIiwic2MiLCJzbCIsIm1sX3N0cmluZ19vZl9yYW5nZSIsInBvc19vZl9sZXhwb3MiLCJwIiwibWtfbGV4X3JhbmdlIiwicDEiLCJwMiIsImxleF9yYW5nZSIsImxleGJ1ZiIsIm5vX2xvYyIsIngiLCJkZWZhdWx0X3JlZHVjdGlvbiIsImVycm9yIiwiYWN0aW9uIiwibGhzIiwiZ290byQwIiwiRXJyb3IiLCJsb2MiLCJzdGFydHBvcyIsImVuZHBvcyIsImVsdCIsInRva2VuMnRlcm1pbmFsIiwidG9rIiwiZXJyb3JfdGVybWluYWwiLCJ0b2tlbjJ2YWx1ZSIsInYiLCJ2JDAiLCJ2JDEiLCJzdGFydCIsIm1lbmhpcl9lbnYiLCJtZW5oaXJfc3RhY2siLCJtZW5oaXJfc3RhY2skMCIsImVuZHBvc194cyIsInN0YXJ0cG9zX3hzIiwieHMiLCJtZW5oaXJfcyIsInN0YXJ0cG9zXzEiLCJpZCIsImVuZHBvc19pbml0IiwiaW5pdCIsInN0YXJ0cG9zX3QiLCJ0IiwiZW5kcG9zXzMiLCJyIiwiZW5kcG9zXzEiLCJzdGFydHBvc19zIiwicyIsImVuZHBvc18yIiwiZW5kcG9zX3MiLCJkcyIsImUiLCJlbmRwb3NfYiIsImIiLCJlbmRwb3NfaWZzIiwic3RhcnRwb3NfaWZzIiwiaWZzIiwic3RhcnRwb3NfZSIsImVuZHBvc181Iiwic3RhcnRwb3NfcCIsInAiLCJlbmRwb3NfNCIsInN0YXJ0cG9zX2QiLCJkIiwic3RhcnRwb3NfeCIsIngiLCJlbmRwb3NfeCIsInkiLCJ4JDAiLCJlbmRwb3NfeSIsImkiLCJlbmRwb3NfaWQiLCJzdGFydHBvc19pZCIsImIxIiwiZW5kcG9zX2IyIiwiYjIiLCJlbmRwb3NfNyIsInQkMCIsImVuZHBvc19pIiwic3RhcnRwb3NfaSIsImVuZHBvc19lIiwic3RhcnRwb3NfZTEiLCJlMSIsImVuZHBvc19lMiIsImUyIiwiZm5hbWUiLCJhcmdzIiwiZW5kcG9zX2JvZHkiLCJib2R5IiwiZnJ0eXAiLCJuYW1lIiwic3RtdHMiLCJzZW1hbnRpY19hY3Rpb24iLCJzdG10X3RvcCIsImxleGVyIiwibGV4YnVmIiwicHJvZyIsImV4cF90b3AiLCJzdG10X3RvcCQwIiwiaW5pdGlhbF9wb3NpdGlvbiIsInByb2ckMCIsImV4cF90b3AkMCIsInJlc2VydmVkX3dvcmRzIiwib2NhbWxfbGV4X3RhYmxlcyIsInJlc2V0X2xleGJ1ZiIsImZpbGVuYW1lIiwibG51bSIsImxleGJ1ZiIsIm5ld2xpbmUiLCJ1bmV4cGVjdGVkX2NoYXIiLCJjIiwic3ltYm9sX3RhYmxlIiwidCIsInN0ciIsImNyZWF0ZV90b2tlbiIsInN0cmluZ19idWZmZXIiLCJzdHJpbmdfZW5kIiwic3RhcnRfbGV4Iiwic3RhcnRfcG9zX29mX2xleGJ1ZiIsImxleF9sb25nX3JhbmdlIiwiZW5kX3AiLCJyZXNldF9zdHIiLCJhZGRfc3RyIiwiY2giLCJ4IiwiYnVmZmVyIiwibmV3X2J1ZmZlciIsImdldF9zdHIiLCJ0b2tlbiQwIiwib2NhbWxfbGV4X3Rva2VuX3JlYyQwIiwib2NhbWxfbGV4X3N0YXRlIiwib2NhbWxfbGV4X3N0YXRlJDAiLCJvY2FtbF9sZXhfc3RhdGUkMSIsImNvbW1lbnRzJDAiLCJzdHJpbmckMCIsInAiLCJkaXJlY3RpdmUkMCIsInN0YXRlIiwib2NhbWxfbGV4X2RpcmVjdGl2ZV9yZWMkMCIsImxldmVsIiwib2NhbWxfbGV4X2NvbW1lbnRzX3JlYyQwIiwiaW5fZGlyZWN0aXZlIiwib2NhbWxfbGV4X3N0cmluZ19yZWMkMCIsImVzY2FwZWQiLCJ0b2tlbiIsIm9jYW1sX2xleF90b2tlbl9yZWMiLCJkaXJlY3RpdmUiLCJvY2FtbF9sZXhfZGlyZWN0aXZlX3JlYyIsImNvbW1lbnRzIiwib2NhbWxfbGV4X2NvbW1lbnRzX3JlYyIsInN0cmluZyIsIm9jYW1sX2xleF9zdHJpbmdfcmVjIiwib2NhbWxfbGV4X2VzY2FwZWRfcmVjIiwicmVhZF9maWxlIiwiZmlsZW5hbWUiLCJsaW5lcyIsImNoYW5uZWwiLCJzdWNjZWVkIiwicmVjb3Zlcl9mcm9tX2Vycm9yIiwic3VwcGxpZXIiLCJkZXB0aCIsImRlcHRoJDAiLCJkZXB0aCQxIiwic3RvcCIsInN0YXJ0Iiwic3RvcCQwIiwic3RhcnQkMCIsImZhaWwiLCJsZXhidWYiLCJiYWNrZWRfdXAiLCJiIiwiYSIsImZpbmRfZXJyb3JzIiwicmVzdWx0IiwiZmlsdGVyX21hcCIsImwiLCJsJDAiLCJ0bCIsIngiLCJsJDEiLCJwcmludF9lcnJvciIsImxvYyIsImpzX29mX3JhbmdlIiwianNfb2ZfcG9zIiwicG9zIiwiY2hhciQwIiwibGluZSIsImZpbmlzaCIsImZpbGUiLCJtYWluIiwiZmlsZXMiXSwibWFwcGluZ3MiOiI7Ozs7SUFvRkEsU0FBU0EsbUJBQW1CQyxHQUMxQixRQUFRQSxPQUFLQSxPQUFLQSxVQUNwQjtJQ3JDQSxTQUFTQyxnQkFBZ0JDLEVBQUdDO01BQzFCLEdBQUdELE9BQVE7TUFDWCxHQUFJQyxTQUFVLE9BQVEsU0FBU0Q7TUFDL0IsSUFBTSxLQUFRO01BQ2QsR0FBSUEsT0FBUSxPQUFPRTtNQUNuQjtPQUFRLENBQ04sR0FBSUYsTUFBT0UsS0FBS0Q7UUFDaEJEO1FBQ0EsR0FBSUEsT0FBUSxPQUFPRTtRQUNuQkQsS0FBS0E7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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztVOzs7Ozs7O0lRN0IxQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0NrQkt3N0I7S0FDQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQzRHQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0NwRkFDO0tBQ0FDO0tBQ0FDO0tBSUFDO0tBQ0FDOzs7O0tDekJBQztLQW9IQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tDeTdFTUM7S0FRUUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQzFqRmRDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQ3FERUM7S0FDQUM7S0FDQUM7OztLQTNEWUM7S0E4RVpDO0tBQ0FDO0tBQ0FDOzs7S0ErREFDO0tBQ0FDO0tBQ0FDOzs7S0M3SUZDO0tBQ0FDO0tBQ0FDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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Y0FKRU07T0FHSCxjQUhKdkI7TUFFRyx3REFHVDthQUVGeUIsS0FBS0M7TUFDUDt5REFET0E7T0FDUDsrQkFuQ0VsQjtPQW1DRjsrQkFoQkVVO01BZ0JGLDREQU00QjtzQkFLVFEsT0FBUSxZQUFSQSxNQUFrQjtJQUZyQzs7Ozs7O09BMUZFckM7T0FZQUk7T0FJSUM7T0FxQkFTO09BU0pLO09BU0lFO09BTUpNO09BSUFFO09BZUFPO0lBVUY7VUQ5RkgiLCJzb3VyY2VzIjpbIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvanNfb2Zfb2NhbWwtY29tcGlsZXIvaW50NjQuanMiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL2pzX29mX29jYW1sLWNvbXBpbGVyL21sU3RyaW5nLmpzIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9qc19vZl9vY2FtbC1jb21waWxlci9zdGRsaWIuanMiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL2pzX29mX29jYW1sLWNvbXBpbGVyL2llZWVfNzU0LmpzIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9qc19vZl9vY2FtbC1jb21waWxlci9mcy5qcyIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvanNfb2Zfb2NhbWwtY29tcGlsZXIvZnNfZmFrZS5qcyIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvanNfb2Zfb2NhbWwtY29tcGlsZXIvZnNfbm9kZS5qcyIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvanNfb2Zfb2NhbWwtY29tcGlsZXIvbmF0LmpzIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9qc19vZl9vY2FtbC1jb21waWxlci9tYXJzaGFsLmpzIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9qc19vZl9vY2FtbC1jb21waWxlci9pby5qcyIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvanNfb2Zfb2NhbWwtY29tcGlsZXIvZ2MuanMiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL2pzX29mX29jYW1sLWNvbXBpbGVyL2JpZ2FycmF5LmpzIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9qc19vZl9vY2FtbC1jb21waWxlci9wYXJzaW5nLmpzIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9qc19vZl9vY2FtbC1jb21waWxlci91bml4LmpzIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9qc19vZl9vY2FtbC1jb21waWxlci9qc2xpYl9qc19vZl9vY2FtbC5qcyIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvanNfb2Zfb2NhbWwtY29tcGlsZXIvanNsaWIuanMiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL2pzX29mX29jYW1sLWNvbXBpbGVyL2ludGVybmFsTW9kLmpzIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9qc19vZl9vY2FtbC1jb21waWxlci9iaWdzdHJpbmcuanMiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL2pzX29mX29jYW1sLWNvbXBpbGVyL2xleGluZy5qcyIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvanNfb2Zfb2NhbWwtY29tcGlsZXIvd2Vhay5qcyIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvanNfb2Zfb2NhbWwtY29tcGlsZXIvbWQ1LmpzIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9qc19vZl9vY2FtbC1jb21waWxlci9iaWdzdHJpbmctY3N0cnVjdC5qcyIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvanNfb2Zfb2NhbWwtY29tcGlsZXIvcG9seWZpbGwvanNvbjIuanMiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL29jYW1sL3VjaGFyLm1sIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9vY2FtbC9zeXMubWwiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL29jYW1sL2ludDY0Lm1sIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9vY2FtbC9sZXhpbmcubWwiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL29jYW1sL2NhbWxpbnRlcm5hbEZvcm1hdC5tbCIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvb2NhbWwvcHJpbnRleGMubWwiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL29jYW1sL2ZpbGVuYW1lLm1sIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9vY2FtbC9jb21wbGV4Lm1sIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9vY2FtbC9jYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MubWwiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL29jYW1sL3BlcnZhc2l2ZXMubWwiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL29jYW1sL2xpc3QubWwiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL29jYW1sL2NoYXIubWwiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL29jYW1sL2J5dGVzLm1sIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9vY2FtbC9zdHJpbmcubWwiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL29jYW1sL25hdGl2ZWludC5tbCIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvb2NhbWwvc29ydC5tbCIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvb2NhbWwvbWFyc2hhbC5tbCIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvb2NhbWwvb2JqLm1sIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9vY2FtbC9hcnJheS5tbCIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvb2NhbWwvaW50MzIubWwiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL29jYW1sL3BhcnNpbmcubWwiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL29jYW1sL3NldC5tbCIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvb2NhbWwvbWFwLm1sIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9vY2FtbC9zdGFjay5tbCIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvb2NhbWwvcXVldWUubWwiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL29jYW1sL2NhbWxpbnRlcm5hbExhenkubWwiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL29jYW1sL2xhenkubWwiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL29jYW1sL3N0cmVhbS5tbCIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvb2NhbWwvYnVmZmVyLm1sIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9vY2FtbC9wcmludGYubWwiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL29jYW1sL2FyZy5tbCIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvb2NhbWwvZ2MubWwiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL29jYW1sL2RpZ2VzdC5tbCIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvb2NhbWwvcmFuZG9tLm1sIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9vY2FtbC9oYXNodGJsLm1sIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9vY2FtbC93ZWFrLm1sIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9vY2FtbC9mb3JtYXQubWwiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL29jYW1sL3NjYW5mLm1sIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9vY2FtbC9jYWxsYmFjay5tbCIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvb2NhbWwvY2FtbGludGVybmFsT08ubWwiLCIvaG9tZS90aWdhci8ub3BhbS80LjA2LjAvbGliL29jYW1sL2dlbmxleC5tbCIsIi9ob21lL3RpZ2FyLy5vcGFtLzQuMDYuMC9saWIvb2NhbWwvZXBoZW1lcm9uLm1sIiwiL2hvbWUvdGlnYXIvLm9wYW0vNC4wNi4wL2xpYi9vY2FtbC9zcGFjZXRpbWUubWwiLCIvaG9tZS90aWdhci9DT1NfMzIwL19idWlsZC9kZWZhdWx0L2h3MDMvdXRpbC9yYW5nZS5tbCIsIi9ob21lL3RpZ2FyL0NPU18zMjAvX2J1aWxkL2RlZmF1bHQvaHcwMy9hc3QubWwiLCIvaG9tZS90aWdhci9DT1NfMzIwL19idWlsZC9kZWZhdWx0L2h3MDMvcGFyc2VyLm1sIiwiL2hvbWUvdGlnYXIvQ09TXzMyMC9fYnVpbGQvZGVmYXVsdC9odzAzL3BhcnNlci5tbHkiLCIvaG9tZS90aWdhci9DT1NfMzIwL19idWlsZC9kZWZhdWx0L2h3MDMvbGV4ZXIubWxsIiwiL2hvbWUvdGlnYXIvQ09TXzMyMC9fYnVpbGQvZGVmYXVsdC9odzAzL2xleGVyLm1sIiwiL2hvbWUvdGlnYXIvQ09TXzMyMC9fYnVpbGQvZGVmYXVsdC9odzAzL3NlcnZlci5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZmZzZXRcbnZhciBjYW1sX2ludDY0X29mZnNldCA9IE1hdGgucG93KDIsIC0yNCk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdWNvbXBhcmUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdWNvbXBhcmUoeCx5KSB7XG4gIGlmICh4WzNdID4geVszXSkgcmV0dXJuIDE7XG4gIGlmICh4WzNdIDwgeVszXSkgcmV0dXJuIC0xO1xuICBpZiAoeFsyXSA+IHlbMl0pIHJldHVybiAxO1xuICBpZiAoeFsyXSA8IHlbMl0pIHJldHVybiAtMTtcbiAgaWYgKHhbMV0gPiB5WzFdKSByZXR1cm4gMTtcbiAgaWYgKHhbMV0gPCB5WzFdKSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3VsdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF91Y29tcGFyZVxuZnVuY3Rpb24gY2FtbF9pbnQ2NF91bHQoeCx5KSB7IHJldHVybiBjYW1sX2ludDY0X3Vjb21wYXJlKHgseSkgPCAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfY29tcGFyZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9jb21wYXJlKHgseSkge1xuICB2YXIgeDMgPSB4WzNdIDw8IDE2O1xuICB2YXIgeTMgPSB5WzNdIDw8IDE2O1xuICBpZiAoeDMgPiB5MykgcmV0dXJuIDE7XG4gIGlmICh4MyA8IHkzKSByZXR1cm4gLTE7XG4gIGlmICh4WzJdID4geVsyXSkgcmV0dXJuIDE7XG4gIGlmICh4WzJdIDwgeVsyXSkgcmV0dXJuIC0xO1xuICBpZiAoeFsxXSA+IHlbMV0pIHJldHVybiAxO1xuICBpZiAoeFsxXSA8IHlbMV0pIHJldHVybiAtMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbmVnIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X25lZyAoeCkge1xuICB2YXIgeTEgPSAtIHhbMV07XG4gIHZhciB5MiA9IC0geFsyXSArICh5MSA+PiAyNCk7XG4gIHZhciB5MyA9IC0geFszXSArICh5MiA+PiAyNCk7XG4gIHJldHVybiBbMjU1LCB5MSAmIDB4ZmZmZmZmLCB5MiAmIDB4ZmZmZmZmLCB5MyAmIDB4ZmZmZl07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfYWRkIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2FkZCAoeCwgeSkge1xuICB2YXIgejEgPSB4WzFdICsgeVsxXTtcbiAgdmFyIHoyID0geFsyXSArIHlbMl0gKyAoejEgPj4gMjQpO1xuICB2YXIgejMgPSB4WzNdICsgeVszXSArICh6MiA+PiAyNCk7XG4gIHJldHVybiBbMjU1LCB6MSAmIDB4ZmZmZmZmLCB6MiAmIDB4ZmZmZmZmLCB6MyAmIDB4ZmZmZl07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc3ViIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3N1YiAoeCwgeSkge1xuICB2YXIgejEgPSB4WzFdIC0geVsxXTtcbiAgdmFyIHoyID0geFsyXSAtIHlbMl0gKyAoejEgPj4gMjQpO1xuICB2YXIgejMgPSB4WzNdIC0geVszXSArICh6MiA+PiAyNCk7XG4gIHJldHVybiBbMjU1LCB6MSAmIDB4ZmZmZmZmLCB6MiAmIDB4ZmZmZmZmLCB6MyAmIDB4ZmZmZl07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbXVsIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mZnNldFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9tdWwoeCx5KSB7XG4gIHZhciB6MSA9IHhbMV0gKiB5WzFdO1xuICB2YXIgejIgPSAoKHoxICogY2FtbF9pbnQ2NF9vZmZzZXQpIHwgMCkgKyB4WzJdICogeVsxXSArIHhbMV0gKiB5WzJdO1xuICB2YXIgejMgPSAoKHoyICogY2FtbF9pbnQ2NF9vZmZzZXQpIHwgMCkgKyB4WzNdICogeVsxXSArIHhbMl0gKiB5WzJdICsgeFsxXSAqIHlbM107XG4gIHJldHVybiBbMjU1LCB6MSAmIDB4ZmZmZmZmLCB6MiAmIDB4ZmZmZmZmLCB6MyAmIDB4ZmZmZl07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaXNfemVybyBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9pc196ZXJvKHgpIHtcbiAgcmV0dXJuICh4WzNdfHhbMl18eFsxXSkgPT0gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSh4KSB7XG4gIHJldHVybiAoeFszXSA8PCAxNikgPCAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2lzX21pbl9pbnQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfaXNfbWluX2ludCh4KSB7XG4gIHJldHVybiB4WzNdID09IDB4ODAwMCAmJiAoeFsxXXx4WzJdKSA9PSAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2lzX21pbnVzX29uZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9pc19taW51c19vbmUoeCkge1xuICByZXR1cm4geFszXSA9PSAweGZmZmYgJiYgKHhbMV0meFsyXSkgPT0gMHhmZmZmZmY7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfYW5kIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2FuZCAoeCwgeSkge1xuICByZXR1cm4gWzI1NSwgeFsxXSZ5WzFdLCB4WzJdJnlbMl0sIHhbM10meVszXV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb3IgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb3IgKHgsIHkpIHtcbiAgcmV0dXJuIFsyNTUsIHhbMV18eVsxXSwgeFsyXXx5WzJdLCB4WzNdfHlbM11dO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3hvciBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF94b3IgKHgsIHkpIHtcbiAgcmV0dXJuIFsyNTUsIHhbMV1eeVsxXSwgeFsyXV55WzJdLCB4WzNdXnlbM11dO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3NoaWZ0X2xlZnQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc2hpZnRfbGVmdCAoeCwgcykge1xuICBzID0gcyAmIDYzO1xuICBpZiAocyA9PSAwKSByZXR1cm4geDtcbiAgaWYgKHMgPCAyNClcbiAgICByZXR1cm4gWzI1NSxcbiAgICAgICAgICAgICh4WzFdIDw8IHMpICYgMHhmZmZmZmYsXG4gICAgICAgICAgICAoKHhbMl0gPDwgcykgfCAoeFsxXSA+PiAoMjQgLSBzKSkpICYgMHhmZmZmZmYsXG4gICAgICAgICAgICAoKHhbM10gPDwgcykgfCAoeFsyXSA+PiAoMjQgLSBzKSkpICYgMHhmZmZmXTtcbiAgaWYgKHMgPCA0OClcbiAgICByZXR1cm4gWzI1NSwgMCxcbiAgICAgICAgICAgICh4WzFdIDw8IChzIC0gMjQpKSAmIDB4ZmZmZmZmLFxuICAgICAgICAgICAgKCh4WzJdIDw8IChzIC0gMjQpKSB8ICh4WzFdID4+ICg0OCAtIHMpKSkgJiAweGZmZmZdO1xuICByZXR1cm4gWzI1NSwgMCwgMCwgKHhbMV0gPDwgKHMgLSA0OCkpICYgMHhmZmZmXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCAoeCwgcykge1xuICBzID0gcyAmIDYzO1xuICBpZiAocyA9PSAwKSByZXR1cm4geDtcbiAgaWYgKHMgPCAyNClcbiAgICByZXR1cm4gWzI1NSxcbiAgICAgICAgICAgICgoeFsxXSA+PiBzKSB8ICh4WzJdIDw8ICgyNCAtIHMpKSkgJiAweGZmZmZmZixcbiAgICAgICAgICAgICgoeFsyXSA+PiBzKSB8ICh4WzNdIDw8ICgyNCAtIHMpKSkgJiAweGZmZmZmZixcbiAgICAgICAgICAgICh4WzNdID4+IHMpXTtcbiAgaWYgKHMgPCA0OClcbiAgICByZXR1cm4gWzI1NSxcbiAgICAgICAgICAgICgoeFsyXSA+PiAocyAtIDI0KSkgfCAoeFszXSA8PCAoNDggLSBzKSkpICYgMHhmZmZmZmYsXG4gICAgICAgICAgICAoeFszXSA+PiAocyAtIDI0KSksXG4gICAgICAgICAgICAwXTtcbiAgcmV0dXJuIFsyNTUsICh4WzNdID4+IChzIC0gNDgpKSwgMCwgMF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc2hpZnRfcmlnaHQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc2hpZnRfcmlnaHQgKHgsIHMpIHtcbiAgcyA9IHMgJiA2MztcbiAgaWYgKHMgPT0gMCkgcmV0dXJuIHg7XG4gIHZhciBoID0gKHhbM10gPDwgMTYpID4+IDE2O1xuICBpZiAocyA8IDI0KVxuICAgIHJldHVybiBbMjU1LFxuICAgICAgICAgICAgKCh4WzFdID4+IHMpIHwgKHhbMl0gPDwgKDI0IC0gcykpKSAmIDB4ZmZmZmZmLFxuICAgICAgICAgICAgKCh4WzJdID4+IHMpIHwgKGggPDwgKDI0IC0gcykpKSAmIDB4ZmZmZmZmLFxuICAgICAgICAgICAgKCh4WzNdIDw8IDE2KSA+PiBzKSA+Pj4gMTZdO1xuICB2YXIgc2lnbiA9ICh4WzNdIDw8IDE2KSA+PiAzMTtcbiAgaWYgKHMgPCA0OClcbiAgICByZXR1cm4gWzI1NSxcbiAgICAgICAgICAgICgoeFsyXSA+PiAocyAtIDI0KSkgfCAoeFszXSA8PCAoNDggLSBzKSkpICYgMHhmZmZmZmYsXG4gICAgICAgICAgICAoKHhbM10gPDwgMTYpID4+IChzIC0gMjQpID4+IDE2KSAmIDB4ZmZmZmZmLFxuICAgICAgICAgICAgc2lnbiAmIDB4ZmZmZl07XG4gIHJldHVybiBbMjU1LFxuICAgICAgICAgICgoeFszXSA8PCAxNikgPj4gKHMgLSAzMikpICYgMHhmZmZmZmYsXG4gICAgICAgICAgc2lnbiAmIDB4ZmZmZmZmLCBzaWduICYgMHhmZmZmXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9sc2wxIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2xzbDEgKHgpIHtcbiAgeFszXSA9ICh4WzNdIDw8IDEpIHwgKHhbMl0gPj4gMjMpO1xuICB4WzJdID0gKCh4WzJdIDw8IDEpIHwgKHhbMV0gPj4gMjMpKSAmIDB4ZmZmZmZmO1xuICB4WzFdID0gKHhbMV0gPDwgMSkgJiAweGZmZmZmZjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9sc3IxIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2xzcjEgKHgpIHtcbiAgeFsxXSA9ICgoeFsxXSA+Pj4gMSkgfCAoeFsyXSA8PCAyMykpICYgMHhmZmZmZmY7XG4gIHhbMl0gPSAoKHhbMl0gPj4+IDEpIHwgKHhbM10gPDwgMjMpKSAmIDB4ZmZmZmZmO1xuICB4WzNdID0geFszXSA+Pj4gMTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF91ZGl2bW9kIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3Vjb21wYXJlLCBjYW1sX2ludDY0X2xzbDEsIGNhbWxfaW50NjRfbHNyMVxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9zdWJcbi8vUmVxdWlyZXM6IGNhbWxfb2JqX2R1cFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF91ZGl2bW9kICh4LCB5KSB7XG4gIHZhciBvZmZzZXQgPSAwO1xuICB2YXIgbW9kdWx1cyA9IGNhbWxfb2JqX2R1cCh4KTtcbiAgdmFyIGRpdmlzb3IgPSBjYW1sX29ial9kdXAoeSk7XG4gIHZhciBxdW90aWVudCA9IFsyNTUsIDAsIDAsIDBdO1xuICB3aGlsZSAoY2FtbF9pbnQ2NF91Y29tcGFyZSAobW9kdWx1cywgZGl2aXNvcikgPiAwKSB7XG4gICAgb2Zmc2V0Kys7XG4gICAgY2FtbF9pbnQ2NF9sc2wxIChkaXZpc29yKTtcbiAgfVxuICB3aGlsZSAob2Zmc2V0ID49IDApIHtcbiAgICBvZmZzZXQgLS07XG4gICAgY2FtbF9pbnQ2NF9sc2wxIChxdW90aWVudCk7XG4gICAgaWYgKGNhbWxfaW50NjRfdWNvbXBhcmUgKG1vZHVsdXMsIGRpdmlzb3IpID49IDApIHtcbiAgICAgIHF1b3RpZW50WzFdICsrO1xuICAgICAgbW9kdWx1cyA9IGNhbWxfaW50NjRfc3ViIChtb2R1bHVzLCBkaXZpc29yKTtcbiAgICB9XG4gICAgY2FtbF9pbnQ2NF9sc3IxIChkaXZpc29yKTtcbiAgfVxuICByZXR1cm4gWzAscXVvdGllbnQsIG1vZHVsdXNdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2RpdiBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9pc196ZXJvLCBjYW1sX3JhaXNlX3plcm9fZGl2aWRlXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X25lZywgY2FtbF9pbnQ2NF91ZGl2bW9kXG5mdW5jdGlvbiBjYW1sX2ludDY0X2RpdiAoeCwgeSlcbntcbiAgaWYgKGNhbWxfaW50NjRfaXNfemVybyAoeSkpIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHZhciBzaWduID0geFszXSBeIHlbM107XG4gIGlmICh4WzNdICYgMHg4MDAwKSB4ID0gY2FtbF9pbnQ2NF9uZWcoeCk7XG4gIGlmICh5WzNdICYgMHg4MDAwKSB5ID0gY2FtbF9pbnQ2NF9uZWcoeSk7XG4gIHZhciBxID0gY2FtbF9pbnQ2NF91ZGl2bW9kKHgsIHkpWzFdO1xuICBpZiAoc2lnbiAmIDB4ODAwMCkgcSA9IGNhbWxfaW50NjRfbmVnKHEpO1xuICByZXR1cm4gcTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9tb2QgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfaXNfemVybywgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9uZWcsIGNhbWxfaW50NjRfdWRpdm1vZFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9tb2QgKHgsIHkpXG57XG4gIGlmIChjYW1sX2ludDY0X2lzX3plcm8gKHkpKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpO1xuICB2YXIgc2lnbiA9IHhbM107XG4gIGlmICh4WzNdICYgMHg4MDAwKSB4ID0gY2FtbF9pbnQ2NF9uZWcoeCk7XG4gIGlmICh5WzNdICYgMHg4MDAwKSB5ID0gY2FtbF9pbnQ2NF9uZWcoeSk7XG4gIHZhciByID0gY2FtbF9pbnQ2NF91ZGl2bW9kKHgsIHkpWzJdO1xuICBpZiAoc2lnbiAmIDB4ODAwMCkgciA9IGNhbWxfaW50NjRfbmVnKHIpO1xuICByZXR1cm4gcjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZl9pbnQzMiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vZl9pbnQzMiAoeCkge1xuICByZXR1cm4gWzI1NSwgeCAmIDB4ZmZmZmZmLCAoeCA+PiAyNCkgJiAweGZmZmZmZiwgKHggPj4gMzEpICYgMHhmZmZmXVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3RvX2ludDMyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3RvX2ludDMyICh4KSB7XG4gIHJldHVybiB4WzFdIHwgKHhbMl0gPDwgMjQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3RvX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3RvX2Zsb2F0ICh4KSB7XG4gIHJldHVybiAoKHhbM10gPDwgMTYpICogTWF0aC5wb3coMiwgMzIpICsgeFsyXSAqIE1hdGgucG93KDIsIDI0KSkgKyB4WzFdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mZnNldFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vZl9mbG9hdCAoeCkge1xuICBpZiAoeCA8IDApIHggPSBNYXRoLmNlaWwoeCk7XG4gIHJldHVybiBbMjU1LFxuICAgICAgICAgIHggJiAweGZmZmZmZixcbiAgICAgICAgICBNYXRoLmZsb29yKHggKiBjYW1sX2ludDY0X29mZnNldCkgJiAweGZmZmZmZixcbiAgICAgICAgICBNYXRoLmZsb29yKHggKiBjYW1sX2ludDY0X29mZnNldCAqIGNhbWxfaW50NjRfb2Zmc2V0KSAmIDB4ZmZmZl07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfZm9ybWF0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX2Zvcm1hdCwgY2FtbF9maW5pc2hfZm9ybWF0dGluZ1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSwgY2FtbF9pbnQ2NF9uZWdcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfaW50MzIsIGNhbWxfaW50NjRfdWRpdm1vZCwgY2FtbF9pbnQ2NF90b19pbnQzMlxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9pc196ZXJvLCBjYW1sX3N0cl9yZXBlYXRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfZm9ybWF0IChmbXQsIHgpIHtcbiAgdmFyIGYgPSBjYW1sX3BhcnNlX2Zvcm1hdChmbXQpO1xuICBpZiAoZi5zaWduZWRjb252ICYmIGNhbWxfaW50NjRfaXNfbmVnYXRpdmUoeCkpIHtcbiAgICBmLnNpZ24gPSAtMTsgeCA9IGNhbWxfaW50NjRfbmVnKHgpO1xuICB9XG4gIHZhciBidWZmZXIgPSBcIlwiO1xuICB2YXIgd2Jhc2UgPSBjYW1sX2ludDY0X29mX2ludDMyKGYuYmFzZSk7XG4gIHZhciBjdnRibCA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuICBkbyB7XG4gICAgdmFyIHAgPSBjYW1sX2ludDY0X3VkaXZtb2QoeCwgd2Jhc2UpO1xuICAgIHggPSBwWzFdO1xuICAgIGJ1ZmZlciA9IGN2dGJsLmNoYXJBdChjYW1sX2ludDY0X3RvX2ludDMyKHBbMl0pKSArIGJ1ZmZlcjtcbiAgfSB3aGlsZSAoISBjYW1sX2ludDY0X2lzX3plcm8oeCkpO1xuICBpZiAoZi5wcmVjID49IDApIHtcbiAgICBmLmZpbGxlciA9ICcgJztcbiAgICB2YXIgbiA9IGYucHJlYyAtIGJ1ZmZlci5sZW5ndGg7XG4gICAgaWYgKG4gPiAwKSBidWZmZXIgPSBjYW1sX3N0cl9yZXBlYXQgKG4sICcwJykgKyBidWZmZXI7XG4gIH1cbiAgcmV0dXJuIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcoZiwgYnVmZmVyKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSwgY2FtbF9mYWlsd2l0aCwgY2FtbF9wYXJzZV9kaWdpdCwgTWxCeXRlc1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9pbnQzMiwgY2FtbF9pbnQ2NF91ZGl2bW9kLCBjYW1sX2ludDY0X3VsdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9hZGQsIGNhbWxfaW50NjRfbXVsLCBjYW1sX2ludDY0X25lZ1xuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb2Zfc3RyaW5nKHMpIHtcbiAgdmFyIHIgPSBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UgKHMpO1xuICB2YXIgaSA9IHJbMF0sIHNpZ24gPSByWzFdLCBiYXNlID0gclsyXTtcbiAgdmFyIGJhc2U2NCA9IGNhbWxfaW50NjRfb2ZfaW50MzIoYmFzZSk7XG4gIHZhciB0aHJlc2hvbGQgPVxuICAgICAgY2FtbF9pbnQ2NF91ZGl2bW9kKFsyNTUsIDB4ZmZmZmZmLCAweGZmZmZmZmYsIDB4ZmZmZl0sIGJhc2U2NClbMV07XG4gIHZhciBjID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTtcbiAgdmFyIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgdmFyIHJlcyA9IGNhbWxfaW50NjRfb2ZfaW50MzIoZCk7XG4gIGZvciAoOzspIHtcbiAgICBpKys7XG4gICAgYyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSk7XG4gICAgaWYgKGMgPT0gOTUpIGNvbnRpbnVlO1xuICAgIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICAgIGlmIChkIDwgMCB8fCBkID49IGJhc2UpIGJyZWFrO1xuICAgIC8qIERldGVjdCBvdmVyZmxvdyBpbiBtdWx0aXBsaWNhdGlvbiBiYXNlICogcmVzICovXG4gICAgaWYgKGNhbWxfaW50NjRfdWx0KHRocmVzaG9sZCwgcmVzKSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gICAgZCA9IGNhbWxfaW50NjRfb2ZfaW50MzIoZCk7XG4gICAgcmVzID0gY2FtbF9pbnQ2NF9hZGQoY2FtbF9pbnQ2NF9tdWwoYmFzZTY0LCByZXMpLCBkKTtcbiAgICAvKiBEZXRlY3Qgb3ZlcmZsb3cgaW4gYWRkaXRpb24gKGJhc2UgKiByZXMpICsgZCAqL1xuICAgIGlmIChjYW1sX2ludDY0X3VsdChyZXMsIGQpKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgfVxuICBpZiAoaSAhPSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICBpZiAoclsyXSA9PSAxMCAmJiBjYW1sX2ludDY0X3VsdChbMjU1LCAwLCAwLCAweDgwMDBdLCByZXMpKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICBpZiAoc2lnbiA8IDApIHJlcyA9IGNhbWxfaW50NjRfbmVnKHJlcyk7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpXG5mdW5jdGlvbiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaShsbywgbWksIGhpKXtcbiAgcmV0dXJuIFsyNTUsIGxvLCBtaSwgaGldXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2NyZWF0ZV9sb19oaVxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkobG8sIGhpKXtcbiAgcmV0dXJuIFsyNTUsXG4gICAgICAgICAgbG8gJiAweGZmZmZmZixcbiAgICAgICAgICAoKGxvID4+PiAyNCkgJiAweGZmKSB8ICgoaGkgJiAweGZmZmYpIDw8IDgpLFxuICAgICAgICAgIChoaSA+Pj4gMTYpICYgMHhmZmZmXTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbG8zMiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9sbzMyKHYpe1xuICByZXR1cm4gdlsxXSB8ICgodlsyXSAmIDB4ZmYpIDw8IDI0KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaGkzMiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9oaTMyKHYpe1xuICByZXR1cm4gKCh2WzJdID4+PiA4KSAmIDB4ZmZmZikgfCAodlszXSA8PCAxNik7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vZl9ieXRlcyhhKSB7XG4gIHJldHVybiBbMjU1LCBhWzddIHwgKGFbNl0gPDwgOCkgfCAoYVs1XSA8PCAxNiksXG4gICAgICAgICAgYVs0XSB8IChhWzNdIDw8IDgpIHwgKGFbMl0gPDwgMTYpLCBhWzFdIHwgKGFbMF0gPDwgOCldO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF90b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9pbnQ2NF90b19ieXRlcyh4KSB7XG4gIHJldHVybiBbeFszXSA+PiA4LCB4WzNdICYgMHhmZiwgeFsyXSA+PiAxNiwgKHhbMl0gPj4gOCkgJiAweGZmLCB4WzJdICYgMHhmZixcbiAgICAgICAgICB4WzFdID4+IDE2LCAoeFsxXSA+PiA4KSAmIDB4ZmYsIHhbMV0gJiAweGZmXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9oYXNoXG5mdW5jdGlvbiBjYW1sX2ludDY0X2hhc2goeCl7XG4gIHZhciBsbyA9ICgoeFsxXSAgICAgICkgICAgICAgICApIHwgKCh4WzJdICYgMHhmZikgPDwgMjQpO1xuICB2YXIgaGkgPSAoKHhbMl0gPj4+IDgpICYgMHhmZmZmKSB8ICgoeFszXSAgICAgICApIDw8IDE2KTtcbiAgcmV0dXJuIGxvIF4gaGk7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxNCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLyBBbiBPQ2FtbCBzdHJpbmcgaXMgYW4gb2JqZWN0IHdpdGggdGhyZWUgZmllbGRzOlxuLy8gLSB0YWcgJ3QnXG4vLyAtIGxlbmd0aCAnbCdcbi8vIC0gY29udGVudHMgJ2MnXG4vL1xuLy8gVGhlIGNvbnRlbnRzIG9mIHRoZSBzdHJpbmcgY2FuIGJlIGVpdGhlciBhIEphdmFTY3JpcHQgYXJyYXkgb3Jcbi8vIGEgSmF2YVNjcmlwdCBzdHJpbmcuIFRoZSBsZW5ndGggb2YgdGhpcyBzdHJpbmcgY2FuIGJlIGxlc3MgdGhhbiB0aGVcbi8vIGxlbmd0aCBvZiB0aGUgT0NhbWwgc3RyaW5nLiBJbiB0aGlzIGNhc2UsIHJlbWFpbmluZyBieXRlcyBhcmVcbi8vIGFzc3VtZWQgdG8gYmUgemVyb2VzLiBBcnJheXMgYXJlIG11dGFibGUgYnV0IGNvbnN1bWVzIG1vcmUgbWVtb3J5XG4vLyB0aGFuIHN0cmluZ3MuIEEgY29tbW9uIHBhdHRlcm4gaXMgdG8gc3RhcnQgZnJvbSBhbiBlbXB0eSBzdHJpbmcgYW5kXG4vLyBwcm9ncmVzc2l2ZWx5IGZpbGwgaXQgZnJvbSB0aGUgc3RhcnQuIFBhcnRpYWwgc3RyaW5ncyBtYWtlcyBpdFxuLy8gcG9zc2libGUgdG8gaW1wbGVtZW50IHRoaXMgZWZmaWNpZW50bHkuXG4vL1xuLy8gV2hlbiBjb252ZXJ0aW5nIHRvIGFuZCBmcm9tIFVURi0xNiwgd2Uga2VlcCB0cmFjayBvZiB3aGV0aGVyIHRoZVxuLy8gc3RyaW5nIGlzIGNvbXBvc2VkIG9ubHkgb2YgQVNDSUkgY2hhcmFjdGVycyAoaW4gd2hpY2ggY2FzZSwgbm9cbi8vIGNvbnZlcnNpb24gbmVlZHMgdG8gYmUgcGVyZm9ybWVkKSBvciBub3QuXG4vL1xuLy8gVGhlIHN0cmluZyB0YWcgY2FuIHRodXMgdGFrZSB0aGUgZm9sbG93aW5nIHZhbHVlczpcbi8vICAgZnVsbCBzdHJpbmcgICAgIEJZVEUgfCBVTktOT1dOOiAgICAgIDBcbi8vICAgICAgICAgICAgICAgICAgIEJZVEUgfCBBU0NJSTogICAgICAgIDlcbi8vICAgICAgICAgICAgICAgICAgIEJZVEUgfCBOT1RfQVNDSUk6ICAgIDhcbi8vICAgc3RyaW5nIHByZWZpeCAgIFBBUlRJQUw6ICAgICAgICAgICAgIDJcbi8vICAgYXJyYXkgICAgICAgICAgIEFSUkFZOiAgICAgICAgICAgICAgIDRcbi8vXG4vLyBPbmUgY2FuIHVzZSBiaXQgbWFza2luZyB0byBkaXNjcmltaW5hdGUgdGhlc2UgZGlmZmVyZW50IGNhc2VzOlxuLy8gICBrbm93bl9lbmNvZGluZyh4KSA9IHgmOFxuLy8gICBpc19hc2NpaSh4KSA9ICAgICAgIHgmMVxuLy8gICBraW5kKHgpID0gICAgICAgICAgIHgmNlxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cl9yZXBlYXRcbmZ1bmN0aW9uIGNhbWxfc3RyX3JlcGVhdChuLCBzKSB7XG4gIGlmKG4gPT0gMCkgcmV0dXJuIFwiXCI7XG4gIGlmIChzLnJlcGVhdCkge3JldHVybiBzLnJlcGVhdChuKTt9IC8vIEVDTUFzY3JpcHQgNiBhbmQgRmlyZWZveCAyNCtcbiAgdmFyIHIgPSBcIlwiLCBsID0gMDtcbiAgaWYgKG4gPT0gMCkgcmV0dXJuIHI7XG4gIGZvcig7Oykge1xuICAgIGlmIChuICYgMSkgciArPSBzO1xuICAgIG4gPj49IDE7XG4gICAgaWYgKG4gPT0gMCkgcmV0dXJuIHI7XG4gICAgcyArPSBzO1xuICAgIGwrKztcbiAgICBpZiAobCA9PSA5KSB7XG4gICAgICBzLnNsaWNlKDAsMSk7IC8vIGZsYXR0ZW4gdGhlIHN0cmluZ1xuICAgICAgLy8gdGhlbiwgdGhlIGZsYXR0ZW5pbmcgb2YgdGhlIHdob2xlIHN0cmluZyB3aWxsIGJlIGZhc3RlcixcbiAgICAgIC8vIGFzIGl0IHdpbGwgYmUgY29tcG9zZWQgb2YgbGFyZ2VyIHBpZWNlc1xuICAgIH1cbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N1YmFycmF5X3RvX3N0cmluZ1xuLy9SZXF1aXJlczogcmF3X2FycmF5X3N1YlxuLy9XZWFrZGVmXG4vLyBQcmUgRUNNQVNjcmlwdCA1LCBbYXBwbHldIHdvdWxkIG5vdCBzdXBwb3J0IGFycmF5LWxpa2Ugb2JqZWN0LlxuLy8gSW4gc3VjaCBzZXR1cCwgVHlwZWRfYXJyYXkgd291bGQgYmUgaW1wbGVtZW50ZWQgYXMgcG9seWZpbGwsIGFuZCBbZi5hcHBseV0gd291bGRcbi8vIGZhaWwgaGVyZS4gTWFyayB0aGUgcHJpbWl0aXZlIGFzIFdlYWtkZWYsIHNvIHRoYXQgcGVvcGxlIGNhbiBvdmVycmlkZSBpdCBlYXNpbHkuXG5mdW5jdGlvbiBjYW1sX3N1YmFycmF5X3RvX3N0cmluZyAoYSwgaSwgbGVuKSB7XG4gIHZhciBmID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbiAgaWYgKGkgPT0gMCAmJiBsZW4gPD0gNDA5NiAmJiBsZW4gPT0gYS5sZW5ndGgpIHJldHVybiBmLmFwcGx5IChudWxsLCBhKTtcbiAgdmFyIHMgPSBcIlwiO1xuICBmb3IgKDsgMCA8IGxlbjsgaSArPSAxMDI0LGxlbi09MTAyNClcbiAgICBzICs9IGYuYXBwbHkgKG51bGwsIHJhd19hcnJheV9zdWIoYSxpLCBNYXRoLm1pbihsZW4sIDEwMjQpKSk7XG4gIHJldHVybiBzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3V0Zjhfb2ZfdXRmMTZcbmZ1bmN0aW9uIGNhbWxfdXRmOF9vZl91dGYxNihzKSB7XG4gIGZvciAodmFyIGIgPSBcIlwiLCB0ID0gYiwgYywgZCwgaSA9IDAsIGwgPSBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGMgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICBmb3IgKHZhciBqID0gaSArIDE7IChqIDwgbCkgJiYgKGMgPSBzLmNoYXJDb2RlQXQoaikpIDwgMHg4MDsgaisrKTtcbiAgICAgIGlmIChqIC0gaSA+IDUxMikgeyB0LnN1YnN0cigwLCAxKTsgYiArPSB0OyB0ID0gXCJcIjsgYiArPSBzLnNsaWNlKGksIGopIH1cbiAgICAgIGVsc2UgdCArPSBzLnNsaWNlKGksIGopO1xuICAgICAgaWYgKGogPT0gbCkgYnJlYWs7XG4gICAgICBpID0gajtcbiAgICB9XG4gICAgaWYgKGMgPCAweDgwMCkge1xuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4YzAgfCAoYyA+PiA2KSk7XG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHg4MCB8IChjICYgMHgzZikpO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4ZDgwMCB8fCBjID49IDB4ZGZmZikge1xuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZTAgfCAoYyA+PiAxMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoYyA+PiA2KSAmIDB4M2YpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoYyAmIDB4M2YpKTtcbiAgICB9IGVsc2UgaWYgKGMgPj0gMHhkYmZmIHx8IGkgKyAxID09IGwgfHxcbiAgICAgICAgICAgICAgIChkID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgZCA+IDB4ZGZmZikge1xuICAgICAgLy8gVW5tYXRjaGVkIHN1cnJvZ2F0ZSBwYWlyLCByZXBsYWNlZCBieSBcXHVmZmZkIChyZXBsYWNlbWVudCBjaGFyYWN0ZXIpXG4gICAgICB0ICs9IFwiXFx4ZWZcXHhiZlxceGJkXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGkrKztcbiAgICAgIGMgPSAoYyA8PCAxMCkgKyBkIC0gMHgzNWZkYzAwO1xuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZjAgfCAoYyA+PiAxOCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoYyA+PiAxMikgJiAweDNmKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKChjID4+IDYpICYgMHgzZiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8IChjICYgMHgzZikpO1xuICAgIH1cbiAgICBpZiAodC5sZW5ndGggPiAxMDI0KSB7dC5zdWJzdHIoMCwgMSk7IGIgKz0gdDsgdCA9IFwiXCI7fVxuICB9XG4gIHJldHVybiBiK3Q7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdXRmMTZfb2ZfdXRmOFxuZnVuY3Rpb24gY2FtbF91dGYxNl9vZl91dGY4KHMpIHtcbiAgZm9yICh2YXIgYiA9IFwiXCIsIHQgPSBcIlwiLCBjLCBjMSwgYzIsIHYsIGkgPSAwLCBsID0gcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjMSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoYzEgPCAweDgwKSB7XG4gICAgICBmb3IgKHZhciBqID0gaSArIDE7IChqIDwgbCkgJiYgKGMxID0gcy5jaGFyQ29kZUF0KGopKSA8IDB4ODA7IGorKyk7XG4gICAgICBpZiAoaiAtIGkgPiA1MTIpIHsgdC5zdWJzdHIoMCwgMSk7IGIgKz0gdDsgdCA9IFwiXCI7IGIgKz0gcy5zbGljZShpLCBqKSB9XG4gICAgICBlbHNlIHQgKz0gcy5zbGljZShpLCBqKTtcbiAgICAgIGlmIChqID09IGwpIGJyZWFrO1xuICAgICAgaSA9IGo7XG4gICAgfVxuICAgIHYgPSAxO1xuICAgIGlmICgoKytpIDwgbCkgJiYgKCgoYzIgPSBzLmNoYXJDb2RlQXQoaSkpICYgLTY0KSA9PSAxMjgpKSB7XG4gICAgICBjID0gYzIgKyAoYzEgPDwgNik7XG4gICAgICBpZiAoYzEgPCAweGUwKSB7XG4gICAgICAgIHYgPSBjIC0gMHgzMDgwO1xuICAgICAgICBpZiAodiA8IDB4ODApIHYgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdiA9IDI7XG4gICAgICAgIGlmICgoKytpIDwgbCkgJiYgKCgoYzIgPSBzLmNoYXJDb2RlQXQoaSkpICYgLTY0KSA9PSAxMjgpKSB7XG4gICAgICAgICAgYyA9IGMyICsgKGMgPDwgNik7XG4gICAgICAgICAgaWYgKGMxIDwgMHhmMCkge1xuICAgICAgICAgICAgdiA9IGMgLSAweGUyMDgwO1xuICAgICAgICAgICAgaWYgKCh2IDwgMHg4MDApIHx8ICgodiA+PSAweGQ3ZmYpICYmICh2IDwgMHhlMDAwKSkpIHYgPSAyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2ID0gMztcbiAgICAgICAgICAgIGlmICgoKytpIDwgbCkgJiYgKCgoYzIgPSBzLmNoYXJDb2RlQXQoaSkpICYgLTY0KSA9PSAxMjgpICYmXG4gICAgICAgICAgICAgICAgKGMxIDwgMHhmNSkpIHtcbiAgICAgICAgICAgICAgdiA9IGMyIC0gMHgzYzgyMDgwICsgKGMgPDwgNik7XG4gICAgICAgICAgICAgIGlmICh2IDwgMHgxMDAwMCB8fCB2ID4gMHgxMGZmZmYpIHYgPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodiA8IDQpIHsgLy8gSW52YWxpZCBzZXF1ZW5jZVxuICAgICAgaSAtPSB2O1xuICAgICAgdCArPSBcIlxcdWZmZmRcIjtcbiAgICB9IGVsc2UgaWYgKHYgPiAweGZmZmYpXG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkN2MwICsgKHYgPj4gMTApLCAweGRjMDAgKyAodiAmIDB4M0ZGKSlcbiAgICBlbHNlXG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodik7XG4gICAgaWYgKHQubGVuZ3RoID4gMTAyNCkge3Quc3Vic3RyKDAsIDEpOyBiICs9IHQ7IHQgPSBcIlwiO31cbiAgfVxuICByZXR1cm4gYit0O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX2FzY2lpXG5mdW5jdGlvbiBjYW1sX2lzX2FzY2lpIChzKSB7XG4gIC8vIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gZ2V0cyBiZXR0ZXIgYXQgYXJvdW5kIHRoaXMgcG9pbnQgZm9yIGFsbCBicm93c2Vyc1xuICBpZiAocy5sZW5ndGggPCAyNCkge1xuICAgIC8vIFNwaWRlcm1vbmtleSBnZXRzIG11Y2ggc2xvd2VyIHdoZW4gcy5sZW5ndGggPj0gMjQgKG9uIDY0IGJpdCBhcmNocylcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIGlmIChzLmNoYXJDb2RlQXQoaSkgPiAxMjcpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlXG4gICAgcmV0dXJuICEvW15cXHgwMC1cXHg3Zl0vLnRlc3Qocyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdG9fanNfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzLCBjYW1sX2lzX2FzY2lpLCBjYW1sX3V0ZjE2X29mX3V0ZjhcbmZ1bmN0aW9uIGNhbWxfdG9fanNfc3RyaW5nKHMpIHtcbiAgc3dpdGNoIChzLnQpIHtcbiAgY2FzZSA5OiAvKkJZVEVTIHwgQVNDSUkqL1xuICAgIHJldHVybiBzLmM7XG4gIGRlZmF1bHQ6XG4gICAgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzKTtcbiAgY2FzZSAwOiAvKkJZVEVTIHwgVU5LT1dOKi9cbiAgICBpZiAoY2FtbF9pc19hc2NpaShzLmMpKSB7XG4gICAgICBzLnQgPSA5OyAvKkJZVEVTIHwgQVNDSUkqL1xuICAgICAgcmV0dXJuIHMuYztcbiAgICB9XG4gICAgcy50ID0gODsgLypCWVRFUyB8IE5PVF9BU0NJSSovXG4gIGNhc2UgODogLypCWVRFUyB8IE5PVF9BU0NJSSovXG4gICAgcmV0dXJuIGNhbWxfdXRmMTZfb2ZfdXRmOChzLmMpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSkge1xuICBzd2l0Y2ggKHMudCAmIDYpIHtcbiAgZGVmYXVsdDogLyogUEFSVElBTCAqL1xuICAgIGlmIChpID49IHMuYy5sZW5ndGgpIHJldHVybiAwO1xuICBjYXNlIDA6IC8qIEJZVEVTICovXG4gICAgcmV0dXJuIHMuYy5jaGFyQ29kZUF0KGkpO1xuICBjYXNlIDQ6IC8qIEFSUkFZICovXG4gICAgcmV0dXJuIHMuY1tpXVxuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkpIHtcbiAgc3dpdGNoIChzLnQgJiA2KSB7XG4gIGRlZmF1bHQ6IC8qIFBBUlRJQUwgKi9cbiAgICBpZiAoaSA+PSBzLmMubGVuZ3RoKSByZXR1cm4gMDtcbiAgY2FzZSAwOiAvKiBCWVRFUyAqL1xuICAgIHJldHVybiBzLmMuY2hhckNvZGVBdChpKTtcbiAgY2FzZSA0OiAvKiBBUlJBWSAqL1xuICAgIHJldHVybiBzLmNbaV1cbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSwgYykge1xuICAvLyBUaGUgT0NhbWwgY29tcGlsZXIgdXNlcyBDaGFyLnVuc2FmZV9jaHIgb24gaW50ZWdlcnMgbGFyZ2VyIHRoYW4gMjU1IVxuICBjICY9IDB4ZmY7XG4gIGlmIChzLnQgIT0gNCAvKiBBUlJBWSAqLykge1xuICAgIGlmIChpID09IHMuYy5sZW5ndGgpIHtcbiAgICAgIHMuYyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlIChjKTtcbiAgICAgIGlmIChpICsgMSA9PSBzLmwpIHMudCA9IDA7IC8qQllURVMgfCBVTktPV04qL1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYXJyYXkgKHMpO1xuICB9XG4gIHMuY1tpXSA9IGM7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ191bnNhZmVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGksIGMpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX3NldChzLGksYyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yICgpIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcImluZGV4IG91dCBvZiBib3VuZHNcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dldFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldCAocywgaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19nZXQxNihzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gMSkgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSksXG4gICAgICBiMiA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAxKTtcbiAgcmV0dXJuIChiMiA8PCA4IHwgYjEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dldDE2XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9ieXRlc19nZXQxNihzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gMSkgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSksXG4gICAgICBiMiA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAxKTtcbiAgcmV0dXJuIChiMiA8PCA4IHwgYjEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19nZXQzMlxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldDMyKHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSAzKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSxcbiAgICAgIGIyID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDEpLFxuICAgICAgYjMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMiksXG4gICAgICBiNCA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAzKTtcbiAgcmV0dXJuIChiNCA8PCAyNCB8IGIzIDw8IDE2IHwgYjIgPDwgOCB8IGIxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19nZXQzMlxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ2V0MzIocyxpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDMpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpLFxuICAgICAgYjIgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMSksXG4gICAgICBiMyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAyKSxcbiAgICAgIGI0ID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDMpO1xuICByZXR1cm4gKGI0IDw8IDI0IHwgYjMgPDwgMTYgfCBiMiA8PCA4IHwgYjEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19nZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldDY0KHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSA3KSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYSA9IG5ldyBBcnJheSg4KTtcbiAgZm9yKHZhciBqID0gMDsgaiA8IDg7IGorKyl7XG4gICAgYVs3IC0gal0gPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgaik7XG4gIH1cbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMoYSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dldDY0KHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSA3KSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYSA9IG5ldyBBcnJheSg4KTtcbiAgZm9yKHZhciBqID0gMDsgaiA8IDg7IGorKyl7XG4gICAgYVs3IC0gal0gPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgaik7XG4gIH1cbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMoYSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfZ2V0XG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dldCAocywgaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQgKHMsIGksIGMpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gY2FtbF9zdHJpbmdfdW5zYWZlX3NldCAocywgaSwgYyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yLCBjYW1sX3N0cmluZ191bnNhZmVfc2V0XG5mdW5jdGlvbiBjYW1sX2J5dGVzX3NldDE2KHMsaSxpMTYpe1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSAxKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjIgPSAweEZGICYgaTE2ID4+IDgsXG4gICAgICBiMSA9IDB4RkYgJiBpMTY7XG4gIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGkgKyAwLCBiMSk7XG4gIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGkgKyAxLCBiMik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3NldDE2XG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQxNihzLGksaTE2KXtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfc2V0MTYocyxpLGkxNik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yLCBjYW1sX3N0cmluZ191bnNhZmVfc2V0XG5mdW5jdGlvbiBjYW1sX2J5dGVzX3NldDMyKHMsaSxpMzIpe1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSAzKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjQgPSAweEZGICYgaTMyID4+IDI0LFxuICAgICAgYjMgPSAweEZGICYgaTMyID4+IDE2LFxuICAgICAgYjIgPSAweEZGICYgaTMyID4+IDgsXG4gICAgICBiMSA9IDB4RkYgJiBpMzI7XG4gIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGkgKyAwLCBiMSk7XG4gIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGkgKyAxLCBiMik7XG4gIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGkgKyAyLCBiMyk7XG4gIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGkgKyAzLCBiNCk7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3NldDMyXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQzMihzLGksaTMyKXtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfc2V0MzIocyxpLGkzMik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yLCBjYW1sX3N0cmluZ191bnNhZmVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX3NldDY0KHMsaSxpNjQpe1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSA3KSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYSA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoaTY0KTtcbiAgZm9yKHZhciBqID0gMDsgaiA8IDg7IGorKykge1xuICAgIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGkgKyA3IC0gaiwgYVtqXSk7XG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfc2V0NjRcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDY0KHMsaSxpNjQpe1xuICByZXR1cm4gY2FtbF9ieXRlc19zZXQ2NChzLGksaTY0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfc2V0IChzLCBpLCBjKSB7XG4gIGlmIChpID4+PiAwID49IHMubCkgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSwgYyk7XG59XG5cbi8vUHJvdmlkZXM6IE1sQnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfdG9fanNfc3RyaW5nXG5mdW5jdGlvbiBNbEJ5dGVzICh0YWcsIGNvbnRlbnRzLCBsZW5ndGgpIHtcbiAgdGhpcy50PXRhZzsgdGhpcy5jPWNvbnRlbnRzOyB0aGlzLmw9bGVuZ3RoO1xufVxuTWxCeXRlcy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpe3JldHVybiBjYW1sX3RvX2pzX3N0cmluZyh0aGlzKX07XG5NbEJ5dGVzLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uICgpe1xuICB2YXIgY29udGVudCA9IHRoaXMudCA9PSA0ID8gdGhpcy5jLnNsaWNlKCkgOiB0aGlzLmM7XG4gIHJldHVybiBuZXcgTWxCeXRlcyh0aGlzLnQsY29udGVudCx0aGlzLmwpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3N0cl9yZXBlYXQsIGNhbWxfc3ViYXJyYXlfdG9fc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzIChzKSB7XG4gIC8qIEFzc3VtZXMgbm90IEJZVEVTICovXG4gIGlmIChzLnQgPT0gMiAvKiBQQVJUSUFMICovKVxuICAgIHMuYyArPSBjYW1sX3N0cl9yZXBlYXQocy5sIC0gcy5jLmxlbmd0aCwgJ1xcMCcpXG4gIGVsc2VcbiAgICBzLmMgPSBjYW1sX3N1YmFycmF5X3RvX3N0cmluZyAocy5jLCAwLCBzLmMubGVuZ3RoKTtcbiAgcy50ID0gMDsgLypCWVRFUyB8IFVOS09XTiovXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYXJyYXkgKHMpIHtcbiAgLyogQXNzdW1lcyBub3QgQVJSQVkgKi9cbiAgaWYoam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheSkge1xuICAgIHZhciBhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkocy5sKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYSA9IG5ldyBBcnJheShzLmwpO1xuICB9XG4gIHZhciBiID0gcy5jLCBsID0gYi5sZW5ndGgsIGkgPSAwO1xuICBmb3IgKDsgaSA8IGw7IGkrKykgYVtpXSA9IGIuY2hhckNvZGVBdChpKTtcbiAgZm9yIChsID0gcy5sOyBpIDwgbDsgaSsrKSBhW2ldID0gMDtcbiAgcy5jID0gYTtcbiAgcy50ID0gNDsgLyogQVJSQVkgKi9cbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfb2Zfc3RyaW5nIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfb2Zfc3RyaW5nIChzKSB7XG4gIGlmIChzLnQgIT0gNCAvKiBBUlJBWSAqLykgY2FtbF9jb252ZXJ0X3N0cmluZ190b19hcnJheShzKTtcbiAgcmV0dXJuIHMuYztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nIChzKSB7XG4gIGlmICgocy50ICYgNikgIT0gMCAvKiBCWVRFUyAqLykgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzKTtcbiAgcmV0dXJuIHMuYztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc190b19zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaXNfYXNjaWksIGNhbWxfdXRmOF9vZl91dGYxNiwgTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9qc190b19zdHJpbmcgKHMpIHtcbiAgdmFyIHRhZyA9IDkgLyogQllURVMgfCBBU0NJSSAqLztcbiAgaWYgKCFjYW1sX2lzX2FzY2lpKHMpKVxuICAgIHRhZyA9IDggLyogQllURVMgfCBOT1RfQVNDSUkgKi8sIHMgPSBjYW1sX3V0Zjhfb2ZfdXRmMTYocyk7XG4gIHJldHVybiBuZXcgTWxCeXRlcyh0YWcsIHMsIHMubGVuZ3RoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEJ5dGVzLGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9jcmVhdGVfc3RyaW5nKGxlbikge1xuICBpZiAobGVuIDwgMCkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyaW5nLmNyZWF0ZVwiKTtcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKGxlbj8yOjksXCJcIixsZW4pO1xufVxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfYnl0ZXMgY29uc3Rcbi8vUmVxdWlyZXM6IE1sQnl0ZXMsY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pIHtcbiAgaWYgKGxlbiA8IDApIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJ5dGVzLmNyZWF0ZVwiKTtcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKGxlbj8yOjksXCJcIixsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25ld19zdHJpbmcgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9uZXdfc3RyaW5nIChzKSB7IHJldHVybiBuZXcgTWxCeXRlcygwLHMscy5sZW5ndGgpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5XG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9hcnJheSAoYSkgeyByZXR1cm4gbmV3IE1sQnl0ZXMoNCxhLGEubGVuZ3RoKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19jb21wYXJlIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2NvbXBhcmUoczEsIHMyKSB7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiAoczEuYyA8IHMyLmMpPy0xOihzMS5jID4gczIuYyk/MTowO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfY29tcGFyZSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2NvbXBhcmUoczEsIHMyKSB7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiAoczEuYyA8IHMyLmMpPy0xOihzMS5jID4gczIuYyk/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19lcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19lcXVhbChzMSwgczIpIHtcbiAgaWYoczEgPT09IHMyKSByZXR1cm4gMTtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jID09IHMyLmMpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19lcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2VxdWFsKHMxLCBzMikge1xuICBpZihzMSA9PT0gczIpIHJldHVybiAxO1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPT0gczIuYyk/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19ub3RlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19lcXVhbFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbm90ZXF1YWwoczEsIHMyKSB7IHJldHVybiAxLWNhbWxfc3RyaW5nX2VxdWFsKHMxLCBzMik7IH1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19ub3RlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19lcXVhbFxuZnVuY3Rpb24gY2FtbF9ieXRlc19ub3RlcXVhbChzMSwgczIpIHsgcmV0dXJuIDEtY2FtbF9zdHJpbmdfZXF1YWwoczEsIHMyKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19sZXNzZXF1YWwgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbGVzc2VxdWFsKHMxLCBzMikge1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPD0gczIuYyk/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2xlc3NlcXVhbCBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2xlc3NlcXVhbChzMSwgczIpIHtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jIDw9IHMyLmMpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbGVzc3RoYW4gbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbGVzc3RoYW4oczEsIHMyKSB7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiAoczEuYyA8IHMyLmMpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19sZXNzdGhhbiBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2xlc3N0aGFuKHMxLCBzMikge1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPCBzMi5jKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dyZWF0ZXJlcXVhbFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfbGVzc2VxdWFsXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ncmVhdGVyZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19sZXNzZXF1YWwoczIsczEpO1xufVxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19ncmVhdGVyZXF1YWxcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc2VxdWFsXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dyZWF0ZXJlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfbGVzc2VxdWFsKHMyLHMxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ3JlYXRlcnRoYW5cbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2xlc3N0aGFuXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ncmVhdGVydGhhbihzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX2xlc3N0aGFuKHMyLCBzMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ3JlYXRlcnRoYW5cbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc3RoYW5cbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ3JlYXRlcnRoYW4oczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3N0aGFuKHMyLCBzMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmlsbF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdHJfcmVwZWF0LCBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2ZpbGxfYnl0ZXMocywgaSwgbCwgYykge1xuICBpZiAobCA+IDApIHtcbiAgICBpZiAoaSA9PSAwICYmIChsID49IHMubCB8fCAocy50ID09IDIgLyogUEFSVElBTCAqLyAmJiBsID49IHMuYy5sZW5ndGgpKSkge1xuICAgICAgaWYgKGMgPT0gMCkge1xuICAgICAgICBzLmMgPSBcIlwiO1xuICAgICAgICBzLnQgPSAyOyAvKiBQQVJUSUFMICovXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzLmMgPSBjYW1sX3N0cl9yZXBlYXQgKGwsIFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICAgICAgICBzLnQgPSAobCA9PSBzLmwpPzAgLyogQllURVMgfCBVTktPV04gKi8gOjI7IC8qIFBBUlRJQUwgKi9cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHMudCAhPSA0IC8qIEFSUkFZICovKSBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2FycmF5KHMpO1xuICAgICAgZm9yIChsICs9IGk7IGkgPCBsOyBpKyspIHMuY1tpXSA9IGM7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbGxfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2ZpbGxfYnl0ZXNcbnZhciBjYW1sX2ZpbGxfc3RyaW5nID0gY2FtbF9maWxsX2J5dGVzXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmxpdF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdWJhcnJheV90b19zdHJpbmcsIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYmxpdF9ieXRlcyhzMSwgaTEsIHMyLCBpMiwgbGVuKSB7XG4gIGlmIChsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIGlmICgoaTIgPT0gMCkgJiZcbiAgICAgIChsZW4gPj0gczIubCB8fCAoczIudCA9PSAyIC8qIFBBUlRJQUwgKi8gJiYgbGVuID49IHMyLmMubGVuZ3RoKSkpIHtcbiAgICBzMi5jID0gKHMxLnQgPT0gNCAvKiBBUlJBWSAqLyk/XG4gICAgICBjYW1sX3N1YmFycmF5X3RvX3N0cmluZyhzMS5jLCBpMSwgbGVuKTpcbiAgICAgIChpMSA9PSAwICYmIHMxLmMubGVuZ3RoID09IGxlbik/czEuYzpzMS5jLnN1YnN0cihpMSwgbGVuKTtcbiAgICBzMi50ID0gKHMyLmMubGVuZ3RoID09IHMyLmwpPzAgLyogQllURVMgfCBVTktPV04gKi8gOjI7IC8qIFBBUlRJQUwgKi9cbiAgfSBlbHNlIGlmIChzMi50ID09IDIgLyogUEFSVElBTCAqLyAmJiBpMiA9PSBzMi5jLmxlbmd0aCkge1xuICAgIHMyLmMgKz0gKHMxLnQgPT0gNCAvKiBBUlJBWSAqLyk/XG4gICAgICBjYW1sX3N1YmFycmF5X3RvX3N0cmluZyhzMS5jLCBpMSwgbGVuKTpcbiAgICAgIChpMSA9PSAwICYmIHMxLmMubGVuZ3RoID09IGxlbik/czEuYzpzMS5jLnN1YnN0cihpMSwgbGVuKTtcbiAgICBzMi50ID0gKHMyLmMubGVuZ3RoID09IHMyLmwpPzAgLyogQllURVMgfCBVTktPV04gKi8gOjI7IC8qIFBBUlRJQUwgKi9cbiAgfSBlbHNlIHtcbiAgICBpZiAoczIudCAhPSA0IC8qIEFSUkFZICovKSBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2FycmF5KHMyKTtcbiAgICB2YXIgYzEgPSBzMS5jLCBjMiA9IHMyLmM7XG4gICAgaWYgKHMxLnQgPT0gNCAvKiBBUlJBWSAqLykge1xuICAgICAgaWYgKGkyIDw9IGkxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGMyIFtpMiArIGldID0gYzEgW2kxICsgaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIGMyIFtpMiArIGldID0gYzEgW2kxICsgaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsID0gTWF0aC5taW4gKGxlbiwgYzEubGVuZ3RoIC0gaTEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIGMyIFtpMiArIGldID0gYzEuY2hhckNvZGVBdChpMSArIGkpO1xuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykgYzIgW2kyICsgaV0gPSAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ibGl0X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ibGl0X2J5dGVzXG5mdW5jdGlvbiBjYW1sX2JsaXRfc3RyaW5nKHMxLCBpMSwgczIsIGkyLCBsZW4pIHtcbiAgLy8gVE9ETzogczEgLT4gc3RyaW5nIHRvIGJ5dGVzXG4gIHJldHVybiBjYW1sX2JsaXRfYnl0ZXMoczEsIGkxLCBzMiwgaTIsIGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCBjb25zdFxuZnVuY3Rpb24gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIHsgcmV0dXJuIHMubCB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoIGNvbnN0XG5mdW5jdGlvbiBjYW1sX21sX2J5dGVzX2xlbmd0aChzKSB7IHJldHVybiBzLmwgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9ieXRlcyBjb25zdFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfYnl0ZXMocykgeyByZXR1cm4gc31cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl9zdHJpbmcgY29uc3RcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKHMpIHsgcmV0dXJuIHN9XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBDb3JlXG5cbi8vUHJvdmlkZXM6IHJhd19hcnJheV9zdWJcbmZ1bmN0aW9uIHJhd19hcnJheV9zdWIgKGEsaSxsKSB7XG4gIHZhciBiID0gbmV3IEFycmF5KGwpO1xuICBmb3IodmFyIGogPSAwOyBqIDwgbDsgaisrKSBiW2pdID0gYVtpK2pdO1xuICByZXR1cm4gYlxufVxuXG4vL1Byb3ZpZGVzOiByYXdfYXJyYXlfY29weVxuZnVuY3Rpb24gcmF3X2FycmF5X2NvcHkgKGEpIHtcbiAgdmFyIGwgPSBhLmxlbmd0aDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKysgKSBiW2ldID0gYVtpXTtcbiAgcmV0dXJuIGJcbn1cblxuLy9Qcm92aWRlczogcmF3X2FycmF5X2NvbnNcbmZ1bmN0aW9uIHJhd19hcnJheV9jb25zIChhLHgpIHtcbiAgdmFyIGwgPSBhLmxlbmd0aDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobCsxKTtcbiAgYlswXT14O1xuICBmb3IodmFyIGkgPSAxOyBpIDw9IGw7IGkrKyApIGJbaV0gPSBhW2ktMV07XG4gIHJldHVybiBiXG59XG5cbi8vUHJvdmlkZXM6IHJhd19hcnJheV9hcHBlbmRfb25lXG5mdW5jdGlvbiByYXdfYXJyYXlfYXBwZW5kX29uZShhLHgpIHtcbiAgdmFyIGwgPSBhLmxlbmd0aDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobCsxKTtcbiAgdmFyIGkgPSAwO1xuICBmb3IoOyBpIDwgbDsgaSsrICkgYltpXSA9IGFbaV07XG4gIGJbaV09eDtcbiAgcmV0dXJuIGJcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jYWxsX2dlbiAoY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiByYXdfYXJyYXlfc3ViXG4vL1JlcXVpcmVzOiByYXdfYXJyYXlfYXBwZW5kX29uZVxuZnVuY3Rpb24gY2FtbF9jYWxsX2dlbihmLCBhcmdzKSB7XG4gIGlmKGYuZnVuKVxuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYuZnVuLCBhcmdzKTtcbiAgdmFyIG4gPSBmLmxlbmd0aDtcbiAgdmFyIGFyZ3NMZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIGQgPSBuIC0gYXJnc0xlbjtcbiAgaWYgKGQgPT0gMClcbiAgICByZXR1cm4gZi5hcHBseShudWxsLCBhcmdzKTtcbiAgZWxzZSBpZiAoZCA8IDApXG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZi5hcHBseShudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF3X2FycmF5X3N1YihhcmdzLDAsbikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgIHJhd19hcnJheV9zdWIoYXJncyxuLGFyZ3NMZW4gLSBuKSk7XG4gIGVsc2VcbiAgICByZXR1cm4gZnVuY3Rpb24gKHgpeyByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCByYXdfYXJyYXlfYXBwZW5kX29uZShhcmdzLHgpKTsgfTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9uYW1lZF92YWx1ZXNcbnZhciBjYW1sX25hbWVkX3ZhbHVlcyA9IHt9O1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlIChjb25zdCxjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlKG5tLHYpIHtcbiAgY2FtbF9uYW1lZF92YWx1ZXNbY2FtbF9qc2J5dGVzX29mX3N0cmluZyhubSldID0gdjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmFtZWRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWVzXG5mdW5jdGlvbiBjYW1sX25hbWVkX3ZhbHVlKG5tKSB7XG4gIHJldHVybiBjYW1sX25hbWVkX3ZhbHVlc1tubV1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9nbG9iYWxfZGF0YVxudmFyIGNhbWxfZ2xvYmFsX2RhdGEgPSBbMF07XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVnaXN0ZXJfZ2xvYmFsIChjb25zdCwgc2hhbGxvdywgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JlZ2lzdGVyX2dsb2JhbCAobiwgdiwgbmFtZV9vcHQpIHtcbiAgaWYobmFtZV9vcHQgJiYgam9vX2dsb2JhbF9vYmplY3QudG9wbGV2ZWxSZWxvYylcbiAgICBuID0gam9vX2dsb2JhbF9vYmplY3QudG9wbGV2ZWxSZWxvYyhuYW1lX29wdCk7XG4gIGNhbWxfZ2xvYmFsX2RhdGFbbiArIDFdID0gdjtcbiAgaWYobmFtZV9vcHQpIGNhbWxfZ2xvYmFsX2RhdGFbbmFtZV9vcHRdID0gdjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9nZXRfZ2xvYmFsX2RhdGEgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9nZXRfZ2xvYmFsX2RhdGEgKCkgeyByZXR1cm4gY2FtbF9nbG9iYWxfZGF0YTsgfVxuXG4vL1JhaXNlIGV4Y2VwdGlvblxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9yYWlzZV9jb25zdGFudCAodGFnKSB7IHRocm93IHRhZzsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JldHVybl9leG5fY29uc3RhbnQgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50ICh0YWcpIHsgcmV0dXJuIHRhZzsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX3dpdGhfYXJnIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3dpdGhfYXJnICh0YWcsIGFyZykgeyB0aHJvdyBbMCwgdGFnLCBhcmddOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9hcmcsY2FtbF9uZXdfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nICh0YWcsIG1zZykge1xuICBjYW1sX3JhaXNlX3dpdGhfYXJnICh0YWcsIGNhbWxfbmV3X3N0cmluZyAobXNnKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfc3lzX2Vycm9yIChtc2cpIHtcbiAgY2FtbF9yYWlzZV93aXRoX3N0cmluZyhjYW1sX2dsb2JhbF9kYXRhLlN5c19lcnJvciwgbXNnKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mYWlsd2l0aCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX2ZhaWx3aXRoIChtc2cpIHtcbiAgY2FtbF9yYWlzZV93aXRoX3N0cmluZyhjYW1sX2dsb2JhbF9kYXRhLkZhaWx1cmUsIG1zZyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfd3JhcF9leGNlcHRpb24gY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YSxjYW1sX2pzX3RvX3N0cmluZyxjYW1sX25hbWVkX3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX3JldHVybl9leG5fY29uc3RhbnRcbmZ1bmN0aW9uIGNhbWxfd3JhcF9leGNlcHRpb24oZSkge1xuICBpZihlIGluc3RhbmNlb2YgQXJyYXkpIHJldHVybiBlO1xuICAvL1N0YWNrX292ZXJmbG93OiBjaHJvbWUsIHNhZmFyaVxuICBpZihqb29fZ2xvYmFsX29iamVjdC5SYW5nZUVycm9yXG4gICAgICYmIGUgaW5zdGFuY2VvZiBqb29fZ2xvYmFsX29iamVjdC5SYW5nZUVycm9yXG4gICAgICYmIGUubWVzc2FnZVxuICAgICAmJiBlLm1lc3NhZ2UubWF0Y2goL21heGltdW0gY2FsbCBzdGFjay9pKSlcbiAgICByZXR1cm4gY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50KGNhbWxfZ2xvYmFsX2RhdGEuU3RhY2tfb3ZlcmZsb3cpO1xuICAvL1N0YWNrX292ZXJmbG93OiBmaXJlZm94XG4gIGlmKGpvb19nbG9iYWxfb2JqZWN0LkludGVybmFsRXJyb3JcbiAgICAgJiYgZSBpbnN0YW5jZW9mIGpvb19nbG9iYWxfb2JqZWN0LkludGVybmFsRXJyb3JcbiAgICAgJiYgZS5tZXNzYWdlXG4gICAgICYmIGUubWVzc2FnZS5tYXRjaCgvdG9vIG11Y2ggcmVjdXJzaW9uL2kpKVxuICAgIHJldHVybiBjYW1sX3JldHVybl9leG5fY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5TdGFja19vdmVyZmxvdyk7XG4gIC8vV3JhcCBFcnJvciBpbiBKcy5FcnJvciBleGNlcHRpb25cbiAgaWYoZSBpbnN0YW5jZW9mIGpvb19nbG9iYWxfb2JqZWN0LkVycm9yICYmIGNhbWxfbmFtZWRfdmFsdWUoXCJqc0Vycm9yXCIpKVxuICAgIHJldHVybiBbMCxjYW1sX25hbWVkX3ZhbHVlKFwianNFcnJvclwiKSxlXTtcbiAgLy9mYWxsYmFjazogd3JhcHBlZCBpbiBGYWlsdXJlXG4gIHJldHVybiBbMCxjYW1sX2dsb2JhbF9kYXRhLkZhaWx1cmUsY2FtbF9qc190b19zdHJpbmcgKFN0cmluZyhlKSldO1xufVxuXG4vLyBFeHBlcmltZW50YWxcbi8vUHJvdmlkZXM6IGNhbWxfZXhuX3dpdGhfanNfYmFja3RyYWNlXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX2V4bl93aXRoX2pzX2JhY2t0cmFjZShleG4sIGZvcmNlKSB7XG4gIC8vbmV2ZXIgcmVyYWlzZSBmb3IgY29uc3RhbnQgZXhuXG4gIGlmKCFleG4uanNfZXJyb3IgfHwgZm9yY2UgfHwgZXhuWzBdID09IDI0OCkgZXhuLmpzX2Vycm9yID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LkVycm9yKFwiSnMgZXhjZXB0aW9uIGNvbnRhaW5pbmcgYmFja3RyYWNlXCIpO1xuICByZXR1cm4gZXhuO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc19lcnJvcl9vZl9leGNlcHRpb25cbmZ1bmN0aW9uIGNhbWxfanNfZXJyb3Jfb2ZfZXhjZXB0aW9uKGV4bikge1xuICBpZihleG4uanNfZXJyb3IpIHsgcmV0dXJuIGV4bi5qc19lcnJvcjsgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfaW52YWxpZF9hcmd1bWVudCAobXNnKSB7XG4gIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcoY2FtbF9nbG9iYWxfZGF0YS5JbnZhbGlkX2FyZ3VtZW50LCBtc2cpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2NvbnN0YW50LCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlICgpIHtcbiAgY2FtbF9yYWlzZV9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLkVuZF9vZl9maWxlKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9jb25zdGFudCwgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSAoKSB7XG4gIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5EaXZpc2lvbl9ieV96ZXJvKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9ub3RfZm91bmRcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfbm90X2ZvdW5kICgpIHtcbiAgY2FtbF9yYWlzZV9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLk5vdF9mb3VuZCk7IH1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IgKCkge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VwZGF0ZV9kdW1teVxuZnVuY3Rpb24gY2FtbF91cGRhdGVfZHVtbXkgKHgsIHkpIHtcbiAgaWYoIHR5cGVvZiB5PT09XCJmdW5jdGlvblwiICkgeyB4LmZ1biA9IHk7IHJldHVybiAwOyB9XG4gIGlmKCB5LmZ1biApIHsgeC5mdW4gPSB5LmZ1bjsgcmV0dXJuIDA7IH1cbiAgdmFyIGkgPSB5Lmxlbmd0aDsgd2hpbGUgKGktLSkgeFtpXSA9IHlbaV07IHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9pc19ibG9jayBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX29ial9pc19ibG9jayAoeCkgeyByZXR1cm4gKyh4IGluc3RhbmNlb2YgQXJyYXkpOyB9XG5cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfdGFnXG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX29ial90YWcgKHgpIHtcbiAgaWYgKCh4IGluc3RhbmNlb2YgQXJyYXkpICYmIHhbMF0gPT0gKHhbMF0gPj4+IDApKVxuICAgIHJldHVybiB4WzBdXG4gIGVsc2UgaWYgKHggaW5zdGFuY2VvZiBNbEJ5dGVzKVxuICAgIHJldHVybiAyNTJcbiAgZWxzZSBpZiAoKHggaW5zdGFuY2VvZiBGdW5jdGlvbikgfHwgdHlwZW9mIHggPT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiAyNDdcbiAgZWxzZSBpZiAoeCAmJiB4LmNhbWxfY3VzdG9tKVxuICAgIHJldHVybiAyNTVcbiAgZWxzZVxuICAgIHJldHVybiAxMDAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3NldF90YWcgKG11dGFibGUsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9vYmpfc2V0X3RhZyAoeCwgdGFnKSB7IHhbMF0gPSB0YWc7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX29ial9ibG9jayBjb25zdCAoY29uc3QsY29uc3QpXG5mdW5jdGlvbiBjYW1sX29ial9ibG9jayAodGFnLCBzaXplKSB7XG4gIHZhciBvID0gbmV3IEFycmF5KHNpemUrMSk7XG4gIG9bMF09dGFnO1xuICBmb3IgKHZhciBpID0gMTsgaSA8PSBzaXplOyBpKyspIG9baV0gPSAwO1xuICByZXR1cm4gbztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfd2l0aF90YWdcbmZ1bmN0aW9uIGNhbWxfb2JqX3dpdGhfdGFnKHRhZyx4KSB7XG4gIHZhciBsID0geC5sZW5ndGg7XG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICBhWzBdID0gdGFnO1xuICBmb3IodmFyIGkgPSAxOyBpIDwgbDsgaSsrICkgYVtpXSA9IHhbaV07XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9kdXAgbXV0YWJsZSAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX29ial9kdXAgKHgpIHtcbiAgdmFyIGwgPSB4Lmxlbmd0aDtcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKysgKSBhW2ldID0geFtpXTtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3RydW5jYXRlIChtdXRhYmxlLCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9vYmpfdHJ1bmNhdGUgKHgsIHMpIHtcbiAgaWYgKHM8PTAgfHwgcyArIDEgPiB4Lmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiT2JqLnRydW5jYXRlXCIpO1xuICBpZiAoeC5sZW5ndGggIT0gcyArIDEpIHgubGVuZ3RoID0gcyArIDE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9tYWtlX2ZvcndhcmRcbmZ1bmN0aW9uIGNhbWxfb2JqX21ha2VfZm9yd2FyZCAoYix2KSB7XG4gIGJbMF09MjUwO1xuICBiWzFdPXY7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGF6eV9tYWtlX2ZvcndhcmQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9sYXp5X21ha2VfZm9yd2FyZCAodikgeyByZXR1cm4gWzI1MCwgdl07IH1cblxuLy9Qcm92aWRlczogY2FtbF9tdWwgY29uc3RcbmlmICghTWF0aC5pbXVsKVxuICBNYXRoLmltdWwgPVxuICBmdW5jdGlvbiAoeCx5KSB7XG4gICAgeSB8PSAwO1xuICAgIHJldHVybiAoKCgoeCA+PiAxNikgKiB5KSA8PCAxNikgKyAoeCAmIDB4ZmZmZikgKiB5KXwwO1xuICB9O1xudmFyIGNhbWxfbXVsID0gTWF0aC5pbXVsO1xuXG4vL3NsaWdodGx5IHNsb3dlclxuLy8gZnVuY3Rpb24gbXVsMzIoeCx5KSB7XG4vLyAgIHZhciB4bG8gPSB4ICYgMHhmZmZmO1xuLy8gICB2YXIgeGhpID0geCAtIHhsbztcbi8vICAgcmV0dXJuICgoKHhoaSAqIHkpIHwwKSArIHhsbyAqIHkpfDA7XG4vLyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZGl2XG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3plcm9fZGl2aWRlXG5mdW5jdGlvbiBjYW1sX2Rpdih4LHkpIHtcbiAgaWYgKHkgPT0gMCkgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSAoKTtcbiAgcmV0dXJuICh4L3kpfDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbW9kXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3plcm9fZGl2aWRlXG5mdW5jdGlvbiBjYW1sX21vZCh4LHkpIHtcbiAgaWYgKHkgPT0gMCkgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSAoKTtcbiAgcmV0dXJuIHgleTtcbn1cblxuLy8vLy8vLy8vLy8vLyBQZXJ2YXNpdmVcbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfc2V0IChtdXRhYmxlLCBjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2FycmF5X3NldCAoYXJyYXksIGluZGV4LCBuZXd2YWwpIHtcbiAgaWYgKChpbmRleCA8IDApIHx8IChpbmRleCA+PSBhcnJheS5sZW5ndGggLSAxKSkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICBhcnJheVtpbmRleCsxXT1uZXd2YWw7IHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2dldCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2FycmF5X2dldCAoYXJyYXksIGluZGV4KSB7XG4gIGlmICgoaW5kZXggPCAwKSB8fCAoaW5kZXggPj0gYXJyYXkubGVuZ3RoIC0gMSkpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGFycmF5W2luZGV4KzFdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2ZpbGxcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfZmlsbChhcnJheSwgb2ZzLCBsZW4sIHYpe1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspe1xuICAgIGFycmF5W29mcytpKzFdID0gdjtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jaGVja19ib3VuZCAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9jaGVja19ib3VuZCAoYXJyYXksIGluZGV4KSB7XG4gIGlmIChpbmRleCA+Pj4gMCA+PSBhcnJheS5sZW5ndGggLSAxKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBhcnJheTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tYWtlX3ZlY3QgY29uc3QgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfbWFrZV92ZWN0IChsZW4sIGluaXQpIHtcbiAgaWYgKGxlbiA8IDApIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGxlbiA9IGxlbiArIDEgfCAwO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4pO1xuICBiWzBdPTA7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIGJbaV0gPSBpbml0O1xuICByZXR1cm4gYjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tYWtlX2Zsb2F0X3ZlY3QgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9tYWtlX2Zsb2F0X3ZlY3QobGVuKXtcbiAgaWYgKGxlbiA8IDApIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGxlbiA9IGxlbiArIDEgfCAwO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4pO1xuICBiWzBdPTI1NDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykgYltpXSA9IDA7XG4gIHJldHVybiBiXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfZmxvYXRhcnJheV9jcmVhdGUobGVuKXtcbiAgaWYgKGxlbiA8IDApIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGxlbiA9IGxlbiArIDEgfCAwO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4pO1xuICBiWzBdPTI1NDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykgYltpXSA9IDA7XG4gIHJldHVybiBiXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZV92YWxfdGFnXG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmVfdmFsX3RhZyhhKXtcbiAgaWYgKHR5cGVvZiBhID09PSBcIm51bWJlclwiKSByZXR1cm4gMTAwMDsgLy8gaW50X3RhZyAod2UgdXNlIGl0IGZvciBhbGwgbnVtYmVycylcbiAgZWxzZSBpZiAoYSBpbnN0YW5jZW9mIE1sQnl0ZXMpIHJldHVybiAyNTI7IC8vIHN0cmluZ190YWdcbiAgZWxzZSBpZiAoYSBpbnN0YW5jZW9mIEFycmF5ICYmIGFbMF0gPT09IChhWzBdPj4+MCkgJiYgYVswXSA8PSAyNTUpIHtcbiAgICAvLyBMb29rIGxpa2UgYW4gb2NhbWwgYmxvY2tcbiAgICB2YXIgdGFnID0gYVswXSB8IDA7XG4gICAgLy8gaWdub3JlIGRvdWJsZV9hcnJheV90YWcgYmVjYXVzZSB3ZSBjYW5ub3QgYWNjdXJhdGVseSBzZXRcbiAgICAvLyB0aGlzIHRhZyB3aGVuIHdlIGNyZWF0ZSBhbiBhcnJheSBvZiBmbG9hdC5cbiAgICByZXR1cm4gKHRhZyA9PSAyNTQpPzA6dGFnXG4gIH1cbiAgZWxzZSBpZiAoYSBpbnN0YW5jZW9mIFN0cmluZykgcmV0dXJuIDEyNTI7IC8vIGphdmFzY3JpcHQgc3RyaW5nLCBsaWtlIHN0cmluZ190YWcgKDI1MilcbiAgZWxzZSBpZiAodHlwZW9mIGEgPT0gXCJzdHJpbmdcIikgcmV0dXJuIDEyNTI7IC8vIGphdmFzY3JpcHQgc3RyaW5nLCBsaWtlIHN0cmluZ190YWcgKDI1MilcbiAgZWxzZSBpZiAoYSBpbnN0YW5jZW9mIE51bWJlcikgcmV0dXJuIDEwMDA7IC8vIGludF90YWcgKHdlIHVzZSBpdCBmb3IgYWxsIG51bWJlcnMpXG4gIGVsc2UgaWYgKGEgJiYgYS5jYW1sX2N1c3RvbSkgcmV0dXJuIDEyNTU7IC8vIGxpa2UgY3VzdG9tX3RhZyAoMjU1KVxuICBlbHNlIGlmIChhICYmIGEuY29tcGFyZSkgcmV0dXJuIDEyNTY7IC8vIGxpa2UgY3VzdG9tX3RhZyAoMjU1KVxuICBlbHNlIGlmICh0eXBlb2YgYSA9PSBcImZ1bmN0aW9uXCIpIHJldHVybiAxMjQ3OyAvLyBsaWtlIGNsb3N1cmVfdGFnICgyNDcpXG4gIGVsc2UgaWYgKHR5cGVvZiBhID09IFwic3ltYm9sXCIpIHJldHVybiAxMjUxO1xuICByZXR1cm4gMTAwMTsgLy9vdXRfb2ZfaGVhcF90YWdcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tXG4vL1JlcXVpcmVzOiBjYW1sX2N1c3RvbV9vcHNcbmZ1bmN0aW9uIGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbShhKXtcbiAgcmV0dXJuIGNhbWxfY3VzdG9tX29wc1thLmNhbWxfY3VzdG9tXSAmJiBjYW1sX2N1c3RvbV9vcHNbYS5jYW1sX2N1c3RvbV0uY29tcGFyZTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb21wYXJlX3ZhbF9udW1iZXJfY3VzdG9tXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b21cbmZ1bmN0aW9uIGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbShudW0sIGN1c3RvbSwgc3dhcCwgdG90YWwpIHtcbiAgdmFyIGNvbXAgPSBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20oY3VzdG9tKTtcbiAgaWYoY29tcCkge1xuICAgIHZhciB4ID0gKHN3YXAgPiAwKT9jb21wKGN1c3RvbSxudW0sdG90YWwpOmNvbXAobnVtLGN1c3RvbSx0b3RhbCk7XG4gICAgaWYodG90YWwgJiYgeCAhPSB4KSByZXR1cm4gc3dhcDsgLy8gdG90YWwgJiYgbmFuXG4gICAgaWYoK3ggIT0gK3gpIHJldHVybiAreDsgLy8gbmFuXG4gICAgaWYoKHggfCAwKSAhPSAwKSByZXR1cm4gKHggfCAwKTsgLy8gIW5hblxuICB9XG4gIHJldHVybiBzd2FwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZV92YWwgKGNvbnN0LCBjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2NvbXBhcmUsIGNhbWxfaW50X2NvbXBhcmUsIGNhbWxfc3RyaW5nX2NvbXBhcmVcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tLCBjYW1sX2NvbXBhcmVfdmFsX3RhZ1xuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbF9udW1iZXJfY3VzdG9tXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmVfdmFsIChhLCBiLCB0b3RhbCkge1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgZm9yKDs7KSB7XG4gICAgaWYgKCEodG90YWwgJiYgYSA9PT0gYikpIHtcbiAgICAgIHZhciB0YWdfYSA9IGNhbWxfY29tcGFyZV92YWxfdGFnKGEpO1xuICAgICAgLy8gZm9yd2FyZF90YWcgP1xuICAgICAgaWYodGFnX2EgPT0gMjUwKSB7IGEgPSBhWzFdOyBjb250aW51ZSB9XG5cbiAgICAgIHZhciB0YWdfYiA9IGNhbWxfY29tcGFyZV92YWxfdGFnKGIpO1xuICAgICAgLy8gZm9yd2FyZF90YWcgP1xuICAgICAgaWYodGFnX2IgPT0gMjUwKSB7IGIgPSBiWzFdOyBjb250aW51ZSB9XG5cbiAgICAgIC8vIHRhZ3MgYXJlIGRpZmZlcmVudFxuICAgICAgaWYodGFnX2EgIT09IHRhZ19iKSB7XG4gICAgICAgIGlmKHRhZ19hID09IDEwMDApIHtcbiAgICAgICAgICBpZih0YWdfYiA9PSAxMjU1KSB7IC8vaW1tZWRpYXRlIGNhbiBjb21wYXJlIGFnYWluc3QgY3VzdG9tXG4gICAgICAgICAgICByZXR1cm4gY2FtbF9jb21wYXJlX3ZhbF9udW1iZXJfY3VzdG9tKGEsIGIsIC0xLCB0b3RhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICB9XG4gICAgICAgIGlmKHRhZ19iID09IDEwMDApIHtcbiAgICAgICAgICBpZih0YWdfYSA9PSAxMjU1KSB7IC8vaW1tZWRpYXRlIGNhbiBjb21wYXJlIGFnYWluc3QgY3VzdG9tXG4gICAgICAgICAgICByZXR1cm4gY2FtbF9jb21wYXJlX3ZhbF9udW1iZXJfY3VzdG9tKGIsIGEsIDEsIHRvdGFsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIDFcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHRhZ19hIDwgdGFnX2IpPy0xOjE7XG4gICAgICB9XG4gICAgICBzd2l0Y2godGFnX2Epe1xuICAgICAgICAvLyAyNDY6IExhenlfdGFnIGhhbmRsZWQgYmVsbG93XG4gICAgICBjYXNlIDI0NzogLy8gQ2xvc3VyZV90YWdcbiAgICAgICAgLy8gQ2Fubm90IGhhcHBlblxuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjb21wYXJlOiBmdW5jdGlvbmFsIHZhbHVlXCIpO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAyNDg6IC8vIE9iamVjdFxuICAgICAgICB2YXIgeCA9IGNhbWxfaW50X2NvbXBhcmUoYVsyXSwgYlsyXSk7XG4gICAgICAgIGlmICh4ICE9IDApIHJldHVybiAoeCB8IDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjQ5OiAvLyBJbmZpeFxuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGZ1bmN0aW9uYWwgdmFsdWVcIik7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDI1MDogLy8gRm9yd2FyZCB0YWdcbiAgICAgICAgLy8gQ2Fubm90IGhhcHBlbiwgaGFuZGxlZCBhYm92ZVxuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJlcXVhbDogZ290IEZvcndhcmRfdGFnLCBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MTogLy9BYnN0cmFjdFxuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJlcXVhbDogYWJzdHJhY3QgdmFsdWVcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTI6IC8vIE9DYW1sIHN0cmluZ1xuICAgICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICAgIHZhciB4ID0gY2FtbF9zdHJpbmdfY29tcGFyZShhLCBiKTtcbiAgICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MzogLy8gRG91YmxlX3RhZ1xuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBnb3QgRG91YmxlX3RhZywgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTQ6IC8vIERvdWJsZV9hcnJheV90YWdcbiAgICAgICAgLy8gQ2Fubm90IGhhcHBlbiwgaGFuZGxlZCBhYm92ZVxuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJlcXVhbDogZ290IERvdWJsZV9hcnJheV90YWcsIHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAyNTU6IC8vIEludDY0XG4gICAgICAgIC8vIEludDY0IGlzIHRoZSBvbmx5IGN1c3RvbSBibG9jayBpbXBsZW1lbnRlZCB0aGlzIHdheSxcbiAgICAgICAgLy8gVE9ETzogV2Ugc2hvdWxkIHJld3JpdGUgdGhlIGltcGxlbWVudGF0aW9uIGFuZCBmb2xsb3dcbiAgICAgICAgLy8gd2hhdCB3ZSBkbyBmb3Igb3RoZXIgY3VzdG9tIGJsb2NrczogemFyaXRoLCBiaWdpbnQsIGJpZ2FycmF5LCAuLi5cbiAgICAgICAgdmFyIHggPSBjYW1sX2ludDY0X2NvbXBhcmUoYSwgYik7XG4gICAgICAgIGlmICh4ICE9IDApIHJldHVybiAoeCB8IDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI0NzogLy8gRnVuY3Rpb25cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogZnVuY3Rpb25hbCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTU6IC8vIEN1c3RvbVxuICAgICAgICB2YXIgY29tcCA9IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbShhKTtcbiAgICAgICAgaWYoY29tcCAhPSBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20oYikpe1xuICAgICAgICAgIHJldHVybiAoYS5jYW1sX2N1c3RvbTxiLmNhbWxfY3VzdG9tKT8tMToxO1xuICAgICAgICB9XG4gICAgICAgIGlmKCFjb21wKVxuICAgICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGFic3RyYWN0IHZhbHVlXCIpO1xuICAgICAgICB2YXIgeCA9IGNvbXAoYSxiLHRvdGFsKTtcbiAgICAgICAgaWYoeCAhPSB4KXsgLy8gUHJvdGVjdCBhZ2FpbnN0IGludmFsaWQgVU5PUkRFUkVEXG4gICAgICAgICAgcmV0dXJuIHRvdGFsPy0xOng7XG4gICAgICAgIH1cbiAgICAgICAgaWYoeCAhPT0gKHh8MCkpeyAvLyBQcm90ZWN0IGFnYWluc3QgaW52YWxpZCByZXR1cm4gdmFsdWVcbiAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTY6IC8vIGNvbXBhcmUgZnVuY3Rpb25cbiAgICAgICAgdmFyIHggPSBhLmNvbXBhcmUoYix0b3RhbCk7XG4gICAgICAgIGlmKHggIT0geCkgeyAvLyBQcm90ZWN0IGFnYWluc3QgaW52YWxpZCBVTk9SREVSRURcbiAgICAgICAgICByZXR1cm4gdG90YWw/LTE6eDtcbiAgICAgICAgfVxuICAgICAgICBpZih4ICE9PSAoeHwwKSl7IC8vIFByb3RlY3QgYWdhaW5zdCBpbnZhbGlkIHJldHVybiB2YWx1ZVxuICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICB9XG4gICAgICAgIGlmICh4ICE9IDApIHJldHVybiAoeCB8IDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTAwMDogLy8gTnVtYmVyXG4gICAgICAgIGEgPSArYTtcbiAgICAgICAgYiA9ICtiO1xuICAgICAgICBpZiAoYSA8IGIpIHJldHVybiAtMTtcbiAgICAgICAgaWYgKGEgPiBiKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgIT0gYikge1xuICAgICAgICAgIGlmICghdG90YWwpIHJldHVybiBOYU47XG4gICAgICAgICAgaWYgKGEgPT0gYSkgcmV0dXJuIDE7XG4gICAgICAgICAgaWYgKGIgPT0gYikgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMDAxOiAvLyBUaGUgcmVzdFxuICAgICAgICAvLyBIZXJlIHdlIGNhbiBiZSBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICAgICAgICAvLyAxLiBKYXZhU2NyaXB0IHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAvLyAyLiBKYXZhU2NyaXB0IG9iamVjdCB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAvLyAzLiBKYXZhU2NyaXB0IG9iamVjdCB0aGFuIGNhbm5vdCBiZSBjb2VyY2VkIHRvIHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAvL1xuICAgICAgICAvLyAoMykgd2lsbCByYWlzZSBhIFtUeXBlRXJyb3JdXG4gICAgICAgIC8vICgyKSB3aWxsIGNvZXJjZSB0byBwcmltaXRpdmUgdHlwZXMgdXNpbmcgW3ZhbHVlT2ZdIG9yIFt0b1N0cmluZ11cbiAgICAgICAgLy8gKDIpIGFuZCAoMyksIGFmdGVyIGV2ZW50dWFsIGNvZXJjaW9uXG4gICAgICAgIC8vIC0gaWYgYSBhbmQgYiBhcmUgc3RyaW5ncywgYXBwbHkgbGV4aWNvZ3JhcGhpYyBjb21wYXJpc29uXG4gICAgICAgIC8vIC0gaWYgYSBvciBiIGFyZSBub3Qgc3RyaW5ncywgY29udmVydCBhIGFuZCBiIHRvIG51bWJlclxuICAgICAgICAvLyAgIGFuZCBhcHBseSBzdGFuZGFyZCBjb21wYXJpc29uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEV4Y2VwdGlvbjogYCE9YCB3aWxsIG5vdCBjb2VyY2UvY29udmVydCBpZiBib3RoIGEgYW5kIGIgYXJlIG9iamVjdHNcbiAgICAgICAgaWYgKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhICE9IGIpIHtcbiAgICAgICAgICBpZiAoIXRvdGFsKSByZXR1cm4gTmFOO1xuICAgICAgICAgIGlmIChhID09IGEpIHJldHVybiAxO1xuICAgICAgICAgIGlmIChiID09IGIpIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI1MTogLy8gSmF2YVNjcmlwdCBTeW1ib2wsIG5vIG9yZGVyaW5nLlxuICAgICAgICBpZihhICE9PSBiKSB7XG4gICAgICAgICAgaWYgKCF0b3RhbCkgcmV0dXJuIE5hTjtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI1MjogLy8gamF2YXNjcmlwdCBzdHJpbmdzXG4gICAgICAgIHZhciBhID0gYS50b1N0cmluZygpO1xuICAgICAgICB2YXIgYiA9IGIudG9TdHJpbmcoKTtcbiAgICAgICAgaWYoYSAhPT0gYikge1xuICAgICAgICAgIGlmKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgICAgaWYoYSA+IGIpIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNDY6IC8vIExhenlfdGFnXG4gICAgICBjYXNlIDI1NDogLy8gRG91YmxlX2FycmF5XG4gICAgICBkZWZhdWx0OiAvLyBCbG9jayB3aXRoIG90aGVyIHRhZ1xuICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiAoYS5sZW5ndGggPCBiLmxlbmd0aCk/LTE6MTtcbiAgICAgICAgaWYgKGEubGVuZ3RoID4gMSkgc3RhY2sucHVzaChhLCBiLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdGFjay5sZW5ndGggPT0gMCkgcmV0dXJuIDA7XG4gICAgdmFyIGkgPSBzdGFjay5wb3AoKTtcbiAgICBiID0gc3RhY2sucG9wKCk7XG4gICAgYSA9IHN0YWNrLnBvcCgpO1xuICAgIGlmIChpICsgMSA8IGEubGVuZ3RoKSBzdGFjay5wdXNoKGEsIGIsIGkgKyAxKTtcbiAgICBhID0gYVtpXTtcbiAgICBiID0gYltpXTtcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9jb21wYXJlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmUgKGEsIGIpIHsgcmV0dXJuIGNhbWxfY29tcGFyZV92YWwgKGEsIGIsIHRydWUpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2ludF9jb21wYXJlIG11dGFibGUgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfaW50X2NvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGEgPCBiKSByZXR1cm4gKC0xKTsgaWYgKGEgPT0gYikgcmV0dXJuIDA7IHJldHVybiAxO1xufVxuLy9Qcm92aWRlczogY2FtbF9lcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2VxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA9PSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9ub3RlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX25vdGVxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSAhPSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9ncmVhdGVyZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9ncmVhdGVyZXF1YWwgKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpID49IDApOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dyZWF0ZXJ0aGFuIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfZ3JlYXRlcnRoYW4gKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpID4gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbGVzc2VxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfbGVzc2VxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA8PSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9sZXNzdGhhbiBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2xlc3N0aGFuICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA8IDApOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UgKHMpIHtcbiAgdmFyIGkgPSAwLCBsZW4gPSBjYW1sX21sX3N0cmluZ19sZW5ndGgocyksIGJhc2UgPSAxMCwgc2lnbiA9IDE7XG4gIGlmIChsZW4gPiAwKSB7XG4gICAgc3dpdGNoIChjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsaSkpIHtcbiAgICBjYXNlIDQ1OiBpKys7IHNpZ24gPSAtMTsgYnJlYWs7XG4gICAgY2FzZSA0MzogaSsrOyBzaWduID0gMTsgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChpICsgMSA8IGxlbiAmJiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpID09IDQ4KVxuICAgIHN3aXRjaCAoY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpICsgMSkpIHtcbiAgICBjYXNlIDEyMDogY2FzZSA4ODogYmFzZSA9IDE2OyBpICs9IDI7IGJyZWFrO1xuICAgIGNhc2UgMTExOiBjYXNlIDc5OiBiYXNlID0gIDg7IGkgKz0gMjsgYnJlYWs7XG4gICAgY2FzZSAgOTg6IGNhc2UgNjY6IGJhc2UgPSAgMjsgaSArPSAyOyBicmVhaztcbiAgICBjYXNlIDExNzogY2FzZSA4NTogc2lnbiA9ICAwOyBpICs9IDI7IGJyZWFrO1xuICAgIH1cbiAgcmV0dXJuIFtpLCBzaWduLCBiYXNlXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9kaWdpdFxuZnVuY3Rpb24gY2FtbF9wYXJzZV9kaWdpdChjKSB7XG4gIGlmIChjID49IDQ4ICYmIGMgPD0gNTcpICByZXR1cm4gYyAtIDQ4O1xuICBpZiAoYyA+PSA2NSAmJiBjIDw9IDkwKSAgcmV0dXJuIGMgLSA1NTtcbiAgaWYgKGMgPj0gOTcgJiYgYyA8PSAxMjIpIHJldHVybiBjIC0gODc7XG4gIHJldHVybiAtMTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnRfb2Zfc3RyaW5nIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlLCBjYW1sX3BhcnNlX2RpZ2l0LCBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2ludF9vZl9zdHJpbmcgKHMpIHtcbiAgdmFyIHIgPSBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UgKHMpO1xuICB2YXIgaSA9IHJbMF0sIHNpZ24gPSByWzFdLCBiYXNlID0gclsyXTtcbiAgdmFyIGxlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKTtcbiAgdmFyIHRocmVzaG9sZCA9IC0xID4+PiAwO1xuICB2YXIgYyA9IChpIDwgbGVuKT9jYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpOjA7XG4gIHZhciBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgaWYgKGQgPCAwIHx8IGQgPj0gYmFzZSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIHZhciByZXMgPSBkO1xuICBmb3IgKGkrKztpPGxlbjtpKyspIHtcbiAgICBjID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTtcbiAgICBpZiAoYyA9PSA5NSkgY29udGludWU7XG4gICAgZCA9IGNhbWxfcGFyc2VfZGlnaXQoYyk7XG4gICAgaWYgKGQgPCAwIHx8IGQgPj0gYmFzZSkgYnJlYWs7XG4gICAgcmVzID0gYmFzZSAqIHJlcyArIGQ7XG4gICAgaWYgKHJlcyA+IHRocmVzaG9sZCkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIH1cbiAgaWYgKGkgIT0gbGVuKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgLy8gRm9yIGJhc2UgZGlmZmVyZW50IGZyb20gMTAsIHdlIGV4cGVjdCBhbiB1bnNpZ25lZCByZXByZXNlbnRhdGlvbixcbiAgLy8gaGVuY2UgYW55IHZhbHVlIG9mICdyZXMnIChsZXNzIHRoYW4gJ3RocmVzaG9sZCcpIGlzIGFjY2VwdGFibGUuXG4gIC8vIEJ1dCB3ZSBoYXZlIHRvIGNvbnZlcnQgdGhlIHJlc3VsdCBiYWNrIHRvIGEgc2lnbmVkIGludGVnZXIuXG4gIHJlcyA9IHNpZ24gKiByZXM7XG4gIGlmICgoYmFzZSA9PSAxMCkgJiYgKChyZXMgfCAwKSAhPSByZXMpKVxuICAgIC8qIFNpZ25lZCByZXByZXNlbnRhdGlvbiBleHBlY3RlZCwgYWxsb3cgLTJeKG5iaXRzLTEpIHRvIDJeKG5iaXRzLTEpIC0gMSAqL1xuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICByZXR1cm4gcmVzIHwgMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mbG9hdF9vZl9zdHJpbmcgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9mbG9hdF9vZl9zdHJpbmcocykge1xuICB2YXIgcmVzO1xuICBzID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyAocyk7XG4gIHJlcyA9ICtzO1xuICBpZiAoKHMubGVuZ3RoID4gMCkgJiYgKHJlcyA9PT0gcmVzKSkgcmV0dXJuIHJlcztcbiAgcyA9IHMucmVwbGFjZSgvXy9nLFwiXCIpO1xuICByZXMgPSArcztcbiAgaWYgKCgocy5sZW5ndGggPiAwKSAmJiAocmVzID09PSByZXMpKSB8fCAvXlsrLV0/bmFuJC9pLnRlc3QocykpIHJldHVybiByZXM7XG4gIHZhciBtID0gL14gKihbKy1dPykweChbMC05YS1mXSspXFwuPyhbMC05YS1mXSopcChbKy1dP1swLTldKykvaS5leGVjKHMpO1xuICAvLyAgICAgICAgICAxICAgICAgICAyICAgICAgICAgICAgIDMgICAgICAgICAgIDRcbiAgaWYobSl7XG4gICAgdmFyIG0zID0gbVszXS5yZXBsYWNlKC8wKyQvLCcnKTtcbiAgICB2YXIgbWFudGlzc2EgPSBwYXJzZUludChtWzFdICsgbVsyXSArIG0zLCAxNik7XG4gICAgdmFyIGV4cG9uZW50ID0gKG1bNF18MCkgLSA0Km0zLmxlbmd0aDtcbiAgICByZXMgPSBtYW50aXNzYSAqIE1hdGgucG93KDIsIGV4cG9uZW50KTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGlmKC9eXFwrP2luZihpbml0eSk/JC9pLnRlc3QocykpIHJldHVybiBJbmZpbml0eTtcbiAgaWYoL14taW5mKGluaXR5KT8kL2kudGVzdChzKSkgcmV0dXJuIC1JbmZpbml0eTtcbiAgY2FtbF9mYWlsd2l0aChcImZsb2F0X29mX3N0cmluZ1wiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19wcmludGFibGUgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9pc19wcmludGFibGUoYykgeyByZXR1cm4gKyhjID4gMzEgJiYgYyA8IDEyNyk7IH1cblxuLy8vLy8vLy8vLy8vLyBGb3JtYXRcbi8vUHJvdmlkZXM6IGNhbWxfcGFyc2VfZm9ybWF0XG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfcGFyc2VfZm9ybWF0IChmbXQpIHtcbiAgZm10ID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhmbXQpO1xuICB2YXIgbGVuID0gZm10Lmxlbmd0aDtcbiAgaWYgKGxlbiA+IDMxKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJmb3JtYXRfaW50OiBmb3JtYXQgdG9vIGxvbmdcIik7XG4gIHZhciBmID1cbiAgICAgIHsganVzdGlmeTonKycsIHNpZ25zdHlsZTonLScsIGZpbGxlcjonICcsIGFsdGVybmF0ZTpmYWxzZSxcbiAgICAgICAgYmFzZTowLCBzaWduZWRjb252OmZhbHNlLCB3aWR0aDowLCB1cHBlcmNhc2U6ZmFsc2UsXG4gICAgICAgIHNpZ246MSwgcHJlYzotMSwgY29udjonZicgfTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBjID0gZm10LmNoYXJBdChpKTtcbiAgICBzd2l0Y2ggKGMpIHtcbiAgICBjYXNlICctJzpcbiAgICAgIGYuanVzdGlmeSA9ICctJzsgYnJlYWs7XG4gICAgY2FzZSAnKyc6IGNhc2UgJyAnOlxuICAgICAgZi5zaWduc3R5bGUgPSBjOyBicmVhaztcbiAgICBjYXNlICcwJzpcbiAgICAgIGYuZmlsbGVyID0gJzAnOyBicmVhaztcbiAgICBjYXNlICcjJzpcbiAgICAgIGYuYWx0ZXJuYXRlID0gdHJ1ZTsgYnJlYWs7XG4gICAgY2FzZSAnMSc6IGNhc2UgJzInOiBjYXNlICczJzogY2FzZSAnNCc6IGNhc2UgJzUnOlxuICAgIGNhc2UgJzYnOiBjYXNlICc3JzogY2FzZSAnOCc6IGNhc2UgJzknOlxuICAgICAgZi53aWR0aCA9IDA7XG4gICAgICB3aGlsZSAoYz1mbXQuY2hhckNvZGVBdChpKSAtIDQ4LCBjID49IDAgJiYgYyA8PSA5KSB7XG4gICAgICAgIGYud2lkdGggPSBmLndpZHRoICogMTAgKyBjOyBpKytcbiAgICAgIH1cbiAgICAgIGktLTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJy4nOlxuICAgICAgZi5wcmVjID0gMDtcbiAgICAgIGkrKztcbiAgICAgIHdoaWxlIChjPWZtdC5jaGFyQ29kZUF0KGkpIC0gNDgsIGMgPj0gMCAmJiBjIDw9IDkpIHtcbiAgICAgICAgZi5wcmVjID0gZi5wcmVjICogMTAgKyBjOyBpKytcbiAgICAgIH1cbiAgICAgIGktLTtcbiAgICBjYXNlICdkJzogY2FzZSAnaSc6XG4gICAgICBmLnNpZ25lZGNvbnYgPSB0cnVlOyAvKiBmYWxsdGhyb3VnaCAqL1xuICAgIGNhc2UgJ3UnOlxuICAgICAgZi5iYXNlID0gMTA7IGJyZWFrO1xuICAgIGNhc2UgJ3gnOlxuICAgICAgZi5iYXNlID0gMTY7IGJyZWFrO1xuICAgIGNhc2UgJ1gnOlxuICAgICAgZi5iYXNlID0gMTY7IGYudXBwZXJjYXNlID0gdHJ1ZTsgYnJlYWs7XG4gICAgY2FzZSAnbyc6XG4gICAgICBmLmJhc2UgPSA4OyBicmVhaztcbiAgICBjYXNlICdlJzogY2FzZSAnZic6IGNhc2UgJ2cnOlxuICAgICAgZi5zaWduZWRjb252ID0gdHJ1ZTsgZi5jb252ID0gYzsgYnJlYWs7XG4gICAgY2FzZSAnRSc6IGNhc2UgJ0YnOiBjYXNlICdHJzpcbiAgICAgIGYuc2lnbmVkY29udiA9IHRydWU7IGYudXBwZXJjYXNlID0gdHJ1ZTtcbiAgICAgIGYuY29udiA9IGMudG9Mb3dlckNhc2UgKCk7IGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maW5pc2hfZm9ybWF0dGluZ1xuLy9SZXF1aXJlczogY2FtbF9uZXdfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nKGYsIHJhd2J1ZmZlcikge1xuICBpZiAoZi51cHBlcmNhc2UpIHJhd2J1ZmZlciA9IHJhd2J1ZmZlci50b1VwcGVyQ2FzZSgpO1xuICB2YXIgbGVuID0gcmF3YnVmZmVyLmxlbmd0aDtcbiAgLyogQWRqdXN0IGxlbiB0byByZWZsZWN0IGFkZGl0aW9uYWwgY2hhcnMgKHNpZ24sIGV0YykgKi9cbiAgaWYgKGYuc2lnbmVkY29udiAmJiAoZi5zaWduIDwgMCB8fCBmLnNpZ25zdHlsZSAhPSAnLScpKSBsZW4rKztcbiAgaWYgKGYuYWx0ZXJuYXRlKSB7XG4gICAgaWYgKGYuYmFzZSA9PSA4KSBsZW4gKz0gMTtcbiAgICBpZiAoZi5iYXNlID09IDE2KSBsZW4gKz0gMjtcbiAgfVxuICAvKiBEbyB0aGUgZm9ybWF0dGluZyAqL1xuICB2YXIgYnVmZmVyID0gXCJcIjtcbiAgaWYgKGYuanVzdGlmeSA9PSAnKycgJiYgZi5maWxsZXIgPT0gJyAnKVxuICAgIGZvciAodmFyIGkgPSBsZW47IGkgPCBmLndpZHRoOyBpKyspIGJ1ZmZlciArPSAnICc7XG4gIGlmIChmLnNpZ25lZGNvbnYpIHtcbiAgICBpZiAoZi5zaWduIDwgMCkgYnVmZmVyICs9ICctJztcbiAgICBlbHNlIGlmIChmLnNpZ25zdHlsZSAhPSAnLScpIGJ1ZmZlciArPSBmLnNpZ25zdHlsZTtcbiAgfVxuICBpZiAoZi5hbHRlcm5hdGUgJiYgZi5iYXNlID09IDgpIGJ1ZmZlciArPSAnMCc7XG4gIGlmIChmLmFsdGVybmF0ZSAmJiBmLmJhc2UgPT0gMTYpIGJ1ZmZlciArPSBcIjB4XCI7XG4gIGlmIChmLmp1c3RpZnkgPT0gJysnICYmIGYuZmlsbGVyID09ICcwJylcbiAgICBmb3IgKHZhciBpID0gbGVuOyBpIDwgZi53aWR0aDsgaSsrKSBidWZmZXIgKz0gJzAnO1xuICBidWZmZXIgKz0gcmF3YnVmZmVyO1xuICBpZiAoZi5qdXN0aWZ5ID09ICctJylcbiAgICBmb3IgKHZhciBpID0gbGVuOyBpIDwgZi53aWR0aDsgaSsrKSBidWZmZXIgKz0gJyAnO1xuICByZXR1cm4gY2FtbF9uZXdfc3RyaW5nIChidWZmZXIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zvcm1hdF9pbnQgY29uc3QgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2VfZm9ybWF0LCBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nLCBjYW1sX3N0cl9yZXBlYXRcbi8vUmVxdWlyZXM6IGNhbWxfbmV3X3N0cmluZywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9mb3JtYXRfaW50KGZtdCwgaSkge1xuICBpZiAoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhmbXQpID09IFwiJWRcIikgcmV0dXJuIGNhbWxfbmV3X3N0cmluZyhcIlwiK2kpO1xuICB2YXIgZiA9IGNhbWxfcGFyc2VfZm9ybWF0KGZtdCk7XG4gIGlmIChpIDwgMCkgeyBpZiAoZi5zaWduZWRjb252KSB7IGYuc2lnbiA9IC0xOyBpID0gLWk7IH0gZWxzZSBpID4+Pj0gMDsgfVxuICB2YXIgcyA9IGkudG9TdHJpbmcoZi5iYXNlKTtcbiAgaWYgKGYucHJlYyA+PSAwKSB7XG4gICAgZi5maWxsZXIgPSAnICc7XG4gICAgdmFyIG4gPSBmLnByZWMgLSBzLmxlbmd0aDtcbiAgICBpZiAobiA+IDApIHMgPSBjYW1sX3N0cl9yZXBlYXQgKG4sICcwJykgKyBzO1xuICB9XG4gIHJldHVybiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nKGYsIHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zvcm1hdF9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9mb3JtYXQsIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmdcbmZ1bmN0aW9uIGNhbWxfZm9ybWF0X2Zsb2F0IChmbXQsIHgpIHtcbiAgZnVuY3Rpb24gdG9GaXhlZCh4LGRwKSB7XG4gICAgaWYgKE1hdGguYWJzKHgpIDwgMS4wKSB7XG4gICAgICByZXR1cm4geC50b0ZpeGVkKGRwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGUgPSBwYXJzZUludCh4LnRvU3RyaW5nKCkuc3BsaXQoJysnKVsxXSk7XG4gICAgICBpZiAoZSA+IDIwKSB7XG4gICAgICAgIGUgLT0gMjA7XG4gICAgICAgIHggLz0gTWF0aC5wb3coMTAsZSk7XG4gICAgICAgIHggKz0gKG5ldyBBcnJheShlKzEpKS5qb2luKCcwJyk7XG4gICAgICAgIGlmKGRwID4gMCkge1xuICAgICAgICAgIHggPSB4ICsgJy4nICsgKG5ldyBBcnJheShkcCsxKSkuam9pbignMCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgICAgfVxuICAgICAgZWxzZSByZXR1cm4geC50b0ZpeGVkKGRwKVxuICAgIH1cbiAgfVxuICB2YXIgcywgZiA9IGNhbWxfcGFyc2VfZm9ybWF0KGZtdCk7XG4gIHZhciBwcmVjID0gKGYucHJlYyA8IDApPzY6Zi5wcmVjO1xuICBpZiAoeCA8IDAgfHwgKHggPT0gMCAmJiAxL3ggPT0gLUluZmluaXR5KSkgeyBmLnNpZ24gPSAtMTsgeCA9IC14OyB9XG4gIGlmIChpc05hTih4KSkgeyBzID0gXCJuYW5cIjsgZi5maWxsZXIgPSAnICc7IH1cbiAgZWxzZSBpZiAoIWlzRmluaXRlKHgpKSB7IHMgPSBcImluZlwiOyBmLmZpbGxlciA9ICcgJzsgfVxuICBlbHNlXG4gICAgc3dpdGNoIChmLmNvbnYpIHtcbiAgICBjYXNlICdlJzpcbiAgICAgIHZhciBzID0geC50b0V4cG9uZW50aWFsKHByZWMpO1xuICAgICAgLy8gZXhwb25lbnQgc2hvdWxkIGJlIGF0IGxlYXN0IHR3byBkaWdpdHNcbiAgICAgIHZhciBpID0gcy5sZW5ndGg7XG4gICAgICBpZiAocy5jaGFyQXQoaSAtIDMpID09ICdlJylcbiAgICAgICAgcyA9IHMuc2xpY2UgKDAsIGkgLSAxKSArICcwJyArIHMuc2xpY2UgKGkgLSAxKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2YnOlxuICAgICAgcyA9IHRvRml4ZWQoeCwgcHJlYyk7IGJyZWFrO1xuICAgIGNhc2UgJ2cnOlxuICAgICAgcHJlYyA9IHByZWM/cHJlYzoxO1xuICAgICAgcyA9IHgudG9FeHBvbmVudGlhbChwcmVjIC0gMSk7XG4gICAgICB2YXIgaiA9IHMuaW5kZXhPZignZScpO1xuICAgICAgdmFyIGV4cCA9ICtzLnNsaWNlKGogKyAxKTtcbiAgICAgIGlmIChleHAgPCAtNCB8fCB4ID49IDFlMjEgfHwgeC50b0ZpeGVkKDApLmxlbmd0aCA+IHByZWMpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHplcm9lc1xuICAgICAgICB2YXIgaSA9IGogLSAxOyB3aGlsZSAocy5jaGFyQXQoaSkgPT0gJzAnKSBpLS07XG4gICAgICAgIGlmIChzLmNoYXJBdChpKSA9PSAnLicpIGktLTtcbiAgICAgICAgcyA9IHMuc2xpY2UoMCwgaSArIDEpICsgcy5zbGljZShqKTtcbiAgICAgICAgaSA9IHMubGVuZ3RoO1xuICAgICAgICBpZiAocy5jaGFyQXQoaSAtIDMpID09ICdlJylcbiAgICAgICAgICBzID0gcy5zbGljZSAoMCwgaSAtIDEpICsgJzAnICsgcy5zbGljZSAoaSAtIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwID0gcHJlYztcbiAgICAgICAgaWYgKGV4cCA8IDApIHsgcCAtPSBleHAgKyAxOyBzID0geC50b0ZpeGVkKHApOyB9XG4gICAgICAgIGVsc2Ugd2hpbGUgKHMgPSB4LnRvRml4ZWQocCksIHMubGVuZ3RoID4gcHJlYyArIDEpIHAtLTtcbiAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAvLyByZW1vdmUgdHJhaWxpbmcgemVyb2VzXG4gICAgICAgICAgdmFyIGkgPSBzLmxlbmd0aCAtIDE7IHdoaWxlIChzLmNoYXJBdChpKSA9PSAnMCcpIGktLTtcbiAgICAgICAgICBpZiAocy5jaGFyQXQoaSkgPT0gJy4nKSBpLS07XG4gICAgICAgICAgcyA9IHMuc2xpY2UoMCwgaSArIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gIHJldHVybiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nKGYsIHMpO1xufVxuXG4vLy8vLy8vLy8vLy8vIEhhc2h0Ymxcbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF91bml2X3BhcmFtIG11dGFibGVcbi8vUmVxdWlyZXM6IE1sQnl0ZXMsIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXMsIGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCwgY2FtbF9jdXN0b21fb3BzXG5mdW5jdGlvbiBjYW1sX2hhc2hfdW5pdl9wYXJhbSAoY291bnQsIGxpbWl0LCBvYmopIHtcbiAgdmFyIGhhc2hfYWNjdSA9IDA7XG4gIGZ1bmN0aW9uIGhhc2hfYXV4IChvYmopIHtcbiAgICBsaW1pdCAtLTtcbiAgICBpZiAoY291bnQgPCAwIHx8IGxpbWl0IDwgMCkgcmV0dXJuO1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBBcnJheSAmJiBvYmpbMF0gPT09IChvYmpbMF18MCkpIHtcbiAgICAgIHN3aXRjaCAob2JqWzBdKSB7XG4gICAgICBjYXNlIDI0ODpcbiAgICAgICAgLy8gT2JqZWN0XG4gICAgICAgIGNvdW50IC0tO1xuICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogNjU1OTkgKyBvYmpbMl0pIHwgMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MDpcbiAgICAgICAgLy8gRm9yd2FyZFxuICAgICAgICBsaW1pdCsrOyBoYXNoX2F1eChvYmopOyBicmVhaztcbiAgICAgIGNhc2UgMjU1OlxuICAgICAgICAvLyBJbnQ2NFxuICAgICAgICBjb3VudCAtLTtcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDY1NTk5ICsgb2JqWzFdICsgKG9ialsyXSA8PCAyNCkpIHwgMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb3VudCAtLTtcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgb2JqWzBdKSB8IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSBvYmoubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkgaGFzaF9hdXggKG9ialtpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBNbEJ5dGVzKSB7XG4gICAgICBjb3VudCAtLTtcbiAgICAgIHN3aXRjaCAob2JqLnQgJiA2KSB7XG4gICAgICBkZWZhdWx0OiAvKiBQQVJUSUFMICovXG4gICAgICAgIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMob2JqKTtcbiAgICAgIGNhc2UgMDogLyogQllURVMgKi9cbiAgICAgICAgZm9yICh2YXIgYiA9IG9iai5jLCBsID0gb2JqLmwsIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIGIuY2hhckNvZGVBdChpKSkgfCAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjogLyogQVJSQVkgKi9cbiAgICAgICAgZm9yICh2YXIgYSA9IG9iai5jLCBsID0gb2JqLmwsIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIGFbaV0pIHwgMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9iaiA9PT0gKG9ianwwKSkge1xuICAgICAgLy8gSW50ZWdlclxuICAgICAgY291bnQgLS07XG4gICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogNjU1OTkgKyBvYmopIHwgMDtcbiAgICB9IGVsc2UgaWYgKG9iaiA9PT0gK29iaikge1xuICAgICAgLy8gRmxvYXRcbiAgICAgIGNvdW50LS07XG4gICAgICB2YXIgcCA9IGNhbWxfaW50NjRfdG9fYnl0ZXMgKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCAob2JqKSk7XG4gICAgICBmb3IgKHZhciBpID0gNzsgaSA+PSAwOyBpLS0pIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIHBbaV0pIHwgMDtcbiAgICB9IGVsc2UgaWYob2JqICYmIG9iai5jYW1sX2N1c3RvbSkge1xuICAgICAgaWYoY2FtbF9jdXN0b21fb3BzW29iai5jYW1sX2N1c3RvbV0gJiYgY2FtbF9jdXN0b21fb3BzW29iai5jYW1sX2N1c3RvbV0uaGFzaCkge1xuICAgICAgICB2YXIgaCA9IGNhbWxfY3VzdG9tX29wc1tvYmouY2FtbF9jdXN0b21dLmhhc2gob2JqKSB8IDA7XG4gICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiA2NTU5OSArIGgpIHwgMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaGFzaF9hdXggKG9iaik7XG4gIHJldHVybiBoYXNoX2FjY3UgJiAweDNGRkZGRkZGO1xufVxuXG4vL2Z1bmN0aW9uIFJPVEwzMih4LG4pIHsgcmV0dXJuICgoeCA8PCBuKSB8ICh4ID4+PiAoMzItbikpKTsgfVxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfbXVsXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2ludChoLGQpIHtcbiAgZCA9IGNhbWxfbXVsKGQsIDB4Y2M5ZTJkNTF8MCk7XG4gIGQgPSAoKGQgPDwgMTUpIHwgKGQgPj4+ICgzMi0xNSkpKTsgLy8gUk9UTDMyKGQsIDE1KTtcbiAgZCA9IGNhbWxfbXVsKGQsIDB4MWI4NzM1OTMpO1xuICBoIF49IGQ7XG4gIGggPSAoKGggPDwgMTMpIHwgKGggPj4+ICgzMi0xMykpKTsgICAvL1JPVEwzMihoLCAxMyk7XG4gIHJldHVybiAoKChoICsgKGggPDwgMikpfDApICsgKDB4ZTY1NDZiNjR8MCkpfDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfZmluYWxcbi8vUmVxdWlyZXM6IGNhbWxfbXVsXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2ZpbmFsKGgpIHtcbiAgaCBePSBoID4+PiAxNjtcbiAgaCA9IGNhbWxfbXVsIChoLCAweDg1ZWJjYTZifDApO1xuICBoIF49IGggPj4+IDEzO1xuICBoID0gY2FtbF9tdWwgKGgsIDB4YzJiMmFlMzV8MCk7XG4gIGggXj0gaCA+Pj4gMTY7XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2Zsb2F0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQsIGNhbWxfaGFzaF9taXhfaW50NjRcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfZmxvYXQgKGgsIHYwKSB7XG4gIHJldHVybiBjYW1sX2hhc2hfbWl4X2ludDY0KGgsIGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCAodjApKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfaW50NjRcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2xvMzIsIGNhbWxfaW50NjRfaGkzMlxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9pbnQ2NCAoaCwgdikge1xuICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgY2FtbF9pbnQ2NF9sbzMyKHYpKTtcbiAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGNhbWxfaW50NjRfaGkzMih2KSk7XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X3N0cmluZ19zdHJcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50XG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X3N0cmluZ19zdHIoaCwgcykge1xuICB2YXIgbGVuID0gcy5sZW5ndGgsIGksIHc7XG4gIGZvciAoaSA9IDA7IGkgKyA0IDw9IGxlbjsgaSArPSA0KSB7XG4gICAgdyA9IHMuY2hhckNvZGVBdChpKVxuICAgICAgfCAocy5jaGFyQ29kZUF0KGkrMSkgPDwgOClcbiAgICAgIHwgKHMuY2hhckNvZGVBdChpKzIpIDw8IDE2KVxuICAgICAgfCAocy5jaGFyQ29kZUF0KGkrMykgPDwgMjQpO1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgfVxuICB3ID0gMDtcbiAgc3dpdGNoIChsZW4gJiAzKSB7XG4gIGNhc2UgMzogdyAgPSBzLmNoYXJDb2RlQXQoaSsyKSA8PCAxNjtcbiAgY2FzZSAyOiB3IHw9IHMuY2hhckNvZGVBdChpKzEpIDw8IDg7XG4gIGNhc2UgMTpcbiAgICB3IHw9IHMuY2hhckNvZGVBdChpKTtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gIGRlZmF1bHQ6XG4gIH1cbiAgaCBePSBsZW47XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X3N0cmluZ19hcnJcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50XG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X3N0cmluZ19hcnIoaCwgcykge1xuICB2YXIgbGVuID0gcy5sZW5ndGgsIGksIHc7XG4gIGZvciAoaSA9IDA7IGkgKyA0IDw9IGxlbjsgaSArPSA0KSB7XG4gICAgdyA9IHNbaV1cbiAgICAgIHwgKHNbaSsxXSA8PCA4KVxuICAgICAgfCAoc1tpKzJdIDw8IDE2KVxuICAgICAgfCAoc1tpKzNdIDw8IDI0KTtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gIH1cbiAgdyA9IDA7XG4gIHN3aXRjaCAobGVuICYgMykge1xuICBjYXNlIDM6IHcgID0gc1tpKzJdIDw8IDE2O1xuICBjYXNlIDI6IHcgfD0gc1tpKzFdIDw8IDg7XG4gIGNhc2UgMTogdyB8PSBzW2ldO1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgZGVmYXVsdDpcbiAgfVxuICBoIF49IGxlbjtcbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X3N0cmluZ19zdHJcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfc3RyaW5nX2FyclxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9zdHJpbmcoaCwgdikge1xuICBzd2l0Y2ggKHYudCAmIDYpIHtcbiAgZGVmYXVsdDpcbiAgICBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzICh2KTtcbiAgY2FzZSAwOiAvKiBCWVRFUyAqL1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X3N0cmluZ19zdHIoaCwgdi5jKTtcbiAgICBicmVhaztcbiAgY2FzZSAyOiAvKiBBUlJBWSAqL1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X3N0cmluZ19hcnIoaCwgdi5jKTtcbiAgfVxuICByZXR1cm4gaFxufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaCBtdXRhYmxlXG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQsIGNhbWxfaGFzaF9taXhfaW50LCBjYW1sX2hhc2hfbWl4X2ZpbmFsXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludDY0LCBjYW1sX2hhc2hfbWl4X2Zsb2F0LCBjYW1sX2hhc2hfbWl4X3N0cmluZywgY2FtbF9jdXN0b21fb3BzXG5mdW5jdGlvbiBjYW1sX2hhc2ggKGNvdW50LCBsaW1pdCwgc2VlZCwgb2JqKSB7XG4gIHZhciBxdWV1ZSwgcmQsIHdyLCBzeiwgbnVtLCBoLCB2LCBpLCBsZW47XG4gIHN6ID0gbGltaXQ7XG4gIGlmIChzeiA8IDAgfHwgc3ogPiAyNTYpIHN6ID0gMjU2O1xuICBudW0gPSBjb3VudDtcbiAgaCA9IHNlZWQ7XG4gIHF1ZXVlID0gW29ial07IHJkID0gMDsgd3IgPSAxO1xuICB3aGlsZSAocmQgPCB3ciAmJiBudW0gPiAwKSB7XG4gICAgdiA9IHF1ZXVlW3JkKytdO1xuICAgIGlmICh2ICYmIHYuY2FtbF9jdXN0b20pe1xuICAgICAgaWYoY2FtbF9jdXN0b21fb3BzW3YuY2FtbF9jdXN0b21dICYmIGNhbWxfY3VzdG9tX29wc1t2LmNhbWxfY3VzdG9tXS5oYXNoKSB7XG4gICAgICAgIHZhciBoaCA9IGNhbWxfY3VzdG9tX29wc1t2LmNhbWxfY3VzdG9tXS5oYXNoKHYpO1xuICAgICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQgKGgsIGhoKTtcbiAgICAgICAgbnVtIC0tO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh2IGluc3RhbmNlb2YgQXJyYXkgJiYgdlswXSA9PT0gKHZbMF18MCkpIHtcbiAgICAgIHN3aXRjaCAodlswXSkge1xuICAgICAgY2FzZSAyNDg6XG4gICAgICAgIC8vIE9iamVjdFxuICAgICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdlsyXSk7XG4gICAgICAgIG51bS0tO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUwOlxuICAgICAgICAvLyBGb3J3YXJkXG4gICAgICAgIHF1ZXVlWy0tcmRdID0gdlsxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1NTpcbiAgICAgICAgLy8gSW50NjRcbiAgICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50NjQgKGgsIHYpO1xuICAgICAgICBudW0gLS07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIHRhZyA9ICgodi5sZW5ndGggLSAxKSA8PCAxMCkgfCB2WzBdO1xuICAgICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdGFnKTtcbiAgICAgICAgZm9yIChpID0gMSwgbGVuID0gdi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmICh3ciA+PSBzeikgYnJlYWs7XG4gICAgICAgICAgcXVldWVbd3IrK10gPSB2W2ldO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodiBpbnN0YW5jZW9mIE1sQnl0ZXMpIHtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X3N0cmluZyhoLHYpXG4gICAgICBudW0tLTtcbiAgICB9IGVsc2UgaWYgKHYgPT09ICh2fDApKSB7XG4gICAgICAvLyBJbnRlZ2VyXG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdit2KzEpO1xuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmICh2ID09PSArdikge1xuICAgICAgLy8gRmxvYXRcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2Zsb2F0KGgsdik7XG4gICAgICBudW0tLTtcbiAgICB9XG4gIH1cbiAgaCA9IGNhbWxfaGFzaF9taXhfZmluYWwoaCk7XG4gIHJldHVybiBoICYgMHgzRkZGRkZGRjtcbn1cblxuLy8vLy8vLy8vLy8vLyBTeXNcbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3RpbWUgbXV0YWJsZVxudmFyIGNhbWxfaW5pdGlhbF90aW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAqIDAuMDAxO1xuZnVuY3Rpb24gY2FtbF9zeXNfdGltZSAoKSB7XG4gIHZhciBub3cgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICByZXR1cm4gbm93ICogMC4wMDEgLSBjYW1sX2luaXRpYWxfdGltZTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0X2NvbmZpZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9uZXdfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N5c19nZXRfY29uZmlnICgpIHtcbiAgcmV0dXJuIFswLCBjYW1sX25ld19zdHJpbmcoXCJVbml4XCIpLCAzMiwgMF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X2JhY2tlbmRfdHlwZSBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9uZXdfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9iYWNrZW5kX3R5cGUgKCkge1xuICByZXR1cm4gWzAsIGNhbWxfbmV3X3N0cmluZyhcImpzX29mX29jYW1sXCIpXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcmFuZG9tX3NlZWQgbXV0YWJsZVxuLy9UaGUgZnVuY3Rpb24gbmVlZHMgdG8gcmV0dXJuIGFuIGFycmF5IHNpbmNlIE9DYW1sIDQuMC4uLlxuZnVuY3Rpb24gY2FtbF9zeXNfcmFuZG9tX3NlZWQgKCkge1xuICB2YXIgbm93ID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgdmFyIHggPSBub3deMHhmZmZmZmZmZipNYXRoLnJhbmRvbSgpO1xuICByZXR1cm4gWzAseF07XG59XG5cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9iaWdfZW5kaWFuIGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9iaWdfZW5kaWFuICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X3dvcmRfc2l6ZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3Rfd29yZF9zaXplICgpIHsgcmV0dXJuIDMyOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9pbnRfc2l6ZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfaW50X3NpemUgKCkgeyByZXR1cm4gMzI7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfbWF4X3dvc2l6ZSBjb25zdFxuLy8gbWF4X2ludCAvIDQgc28gdGhhdCB0aGUgZm9sbG93aW5nIGRvZXMgbm90IG92ZXJmbG93XG4vL2xldCBtYXhfc3RyaW5nX2xlbmd0aCA9IHdvcmRfc2l6ZSAvIDggKiBtYXhfYXJyYXlfbGVuZ3RoIC0gMTs7XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9tYXhfd29zaXplICgpIHsgcmV0dXJuICgweDdGRkZGRkZGLzQpIHwgMDt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X29zdHlwZV9jeWd3aW4gY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X29zdHlwZV9jeWd3aW4gKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3VuaXggY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X29zdHlwZV91bml4ICgpIHsgcmV0dXJuIDE7IH1cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X29zdHlwZV93aW4zMiBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3dpbjMyICgpIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfc3lzdGVtX2NvbW1hbmRcbmZ1bmN0aW9uIGNhbWxfc3lzX3N5c3RlbV9jb21tYW5kKGNtZCl7XG4gIHZhciBjbWQgPSBjbWQudG9TdHJpbmcoKTtcbiAgam9vX2dsb2JhbF9vYmplY3QuY29uc29sZS5sb2coY21kKTtcbiAgaWYgKHR5cGVvZiByZXF1aXJlICE9IFwidW5kZWZpbmVkXCJcbiAgICAgICYmIHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKVxuICAgICAgJiYgcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWNTeW5jKSB7XG4gICAgdHJ5IHtyZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlY1N5bmMoY21kKTsgcmV0dXJuIDB9XG4gICAgY2F0Y2ggKGUpIHtyZXR1cm4gMX1cbiAgfVxuICBlbHNlIHJldHVybiAxMjc7XG59XG5cbi8vLy8vLy8vLy8vLy8gQXJyYXlcbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfc3ViIG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfc3ViIChhLCBpLCBsZW4pIHtcbiAgdmFyIGEyID0gbmV3IEFycmF5KGxlbisxKTtcbiAgYTJbMF09MDtcbiAgZm9yKHZhciBpMiA9IDEsIGkxPSBpKzE7IGkyIDw9IGxlbjsgaTIrKyxpMSsrICl7XG4gICAgYTJbaTJdPWFbaTFdO1xuICB9XG4gIHJldHVybiBhMjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9hcHBlbmQgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9hcnJheV9hcHBlbmQoYTEsIGEyKSB7XG4gIHZhciBsMSA9IGExLmxlbmd0aCwgbDIgPSBhMi5sZW5ndGg7XG4gIHZhciBsID0gbDErbDItMVxuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgYVswXSA9IDA7XG4gIHZhciBpID0gMSxqID0gMTtcbiAgZm9yKDtpPGwxO2krKykgYVtpXT1hMVtpXTtcbiAgZm9yKDtpPGw7aSsrLGorKykgYVtpXT1hMltqXTtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfY29uY2F0IG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfY29uY2F0KGwpIHtcbiAgdmFyIGEgPSBbMF07XG4gIHdoaWxlIChsICE9PSAwKSB7XG4gICAgdmFyIGIgPSBsWzFdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYi5sZW5ndGg7IGkrKykgYS5wdXNoKGJbaV0pO1xuICAgIGwgPSBsWzJdO1xuICB9XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2JsaXRcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfYmxpdChhMSwgaTEsIGEyLCBpMiwgbGVuKSB7XG4gIGlmIChpMiA8PSBpMSkge1xuICAgIGZvciAodmFyIGogPSAxOyBqIDw9IGxlbjsgaisrKSBhMltpMiArIGpdID0gYTFbaTEgKyBqXTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBqID0gbGVuOyBqID49IDE7IGotLSkgYTJbaTIgKyBqXSA9IGExW2kxICsgal07XG4gIH07XG4gIHJldHVybiAwO1xufVxuXG4vLy8vLy8vLy8vLy8vIENhbWxpbnRlcm5hbE9PXG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9wdWJsaWNfbWV0aG9kIGNvbnN0XG52YXIgY2FtbF9tZXRob2RfY2FjaGUgPSBbXTtcbmZ1bmN0aW9uIGNhbWxfZ2V0X3B1YmxpY19tZXRob2QgKG9iaiwgdGFnLCBjYWNoZWlkKSB7XG4gIHZhciBtZXRocyA9IG9ialsxXTtcbiAgdmFyIG9mcyA9IGNhbWxfbWV0aG9kX2NhY2hlW2NhY2hlaWRdO1xuICBpZiAob2ZzID09PSBudWxsKSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBhcnJheSBpcyBub3Qgc3BhcnNlXG4gICAgZm9yICh2YXIgaSA9IGNhbWxfbWV0aG9kX2NhY2hlLmxlbmd0aDsgaSA8IGNhY2hlaWQ7IGkrKylcbiAgICAgIGNhbWxfbWV0aG9kX2NhY2hlW2ldID0gMDtcbiAgfSBlbHNlIGlmIChtZXRoc1tvZnNdID09PSB0YWcpIHtcbiAgICByZXR1cm4gbWV0aHNbb2ZzIC0gMV07XG4gIH1cbiAgdmFyIGxpID0gMywgaGkgPSBtZXRoc1sxXSAqIDIgKyAxLCBtaTtcbiAgd2hpbGUgKGxpIDwgaGkpIHtcbiAgICBtaSA9ICgobGkraGkpID4+IDEpIHwgMTtcbiAgICBpZiAodGFnIDwgbWV0aHNbbWkrMV0pIGhpID0gbWktMjtcbiAgICBlbHNlIGxpID0gbWk7XG4gIH1cbiAgY2FtbF9tZXRob2RfY2FjaGVbY2FjaGVpZF0gPSBsaSArIDE7XG4gIC8qIHJldHVybiAwIGlmIHRhZyBpcyBub3QgdGhlcmUgKi9cbiAgcmV0dXJuICh0YWcgPT0gbWV0aHNbbGkrMV0gPyBtZXRoc1tsaV0gOiAwKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maW5hbF9yZWdpc3RlciBjb25zdFxuZnVuY3Rpb24gY2FtbF9maW5hbF9yZWdpc3RlciAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbmFsX3JlZ2lzdGVyX2NhbGxlZF93aXRob3V0X3ZhbHVlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ZpbmFsX3JlZ2lzdGVyX2NhbGxlZF93aXRob3V0X3ZhbHVlICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZmluYWxfcmVsZWFzZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9maW5hbF9yZWxlYXNlICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfYmFja3RyYWNlX3N0YXR1cyBjb25zdFxuZnVuY3Rpb24gY2FtbF9iYWNrdHJhY2Vfc3RhdHVzICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2V4Y2VwdGlvbl9iYWNrdHJhY2UgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZ2V0X2V4Y2VwdGlvbl9iYWNrdHJhY2UgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9nZXRfZXhjZXB0aW9uX3Jhd19iYWNrdHJhY2UgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZ2V0X2V4Y2VwdGlvbl9yYXdfYmFja3RyYWNlICgpIHsgcmV0dXJuIFswXTsgfVxuLy9Qcm92aWRlczogY2FtbF9yZWNvcmRfYmFja3RyYWNlXG5mdW5jdGlvbiBjYW1sX3JlY29yZF9iYWNrdHJhY2UgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2UgY29uc3RcbmZ1bmN0aW9uIGNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlICgpIHsgcmV0dXJuIFswXTsgfVxuLy9Qcm92aWRlczogY2FtbF9yYXdfYmFja3RyYWNlX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9yYXdfYmFja3RyYWNlX2xlbmd0aCgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3RcbmZ1bmN0aW9uIGNhbWxfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3QoKSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNhbWxfcmF3X2JhY2t0cmFjZV9zbG90XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfcmF3X2JhY2t0cmFjZV9zbG90ICgpIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiUHJpbnRleGMuZ2V0X3Jhd19iYWNrdHJhY2Vfc2xvdDogaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfcmVzdG9yZV9yYXdfYmFja3RyYWNlXG5mdW5jdGlvbiBjYW1sX3Jlc3RvcmVfcmF3X2JhY2t0cmFjZShleG4sIGJ0KSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2N1cnJlbnRfY2FsbHN0YWNrIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2dldF9jdXJyZW50X2NhbGxzdGFjayAoKSB7IHJldHVybiBbMF07IH1cblxuLy9Qcm92aWRlczogY2FtbF9zZXRfc3RhdGljX2VudlxuZnVuY3Rpb24gY2FtbF9zZXRfc3RhdGljX2VudihrLHYpe1xuICBpZigham9vX2dsb2JhbF9vYmplY3QuanNvb19zdGF0aWNfZW52KVxuICAgIGpvb19nbG9iYWxfb2JqZWN0Lmpzb29fc3RhdGljX2VudiA9IHt9XG4gIGpvb19nbG9iYWxfb2JqZWN0Lmpzb29fc3RhdGljX2VudltrXSA9IHY7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0ZW52IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfbm90X2ZvdW5kXG4vL1JlcXVpcmVzOiBjYW1sX2pzX3RvX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9zeXNfZ2V0ZW52IChuYW1lKSB7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIHZhciBuID0gbmFtZS50b1N0cmluZygpO1xuICAvL25vZGVqcyBlbnZcbiAgaWYoZy5wcm9jZXNzXG4gICAgICYmIGcucHJvY2Vzcy5lbnZcbiAgICAgJiYgZy5wcm9jZXNzLmVudltuXSAhPSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGNhbWxfanNfdG9fc3RyaW5nKGcucHJvY2Vzcy5lbnZbbl0pO1xuICBpZihqb29fZ2xvYmFsX29iamVjdC5qc29vX3N0YXRpY19lbnZcbiAgICAgJiYgam9vX2dsb2JhbF9vYmplY3QuanNvb19zdGF0aWNfZW52W25dKVxuICAgIHJldHVybiBjYW1sX2pzX3RvX3N0cmluZyhqb29fZ2xvYmFsX29iamVjdC5qc29vX3N0YXRpY19lbnZbbl0pXG4gIGNhbWxfcmFpc2Vfbm90X2ZvdW5kICgpO1xufVxuLy9Qcm92aWRlczogY2FtbF9zeXNfZXhpdFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3N5c19leGl0IChjb2RlKSB7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIGlmKGcucXVpdCkgZy5xdWl0KGNvZGUpO1xuICAvL25vZGVqc1xuICBpZihnLnByb2Nlc3MgJiYgZy5wcm9jZXNzLmV4aXQpXG4gICAgZy5wcm9jZXNzLmV4aXQoY29kZSk7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkZ1bmN0aW9uICdleGl0JyBub3QgaW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJndlxuLy9SZXF1aXJlczogY2FtbF9qc190b19zdHJpbmdcbi8vUmVxdWlyZXM6IHJhd19hcnJheV9zdWJcbnZhciBjYW1sX2FyZ3YgPSAoKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgdmFyIG1haW4gPSBcImEub3V0XCI7XG4gIHZhciBhcmdzID0gW11cblxuICBpZihnLnByb2Nlc3NcbiAgICAgJiYgZy5wcm9jZXNzLmFyZ3ZcbiAgICAgJiYgZy5wcm9jZXNzLmFyZ3YubGVuZ3RoID4gMSkge1xuICAgIHZhciBhcmd2ID0gZy5wcm9jZXNzLmFyZ3ZcbiAgICAvL25vZGVqc1xuICAgIG1haW4gPSBhcmd2WzFdO1xuICAgIGFyZ3MgPSByYXdfYXJyYXlfc3ViKGFyZ3YsMixhcmd2Lmxlbmd0aCAtIDIpO1xuICB9XG5cbiAgdmFyIHAgPSBjYW1sX2pzX3RvX3N0cmluZyhtYWluKTtcbiAgdmFyIGFyZ3MyID0gWzAsIHBdO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKylcbiAgICBhcmdzMi5wdXNoKGNhbWxfanNfdG9fc3RyaW5nKGFyZ3NbaV0pKTtcbiAgcmV0dXJuIGFyZ3MyO1xufSkoKSlcblxuLy9Qcm92aWRlczogY2FtbF9leGVjdXRhYmxlX25hbWVcbi8vUmVxdWlyZXM6IGNhbWxfYXJndlxudmFyIGNhbWxfZXhlY3V0YWJsZV9uYW1lID0gY2FtbF9hcmd2WzFdXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2dldF9hcmd2XG4vL1JlcXVpcmVzOiBjYW1sX2FyZ3ZcbmZ1bmN0aW9uIGNhbWxfc3lzX2dldF9hcmd2IChhKSB7XG4gIHJldHVybiBbMCwgY2FtbF9hcmd2WzFdLCBjYW1sX2FyZ3ZdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19hcmd2XG4vL1JlcXVpcmVzOiBjYW1sX2FyZ3ZcbmZ1bmN0aW9uIGNhbWxfc3lzX2FyZ3YgKGEpIHtcbiAgcmV0dXJuIGNhbWxfYXJndjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfbW9kaWZ5X2FyZ3Zcbi8vUmVxdWlyZXM6IGNhbWxfYXJndlxuZnVuY3Rpb24gY2FtbF9zeXNfbW9kaWZ5X2FyZ3YoYXJnKXtcbiAgY2FtbF9hcmd2ID0gYXJnO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZXhlY3V0YWJsZV9uYW1lIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2V4ZWN1dGFibGVfbmFtZVxuZnVuY3Rpb24gY2FtbF9zeXNfZXhlY3V0YWJsZV9uYW1lKGEpe1xuICByZXR1cm4gY2FtbF9leGVjdXRhYmxlX25hbWVcbn1cblxuLy9Qcm92aWRlczogdW5peF9pbmV0X2FkZHJfb2Zfc3RyaW5nXG5mdW5jdGlvbiB1bml4X2luZXRfYWRkcl9vZl9zdHJpbmcgKCkge3JldHVybiAwO31cblxuLy9Qcm92aWRlczogY2FtbF9vb19sYXN0X2lkXG52YXIgY2FtbF9vb19sYXN0X2lkID0gMDtcblxuLy9Qcm92aWRlczogY2FtbF9zZXRfb29faWRcbi8vUmVxdWlyZXM6IGNhbWxfb29fbGFzdF9pZFxuZnVuY3Rpb24gY2FtbF9zZXRfb29faWQgKGIpIHtcbiAgYlsyXT1jYW1sX29vX2xhc3RfaWQrKztcbiAgcmV0dXJuIGI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZnJlc2hfb29faWRcbi8vUmVxdWlyZXM6IGNhbWxfb29fbGFzdF9pZFxuZnVuY3Rpb24gY2FtbF9mcmVzaF9vb19pZCgpIHtcbiAgcmV0dXJuIGNhbWxfb29fbGFzdF9pZCsrO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2luc3RhbGxfc2lnbmFsX2hhbmRsZXIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW5zdGFsbF9zaWduYWxfaGFuZGxlcigpe3JldHVybiAwfVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3Rcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3QoKXtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3RcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnN3YXAxNlxuZnVuY3Rpb24gY2FtbF9ic3dhcDE2KHgpIHtcbiAgcmV0dXJuICgoKCh4ICYgMHgwMEZGKSA8PCA4KSB8XG4gICAgICAgICAgICgoeCAmIDB4RkYwMCkgPj4gOCkpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50MzJfYnN3YXBcbmZ1bmN0aW9uIGNhbWxfaW50MzJfYnN3YXAoeCkge1xuICByZXR1cm4gKCgoeCAmIDB4MDAwMDAwRkYpIDw8IDI0KSB8XG4gICAgICAgICAgKCh4ICYgMHgwMDAwRkYwMCkgPDwgOCkgfFxuICAgICAgICAgICgoeCAmIDB4MDBGRjAwMDApID4+PiA4KSB8XG4gICAgICAgICAgKCh4ICYgMHhGRjAwMDAwMCkgPj4+IDI0KSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2Jzd2FwXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzLCBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ludDY0X2Jzd2FwKHgpIHtcbiAgdmFyIHkgPSBjYW1sX2ludDY0X3RvX2J5dGVzKHgpO1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhbeVs3XSwgeVs2XSwgeVs1XSwgeVs0XSwgeVszXSwgeVsyXSwgeVsxXSwgeVswXV0pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xpc3Rfb2ZfanNfYXJyYXkgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9saXN0X29mX2pzX2FycmF5KGEpe1xuICB2YXIgbCA9IDA7XG4gIGZvcih2YXIgaT1hLmxlbmd0aCAtIDE7IGk+PTA7IGktLSl7XG4gICAgdmFyIGUgPSBhW2ldO1xuICAgIGwgPSBbMCxlLGxdO1xuICB9XG4gIHJldHVybiBsXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGlzdF90b19qc19hcnJheSBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2xpc3RfdG9fanNfYXJyYXkobCl7XG4gIHZhciBhID0gW107XG4gIGZvcig7IGwgIT09IDA7IGwgPSBsWzJdKSB7XG4gICAgYS5wdXNoKGxbMV0pO1xuICB9XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfd2FybmluZ3NcbnZhciBjYW1sX3J1bnRpbWVfd2FybmluZ3MgPSAwO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2VuYWJsZV9ydW50aW1lX3dhcm5pbmdzXG4vL1JlcXVpcmVzOiBjYW1sX3J1bnRpbWVfd2FybmluZ3NcbmZ1bmN0aW9uIGNhbWxfbWxfZW5hYmxlX3J1bnRpbWVfd2FybmluZ3MgKGJvb2wpIHtcbiAgY2FtbF9ydW50aW1lX3dhcm5pbmdzID0gYm9vbDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcnVudGltZV93YXJuaW5nc19lbmFibGVkXG4vL1JlcXVpcmVzOiBjYW1sX3J1bnRpbWVfd2FybmluZ3NcbmZ1bmN0aW9uIGNhbWxfbWxfcnVudGltZV93YXJuaW5nc19lbmFibGVkIChfdW5pdCkge1xuICByZXR1cm4gY2FtbF9ydW50aW1lX3dhcm5pbmdzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfdmFyaWFudFxuLy9SZXF1aXJlczogY2FtbF9uZXdfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3J1bnRpbWVfdmFyaWFudChfdW5pdCkge1xuICByZXR1cm4gY2FtbF9uZXdfc3RyaW5nKFwiXCIpO1xufVxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX3BhcmFtZXRlcnNcbi8vUmVxdWlyZXM6IGNhbWxfbmV3X3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ydW50aW1lX3BhcmFtZXRlcnMoX3VuaXQpIHtcbiAgcmV0dXJuIGNhbWxfbmV3X3N0cmluZyhcIlwiKTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19pc2F0dHlcbmZ1bmN0aW9uIGNhbWxfc3lzX2lzYXR0eShfY2hhbikge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zcGFjZXRpbWVfZW5hYmxlZCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3NwYWNldGltZV9lbmFibGVkKF91bml0KSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZSBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZShfY2hhbm5lbCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlKCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiU3BhY2V0aW1lIHByb2ZpbGluZyBvbmx5IHdvcmtzIGZvciBuYXRpdmUgY29kZVwiKTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX2pzXG5mdW5jdGlvbiBjYW1sX2lzX2pzKCkge1xuICByZXR1cm4gMTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBqc29vX2Zsb29yX2xvZzJcbnZhciBsb2cyX29rID0gTWF0aC5sb2cyICYmIE1hdGgubG9nMigxLjEyMzU1ODIwOTI4ODk0NzRFKzMwNykgPT0gMTAyMFxuZnVuY3Rpb24ganNvb19mbG9vcl9sb2cyKHgpIHtcbiAgaWYobG9nMl9vaykgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5sb2cyKHgpKVxuICB2YXIgaSA9IDA7XG4gIGlmICh4ID09IDApIHJldHVybiAtSW5maW5pdHk7XG4gIGlmKHg+PTEpIHt3aGlsZSAoeD49Mikge3gvPTI7IGkrK30gfVxuICBlbHNlIHt3aGlsZSAoeCA8IDEpIHt4Kj0yOyBpLS19IH07XG4gIHJldHVybiBpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29fZmxvb3JfbG9nMiwgY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGlcbmZ1bmN0aW9uIGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCAoeCkge1xuICBpZiAoIWlzRmluaXRlKHgpKSB7XG4gICAgaWYgKGlzTmFOKHgpKVxuICAgICAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKDEsIDAsIDB4N2ZmMCk7XG4gICAgaWYgKHggPiAwKVxuICAgICAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKDAsIDAsIDB4N2ZmMClcbiAgICBlbHNlXG4gICAgICByZXR1cm4gY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkoMCwgMCwgMHhmZmYwKVxuICB9XG4gIHZhciBzaWduID0gKHg9PTAgJiYgMS94ID09IC1JbmZpbml0eSk/MHg4MDAwOih4Pj0wKT8wOjB4ODAwMDtcbiAgaWYgKHNpZ24pIHggPSAteDtcbiAgLy8gSW50NjQuYml0c19vZl9mbG9hdCAxLjEyMzU1ODIwOTI4ODk0NzRFKzMwNyA9IDB4N2ZiMDAwMDAwMDAwMDAwMExcbiAgLy8gdXNpbmcgTWF0aC5MT0cyRSpNYXRoLmxvZyh4KSBpbiBwbGFjZSBvZiBNYXRoLmxvZzIgcmVzdWx0IGluIHByZWNpc2lvbiBsb3N0XG4gIHZhciBleHAgPSBqc29vX2Zsb29yX2xvZzIoeCkgKyAxMDIzO1xuICBpZiAoZXhwIDw9IDApIHtcbiAgICBleHAgPSAwO1xuICAgIHggLz0gTWF0aC5wb3coMiwtMTAyNik7XG4gIH0gZWxzZSB7XG4gICAgeCAvPSBNYXRoLnBvdygyLGV4cC0xMDI3KTtcbiAgICBpZiAoeCA8IDE2KSB7XG4gICAgICB4ICo9IDI7IGV4cCAtPTE7IH1cbiAgICBpZiAoZXhwID09IDApIHtcbiAgICAgIHggLz0gMjsgfVxuICB9XG4gIHZhciBrID0gTWF0aC5wb3coMiwyNCk7XG4gIHZhciByMyA9IHh8MDtcbiAgeCA9ICh4IC0gcjMpICogaztcbiAgdmFyIHIyID0geHwwO1xuICB4ID0gKHggLSByMikgKiBrO1xuICB2YXIgcjEgPSB4fDA7XG4gIHIzID0gKHIzICYweGYpIHwgc2lnbiB8IGV4cCA8PCA0O1xuICByZXR1cm4gY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkocjEsIHIyLCByMyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50MzJfYml0c19vZl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczoganNvb19mbG9vcl9sb2cyXG5mdW5jdGlvbiBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQgKHgpIHtcbiAgdmFyIGZsb2F0MzJhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LkZsb2F0MzJBcnJheSgxKTtcbiAgZmxvYXQzMmFbMF0gPSB4O1xuICB2YXIgaW50MzJhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LkludDMyQXJyYXkoZmxvYXQzMmEuYnVmZmVyKTtcbiAgcmV0dXJuIGludDMyYVswXSB8IDA7XG59XG5cbi8vRlAgbGl0ZXJhbHMgY2FuIGJlIHdyaXR0ZW4gdXNpbmcgdGhlIGhleGFkZWNpbWFsXG4vL25vdGF0aW9uIDB4PG1hbnRpc3NhIGluIGhleD5wPGV4cG9uZW50PiBmcm9tIElTTyBDOTkuXG4vL2h0dHBzOi8vZ2l0aHViLmNvbS9kYW5rb2dhaS9qcy1oZXhmbG9hdC9ibG9iL21hc3Rlci9oZXhmbG9hdC5qc1xuLy9Qcm92aWRlczogY2FtbF9oZXhzdHJpbmdfb2ZfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfanNfdG9fc3RyaW5nLCBjYW1sX3N0cl9yZXBlYXRcbmZ1bmN0aW9uIGNhbWxfaGV4c3RyaW5nX29mX2Zsb2F0ICh4LCBwcmVjLCBzdHlsZSkge1xuICBpZiAoIWlzRmluaXRlKHgpKSB7XG4gICAgaWYgKGlzTmFOKHgpKSByZXR1cm4gY2FtbF9qc190b19zdHJpbmcoXCJuYW5cIik7XG4gICAgcmV0dXJuIGNhbWxfanNfdG9fc3RyaW5nICgoeCA+IDApP1wiaW5maW5pdHlcIjpcIi1pbmZpbml0eVwiKTtcbiAgfVxuICB2YXIgc2lnbiA9ICh4PT0wICYmIDEveCA9PSAtSW5maW5pdHkpPzE6KHg+PTApPzA6MTtcbiAgaWYoc2lnbikgeCA9IC14O1xuICB2YXIgZXhwID0gMDtcbiAgaWYgKHggPT0gMCkgeyB9XG4gIGVsc2UgaWYgKHggPCAxKSB7XG4gICAgd2hpbGUgKHggPCAxICYmIGV4cCA+IC0xMDIyKSAgeyB4ICo9IDI7IGV4cC0tIH1cbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoeCA+PSAyKSB7IHggLz0gMjsgZXhwKysgfVxuICB9XG4gIHZhciBleHBfc2lnbiA9IGV4cCA8IDAgPyAnJyA6ICcrJztcbiAgdmFyIHNpZ25fc3RyID0gJyc7XG4gIGlmIChzaWduKSBzaWduX3N0ciA9ICctJ1xuICBlbHNlIHtcbiAgICBzd2l0Y2goc3R5bGUpe1xuICAgIGNhc2UgNDMgLyogJysnICovOiBzaWduX3N0ciA9ICcrJzsgYnJlYWs7XG4gICAgY2FzZSAzMiAvKiAnICcgKi86IHNpZ25fc3RyID0gJyAnOyBicmVhaztcbiAgICBkZWZhdWx0OiBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKHByZWMgPj0gMCAmJiBwcmVjIDwgMTMpIHtcbiAgICAvKiBJZiBhIHByZWNpc2lvbiBpcyBnaXZlbiwgYW5kIGlzIHNtYWxsLCByb3VuZCBtYW50aXNzYSBhY2NvcmRpbmdseSAqL1xuICAgIHZhciBjc3QgPSBNYXRoLnBvdygyLHByZWMgKiA0KTtcbiAgICB4ID0gTWF0aC5yb3VuZCh4ICogY3N0KSAvIGNzdDtcbiAgfVxuICB2YXIgeF9zdHIgPSB4LnRvU3RyaW5nKDE2KTtcbiAgaWYocHJlYyA+PSAwKXtcbiAgICB2YXIgaWR4ID0geF9zdHIuaW5kZXhPZignLicpO1xuICAgIGlmKGlkeDwwKSB7XG4gICAgICB4X3N0ciArPSAnLicgKyBjYW1sX3N0cl9yZXBlYXQocHJlYywgJzAnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgc2l6ZSA9IGlkeCsxK3ByZWM7XG4gICAgICBpZih4X3N0ci5sZW5ndGggPCBzaXplKVxuICAgICAgICB4X3N0ciArPSBjYW1sX3N0cl9yZXBlYXQoc2l6ZSAtIHhfc3RyLmxlbmd0aCwgJzAnKTtcbiAgICAgIGVsc2VcbiAgICAgICAgeF9zdHIgPSB4X3N0ci5zdWJzdHIoMCxzaXplKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhbWxfanNfdG9fc3RyaW5nIChzaWduX3N0ciArICcweCcgKyB4X3N0ciArICdwJyArIGV4cF9zaWduICsgZXhwLnRvU3RyaW5nKDEwKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzICh4KSB7XG4gIHZhciBsbyA9IHhbMV07XG4gIHZhciBtaSA9IHhbMl07XG4gIHZhciBoaSA9IHhbM107XG4gIHZhciBleHAgPSAoaGkgJiAweDdmZmYpID4+IDQ7XG4gIGlmIChleHAgPT0gMjA0Nykge1xuICAgIGlmICgobG98bWl8KGhpJjB4ZikpID09IDApXG4gICAgICByZXR1cm4gKGhpICYgMHg4MDAwKT8oLUluZmluaXR5KTpJbmZpbml0eTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gTmFOO1xuICB9XG4gIHZhciBrID0gTWF0aC5wb3coMiwtMjQpO1xuICB2YXIgcmVzID0gKGxvKmsrbWkpKmsrKGhpJjB4Zik7XG4gIGlmIChleHAgPiAwKSB7XG4gICAgcmVzICs9IDE2O1xuICAgIHJlcyAqPSBNYXRoLnBvdygyLGV4cC0xMDI3KTtcbiAgfSBlbHNlXG4gICAgcmVzICo9IE1hdGgucG93KDIsLTEwMjYpO1xuICBpZiAoaGkgJiAweDgwMDApIHJlcyA9IC0gcmVzO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25leHRhZnRlcl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzLCBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQsIGNhbWxfaW50NjRfYWRkLCBjYW1sX2ludDY0X3N1YixjYW1sX2ludDY0X29mX2ludDMyXG5mdW5jdGlvbiBjYW1sX25leHRhZnRlcl9mbG9hdCAoeCx5KSB7XG4gIGlmKGlzTmFOKHgpIHx8IGlzTmFOKHkpKSByZXR1cm4gTmFOO1xuICBpZih4PT15KSByZXR1cm4geTtcbiAgaWYoeD09MCl7XG4gICAgaWYoeSA8IDApXG4gICAgICByZXR1cm4gLU1hdGgucG93KDIsIC0xMDc0KVxuICAgIGVsc2VcbiAgICAgIHJldHVybiBNYXRoLnBvdygyLCAtMTA3NClcbiAgfVxuICB2YXIgYml0cyA9IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCh4KTtcbiAgdmFyIG9uZSA9IGNhbWxfaW50NjRfb2ZfaW50MzIoMSk7XG4gIGlmICgoeDx5KSA9PSAoeD4wKSlcbiAgICBiaXRzID0gY2FtbF9pbnQ2NF9hZGQoYml0cywgb25lKVxuICBlbHNlXG4gICAgYml0cyA9IGNhbWxfaW50NjRfc3ViKGJpdHMsIG9uZSlcbiAgcmV0dXJuIGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyhiaXRzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF90cnVuY19mbG9hdFxuZnVuY3Rpb24gY2FtbF90cnVuY19mbG9hdCh4KXtcbiAgcmV0dXJuIE1hdGgudHJ1bmMoeCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzICh4KSB7XG4gIHZhciBpbnQzMmEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuSW50MzJBcnJheSgxKTtcbiAgaW50MzJhWzBdID0geDtcbiAgdmFyIGZsb2F0MzJhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LkZsb2F0MzJBcnJheShpbnQzMmEuYnVmZmVyKTtcbiAgcmV0dXJuIGZsb2F0MzJhWzBdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NsYXNzaWZ5X2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2NsYXNzaWZ5X2Zsb2F0ICh4KSB7XG4gIGlmIChpc0Zpbml0ZSAoeCkpIHtcbiAgICBpZiAoTWF0aC5hYnMoeCkgPj0gMi4yMjUwNzM4NTg1MDcyMDE0ZS0zMDgpIHJldHVybiAwO1xuICAgIGlmICh4ICE9IDApIHJldHVybiAxO1xuICAgIHJldHVybiAyO1xuICB9XG4gIHJldHVybiBpc05hTih4KT80OjM7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX21vZGZfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbW9kZl9mbG9hdCAoeCkge1xuICBpZiAoaXNGaW5pdGUgKHgpKSB7XG4gICAgdmFyIG5lZyA9ICgxL3gpIDwgMDtcbiAgICB4ID0gTWF0aC5hYnMoeCk7XG4gICAgdmFyIGkgPSBNYXRoLmZsb29yICh4KTtcbiAgICB2YXIgZiA9IHggLSBpO1xuICAgIGlmIChuZWcpIHsgaSA9IC1pOyBmID0gLWY7IH1cbiAgICByZXR1cm4gWzAsIGYsIGldO1xuICB9XG4gIGlmIChpc05hTiAoeCkpIHJldHVybiBbMCwgTmFOLCBOYU5dO1xuICByZXR1cm4gWzAsIDEveCwgeF07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2xkZXhwX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2xkZXhwX2Zsb2F0ICh4LGV4cCkge1xuICBleHAgfD0gMDtcbiAgaWYgKGV4cCA+IDEwMjMpIHtcbiAgICBleHAgLT0gMTAyMztcbiAgICB4ICo9IE1hdGgucG93KDIsIDEwMjMpO1xuICAgIGlmIChleHAgPiAxMDIzKSB7ICAvLyBpbiBjYXNlIHggaXMgc3Vibm9ybWFsXG4gICAgICBleHAgLT0gMTAyMztcbiAgICAgIHggKj0gTWF0aC5wb3coMiwgMTAyMyk7XG4gICAgfVxuICB9XG4gIGlmIChleHAgPCAtMTAyMykge1xuICAgIGV4cCArPSAxMDIzO1xuICAgIHggKj0gTWF0aC5wb3coMiwgLTEwMjMpO1xuICB9XG4gIHggKj0gTWF0aC5wb3coMiwgZXhwKTtcbiAgcmV0dXJuIHg7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ZyZXhwX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2Zsb29yX2xvZzJcbmZ1bmN0aW9uIGNhbWxfZnJleHBfZmxvYXQgKHgpIHtcbiAgaWYgKCh4ID09IDApIHx8ICFpc0Zpbml0ZSh4KSkgcmV0dXJuIFswLCB4LCAwXTtcbiAgdmFyIG5lZyA9IHggPCAwO1xuICBpZiAobmVnKSB4ID0gLSB4O1xuICB2YXIgZXhwID0gTWF0aC5tYXgoLTEwMjMsIGpzb29fZmxvb3JfbG9nMih4KSArIDEpO1xuICB4ICo9IE1hdGgucG93KDIsLWV4cCk7XG4gIHdoaWxlICh4IDwgMC41KSB7XG4gICAgeCAqPSAyO1xuICAgIGV4cC0tO1xuICB9XG4gIHdoaWxlICh4ID49IDEpIHtcbiAgICB4ICo9IDAuNTtcbiAgICBleHArKztcbiAgfVxuICBpZiAobmVnKSB4ID0gLSB4O1xuICByZXR1cm4gWzAsIHgsIGV4cF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRfY29tcGFyZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9mbG9hdF9jb21wYXJlICh4LCB5KSB7XG4gIGlmICh4ID09PSB5KSByZXR1cm4gMDtcbiAgaWYgKHggPCB5KSByZXR1cm4gLTE7XG4gIGlmICh4ID4geSkgcmV0dXJuIDE7XG4gIGlmICh4ID09PSB4KSByZXR1cm4gMTtcbiAgaWYgKHkgPT09IHkpIHJldHVybiAtMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29weXNpZ25fZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfY29weXNpZ25fZmxvYXQgKHgsIHkpIHtcbiAgaWYgKHkgPT0gMCkgeSA9IDEgLyB5O1xuICB4ID0gTWF0aC5hYnMoeCk7XG4gIHJldHVybiAoeSA8IDApPygteCk6eDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zaWduYml0X2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX3NpZ25iaXRfZmxvYXQoeCkge1xuICBpZiAoeCA9PSAwKSB4ID0gMSAvIHg7XG4gIHJldHVybiAoeCA8IDApPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9leHBtMV9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9leHBtMV9mbG9hdCAoeCkge1xuICB2YXIgeSA9IE1hdGguZXhwKHgpLCB6ID0geSAtIDE7XG4gIHJldHVybiAoTWF0aC5hYnMoeCk+MT96Oih6PT0wP3g6eCp6L01hdGgubG9nKHkpKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbG9nMXBfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbG9nMXBfZmxvYXQgKHgpIHtcbiAgdmFyIHkgPSAxICsgeCwgeiA9IHkgLSAxO1xuICByZXR1cm4gKHo9PTA/eDp4Kk1hdGgubG9nKHkpL3opO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2h5cG90X2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2h5cG90X2Zsb2F0ICh4LCB5KSB7XG4gIHZhciB4ID0gTWF0aC5hYnMoeCksIHkgPSBNYXRoLmFicyh5KTtcbiAgdmFyIGEgPSBNYXRoLm1heCh4LCB5KSwgYiA9IE1hdGgubWluKHgseSkgLyAoYT9hOjEpO1xuICByZXR1cm4gKGEgKiBNYXRoLnNxcnQoMSArIGIqYikpO1xufVxuXG4vLyBGSVg6IHRoZXNlIGZpdmUgZnVuY3Rpb25zIG9ubHkgZ2l2ZSBhcHByb3hpbWF0ZSByZXN1bHRzLlxuLy9Qcm92aWRlczogY2FtbF9sb2cxMF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9sb2cxMF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5MT0cxMEUgKiBNYXRoLmxvZyh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9jb3NoX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2Nvc2hfZmxvYXQgKHgpIHsgcmV0dXJuIChNYXRoLmV4cCh4KSArIE1hdGguZXhwKC14KSkgLyAyOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3NpbmhfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc2luaF9mbG9hdCAoeCkgeyByZXR1cm4gKE1hdGguZXhwKHgpIC0gTWF0aC5leHAoLXgpKSAvIDI7IH1cbi8vUHJvdmlkZXM6IGNhbWxfdGFuaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF90YW5oX2Zsb2F0ICh4KSB7XG4gIHZhciB5ID0gTWF0aC5leHAoeCksIHogPSBNYXRoLmV4cCgteCk7XG4gIHJldHVybiAoeSAtIHopIC8gKHkgKyB6KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yb3VuZF9mbG9hdFxuZnVuY3Rpb24gY2FtbF9yb3VuZF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KTsgfVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBEdW1teSBmaWxlc3lzdGVtXG5cbi8vUHJvdmlkZXM6IGNhbWxfY3VycmVudF9kaXJcbmlmKGpvb19nbG9iYWxfb2JqZWN0LnByb2Nlc3MgJiYgam9vX2dsb2JhbF9vYmplY3QucHJvY2Vzcy5jd2QpXG4gIHZhciBjYW1sX2N1cnJlbnRfZGlyID0gam9vX2dsb2JhbF9vYmplY3QucHJvY2Vzcy5jd2QoKS5yZXBsYWNlKC9cXFxcL2csJy8nKTtcbmVsc2VcbiAgdmFyIGNhbWxfY3VycmVudF9kaXIgPSAgXCIvc3RhdGljXCI7XG5pZihjYW1sX2N1cnJlbnRfZGlyLnNsaWNlKC0xKSAhPT0gXCIvXCIpIGNhbWxfY3VycmVudF9kaXIgKz0gXCIvXCJcblxuLy9Qcm92aWRlczogY2FtbF9yb290XG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfZGlyXG52YXIgY2FtbF9yb290ID0gY2FtbF9jdXJyZW50X2Rpci5tYXRjaCgvW15cXC9dKlxcLy8pWzBdO1xuXG5cbi8vUHJvdmlkZXM6IE1sRmlsZVxuZnVuY3Rpb24gTWxGaWxlKCl7ICB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFrZV9wYXRoXG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfZGlyLE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbWFrZV9wYXRoIChuYW1lKSB7XG4gIG5hbWU9KG5hbWUgaW5zdGFuY2VvZiBNbEJ5dGVzKT9uYW1lLnRvU3RyaW5nKCk6bmFtZTtcbiAgaWYobmFtZS5jaGFyQ29kZUF0KDApICE9IDQ3KVxuICAgIG5hbWUgPSBjYW1sX2N1cnJlbnRfZGlyICsgbmFtZTtcbiAgdmFyIGNvbXAgPSBuYW1lLnNwbGl0KFwiL1wiKTtcbiAgdmFyIG5jb21wID0gW11cbiAgZm9yKHZhciBpID0gMDsgaTxjb21wLmxlbmd0aDsgaSsrKXtcbiAgICBzd2l0Y2goY29tcFtpXSl7XG4gICAgY2FzZSBcIi4uXCI6IGlmKG5jb21wLmxlbmd0aD4xKSBuY29tcC5wb3AoKTsgYnJlYWs7XG4gICAgY2FzZSBcIi5cIjogYnJlYWs7XG4gICAgY2FzZSBcIlwiOiBpZihuY29tcC5sZW5ndGggPT0gMCkgbmNvbXAucHVzaChcIlwiKTsgYnJlYWs7XG4gICAgZGVmYXVsdDogbmNvbXAucHVzaChjb21wW2ldKTticmVha1xuICAgIH1cbiAgfVxuICBuY29tcC5vcmlnID0gbmFtZTtcbiAgcmV0dXJuIG5jb21wO1xufVxuXG4vL1Byb3ZpZGVzOmpzb29fbW91bnRfcG9pbnRcbi8vUmVxdWlyZXM6IE1sRmFrZURldmljZSwgTWxOb2RlRGV2aWNlLCBjYW1sX3Jvb3QsIGZzX25vZGVfc3VwcG9ydGVkXG52YXIganNvb19tb3VudF9wb2ludCA9IFtdXG5pZiAoZnNfbm9kZV9zdXBwb3J0ZWQoKSkge1xuICBqc29vX21vdW50X3BvaW50LnB1c2goe3BhdGg6Y2FtbF9yb290LGRldmljZTpuZXcgTWxOb2RlRGV2aWNlKGNhbWxfcm9vdCl9KTtcbn0gZWxzZSB7XG4gIGpzb29fbW91bnRfcG9pbnQucHVzaCh7cGF0aDpjYW1sX3Jvb3QsZGV2aWNlOm5ldyBNbEZha2VEZXZpY2UoY2FtbF9yb290KX0pO1xufVxuanNvb19tb3VudF9wb2ludC5wdXNoKHtwYXRoOmNhbWxfcm9vdCtcInN0YXRpYy9cIiwgZGV2aWNlOm5ldyBNbEZha2VEZXZpY2UoY2FtbF9yb290K1wic3RhdGljL1wiKX0pO1xuXG4vL1Byb3ZpZGVzOmNhbWxfbGlzdF9tb3VudF9wb2ludFxuLy9SZXF1aXJlczoganNvb19tb3VudF9wb2ludCwgY2FtbF9uZXdfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2xpc3RfbW91bnRfcG9pbnQoKXtcbiAgdmFyIHByZXYgPSAwXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBqc29vX21vdW50X3BvaW50Lmxlbmd0aDsgaSsrKXtcbiAgICB2YXIgb2xkID0gcHJldjtcbiAgICBwcmV2ID0gWzAsIGNhbWxfbmV3X3N0cmluZyhqc29vX21vdW50X3BvaW50W2ldLnBhdGgpLCBvbGRdXG4gIH1cbiAgcmV0dXJuIHByZXY7XG59XG5cbi8vUHJvdmlkZXM6IHJlc29sdmVfZnNfZGV2aWNlXG4vL1JlcXVpcmVzOiBjYW1sX21ha2VfcGF0aCwganNvb19tb3VudF9wb2ludFxuZnVuY3Rpb24gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSl7XG4gIHZhciBwYXRoID0gY2FtbF9tYWtlX3BhdGgobmFtZSk7XG4gIHZhciBuYW1lID0gcGF0aC5qb2luKFwiL1wiKTtcbiAgdmFyIG5hbWVfc2xhc2ggPSBuYW1lICsgXCIvXCI7XG4gIHZhciByZXM7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBqc29vX21vdW50X3BvaW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG0gPSBqc29vX21vdW50X3BvaW50W2ldO1xuICAgIGlmKG5hbWVfc2xhc2guc2VhcmNoKG0ucGF0aCkgPT0gMFxuICAgICAgICYmICghcmVzIHx8IHJlcy5wYXRoLmxlbmd0aCA8IG0ucGF0aC5sZW5ndGgpKVxuICAgICAgcmVzID0ge3BhdGg6bS5wYXRoLGRldmljZTptLmRldmljZSxyZXN0Om5hbWUuc3Vic3RyaW5nKG0ucGF0aC5sZW5ndGgsbmFtZS5sZW5ndGgpfTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21vdW50X2F1dG9sb2FkXG4vL1JlcXVpcmVzOiBNbEZha2VEZXZpY2UsIGNhbWxfbWFrZV9wYXRoLCBqc29vX21vdW50X3BvaW50XG5mdW5jdGlvbiBjYW1sX21vdW50X2F1dG9sb2FkKG5hbWUsZil7XG4gIHZhciBwYXRoID0gY2FtbF9tYWtlX3BhdGgobmFtZSk7XG4gIHZhciBuYW1lID0gcGF0aC5qb2luKFwiL1wiKSArIFwiL1wiO1xuICBqc29vX21vdW50X3BvaW50LnB1c2goe3BhdGg6bmFtZSxkZXZpY2U6bmV3IE1sRmFrZURldmljZShuYW1lLGYpfSlcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5tb3VudFxuLy9SZXF1aXJlczoganNvb19tb3VudF9wb2ludCwgY2FtbF9tYWtlX3BhdGhcbmZ1bmN0aW9uIGNhbWxfdW5tb3VudChuYW1lKXtcbiAgdmFyIHBhdGggPSBjYW1sX21ha2VfcGF0aChuYW1lKTtcbiAgdmFyIG5hbWUgPSBwYXRoLmpvaW4oXCIvXCIpICsgXCIvXCI7XG4gIHZhciBpZHggPSAtMTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGpzb29fbW91bnRfcG9pbnQubGVuZ3RoOyBpKyspXG4gICAgaWYoanNvb19tb3VudF9wb2ludFtpXS5wYXRoID09IG5hbWUpIGlkeCA9IGk7XG4gIGlmKGlkeCA+IC0xKSBqc29vX21vdW50X3BvaW50LnNwbGljZShpZHgsMSk7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2dldGN3ZFxuLy9SZXF1aXJlczogY2FtbF9jdXJyZW50X2RpciwgY2FtbF9uZXdfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N5c19nZXRjd2QoKSB7XG4gIHJldHVybiBjYW1sX25ld19zdHJpbmcoY2FtbF9jdXJyZW50X2Rpcik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NoZGlyXG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfZGlyLCBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSwgcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX2NoZGlyKGRpcikge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKGRpcik7XG4gIGlmKHJvb3QuZGV2aWNlLmV4aXN0cyhyb290LnJlc3QpKSB7XG4gICAgaWYocm9vdC5yZXN0KSBjYW1sX2N1cnJlbnRfZGlyID0gcm9vdC5wYXRoICsgcm9vdC5yZXN0ICsgXCIvXCI7XG4gICAgZWxzZSBjYW1sX2N1cnJlbnRfZGlyID0gcm9vdC5wYXRoO1xuICAgIHJldHVybiAwO1xuICB9XG4gIGVsc2Uge1xuICAgIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlKGRpcik7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGVcbi8vUmVxdWlyZXM6IE1sQnl0ZXMsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG5mdW5jdGlvbiBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShuYW1lKXtcbiAgbmFtZSA9IChuYW1lIGluc3RhbmNlb2YgTWxCeXRlcyk/bmFtZS50b1N0cmluZygpOm5hbWU7XG4gIGNhbWxfcmFpc2Vfc3lzX2Vycm9yIChuYW1lICsgXCI6IE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnlcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfbm90X2FfZGlyXG4vL1JlcXVpcmVzOiBNbEJ5dGVzLCBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gY2FtbF9yYWlzZV9ub3RfYV9kaXIobmFtZSl7XG4gIG5hbWUgPSAobmFtZSBpbnN0YW5jZW9mIE1sQnl0ZXMpP25hbWUudG9TdHJpbmcoKTpuYW1lO1xuICBjYW1sX3JhaXNlX3N5c19lcnJvciAobmFtZSArIFwiOiBOb3QgYSBkaXJlY3RvcnlcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2ZpbGVfZXhpc3RzXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfZmlsZV9leGlzdHMgKG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgcmV0dXJuIHJvb3QuZGV2aWNlLmV4aXN0cyhyb290LnJlc3QpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yZWFkX2RpcmVjdG9yeVxuLy9SZXF1aXJlczogY2FtbF9uZXdfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX25vdF9hX2RpciwgcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX3JlYWRfZGlyZWN0b3J5KG5hbWUpe1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICB2YXIgYSA9IHJvb3QuZGV2aWNlLnJlYWRkaXIocm9vdC5yZXN0KTtcbiAgdmFyIGwgPSBuZXcgQXJyYXkoYS5sZW5ndGggKyAxKTtcbiAgbFswXSA9IDA7XG4gIGZvcih2YXIgaT0wO2k8YS5sZW5ndGg7aSsrKVxuICAgIGxbaSsxXSA9IGNhbWxfbmV3X3N0cmluZyhhW2ldKTtcbiAgcmV0dXJuIGw7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JlbW92ZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUsIHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19yZW1vdmUobmFtZSl7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBvayA9IHJvb3QuZGV2aWNlLnVubGluayhyb290LnJlc3QpO1xuICBpZihvayA9PSAwKSBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShuYW1lKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2lzX2RpcmVjdG9yeVxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX2lzX2RpcmVjdG9yeShuYW1lKXtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgdmFyIGEgPSByb290LmRldmljZS5pc19kaXIocm9vdC5yZXN0KTtcbiAgcmV0dXJuIGE/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yZW5hbWVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19yZW5hbWUobyxuKXtcbiAgdmFyIG9fcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG8pO1xuICB2YXIgbl9yb290ID0gcmVzb2x2ZV9mc19kZXZpY2Uobik7XG4gIGlmKG9fcm9vdC5kZXZpY2UgIT0gbl9yb290LmRldmljZSlcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zeXNfcmVuYW1lOiBjYW5ub3QgbW92ZSBmaWxlIGJldHdlZW4gdHdvIGZpbGVzeXN0ZW1cIik7XG4gIGlmKCFvX3Jvb3QuZGV2aWNlLnJlbmFtZSlcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zeXNfcmVuYW1lOiBubyBpbXBsZW1lbnRlZFwiKTtcbiAgb19yb290LmRldmljZS5yZW5hbWUob19yb290LnJlc3QsIG5fcm9vdC5yZXN0KTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX21hcF9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2JhX21hcF9maWxlKHZmZCwga2luZCwgbGF5b3V0LCBzaGFyZWQsIGRpbXMsIHBvcykge1xuICAvLyB2YXIgZGF0YSA9IGNhbWxfZ2xvYmFsX2RhdGEuZmRzW3ZmZF07XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2JhX21hcF9maWxlIG5vdCBpbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9tYXBfZmlsZV9ieXRlY29kZVxuLy9SZXF1aXJlczogY2FtbF9iYV9tYXBfZmlsZVxuZnVuY3Rpb24gY2FtbF9iYV9tYXBfZmlsZV9ieXRlY29kZShhcmd2LGFyZ24pe1xuICByZXR1cm4gY2FtbF9iYV9tYXBfZmlsZShhcmd2WzBdLGFyZ3ZbMV0sYXJndlsyXSxhcmd2WzNdLGFyZ3ZbNF0sYXJndls1XSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX2ZpbGVfZXh0ZXJuXG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9maWxlX2V4dGVybihuYW1lLGNvbnRlbnQpe1xuICBpZihqb29fZ2xvYmFsX29iamVjdC5jYW1sX2NyZWF0ZV9maWxlKVxuICAgIGpvb19nbG9iYWxfb2JqZWN0LmNhbWxfY3JlYXRlX2ZpbGUobmFtZSxjb250ZW50KTtcbiAgZWxzZSB7XG4gICAgaWYoIWpvb19nbG9iYWxfb2JqZWN0LmNhbWxfZnNfdG1wKSBqb29fZ2xvYmFsX29iamVjdC5jYW1sX2ZzX3RtcCA9IFtdO1xuICAgIGpvb19nbG9iYWxfb2JqZWN0LmNhbWxfZnNfdG1wLnB1c2goe25hbWU6bmFtZSxjb250ZW50OmNvbnRlbnR9KTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mc19pbml0XG4vL1JlcXVpcmVzOiBjYW1sX2NyZWF0ZV9maWxlXG5mdW5jdGlvbiBjYW1sX2ZzX2luaXQgKCl7XG4gIHZhciB0bXA9am9vX2dsb2JhbF9vYmplY3QuY2FtbF9mc190bXBcbiAgaWYodG1wKXtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdG1wLmxlbmd0aDsgaSsrKXtcbiAgICAgIGNhbWxfY3JlYXRlX2ZpbGUodG1wW2ldLm5hbWUsdG1wW2ldLmNvbnRlbnQpO1xuICAgIH1cbiAgfVxuICBqb29fZ2xvYmFsX29iamVjdC5jYW1sX2NyZWF0ZV9maWxlID0gY2FtbF9jcmVhdGVfZmlsZTtcbiAgam9vX2dsb2JhbF9vYmplY3QuY2FtbF9mc190bXAgPSBbXTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9maWxlKG5hbWUsY29udGVudCkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZighIHJvb3QuZGV2aWNlLnJlZ2lzdGVyKSBjYW1sX2ZhaWx3aXRoKFwiY2Fubm90IHJlZ2lzdGVyIGZpbGVcIik7XG4gIHJvb3QuZGV2aWNlLnJlZ2lzdGVyKHJvb3QucmVzdCxjb250ZW50KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVhZF9maWxlX2NvbnRlbnRcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSwgY2FtbF9jcmVhdGVfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfcmVhZF9maWxlX2NvbnRlbnQgKG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYocm9vdC5kZXZpY2UuZXhpc3RzKHJvb3QucmVzdCkpIHtcbiAgICB2YXIgZmlsZSA9IHJvb3QuZGV2aWNlLm9wZW4ocm9vdC5yZXN0LHtyZG9ubHk6MX0pO1xuICAgIHZhciBsZW4gID0gZmlsZS5sZW5ndGgoKTtcbiAgICB2YXIgYnVmICA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbik7XG4gICAgZmlsZS5yZWFkKDAsYnVmLDAsbGVuKTtcbiAgICByZXR1cm4gYnVmXG4gIH1cbiAgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUobmFtZSk7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBNbEZha2VEZXZpY2Vcbi8vUmVxdWlyZXM6IE1sRmFrZUZpbGUsIGNhbWxfY3JlYXRlX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUsIGNhbWxfbmV3X3N0cmluZywgY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbmZ1bmN0aW9uIE1sRmFrZURldmljZSAocm9vdCwgZikge1xuICB0aGlzLmNvbnRlbnQ9e307XG4gIHRoaXMucm9vdCA9IHJvb3Q7XG4gIHRoaXMubG9va3VwRnVuID0gZjtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUubm0gPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiAodGhpcy5yb290ICsgbmFtZSk7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgaWYoIXRoaXMuY29udGVudFtuYW1lXSAmJiB0aGlzLmxvb2t1cEZ1bikge1xuICAgIHZhciByZXMgPSB0aGlzLmxvb2t1cEZ1bihjYW1sX25ld19zdHJpbmcodGhpcy5yb290KSwgY2FtbF9uZXdfc3RyaW5nKG5hbWUpKTtcbiAgICBpZihyZXMgIT09IDApIHRoaXMuY29udGVudFtuYW1lXT1uZXcgTWxGYWtlRmlsZShyZXNbMV0pO1xuICB9XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmV4aXN0cyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgLy8gVGhlIHJvb3Qgb2YgdGhlIGRldmljZSBleGlzdHNcbiAgaWYobmFtZSA9PSBcIlwiKSByZXR1cm4gMTtcbiAgLy8gQ2hlY2sgaWYgYSBkaXJlY3RvcnkgZXhpc3RzXG4gIHZhciBuYW1lX3NsYXNoID0gKG5hbWUgKyBcIi9cIik7XG4gIHZhciByID0gbmV3IFJlZ0V4cChcIl5cIiArIG5hbWVfc2xhc2gpO1xuICBmb3IodmFyIG4gaW4gdGhpcy5jb250ZW50KSB7XG4gICAgaWYgKG4ubWF0Y2gocikpIHJldHVybiAxXG4gIH1cbiAgLy8gQ2hlY2sgaWYgYSBmaWxlIGV4aXN0c1xuICB0aGlzLmxvb2t1cChuYW1lKTtcbiAgcmV0dXJuIHRoaXMuY29udGVudFtuYW1lXT8xOjA7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLnJlYWRkaXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBuYW1lX3NsYXNoID0gKG5hbWUgPT0gXCJcIik/XCJcIjoobmFtZSArIFwiL1wiKTtcbiAgdmFyIHIgPSBuZXcgUmVnRXhwKFwiXlwiICsgbmFtZV9zbGFzaCArIFwiKFteL10qKVwiKTtcbiAgdmFyIHNlZW4gPSB7fVxuICB2YXIgYSA9IFtdO1xuICBmb3IodmFyIG4gaW4gdGhpcy5jb250ZW50KSB7XG4gICAgdmFyIG0gPSBuLm1hdGNoKHIpO1xuICAgIGlmKG0gJiYgIXNlZW5bbVsxXV0pIHtzZWVuW21bMV1dID0gdHJ1ZTsgYS5wdXNoKG1bMV0pfVxuICB9XG4gIHJldHVybiBhO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5pc19kaXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBuYW1lX3NsYXNoID0gKG5hbWUgPT0gXCJcIik/XCJcIjoobmFtZSArIFwiL1wiKTtcbiAgdmFyIHIgPSBuZXcgUmVnRXhwKFwiXlwiICsgbmFtZV9zbGFzaCArIFwiKFteL10qKVwiKTtcbiAgdmFyIGEgPSBbXTtcbiAgZm9yKHZhciBuIGluIHRoaXMuY29udGVudCkge1xuICAgIHZhciBtID0gbi5tYXRjaChyKTtcbiAgICBpZihtKSByZXR1cm4gMVxuICB9XG4gIHJldHVybiAwXG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLnVubGluayA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIG9rID0gdGhpcy5jb250ZW50W25hbWVdP3RydWU6ZmFsc2U7XG4gIGRlbGV0ZSB0aGlzLmNvbnRlbnRbbmFtZV07XG4gIHJldHVybiBvaztcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uKG5hbWUsIGYpIHtcbiAgaWYoZi5yZG9ubHkgJiYgZi53cm9ubHkpXG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogZmxhZ3MgT3Blbl9yZG9ubHkgYW5kIE9wZW5fd3Jvbmx5IGFyZSBub3QgY29tcGF0aWJsZVwiKTtcbiAgaWYoZi50ZXh0ICYmIGYuYmluYXJ5KVxuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZsYWdzIE9wZW5fdGV4dCBhbmQgT3Blbl9iaW5hcnkgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xuICB0aGlzLmxvb2t1cChuYW1lKTtcbiAgaWYgKHRoaXMuY29udGVudFtuYW1lXSkge1xuICAgIGlmICh0aGlzLmlzX2RpcihuYW1lKSkgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogaXMgYSBkaXJlY3RvcnlcIik7XG4gICAgaWYgKGYuY3JlYXRlICYmIGYuZXhjbCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogZmlsZSBhbHJlYWR5IGV4aXN0c1wiKTtcbiAgICB2YXIgZmlsZSA9IHRoaXMuY29udGVudFtuYW1lXTtcbiAgICBpZihmLnRydW5jYXRlKSBmaWxlLnRydW5jYXRlKCk7XG4gICAgcmV0dXJuIGZpbGU7XG4gIH0gZWxzZSBpZiAoZi5jcmVhdGUpIHtcbiAgICB0aGlzLmNvbnRlbnRbbmFtZV0gPSBuZXcgTWxGYWtlRmlsZShjYW1sX2NyZWF0ZV9ieXRlcygwKSk7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudFtuYW1lXTtcbiAgfSBlbHNlIHtcbiAgICBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSAodGhpcy5ubShuYW1lKSk7XG4gIH1cbn1cblxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5yZWdpc3Rlcj0gZnVuY3Rpb24gKG5hbWUsY29udGVudCl7XG4gIGlmKHRoaXMuY29udGVudFtuYW1lXSkgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogZmlsZSBhbHJlYWR5IGV4aXN0c1wiKTtcbiAgaWYoY29udGVudCBpbnN0YW5jZW9mIE1sQnl0ZXMpXG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gbmV3IE1sRmFrZUZpbGUoY29udGVudCk7XG4gIGVsc2UgaWYoY29udGVudCBpbnN0YW5jZW9mIEFycmF5KVxuICAgIHRoaXMuY29udGVudFtuYW1lXSA9IG5ldyBNbEZha2VGaWxlKGNhbWxfc3RyaW5nX29mX2FycmF5KGNvbnRlbnQpKTtcbiAgZWxzZSBpZihjb250ZW50LnRvU3RyaW5nKSB7XG4gICAgdmFyIG1sc3RyaW5nID0gY2FtbF9uZXdfc3RyaW5nKGNvbnRlbnQudG9TdHJpbmcoKSk7XG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gbmV3IE1sRmFrZUZpbGUobWxzdHJpbmcpO1xuICB9XG59XG5cbk1sRmFrZURldmljZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNbEZha2VEZXZpY2VcblxuLy9Qcm92aWRlczogTWxGYWtlRmlsZVxuLy9SZXF1aXJlczogTWxGaWxlXG4vL1JlcXVpcmVzOiBjYW1sX2NyZWF0ZV9ieXRlcywgY2FtbF9tbF9ieXRlc19sZW5ndGgsY2FtbF9ibGl0X2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2dldFxuZnVuY3Rpb24gTWxGYWtlRmlsZShjb250ZW50KXtcbiAgdGhpcy5kYXRhID0gY29udGVudDtcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlID0gbmV3IE1sRmlsZSAoKTtcbk1sRmFrZUZpbGUucHJvdG90eXBlLnRydW5jYXRlID0gZnVuY3Rpb24obGVuKXtcbiAgdmFyIG9sZCA9IHRoaXMuZGF0YTtcbiAgdGhpcy5kYXRhID0gY2FtbF9jcmVhdGVfYnl0ZXMobGVufDApO1xuICBjYW1sX2JsaXRfYnl0ZXMob2xkLCAwLCB0aGlzLmRhdGEsIDAsIGxlbik7XG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBjYW1sX21sX2J5dGVzX2xlbmd0aCh0aGlzLmRhdGEpO1xufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihvZmZzZXQsYnVmLHBvcyxsZW4pe1xuICB2YXIgY2xlbiA9IHRoaXMubGVuZ3RoKCk7XG4gIGlmKG9mZnNldCArIGxlbiA+PSBjbGVuKSB7XG4gICAgdmFyIG5ld19zdHIgPSBjYW1sX2NyZWF0ZV9ieXRlcyhvZmZzZXQgKyBsZW4pO1xuICAgIHZhciBvbGRfZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB0aGlzLmRhdGEgPSBuZXdfc3RyO1xuICAgIGNhbWxfYmxpdF9ieXRlcyhvbGRfZGF0YSwgMCwgdGhpcy5kYXRhLCAwLCBjbGVuKTtcbiAgfVxuICBjYW1sX2JsaXRfYnl0ZXMoYnVmLCBwb3MsIHRoaXMuZGF0YSwgb2Zmc2V0LCBsZW4pO1xuICByZXR1cm4gMFxufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKG9mZnNldCxidWYscG9zLGxlbil7XG4gIHZhciBjbGVuID0gdGhpcy5sZW5ndGgoKTtcbiAgY2FtbF9ibGl0X2J5dGVzKHRoaXMuZGF0YSwgb2Zmc2V0LCBidWYsIHBvcywgbGVuKTtcbiAgcmV0dXJuIDBcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLnJlYWRfb25lID0gZnVuY3Rpb24ob2Zmc2V0KXtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfZ2V0KHRoaXMuZGF0YSwgb2Zmc2V0KTtcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKXtcblxufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNbEZha2VGaWxlXG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBmc19ub2RlX3N1cHBvcnRlZFxuZnVuY3Rpb24gZnNfbm9kZV9zdXBwb3J0ZWQgKCkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBqb29fZ2xvYmFsX29iamVjdC5wcm9jZXNzICE9PSAndW5kZWZpbmVkJ1xuICAgICAgJiYgdHlwZW9mIGpvb19nbG9iYWxfb2JqZWN0LnByb2Nlc3MudmVyc2lvbnMgIT09ICd1bmRlZmluZWQnXG4gICAgICAmJiB0eXBlb2Ygam9vX2dsb2JhbF9vYmplY3QucHJvY2Vzcy52ZXJzaW9ucy5ub2RlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgJiYgam9vX2dsb2JhbF9vYmplY3QucHJvY2Vzcy5wbGF0Zm9ybSAhPT0gXCJicm93c2VyXCIpXG59XG5cbi8vUHJvdmlkZXM6IE1sTm9kZURldmljZVxuLy9SZXF1aXJlczogTWxOb2RlRmlsZVxuZnVuY3Rpb24gTWxOb2RlRGV2aWNlKHJvb3QpIHtcbiAgdGhpcy5mcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gIHRoaXMucm9vdCA9IHJvb3Q7XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLm5tID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gKHRoaXMucm9vdCArIG5hbWUpO1xufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5leGlzdHMgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiB0aGlzLmZzLmV4aXN0c1N5bmModGhpcy5ubShuYW1lKSk/MTowO1xufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5yZWFkZGlyID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gdGhpcy5mcy5yZWFkZGlyU3luYyh0aGlzLm5tKG5hbWUpKTtcbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUuaXNfZGlyID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gdGhpcy5mcy5zdGF0U3luYyh0aGlzLm5tKG5hbWUpKS5pc0RpcmVjdG9yeSgpPzE6MDtcbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUudW5saW5rID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgYiA9IHRoaXMuZnMuZXhpc3RzU3luYyh0aGlzLm5tKG5hbWUpKT8xOjA7XG4gIHRoaXMuZnMudW5saW5rU3luYyh0aGlzLm5tKG5hbWUpKTtcbiAgcmV0dXJuIGJcbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uKG5hbWUsIGYpIHtcbiAgdmFyIGNvbnN0cyA9IHJlcXVpcmUoJ2NvbnN0YW50cycpO1xuICB2YXIgcmVzID0gMDtcbiAgZm9yKHZhciBrZXkgaW4gZil7XG4gICAgc3dpdGNoKGtleSl7XG4gICAgY2FzZSBcInJkb25seVwiICA6IHJlcyB8PSBjb25zdHMuT19SRE9OTFk7IGJyZWFrO1xuICAgIGNhc2UgXCJ3cm9ubHlcIiAgOiByZXMgfD0gY29uc3RzLk9fV1JPTkxZOyBicmVhaztcbiAgICBjYXNlIFwiYXBwZW5kXCIgIDpcbiAgICAgIHJlcyB8PSBjb25zdHMuT19XUk9OTFkgfCBjb25zdHMuT19BUFBFTkQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY3JlYXRlXCIgICA6IHJlcyB8PSBjb25zdHMuT19DUkVBVDsgICAgYnJlYWs7XG4gICAgY2FzZSBcInRydW5jYXRlXCIgOiByZXMgfD0gY29uc3RzLk9fVFJVTkM7ICAgIGJyZWFrO1xuICAgIGNhc2UgXCJleGNsXCIgICAgIDogcmVzIHw9IGNvbnN0cy5PX0VYQ0w7ICAgICBicmVhaztcbiAgICBjYXNlIFwiYmluYXJ5XCIgICA6IHJlcyB8PSBjb25zdHMuT19CSU5BUlk7ICAgYnJlYWs7XG4gICAgY2FzZSBcInRleHRcIiAgICAgOiByZXMgfD0gY29uc3RzLk9fVEVYVDsgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJub25ibG9ja1wiIDogcmVzIHw9IGNvbnN0cy5PX05PTkJMT0NLOyBicmVhaztcbiAgICB9XG4gIH1cbiAgdmFyIGZkID0gdGhpcy5mcy5vcGVuU3luYyh0aGlzLm5tKG5hbWUpLCByZXMpO1xuICByZXR1cm4gbmV3IE1sTm9kZUZpbGUoZmQpO1xufVxuXG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnJlbmFtZSA9IGZ1bmN0aW9uKG8sbikge1xuICB0aGlzLmZzLnJlbmFtZVN5bmModGhpcy5ubShvKSwgdGhpcy5ubShuKSk7XG59XG5cbk1sTm9kZURldmljZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNbE5vZGVEZXZpY2VcblxuLy9Qcm92aWRlczogTWxOb2RlRmlsZVxuLy9SZXF1aXJlczogTWxGaWxlLCBjYW1sX2FycmF5X29mX3N0cmluZywgY2FtbF9ieXRlc19zZXRcblxudmFyIEJ1ZmZlciA9IGpvb19nbG9iYWxfb2JqZWN0LkJ1ZmZlclxuXG5mdW5jdGlvbiBNbE5vZGVGaWxlKGZkKXtcbiAgdGhpcy5mcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gIHRoaXMuZmQgPSBmZDtcbn1cbk1sTm9kZUZpbGUucHJvdG90eXBlID0gbmV3IE1sRmlsZSAoKTtcblxuTWxOb2RlRmlsZS5wcm90b3R5cGUudHJ1bmNhdGUgPSBmdW5jdGlvbihsZW4pe1xuICB0aGlzLmZzLmZ0cnVuY2F0ZVN5bmModGhpcy5mZCxsZW58MClcbn1cbk1sTm9kZUZpbGUucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZnMuZnN0YXRTeW5jKHRoaXMuZmQpLnNpemU7XG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKG9mZnNldCxidWYsYnVmX29mZnNldCxsZW4pe1xuICB2YXIgYSA9IGNhbWxfYXJyYXlfb2Zfc3RyaW5nKGJ1Zik7XG4gIGlmKCEgKGEgaW5zdGFuY2VvZiBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KSlcbiAgICBhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkoYSk7XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuZnJvbShhKTtcbiAgdGhpcy5mcy53cml0ZVN5bmModGhpcy5mZCwgYnVmZmVyLCBidWZfb2Zmc2V0LCBsZW4sIG9mZnNldCk7XG4gIHJldHVybiAwO1xufVxuTWxOb2RlRmlsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKG9mZnNldCxidWYsYnVmX29mZnNldCxsZW4pe1xuICB2YXIgYSA9IGNhbWxfYXJyYXlfb2Zfc3RyaW5nKGJ1Zik7XG4gIGlmKCEgKGEgaW5zdGFuY2VvZiBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KSlcbiAgICBhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkoYSk7XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuZnJvbShhKTtcbiAgdGhpcy5mcy5yZWFkU3luYyh0aGlzLmZkLCBidWZmZXIsIGJ1Zl9vZmZzZXQsIGxlbiwgb2Zmc2V0KTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICBjYW1sX2J5dGVzX3NldChidWYsYnVmX29mZnNldCArIGksYnVmZmVyW2J1Zl9vZmZzZXQraV0pO1xuICB9XG4gIHJldHVybiAwXG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZS5yZWFkX29uZSA9IGZ1bmN0aW9uKG9mZnNldCl7XG4gIHZhciBhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkoMSk7XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuZnJvbShhKTtcbiAgdGhpcy5mcy5yZWFkU3luYyh0aGlzLmZkLCBidWZmZXIsIDAsIDEsIG9mZnNldCk7XG4gIHJldHVybiBidWZmZXJbMF07XG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuZnMuY2xvc2VTeW5jKHRoaXMuZmQpO1xufVxuXG5NbE5vZGVGaWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1sTm9kZUZpbGU7XG4iLCIvL1Byb3ZpZGVzOiBpbml0aWFsaXplX25hdFxuLy9SZXF1aXJlczogY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBzZXJpYWxpemVfbmF0LCBkZXNlcmlhbGl6ZV9uYXQsIGNhbWxfaGFzaF9uYXRcbmZ1bmN0aW9uIGluaXRpYWxpemVfbmF0KCkge1xuICBjYW1sX2N1c3RvbV9vcHNbXCJfbmF0XCJdID1cbiAgICB7IGRlc2VyaWFsaXplIDogZGVzZXJpYWxpemVfbmF0LFxuICAgICAgc2VyaWFsaXplIDogc2VyaWFsaXplX25hdCxcbiAgICAgIGhhc2ggOiBjYW1sX2hhc2hfbmF0XG4gICAgfVxufVxuXG4vL1Byb3ZpZGVzOiBNbE5hdFxuZnVuY3Rpb24gTWxOYXQoeCl7XG4gIHRoaXMuZGF0YSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5JbnQzMkFycmF5KHgpO1xuICAvLyBsZW5ndGhfbmF0IGlzbid0IGV4dGVybmFsLCBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhlIE9iai5zaXplXG4gIC8vIHdvcmsgb3V0IHJpZ2h0LiBUaGUgKzIgdG8gYXJyYXkgbGVuZ3RoIHNlZW1zIHRvIHdvcmsuXG4gIHRoaXMubGVuZ3RoID0gdGhpcy5kYXRhLmxlbmd0aCArIDJcbn1cblxuTWxOYXQucHJvdG90eXBlLmNhbWxfY3VzdG9tID0gXCJfbmF0XCI7XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9uYXRcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50LCBudW1fZGlnaXRzX25hdFxuZnVuY3Rpb24gY2FtbF9oYXNoX25hdCh4KSB7XG4gIHZhciBsZW4gPSBudW1fZGlnaXRzX25hdCh4LCAwLCB4LmRhdGEubGVuZ3RoKTtcbiAgdmFyIGggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHguZGF0YVtpXSk7XG4gIH1cbiAgcmV0dXJuIGg7XG59XG5cblxuLy9Qcm92aWRlczogbmF0X29mX2FycmF5XG4vL1JlcXVpcmVzOiBNbE5hdFxuZnVuY3Rpb24gbmF0X29mX2FycmF5KGwpe1xuICByZXR1cm4gbmV3IE1sTmF0KGwpO1xufVxuXG4vL1Byb3ZpZGVzOiBjcmVhdGVfbmF0XG4vL1JlcXVpcmVzOiBNbE5hdFxuZnVuY3Rpb24gY3JlYXRlX25hdChzaXplKSB7XG4gIHZhciBhcnIgPSBuZXcgTWxOYXQoc2l6ZSk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICBhcnIuZGF0YVtpXSA9IC0xO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbi8vUHJvdmlkZXM6IHNldF90b196ZXJvX25hdFxuZnVuY3Rpb24gc2V0X3RvX3plcm9fbmF0KG5hdCwgb2ZzLCBsZW4pIHtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbmF0LmRhdGFbb2ZzK2ldID0gMDtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogYmxpdF9uYXRcbmZ1bmN0aW9uIGJsaXRfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIsIGxlbikge1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IG5hdDIuZGF0YVtvZnMyK2ldO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBzZXRfZGlnaXRfbmF0XG5mdW5jdGlvbiBzZXRfZGlnaXRfbmF0KG5hdCwgb2ZzLCBkaWdpdCkge1xuICBuYXQuZGF0YVtvZnNdID0gZGlnaXQ7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBudGhfZGlnaXRfbmF0XG5mdW5jdGlvbiBudGhfZGlnaXRfbmF0KG5hdCwgb2ZzKSB7XG4gIHJldHVybiBuYXQuZGF0YVtvZnNdO1xufVxuXG4vL1Byb3ZpZGVzOiBzZXRfZGlnaXRfbmF0X25hdGl2ZVxuZnVuY3Rpb24gc2V0X2RpZ2l0X25hdF9uYXRpdmUobmF0LCBvZnMsIGRpZ2l0KSB7XG4gIG5hdC5kYXRhW29mc10gPSBkaWdpdDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG50aF9kaWdpdF9uYXRfbmF0aXZlXG5mdW5jdGlvbiBudGhfZGlnaXRfbmF0X25hdGl2ZShuYXQsIG9mcykge1xuICByZXR1cm4gbmF0LmRhdGFbb2ZzXTtcbn1cblxuLy9Qcm92aWRlczogbnVtX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIG51bV9kaWdpdHNfbmF0KG5hdCwgb2ZzLCBsZW4pIHtcbiAgZm9yKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZihuYXQuZGF0YVtvZnMraV0gIT0gMCkgcmV0dXJuIGkrMTtcbiAgfVxuICByZXR1cm4gMTsgLy8gMCBjb3VudHMgYXMgMSBkaWdpdFxufVxuXG4vL1Byb3ZpZGVzOiBudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXRcbmZ1bmN0aW9uIG51bV9sZWFkaW5nX3plcm9fYml0c19pbl9kaWdpdChuYXQsIG9mcykge1xuICB2YXIgYSA9IG5hdC5kYXRhW29mc107XG4gIHZhciBiID0gMDtcbiAgaWYoYSAmIDB4RkZGRjAwMDApIHsgYiArPTE2OyBhID4+Pj0xNjsgfVxuICBpZihhICYgMHhGRjAwKSAgICAgeyBiICs9IDg7IGEgPj4+PSA4OyB9XG4gIGlmKGEgJiAweEYwKSAgICAgICB7IGIgKz0gNDsgYSA+Pj49IDQ7IH1cbiAgaWYoYSAmIDEyKSAgICAgICAgIHsgYiArPSAyOyBhID4+Pj0gMjsgfVxuICBpZihhICYgMikgICAgICAgICAgeyBiICs9IDE7IGEgPj4+PSAxOyB9XG4gIGlmKGEgJiAxKSAgICAgICAgICB7IGIgKz0gMTsgfVxuICByZXR1cm4gMzIgLSBiO1xufVxuXG4vL1Byb3ZpZGVzOiBpc19kaWdpdF9pbnRcbmZ1bmN0aW9uIGlzX2RpZ2l0X2ludChuYXQsIG9mcykge1xuICBpZiAobmF0LmRhdGFbb2ZzXSA+PSAwKSByZXR1cm4gMVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogaXNfZGlnaXRfemVyb1xuZnVuY3Rpb24gaXNfZGlnaXRfemVybyhuYXQsIG9mcykge1xuICBpZihuYXQuZGF0YVtvZnNdID09IDApIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogaXNfZGlnaXRfb2RkXG5mdW5jdGlvbiBpc19kaWdpdF9vZGQobmF0LCBvZnMpIHtcbiAgaWYobmF0LmRhdGFbb2ZzXSAmIDEpIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogaW5jcl9uYXRcbmZ1bmN0aW9uIGluY3JfbmF0KG5hdCwgb2ZzLCBsZW4sIGNhcnJ5X2luKSB7XG4gIHZhciBjYXJyeSA9IGNhcnJ5X2luO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgeCA9IChuYXQuZGF0YVtvZnMraV0gPj4+IDApICsgY2Fycnk7XG4gICAgbmF0LmRhdGFbb2ZzK2ldID0gKHggfCAwKTtcbiAgICBpZih4ID09ICh4ID4+PiAwKSkge1xuICAgICAgY2FycnkgPSAwO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhcnJ5ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhcnJ5O1xufVxuXG4vLyBsZW4xID49IGxlbjJcbi8vUHJvdmlkZXM6IGFkZF9uYXRcbi8vUmVxdWlyZXM6IGluY3JfbmF0XG5mdW5jdGlvbiBhZGRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIGNhcnJ5X2luKSB7XG4gIHZhciBjYXJyeSA9IGNhcnJ5X2luO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0MS5kYXRhW29mczEraV0gPj4+IDApICsgKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSArIGNhcnJ5O1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0geFxuICAgIGlmKHggPT0gKHggPj4+IDApKSB7XG4gICAgICBjYXJyeSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhcnJ5ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluY3JfbmF0KG5hdDEsIG9mczErbGVuMiwgbGVuMS1sZW4yLCBjYXJyeSk7XG59XG5cbi8vUHJvdmlkZXM6IGNvbXBsZW1lbnRfbmF0XG5mdW5jdGlvbiBjb21wbGVtZW50X25hdChuYXQsIG9mcywgbGVuKSB7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG5hdC5kYXRhW29mcytpXSA9ICgtMSA+Pj4gMCkgLSAobmF0LmRhdGFbb2ZzK2ldID4+PiAwKTtcbiAgfVxufVxuXG4vLyBvY2FtbCBmbGlwcyBjYXJyeV9pblxuLy9Qcm92aWRlczogZGVjcl9uYXRcbmZ1bmN0aW9uIGRlY3JfbmF0KG5hdCwgb2ZzLCBsZW4sIGNhcnJ5X2luKSB7XG4gIHZhciBib3Jyb3cgPSAoY2FycnlfaW4gPT0gMSkgPyAwIDogMTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0LmRhdGFbb2ZzK2ldID4+PjApIC0gYm9ycm93O1xuICAgIG5hdC5kYXRhW29mcytpXSA9IHg7XG4gICAgaWYgKHggPj0gMCkge1xuICAgICAgYm9ycm93ID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3Jyb3cgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gKGJvcnJvdyA9PSAxKSA/IDAgOiAxO1xufVxuXG4vLyBvY2FtbCBmbGlwcyBjYXJyeV9pblxuLy8gbGVuMSA+PSBsZW4yXG4vL1Byb3ZpZGVzOiBzdWJfbmF0XG4vL1JlcXVpcmVzOiBkZWNyX25hdFxuZnVuY3Rpb24gc3ViX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBjYXJyeV9pbikge1xuICB2YXIgYm9ycm93ID0gKGNhcnJ5X2luID09IDEpID8gMCA6IDE7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW4yOyBpKyspIHtcbiAgICB2YXIgeCA9IChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgLSAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApIC0gYm9ycm93O1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0geDtcbiAgICBpZiAoeCA+PSAwKSB7XG4gICAgICBib3Jyb3cgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3Jyb3cgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVjcl9uYXQobmF0MSwgb2ZzMStsZW4yLCBsZW4xLWxlbjIsIChib3Jyb3c9PTEpPzA6MSk7XG59XG5cbi8vIG5hdDEgKz0gbmF0MiAqIG5hdDNbb2ZzM11cbi8vIGxlbjEgPj0gbGVuMlxuLy9Qcm92aWRlczogbXVsdF9kaWdpdF9uYXRcbi8vUmVxdWlyZXM6IGFkZF9uYXQsIG5hdF9vZl9hcnJheVxuZnVuY3Rpb24gbXVsdF9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0Mywgb2ZzMykge1xuICB2YXIgY2FycnkgPSAwO1xuICB2YXIgYSA9IChuYXQzLmRhdGFbb2ZzM10gPj4+IDApO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMjsgaSsrKSB7XG4gICAgdmFyIHgxID0gKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSArIChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkgKiAoYSAmIDB4MDAwMEZGRkYpICsgY2Fycnk7XG4gICAgdmFyIHgyID0gKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSAqIChhID4+PiAxNik7XG4gICAgY2FycnkgPSBNYXRoLmZsb29yKHgyLzY1NTM2KTtcbiAgICB2YXIgeDMgPSB4MSArICh4MiAlIDY1NTM2KSAqIDY1NTM2O1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0geDM7XG4gICAgY2FycnkgKz0gTWF0aC5mbG9vcih4My80Mjk0OTY3Mjk2KTtcbiAgfVxuXG4gIGlmKGxlbjIgPCBsZW4xICYmIGNhcnJ5KSB7XG4gICAgcmV0dXJuIGFkZF9uYXQobmF0MSwgb2ZzMStsZW4yLCBsZW4xLWxlbjIsIG5hdF9vZl9hcnJheShbY2FycnldKSwgMCwgMSwgMCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNhcnJ5O1xuICB9XG59XG5cbi8vIG5hdDEgKz0gbmF0MiAqIG5hdDNcbi8vIGxlbjEgPj0gbGVuMiArIGxlbjMuXG4vL1Byb3ZpZGVzOiBtdWx0X25hdFxuLy9SZXF1aXJlczogbXVsdF9kaWdpdF9uYXRcbmZ1bmN0aW9uIG11bHRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIG5hdDMsIG9mczMsIGxlbjMpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjM7IGkrKykge1xuICAgIGNhcnJ5ICs9IG11bHRfZGlnaXRfbmF0KG5hdDEsIG9mczEraSwgbGVuMS1pLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXQzLCBvZnMzK2kpO1xuICB9XG4gIHJldHVybiBjYXJyeTtcbn1cblxuLy8gbmF0MSA9IDIgKiBuYXQxICsgbmF0MiAqIG5hdDJcbi8vIGxlbjEgPj0gMiAqIGxlbjJcbi8vUHJvdmlkZXM6IHNxdWFyZV9uYXRcbi8vUmVxdWlyZXM6IG11bHRfbmF0LCBhZGRfbmF0XG5mdW5jdGlvbiBzcXVhcmVfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgY2FycnkgKz0gYWRkX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQxLCBvZnMxLCBsZW4xLCAwKTtcbiAgY2FycnkgKz0gbXVsdF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0Miwgb2ZzMiwgbGVuMik7XG4gIHJldHVybiBjYXJyeTtcbn1cblxuXG4vLyAwIDw9IHNoaWZ0IDwgMzJcbi8vUHJvdmlkZXM6IHNoaWZ0X2xlZnRfbmF0XG5mdW5jdGlvbiBzaGlmdF9sZWZ0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBuYml0cykge1xuICBpZihuYml0cyA9PSAwKSB7XG4gICAgbmF0Mi5kYXRhW29mczJdID0gMDtcbiAgICByZXR1cm4gMDtcbiAgfVxuICB2YXIgd3JhcCA9IDA7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW4xOyBpKyspIHtcbiAgICB2YXIgYSA9IChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCk7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSAoYSA8PCBuYml0cykgfCB3cmFwO1xuICAgIHdyYXAgPSBhID4+PiAoMzIgLSBuYml0cyk7XG4gIH1cbiAgbmF0Mi5kYXRhW29mczJdID0gd3JhcDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vIEFzc3VtaW5nIGMgPiBhLCByZXR1cm5zIFtxdW90aWVudCwgcmVtYWluZGVyXSBvZiAoYTw8MzIgKyBiKS9jXG4vL1Byb3ZpZGVzOiBkaXZfaGVscGVyXG5mdW5jdGlvbiBkaXZfaGVscGVyKGEsIGIsIGMpIHtcbiAgdmFyIHggPSBhICogNjU1MzYgKyAoYj4+PjE2KTtcbiAgdmFyIHkgPSBNYXRoLmZsb29yKHgvYykgKiA2NTUzNjtcbiAgdmFyIHogPSAoeCAlIGMpICogNjU1MzY7XG4gIHZhciB3ID0geiArIChiICYgMHgwMDAwRkZGRik7XG4gIHJldHVybiBbeSArIE1hdGguZmxvb3Iody9jKSwgdyAlIGNdO1xufVxuXG4vLyBuYXQxW29mczErbGVuXSA8IG5hdDJbb2ZzMl1cbi8vUHJvdmlkZXM6IGRpdl9kaWdpdF9uYXRcbi8vUmVxdWlyZXM6IGRpdl9oZWxwZXJcbmZ1bmN0aW9uIGRpdl9kaWdpdF9uYXQobmF0cSwgb2ZzcSwgbmF0ciwgb2ZzciwgbmF0MSwgb2ZzMSwgbGVuLCBuYXQyLCBvZnMyKSB7XG4gIHZhciByZW0gPSAobmF0MS5kYXRhW29mczErbGVuLTFdID4+PjApO1xuICAvLyBuYXRxW29mc3ErbGVuLTFdIGlzIGd1YXJhbnRlZWQgdG8gYmUgemVybyAoZHVlIHRvIHRoZSBNU0QgcmVxdWlyZW1lbnQpLFxuICAvLyBhbmQgc2hvdWxkIG5vdCBiZSB3cml0dGVuIHRvLlxuICBmb3IodmFyIGkgPSBsZW4tMjsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgeCA9IGRpdl9oZWxwZXIocmVtLCAobmF0MS5kYXRhW29mczEraV0gPj4+IDApLCAobmF0Mi5kYXRhW29mczJdID4+PiAwKSk7XG4gICAgbmF0cS5kYXRhW29mc3EraV0gPSB4WzBdO1xuICAgIHJlbSA9IHhbMV07XG4gIH1cbiAgbmF0ci5kYXRhW29mc3JdID0gcmVtO1xuICByZXR1cm4gMDtcbn1cblxuLy8gbmF0MVtuYXQyOl0gOj0gbmF0MSAvIG5hdDJcbi8vIG5hdDFbOm5hdDJdIDo9IG5hdDEgJSBuYXQyXG4vLyBsZW4xID4gbGVuMiwgbmF0MltvZnMyK2xlbjItMV0gPiBuYXQxW29mczErbGVuMS0xXVxuLy9Qcm92aWRlczogZGl2X25hdFxuLy9SZXF1aXJlczogZGl2X2RpZ2l0X25hdCwgZGl2X2hlbHBlciwgbnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0LCBzaGlmdF9sZWZ0X25hdCwgc2hpZnRfcmlnaHRfbmF0LCBjcmVhdGVfbmF0LCBzZXRfdG9femVyb19uYXQsIG11bHRfZGlnaXRfbmF0LCBzdWJfbmF0LCBjb21wYXJlX25hdCwgbmF0X29mX2FycmF5XG5mdW5jdGlvbiBkaXZfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIpIHtcbiAgaWYobGVuMiA9PSAxKSB7XG4gICAgZGl2X2RpZ2l0X25hdChuYXQxLCBvZnMxKzEsIG5hdDEsIG9mczEsIG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIpO1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHMgPSBudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXQobmF0Miwgb2ZzMitsZW4yLTEpO1xuICBzaGlmdF9sZWZ0X25hdChuYXQyLCBvZnMyLCBsZW4yLCBuYXRfb2ZfYXJyYXkoWzBdKSwgMCwgcyk7XG4gIHNoaWZ0X2xlZnRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdF9vZl9hcnJheShbMF0pLCAwLCBzKTtcblxuICB2YXIgZCA9IChuYXQyLmRhdGFbb2ZzMitsZW4yLTFdID4+PiAwKSArIDE7XG4gIHZhciBhID0gY3JlYXRlX25hdChsZW4yKzEpO1xuICBmb3IgKHZhciBpID0gbGVuMSAtIDE7IGkgPj0gbGVuMjsgaS0tKSB7XG4gICAgLy8gRGVjZW50IGxvd2VyIGJvdW5kIG9uIHF1b1xuICAgIHZhciBxdW8gPSBkID09IDQyOTQ5NjcyOTYgPyAobmF0MS5kYXRhW29mczEraV0gPj4+IDApIDogZGl2X2hlbHBlcigobmF0MS5kYXRhW29mczEraV0gPj4+IDApLCAobmF0MS5kYXRhW29mczEraS0xXSA+Pj4wKSwgZClbMF07XG4gICAgc2V0X3RvX3plcm9fbmF0KGEsIDAsIGxlbjIrMSk7XG4gICAgbXVsdF9kaWdpdF9uYXQoYSwgMCwgbGVuMisxLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXRfb2ZfYXJyYXkoW3F1b10pLCAwKTtcbiAgICBzdWJfbmF0KG5hdDEsIG9mczEraS1sZW4yLCBsZW4yKzEsIGEsIDAsIGxlbjIrMSwgMSk7XG5cbiAgICB3aGlsZSAobmF0MS5kYXRhW29mczEraV0gIT0gMCB8fCBjb21wYXJlX25hdChuYXQxLCBvZnMxK2ktbGVuMiwgbGVuMiwgbmF0Miwgb2ZzMiwgbGVuMikgPj0gMCkge1xuICAgICAgcXVvID0gcXVvICsgMTtcbiAgICAgIHN1Yl9uYXQobmF0MSwgb2ZzMStpLWxlbjIsIGxlbjIrMSwgbmF0Miwgb2ZzMiwgbGVuMiwgMSk7XG4gICAgfVxuXG4gICAgbmF0MS5kYXRhW29mczEraV0gPSBxdW87XG4gIH1cblxuICBzaGlmdF9yaWdodF9uYXQobmF0MSwgb2ZzMSwgbGVuMiwgbmF0X29mX2FycmF5KFswXSksIDAsIHMpOyAvLyBzaGlmdCByZW1haW5kZXJcbiAgc2hpZnRfcmlnaHRfbmF0KG5hdDIsIG9mczIsIGxlbjIsIG5hdF9vZl9hcnJheShbMF0pLCAwLCBzKTsgLy8gcmVzdG9yZVxuICByZXR1cm4gMDtcbn1cblxuXG4vLyAwIDw9IHNoaWZ0IDwgMzJcbi8vUHJvdmlkZXM6IHNoaWZ0X3JpZ2h0X25hdFxuZnVuY3Rpb24gc2hpZnRfcmlnaHRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIG5iaXRzKSB7XG4gIGlmKG5iaXRzID09IDApIHtcbiAgICBuYXQyLmRhdGFbb2ZzMl0gPSAwO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHZhciB3cmFwID0gMDtcbiAgZm9yKHZhciBpID0gbGVuMS0xOyBpID49IDA7IGktLSkge1xuICAgIHZhciBhID0gbmF0MS5kYXRhW29mczEraV0gPj4+IDA7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSAoYSA+Pj4gbmJpdHMpIHwgd3JhcDtcbiAgICB3cmFwID0gYSA8PCAoMzIgLSBuYml0cyk7XG4gIH1cbiAgbmF0Mi5kYXRhW29mczJdID0gd3JhcDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNvbXBhcmVfZGlnaXRzX25hdFxuZnVuY3Rpb24gY29tcGFyZV9kaWdpdHNfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIpIHtcbiAgaWYobmF0MS5kYXRhW29mczFdID4gbmF0Mi5kYXRhW29mczJdKSByZXR1cm4gMTtcbiAgaWYobmF0MS5kYXRhW29mczFdIDwgbmF0Mi5kYXRhW29mczJdKSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wYXJlX25hdFxuLy9SZXF1aXJlczogbnVtX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIGNvbXBhcmVfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIpIHtcbiAgdmFyIGEgPSBudW1fZGlnaXRzX25hdChuYXQxLCBvZnMxLCBsZW4xKTtcbiAgdmFyIGIgPSBudW1fZGlnaXRzX25hdChuYXQyLCBvZnMyLCBsZW4yKTtcbiAgaWYoYSA+IGIpIHJldHVybiAxO1xuICBpZihhIDwgYikgcmV0dXJuIC0xO1xuICBmb3IodmFyIGkgPSBsZW4xIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSA+IChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkpIHJldHVybiAxO1xuICAgIGlmICgobmF0MS5kYXRhW29mczEraV0gPj4+IDApIDwgKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSkgcmV0dXJuIC0xO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wYXJlX25hdF9yZWFsXG4vL1JlcXVpcmVzOiBjb21wYXJlX25hdFxuZnVuY3Rpb24gY29tcGFyZV9uYXRfcmVhbChuYXQxLG5hdDIpe1xuICByZXR1cm4gY29tcGFyZV9uYXQobmF0MSwwLG5hdDEuZGF0YS5sZW5ndGgsbmF0MiwwLG5hdDIuZGF0YS5sZW5ndGgpO1xufVxuXG4vL1Byb3ZpZGVzOiBsYW5kX2RpZ2l0X25hdFxuZnVuY3Rpb24gbGFuZF9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMikge1xuICBuYXQxLmRhdGFbb2ZzMV0gJj0gbmF0Mi5kYXRhW29mczJdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbG9yX2RpZ2l0X25hdFxuZnVuY3Rpb24gbG9yX2RpZ2l0X25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyKSB7XG4gIG5hdDEuZGF0YVtvZnMxXSB8PSBuYXQyLmRhdGFbb2ZzMl07XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBseG9yX2RpZ2l0X25hdFxuZnVuY3Rpb24gbHhvcl9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMikge1xuICBuYXQxLmRhdGFbb2ZzMV0gXj0gbmF0Mi5kYXRhW29mczJdO1xuICByZXR1cm4gMDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBzZXJpYWxpemVfbmF0XG5mdW5jdGlvbiBzZXJpYWxpemVfbmF0KHdyaXRlciwgbmF0LCBzeil7XG4gIHZhciBsZW4gPSBuYXQuZGF0YS5sZW5ndGg7XG4gIHdyaXRlci53cml0ZSgzMiwgbGVuKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICB3cml0ZXIud3JpdGUoMzIsIG5hdC5kYXRhW2ldKTtcbiAgfVxuICBzelswXSA9IGxlbiAqIDQ7XG4gIHN6WzFdID0gbGVuICogODtcbn1cblxuLy9Qcm92aWRlczogZGVzZXJpYWxpemVfbmF0XG4vL1JlcXVpcmVzOiBNbE5hdFxuZnVuY3Rpb24gZGVzZXJpYWxpemVfbmF0KHJlYWRlciwgc3ope1xuICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgdmFyIG5hdCA9IG5ldyBNbE5hdChsZW4pO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspe1xuICAgIG5hdC5kYXRhW2ldID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgfVxuICBzelswXSA9IGxlbiAqIDQ7XG4gIHJldHVybiBuYXQ7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9tYXJzaGFsX2NvbnN0YW50c1xudmFyIGNhbWxfbWFyc2hhbF9jb25zdGFudHMgPSB7XG4gIFBSRUZJWF9TTUFMTF9CTE9DSzogICAgICAgICAweDgwLFxuICBQUkVGSVhfU01BTExfSU5UOiAgICAgICAgICAgMHg0MCxcbiAgUFJFRklYX1NNQUxMX1NUUklORzogICAgICAgIDB4MjAsXG4gIENPREVfSU5UODogICAgICAgICAgICAgICAgICAweDAwLFxuICBDT0RFX0lOVDE2OiAgICAgICAgICAgICAgICAgMHgwMSxcbiAgQ09ERV9JTlQzMjogICAgICAgICAgICAgICAgIDB4MDIsXG4gIENPREVfSU5UNjQ6ICAgICAgICAgICAgICAgICAweDAzLFxuICBDT0RFX1NIQVJFRDg6ICAgICAgICAgICAgICAgMHgwNCxcbiAgQ09ERV9TSEFSRUQxNjogICAgICAgICAgICAgIDB4MDUsXG4gIENPREVfU0hBUkVEMzI6ICAgICAgICAgICAgICAweDA2LFxuICBDT0RFX0JMT0NLMzI6ICAgICAgICAgICAgICAgMHgwOCxcbiAgQ09ERV9CTE9DSzY0OiAgICAgICAgICAgICAgIDB4MTMsXG4gIENPREVfU1RSSU5HODogICAgICAgICAgICAgICAweDA5LFxuICBDT0RFX1NUUklORzMyOiAgICAgICAgICAgICAgMHgwQSxcbiAgQ09ERV9ET1VCTEVfQklHOiAgICAgICAgICAgIDB4MEIsXG4gIENPREVfRE9VQkxFX0xJVFRMRTogICAgICAgICAweDBDLFxuICBDT0RFX0RPVUJMRV9BUlJBWThfQklHOiAgICAgMHgwRCxcbiAgQ09ERV9ET1VCTEVfQVJSQVk4X0xJVFRMRTogIDB4MEUsXG4gIENPREVfRE9VQkxFX0FSUkFZMzJfQklHOiAgICAweDBGLFxuICBDT0RFX0RPVUJMRV9BUlJBWTMyX0xJVFRMRTogMHgwNyxcbiAgQ09ERV9DT0RFUE9JTlRFUjogICAgICAgICAgIDB4MTAsXG4gIENPREVfSU5GSVhQT0lOVEVSOiAgICAgICAgICAweDExLFxuICBDT0RFX0NVU1RPTTogICAgICAgICAgICAgICAgMHgxMixcbiAgQ09ERV9DVVNUT01fTEVOOiAgICAgICAgICAgIDB4MTgsXG4gIENPREVfQ1VTVE9NX0ZJWEVEOiAgICAgICAgICAweDE5XG59XG5cblxuLy9Qcm92aWRlczogTWxCeXRlc1JlYWRlclxuLy9SZXF1aXJlczogY2FtbF9uZXdfc3RyaW5nLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBNbEJ5dGVzUmVhZGVyIChzLCBpKSB7IHRoaXMucyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocyk7IHRoaXMuaSA9IGk7IH1cbk1sQnl0ZXNSZWFkZXIucHJvdG90eXBlID0ge1xuICByZWFkOHU6ZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5zLmNoYXJDb2RlQXQodGhpcy5pKyspOyB9LFxuICByZWFkOHM6ZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5zLmNoYXJDb2RlQXQodGhpcy5pKyspIDw8IDI0ID4+IDI0OyB9LFxuICByZWFkMTZ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKHMuY2hhckNvZGVBdChpKSA8PCA4KSB8IHMuY2hhckNvZGVBdChpICsgMSlcbiAgfSxcbiAgcmVhZDE2czpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChzLmNoYXJDb2RlQXQoaSkgPDwgMjQgPj4gMTYpIHwgcy5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgfSxcbiAgcmVhZDMydTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuICgocy5jaGFyQ29kZUF0KGkpIDw8IDI0KSB8IChzLmNoYXJDb2RlQXQoaSsxKSA8PCAxNikgfFxuICAgICAgICAgICAgKHMuY2hhckNvZGVBdChpKzIpIDw8IDgpIHwgcy5jaGFyQ29kZUF0KGkrMykpID4+PiAwO1xuICB9LFxuICByZWFkMzJzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKHMuY2hhckNvZGVBdChpKSA8PCAyNCkgfCAocy5jaGFyQ29kZUF0KGkrMSkgPDwgMTYpIHxcbiAgICAgIChzLmNoYXJDb2RlQXQoaSsyKSA8PCA4KSB8IHMuY2hhckNvZGVBdChpKzMpO1xuICB9LFxuICByZWFkc3RyOmZ1bmN0aW9uIChsZW4pIHtcbiAgICB2YXIgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgbGVuO1xuICAgIHJldHVybiBjYW1sX25ld19zdHJpbmcodGhpcy5zLnN1YnN0cmluZyhpLCBpICsgbGVuKSk7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogQmlnU3RyaW5nUmVhZGVyXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9hcnJheSwgY2FtbF9iYV9nZXRfMVxuZnVuY3Rpb24gQmlnU3RyaW5nUmVhZGVyIChicywgaSkgeyB0aGlzLnMgPSBiczsgdGhpcy5pID0gaTsgfVxuQmlnU3RyaW5nUmVhZGVyLnByb3RvdHlwZSA9IHtcbiAgcmVhZDh1OmZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbWxfYmFfZ2V0XzEodGhpcy5zLHRoaXMuaSsrKTsgfSxcbiAgcmVhZDhzOmZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbWxfYmFfZ2V0XzEodGhpcy5zLHRoaXMuaSsrKSA8PCAyNCA+PiAyNDsgfSxcbiAgcmVhZDE2dTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChjYW1sX2JhX2dldF8xKHMsaSkgPDwgOCkgfCBjYW1sX2JhX2dldF8xKHMsaSArIDEpXG4gIH0sXG4gIHJlYWQxNnM6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyAyO1xuICAgIHJldHVybiAoY2FtbF9iYV9nZXRfMShzLGkpIDw8IDI0ID4+IDE2KSB8IGNhbWxfYmFfZ2V0XzEocyxpICsgMSk7XG4gIH0sXG4gIHJlYWQzMnU6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyA0O1xuICAgIHJldHVybiAoKGNhbWxfYmFfZ2V0XzEocyxpKSAgIDw8IDI0KSB8IChjYW1sX2JhX2dldF8xKHMsaSsxKSA8PCAxNikgfFxuICAgICAgICAgICAgKGNhbWxfYmFfZ2V0XzEocyxpKzIpIDw8IDgpICB8IGNhbWxfYmFfZ2V0XzEocyxpKzMpICAgICAgICAgKSA+Pj4gMDtcbiAgfSxcbiAgcmVhZDMyczpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuIChjYW1sX2JhX2dldF8xKHMsaSkgICA8PCAyNCkgfCAoY2FtbF9iYV9nZXRfMShzLGkrMSkgPDwgMTYpIHxcbiAgICAgIChjYW1sX2JhX2dldF8xKHMsaSsyKSA8PCA4KSAgfCBjYW1sX2JhX2dldF8xKHMsaSszKTtcbiAgfSxcbiAgcmVhZHN0cjpmdW5jdGlvbiAobGVuKSB7XG4gICAgdmFyIGkgPSB0aGlzLmk7XG4gICAgdmFyIGFyciA9IG5ldyBBcnJheShsZW4pXG4gICAgZm9yKHZhciBqID0gMDsgaiA8IGxlbjsgaisrKXtcbiAgICAgIGFycltqXSA9IGNhbWxfYmFfZ2V0XzEodGhpcy5zLCBpK2opO1xuICAgIH1cbiAgICB0aGlzLmkgPSBpICsgbGVuO1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9hcnJheShhcnIpO1xuICB9XG59XG5cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0X29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMsIGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKGEpIHtcbiAgcmV0dXJuIGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyAoY2FtbF9pbnQ2NF9vZl9ieXRlcyAoYSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fc3RyaW5nIG11dGFibGVcbi8vUmVxdWlyZXM6IE1sQnl0ZXNSZWFkZXIsIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXJcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmcocyxvZnMpIHtcbiAgdmFyIHJlYWRlciA9IG5ldyBNbEJ5dGVzUmVhZGVyIChzLCB0eXBlb2Ygb2ZzPT1cIm51bWJlclwiP29mczpvZnNbMF0pO1xuICByZXR1cm4gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlcihyZWFkZXIsIG9mcylcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzIG11dGFibGVcbi8vUmVxdWlyZXM6IE1sQnl0ZXNSZWFkZXIsIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXJcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyhzLG9mcykge1xuICB2YXIgcmVhZGVyID0gbmV3IE1sQnl0ZXNSZWFkZXIgKHMsIHR5cGVvZiBvZnM9PVwibnVtYmVyXCI/b2ZzOm9mc1swXSk7XG4gIHJldHVybiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyKHJlYWRlciwgb2ZzKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3VubWFyc2hhbFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9pbnQ2NF91bm1hcnNoYWwocmVhZGVyLCBzaXplKXtcbiAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gIHNpemVbMF0gPSA4O1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyAodCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbWFyc2hhbFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9pbnQ2NF9tYXJzaGFsKHdyaXRlciwgdiwgc2l6ZXMpIHtcbiAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzICh2KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHdyaXRlci53cml0ZSAoOCwgYltpXSk7XG4gIHNpemVzWzBdID0gODsgc2l6ZXNbMV0gPSA4O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX3VubWFyc2hhbFxuZnVuY3Rpb24gY2FtbF9pbnQzMl91bm1hcnNoYWwocmVhZGVyLCBzaXplKXtcbiAgc2l6ZVswXSA9IDQ7XG4gIHJldHVybiByZWFkZXIucmVhZDMycyAoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX25hdGl2ZWludF91bm1hcnNoYWwocmVhZGVyLCBzaXplKXtcbiAgc3dpdGNoIChyZWFkZXIucmVhZDh1ICgpKSB7XG4gIGNhc2UgMTpcbiAgICBzaXplWzBdID0gNDtcbiAgICByZXR1cm4gcmVhZGVyLnJlYWQzMnMgKCk7XG4gIGNhc2UgMjpcbiAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IG5hdGl2ZSBpbnRlZ2VyIHZhbHVlIHRvbyBsYXJnZVwiKTtcbiAgZGVmYXVsdDogY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBpbGwtZm9ybWVkIG5hdGl2ZSBpbnRlZ2VyXCIpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3VzdG9tX29wc1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF91bm1hcnNoYWwsIGNhbWxfaW50NjRfbWFyc2hhbCwgY2FtbF9pbnQ2NF9jb21wYXJlLCBjYW1sX2ludDY0X2hhc2hcbi8vUmVxdWlyZXM6IGNhbWxfaW50MzJfdW5tYXJzaGFsLCBjYW1sX25hdGl2ZWludF91bm1hcnNoYWxcbi8vUmVxdWlyZXM6IGNhbWxfYmFfc2VyaWFsaXplLCBjYW1sX2JhX2Rlc2VyaWFsaXplLCBjYW1sX2JhX2NvbXBhcmUsIGNhbWxfYmFfaGFzaFxudmFyIGNhbWxfY3VzdG9tX29wcyA9XG4gICAge1wiX2pcIjoge1xuICAgICAgZGVzZXJpYWxpemUgOiBjYW1sX2ludDY0X3VubWFyc2hhbCxcbiAgICAgIHNlcmlhbGl6ZSAgOiBjYW1sX2ludDY0X21hcnNoYWwsXG4gICAgICBmaXhlZF9sZW5ndGggOiA4LFxuICAgICAgY29tcGFyZSA6IGNhbWxfaW50NjRfY29tcGFyZSxcbiAgICAgIGhhc2ggOiBjYW1sX2ludDY0X2hhc2hcbiAgICB9LFxuICAgICBcIl9pXCI6IHtcbiAgICAgICBkZXNlcmlhbGl6ZSA6IGNhbWxfaW50MzJfdW5tYXJzaGFsLFxuICAgICAgIGZpeGVkX2xlbmd0aCA6IDQsXG4gICAgIH0sXG4gICAgIFwiX25cIjoge1xuICAgICAgIGRlc2VyaWFsaXplIDogY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsLFxuICAgICAgIGZpeGVkX2xlbmd0aCA6IDQsXG4gICAgIH0sXG4gICAgIFwiX2JpZ2FycmF5XCI6e1xuICAgICAgIGRlc2VyaWFsaXplIDogY2FtbF9iYV9kZXNlcmlhbGl6ZSxcbiAgICAgICBzZXJpYWxpemUgOiBjYW1sX2JhX3NlcmlhbGl6ZSxcbiAgICAgICBjb21wYXJlIDogY2FtbF9iYV9jb21wYXJlLFxuICAgICAgIGhhc2g6IGNhbWxfYmFfaGFzaCxcbiAgICAgfVxuICAgIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlciBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL1JlcXVpcmVzOiBjYW1sX2Zsb2F0X29mX2J5dGVzLCBjYW1sX2N1c3RvbV9vcHNcblxuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlcihyZWFkZXIsIG9mcykge1xuICB2YXIgX21hZ2ljID0gcmVhZGVyLnJlYWQzMnUgKClcbiAgdmFyIF9ibG9ja19sZW4gPSByZWFkZXIucmVhZDMydSAoKTtcbiAgdmFyIG51bV9vYmplY3RzID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gIHZhciBfc2l6ZV8zMiA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICB2YXIgX3NpemVfNjQgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciBpbnRlcm5fb2JqX3RhYmxlID0gKG51bV9vYmplY3RzID4gMCk/W106bnVsbDtcbiAgdmFyIG9ial9jb3VudGVyID0gMDtcbiAgZnVuY3Rpb24gaW50ZXJuX3JlYyAoKSB7XG4gICAgdmFyIGNvZGUgPSByZWFkZXIucmVhZDh1ICgpO1xuICAgIGlmIChjb2RlID49IDB4NDAgLypjc3QuUFJFRklYX1NNQUxMX0lOVCovKSB7XG4gICAgICBpZiAoY29kZSA+PSAweDgwIC8qY3N0LlBSRUZJWF9TTUFMTF9CTE9DSyovKSB7XG4gICAgICAgIHZhciB0YWcgPSBjb2RlICYgMHhGO1xuICAgICAgICB2YXIgc2l6ZSA9IChjb2RlID4+IDQpICYgMHg3O1xuICAgICAgICB2YXIgdiA9IFt0YWddO1xuICAgICAgICBpZiAoc2l6ZSA9PSAwKSByZXR1cm4gdjtcbiAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICBzdGFjay5wdXNoKHYsIHNpemUpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH0gZWxzZVxuICAgICAgICByZXR1cm4gKGNvZGUgJiAweDNGKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNvZGUgPj0gMHgyMC8qY3N0LlBSRUZJWF9TTUFMTF9TVFJJTkcgKi8pIHtcbiAgICAgICAgdmFyIGxlbiA9IGNvZGUgJiAweDFGO1xuICAgICAgICB2YXIgdiA9IHJlYWRlci5yZWFkc3RyIChsZW4pO1xuICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgIHJldHVybiB2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoKGNvZGUpIHtcbiAgICAgICAgY2FzZSAweDAwOiAvL2NzdC5DT0RFX0lOVDg6XG4gICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkOHMgKCk7XG4gICAgICAgIGNhc2UgMHgwMTogLy9jc3QuQ09ERV9JTlQxNjpcbiAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWQxNnMgKCk7XG4gICAgICAgIGNhc2UgMHgwMjogLy9jc3QuQ09ERV9JTlQzMjpcbiAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWQzMnMgKCk7XG4gICAgICAgIGNhc2UgMHgwMzogLy9jc3QuQ09ERV9JTlQ2NDpcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGludGVnZXIgdG9vIGxhcmdlXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MDQ6IC8vY3N0LkNPREVfU0hBUkVEODpcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gcmVhZGVyLnJlYWQ4dSAoKTtcbiAgICAgICAgICByZXR1cm4gaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlciAtIG9mZnNldF07XG4gICAgICAgIGNhc2UgMHgwNTogLy9jc3QuQ09ERV9TSEFSRUQxNjpcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gcmVhZGVyLnJlYWQxNnUgKCk7XG4gICAgICAgICAgcmV0dXJuIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIgLSBvZmZzZXRdO1xuICAgICAgICBjYXNlIDB4MDY6IC8vY3N0LkNPREVfU0hBUkVEMzI6XG4gICAgICAgICAgdmFyIG9mZnNldCA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICAgICAgICAgIHJldHVybiBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyIC0gb2Zmc2V0XTtcbiAgICAgICAgY2FzZSAweDA4OiAvL2NzdC5DT0RFX0JMT0NLMzI6XG4gICAgICAgICAgdmFyIGhlYWRlciA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICAgICAgICAgIHZhciB0YWcgPSBoZWFkZXIgJiAweEZGO1xuICAgICAgICAgIHZhciBzaXplID0gaGVhZGVyID4+IDEwO1xuICAgICAgICAgIHZhciB2ID0gW3RhZ107XG4gICAgICAgICAgaWYgKHNpemUgPT0gMCkgcmV0dXJuIHY7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHN0YWNrLnB1c2godiwgc2l6ZSk7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgxMzogLy9jc3QuQ09ERV9CTE9DSzY0OlxuICAgICAgICAgIGNhbWxfZmFpbHdpdGggKFwiaW5wdXRfdmFsdWU6IGRhdGEgYmxvY2sgdG9vIGxhcmdlXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MDk6IC8vY3N0LkNPREVfU1RSSU5HODpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgIHZhciB2ID0gcmVhZGVyLnJlYWRzdHIgKGxlbik7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEE6IC8vY3N0LkNPREVfU1RSSU5HMzI6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgICAgdmFyIHYgPSByZWFkZXIucmVhZHN0ciAobGVuKTtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwQzogLy9jc3QuQ09ERV9ET1VCTEVfTElUVExFOlxuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgODtpKyspIHRbNyAtIGldID0gcmVhZGVyLnJlYWQ4dSAoKTtcbiAgICAgICAgICB2YXIgdiA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBCOiAvL2NzdC5DT0RFX0RPVUJMRV9CSUc6XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwO2kgPCA4O2krKykgdFtpXSA9IHJlYWRlci5yZWFkOHUgKCk7XG4gICAgICAgICAgdmFyIHYgPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwRTogLy9jc3QuQ09ERV9ET1VCTEVfQVJSQVk4X0xJVFRMRTpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgIHZhciB2ID0gbmV3IEFycmF5KGxlbisxKTtcbiAgICAgICAgICB2WzBdID0gMjU0O1xuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7aSA8PSBsZW47aSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbNyAtIGpdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgICAgdltpXSA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBEOiAvL2NzdC5DT0RFX0RPVUJMRV9BUlJBWThfQklHOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHYgW2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MDc6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZMzJfTElUVExFOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICAgIHZhciB2ID0gbmV3IEFycmF5KGxlbisxKTtcbiAgICAgICAgICB2WzBdID0gMjU0O1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7aSA8PSBsZW47aSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbNyAtIGpdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgICAgdltpXSA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBGOiAvL2NzdC5DT0RFX0RPVUJMRV9BUlJBWTMyX0JJRzpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgICAgICB2YXIgdiA9IG5ldyBBcnJheShsZW4rMSk7XG4gICAgICAgICAgdlswXSA9IDI1NDtcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7aSA8PSBsZW47aSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2IFtpXSA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDEwOiAvL2NzdC5DT0RFX0NPREVQT0lOVEVSOlxuICAgICAgICBjYXNlIDB4MTE6IC8vY3N0LkNPREVfSU5GSVhQT0lOVEVSOlxuICAgICAgICAgIGNhbWxfZmFpbHdpdGggKFwiaW5wdXRfdmFsdWU6IGNvZGUgcG9pbnRlclwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDEyOiAvL2NzdC5DT0RFX0NVU1RPTTpcbiAgICAgICAgY2FzZSAweDE4OiAvL2NzdC5DT0RFX0NVU1RPTV9MRU46XG4gICAgICAgIGNhc2UgMHgxOTogLy9jc3QuQ09ERV9DVVNUT01fRklYRUQ6XG4gICAgICAgICAgdmFyIGMsIHMgPSBcIlwiO1xuICAgICAgICAgIHdoaWxlICgoYyA9IHJlYWRlci5yZWFkOHUgKCkpICE9IDApIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSAoYyk7XG4gICAgICAgICAgdmFyIG9wcyA9IGNhbWxfY3VzdG9tX29wc1tzXTtcbiAgICAgICAgICB2YXIgZXhwZWN0ZWRfc2l6ZTtcbiAgICAgICAgICBpZighb3BzKVxuICAgICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiB1bmtub3duIGN1c3RvbSBibG9jayBpZGVudGlmaWVyXCIpO1xuICAgICAgICAgIHN3aXRjaChjb2RlKXtcbiAgICAgICAgICBjYXNlIDB4MTI6IC8vIGNzdC5DT0RFX0NVU1RPTSAoZGVwcmVjYXRlZClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMHgxOTogLy8gY3N0LkNPREVfQ1VTVE9NX0ZJWEVEXG4gICAgICAgICAgICBpZighb3BzLmZpeGVkX2xlbmd0aClcbiAgICAgICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBleHBlY3RlZCBhIGZpeGVkLXNpemUgY3VzdG9tIGJsb2NrXCIpO1xuICAgICAgICAgICAgZXhwZWN0ZWRfc2l6ZSA9IG9wcy5maXhlZF9sZW5ndGg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDB4MTg6IC8vIGNzdC5DT0RFX0NVU1RPTV9MRU5cbiAgICAgICAgICAgIGV4cGVjdGVkX3NpemUgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgICAgICAgICAgIC8vIFNraXAgc2l6ZTY0XG4gICAgICAgICAgICByZWFkZXIucmVhZDMycygpOyByZWFkZXIucmVhZDMycygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBvbGRfcG9zID0gcmVhZGVyLmk7XG4gICAgICAgICAgdmFyIHNpemUgPSBbMF07XG4gICAgICAgICAgdmFyIHYgPSBvcHMuZGVzZXJpYWxpemUocmVhZGVyLCBzaXplKTtcbiAgICAgICAgICBpZihleHBlY3RlZF9zaXplICE9IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICBpZihleHBlY3RlZF9zaXplICE9IHNpemVbMF0pXG4gICAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogaW5jb3JyZWN0IGxlbmd0aCBvZiBzZXJpYWxpemVkIGN1c3RvbSBibG9ja1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNhbWxfZmFpbHdpdGggKFwiaW5wdXRfdmFsdWU6IGlsbC1mb3JtZWQgbWVzc2FnZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgcmVzID0gaW50ZXJuX3JlYyAoKTtcbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgc2l6ZSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciB2ID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGQgPSB2Lmxlbmd0aDtcbiAgICBpZiAoZCA8IHNpemUpIHN0YWNrLnB1c2godiwgc2l6ZSk7XG4gICAgdltkXSA9IGludGVybl9yZWMgKCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBvZnMhPVwibnVtYmVyXCIpIG9mc1swXSA9IHJlYWRlci5pO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21hcnNoYWxfZGF0YV9zaXplIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldFxuZnVuY3Rpb24gY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSAocywgb2ZzKSB7XG4gIGZ1bmN0aW9uIGdldDMyKHMsaSkge1xuICAgIHJldHVybiAoY2FtbF9ieXRlc191bnNhZmVfZ2V0KHMsIGkpIDw8IDI0KSB8XG4gICAgICAoY2FtbF9ieXRlc191bnNhZmVfZ2V0KHMsIGkgKyAxKSA8PCAxNikgfFxuICAgICAgKGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLCBpICsgMikgPDwgOCkgfFxuICAgICAgY2FtbF9ieXRlc191bnNhZmVfZ2V0KHMsIGkgKyAzKTtcbiAgfVxuICBpZiAoZ2V0MzIocywgb2ZzKSAhPSAoMHg4NDk1QTZCRXwwKSlcbiAgICBjYW1sX2ZhaWx3aXRoKFwiTWFyc2hhbC5kYXRhX3NpemU6IGJhZCBvYmplY3RcIik7XG4gIHJldHVybiAoZ2V0MzIocywgb2ZzICsgNCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBNbE9iamVjdFRhYmxlXG52YXIgTWxPYmplY3RUYWJsZTtcbmlmICh0eXBlb2Ygam9vX2dsb2JhbF9vYmplY3QuV2Vha01hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgTWxPYmplY3RUYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8qIHBvbHlmaWxsICh1c2luZyBsaW5lYXIgc2VhcmNoKSAqL1xuICAgIGZ1bmN0aW9uIE5haXZlTG9va3VwKG9ianMpIHsgdGhpcy5vYmpzID0gb2JqczsgfVxuICAgIE5haXZlTG9va3VwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbih2KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub2Jqcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5vYmpzW2ldID09PSB2KSByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9O1xuICAgIE5haXZlTG9va3VwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIERvIG5vdGhpbmcgaGVyZS4gW01sT2JqZWN0VGFibGUuc3RvcmVdIHdpbGwgcHVzaCB0byBbdGhpcy5vYmpzXSBkaXJlY3RseS5cbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIE1sT2JqZWN0VGFibGUoKSB7XG4gICAgICB0aGlzLm9ianMgPSBbXTsgdGhpcy5sb29rdXAgPSBuZXcgTmFpdmVMb29rdXAodGhpcy5vYmpzKTtcbiAgICB9O1xuICB9KCk7XG59XG5lbHNlIHtcbiAgTWxPYmplY3RUYWJsZSA9IGZ1bmN0aW9uIE1sT2JqZWN0VGFibGUoKSB7XG4gICAgdGhpcy5vYmpzID0gW107IHRoaXMubG9va3VwID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LldlYWtNYXAoKTtcbiAgfTtcbn1cblxuTWxPYmplY3RUYWJsZS5wcm90b3R5cGUuc3RvcmUgPSBmdW5jdGlvbih2KSB7XG4gIHRoaXMubG9va3VwLnNldCh2LCB0aGlzLm9ianMubGVuZ3RoKTtcbiAgdGhpcy5vYmpzLnB1c2godik7XG59XG5cbk1sT2JqZWN0VGFibGUucHJvdG90eXBlLnJlY2FsbCA9IGZ1bmN0aW9uKHYpIHtcbiAgdmFyIGkgPSB0aGlzLmxvb2t1cC5nZXQodik7XG4gIHJldHVybiAoaSA9PT0gdW5kZWZpbmVkKVxuICAgID8gdW5kZWZpbmVkIDogdGhpcy5vYmpzLmxlbmd0aCAtIGk7ICAgLyogaW5kZXggaXMgcmVsYXRpdmUgKi9cbn1cblxuLy9Qcm92aWRlczogY2FtbF9sZWdhY3lfY3VzdG9tX2NvZGVcbi8vVmVyc2lvbjogPj0gNC4wOFxudmFyIGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlID0gZmFsc2VcblxuLy9Qcm92aWRlczogY2FtbF9sZWdhY3lfY3VzdG9tX2NvZGVcbi8vVmVyc2lvbjogPCA0LjA4XG52YXIgY2FtbF9sZWdhY3lfY3VzdG9tX2NvZGUgPSB0cnVlXG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlcywgY2FtbF9mYWlsd2l0aFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0XG4vL1JlcXVpcmVzOiBNbEJ5dGVzLCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbi8vUmVxdWlyZXM6IE1sT2JqZWN0VGFibGUsIGNhbWxfbGlzdF90b19qc19hcnJheSwgY2FtbF9sZWdhY3lfY3VzdG9tX2NvZGUsIGNhbWxfY3VzdG9tX29wc1xuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG52YXIgY2FtbF9vdXRwdXRfdmFsID0gZnVuY3Rpb24gKCl7XG4gIGZ1bmN0aW9uIFdyaXRlciAoKSB7IHRoaXMuY2h1bmsgPSBbXTsgfVxuICBXcml0ZXIucHJvdG90eXBlID0ge1xuICAgIGNodW5rX2lkeDoyMCwgYmxvY2tfbGVuOjAsIG9ial9jb3VudGVyOjAsIHNpemVfMzI6MCwgc2l6ZV82NDowLFxuICAgIHdyaXRlOmZ1bmN0aW9uIChzaXplLCB2YWx1ZSkge1xuICAgICAgZm9yICh2YXIgaSA9IHNpemUgLSA4O2kgPj0gMDtpIC09IDgpXG4gICAgICAgIHRoaXMuY2h1bmtbdGhpcy5jaHVua19pZHgrK10gPSAodmFsdWUgPj4gaSkgJiAweEZGO1xuICAgIH0sXG4gICAgd3JpdGVfYXQ6ZnVuY3Rpb24gKHBvcywgc2l6ZSwgdmFsdWUpIHtcbiAgICAgIHZhciBwb3MgPSBwb3M7XG4gICAgICBmb3IgKHZhciBpID0gc2l6ZSAtIDg7aSA+PSAwO2kgLT0gOClcbiAgICAgICAgdGhpcy5jaHVua1twb3MrK10gPSAodmFsdWUgPj4gaSkgJiAweEZGO1xuICAgIH0sXG4gICAgd3JpdGVfY29kZTpmdW5jdGlvbiAoc2l6ZSwgY29kZSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuY2h1bmtbdGhpcy5jaHVua19pZHgrK10gPSBjb2RlO1xuICAgICAgZm9yICh2YXIgaSA9IHNpemUgLSA4O2kgPj0gMDtpIC09IDgpXG4gICAgICAgIHRoaXMuY2h1bmtbdGhpcy5jaHVua19pZHgrK10gPSAodmFsdWUgPj4gaSkgJiAweEZGO1xuICAgIH0sXG4gICAgd3JpdGVfc2hhcmVkOmZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgIGlmIChvZmZzZXQgPCAoMSA8PCA4KSkgdGhpcy53cml0ZV9jb2RlKDgsIDB4MDQgLypjc3QuQ09ERV9TSEFSRUQ4Ki8sIG9mZnNldCk7XG4gICAgICBlbHNlIGlmIChvZmZzZXQgPCAoMSA8PCAxNikpIHRoaXMud3JpdGVfY29kZSgxNiwgMHgwNSAvKmNzdC5DT0RFX1NIQVJFRDE2Ki8sIG9mZnNldCk7XG4gICAgICBlbHNlIHRoaXMud3JpdGVfY29kZSgzMiwgMHgwNiAvKmNzdC5DT0RFX1NIQVJFRDMyKi8sIG9mZnNldCk7XG4gICAgfSxcbiAgICBwb3M6ZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jaHVua19pZHggfSxcbiAgICBmaW5hbGl6ZTpmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmJsb2NrX2xlbiA9IHRoaXMuY2h1bmtfaWR4IC0gMjA7XG4gICAgICB0aGlzLmNodW5rX2lkeCA9IDA7XG4gICAgICB0aGlzLndyaXRlICgzMiwgMHg4NDk1QTZCRSk7XG4gICAgICB0aGlzLndyaXRlICgzMiwgdGhpcy5ibG9ja19sZW4pO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIHRoaXMub2JqX2NvdW50ZXIpO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIHRoaXMuc2l6ZV8zMik7XG4gICAgICB0aGlzLndyaXRlICgzMiwgdGhpcy5zaXplXzY0KTtcbiAgICAgIHJldHVybiB0aGlzLmNodW5rO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKHYsIGZsYWdzKSB7XG4gICAgZmxhZ3MgPSBjYW1sX2xpc3RfdG9fanNfYXJyYXkoZmxhZ3MpO1xuXG4gICAgdmFyIG5vX3NoYXJpbmcgPSAoZmxhZ3MuaW5kZXhPZigwIC8qTWFyc2hhbC5Ob19zaGFyaW5nKi8pICE9PSAtMSksXG4gICAgICAgIGNsb3N1cmVzID0gIChmbGFncy5pbmRleE9mKDEgLypNYXJzaGFsLkNsb3N1cmVzKi8pICE9PSAtMSk7XG4gICAgICAgIC8qIE1hcnNoYWwuQ29tcGF0XzMyIGlzIHJlZHVuZGFudCBzaW5jZSBpbnRlZ2VycyBhcmUgMzItYml0IGFueXdheSAqL1xuXG4gICAgaWYgKGNsb3N1cmVzKVxuICAgICAgam9vX2dsb2JhbF9vYmplY3QuY29uc29sZS53YXJuKFwiaW4gY2FtbF9vdXRwdXRfdmFsOiBmbGFnIE1hcnNoYWwuQ2xvc3VyZXMgaXMgbm90IHN1cHBvcnRlZC5cIik7XG5cbiAgICB2YXIgd3JpdGVyID0gbmV3IFdyaXRlciAoKTtcbiAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICB2YXIgaW50ZXJuX29ial90YWJsZSA9IG5vX3NoYXJpbmcgPyBudWxsIDogbmV3IE1sT2JqZWN0VGFibGUoKTtcblxuICAgIGZ1bmN0aW9uIG1lbW8odikge1xuICAgICAgaWYgKG5vX3NoYXJpbmcpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBleGlzdGluZ19vZmZzZXQgPSBpbnRlcm5fb2JqX3RhYmxlLnJlY2FsbCh2KTtcbiAgICAgIGlmIChleGlzdGluZ19vZmZzZXQpIHsgd3JpdGVyLndyaXRlX3NoYXJlZChleGlzdGluZ19vZmZzZXQpOyByZXR1cm4gdHJ1ZTsgfVxuICAgICAgZWxzZSB7IGludGVybl9vYmpfdGFibGUuc3RvcmUodik7IHJldHVybiBmYWxzZTsgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dGVybl9yZWMgKHYpIHtcbiAgICAgIGlmICh2LmNhbWxfY3VzdG9tIHx8ICh2IGluc3RhbmNlb2YgQXJyYXkgJiYgdlswXSA9PT0gMjU1KSkge1xuICAgICAgICBpZiAobWVtbyh2KSkgcmV0dXJuO1xuICAgICAgICB2YXIgbmFtZSA9IHYuY2FtbF9jdXN0b20gfHwgXCJfalwiO1xuICAgICAgICB2YXIgb3BzID0gY2FtbF9jdXN0b21fb3BzW25hbWVdO1xuICAgICAgICB2YXIgc3pfMzJfNjQgPSBbMCwwXTtcbiAgICAgICAgaWYoIW9wcy5zZXJpYWxpemUpXG4gICAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwib3V0cHV0X3ZhbHVlOiBhYnN0cmFjdCB2YWx1ZSAoQ3VzdG9tKVwiKTtcbiAgICAgICAgaWYoY2FtbF9sZWdhY3lfY3VzdG9tX2NvZGUpIHtcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MTIgLypjc3QuQ09ERV9DVVNUT00qLyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBuYW1lLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICBvcHMuc2VyaWFsaXplKHdyaXRlciwgdiwgc3pfMzJfNjQpO1xuICAgICAgICB9IGVsc2UgaWYob3BzLmZpeGVkX2xlbmd0aCA9PSB1bmRlZmluZWQpe1xuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgxOCAvKmNzdC5DT0RFX0NVU1RPTV9MRU4qLyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBuYW1lLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICB2YXIgaGVhZGVyX3BvcyA9IHdyaXRlci5wb3MgKCk7XG4gICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3BzLnNlcmlhbGl6ZSh3cml0ZXIsIHYsIHN6XzMyXzY0KTtcbiAgICAgICAgICB3cml0ZXIud3JpdGVfYXQoaGVhZGVyX3BvcywgMzIsIHN6XzMyXzY0WzBdKTtcbiAgICAgICAgICB3cml0ZXIud3JpdGVfYXQoaGVhZGVyX3BvcyArIDQsIDMyLCAwKTsgLy8gemVyb1xuICAgICAgICAgIHdyaXRlci53cml0ZV9hdChoZWFkZXJfcG9zICsgOCwgMzIsIHN6XzMyXzY0WzFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MTkgLypjc3QuQ09ERV9DVVNUT01fRklYRUQqLyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBuYW1lLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICB2YXIgb2xkX3BvcyA9IHdyaXRlci5wb3MoKTtcbiAgICAgICAgICBvcHMuc2VyaWFsaXplKHdyaXRlciwgdiwgc3pfMzJfNjQpO1xuICAgICAgICAgIGlmIChvcHMuZml4ZWRfbGVuZ3RoICE9IHdyaXRlci5wb3MoKSAtIG9sZF9wb3MpXG4gICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBpbmNvcnJlY3QgZml4ZWQgc2l6ZXMgc3BlY2lmaWVkIGJ5IFwiICsgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gMiArICgoc3pfMzJfNjRbMF0gKyAzKSA+PiAyKTtcbiAgICAgICAgd3JpdGVyLnNpemVfNjQgKz0gMiArICgoc3pfMzJfNjRbMV0gKyA3KSA+PiAzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBBcnJheSAmJiB2WzBdID09PSAodlswXXwwKSkge1xuICAgICAgICBpZiAodlswXSA9PSAyNTEpIHtcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBhYnN0cmFjdCB2YWx1ZSAoQWJzdHJhY3QpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2Lmxlbmd0aCA+IDEgJiYgbWVtbyh2KSkgcmV0dXJuO1xuICAgICAgICBpZiAodlswXSA8IDE2ICYmIHYubGVuZ3RoIC0gMSA8IDgpXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDgwIC8qY3N0LlBSRUZJWF9TTUFMTF9CTE9DSyovICsgdlswXSArICgodi5sZW5ndGggLSAxKTw8NCkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoMzIsIDB4MDggLypjc3QuQ09ERV9CTE9DSzMyKi8sICgodi5sZW5ndGgtMSkgPDwgMTApIHwgdlswXSk7XG4gICAgICAgIHdyaXRlci5zaXplXzMyICs9IHYubGVuZ3RoO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSB2Lmxlbmd0aDtcbiAgICAgICAgaWYgKHYubGVuZ3RoID4gMSkgc3RhY2sucHVzaCAodiwgMSk7XG4gICAgICB9IGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBNbEJ5dGVzKSB7XG4gICAgICAgIGlmIChtZW1vKHYpKSByZXR1cm47XG4gICAgICAgIHZhciBsZW4gPSBjYW1sX21sX3N0cmluZ19sZW5ndGgodik7XG4gICAgICAgIGlmIChsZW4gPCAweDIwKVxuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgyMCAvKmNzdC5QUkVGSVhfU01BTExfU1RSSU5HKi8gKyBsZW4pO1xuICAgICAgICBlbHNlIGlmIChsZW4gPCAweDEwMClcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSAoOCwgMHgwOS8qY3N0LkNPREVfU1RSSU5HOCovLCBsZW4pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUgKDMyLCAweDBBIC8qY3N0LkNPREVfU1RSSU5HMzIqLywgbGVuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IGxlbjtpKyspXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHYsaSkpO1xuICAgICAgICB3cml0ZXIuc2l6ZV8zMiArPSAxICsgKCgobGVuICsgNCkgLyA0KXwwKTtcbiAgICAgICAgd3JpdGVyLnNpemVfNjQgKz0gMSArICgoKGxlbiArIDgpIC8gOCl8MCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodiAhPSAodnwwKSl7XG4gICAgICAgICAgdmFyIHR5cGVfb2ZfdiA9IHR5cGVvZiB2O1xuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gSWYgYSBmbG9hdCBoYXBwZW5zIHRvIGJlIGFuIGludGVnZXIgaXQgaXMgc2VyaWFsaXplZCBhcyBhbiBpbnRlZ2VyXG4gICAgICAgICAgLy8gKEpzX29mX29jYW1sIGNhbm5vdCB0ZWxsIHdoZXRoZXIgdGhlIHR5cGUgb2YgYW4gaW50ZWdlciBudW1iZXIgaXNcbiAgICAgICAgICAvLyBmbG9hdCBvciBpbnRlZ2VyLikgVGhpcyBjYW4gcmVzdWx0IGluIHVuZXhwZWN0ZWQgY3Jhc2hlcyB3aGVuXG4gICAgICAgICAgLy8gdW5tYXJzaGFsbGluZyB1c2luZyB0aGUgc3RhbmRhcmQgcnVudGltZS4gSXQgc2VlbXMgYmV0dGVyIHRvXG4gICAgICAgICAgLy8gc3lzdGVtYXRpY2FsbHkgZmFpbCBvbiBtYXJzaGFsbGluZy5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vICAgICAgICAgIGlmKHR5cGVfb2ZfdiAhPSBcIm51bWJlclwiKVxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJvdXRwdXRfdmFsdWU6IGFic3RyYWN0IHZhbHVlIChcIit0eXBlX29mX3YrXCIpXCIpO1xuICAgICAgICAgIC8vICAgICAgICAgIHZhciB0ID0gY2FtbF9pbnQ2NF90b19ieXRlcyhjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQodikpO1xuICAgICAgICAgIC8vICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgwQiAvKmNzdC5DT0RFX0RPVUJMRV9CSUcqLyk7XG4gICAgICAgICAgLy8gICAgICAgICAgZm9yKHZhciBpID0gMDsgaTw4OyBpKyspe3dyaXRlci53cml0ZSg4LHRbaV0pfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHYgPj0gMCAmJiB2IDwgMHg0MCkge1xuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMFg0MCAvKmNzdC5QUkVGSVhfU01BTExfSU5UKi8gKyB2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodiA+PSAtKDEgPDwgNykgJiYgdiA8ICgxIDw8IDcpKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoOCwgMHgwMCAvKmNzdC5DT0RFX0lOVDgqLywgdik7XG4gICAgICAgICAgZWxzZSBpZiAodiA+PSAtKDEgPDwgMTUpICYmIHYgPCAoMSA8PCAxNSkpXG4gICAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSgxNiwgMHgwMSAvKmNzdC5DT0RFX0lOVDE2Ki8sIHYpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlKDMyLCAweDAyIC8qY3N0LkNPREVfSU5UMzIqLywgdik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZXh0ZXJuX3JlYyAodik7XG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBpID0gc3RhY2sucG9wICgpO1xuICAgICAgdmFyIHYgPSBzdGFjay5wb3AgKCk7XG4gICAgICBpZiAoaSArIDEgPCB2Lmxlbmd0aCkgc3RhY2sucHVzaCAodiwgaSArIDEpO1xuICAgICAgZXh0ZXJuX3JlYyAodltpXSk7XG4gICAgfVxuICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSB3cml0ZXIub2JqX2NvdW50ZXIgPSBpbnRlcm5fb2JqX3RhYmxlLm9ianMubGVuZ3RoO1xuICAgIHdyaXRlci5maW5hbGl6ZSgpO1xuICAgIHJldHVybiB3cml0ZXIuY2h1bms7XG4gIH1cbn0gKCk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX291dHB1dF92YWwsIGNhbWxfc3RyaW5nX29mX2FycmF5XG5mdW5jdGlvbiBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcgKHYsIGZsYWdzKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9hcnJheSAoY2FtbF9vdXRwdXRfdmFsICh2LCBmbGFncykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWx1ZV90b19ieXRlcyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX291dHB1dF92YWwsIGNhbWxfc3RyaW5nX29mX2FycmF5XG5mdW5jdGlvbiBjYW1sX291dHB1dF92YWx1ZV90b19ieXRlcyAodiwgZmxhZ3MpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5IChjYW1sX291dHB1dF92YWwgKHYsIGZsYWdzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J1ZmZlclxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsLCBjYW1sX2ZhaWx3aXRoLCBjYW1sX2JsaXRfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J1ZmZlciAocywgb2ZzLCBsZW4sIHYsIGZsYWdzKSB7XG4gIHZhciB0ID0gY2FtbF9vdXRwdXRfdmFsICh2LCBmbGFncyk7XG4gIGlmICh0Lmxlbmd0aCA+IGxlbikgY2FtbF9mYWlsd2l0aCAoXCJNYXJzaGFsLnRvX2J1ZmZlcjogYnVmZmVyIG92ZXJmbG93XCIpO1xuICBjYW1sX2JsaXRfYnl0ZXModCwgMCwgcywgb2ZzLCB0Lmxlbmd0aCk7XG4gIHJldHVybiAwO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBJb1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jbG9zZVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9zeXNfY2xvc2UoZmQpIHtcbiAgZGVsZXRlIGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2ZkXTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RkX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9uZXdfc3RyaW5nLCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfc3RkX291dHB1dChjaGFuaWQscyl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICB2YXIgc3RyID0gY2FtbF9uZXdfc3RyaW5nKHMpO1xuICB2YXIgc2xlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzdHIpO1xuICBjaGFuLmZpbGUud3JpdGUoY2hhbi5vZmZzZXQsIHN0ciwgMCwgc2xlbik7XG4gIGNoYW4ub2Zmc2V0ICs9IHNsZW47XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19vcGVuXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9nbG9iYWxfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9jcmVhdGVfYnl0ZXMsTWxGYWtlRmlsZVxuLy9SZXF1aXJlczoganNfcHJpbnRfc3RkZXJyLCBqc19wcmludF9zdGRvdXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RkX291dHB1dFxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX29wZW5faW50ZXJuYWwoaWR4LG91dHB1dCxmaWxlLGZsYWdzKSB7XG4gIGlmKGNhbWxfZ2xvYmFsX2RhdGEuZmRzID09PSB1bmRlZmluZWQpIGNhbWxfZ2xvYmFsX2RhdGEuZmRzID0gbmV3IEFycmF5KCk7XG4gIGZsYWdzPWZsYWdzP2ZsYWdzOnt9O1xuICB2YXIgaW5mbyA9IHt9O1xuICBpbmZvLmZpbGUgPSBmaWxlO1xuICBpbmZvLm9mZnNldCA9IGZsYWdzLmFwcGVuZD9maWxlLmxlbmd0aCgpOjA7XG4gIGluZm8uZmxhZ3MgPSBmbGFncztcbiAgaW5mby5vdXRwdXQgPSBvdXRwdXQ7XG4gIGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2lkeF0gPSBpbmZvO1xuICBpZighY2FtbF9nbG9iYWxfZGF0YS5mZF9sYXN0X2lkeCB8fCBpZHggPiBjYW1sX2dsb2JhbF9kYXRhLmZkX2xhc3RfaWR4KVxuICAgIGNhbWxfZ2xvYmFsX2RhdGEuZmRfbGFzdF9pZHggPSBpZHg7XG4gIHJldHVybiBpZHg7XG59XG5mdW5jdGlvbiBjYW1sX3N5c19vcGVuIChuYW1lLCBmbGFncywgX3Blcm1zKSB7XG4gIHZhciBmID0ge307XG4gIHdoaWxlKGZsYWdzKXtcbiAgICBzd2l0Y2goZmxhZ3NbMV0pe1xuICAgIGNhc2UgMDogZi5yZG9ubHkgPSAxO2JyZWFrO1xuICAgIGNhc2UgMTogZi53cm9ubHkgPSAxO2JyZWFrO1xuICAgIGNhc2UgMjogZi5hcHBlbmQgPSAxO2JyZWFrO1xuICAgIGNhc2UgMzogZi5jcmVhdGUgPSAxO2JyZWFrO1xuICAgIGNhc2UgNDogZi50cnVuY2F0ZSA9IDE7YnJlYWs7XG4gICAgY2FzZSA1OiBmLmV4Y2wgPSAxOyBicmVhaztcbiAgICBjYXNlIDY6IGYuYmluYXJ5ID0gMTticmVhaztcbiAgICBjYXNlIDc6IGYudGV4dCA9IDE7YnJlYWs7XG4gICAgY2FzZSA4OiBmLm5vbmJsb2NrID0gMTticmVhaztcbiAgICB9XG4gICAgZmxhZ3M9ZmxhZ3NbMl07XG4gIH1cbiAgaWYoZi5yZG9ubHkgJiYgZi53cm9ubHkpXG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IobmFtZS50b1N0cmluZygpICsgXCIgOiBmbGFncyBPcGVuX3Jkb25seSBhbmQgT3Blbl93cm9ubHkgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xuICBpZihmLnRleHQgJiYgZi5iaW5hcnkpXG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IobmFtZS50b1N0cmluZygpICsgXCIgOiBmbGFncyBPcGVuX3RleHQgYW5kIE9wZW5fYmluYXJ5IGFyZSBub3QgY29tcGF0aWJsZVwiKTtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgdmFyIGZpbGUgPSByb290LmRldmljZS5vcGVuKHJvb3QucmVzdCxmKTtcbiAgdmFyIGlkeCA9IGNhbWxfZ2xvYmFsX2RhdGEuZmRfbGFzdF9pZHg/Y2FtbF9nbG9iYWxfZGF0YS5mZF9sYXN0X2lkeDowO1xuICByZXR1cm4gY2FtbF9zeXNfb3Blbl9pbnRlcm5hbCAoaWR4KzEsY2FtbF9zdGRfb3V0cHV0LGZpbGUsZik7XG59XG5jYW1sX3N5c19vcGVuX2ludGVybmFsKDAsY2FtbF9zdGRfb3V0cHV0LCBuZXcgTWxGYWtlRmlsZShjYW1sX2NyZWF0ZV9ieXRlcygwKSkpOyAvL3N0ZGluXG5jYW1sX3N5c19vcGVuX2ludGVybmFsKDEsanNfcHJpbnRfc3Rkb3V0LCBuZXcgTWxGYWtlRmlsZShjYW1sX2NyZWF0ZV9ieXRlcygwKSkpOyAvL3N0ZG91dFxuY2FtbF9zeXNfb3Blbl9pbnRlcm5hbCgyLGpzX3ByaW50X3N0ZGVyciwgbmV3IE1sRmFrZUZpbGUoY2FtbF9jcmVhdGVfYnl0ZXMoMCkpKTsgLy9zdGRlcnJcblxuXG4vLyBvY2FtbCBDaGFubmVsc1xuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9jaGFubmVsX25hbWVcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZSgpIHtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jaGFubmVsc1xudmFyIGNhbWxfbWxfY2hhbm5lbHMgPSBuZXcgQXJyYXkoKTtcblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRfY2hhbm5lbHNfbGlzdFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9vdXRfY2hhbm5lbHNfbGlzdCAoKSB7XG4gIHZhciBsID0gMDtcbiAgZm9yKHZhciBjID0gMDsgYyA8IGNhbWxfbWxfY2hhbm5lbHMubGVuZ3RoOyBjKyspe1xuICAgIGlmKGNhbWxfbWxfY2hhbm5lbHNbY10gJiYgY2FtbF9tbF9jaGFubmVsc1tjXS5vcGVuZWQgJiYgY2FtbF9tbF9jaGFubmVsc1tjXS5vdXQpXG4gICAgICBsPVswLGNhbWxfbWxfY2hhbm5lbHNbY10uZmQsbF07XG4gIH1cbiAgcmV0dXJuIGw7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3Jfb3V0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX2dsb2JhbF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3Jfb3V0IChmZCkge1xuICB2YXIgZGF0YSA9IGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2ZkXTtcbiAgaWYoZGF0YS5mbGFncy5yZG9ubHkpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiZmQgXCIrIGZkICsgXCIgaXMgcmVhZG9ubHlcIik7XG4gIHZhciBjaGFubmVsID0ge1xuICAgIGZpbGU6ZGF0YS5maWxlLFxuICAgIG9mZnNldDpkYXRhLm9mZnNldCxcbiAgICBmZDpmZCxcbiAgICBvcGVuZWQ6dHJ1ZSxcbiAgICBvdXQ6dHJ1ZSxcbiAgICBidWZmZXI6XCJcIlxuICB9O1xuICBjYW1sX21sX2NoYW5uZWxzW2NoYW5uZWwuZmRdPWNoYW5uZWw7XG4gIHJldHVybiBjaGFubmVsLmZkO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pblxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YSxjYW1sX3N5c19vcGVuLGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pbiAoZmQpICB7XG4gIHZhciBkYXRhID0gY2FtbF9nbG9iYWxfZGF0YS5mZHNbZmRdO1xuICBpZihkYXRhLmZsYWdzLndyb25seSkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJmZCBcIisgZmQgKyBcIiBpcyB3cml0ZW9ubHlcIik7XG5cbiAgdmFyIGNoYW5uZWwgPSB7XG4gICAgZmlsZTpkYXRhLmZpbGUsXG4gICAgb2Zmc2V0OmRhdGEub2Zmc2V0LFxuICAgIGZkOmZkLFxuICAgIG9wZW5lZDp0cnVlLFxuICAgIG91dDogZmFsc2UsXG4gICAgcmVmaWxsOm51bGxcbiAgfTtcbiAgY2FtbF9tbF9jaGFubmVsc1tjaGFubmVsLmZkXT1jaGFubmVsO1xuICByZXR1cm4gY2hhbm5lbC5mZDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9iaW5hcnlfbW9kZVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YSwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9zZXRfYmluYXJ5X21vZGUoY2hhbmlkLG1vZGUpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgdmFyIGRhdGEgPSBjYW1sX2dsb2JhbF9kYXRhLmZkc1tjaGFuLmZkXTtcbiAgZGF0YS5mbGFncy50ZXh0ID0gIW1vZGVcbiAgZGF0YS5mbGFncy5iaW5hcnkgPSBtb2RlXG4gIHJldHVybiAwO1xufVxuXG4vL0lucHV0IGZyb20gaW5fY2hhbm5lbFxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2Nsb3NlX2NoYW5uZWxcbi8vUmVxdWlyZXM6IGNhbWxfbWxfZmx1c2gsIGNhbWxfbWxfY2hhbm5lbHNcbi8vUmVxdWlyZXM6IGNhbWxfc3lzX2Nsb3NlXG5mdW5jdGlvbiBjYW1sX21sX2Nsb3NlX2NoYW5uZWwgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICBjaGFuLm9wZW5lZCA9IGZhbHNlO1xuICBjaGFuLmZpbGUuY2xvc2UoKTtcbiAgY2FtbF9zeXNfY2xvc2UoY2hhbi5mZClcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2NoYW5uZWxfc2l6ZShjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHJldHVybiBjaGFuLmZpbGUubGVuZ3RoKCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbF9zaXplXzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0LGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfY2hhbm5lbF9zaXplXzY0KGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfZmxvYXQoY2hhbi5maWxlLmxlbmd0aCAoKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2NoYW5uZWxfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX21sX3NldF9jaGFubmVsX291dHB1dChjaGFuaWQsZikge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgY2FtbF9nbG9iYWxfZGF0YS5mZHNbY2hhbi5mZF0ub3V0cHV0ID0gZjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2NoYW5uZWxfcmVmaWxsXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX21sX3NldF9jaGFubmVsX3JlZmlsbChjaGFuaWQsZikge1xuICBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ucmVmaWxsID0gZjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcmVmaWxsX2lucHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9tbF9yZWZpbGxfaW5wdXQgKGNoYW4pIHtcbiAgdmFyIHN0ciA9IGNoYW4ucmVmaWxsKCk7XG4gIHZhciBzdHJfbGVuID0gY2FtbF9tbF9ieXRlc19sZW5ndGgoc3RyKTtcbiAgaWYgKHN0cl9sZW4gPT0gMCkgY2hhbi5yZWZpbGwgPSBudWxsO1xuICBjaGFuLmZpbGUud3JpdGUoY2hhbi5maWxlLmxlbmd0aCgpLCBzdHIsIDAsIHN0cl9sZW4pO1xuICByZXR1cm4gc3RyX2xlbjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX3JlZmlsbF9pbnB1dCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0IChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGlmIChjaGFuLnJlZmlsbCA9PSBudWxsKSByZXR1cm47XG4gIGlmIChjaGFuLmZpbGUubGVuZ3RoKCkgIT0gY2hhbi5vZmZzZXQpIHJldHVybjtcbiAgY2FtbF9tbF9yZWZpbGxfaW5wdXQgKGNoYW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX3JlZmlsbF9pbnB1dCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dCAoY2hhbmlkLCBzLCBpLCBsKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICB2YXIgbDIgPSBjaGFuLmZpbGUubGVuZ3RoKCkgLSBjaGFuLm9mZnNldDtcbiAgaWYgKGwyID09IDAgJiYgY2hhbi5yZWZpbGwgIT0gbnVsbCkgbDIgPSBjYW1sX21sX3JlZmlsbF9pbnB1dChjaGFuKTtcbiAgaWYgKGwyIDwgbCkgbCA9IGwyO1xuICBjaGFuLmZpbGUucmVhZChjaGFuLm9mZnNldCwgcywgaSwgbCk7XG4gIGNoYW4ub2Zmc2V0ICs9IGw7XG4gIHJldHVybiBsO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX21hcnNoYWxfZGF0YV9zaXplLCBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fc3RyaW5nLCBjYW1sX2NyZWF0ZV9ieXRlcywgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZSAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuXG4gIHZhciBidWYgPSBjYW1sX2NyZWF0ZV9ieXRlcyg4KTtcbiAgY2hhbi5maWxlLnJlYWQoY2hhbi5vZmZzZXQsYnVmLDAsOCk7XG5cbiAgLy8gSGVhZGVyIGlzIDIwIGJ5dGVzXG4gIHZhciBsZW4gPSBjYW1sX21hcnNoYWxfZGF0YV9zaXplIChidWYsIDApICsgMjA7XG5cbiAgdmFyIGJ1ZiA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbik7XG4gIGNoYW4uZmlsZS5yZWFkKGNoYW4ub2Zmc2V0LGJ1ZiwwLGxlbik7XG5cbiAgdmFyIG9mZnNldCA9IFswXTtcbiAgdmFyIHJlcyA9IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmcoYnVmLCBvZmZzZXQpO1xuICBjaGFuLm9mZnNldCA9IGNoYW4ub2Zmc2V0ICsgb2Zmc2V0WzBdO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0X2NoYXJcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUsIGNhbWxfYXJyYXlfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dF9jaGFyIChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dChjaGFuaWQpO1xuICBpZiAoY2hhbi5vZmZzZXQgPj0gY2hhbi5maWxlLmxlbmd0aCgpKVxuICAgIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUoKTtcbiAgdmFyIHJlcyA9IGNoYW4uZmlsZS5yZWFkX29uZShjaGFuLm9mZnNldCk7XG4gIGNoYW4ub2Zmc2V0Kys7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRfaW50XG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX21sX3JlZmlsbF9pbnB1dCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dF9pbnQgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgdmFyIGZpbGUgPSBjaGFuLmZpbGU7XG4gIHdoaWxlICgoY2hhbi5vZmZzZXQgKyAzKSA+PSBmaWxlLmxlbmd0aCgpKSB7XG4gICAgdmFyIGwgPSBjYW1sX21sX3JlZmlsbF9pbnB1dChjaGFuKTtcbiAgICBpZiAobCA9PSAwKSBjYW1sX3JhaXNlX2VuZF9vZl9maWxlKCk7XG4gIH1cbiAgdmFyIG8gPSBjaGFuLm9mZnNldDtcbiAgdmFyIHIgPShmaWxlLnJlYWRfb25lKG8gICkgPDwgMjQpXG4gICAgICB8ICAoZmlsZS5yZWFkX29uZShvKzEpIDw8IDE2KVxuICAgICAgfCAgKGZpbGUucmVhZF9vbmUobysyKSA8PCA4KVxuICAgICAgfCAgKGZpbGUucmVhZF9vbmUobyszKSk7XG4gIGNoYW4ub2Zmc2V0Kz00O1xuICByZXR1cm4gcjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZWVrX2luXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9zZWVrX2luKGNoYW5pZCxwb3Mpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYgKGNoYW4ucmVmaWxsICE9IG51bGwpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiSWxsZWdhbCBzZWVrXCIpO1xuICBjaGFuLm9mZnNldCA9IHBvcztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19pbl82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19mbG9hdCwgY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19pbl82NChjaGFuaWQscG9zKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGlmIChjaGFuLnJlZmlsbCAhPSBudWxsKSBjYW1sX3JhaXNlX3N5c19lcnJvcihcIklsbGVnYWwgc2Vla1wiKTtcbiAgY2hhbi5vZmZzZXQgPSBjYW1sX2ludDY0X3RvX2Zsb2F0KHBvcyk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19pblxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9wb3NfaW4oY2hhbmlkKSB7cmV0dXJuIGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXR9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX2luXzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3Bvc19pbl82NChjaGFuaWQpIHtyZXR1cm4gY2FtbF9pbnQ2NF9vZl9mbG9hdChjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ub2Zmc2V0KX1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dF9zY2FuX2xpbmVcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dF9zY2FuX2xpbmUoY2hhbmlkKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dChjaGFuaWQpO1xuICB2YXIgcCA9IGNoYW4ub2Zmc2V0O1xuICB2YXIgbGVuID0gY2hhbi5maWxlLmxlbmd0aCgpO1xuICBpZihwID49IGxlbikgeyByZXR1cm4gMDt9XG4gIHdoaWxlKHRydWUpIHtcbiAgICBpZihwID49IGxlbikgcmV0dXJuIC0gKHAgLSBjaGFuLm9mZnNldCk7XG4gICAgaWYoY2hhbi5maWxlLnJlYWRfb25lKHApID09IDEwKSByZXR1cm4gcCAtIGNoYW4ub2Zmc2V0ICsgMTtcbiAgICBwKys7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9mbHVzaFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfZ2xvYmFsX2RhdGEsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfZmx1c2ggKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYoISBjaGFuLm9wZW5lZCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJDYW5ub3QgZmx1c2ggYSBjbG9zZWQgY2hhbm5lbFwiKTtcbiAgaWYoIWNoYW4uYnVmZmVyIHx8IGNoYW4uYnVmZmVyID09IFwiXCIpIHJldHVybiAwO1xuICBpZihjaGFuLmZkXG4gICAgICYmIGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2NoYW4uZmRdXG4gICAgICYmIGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2NoYW4uZmRdLm91dHB1dCkge1xuICAgIHZhciBvdXRwdXQgPSBjYW1sX2dsb2JhbF9kYXRhLmZkc1tjaGFuLmZkXS5vdXRwdXQ7XG4gICAgc3dpdGNoKG91dHB1dC5sZW5ndGgpe1xuICAgIGNhc2UgMjogb3V0cHV0KGNoYW5pZCxjaGFuLmJ1ZmZlcik7YnJlYWs7XG4gICAgZGVmYXVsdDogb3V0cHV0KGNoYW4uYnVmZmVyKVxuICAgIH07XG4gIH1cbiAgY2hhbi5idWZmZXIgPSBcIlwiO1xuICByZXR1cm4gMDtcbn1cblxuLy9vdXRwdXQgdG8gb3V0X2NoYW5uZWxcblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfZmx1c2gsY2FtbF9tbF9ieXRlc19sZW5ndGhcbi8vUmVxdWlyZXM6IGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX2JsaXRfYnl0ZXMsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX21sX291dHB1dF9ieXRlcyhjaGFuaWQsYnVmZmVyLG9mZnNldCxsZW4pIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGlmKCEgY2hhbi5vcGVuZWQpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiQ2Fubm90IG91dHB1dCB0byBhIGNsb3NlZCBjaGFubmVsXCIpO1xuICB2YXIgc3RyaW5nO1xuICBpZihvZmZzZXQgPT0gMCAmJiBjYW1sX21sX2J5dGVzX2xlbmd0aChidWZmZXIpID09IGxlbilcbiAgICBzdHJpbmcgPSBidWZmZXI7XG4gIGVsc2Uge1xuICAgIHN0cmluZyA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbik7XG4gICAgY2FtbF9ibGl0X2J5dGVzKGJ1ZmZlcixvZmZzZXQsc3RyaW5nLDAsbGVuKTtcbiAgfVxuICB2YXIganNzdHJpbmcgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHN0cmluZyk7XG4gIHZhciBpZCA9IGpzc3RyaW5nLmxhc3RJbmRleE9mKFwiXFxuXCIpO1xuICBpZihpZCA8IDApXG4gICAgY2hhbi5idWZmZXIrPWpzc3RyaW5nO1xuICBlbHNlIHtcbiAgICBjaGFuLmJ1ZmZlcis9anNzdHJpbmcuc3Vic3RyKDAsaWQrMSk7XG4gICAgY2FtbF9tbF9mbHVzaCAoY2hhbmlkKTtcbiAgICBjaGFuLmJ1ZmZlciArPSBqc3N0cmluZy5zdWJzdHIoaWQrMSk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dF9ieXRlc1xuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXQoY2hhbmlkLGJ1ZmZlcixvZmZzZXQsbGVuKXtcbiAgcmV0dXJuIGNhbWxfbWxfb3V0cHV0X2J5dGVzKGNoYW5pZCxidWZmZXIsb2Zmc2V0LGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0X2NoYXJcbi8vUmVxdWlyZXM6IGNhbWxfbWxfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX25ld19zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0X2NoYXIgKGNoYW5pZCxjKSB7XG4gIHZhciBzID0gY2FtbF9uZXdfc3RyaW5nKFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICBjYW1sX21sX291dHB1dChjaGFuaWQscywwLDEpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZywgY2FtbF9tbF9vdXRwdXQsY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX291dHB1dF92YWx1ZSAoY2hhbmlkLHYsZmxhZ3MpIHtcbiAgdmFyIHMgPSBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcodiwgZmxhZ3MpO1xuICBjYW1sX21sX291dHB1dChjaGFuaWQscywwLGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSk7XG4gIHJldHVybiAwO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19vdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfbWxfZmx1c2hcbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19vdXQoY2hhbmlkLHBvcyl7XG4gIGNhbWxfbWxfZmx1c2goY2hhbmlkKTtcbiAgY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldCA9IHBvcztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19vdXRfNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fZmxvYXQsIGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfbWxfZmx1c2hcbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19vdXRfNjQoY2hhbmlkLHBvcyl7XG4gIGNhbWxfbWxfZmx1c2goY2hhbmlkKTtcbiAgY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldCA9IGNhbWxfaW50NjRfdG9fZmxvYXQocG9zKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX291dFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVscywgY2FtbF9tbF9mbHVzaFxuZnVuY3Rpb24gY2FtbF9tbF9wb3Nfb3V0KGNoYW5pZCkge1xuICBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gIHJldHVybiBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ub2Zmc2V0XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX291dF82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9mbG9hdCwgY2FtbF9tbF9jaGFubmVscywgY2FtbF9tbF9mbHVzaFxuZnVuY3Rpb24gY2FtbF9tbF9wb3Nfb3V0XzY0KGNoYW5pZCkge1xuICBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2Zsb2F0IChjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ub2Zmc2V0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRfaW50XG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0X2ludCAoY2hhbmlkLGkpIHtcbiAgdmFyIGFyciA9IFsoaT4+MjQpICYgMHhGRiwoaT4+MTYpICYgMHhGRiwoaT4+OCkgJiAweEZGLGkgJiAweEZGIF07XG4gIHZhciBzID0gY2FtbF9zdHJpbmdfb2ZfYXJyYXkoYXJyKTtcbiAgY2FtbF9tbF9vdXRwdXQoY2hhbmlkLHMsMCw0KTtcbiAgcmV0dXJuIDBcbn1cbiIsIlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX21pbm9yXG5mdW5jdGlvbiBjYW1sX2djX21pbm9yKCl7IHJldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9nY19tYWpvclxuZnVuY3Rpb24gY2FtbF9nY19tYWpvcigpeyByZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfZnVsbF9tYWpvclxuZnVuY3Rpb24gY2FtbF9nY19mdWxsX21ham9yKCl7IHJldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9nY19jb21wYWN0aW9uXG5mdW5jdGlvbiBjYW1sX2djX2NvbXBhY3Rpb24oKXsgcmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2djX2NvdW50ZXJzXG5mdW5jdGlvbiBjYW1sX2djX2NvdW50ZXJzKCkgeyByZXR1cm4gWzI1NCwwLDAsMF0gfVxuLy9Qcm92aWRlczogY2FtbF9nY19xdWlja19zdGF0XG5mdW5jdGlvbiBjYW1sX2djX3F1aWNrX3N0YXQoKXtcbiAgcmV0dXJuIFswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDBdXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2djX3N0YXRcbmZ1bmN0aW9uIGNhbWxfZ2Nfc3RhdCgpIHtcbiAgcmV0dXJuIFswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDBdXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2Nfc2V0XG5mdW5jdGlvbiBjYW1sX2djX3NldChfY29udHJvbCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9nY19nZXRcbmZ1bmN0aW9uIGNhbWxfZ2NfZ2V0KCl7XG4gIHJldHVybiBbMCwwLDAsMCwwLDAsMCwwLDBdXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWVtcHJvZl9zZXRcbmZ1bmN0aW9uIGNhbWxfbWVtcHJvZl9zZXQoX2NvbnRyb2wpIHtcbiAgcmV0dXJuIDA7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZCwgQW5keSBSYXlcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cbi8vXG4vLyBCaWdhcnJheS5cbi8vXG4vLyAtIGFsbCBiaWdhcnJheSB0eXBlcyBpbmNsdWRpbmcgSW50NjQgYW5kIENvbXBsZXguXG4vLyAtIGZvcnRyYW4gKyBjIGxheW91dHNcbi8vIC0gc3ViL3NsaWNlL3Jlc2hhcGVcbi8vIC0gcmV0YWluIGZhc3QgcGF0aCBmb3IgMWQgYXJyYXkgYWNjZXNzXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfaW5pdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9iYV9pbml0KCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2dldF9zaXplKGRpbXMpIHtcbiAgdmFyIG5fZGltcyA9IGRpbXMubGVuZ3RoO1xuICB2YXIgc2l6ZSA9IDE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbl9kaW1zOyBpKyspIHtcbiAgICBpZiAoZGltc1tpXSA8IDApXG4gICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5jcmVhdGU6IG5lZ2F0aXZlIGRpbWVuc2lvblwiKTtcbiAgICBzaXplID0gc2l6ZSAqIGRpbXNbaV07XG4gIH1cbiAgcmV0dXJuIHNpemU7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoa2luZCl7XG4gIHN3aXRjaChraW5kKXtcbiAgY2FzZSA3OiBjYXNlIDEwOiBjYXNlIDExOiByZXR1cm4gMjtcbiAgZGVmYXVsdDogcmV0dXJuIDE7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jcmVhdGVfYnVmZmVyXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfY3JlYXRlX2J1ZmZlcihraW5kLCBzaXplKXtcbiAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgdmFyIHZpZXc7XG4gIHN3aXRjaChraW5kKXtcbiAgY2FzZSAwOiAgdmlldyA9IGcuRmxvYXQzMkFycmF5OyBicmVhaztcbiAgY2FzZSAxOiAgdmlldyA9IGcuRmxvYXQ2NEFycmF5OyBicmVhaztcbiAgY2FzZSAyOiAgdmlldyA9IGcuSW50OEFycmF5OyBicmVhaztcbiAgY2FzZSAzOiAgdmlldyA9IGcuVWludDhBcnJheTsgYnJlYWs7XG4gIGNhc2UgNDogIHZpZXcgPSBnLkludDE2QXJyYXk7IGJyZWFrO1xuICBjYXNlIDU6ICB2aWV3ID0gZy5VaW50MTZBcnJheTsgYnJlYWs7XG4gIGNhc2UgNjogIHZpZXcgPSBnLkludDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDc6ICB2aWV3ID0gZy5JbnQzMkFycmF5OyBicmVhaztcbiAgY2FzZSA4OiAgdmlldyA9IGcuSW50MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgOTogIHZpZXcgPSBnLkludDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDEwOiB2aWV3ID0gZy5GbG9hdDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDExOiB2aWV3ID0gZy5GbG9hdDY0QXJyYXk7IGJyZWFrO1xuICBjYXNlIDEyOiB2aWV3ID0gZy5VaW50OEFycmF5OyBicmVhaztcbiAgfVxuICBpZiAoIXZpZXcpIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmNyZWF0ZTogdW5zdXBwb3J0ZWQga2luZFwiKTtcbiAgdmFyIGRhdGEgPSBuZXcgdmlldyhzaXplICogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChraW5kKSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vL1Byb3ZpZGVzOiBNbF9CaWdhcnJheVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2NyZWF0ZV9sb19oaSwgY2FtbF9pbnQ2NF9oaTMyLCBjYW1sX2ludDY0X2xvMzJcbmZ1bmN0aW9uIE1sX0JpZ2FycmF5IChraW5kLCBsYXlvdXQsIGRpbXMsIGJ1ZmZlcikge1xuXG4gIHRoaXMua2luZCAgID0ga2luZCA7XG4gIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICB0aGlzLmRpbXMgICA9IGRpbXM7XG4gIHRoaXMuZGF0YSA9IGJ1ZmZlcjtcbn1cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLmNhbWxfY3VzdG9tID0gXCJfYmlnYXJyYXlcIjtcblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLm9mZnNldCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgdmFyIG9mcyA9IDA7XG4gIGlmKHR5cGVvZiBhcmcgPT09IFwibnVtYmVyXCIpIGFyZyA9IFthcmddO1xuICBpZiAoISAoYXJnIGluc3RhbmNlb2YgQXJyYXkpKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJiaWdhcnJheS5qczogaW52YWxpZCBvZmZzZXRcIik7XG4gIGlmICh0aGlzLmRpbXMubGVuZ3RoICE9IGFyZy5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuZ2V0L3NldDogYmFkIG51bWJlciBvZiBkaW1lbnNpb25zXCIpO1xuICBpZih0aGlzLmxheW91dCA9PSAwIC8qIGNfbGF5b3V0ICovKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRpbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhcmdbaV0gPCAwIHx8IGFyZ1tpXSA+PSB0aGlzLmRpbXNbaV0pXG4gICAgICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgICAgIG9mcyA9IChvZnMgKiB0aGlzLmRpbXNbaV0pICsgYXJnW2ldO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5kaW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAoYXJnW2ldIDwgMSB8fCBhcmdbaV0gPiB0aGlzLmRpbXNbaV0pe1xuICAgICAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gICAgICB9XG4gICAgICBvZnMgPSAob2ZzICogdGhpcy5kaW1zW2ldKSArIChhcmdbaV0gLSAxKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9mcztcbn1cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZnMpIHtcbiAgc3dpdGNoKHRoaXMua2luZCl7XG4gIGNhc2UgNzpcbiAgICAvLyBJbnQ2NFxuICAgIHZhciBsID0gdGhpcy5kYXRhW29mcyAqIDIgKyAwXTtcbiAgICB2YXIgaCA9IHRoaXMuZGF0YVtvZnMgKiAyICsgMV07XG4gICAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpKGwsaCk7XG4gIGNhc2UgMTA6IGNhc2UgMTE6XG4gICAgLy8gQ29tcGxleDMyLCBDb21wbGV4NjRcbiAgICB2YXIgciA9IHRoaXMuZGF0YVtvZnMgKiAyICsgMF07XG4gICAgdmFyIGkgPSB0aGlzLmRhdGFbb2ZzICogMiArIDFdO1xuICAgIHJldHVybiBbMjU0LCByLCBpXTtcbiAgZGVmYXVsdDpcbiAgICByZXR1cm4gdGhpcy5kYXRhW29mc11cbiAgfVxufVxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG9mcyx2KSB7XG4gIHN3aXRjaCh0aGlzLmtpbmQpe1xuICBjYXNlIDc6XG4gICAgLy8gSW50NjRcbiAgICB0aGlzLmRhdGFbb2ZzICogMiArIDBdID0gY2FtbF9pbnQ2NF9sbzMyKHYpO1xuICAgIHRoaXMuZGF0YVtvZnMgKiAyICsgMV0gPSBjYW1sX2ludDY0X2hpMzIodik7XG4gICAgYnJlYWs7XG4gIGNhc2UgMTA6IGNhc2UgMTE6XG4gICAgLy8gQ29tcGxleDMyLCBDb21wbGV4NjRcbiAgICB0aGlzLmRhdGFbb2ZzICogMiArIDBdID0gdlsxXTtcbiAgICB0aGlzLmRhdGFbb2ZzICogMiArIDFdID0gdlsyXTtcbiAgICBicmVhaztcbiAgZGVmYXVsdDpcbiAgICB0aGlzLmRhdGFbb2ZzXSA9IHY7XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICh2KSB7XG4gIHN3aXRjaCh0aGlzLmtpbmQpe1xuICBjYXNlIDc6XG4gICAgLy8gSW50NjRcbiAgICB2YXIgYSA9IGNhbWxfaW50NjRfbG8zMih2KTtcbiAgICB2YXIgYiA9IGNhbWxfaW50NjRfaGkzMih2KTtcbiAgICBpZihhID09IGIpe1xuICAgICAgdGhpcy5kYXRhLmZpbGwoYSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZm9yKHZhciBpID0gMDsgaTx0aGlzLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgICB0aGlzLmRhdGFbaV0gPSAoaSUyID09IDApID8gYSA6IGI7XG4gICAgICB9XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDEwOiBjYXNlIDExOlxuICAgIC8vIENvbXBsZXgzMiwgQ29tcGxleDY0XG4gICAgdmFyIGltID0gdlsxXTtcbiAgICB2YXIgcmUgPSB2WzJdO1xuICAgIGlmKGltID09IHJlKXtcbiAgICAgIHRoaXMuZGF0YS5maWxsKGltKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpPHRoaXMuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHRoaXMuZGF0YVtpXSA9IChpJTIgPT0gMCkgPyBpbSA6IHJlO1xuICAgICAgfVxuICAgIH1cbiAgICBicmVhaztcbiAgZGVmYXVsdDpcbiAgICB0aGlzLmRhdGEuZmlsbCh2KTtcbiAgICBicmVhaztcbiAgfVxufVxuXG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKGIsIHRvdGFsKSB7XG4gIGlmICh0aGlzLmxheW91dCAhPSBiLmxheW91dCB8fCB0aGlzLmtpbmQgIT0gYi5raW5kKSB7XG4gICAgdmFyIGsxID0gdGhpcy5raW5kIHwgKHRoaXMubGF5b3V0IDw8IDgpO1xuICAgIHZhciBrMiA9ICAgIGIua2luZCB8IChiLmxheW91dCA8PCA4KTtcbiAgICByZXR1cm4gazIgLSBrMTtcbiAgfVxuICBpZiAodGhpcy5kaW1zLmxlbmd0aCAhPSBiLmRpbXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGIuZGltcy5sZW5ndGggLSB0aGlzLmRpbXMubGVuZ3RoO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kaW1zLmxlbmd0aDsgaSsrKVxuICAgIGlmICh0aGlzLmRpbXNbaV0gIT0gYi5kaW1zW2ldKVxuICAgICAgcmV0dXJuICh0aGlzLmRpbXNbaV0gPCBiLmRpbXNbaV0pID8gLTEgOiAxO1xuICBzd2l0Y2ggKHRoaXMua2luZCkge1xuICBjYXNlIDA6XG4gIGNhc2UgMTpcbiAgY2FzZSAxMDpcbiAgY2FzZSAxMTpcbiAgICAvLyBGbG9hdHNcbiAgICB2YXIgeCwgeTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgeCA9IHRoaXMuZGF0YVtpXTtcbiAgICAgIHkgPSBiLmRhdGFbaV07XG4gICAgICBpZiAoeCA8IHkpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIGlmICh4ID4geSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBpZiAoeCAhPSB5KSB7XG4gICAgICAgIGlmICghdG90YWwpIHJldHVybiBOYU47XG4gICAgICAgIGlmICh4ID09IHgpIHJldHVybiAxO1xuICAgICAgICBpZiAoeSA9PSB5KSByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDc6XG4gICAgLy8gSW50NjRcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrPTIpIHtcbiAgICAgIC8vIENoZWNrIGhpZ2hlc3QgYml0cyBmaXJzdFxuICAgICAgaWYgKHRoaXMuZGF0YVtpKzFdIDwgYi5kYXRhW2krMV0pXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIGlmICh0aGlzLmRhdGFbaSsxXSA+IGIuZGF0YVtpKzFdKVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGlmICgodGhpcy5kYXRhW2ldID4+PiAwKSA8IChiLmRhdGFbaV0gPj4+IDApKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICBpZiAoKHRoaXMuZGF0YVtpXSA+Pj4gMCkgPiAoYi5kYXRhW2ldID4+PiAwKSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDI6XG4gIGNhc2UgMzpcbiAgY2FzZSA0OlxuICBjYXNlIDU6XG4gIGNhc2UgNjpcbiAgY2FzZSA4OlxuICBjYXNlIDk6XG4gIGNhc2UgMTI6XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmRhdGFbaV0gPCBiLmRhdGFbaV0pXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIGlmICh0aGlzLmRhdGFbaV0gPiBiLmRhdGFbaV0pXG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogTWxfQmlnYXJyYXlfY18xXzFcbi8vUmVxdWlyZXM6IE1sX0JpZ2FycmF5LCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIE1sX0JpZ2FycmF5X2NfMV8xKGtpbmQsIGxheW91dCwgZGltcywgYnVmZmVyKSB7XG4gIHRoaXMua2luZCAgID0ga2luZCA7XG4gIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICB0aGlzLmRpbXMgICA9IGRpbXM7XG4gIHRoaXMuZGF0YSAgID0gYnVmZmVyO1xufVxuXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUgPSBuZXcgTWxfQmlnYXJyYXkoKVxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlLm9mZnNldCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgaWYodHlwZW9mIGFyZyAhPT0gXCJudW1iZXJcIil7XG4gICAgaWYoKGFyZyBpbnN0YW5jZW9mIEFycmF5KSAmJiBhcmcubGVuZ3RoID09IDEpXG4gICAgICBhcmcgPSBhcmdbMF07XG4gICAgZWxzZSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJNbF9CaWdhcnJheV9jXzFfMS5vZmZzZXRcIik7XG4gIH1cbiAgaWYgKGFyZyA8IDAgfHwgYXJnID49IHRoaXMuZGltc1swXSlcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBhcmc7XG59XG5cbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAob2ZzKSB7XG4gIHJldHVybiB0aGlzLmRhdGFbb2ZzXTtcbn1cblxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChvZnMsdikge1xuICB0aGlzLmRhdGFbb2ZzXSA9IHY7XG4gIHJldHVybiAwXG59XG5cbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHYpIHtcbiAgdGhpcy5kYXRhLmZpbGwodik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY29tcGFyZVxuZnVuY3Rpb24gY2FtbF9iYV9jb21wYXJlKGEsYix0b3RhbCl7XG4gIHJldHVybiBhLmNvbXBhcmUoYix0b3RhbClcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG4vL1JlcXVpcmVzOiBNbF9CaWdhcnJheSwgTWxfQmlnYXJyYXlfY18xXzEsIGNhbWxfYmFfZ2V0X3NpemUsIGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSl7XG4gIHZhciBzaXplX3Blcl9lbGVtZW50ID0gY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChraW5kKTtcbiAgaWYoY2FtbF9iYV9nZXRfc2l6ZShkaW1zKSAqIHNpemVfcGVyX2VsZW1lbnQgIT0gZGF0YS5sZW5ndGgpIHtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJsZW5ndGggZG9lc24ndCBtYXRjaCBkaW1zXCIpO1xuICB9XG4gIGlmKGxheW91dCA9PSAwICYmIC8vIGNfbGF5b3V0XG4gICAgIGRpbXMubGVuZ3RoID09IDEgJiYgLy8gQXJyYXkxXG4gICAgIHNpemVfcGVyX2VsZW1lbnQgPT0gMSkgLy8gMS10by0xIG1hcHBpbmdcbiAgICByZXR1cm4gbmV3IE1sX0JpZ2FycmF5X2NfMV8xKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG4gIHJldHVybiBuZXcgTWxfQmlnYXJyYXkoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcblxufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemUsIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfYnVmZmVyXG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZShraW5kLCBsYXlvdXQsIGRpbXNfbWwpIHtcbiAgdmFyIGRpbXMgPSBjYW1sX2pzX2Zyb21fYXJyYXkoZGltc19tbCk7XG4gIHZhciBkYXRhID0gY2FtbF9iYV9jcmVhdGVfYnVmZmVyKGtpbmQsIGNhbWxfYmFfZ2V0X3NpemUoZGltcykpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY2hhbmdlX2xheW91dFxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG5mdW5jdGlvbiBjYW1sX2JhX2NoYW5nZV9sYXlvdXQoYmEsIGxheW91dCkge1xuICBpZihiYS5sYXlvdXQgPT0gbGF5b3V0KSByZXR1cm4gYmE7XG4gIHZhciBuZXdfZGltcyA9IFtdXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKSBuZXdfZGltc1tpXSA9IGJhLmRpbXNbYmEuZGltcy5sZW5ndGggLSBpIC0gMV07XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoYmEua2luZCwgbGF5b3V0LCBuZXdfZGltcywgYmEuZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfa2luZFxuZnVuY3Rpb24gY2FtbF9iYV9raW5kKGJhKSB7XG4gIHJldHVybiBiYS5raW5kO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2xheW91dFxuZnVuY3Rpb24gY2FtbF9iYV9sYXlvdXQoYmEpIHtcbiAgcmV0dXJuIGJhLmxheW91dDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9udW1fZGltc1xuZnVuY3Rpb24gY2FtbF9iYV9udW1fZGltcyhiYSkge1xuICByZXR1cm4gYmEuZGltcy5sZW5ndGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGltXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfZGltKGJhLCBpKSB7XG4gIGlmIChpIDwgMCB8fCBpID49IGJhLmRpbXMubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmRpbVwiKTtcbiAgcmV0dXJuIGJhLmRpbXNbaV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGltXzFcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZGltXG5mdW5jdGlvbiBjYW1sX2JhX2RpbV8xKGJhKSB7XG4gIHJldHVybiBjYW1sX2JhX2RpbShiYSwgMCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGltXzJcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZGltXG5mdW5jdGlvbiBjYW1sX2JhX2RpbV8yKGJhKSB7XG4gIHJldHVybiBjYW1sX2JhX2RpbShiYSwgMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGltXzNcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZGltXG5mdW5jdGlvbiBjYW1sX2JhX2RpbV8zKGJhKSB7XG4gIHJldHVybiBjYW1sX2JhX2RpbShiYSwgMik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0X2dlbmVyaWNcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfZ2VuZXJpYyhiYSwgaSkge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGNhbWxfanNfZnJvbV9hcnJheShpKSk7XG4gIHJldHVybiBiYS5nZXQob2ZzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9nZXQxNlxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9nZXQxNihiYSwgaTApIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDEgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gYmEuZ2V0KG9mcyk7XG4gIHZhciBiMiA9IGJhLmdldChvZnMgKyAxKTtcbiAgcmV0dXJuIChiMSB8IChiMiA8PCA4KSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfZ2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfZ2V0MzIoYmEsIGkwKSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyAzID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGJhLmdldChvZnMrMCk7XG4gIHZhciBiMiA9IGJhLmdldChvZnMrMSk7XG4gIHZhciBiMyA9IGJhLmdldChvZnMrMik7XG4gIHZhciBiNCA9IGJhLmdldChvZnMrMyk7XG4gIHJldHVybiAoIChiMSA8PCAwKSAgfFxuICAgICAgICAgICAoYjIgPDwgOCkgIHxcbiAgICAgICAgICAgKGIzIDw8IDE2KSB8XG4gICAgICAgICAgIChiNCA8PCAyNCkgKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9nZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9nZXQ2NChiYSwgaTApIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDcgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gYmEuZ2V0KG9mcyswKTtcbiAgdmFyIGIyID0gYmEuZ2V0KG9mcysxKTtcbiAgdmFyIGIzID0gYmEuZ2V0KG9mcysyKTtcbiAgdmFyIGI0ID0gYmEuZ2V0KG9mcyszKTtcbiAgdmFyIGI1ID0gYmEuZ2V0KG9mcys0KTtcbiAgdmFyIGI2ID0gYmEuZ2V0KG9mcys1KTtcbiAgdmFyIGI3ID0gYmEuZ2V0KG9mcys2KTtcbiAgdmFyIGI4ID0gYmEuZ2V0KG9mcys3KTtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMoW2I4LGI3LGI2LGI1LGI0LGIzLGIyLGIxXSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0XzFcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0XzEoYmEsIGkwKSB7XG4gIHJldHVybiBiYS5nZXQoYmEub2Zmc2V0KGkwKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0XzJcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0XzIoYmEsIGkwLCBpMSkge1xuICByZXR1cm4gYmEuZ2V0KGJhLm9mZnNldChbaTAsaTFdKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0XzNcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0XzMoYmEsIGkwLCBpMSwgaTIpIHtcbiAgcmV0dXJuIGJhLmdldChiYS5vZmZzZXQoW2kwLGkxLGkyXSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF9nZW5lcmljXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYmFfc2V0X2dlbmVyaWMoYmEsIGksIHYpIHtcbiAgYmEuc2V0KGJhLm9mZnNldChjYW1sX2pzX2Zyb21fYXJyYXkoaSkpLCB2KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9zZXQxNlxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9zZXQxNihiYSwgaTAsIHYpIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDEgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgYmEuc2V0KG9mcyswLCAgdiAgICAgICAgJiAweGZmKTtcbiAgYmEuc2V0KG9mcysxLCAodiA+Pj4gOCkgJiAweGZmKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfc2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfc2V0MzIoYmEsIGkwLCB2KSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyAzID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIGJhLnNldChvZnMrMCwgIHYgICAgICAgICAmIDB4ZmYpO1xuICBiYS5zZXQob2ZzKzEsICh2ID4+PiA4KSAgJiAweGZmKTtcbiAgYmEuc2V0KG9mcysyLCAodiA+Pj4gMTYpICYgMHhmZik7XG4gIGJhLnNldChvZnMrMywgKHYgPj4+IDI0KSAmIDB4ZmYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9zZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9pbnQ2NF90b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9zZXQ2NChiYSwgaTAsIHYpIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDcgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIHYgPSBjYW1sX2ludDY0X3RvX2J5dGVzKHYpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgODsgaSsrKSBiYS5zZXQob2ZzK2ksIHZbNy1pXSlcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2V0XzFcbmZ1bmN0aW9uIGNhbWxfYmFfc2V0XzEoYmEsIGkwLCB2KSB7XG4gIGJhLnNldChiYS5vZmZzZXQoaTApLCB2KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXRfMlxuZnVuY3Rpb24gY2FtbF9iYV9zZXRfMihiYSwgaTAsIGkxLCB2KSB7XG4gIGJhLnNldChiYS5vZmZzZXQoW2kwLGkxXSksIHYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXRfM1xuZnVuY3Rpb24gY2FtbF9iYV9zZXRfMyhiYSwgaTAsIGkxLCBpMiwgdikge1xuICBiYS5zZXQoYmEub2Zmc2V0KFtpMCxpMSxpMl0pLCB2KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZmlsbFxuZnVuY3Rpb24gY2FtbF9iYV9maWxsKGJhLCB2KSB7XG4gIGJhLmZpbGwodik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2JsaXRcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9ibGl0KHNyYywgZHN0KSB7XG4gIGlmIChkc3QuZGltcy5sZW5ndGggIT0gc3JjLmRpbXMubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmJsaXQ6IGRpbWVuc2lvbiBtaXNtYXRjaFwiKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkc3QuZGltcy5sZW5ndGg7IGkrKylcbiAgICBpZiAoZHN0LmRpbXNbaV0gIT0gc3JjLmRpbXNbaV0pXG4gICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5ibGl0OiBkaW1lbnNpb24gbWlzbWF0Y2hcIik7XG4gIGRzdC5kYXRhLnNldChzcmMuZGF0YSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3N1YlxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfYmFfZ2V0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfc3ViKGJhLCBvZnMsIGxlbikge1xuICB2YXIgY2hhbmdlZF9kaW07XG4gIHZhciBtdWwgPSAxO1xuICBpZiAoYmEubGF5b3V0ID09IDApIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspXG4gICAgICBtdWwgPSBtdWwgKiBiYS5kaW1zW2ldO1xuICAgIGNoYW5nZWRfZGltID0gMDtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IChiYS5kaW1zLmxlbmd0aCAtIDEpOyBpKyspXG4gICAgICBtdWwgPSBtdWwgKiBiYS5kaW1zW2ldO1xuICAgIGNoYW5nZWRfZGltID0gYmEuZGltcy5sZW5ndGggLSAxO1xuICAgIG9mcyA9IG9mcyAtIDE7XG4gIH1cbiAgaWYgKG9mcyA8IDAgfHwgbGVuIDwgMCB8fCAob2ZzICsgbGVuKSA+IGJhLmRpbXNbY2hhbmdlZF9kaW1dKXtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5zdWI6IGJhZCBzdWItYXJyYXlcIik7XG4gIH1cbiAgdmFyIG5ld19kaW1zID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKylcbiAgICBuZXdfZGltc1tpXSA9IGJhLmRpbXNbaV07XG4gIG5ld19kaW1zW2NoYW5nZWRfZGltXSA9IGxlbjtcbiAgbXVsICo9IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoYmEua2luZCk7XG4gIHZhciBuZXdfZGF0YSA9IGJhLmRhdGEuc3ViYXJyYXkob2ZzICogbXVsLCAob2ZzICsgbGVuKSAqIG11bCk7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoYmEua2luZCwgYmEubGF5b3V0LCBuZXdfZGltcywgbmV3X2RhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NsaWNlXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXksIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2dldF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG5mdW5jdGlvbiBjYW1sX2JhX3NsaWNlKGJhLCB2aW5kKSB7XG4gIHZpbmQgPSBjYW1sX2pzX2Zyb21fYXJyYXkodmluZCk7XG4gIHZhciBudW1faW5kcyA9IHZpbmQubGVuZ3RoO1xuICB2YXIgaW5kZXggPSBbXTtcbiAgdmFyIHN1Yl9kaW1zID0gW107XG4gIHZhciBvZnM7XG5cbiAgaWYgKG51bV9pbmRzID4gYmEuZGltcy5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuc2xpY2U6IHRvbyBtYW55IGluZGljZXNcIik7XG5cbiAgLy8gQ29tcHV0ZSBvZmZzZXQgYW5kIGNoZWNrIGJvdW5kc1xuICBpZiAoYmEubGF5b3V0ID09IDApIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9pbmRzOyBpKyspXG4gICAgICBpbmRleFtpXSA9IHZpbmRbaV07XG4gICAgZm9yICg7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKVxuICAgICAgaW5kZXhbaV0gPSAwO1xuICAgIHN1Yl9kaW1zID0gYmEuZGltcy5zbGljZShudW1faW5kcyk7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1faW5kczsgaSsrKVxuICAgICAgaW5kZXhbYmEuZGltcy5sZW5ndGggLSBudW1faW5kcyArIGldID0gdmluZFtpXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoIC0gbnVtX2luZHM7IGkrKylcbiAgICAgIGluZGV4W2ldID0gMTtcbiAgICBzdWJfZGltcyA9IGJhLmRpbXMuc2xpY2UoMCwgYmEuZGltcy5sZW5ndGggLSBudW1faW5kcyk7XG4gIH1cbiAgb2ZzID0gYmEub2Zmc2V0KGluZGV4KTtcbiAgdmFyIHNpemUgPSBjYW1sX2JhX2dldF9zaXplKHN1Yl9kaW1zKTtcbiAgdmFyIHNpemVfcGVyX2VsZW1lbnQgPSBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGJhLmtpbmQpO1xuICB2YXIgbmV3X2RhdGEgPSBiYS5kYXRhLnN1YmFycmF5KG9mcyAqIHNpemVfcGVyX2VsZW1lbnQsIChvZnMgKyBzaXplKSAqIHNpemVfcGVyX2VsZW1lbnQpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGJhLmtpbmQsIGJhLmxheW91dCwgc3ViX2RpbXMsIG5ld19kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9yZXNoYXBlXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXksIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2JhX2dldF9zaXplXG5mdW5jdGlvbiBjYW1sX2JhX3Jlc2hhcGUoYmEsIHZpbmQpIHtcbiAgdmluZCA9IGNhbWxfanNfZnJvbV9hcnJheSh2aW5kKTtcbiAgdmFyIG5ld19kaW0gPSBbXTtcbiAgdmFyIG51bV9kaW1zID0gdmluZC5sZW5ndGg7XG5cbiAgaWYgKG51bV9kaW1zIDwgMCB8fCBudW1fZGltcyA+IDE2KXtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5yZXNoYXBlOiBiYWQgbnVtYmVyIG9mIGRpbWVuc2lvbnNcIik7XG4gIH1cbiAgdmFyIG51bV9lbHRzID0gMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZGltczsgaSsrKSB7XG4gICAgbmV3X2RpbVtpXSA9IHZpbmRbaV07XG4gICAgaWYgKG5ld19kaW1baV0gPCAwKVxuICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkucmVzaGFwZTogbmVnYXRpdmUgZGltZW5zaW9uXCIpO1xuICAgIG51bV9lbHRzID0gbnVtX2VsdHMgKiBuZXdfZGltW2ldO1xuICB9XG5cbiAgdmFyIHNpemUgPSBjYW1sX2JhX2dldF9zaXplKGJhLmRpbXMpO1xuICAvLyBDaGVjayB0aGF0IHNpemVzIGFncmVlXG4gIGlmIChudW1fZWx0cyAhPSBzaXplKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnJlc2hhcGU6IHNpemUgbWlzbWF0Y2hcIik7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoYmEua2luZCwgYmEubGF5b3V0LCBuZXdfZGltLCBiYS5kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXJpYWxpemVcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCwgY2FtbF9pbnQ2NF90b19ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0XG5mdW5jdGlvbiBjYW1sX2JhX3NlcmlhbGl6ZSh3cml0ZXIsIGJhLCBzeikge1xuICB3cml0ZXIud3JpdGUoMzIsIGJhLmRpbXMubGVuZ3RoKTtcbiAgd3JpdGVyLndyaXRlKDMyLCAoYmEua2luZCB8IChiYS5sYXlvdXQgPDwgOCkpKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspIHdyaXRlci53cml0ZSgzMixiYS5kaW1zW2ldKTtcbiAgc3dpdGNoKGJhLmtpbmQpe1xuICBjYXNlIDI6ICAvL0ludDhBcnJheVxuICBjYXNlIDM6ICAvL1VpbnQ4QXJyYXlcbiAgY2FzZSAxMjogLy9VaW50OEFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgd3JpdGVyLndyaXRlKDgsIGJhLmRhdGFbaV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA0OiAgLy8gSW50MTZBcnJheVxuICBjYXNlIDU6ICAvLyBVaW50MTZBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHdyaXRlci53cml0ZSgxNiwgYmEuZGF0YVtpXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDY6ICAvLyBJbnQzMkFycmF5IChpbnQzMilcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB3cml0ZXIud3JpdGUoMzIsIGJhLmRhdGFbaV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA4OiAgLy8gSW50MzJBcnJheSAoaW50KVxuICBjYXNlIDk6ICAvLyBJbnQzMkFycmF5IChuYXRpdmVpbnQpXG4gICAgd3JpdGVyLndyaXRlKDgsMCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNzogIC8vIEludDMyQXJyYXkgKGludDY0KVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aCAvIDI7IGkrKyl7XG4gICAgICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoYmEuZ2V0KGkpKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB3cml0ZXIud3JpdGUgKDgsIGJbal0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxOiAgLy8gRmxvYXQ2NEFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdChiYS5nZXQoaSkpKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB3cml0ZXIud3JpdGUgKDgsIGJbal0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAwOiAgLy8gRmxvYXQzMkFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgdmFyIGIgPSBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQoYmEuZ2V0KGkpKTtcbiAgICAgIHdyaXRlci53cml0ZSgzMiwgYik7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDEwOiAvLyBGbG9hdDMyQXJyYXkgKGNvbXBsZXgzMilcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGggLyAyOyBpKyspe1xuICAgICAgdmFyIGogPSBiYS5nZXQoaSk7XG4gICAgICB3cml0ZXIud3JpdGUoMzIsIGNhbWxfaW50MzJfYml0c19vZl9mbG9hdChqWzFdKSk7XG4gICAgICB3cml0ZXIud3JpdGUoMzIsIGNhbWxfaW50MzJfYml0c19vZl9mbG9hdChqWzJdKSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDExOiAvLyBGbG9hdDY0QXJyYXkgKGNvbXBsZXg2NClcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGggLyAyOyBpKyspe1xuICAgICAgdmFyIGNvbXBsZXggPSBiYS5nZXQoaSk7XG4gICAgICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KGNvbXBsZXhbMV0pKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB3cml0ZXIud3JpdGUgKDgsIGJbal0pO1xuICAgICAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdChjb21wbGV4WzJdKSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlICg4LCBiW2pdKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cbiAgc3pbMF0gPSAoNCArIGJhLmRpbXMubGVuZ3RoKSAqIDQ7XG4gIHN6WzFdID0gKDQgKyBiYS5kaW1zLmxlbmd0aCkgKiA4O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2Rlc2VyaWFsaXplXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfZmFpbHdpdGhcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXMsIGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c1xuLy9SZXF1aXJlczogY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV9idWZmZXJcbmZ1bmN0aW9uIGNhbWxfYmFfZGVzZXJpYWxpemUocmVhZGVyLCBzeil7XG4gIHZhciBudW1fZGltcyA9IHJlYWRlci5yZWFkMzJzKCk7XG4gIGlmIChudW1fZGltcyA8IDAgfHwgbnVtX2RpbXMgPiAxNilcbiAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IHdyb25nIG51bWJlciBvZiBiaWdhcnJheSBkaW1lbnNpb25zXCIpO1xuICB2YXIgdGFnID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgdmFyIGtpbmQgPSB0YWcgJiAweGZmXG4gIHZhciBsYXlvdXQgPSAodGFnID4+IDgpICYgMTtcbiAgdmFyIGRpbXMgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9kaW1zOyBpKyspIGRpbXMucHVzaChyZWFkZXIucmVhZDMydSgpKTtcbiAgdmFyIHNpemUgPSBjYW1sX2JhX2dldF9zaXplKGRpbXMpO1xuICB2YXIgZGF0YSA9IGNhbWxfYmFfY3JlYXRlX2J1ZmZlcihraW5kLCBzaXplKTtcbiAgdmFyIGJhID0gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG4gIHN3aXRjaChraW5kKXtcbiAgY2FzZSAyOiAgLy9JbnQ4QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDhzKCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDM6ICAvL1VpbnQ4QXJyYXlcbiAgY2FzZSAxMjogLy9VaW50OEFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA0OiAgLy8gSW50MTZBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkMTZzKCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDU6ICAvLyBVaW50MTZBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkMTZ1KCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDY6ICAvLyBJbnQzMkFycmF5IChpbnQzMilcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDMycygpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA4OiAgLy8gSW50MzJBcnJheSAoaW50KVxuICBjYXNlIDk6ICAvLyBJbnQzMkFycmF5IChuYXRpdmVpbnQpXG4gICAgdmFyIHNpeHR5ID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgIGlmKHNpeHR5KSBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGNhbm5vdCByZWFkIGJpZ2FycmF5IHdpdGggNjQtYml0IE9DYW1sIGludHNcIik7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNzogLy8gKGludDY0KVxuICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgIHZhciBpbnQ2NCA9IGNhbWxfaW50NjRfb2ZfYnl0ZXModCk7XG4gICAgICBiYS5zZXQoaSxpbnQ2NCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDE6ICAvLyBGbG9hdDY0QXJyYXlcbiAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICB2YXIgZiA9IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyhjYW1sX2ludDY0X29mX2J5dGVzKHQpKTtcbiAgICAgIGJhLnNldChpLGYpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAwOiAgLy8gRmxvYXQzMkFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICB2YXIgZiA9IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyhyZWFkZXIucmVhZDMycygpKTtcbiAgICAgIGJhLnNldChpLGYpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMDogLy8gRmxvYXQzMkFycmF5IChjb21wbGV4MzIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICB2YXIgcmUgPSBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMocmVhZGVyLnJlYWQzMnMoKSk7XG4gICAgICB2YXIgaW0gPSBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMocmVhZGVyLnJlYWQzMnMoKSk7XG4gICAgICBiYS5zZXQoaSxbMjU0LHJlLGltXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDExOiAvLyBGbG9hdDY0QXJyYXkgKGNvbXBsZXg2NClcbiAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICB2YXIgcmUgPSBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMoY2FtbF9pbnQ2NF9vZl9ieXRlcyh0KSk7XG4gICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICB2YXIgaW0gPSBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMoY2FtbF9pbnQ2NF9vZl9ieXRlcyh0KSk7XG4gICAgICBiYS5zZXQoaSxbMjU0LHJlLGltXSk7XG4gICAgfVxuICAgIGJyZWFrXG4gIH1cbiAgc3pbMF0gPSAoNCArIG51bV9kaW1zKSAqIDQ7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcbn1cblxuLy9EZXByZWNhdGVkXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NyZWF0ZV9mcm9tXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuZnVuY3Rpb24gY2FtbF9iYV9jcmVhdGVfZnJvbShkYXRhMSwgZGF0YTIsIGpzdHlwLCBraW5kLCBsYXlvdXQsIGRpbXMpe1xuICBpZihkYXRhMiB8fCBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGtpbmQpID09IDIpe1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmFfY3JlYXRlX2Zyb206IHVzZSByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlXCIpO1xuICB9XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfaGFzaCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZSwgY2FtbF9oYXNoX21peF9pbnQsIGNhbWxfaGFzaF9taXhfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfYmFfaGFzaChiYSl7XG4gIHZhciBudW1fZWx0cyA9IGNhbWxfYmFfZ2V0X3NpemUoYmEuZGltcyk7XG4gIHZhciBoID0gMDtcbiAgc3dpdGNoKGJhLmtpbmQpe1xuICBjYXNlIDI6ICAvL0ludDhBcnJheVxuICBjYXNlIDM6ICAvL1VpbnQ4QXJyYXlcbiAgY2FzZSAxMjogLy9VaW50OEFycmF5XG4gICAgaWYobnVtX2VsdHMgPiAyNTYpIG51bV9lbHRzID0gMjU2O1xuICAgIHZhciB3ID0gMCwgaSA9MDtcbiAgICBmb3IoaSA9IDA7IGkgKyA0IDw9IGJhLmRhdGEubGVuZ3RoOyBpKz00KXtcbiAgICAgIHcgPSBiYS5kYXRhW2krMF0gfCAoYmEuZGF0YVtpKzFdIDw8IDgpIHwgKGJhLmRhdGFbaSsyXSA8PCAxNikgfCAoYmEuZGF0YVtpKzNdIDw8IDI0KTtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLHcpO1xuICAgIH1cbiAgICB3ID0gMDtcbiAgICBzd2l0Y2ggKG51bV9lbHRzICYgMykge1xuICAgIGNhc2UgMzogdyAgPSBiYS5kYXRhW2krMl0gPDwgMTY7ICAgIC8qIGZhbGx0aHJvdWdoICovXG4gICAgY2FzZSAyOiB3IHw9IGJhLmRhdGFbaSsxXSA8PCA4OyAgICAgLyogZmFsbHRocm91Z2ggKi9cbiAgICBjYXNlIDE6IHcgfD0gYmEuZGF0YVtpKzBdO1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA0OiAgLy8gSW50MTZBcnJheVxuICBjYXNlIDU6ICAvLyBVaW50MTZBcnJheVxuICAgIGlmKG51bV9lbHRzID4gMTI4KSBudW1fZWx0cyA9IDEyODtcbiAgICB2YXIgdyA9IDAsIGkgPTA7XG4gICAgZm9yKGkgPSAwOyBpICsgMiA8PSBiYS5kYXRhLmxlbmd0aDsgaSs9Mil7XG4gICAgICB3ID0gYmEuZGF0YVtpKzBdIHwgKGJhLmRhdGFbaSsxXSA8PCAxNik7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCx3KTtcbiAgICB9XG4gICAgaWYgKChudW1fZWx0cyAmIDEpICE9IDApXG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgNjogIC8vIEludDMyQXJyYXkgKGludDMyKVxuICAgIGlmIChudW1fZWx0cyA+IDY0KSBudW1fZWx0cyA9IDY0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGJhLmRhdGFbaV0pO1xuICAgIGJyZWFrO1xuICBjYXNlIDg6ICAvLyBJbnQzMkFycmF5IChpbnQpXG4gIGNhc2UgOTogIC8vIEludDMyQXJyYXkgKG5hdGl2ZWludClcbiAgICBpZiAobnVtX2VsdHMgPiA2NCkgbnVtX2VsdHMgPSA2NDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBiYS5kYXRhW2ldKTtcbiAgICBicmVhaztcbiAgY2FzZSA3OiAgLy8gSW50MzJBcnJheSAoaW50NjQpXG4gICAgaWYgKG51bV9lbHRzID4gMzIpIG51bV9lbHRzID0gMzI7XG4gICAgbnVtX2VsdHMgKj0gMlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykge1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGJhLmRhdGFbaV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMDogLy8gRmxvYXQzMkFycmF5IChjb21wbGV4MzIpXG4gICAgbnVtX2VsdHMgKj0yOyAvKiBmYWxsdGhyb3VnaCAqL1xuICBjYXNlIDA6ICAvLyBGbG9hdDMyQXJyYXlcbiAgICBpZiAobnVtX2VsdHMgPiA2NCkgbnVtX2VsdHMgPSA2NDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIGggPSBjYW1sX2hhc2hfbWl4X2Zsb2F0KGgsIGJhLmRhdGFbaV0pO1xuICAgIGJyZWFrO1xuICBjYXNlIDExOiAvLyBGbG9hdDY0QXJyYXkgKGNvbXBsZXg2NClcbiAgICBudW1fZWx0cyAqPTI7IC8qIGZhbGx0aHJvdWdoICovXG4gIGNhc2UgMTogIC8vIEZsb2F0NjRBcnJheVxuICAgIGlmIChudW1fZWx0cyA+IDMyKSBudW1fZWx0cyA9IDMyO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykgaCA9IGNhbWxfaGFzaF9taXhfZmxvYXQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIGg7XG59XG4iLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdGl2ZSBDYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICovXG4vKiAgZW4gQXV0b21hdGlxdWUuICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkICAgICovXG4vKiAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UsIHdpdGggICAgICovXG4vKiAgdGhlIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIGZpbGUgLi4vTElDRU5TRS4gICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qICRJZDogcGFyc2luZy5jIDg5ODMgMjAwOC0wOC0wNiAwOTozODoyNVogeGxlcm95ICQgKi9cblxuLyogVGhlIFBEQSBhdXRvbWF0b24gZm9yIHBhcnNlcnMgZ2VuZXJhdGVkIGJ5IGNhbWx5YWNjICovXG5cbi8qIFRoZSBwdXNoZG93biBhdXRvbWF0YSAqL1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX2VuZ2luZVxuLy9SZXF1aXJlczogY2FtbF9sZXhfYXJyYXlcbmZ1bmN0aW9uIGNhbWxfcGFyc2VfZW5naW5lKHRhYmxlcywgZW52LCBjbWQsIGFyZylcbntcbiAgdmFyIEVSUkNPREUgPSAyNTY7XG5cbiAgLy92YXIgU1RBUlQgPSAwO1xuICAvL3ZhciBUT0tFTl9SRUFEID0gMTtcbiAgLy92YXIgU1RBQ0tTX0dST1dOXzEgPSAyO1xuICAvL3ZhciBTVEFDS1NfR1JPV05fMiA9IDM7XG4gIC8vdmFyIFNFTUFOVElDX0FDVElPTl9DT01QVVRFRCA9IDQ7XG4gIC8vdmFyIEVSUk9SX0RFVEVDVEVEID0gNTtcbiAgdmFyIGxvb3AgPSA2O1xuICB2YXIgdGVzdHNoaWZ0ID0gNztcbiAgdmFyIHNoaWZ0ID0gODtcbiAgdmFyIHNoaWZ0X3JlY292ZXIgPSA5O1xuICB2YXIgcmVkdWNlID0gMTA7XG5cbiAgdmFyIFJFQURfVE9LRU4gPSAwO1xuICB2YXIgUkFJU0VfUEFSU0VfRVJST1IgPSAxO1xuICB2YXIgR1JPV19TVEFDS1NfMSA9IDI7XG4gIHZhciBHUk9XX1NUQUNLU18yID0gMztcbiAgdmFyIENPTVBVVEVfU0VNQU5USUNfQUNUSU9OID0gNDtcbiAgdmFyIENBTExfRVJST1JfRlVOQ1RJT04gPSA1O1xuXG4gIHZhciBlbnZfc19zdGFjayA9IDE7XG4gIHZhciBlbnZfdl9zdGFjayA9IDI7XG4gIHZhciBlbnZfc3ltYl9zdGFydF9zdGFjayA9IDM7XG4gIHZhciBlbnZfc3ltYl9lbmRfc3RhY2sgPSA0O1xuICB2YXIgZW52X3N0YWNrc2l6ZSA9IDU7XG4gIHZhciBlbnZfc3RhY2tiYXNlID0gNjtcbiAgdmFyIGVudl9jdXJyX2NoYXIgPSA3O1xuICB2YXIgZW52X2x2YWwgPSA4O1xuICB2YXIgZW52X3N5bWJfc3RhcnQgPSA5O1xuICB2YXIgZW52X3N5bWJfZW5kID0gMTA7XG4gIHZhciBlbnZfYXNwID0gMTE7XG4gIHZhciBlbnZfcnVsZV9sZW4gPSAxMjtcbiAgdmFyIGVudl9ydWxlX251bWJlciA9IDEzO1xuICB2YXIgZW52X3NwID0gMTQ7XG4gIHZhciBlbnZfc3RhdGUgPSAxNTtcbiAgdmFyIGVudl9lcnJmbGFnID0gMTY7XG5cbiAgLy8gdmFyIF90YmxfYWN0aW9ucyA9IDE7XG4gIHZhciB0YmxfdHJhbnNsX2NvbnN0ID0gMjtcbiAgdmFyIHRibF90cmFuc2xfYmxvY2sgPSAzO1xuICB2YXIgdGJsX2xocyA9IDQ7XG4gIHZhciB0YmxfbGVuID0gNTtcbiAgdmFyIHRibF9kZWZyZWQgPSA2O1xuICB2YXIgdGJsX2Rnb3RvID0gNztcbiAgdmFyIHRibF9zaW5kZXggPSA4O1xuICB2YXIgdGJsX3JpbmRleCA9IDk7XG4gIHZhciB0YmxfZ2luZGV4ID0gMTA7XG4gIHZhciB0YmxfdGFibGVzaXplID0gMTE7XG4gIHZhciB0YmxfdGFibGUgPSAxMjtcbiAgdmFyIHRibF9jaGVjayA9IDEzO1xuICAvLyB2YXIgX3RibF9lcnJvcl9mdW5jdGlvbiA9IDE0O1xuICAvLyB2YXIgX3RibF9uYW1lc19jb25zdCA9IDE1O1xuICAvLyB2YXIgX3RibF9uYW1lc19ibG9jayA9IDE2O1xuXG4gIGlmICghdGFibGVzLmRnb3RvKSB7XG4gICAgdGFibGVzLmRlZnJlZCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2RlZnJlZF0pO1xuICAgIHRhYmxlcy5zaW5kZXggPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9zaW5kZXhdKTtcbiAgICB0YWJsZXMuY2hlY2sgID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfY2hlY2tdKTtcbiAgICB0YWJsZXMucmluZGV4ID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfcmluZGV4XSk7XG4gICAgdGFibGVzLnRhYmxlICA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX3RhYmxlXSk7XG4gICAgdGFibGVzLmxlbiAgICA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2xlbl0pO1xuICAgIHRhYmxlcy5saHMgICAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9saHNdKTtcbiAgICB0YWJsZXMuZ2luZGV4ID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfZ2luZGV4XSk7XG4gICAgdGFibGVzLmRnb3RvICA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2Rnb3RvXSk7XG4gIH1cblxuICB2YXIgcmVzID0gMCwgbiwgbjEsIG4yLCBzdGF0ZTE7XG5cbiAgLy8gUkVTVE9SRVxuICB2YXIgc3AgPSBlbnZbZW52X3NwXTtcbiAgdmFyIHN0YXRlID0gZW52W2Vudl9zdGF0ZV07XG4gIHZhciBlcnJmbGFnID0gZW52W2Vudl9lcnJmbGFnXTtcblxuICBleGl0OmZvciAoOzspIHtcbiAgICBzd2l0Y2goY21kKSB7XG4gICAgY2FzZSAwOi8vU1RBUlQ6XG4gICAgICBzdGF0ZSA9IDA7XG4gICAgICBlcnJmbGFnID0gMDtcbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgY2FzZSA2Oi8vbG9vcDpcbiAgICAgIG4gPSB0YWJsZXMuZGVmcmVkW3N0YXRlXTtcbiAgICAgIGlmIChuICE9IDApIHsgY21kID0gcmVkdWNlOyBicmVhazsgfVxuICAgICAgaWYgKGVudltlbnZfY3Vycl9jaGFyXSA+PSAwKSB7IGNtZCA9IHRlc3RzaGlmdDsgYnJlYWs7IH1cbiAgICAgIHJlcyA9IFJFQURfVE9LRU47XG4gICAgICBicmVhayBleGl0O1xuICAgICAgLyogVGhlIE1MIGNvZGUgY2FsbHMgdGhlIGxleGVyIGFuZCB1cGRhdGVzICovXG4gICAgICAvKiBzeW1iX3N0YXJ0IGFuZCBzeW1iX2VuZCAqL1xuICAgIGNhc2UgMTovL1RPS0VOX1JFQUQ6XG4gICAgICBpZiAoYXJnIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gdGFibGVzW3RibF90cmFuc2xfYmxvY2tdW2FyZ1swXSArIDFdO1xuICAgICAgICBlbnZbZW52X2x2YWxdID0gYXJnWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gdGFibGVzW3RibF90cmFuc2xfY29uc3RdW2FyZyArIDFdO1xuICAgICAgICBlbnZbZW52X2x2YWxdID0gMDtcbiAgICAgIH1cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgY2FzZSA3Oi8vdGVzdHNoaWZ0OlxuICAgICAgbjEgPSB0YWJsZXMuc2luZGV4W3N0YXRlXTtcbiAgICAgIG4yID0gbjEgKyBlbnZbZW52X2N1cnJfY2hhcl07XG4gICAgICBpZiAobjEgIT0gMCAmJiBuMiA+PSAwICYmIG4yIDw9IHRhYmxlc1t0YmxfdGFibGVzaXplXSAmJlxuICAgICAgICAgIHRhYmxlcy5jaGVja1tuMl0gPT0gZW52W2Vudl9jdXJyX2NoYXJdKSB7XG4gICAgICAgIGNtZCA9IHNoaWZ0OyBicmVhaztcbiAgICAgIH1cbiAgICAgIG4xID0gdGFibGVzLnJpbmRleFtzdGF0ZV07XG4gICAgICBuMiA9IG4xICsgZW52W2Vudl9jdXJyX2NoYXJdO1xuICAgICAgaWYgKG4xICE9IDAgJiYgbjIgPj0gMCAmJiBuMiA8PSB0YWJsZXNbdGJsX3RhYmxlc2l6ZV0gJiZcbiAgICAgICAgICB0YWJsZXMuY2hlY2tbbjJdID09IGVudltlbnZfY3Vycl9jaGFyXSkge1xuICAgICAgICBuID0gdGFibGVzLnRhYmxlW24yXTtcbiAgICAgICAgY21kID0gcmVkdWNlOyBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChlcnJmbGFnIDw9IDApIHtcbiAgICAgICAgcmVzID0gQ0FMTF9FUlJPUl9GVU5DVElPTjtcbiAgICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIH1cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgICAgLyogVGhlIE1MIGNvZGUgY2FsbHMgdGhlIGVycm9yIGZ1bmN0aW9uICovXG4gICAgY2FzZSA1Oi8vRVJST1JfREVURUNURUQ6XG4gICAgICBpZiAoZXJyZmxhZyA8IDMpIHtcbiAgICAgICAgZXJyZmxhZyA9IDM7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBzdGF0ZTEgPSBlbnZbZW52X3Nfc3RhY2tdW3NwICsgMV07XG4gICAgICAgICAgbjEgPSB0YWJsZXMuc2luZGV4W3N0YXRlMV07XG4gICAgICAgICAgbjIgPSBuMSArIEVSUkNPREU7XG4gICAgICAgICAgaWYgKG4xICE9IDAgJiYgbjIgPj0gMCAmJiBuMiA8PSB0YWJsZXNbdGJsX3RhYmxlc2l6ZV0gJiZcbiAgICAgICAgICAgICAgdGFibGVzLmNoZWNrW24yXSA9PSBFUlJDT0RFKSB7XG4gICAgICAgICAgICBjbWQgPSBzaGlmdF9yZWNvdmVyOyBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNwIDw9IGVudltlbnZfc3RhY2tiYXNlXSkgcmV0dXJuIFJBSVNFX1BBUlNFX0VSUk9SO1xuICAgICAgICAgICAgLyogVGhlIE1MIGNvZGUgcmFpc2VzIFBhcnNlX2Vycm9yICovXG4gICAgICAgICAgICBzcC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVudltlbnZfY3Vycl9jaGFyXSA9PSAwKSByZXR1cm4gUkFJU0VfUEFSU0VfRVJST1I7XG4gICAgICAgIC8qIFRoZSBNTCBjb2RlIHJhaXNlcyBQYXJzZV9lcnJvciAqL1xuICAgICAgICBlbnZbZW52X2N1cnJfY2hhcl0gPSAtMTtcbiAgICAgICAgY21kID0gbG9vcDsgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICBjYXNlIDg6Ly9zaGlmdDpcbiAgICAgIGVudltlbnZfY3Vycl9jaGFyXSA9IC0xO1xuICAgICAgaWYgKGVycmZsYWcgPiAwKSBlcnJmbGFnLS07XG4gICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICBjYXNlIDk6Ly9zaGlmdF9yZWNvdmVyOlxuICAgICAgc3RhdGUgPSB0YWJsZXMudGFibGVbbjJdO1xuICAgICAgc3ArKztcbiAgICAgIGlmIChzcCA+PSBlbnZbZW52X3N0YWNrc2l6ZV0pIHtcbiAgICAgICAgcmVzID0gR1JPV19TVEFDS1NfMTtcbiAgICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIH1cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgICAgLyogVGhlIE1MIGNvZGUgcmVzaXplcyB0aGUgc3RhY2tzICovXG4gICAgY2FzZSAyOi8vU1RBQ0tTX0dST1dOXzE6XG4gICAgICBlbnZbZW52X3Nfc3RhY2tdW3NwICsgMV0gPSBzdGF0ZTtcbiAgICAgIGVudltlbnZfdl9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfbHZhbF07XG4gICAgICBlbnZbZW52X3N5bWJfc3RhcnRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfc3RhcnRdO1xuICAgICAgZW52W2Vudl9zeW1iX2VuZF9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfc3ltYl9lbmRdO1xuICAgICAgY21kID0gbG9vcDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAxMDovL3JlZHVjZTpcbiAgICAgIHZhciBtID0gdGFibGVzLmxlbltuXTtcbiAgICAgIGVudltlbnZfYXNwXSA9IHNwO1xuICAgICAgZW52W2Vudl9ydWxlX251bWJlcl0gPSBuO1xuICAgICAgZW52W2Vudl9ydWxlX2xlbl0gPSBtO1xuICAgICAgc3AgPSBzcCAtIG0gKyAxO1xuICAgICAgbSA9IHRhYmxlcy5saHNbbl07XG4gICAgICBzdGF0ZTEgPSBlbnZbZW52X3Nfc3RhY2tdW3NwXTtcbiAgICAgIG4xID0gdGFibGVzLmdpbmRleFttXTtcbiAgICAgIG4yID0gbjEgKyBzdGF0ZTE7XG4gICAgICBpZiAobjEgIT0gMCAmJiBuMiA+PSAwICYmIG4yIDw9IHRhYmxlc1t0YmxfdGFibGVzaXplXSAmJlxuICAgICAgICAgIHRhYmxlcy5jaGVja1tuMl0gPT0gc3RhdGUxKVxuICAgICAgICBzdGF0ZSA9IHRhYmxlcy50YWJsZVtuMl07XG4gICAgICBlbHNlXG4gICAgICAgIHN0YXRlID0gdGFibGVzLmRnb3RvW21dO1xuICAgICAgaWYgKHNwID49IGVudltlbnZfc3RhY2tzaXplXSkge1xuICAgICAgICByZXMgPSBHUk9XX1NUQUNLU18yO1xuICAgICAgICBicmVhayBleGl0O1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgICAvKiBUaGUgTUwgY29kZSByZXNpemVzIHRoZSBzdGFja3MgKi9cbiAgICBjYXNlIDM6Ly9TVEFDS1NfR1JPV05fMjpcbiAgICAgIHJlcyA9IENPTVBVVEVfU0VNQU5USUNfQUNUSU9OO1xuICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIC8qIFRoZSBNTCBjb2RlIGNhbGxzIHRoZSBzZW1hbnRpYyBhY3Rpb24gKi9cbiAgICBjYXNlIDQ6Ly9TRU1BTlRJQ19BQ1RJT05fQ09NUFVURUQ6XG4gICAgICBlbnZbZW52X3Nfc3RhY2tdW3NwICsgMV0gPSBzdGF0ZTtcbiAgICAgIGVudltlbnZfdl9zdGFja11bc3AgKyAxXSA9IGFyZztcbiAgICAgIHZhciBhc3AgPSBlbnZbZW52X2FzcF07XG4gICAgICBlbnZbZW52X3N5bWJfZW5kX3N0YWNrXVtzcCArIDFdID0gZW52W2Vudl9zeW1iX2VuZF9zdGFja11bYXNwICsgMV07XG4gICAgICBpZiAoc3AgPiBhc3ApIHtcbiAgICAgICAgLyogVGhpcyBpcyBhbiBlcHNpbG9uIHByb2R1Y3Rpb24uIFRha2Ugc3ltYl9zdGFydCBlcXVhbCB0byBzeW1iX2VuZC4gKi9cbiAgICAgICAgZW52W2Vudl9zeW1iX3N0YXJ0X3N0YWNrXVtzcCArIDFdID0gZW52W2Vudl9zeW1iX2VuZF9zdGFja11bYXNwICsgMV07XG4gICAgICB9XG4gICAgICBjbWQgPSBsb29wOyBicmVhaztcbiAgICAgIC8qIFNob3VsZCBub3QgaGFwcGVuICovXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBSQUlTRV9QQVJTRV9FUlJPUjtcbiAgICB9XG4gIH1cbiAgLy8gU0FWRVxuICBlbnZbZW52X3NwXSA9IHNwO1xuICBlbnZbZW52X3N0YXRlXSA9IHN0YXRlO1xuICBlbnZbZW52X2VycmZsYWddID0gZXJyZmxhZztcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zZXRfcGFyc2VyX3RyYWNlIGNvbnN0XG4vL0R1bW15IGZ1bmN0aW9uIVxuZnVuY3Rpb24gY2FtbF9zZXRfcGFyc2VyX3RyYWNlKCkgeyByZXR1cm4gMDsgfVxuIiwiLy9Qcm92aWRlczogdW5peF9nZXR0aW1lb2ZkYXlcbmZ1bmN0aW9uIHVuaXhfZ2V0dGltZW9mZGF5ICgpIHtcbiAgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLyAxMDAwO1xufVxuXG4vL1Byb3ZpZGVzOiB1bml4X3RpbWVcbi8vUmVxdWlyZXM6IHVuaXhfZ2V0dGltZW9mZGF5XG5mdW5jdGlvbiB1bml4X3RpbWUgKCkge1xuICByZXR1cm4gTWF0aC5mbG9vcih1bml4X2dldHRpbWVvZmRheSAoKSk7XG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfZ210aW1lXG5mdW5jdGlvbiB1bml4X2dtdGltZSAodCkge1xuICB2YXIgZCA9IG5ldyBEYXRlICh0ICogMTAwMCk7XG4gIHZhciBkX251bSA9IGQuZ2V0VGltZSgpO1xuICB2YXIgamFudWFyeWZpcnN0ID0gKG5ldyBEYXRlKERhdGUuVVRDKGQuZ2V0VVRDRnVsbFllYXIoKSwgMCwgMSkpKS5nZXRUaW1lKCk7XG4gIHZhciBkb3kgPSBNYXRoLmZsb29yKChkX251bSAtIGphbnVhcnlmaXJzdCkgLyA4NjQwMDAwMCk7XG4gIHJldHVybiBCTE9DSygwLCBkLmdldFVUQ1NlY29uZHMoKSwgZC5nZXRVVENNaW51dGVzKCksIGQuZ2V0VVRDSG91cnMoKSxcbiAgICAgICAgICBkLmdldFVUQ0RhdGUoKSwgZC5nZXRVVENNb250aCgpLCBkLmdldFVUQ0Z1bGxZZWFyKCkgLSAxOTAwLFxuICAgICAgICAgIGQuZ2V0VVRDRGF5KCksIGRveSxcbiAgICAgICAgICBmYWxzZSB8IDAgLyogZm9yIFVUQyBkYXlsaWdodCBzYXZpbmdzIHRpbWUgaXMgZmFsc2UgKi8pXG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfbG9jYWx0aW1lXG5mdW5jdGlvbiB1bml4X2xvY2FsdGltZSAodCkge1xuICB2YXIgZCA9IG5ldyBEYXRlICh0ICogMTAwMCk7XG4gIHZhciBkX251bSA9IGQuZ2V0VGltZSgpO1xuICB2YXIgamFudWFyeWZpcnN0ID0gKG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgMCwgMSkpLmdldFRpbWUoKTtcbiAgdmFyIGRveSA9IE1hdGguZmxvb3IoKGRfbnVtIC0gamFudWFyeWZpcnN0KSAvIDg2NDAwMDAwKTtcbiAgdmFyIGphbiA9IG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgMCwgMSk7XG4gIHZhciBqdWwgPSBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIDYsIDEpO1xuICB2YXIgc3RkVGltZXpvbmVPZmZzZXQgPSBNYXRoLm1heChqYW4uZ2V0VGltZXpvbmVPZmZzZXQoKSwganVsLmdldFRpbWV6b25lT2Zmc2V0KCkpO1xuICByZXR1cm4gQkxPQ0soMCwgZC5nZXRTZWNvbmRzKCksIGQuZ2V0TWludXRlcygpLCBkLmdldEhvdXJzKCksXG4gICAgICAgICAgZC5nZXREYXRlKCksIGQuZ2V0TW9udGgoKSwgZC5nZXRGdWxsWWVhcigpIC0gMTkwMCxcbiAgICAgICAgICBkLmdldERheSgpLCBkb3ksXG4gICAgICAgICAgKGQuZ2V0VGltZXpvbmVPZmZzZXQoKSA8IHN0ZFRpbWV6b25lT2Zmc2V0KSB8IDAgLyogZGF5bGlnaHQgc2F2aW5ncyB0aW1lICBmaWVsZC4gKi8pXG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfbWt0aW1lXG4vL1JlcXVpcmVzOiB1bml4X2xvY2FsdGltZVxuZnVuY3Rpb24gdW5peF9ta3RpbWUodG0pe1xuICB2YXIgZCA9IChuZXcgRGF0ZSh0bVs2XSsxOTAwLHRtWzVdLHRtWzRdLHRtWzNdLHRtWzJdLHRtWzFdKSkuZ2V0VGltZSgpO1xuICB2YXIgdCA9IE1hdGguZmxvb3IoZCAvIDEwMDApO1xuICB2YXIgdG0yID0gdW5peF9sb2NhbHRpbWUodCk7XG4gIHJldHVybiBCTE9DSygwLHQsdG0yKTtcbn1cblxuLy9Qcm92aWRlczogd2luX3N0YXJ0dXAgY29uc3RcbmZ1bmN0aW9uIHdpbl9zdGFydHVwKCkge31cblxuLy9Qcm92aWRlczogd2luX2NsZWFudXAgY29uc3RcbmZ1bmN0aW9uIHdpbl9jbGVhbnVwKCkge31cblxuLy9Qcm92aWRlczogd2luX2hhbmRsZV9mZCBjb25zdFxuZnVuY3Rpb24gd2luX2hhbmRsZV9mZCh4KSB7cmV0dXJuIHg7fVxuIiwiLy8gSnNfb2Zfb2NhbWwgbGlicmFyeVxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIEpzbGliOiBjb2RlIHNwZWNpZmljIHRvIEpzX29mX29jYW1sXG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9ib29sIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZnJvbV9ib29sKHgpIHsgcmV0dXJuICEheDsgfVxuLy9Qcm92aWRlczogY2FtbF9qc190b19ib29sIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfdG9fYm9vbCh4KSB7IHJldHVybiAreDsgfVxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX2Zsb2F0IGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZnJvbV9mbG9hdCh4KSB7IHJldHVybiB4OyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2Zsb2F0IGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfdG9fZmxvYXQoeCkgeyByZXR1cm4geDsgfVxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX3N0cmluZyBtdXRhYmxlIChjb25zdClcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfanNfZnJvbV9zdHJpbmcocykgeyByZXR1cm4gcy50b1N0cmluZygpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Zyb21fYXJyYXkgbXV0YWJsZSAoc2hhbGxvdylcbi8vUmVxdWlyZXM6IHJhd19hcnJheV9zdWJcbmZ1bmN0aW9uIGNhbWxfanNfZnJvbV9hcnJheShhKSB7IHJldHVybiByYXdfYXJyYXlfc3ViKGEsMSxhLmxlbmd0aC0xKTsgfVxuLy9Qcm92aWRlczogY2FtbF9qc190b19hcnJheSBtdXRhYmxlIChzaGFsbG93KVxuLy9SZXF1aXJlczogcmF3X2FycmF5X2NvbnNcbmZ1bmN0aW9uIGNhbWxfanNfdG9fYXJyYXkoYSkgeyByZXR1cm4gcmF3X2FycmF5X2NvbnMoYSwwKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3ZhciBtdXRhYmxlIChjb25zdClcbi8vUmVxdWlyZXM6IGpzX3ByaW50X3N0ZGVyclxuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9qc192YXIoeCkge1xuICB2YXIgeCA9IHgudG9TdHJpbmcoKTtcbiAgLy9DaGVja3MgdGhhdCB4IGhhcyB0aGUgZm9ybSBpZGVudFsuaWRlbnRdKlxuICBpZigheC5tYXRjaCgvXlthLXpBLVpfJF1bYS16QS1aXyQwLTldKihcXC5bYS16QS1aXyRdW2EtekEtWl8kMC05XSopKiQvKSl7XG4gICAganNfcHJpbnRfc3RkZXJyKFwiY2FtbF9qc192YXI6IFxcXCJcIiArIHggKyBcIlxcXCIgaXMgbm90IGEgdmFsaWQgSmF2YVNjcmlwdCB2YXJpYWJsZS4gY29udGludWluZyAuLlwiKTtcbiAgICAvL2pvb19nbG9iYWxfb2JqZWN0LmNvbnNvbGUuZXJyb3IoXCJKcy5VbnNhZmUuZXZhbF9zdHJpbmdcIilcbiAgfVxuICByZXR1cm4gZXZhbCh4KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfY2FsbCAoY29uc3QsIG11dGFibGUsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfY2FsbChmLCBvLCBhcmdzKSB7IHJldHVybiBmLmFwcGx5KG8sIGNhbWxfanNfZnJvbV9hcnJheShhcmdzKSk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnVuX2NhbGwgKGNvbnN0LCBzaGFsbG93KVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2pzX2Z1bl9jYWxsKGYsIGEpIHtcbiAgc3dpdGNoIChhLmxlbmd0aCkge1xuICBjYXNlIDE6IHJldHVybiBmKCk7XG4gIGNhc2UgMjogcmV0dXJuIGYgKGFbMV0pO1xuICBjYXNlIDM6IHJldHVybiBmIChhWzFdLGFbMl0pO1xuICBjYXNlIDQ6IHJldHVybiBmIChhWzFdLGFbMl0sYVszXSk7XG4gIGNhc2UgNTogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdLGFbNF0pO1xuICBjYXNlIDY6IHJldHVybiBmIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0pO1xuICBjYXNlIDc6IHJldHVybiBmIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSk7XG4gIGNhc2UgODogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdLGFbN10pO1xuICB9XG4gIHJldHVybiBmLmFwcGx5KG51bGwsIGNhbWxfanNfZnJvbV9hcnJheShhKSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX21ldGhfY2FsbCAobXV0YWJsZSwgY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfbWV0aF9jYWxsKG8sIGYsIGFyZ3MpIHtcbiAgcmV0dXJuIG9bZi50b1N0cmluZygpXS5hcHBseShvLCBjYW1sX2pzX2Zyb21fYXJyYXkoYXJncykpO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc19uZXcgKGNvbnN0LCBzaGFsbG93KVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2pzX25ldyhjLCBhKSB7XG4gIHN3aXRjaCAoYS5sZW5ndGgpIHtcbiAgY2FzZSAxOiByZXR1cm4gbmV3IGM7XG4gIGNhc2UgMjogcmV0dXJuIG5ldyBjIChhWzFdKTtcbiAgY2FzZSAzOiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSk7XG4gIGNhc2UgNDogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0sYVszXSk7XG4gIGNhc2UgNTogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0sYVszXSxhWzRdKTtcbiAgY2FzZSA2OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSk7XG4gIGNhc2UgNzogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSk7XG4gIGNhc2UgODogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSxhWzddKTtcbiAgfVxuICBmdW5jdGlvbiBGKCkgeyByZXR1cm4gYy5hcHBseSh0aGlzLCBjYW1sX2pzX2Zyb21fYXJyYXkoYSkpOyB9XG4gIEYucHJvdG90eXBlID0gYy5wcm90b3R5cGU7XG4gIHJldHVybiBuZXcgRjtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfb2pzX25ld19hcnIgKGNvbnN0LCBzaGFsbG93KVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX29qc19uZXdfYXJyKGMsIGEpIHtcbiAgc3dpdGNoIChhLmxlbmd0aCkge1xuICBjYXNlIDA6IHJldHVybiBuZXcgYztcbiAgY2FzZSAxOiByZXR1cm4gbmV3IGMgKGFbMF0pO1xuICBjYXNlIDI6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdKTtcbiAgY2FzZSAzOiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSxhWzJdKTtcbiAgY2FzZSA0OiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSxhWzJdLGFbM10pO1xuICBjYXNlIDU6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSxhWzRdKTtcbiAgY2FzZSA2OiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdKTtcbiAgY2FzZSA3OiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0pO1xuICB9XG4gIGZ1bmN0aW9uIEYoKSB7IHJldHVybiBjLmFwcGx5KHRoaXMsIGEpOyB9XG4gIEYucHJvdG90eXBlID0gYy5wcm90b3R5cGU7XG4gIHJldHVybiBuZXcgRjtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9jYWxsYmFjayBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfY2FsbGJhY2soZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPiAwKXtcbiAgICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIGFyZ3VtZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIFt1bmRlZmluZWRdKTtcbiAgICB9XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX2NhbGxiYWNrX2FyZ3VtZW50c1xuLy9SZXF1aXJlczogY2FtbF9qc193cmFwX2NhbGxiYWNrXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfYXJndW1lbnRzKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjYW1sX2pzX3dyYXBfY2FsbGJhY2soZikoYXJndW1lbnRzKTtcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX2NhbGxiYWNrX3N0cmljdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlblxuZnVuY3Rpb24gY2FtbF9qc193cmFwX2NhbGxiYWNrX3N0cmljdChhcml0eSwgZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZihuID09IGFyaXR5KSByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBhcmd1bWVudHMpO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyaXR5KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG4gJiYgaSA8IGFyaXR5OyBpKyspIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgYXJncyk7XG4gIH07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFjayBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuLHJhd19hcnJheV9jb25zXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFjayhmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZixyYXdfYXJyYXlfY29ucyhhcmd1bWVudHMsdGhpcykpO1xuICB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19hcmd1bWVudHMgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlbixyYXdfYXJyYXlfY29uc1xuZnVuY3Rpb24gY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfYXJndW1lbnRzKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLFt0aGlzLGFyZ3VtZW50c10pO1xuICB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19zdHJpY3QgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW4sIHJhd19hcnJheV9jb25zXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19zdHJpY3QoYXJpdHksIGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYobiA9PSBhcml0eSkgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgcmF3X2FycmF5X2NvbnMoYXJndW1lbnRzLHRoaXMpKTtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcml0eSArIDEpO1xuICAgIGFyZ3NbMF0gPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbiAmJiBpIDw9IGFyaXR5OyBpKyspIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgYXJncyk7XG4gIH07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja191bnNhZmUgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlbixyYXdfYXJyYXlfY29uc1xuZnVuY3Rpb24gY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfdW5zYWZlKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgZi5hcHBseShudWxsLCByYXdfYXJyYXlfY29ucyhhcmd1bWVudHMsdGhpcykpOyB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2VxdWFscyBtdXRhYmxlIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2VxdWFscyAoeCwgeSkgeyByZXR1cm4gKyh4ID09IHkpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2J5dGVfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX25ld19zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfdG9fYnl0ZV9zdHJpbmcgKHMpIHtyZXR1cm4gY2FtbF9uZXdfc3RyaW5nIChzKTt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXZhbF9zdHJpbmcgKGNvbnN0KVxuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9qc19ldmFsX3N0cmluZyAocykge3JldHVybiBldmFsKHMudG9TdHJpbmcoKSk7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2V4cHIgKGNvbnN0KVxuLy9SZXF1aXJlczoganNfcHJpbnRfc3RkZXJyXG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2pzX2V4cHIocykge1xuICBqc19wcmludF9zdGRlcnIoXCJjYW1sX2pzX2V4cHI6IGZhbGxiYWNrIHRvIHJ1bnRpbWUgZXZhbHVhdGlvblwiKTtcbiAgcmV0dXJuIGV2YWwocy50b1N0cmluZygpKTt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcHVyZV9qc19leHByIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGpzX3ByaW50X3N0ZGVyclxuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9wdXJlX2pzX2V4cHIgKHMpe1xuICBqc19wcmludF9zdGRlcnIoXCJjYW1sX3B1cmVfanNfZXhwcjogZmFsbGJhY2sgdG8gcnVudGltZSBldmFsdWF0aW9uXCIpO1xuICByZXR1cm4gZXZhbChzLnRvU3RyaW5nKCkpO31cblxuLy9Qcm92aWRlczogY2FtbF9qc19vYmplY3QgKG9iamVjdF9saXRlcmFsKVxuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9qc19vYmplY3QgKGEpIHtcbiAgdmFyIG8gPSB7fTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAgPSBhW2ldO1xuICAgIG9bcFsxXS50b1N0cmluZygpXSA9IHBbMl07XG4gIH1cbiAgcmV0dXJuIG87XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9qc19leHBvcnRfdmFyXG5mdW5jdGlvbiBjYW1sX2pzX2V4cG9ydF92YXIgKCl7XG4gIGlmKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cylcbiAgICByZXR1cm4gbW9kdWxlLmV4cG9ydHNcbiAgZWxzZVxuICAgIHJldHVybiBqb29fZ2xvYmFsX29iamVjdDtcbn1cbiIsIi8vIEpzX29mX29jYW1sIGxpYnJhcnlcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBKc2xpYlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3B1cmVfZXhwciBjb25zdFxuZnVuY3Rpb24gY2FtbF9qc19wdXJlX2V4cHIgKGYpIHsgcmV0dXJuIGYoKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3NldCAobXV0YWJsZSwgY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19zZXQobyxmLHYpIHsgb1tmXT12O3JldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9qc19nZXQgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19nZXQobyxmKSB7IHJldHVybiBvW2ZdOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2RlbGV0ZSAobXV0YWJsZSwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2RlbGV0ZShvLGYpIHsgZGVsZXRlIG9bZl07IHJldHVybiAwfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2luc3RhbmNlb2YgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfaW5zdGFuY2VvZihvLGMpIHsgcmV0dXJuIG8gaW5zdGFuY2VvZiBjOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdHlwZW9mIChjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfdHlwZW9mKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfb25faWUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfanNfb25faWUgKCkge1xuICB2YXIgdWEgPVxuICAgICAgam9vX2dsb2JhbF9vYmplY3QubmF2aWdhdG9yP2pvb19nbG9iYWxfb2JqZWN0Lm5hdmlnYXRvci51c2VyQWdlbnQ6XCJcIjtcbiAgcmV0dXJuIHVhLmluZGV4T2YoXCJNU0lFXCIpICE9IC0xICYmIHVhLmluZGV4T2YoXCJPcGVyYVwiKSAhPSAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2h0bWxfZXNjYXBlIGNvbnN0IChjb25zdClcbnZhciBjYW1sX2pzX3JlZ2V4cHMgPSB7IGFtcDovJi9nLCBsdDovPC9nLCBxdW90Oi9cXFwiL2csIGFsbDovWyY8XFxcIl0vIH07XG5mdW5jdGlvbiBjYW1sX2pzX2h0bWxfZXNjYXBlIChzKSB7XG4gIGlmICghY2FtbF9qc19yZWdleHBzLmFsbC50ZXN0KHMpKSByZXR1cm4gcztcbiAgcmV0dXJuIHMucmVwbGFjZShjYW1sX2pzX3JlZ2V4cHMuYW1wLCBcIiZhbXA7XCIpXG4gICAgLnJlcGxhY2UoY2FtbF9qc19yZWdleHBzLmx0LCBcIiZsdDtcIilcbiAgICAucmVwbGFjZShjYW1sX2pzX3JlZ2V4cHMucXVvdCwgXCImcXVvdDtcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfaHRtbF9lbnRpdGllc1xuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9qc19odG1sX2VudGl0aWVzKHMpIHtcbiAgdmFyIGVudGl0eSA9IC9eJiM/WzAtOWEtekEtWl0rOyQvXG4gIGlmKHMubWF0Y2goZW50aXR5KSlcbiAge1xuICAgIHZhciBzdHIsIHRlbXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgdGVtcC5pbm5lckhUTUw9IHM7XG4gICAgc3RyPSB0ZW1wLnRleHRDb250ZW50IHx8IHRlbXAuaW5uZXJUZXh0O1xuICAgIHRlbXA9bnVsbDtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIGVsc2Uge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJJbnZhbGlkIGVudGl0eSBcIiArIHMpO1xuICB9XG59XG5cbi8vLy8vLy8vLy8vIERlYnVnZ2luZyBjb25zb2xlXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2dldF9jb25zb2xlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2pzX2dldF9jb25zb2xlICgpIHtcbiAgdmFyIGMgPSBqb29fZ2xvYmFsX29iamVjdC5jb25zb2xlP2pvb19nbG9iYWxfb2JqZWN0LmNvbnNvbGU6e307XG4gIHZhciBtID0gW1wibG9nXCIsIFwiZGVidWdcIiwgXCJpbmZvXCIsIFwid2FyblwiLCBcImVycm9yXCIsIFwiYXNzZXJ0XCIsIFwiZGlyXCIsIFwiZGlyeG1sXCIsXG4gICAgICAgICAgIFwidHJhY2VcIiwgXCJncm91cFwiLCBcImdyb3VwQ29sbGFwc2VkXCIsIFwiZ3JvdXBFbmRcIiwgXCJ0aW1lXCIsIFwidGltZUVuZFwiXTtcbiAgZnVuY3Rpb24gZiAoKSB7fVxuICBmb3IgKHZhciBpID0gMDsgaSA8IG0ubGVuZ3RoOyBpKyspIGlmICghY1ttW2ldXSkgY1ttW2ldXT1mO1xuICByZXR1cm4gYztcbn1cblxuLy9Qcm92aWRlczpjYW1sX3RyYW1wb2xpbmVcbmZ1bmN0aW9uIGNhbWxfdHJhbXBvbGluZShyZXMpIHtcbiAgdmFyIGMgPSAxO1xuICB3aGlsZShyZXMgJiYgcmVzLmpvb190cmFtcCl7XG4gICAgcmVzID0gcmVzLmpvb190cmFtcC5hcHBseShudWxsLCByZXMuam9vX2FyZ3MpO1xuICAgIGMrKztcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOmNhbWxfdHJhbXBvbGluZV9yZXR1cm5cbmZ1bmN0aW9uIGNhbWxfdHJhbXBvbGluZV9yZXR1cm4oZixhcmdzKSB7XG4gIHJldHVybiB7am9vX3RyYW1wOmYsam9vX2FyZ3M6YXJnc307XG59XG5cbi8vUHJvdmlkZXM6IGpzX3ByaW50X3N0ZG91dCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3V0ZjE2X29mX3V0ZjhcbmZ1bmN0aW9uIGpzX3ByaW50X3N0ZG91dChzKSB7XG4gIHZhciBzID0gY2FtbF91dGYxNl9vZl91dGY4KHMpO1xuICB2YXIgZyA9IGpvb19nbG9iYWxfb2JqZWN0O1xuICBpZiAoZy5wcm9jZXNzICYmIGcucHJvY2Vzcy5zdGRvdXQgJiYgZy5wcm9jZXNzLnN0ZG91dC53cml0ZSkge1xuICAgIGcucHJvY2Vzcy5zdGRvdXQud3JpdGUocylcbiAgfSBlbHNlIHtcbiAgICAvLyBEbyBub3Qgb3V0cHV0IHRoZSBsYXN0IFxcbiBpZiBwcmVzZW50XG4gICAgLy8gYXMgY29uc29sZSBsb2dnaW5nIGRpc3BsYXkgYSBuZXdsaW5lIGF0IHRoZSBlbmRcbiAgICBpZihzLmNoYXJDb2RlQXQocy5sZW5ndGggLSAxKSA9PSAxMClcbiAgICAgIHMgPSBzLnN1YnN0cigwLHMubGVuZ3RoIC0gMSApO1xuICAgIHZhciB2ID0gZy5jb25zb2xlO1xuICAgIHYgICYmIHYubG9nICYmIHYubG9nKHMpO1xuICB9XG59XG4vL1Byb3ZpZGVzOiBqc19wcmludF9zdGRlcnIgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF91dGYxNl9vZl91dGY4XG5mdW5jdGlvbiBqc19wcmludF9zdGRlcnIocykge1xuICB2YXIgcyA9IGNhbWxfdXRmMTZfb2ZfdXRmOChzKTtcbiAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgaWYgKGcucHJvY2VzcyAmJiBnLnByb2Nlc3Muc3Rkb3V0ICYmIGcucHJvY2Vzcy5zdGRvdXQud3JpdGUpIHtcbiAgICBnLnByb2Nlc3Muc3RkZXJyLndyaXRlKHMpXG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gbm90IG91dHB1dCB0aGUgbGFzdCBcXG4gaWYgcHJlc2VudFxuICAgIC8vIGFzIGNvbnNvbGUgbG9nZ2luZyBkaXNwbGF5IGEgbmV3bGluZSBhdCB0aGUgZW5kXG4gICAgaWYocy5jaGFyQ29kZUF0KHMubGVuZ3RoIC0gMSkgPT0gMTApXG4gICAgICBzID0gcy5zdWJzdHIoMCxzLmxlbmd0aCAtIDEgKTtcbiAgICB2YXIgdiA9IGcuY29uc29sZTtcbiAgICB2ICYmIHYuZXJyb3IgJiYgdi5lcnJvcihzKTtcbiAgfVxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9DYW1saW50ZXJuYWxNb2RfaW5pdF9tb2Rcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9hcmcsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfQ2FtbGludGVybmFsTW9kX2luaXRfbW9kKGxvYyxzaGFwZSkge1xuICBmdW5jdGlvbiB1bmRlZl9tb2R1bGUgKF94KSB7XG4gICAgY2FtbF9yYWlzZV93aXRoX2FyZyhjYW1sX2dsb2JhbF9kYXRhLlVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlLCBsb2MpO1xuICB9XG4gIGZ1bmN0aW9uIGxvb3AgKHNoYXBlLHN0cnVjdCxpZHgpe1xuICAgIGlmKHR5cGVvZiBzaGFwZSA9PT0gXCJudW1iZXJcIilcbiAgICAgIHN3aXRjaChzaGFwZSl7XG4gICAgICBjYXNlIDA6Ly9mdW5jdGlvblxuICAgICAgICBzdHJ1Y3RbaWR4XT17ZnVuOnVuZGVmX21vZHVsZX07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOi8vbGF6eVxuICAgICAgICBzdHJ1Y3RbaWR4XT1bMjQ2LCB1bmRlZl9tb2R1bGVdO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6Ly9jYXNlIDI6Ly9jbGFzc1xuICAgICAgICBzdHJ1Y3RbaWR4XT1bXTtcbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICBzd2l0Y2goc2hhcGVbMF0pe1xuICAgICAgY2FzZSAwOi8vbW9kdWxlXG4gICAgICAgIHN0cnVjdFtpZHhdID0gWzBdO1xuICAgICAgICBmb3IodmFyIGk9MTtpPHNoYXBlWzFdLmxlbmd0aDtpKyspXG4gICAgICAgICAgbG9vcChzaGFwZVsxXVtpXSxzdHJ1Y3RbaWR4XSxpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0Oi8vY2FzZSAxOi8vVmFsdWVcbiAgICAgICAgc3RydWN0W2lkeF0gPSBzaGFwZVsxXTtcbiAgICAgIH1cbiAgfVxuICB2YXIgcmVzID0gW107XG4gIGxvb3Aoc2hhcGUscmVzLDApO1xuICByZXR1cm4gcmVzWzBdXG59XG4vL1Byb3ZpZGVzOiBjYW1sX0NhbWxpbnRlcm5hbE1vZF91cGRhdGVfbW9kXG4vL1JlcXVpcmVzOiBjYW1sX3VwZGF0ZV9kdW1teVxuZnVuY3Rpb24gY2FtbF9DYW1saW50ZXJuYWxNb2RfdXBkYXRlX21vZChzaGFwZSxyZWFsLHgpIHtcbiAgaWYodHlwZW9mIHNoYXBlID09PSBcIm51bWJlclwiKVxuICAgIHN3aXRjaChzaGFwZSl7XG4gICAgY2FzZSAwOi8vZnVuY3Rpb25cbiAgICAgIHJlYWwuZnVuID0geDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTovL2xhenlcbiAgICBkZWZhdWx0Oi8vY2FzZSAyOi8vY2xhc3NcbiAgICAgIGNhbWxfdXBkYXRlX2R1bW15KHJlYWwseCk7XG4gICAgfVxuICBlbHNlXG4gICAgc3dpdGNoKHNoYXBlWzBdKXtcbiAgICBjYXNlIDA6Ly9tb2R1bGVcbiAgICAgIGZvcih2YXIgaT0xO2k8c2hhcGVbMV0ubGVuZ3RoO2krKylcbiAgICAgICAgY2FtbF9DYW1saW50ZXJuYWxNb2RfdXBkYXRlX21vZChzaGFwZVsxXVtpXSxyZWFsW2ldLHhbaV0pO1xuICAgICAgYnJlYWs7XG4gICAgICAvL2Nhc2UgMTovL1ZhbHVlXG4gICAgZGVmYXVsdDpcbiAgICB9O1xuICByZXR1cm4gMFxufVxuIiwiLy8vLy8vLy8vIEJJR1NUUklOR1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2JpZ3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9zdHJpbmdfYXJyXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2JpZ3N0cmluZyhoLCBicykge1xuICByZXR1cm4gY2FtbF9oYXNoX21peF9zdHJpbmdfYXJyKGgsYnMuZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ190b19hcnJheV9idWZmZXIgbXV0YWJsZVxuZnVuY3Rpb24gYmlnc3RyaW5nX3RvX2FycmF5X2J1ZmZlcihicykge1xuICByZXR1cm4gYnMuZGF0YS5idWZmZXJcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX3RvX3R5cGVkX2FycmF5IG11dGFibGVcbmZ1bmN0aW9uIGJpZ3N0cmluZ190b190eXBlZF9hcnJheShicykge1xuICByZXR1cm4gYnMuZGF0YVxufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfb2ZfYXJyYXlfYnVmZmVyIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gYmlnc3RyaW5nX29mX2FycmF5X2J1ZmZlcihhYikge1xuICB2YXIgdGEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheShhYik7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoMTIsIDAsIFt0YS5sZW5ndGhdLCB0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19vZl90eXBlZF9hcnJheSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbmZ1bmN0aW9uIGJpZ3N0cmluZ19vZl90eXBlZF9hcnJheShiYSkge1xuICB2YXIgdGEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheShiYS5idWZmZXIsIGJhLmJ5dGVPZmZzZXQsIGJhLmxlbmd0aCAqIGJhLkJZVEVTX1BFUl9FTEVNRU5UKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSgxMiwgMCwgW3RhLmxlbmd0aF0sIHRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfbWVtY21wXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBjYW1sX2JpZ3N0cmluZ19tZW1jbXAoczEsIHBvczEsIHMyLCBwb3MyLCBsZW4pe1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGEgPSBjYW1sX2JhX2dldF8xKHMxLHBvczEgKyBpKTtcbiAgICB2YXIgYiA9IGNhbWxfYmFfZ2V0XzEoczIscG9zMiArIGkpO1xuICAgIGlmIChhIDwgYikgcmV0dXJuIC0xO1xuICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmFcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYShiYTEsIHBvczEsIGJhMiwgcG9zMiwgbGVuKXtcbiAgaWYoMTIgIT0gYmExLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYoMTIgIT0gYmEyLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYobGVuID09IDApIHJldHVybiAwO1xuICB2YXIgb2ZzMSA9IGJhMS5vZmZzZXQocG9zMSk7XG4gIHZhciBvZnMyID0gYmEyLm9mZnNldChwb3MyKTtcbiAgaWYob2ZzMSArIGxlbiA+IGJhMS5kYXRhLmxlbmd0aCl7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIGlmKG9mczIgKyBsZW4gPiBiYTIuZGF0YS5sZW5ndGgpe1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICB2YXIgc2xpY2UgPSBiYTEuZGF0YS5zdWJhcnJheShvZnMxLG9mczErbGVuKTtcbiAgYmEyLmRhdGEuc2V0KHNsaWNlLHBvczIpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2FycmF5X29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmEoc3RyMSwgcG9zMSwgYmEyLCBwb3MyLCBsZW4pe1xuICBpZigxMiAhPSBiYTIua2luZClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYobGVuID09IDApIHJldHVybiAwO1xuICB2YXIgb2ZzMiA9IGJhMi5vZmZzZXQocG9zMik7XG4gIGlmKHBvczEgKyBsZW4gPiBzdHIxLmwpIHtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgaWYob2ZzMiArIGxlbiA+IGJhMi5kYXRhLmxlbmd0aCkge1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICB2YXIgc2xpY2UgPSBjYW1sX2FycmF5X29mX3N0cmluZyhzdHIxKS5zbGljZShwb3MxLHBvczEgKyBsZW4pO1xuICBiYTIuZGF0YS5zZXQoc2xpY2Usb2ZzMik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9ibGl0X2J5dGVzLCBjYW1sX3N0cmluZ19vZl9hcnJheVxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlcyhiYTEsIHBvczEsIGJ5dGVzMiwgcG9zMiwgbGVuKXtcbiAgaWYoMTIgIT0gYmExLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmKGxlbiA9PSAwKSByZXR1cm4gMDtcbiAgdmFyIG9mczEgPSBiYTEub2Zmc2V0KHBvczEpO1xuICBpZihvZnMxICsgbGVuID4gYmExLmRhdGEubGVuZ3RoKXtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgaWYocG9zMiArIGxlbiA+IGJ5dGVzMi5sKXtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgdmFyIHNsaWNlID0gYmExLmRhdGEuc2xpY2Uob2ZzMSwgb2ZzMStsZW4pO1xuICBjYW1sX2JsaXRfYnl0ZXMoY2FtbF9zdHJpbmdfb2ZfYXJyYXkoc2xpY2UpLCAwLCBieXRlczIsIHBvczIsIGxlbik7XG4gIHJldHVybiAwXG59XG4iLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdGl2ZSBDYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICovXG4vKiAgZW4gQXV0b21hdGlxdWUuICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkICAgICovXG4vKiAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UsIHdpdGggICAgICovXG4vKiAgdGhlIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIGZpbGUgLi4vTElDRU5TRS4gICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qICRJZDogbGV4aW5nLmMgNjA0NSAyMDA0LTAxLTAxIDE2OjQyOjQzWiBkb2xpZ2V6ICQgKi9cblxuLyogVGhlIHRhYmxlLWRyaXZlbiBhdXRvbWF0b24gZm9yIGxleGVycyBnZW5lcmF0ZWQgYnkgY2FtbGxleC4gKi9cblxuLy9Qcm92aWRlczogY2FtbF9sZXhfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbGV4X2FycmF5KHMpIHtcbiAgcyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocyk7XG4gIHZhciBsID0gcy5sZW5ndGggLyAyO1xuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgYVtpXSA9IChzLmNoYXJDb2RlQXQoMiAqIGkpIHwgKHMuY2hhckNvZGVBdCgyICogaSArIDEpIDw8IDgpKSA8PCAxNiA+PiAxNjtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGV4X2VuZ2luZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9sZXhfYXJyYXksIGNhbWxfYXJyYXlfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2xleF9lbmdpbmUodGJsLCBzdGFydF9zdGF0ZSwgbGV4YnVmKSB7XG4gIHZhciBsZXhfYnVmZmVyID0gMjtcbiAgdmFyIGxleF9idWZmZXJfbGVuID0gMztcbiAgdmFyIGxleF9zdGFydF9wb3MgPSA1O1xuICB2YXIgbGV4X2N1cnJfcG9zID0gNjtcbiAgdmFyIGxleF9sYXN0X3BvcyA9IDc7XG4gIHZhciBsZXhfbGFzdF9hY3Rpb24gPSA4O1xuICB2YXIgbGV4X2VvZl9yZWFjaGVkID0gOTtcbiAgdmFyIGxleF9iYXNlID0gMTtcbiAgdmFyIGxleF9iYWNrdHJrID0gMjtcbiAgdmFyIGxleF9kZWZhdWx0ID0gMztcbiAgdmFyIGxleF90cmFucyA9IDQ7XG4gIHZhciBsZXhfY2hlY2sgPSA1O1xuXG4gIGlmICghdGJsLmxleF9kZWZhdWx0KSB7XG4gICAgdGJsLmxleF9iYXNlID0gICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFzZV0pO1xuICAgIHRibC5sZXhfYmFja3RyayA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2JhY2t0cmtdKTtcbiAgICB0YmwubGV4X2NoZWNrID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9jaGVja10pO1xuICAgIHRibC5sZXhfdHJhbnMgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X3RyYW5zXSk7XG4gICAgdGJsLmxleF9kZWZhdWx0ID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfZGVmYXVsdF0pO1xuICB9XG5cbiAgdmFyIGMsIHN0YXRlID0gc3RhcnRfc3RhdGU7XG5cbiAgdmFyIGJ1ZmZlciA9IGNhbWxfYXJyYXlfb2Zfc3RyaW5nKGxleGJ1ZltsZXhfYnVmZmVyXSk7XG5cbiAgaWYgKHN0YXRlID49IDApIHtcbiAgICAvKiBGaXJzdCBlbnRyeSAqL1xuICAgIGxleGJ1ZltsZXhfbGFzdF9wb3NdID0gbGV4YnVmW2xleF9zdGFydF9wb3NdID0gbGV4YnVmW2xleF9jdXJyX3Bvc107XG4gICAgbGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPSAtMTtcbiAgfSBlbHNlIHtcbiAgICAvKiBSZWVudHJ5IGFmdGVyIHJlZmlsbCAqL1xuICAgIHN0YXRlID0gLXN0YXRlIC0gMTtcbiAgfVxuICBmb3IoOzspIHtcbiAgICAvKiBMb29rdXAgYmFzZSBhZGRyZXNzIG9yIGFjdGlvbiBudW1iZXIgZm9yIGN1cnJlbnQgc3RhdGUgKi9cbiAgICB2YXIgYmFzZSA9IHRibC5sZXhfYmFzZVtzdGF0ZV07XG4gICAgaWYgKGJhc2UgPCAwKSByZXR1cm4gLWJhc2UtMTtcbiAgICAvKiBTZWUgaWYgaXQncyBhIGJhY2t0cmFjayBwb2ludCAqL1xuICAgIHZhciBiYWNrdHJrID0gdGJsLmxleF9iYWNrdHJrW3N0YXRlXTtcbiAgICBpZiAoYmFja3RyayA+PSAwKSB7XG4gICAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgICAgbGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPSBiYWNrdHJrO1xuICAgIH1cbiAgICAvKiBTZWUgaWYgd2UgbmVlZCBhIHJlZmlsbCAqL1xuICAgIGlmIChsZXhidWZbbGV4X2N1cnJfcG9zXSA+PSBsZXhidWZbbGV4X2J1ZmZlcl9sZW5dKXtcbiAgICAgIGlmIChsZXhidWZbbGV4X2VvZl9yZWFjaGVkXSA9PSAwKVxuICAgICAgICByZXR1cm4gLXN0YXRlIC0gMTtcbiAgICAgIGVsc2VcbiAgICAgICAgYyA9IDI1NjtcbiAgICB9ZWxzZXtcbiAgICAgIC8qIFJlYWQgbmV4dCBpbnB1dCBjaGFyICovXG4gICAgICBjID0gYnVmZmVyW2xleGJ1ZltsZXhfY3Vycl9wb3NdXTtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdICsrO1xuICAgIH1cbiAgICAvKiBEZXRlcm1pbmUgbmV4dCBzdGF0ZSAqL1xuICAgIGlmICh0YmwubGV4X2NoZWNrW2Jhc2UgKyBjXSA9PSBzdGF0ZSlcbiAgICAgIHN0YXRlID0gdGJsLmxleF90cmFuc1tiYXNlICsgY107XG4gICAgZWxzZVxuICAgICAgc3RhdGUgPSB0YmwubGV4X2RlZmF1bHRbc3RhdGVdO1xuICAgIC8qIElmIG5vIHRyYW5zaXRpb24gb24gdGhpcyBjaGFyLCByZXR1cm4gdG8gbGFzdCBiYWNrdHJhY2sgcG9pbnQgKi9cbiAgICBpZiAoc3RhdGUgPCAwKSB7XG4gICAgICBsZXhidWZbbGV4X2N1cnJfcG9zXSA9IGxleGJ1ZltsZXhfbGFzdF9wb3NdO1xuICAgICAgaWYgKGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID09IC0xKVxuICAgICAgICBjYW1sX2ZhaWx3aXRoKFwibGV4aW5nOiBlbXB0eSB0b2tlblwiKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dO1xuICAgIH1lbHNle1xuICAgICAgLyogRXJhc2UgdGhlIEVPRiBjb25kaXRpb24gb25seSBpZiB0aGUgRU9GIHBzZXVkby1jaGFyYWN0ZXIgd2FzXG4gICAgICAgICBjb25zdW1lZCBieSB0aGUgYXV0b21hdG9uIChpLmUuIHRoZXJlIHdhcyBubyBiYWNrdHJhY2sgYWJvdmUpXG4gICAgICAqL1xuICAgICAgaWYgKGMgPT0gMjU2KSBsZXhidWZbbGV4X2VvZl9yZWFjaGVkXSA9IDA7XG4gICAgfVxuICB9XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qIE5ldyBsZXhlciBlbmdpbmUsIHdpdGggbWVtb3J5IG9mIHBvc2l0aW9ucyAgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy9Qcm92aWRlczogY2FtbF9uZXdfbGV4X2VuZ2luZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9sZXhfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfYXJyYXlfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2xleF9ydW5fbWVtKHMsIGksIG1lbSwgY3Vycl9wb3MpIHtcbiAgZm9yICg7Oykge1xuICAgIHZhciBkc3QgPSBzLmNoYXJDb2RlQXQoaSk7IGkrKztcbiAgICBpZiAoZHN0ID09IDB4ZmYpIHJldHVybjtcbiAgICB2YXIgc3JjID0gcy5jaGFyQ29kZUF0KGkpOyBpKys7XG4gICAgaWYgKHNyYyA9PSAweGZmKVxuICAgICAgbWVtIFtkc3QgKyAxXSA9IGN1cnJfcG9zO1xuICAgIGVsc2VcbiAgICAgIG1lbSBbZHN0ICsgMV0gPSBtZW0gW3NyYyArIDFdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbWxfbGV4X3J1bl90YWcocywgaSwgbWVtKSB7XG4gIGZvciAoOzspIHtcbiAgICB2YXIgZHN0ID0gcy5jaGFyQ29kZUF0KGkpOyBpKys7XG4gICAgaWYgKGRzdCA9PSAweGZmKSByZXR1cm4gO1xuICAgIHZhciBzcmMgPSBzLmNoYXJDb2RlQXQoaSk7IGkrKztcbiAgICBpZiAoc3JjID09IDB4ZmYpXG4gICAgICBtZW0gW2RzdCArIDFdID0gLTE7XG4gICAgZWxzZVxuICAgICAgbWVtIFtkc3QgKyAxXSA9IG1lbSBbc3JjICsgMV07XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FtbF9uZXdfbGV4X2VuZ2luZSh0YmwsIHN0YXJ0X3N0YXRlLCBsZXhidWYpIHtcbiAgdmFyIGxleF9idWZmZXIgPSAyO1xuICB2YXIgbGV4X2J1ZmZlcl9sZW4gPSAzO1xuICB2YXIgbGV4X3N0YXJ0X3BvcyA9IDU7XG4gIHZhciBsZXhfY3Vycl9wb3MgPSA2O1xuICB2YXIgbGV4X2xhc3RfcG9zID0gNztcbiAgdmFyIGxleF9sYXN0X2FjdGlvbiA9IDg7XG4gIHZhciBsZXhfZW9mX3JlYWNoZWQgPSA5O1xuICB2YXIgbGV4X21lbSA9IDEwO1xuICB2YXIgbGV4X2Jhc2UgPSAxO1xuICB2YXIgbGV4X2JhY2t0cmsgPSAyO1xuICB2YXIgbGV4X2RlZmF1bHQgPSAzO1xuICB2YXIgbGV4X3RyYW5zID0gNDtcbiAgdmFyIGxleF9jaGVjayA9IDU7XG4gIHZhciBsZXhfYmFzZV9jb2RlID0gNjtcbiAgdmFyIGxleF9iYWNrdHJrX2NvZGUgPSA3O1xuICB2YXIgbGV4X2RlZmF1bHRfY29kZSA9IDg7XG4gIHZhciBsZXhfdHJhbnNfY29kZSA9IDk7XG4gIHZhciBsZXhfY2hlY2tfY29kZSA9IDEwO1xuICB2YXIgbGV4X2NvZGUgPSAxMTtcblxuICBpZiAoIXRibC5sZXhfZGVmYXVsdCkge1xuICAgIHRibC5sZXhfYmFzZSA9ICAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2Jhc2VdKTtcbiAgICB0YmwubGV4X2JhY2t0cmsgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYWNrdHJrXSk7XG4gICAgdGJsLmxleF9jaGVjayA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfY2hlY2tdKTtcbiAgICB0YmwubGV4X3RyYW5zID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF90cmFuc10pO1xuICAgIHRibC5sZXhfZGVmYXVsdCA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2RlZmF1bHRdKTtcbiAgfVxuICBpZiAoIXRibC5sZXhfZGVmYXVsdF9jb2RlKSB7XG4gICAgdGJsLmxleF9iYXNlX2NvZGUgPSAgICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYXNlX2NvZGVdKTtcbiAgICB0YmwubGV4X2JhY2t0cmtfY29kZSA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2JhY2t0cmtfY29kZV0pO1xuICAgIHRibC5sZXhfY2hlY2tfY29kZSA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfY2hlY2tfY29kZV0pO1xuICAgIHRibC5sZXhfdHJhbnNfY29kZSA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfdHJhbnNfY29kZV0pO1xuICAgIHRibC5sZXhfZGVmYXVsdF9jb2RlID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfZGVmYXVsdF9jb2RlXSk7XG4gIH1cbiAgaWYgKHRibC5sZXhfY29kZSA9PSBudWxsKSB0YmwubGV4X2NvZGUgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHRibFtsZXhfY29kZV0pO1xuXG4gIHZhciBjLCBzdGF0ZSA9IHN0YXJ0X3N0YXRlO1xuXG4gIHZhciBidWZmZXIgPSBjYW1sX2FycmF5X29mX3N0cmluZyhsZXhidWZbbGV4X2J1ZmZlcl0pO1xuXG4gIGlmIChzdGF0ZSA+PSAwKSB7XG4gICAgLyogRmlyc3QgZW50cnkgKi9cbiAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfc3RhcnRfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID0gLTE7XG4gIH0gZWxzZSB7XG4gICAgLyogUmVlbnRyeSBhZnRlciByZWZpbGwgKi9cbiAgICBzdGF0ZSA9IC1zdGF0ZSAtIDE7XG4gIH1cbiAgZm9yKDs7KSB7XG4gICAgLyogTG9va3VwIGJhc2UgYWRkcmVzcyBvciBhY3Rpb24gbnVtYmVyIGZvciBjdXJyZW50IHN0YXRlICovXG4gICAgdmFyIGJhc2UgPSB0YmwubGV4X2Jhc2Vbc3RhdGVdO1xuICAgIGlmIChiYXNlIDwgMCkge1xuICAgICAgdmFyIHBjX29mZiA9IHRibC5sZXhfYmFzZV9jb2RlW3N0YXRlXTtcbiAgICAgIGNhbWxfbGV4X3J1bl90YWcodGJsLmxleF9jb2RlLCBwY19vZmYsIGxleGJ1ZltsZXhfbWVtXSk7XG4gICAgICByZXR1cm4gLWJhc2UtMTtcbiAgICB9XG4gICAgLyogU2VlIGlmIGl0J3MgYSBiYWNrdHJhY2sgcG9pbnQgKi9cbiAgICB2YXIgYmFja3RyayA9IHRibC5sZXhfYmFja3Rya1tzdGF0ZV07XG4gICAgaWYgKGJhY2t0cmsgPj0gMCkge1xuICAgICAgdmFyIHBjX29mZiA9IHRibC5sZXhfYmFja3Rya19jb2RlW3N0YXRlXTtcbiAgICAgIGNhbWxfbGV4X3J1bl90YWcodGJsLmxleF9jb2RlLCBwY19vZmYsIGxleGJ1ZltsZXhfbWVtXSk7XG4gICAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgICAgbGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPSBiYWNrdHJrO1xuICAgIH1cbiAgICAvKiBTZWUgaWYgd2UgbmVlZCBhIHJlZmlsbCAqL1xuICAgIGlmIChsZXhidWZbbGV4X2N1cnJfcG9zXSA+PSBsZXhidWZbbGV4X2J1ZmZlcl9sZW5dKXtcbiAgICAgIGlmIChsZXhidWZbbGV4X2VvZl9yZWFjaGVkXSA9PSAwKVxuICAgICAgICByZXR1cm4gLXN0YXRlIC0gMTtcbiAgICAgIGVsc2VcbiAgICAgICAgYyA9IDI1NjtcbiAgICB9ZWxzZXtcbiAgICAgIC8qIFJlYWQgbmV4dCBpbnB1dCBjaGFyICovXG4gICAgICBjID0gYnVmZmVyW2xleGJ1ZltsZXhfY3Vycl9wb3NdXTtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdICsrO1xuICAgIH1cbiAgICAvKiBEZXRlcm1pbmUgbmV4dCBzdGF0ZSAqL1xuICAgIHZhciBwc3RhdGUgPSBzdGF0ZSA7XG4gICAgaWYgKHRibC5sZXhfY2hlY2tbYmFzZSArIGNdID09IHN0YXRlKVxuICAgICAgc3RhdGUgPSB0YmwubGV4X3RyYW5zW2Jhc2UgKyBjXTtcbiAgICBlbHNlXG4gICAgICBzdGF0ZSA9IHRibC5sZXhfZGVmYXVsdFtzdGF0ZV07XG4gICAgLyogSWYgbm8gdHJhbnNpdGlvbiBvbiB0aGlzIGNoYXIsIHJldHVybiB0byBsYXN0IGJhY2t0cmFjayBwb2ludCAqL1xuICAgIGlmIChzdGF0ZSA8IDApIHtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdID0gbGV4YnVmW2xleF9sYXN0X3Bvc107XG4gICAgICBpZiAobGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPT0gLTEpXG4gICAgICAgIGNhbWxfZmFpbHdpdGgoXCJsZXhpbmc6IGVtcHR5IHRva2VuXCIpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gbGV4YnVmW2xleF9sYXN0X2FjdGlvbl07XG4gICAgfWVsc2V7XG4gICAgICAvKiBJZiBzb21lIHRyYW5zaXRpb24sIGdldCBhbmQgcGVyZm9ybSBtZW1vcnkgbW92ZXMgKi9cbiAgICAgIHZhciBiYXNlX2NvZGUgPSB0YmwubGV4X2Jhc2VfY29kZVtwc3RhdGVdLCBwY19vZmY7XG4gICAgICBpZiAodGJsLmxleF9jaGVja19jb2RlW2Jhc2VfY29kZSArIGNdID09IHBzdGF0ZSlcbiAgICAgICAgcGNfb2ZmID0gdGJsLmxleF90cmFuc19jb2RlW2Jhc2VfY29kZSArIGNdO1xuICAgICAgZWxzZVxuICAgICAgICBwY19vZmYgPSB0YmwubGV4X2RlZmF1bHRfY29kZVtwc3RhdGVdO1xuICAgICAgaWYgKHBjX29mZiA+IDApXG4gICAgICAgIGNhbWxfbGV4X3J1bl9tZW1cbiAgICAgICh0YmwubGV4X2NvZGUsIHBjX29mZiwgbGV4YnVmW2xleF9tZW1dLCBsZXhidWZbbGV4X2N1cnJfcG9zXSk7XG4gICAgICAvKiBFcmFzZSB0aGUgRU9GIGNvbmRpdGlvbiBvbmx5IGlmIHRoZSBFT0YgcHNldWRvLWNoYXJhY3RlciB3YXNcbiAgICAgICAgIGNvbnN1bWVkIGJ5IHRoZSBhdXRvbWF0b24gKGkuZS4gdGhlcmUgd2FzIG5vIGJhY2t0cmFjayBhYm92ZSlcbiAgICAgICovXG4gICAgICBpZiAoYyA9PSAyNTYpIGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID0gMDtcbiAgICB9XG4gIH1cbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLyBXZWFrIEFQSSwgYnV0IHdpdGhvdXQgdGhlIHdlYWsgc2VtYW50aWNzXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG4vL1ZlcnNpb246IDwgNC4wM1xudmFyIGNhbWxfZXBoZV9rZXlfb2Zmc2V0ID0gMlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfa2V5X29mZnNldFxuLy9WZXJzaW9uOiA+PSA0LjAzXG52YXIgY2FtbF9lcGhlX2tleV9vZmZzZXQgPSAzXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuLy9WZXJzaW9uOiA+PSA0LjAzXG52YXIgY2FtbF9lcGhlX2RhdGFfb2Zmc2V0ID0gMlxuXG4vL1Byb3ZpZGVzOiBjYW1sX3dlYWtfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfa2V5X29mZnNldCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3dlYWtfY3JlYXRlIChuKSB7XG4gIGlmIChuIDwgMCkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuY3JlYXRlXCIpO1xuICB2YXIgeCA9IFsyNTEsXCJjYW1sX2VwaGVfbGlzdF9oZWFkXCJdO1xuICB4Lmxlbmd0aCA9IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgbjtcbiAgcmV0dXJuIHg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0LCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfd2Vha19zZXQoeCwgaSwgdikge1xuICBpZihpIDwgMCB8fCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkgPj0geC5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuc2V0XCIpO1xuICB4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV0gPSB2O1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19nZXRcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0LCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfd2Vha19nZXQoeCwgaSkge1xuICBpZihpIDwgMCB8fCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkgPj0geC5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuZ2V0X2tleVwiKTtcbiAgcmV0dXJuICh4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaSBdPT09dW5kZWZpbmVkKT8wOnhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19nZXRfY29weVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2dldCxjYW1sX2VwaGVfa2V5X29mZnNldFxuLy9SZXF1aXJlczogY2FtbF9vYmpfZHVwLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfd2Vha19nZXRfY29weSh4LCBpKSB7XG4gIGlmKGkgPCAwIHx8IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaSA+PSB4Lmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiV2Vhay5nZXRfY29weVwiKTtcbiAgdmFyIHkgPSBjYW1sX3dlYWtfZ2V0KHgsIGkpO1xuICBpZiAoeSA9PT0gMCkgcmV0dXJuIHk7XG4gIHZhciB6ID0geVsxXTtcbiAgaWYgKHogaW5zdGFuY2VvZiBBcnJheSkgcmV0dXJuIFswLCBjYW1sX29ial9kdXAoeildO1xuICByZXR1cm4geTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2NoZWNrIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX3dlYWtfY2hlY2soeCwgaSkge1xuICBpZih4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV0hPT11bmRlZmluZWQgJiYgeFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldICE9PTApXG4gICAgcmV0dXJuIDE7XG4gIGVsc2VcbiAgICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2JsaXRcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYmxpdFxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfd2Vha19ibGl0KGExLCBpMSwgYTIsIGkyLCBsZW4pIHtcbiAgLy8gbWludXMgb25lIGJlY2F1c2UgY2FtbF9hcnJheV9ibGl0IHdvcmtzIG9uIG9jYW1sIGFycmF5XG4gIGNhbWxfYXJyYXlfYmxpdChhMSwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpMSAtIDEsXG4gICAgICAgICAgICAgICAgICBhMiwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpMiAtIDEsXG4gICAgICAgICAgICAgICAgICBsZW4pO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2NyZWF0ZVxudmFyIGNhbWxfZXBoZV9jcmVhdGUgPSBjYW1sX3dlYWtfY3JlYXRlXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9ibGl0X2tleVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2JsaXRcbnZhciBjYW1sX2VwaGVfYmxpdF9rZXkgPSBjYW1sX3dlYWtfYmxpdFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZ2V0X2tleVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2dldFxudmFyIGNhbWxfZXBoZV9nZXRfa2V5ID0gY2FtbF93ZWFrX2dldFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZ2V0X2tleV9jb3B5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfZ2V0X2NvcHlcbnZhciBjYW1sX2VwaGVfZ2V0X2tleV9jb3B5ID0gY2FtbF93ZWFrX2dldF9jb3B5XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9jaGVja19rZXlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19jaGVja1xudmFyIGNhbWxfZXBoZV9jaGVja19rZXkgPSBjYW1sX3dlYWtfY2hlY2tcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3NldF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19zZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV9zZXRfa2V5KHgsIGksIHYpIHtcbiAgcmV0dXJuIGNhbWxfd2Vha19zZXQoeCwgaSwgWzAsIHZdKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfdW5zZXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfc2V0XG5mdW5jdGlvbiBjYW1sX2VwaGVfdW5zZXRfa2V5KHgsIGkpIHtcbiAgcmV0dXJuIGNhbWxfd2Vha19zZXQoeCwgaSwgMClcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2JsaXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1ZlcnNpb246ID49IDQuMDNcbmZ1bmN0aW9uIGNhbWxfZXBoZV9ibGl0X2RhdGEoc3JjLCBkc3Qpe1xuICBkc3RbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9IHNyY1tjYW1sX2VwaGVfZGF0YV9vZmZzZXRdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vVmVyc2lvbjogPj0gNC4wM1xuZnVuY3Rpb24gY2FtbF9lcGhlX2dldF9kYXRhKHgpe1xuICBpZih4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gMDtcbiAgZWxzZVxuICAgIHJldHVybiBbMCwgeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9kYXRhX2NvcHlcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuLy9SZXF1aXJlczogY2FtbF9vYmpfZHVwXG4vL1ZlcnNpb246ID49IDQuMDNcbmZ1bmN0aW9uIGNhbWxfZXBoZV9nZXRfZGF0YV9jb3B5KHgpe1xuICBpZih4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gMDtcbiAgZWxzZVxuICAgIHJldHVybiBbMCwgY2FtbF9vYmpfZHVwKHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSldO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfc2V0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuLy9WZXJzaW9uOiA+PSA0LjAzXG5mdW5jdGlvbiBjYW1sX2VwaGVfc2V0X2RhdGEoeCwgZGF0YSl7XG4gIHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9IGRhdGE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfdW5zZXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1ZlcnNpb246ID49IDQuMDNcbmZ1bmN0aW9uIGNhbWxfZXBoZV91bnNldF9kYXRhKHgsIGRhdGEpe1xuICB4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPSB1bmRlZmluZWQ7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfY2hlY2tfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1ZlcnNpb246ID49IDQuMDNcbmZ1bmN0aW9uIGNhbWxfZXBoZV9jaGVja19kYXRhKHgpe1xuICBpZih4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gMDtcbiAgZWxzZVxuICAgIHJldHVybiAxO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cblxuLy9Qcm92aWRlczogY2FtbF9tZDVfY2hhblxuLy9SZXF1aXJlczogY2FtbF9tZDVfc3RyaW5nLCBjYW1sX3N0cmluZ19vZl9hcnJheSxjYW1sX21sX2NoYW5uZWxzXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlLCBjYW1sX2NyZWF0ZV9ieXRlc1xuZnVuY3Rpb24gY2FtbF9tZDVfY2hhbihjaGFuaWQsbGVuKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciBjaGFuX2xlbiA9IGNoYW4uZmlsZS5sZW5ndGgoKTtcbiAgaWYobGVuPDApIGxlbiA9IGNoYW5fbGVuIC0gY2hhbi5vZmZzZXQ7XG4gIGlmKGNoYW4ub2Zmc2V0ICsgbGVuID4gY2hhbl9sZW4pIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUoKTtcbiAgdmFyIGJ1ZiA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbik7XG4gIGNoYW4uZmlsZS5yZWFkKGNoYW4ub2Zmc2V0LGJ1ZiwwLGxlbik7XG4gIHJldHVybiBjYW1sX21kNV9zdHJpbmcoYnVmLDAsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tZDVfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9hcnJheSwgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xudmFyIGNhbWxfbWQ1X3N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gYWRkICh4LCB5KSB7IHJldHVybiAoeCArIHkpIHwgMDsgfVxuICBmdW5jdGlvbiB4eChxLGEsYix4LHMsdCkge1xuICAgIGEgPSBhZGQoYWRkKGEsIHEpLCBhZGQoeCwgdCkpO1xuICAgIHJldHVybiBhZGQoKGEgPDwgcykgfCAoYSA+Pj4gKDMyIC0gcykpLCBiKTtcbiAgfVxuICBmdW5jdGlvbiBmZihhLGIsYyxkLHgscyx0KSB7XG4gICAgcmV0dXJuIHh4KChiICYgYykgfCAoKH5iKSAmIGQpLCBhLCBiLCB4LCBzLCB0KTtcbiAgfVxuICBmdW5jdGlvbiBnZyhhLGIsYyxkLHgscyx0KSB7XG4gICAgcmV0dXJuIHh4KChiICYgZCkgfCAoYyAmICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTtcbiAgfVxuICBmdW5jdGlvbiBoaChhLGIsYyxkLHgscyx0KSB7IHJldHVybiB4eChiIF4gYyBeIGQsIGEsIGIsIHgsIHMsIHQpOyB9XG4gIGZ1bmN0aW9uIGlpKGEsYixjLGQseCxzLHQpIHsgcmV0dXJuIHh4KGMgXiAoYiB8ICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTsgfVxuXG4gIGZ1bmN0aW9uIG1kNShidWZmZXIsIGxlbmd0aCkge1xuICAgIHZhciBpID0gbGVuZ3RoO1xuICAgIGJ1ZmZlcltpID4+IDJdIHw9IDB4ODAgPDwgKDggKiAoaSAmIDMpKTtcbiAgICBmb3IgKGkgPSAoaSAmIH4weDMpICsgODsoaSAmIDB4M0YpIDwgNjAgO2kgKz0gNClcbiAgICAgIGJ1ZmZlclsoaSA+PiAyKSAtIDFdID0gMDtcbiAgICBidWZmZXJbKGkgPj4gMikgLTFdID0gbGVuZ3RoIDw8IDM7XG4gICAgYnVmZmVyW2kgPj4gMl0gPSAobGVuZ3RoID4+IDI5KSAmIDB4MUZGRkZGRkY7XG5cbiAgICB2YXIgdyA9IFsweDY3NDUyMzAxLCAweEVGQ0RBQjg5LCAweDk4QkFEQ0ZFLCAweDEwMzI1NDc2XTtcblxuICAgIGZvcihpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICAgIHZhciBhID0gd1swXSwgYiA9IHdbMV0sIGMgPSB3WzJdLCBkID0gd1szXTtcblxuICAgICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyAwXSwgNywgMHhENzZBQTQ3OCk7XG4gICAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyW2krIDFdLCAxMiwgMHhFOEM3Qjc1Nik7XG4gICAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyW2krIDJdLCAxNywgMHgyNDIwNzBEQik7XG4gICAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyW2krIDNdLCAyMiwgMHhDMUJEQ0VFRSk7XG4gICAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyW2krIDRdLCA3LCAweEY1N0MwRkFGKTtcbiAgICAgIGQgPSBmZihkLCBhLCBiLCBjLCBidWZmZXJbaSsgNV0sIDEyLCAweDQ3ODdDNjJBKTtcbiAgICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXJbaSsgNl0sIDE3LCAweEE4MzA0NjEzKTtcbiAgICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXJbaSsgN10sIDIyLCAweEZENDY5NTAxKTtcbiAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXJbaSsgOF0sIDcsIDB4Njk4MDk4RDgpO1xuICAgICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA5XSwgMTIsIDB4OEI0NEY3QUYpO1xuICAgICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzEwXSwgMTcsIDB4RkZGRjVCQjEpO1xuICAgICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzExXSwgMjIsIDB4ODk1Q0Q3QkUpO1xuICAgICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKzEyXSwgNywgMHg2QjkwMTEyMik7XG4gICAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyW2krMTNdLCAxMiwgMHhGRDk4NzE5Myk7XG4gICAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyW2krMTRdLCAxNywgMHhBNjc5NDM4RSk7XG4gICAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyW2krMTVdLCAyMiwgMHg0OUI0MDgyMSk7XG5cbiAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbaSsgMV0sIDUsIDB4RjYxRTI1NjIpO1xuICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA2XSwgOSwgMHhDMDQwQjM0MCk7XG4gICAgICBjID0gZ2coYywgZCwgYSwgYiwgYnVmZmVyW2krMTFdLCAxNCwgMHgyNjVFNUE1MSk7XG4gICAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyW2krIDBdLCAyMCwgMHhFOUI2QzdBQSk7XG4gICAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyW2krIDVdLCA1LCAweEQ2MkYxMDVEKTtcbiAgICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBidWZmZXJbaSsxMF0sIDksIDB4MDI0NDE0NTMpO1xuICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzE1XSwgMTQsIDB4RDhBMUU2ODEpO1xuICAgICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyA0XSwgMjAsIDB4RTdEM0ZCQzgpO1xuICAgICAgYSA9IGdnKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA5XSwgNSwgMHgyMUUxQ0RFNik7XG4gICAgICBkID0gZ2coZCwgYSwgYiwgYywgYnVmZmVyW2krMTRdLCA5LCAweEMzMzcwN0Q2KTtcbiAgICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbaSsgM10sIDE0LCAweEY0RDUwRDg3KTtcbiAgICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBidWZmZXJbaSsgOF0sIDIwLCAweDQ1NUExNEVEKTtcbiAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbaSsxM10sIDUsIDB4QTlFM0U5MDUpO1xuICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyAyXSwgOSwgMHhGQ0VGQTNGOCk7XG4gICAgICBjID0gZ2coYywgZCwgYSwgYiwgYnVmZmVyW2krIDddLCAxNCwgMHg2NzZGMDJEOSk7XG4gICAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyW2krMTJdLCAyMCwgMHg4RDJBNEM4QSk7XG5cbiAgICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbaSsgNV0sIDQsIDB4RkZGQTM5NDIpO1xuICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA4XSwgMTEsIDB4ODc3MUY2ODEpO1xuICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzExXSwgMTYsIDB4NkQ5RDYxMjIpO1xuICAgICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzE0XSwgMjMsIDB4RkRFNTM4MEMpO1xuICAgICAgYSA9IGhoKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyAxXSwgNCwgMHhBNEJFRUE0NCk7XG4gICAgICBkID0gaGgoZCwgYSwgYiwgYywgYnVmZmVyW2krIDRdLCAxMSwgMHg0QkRFQ0ZBOSk7XG4gICAgICBjID0gaGgoYywgZCwgYSwgYiwgYnVmZmVyW2krIDddLCAxNiwgMHhGNkJCNEI2MCk7XG4gICAgICBiID0gaGgoYiwgYywgZCwgYSwgYnVmZmVyW2krMTBdLCAyMywgMHhCRUJGQkM3MCk7XG4gICAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyW2krMTNdLCA0LCAweDI4OUI3RUM2KTtcbiAgICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXJbaSsgMF0sIDExLCAweEVBQTEyN0ZBKTtcbiAgICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbaSsgM10sIDE2LCAweEQ0RUYzMDg1KTtcbiAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXJbaSsgNl0sIDIzLCAweDA0ODgxRDA1KTtcbiAgICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbaSsgOV0sIDQsIDB4RDlENEQwMzkpO1xuICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKzEyXSwgMTEsIDB4RTZEQjk5RTUpO1xuICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzE1XSwgMTYsIDB4MUZBMjdDRjgpO1xuICAgICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyAyXSwgMjMsIDB4QzRBQzU2NjUpO1xuXG4gICAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyW2krIDBdLCA2LCAweEY0MjkyMjQ0KTtcbiAgICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbaSsgN10sIDEwLCAweDQzMkFGRjk3KTtcbiAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbaSsxNF0sIDE1LCAweEFCOTQyM0E3KTtcbiAgICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbaSsgNV0sIDIxLCAweEZDOTNBMDM5KTtcbiAgICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXJbaSsxMl0sIDYsIDB4NjU1QjU5QzMpO1xuICAgICAgZCA9IGlpKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyAzXSwgMTAsIDB4OEYwQ0NDOTIpO1xuICAgICAgYyA9IGlpKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzEwXSwgMTUsIDB4RkZFRkY0N0QpO1xuICAgICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyAxXSwgMjEsIDB4ODU4NDVERDEpO1xuICAgICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA4XSwgNiwgMHg2RkE4N0U0Rik7XG4gICAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyW2krMTVdLCAxMCwgMHhGRTJDRTZFMCk7XG4gICAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyW2krIDZdLCAxNSwgMHhBMzAxNDMxNCk7XG4gICAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyW2krMTNdLCAyMSwgMHg0RTA4MTFBMSk7XG4gICAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyW2krIDRdLCA2LCAweEY3NTM3RTgyKTtcbiAgICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbaSsxMV0sIDEwLCAweEJEM0FGMjM1KTtcbiAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbaSsgMl0sIDE1LCAweDJBRDdEMkJCKTtcbiAgICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbaSsgOV0sIDIxLCAweEVCODZEMzkxKTtcblxuICAgICAgd1swXSA9IGFkZChhLCB3WzBdKTtcbiAgICAgIHdbMV0gPSBhZGQoYiwgd1sxXSk7XG4gICAgICB3WzJdID0gYWRkKGMsIHdbMl0pO1xuICAgICAgd1szXSA9IGFkZChkLCB3WzNdKTtcbiAgICB9XG5cbiAgICB2YXIgdCA9IG5ldyBBcnJheSgxNik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDQ7IGorKylcbiAgICAgICAgdFtpICogNCArIGpdID0gKHdbaV0gPj4gKDggKiBqKSkgJiAweEZGO1xuICAgIHJldHVybiB0O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChzLCBvZnMsIGxlbikge1xuICAgIC8vIEZJWDogbWF5YmUgd2Ugc2hvdWxkIHBlcmZvcm0gdGhlIGNvbXB1dGF0aW9uIGJ5IGNodW5rIG9mIDY0IGJ5dGVzXG4gICAgLy8gYXMgaW4gaHR0cDovL3d3dy5teWVyc2RhaWx5Lm9yZy9qb3NlcGgvamF2YXNjcmlwdC9tZDUuanNcbiAgICB2YXIgYnVmID0gW107XG4gICAgc3dpdGNoIChzLnQgJiA2KSB7XG4gICAgZGVmYXVsdDpcbiAgICAgIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMocyk7XG4gICAgY2FzZSAwOiAvKiBCWVRFUyAqL1xuICAgICAgdmFyIGIgPSBzLmM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSs9NCkge1xuICAgICAgICB2YXIgaiA9IGkgKyBvZnM7XG4gICAgICAgIGJ1ZltpPj4yXSA9XG4gICAgICAgICAgYi5jaGFyQ29kZUF0KGopIHwgKGIuY2hhckNvZGVBdChqKzEpIDw8IDgpIHxcbiAgICAgICAgICAoYi5jaGFyQ29kZUF0KGorMikgPDwgMTYpIHwgKGIuY2hhckNvZGVBdChqKzMpIDw8IDI0KTtcbiAgICAgIH1cbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIGJ1ZltpPj4yXSB8PSBiLmNoYXJDb2RlQXQoaSArIG9mcykgPDwgKDggKiAoaSAmIDMpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDogLyogQVJSQVkgKi9cbiAgICAgIHZhciBhID0gcy5jO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrPTQpIHtcbiAgICAgICAgdmFyIGogPSBpICsgb2ZzO1xuICAgICAgICBidWZbaT4+Ml0gPSBhW2pdIHwgKGFbaisxXSA8PCA4KSB8IChhW2orMl0gPDwgMTYpIHwgKGFbaiszXSA8PCAyNCk7XG4gICAgICB9XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSBidWZbaT4+Ml0gfD0gYVtpICsgb2ZzXSA8PCAoOCAqIChpICYgMykpO1xuICAgIH1cbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYXJyYXkobWQ1KGJ1ZiwgbGVuKSk7XG4gIH1cbn0gKCk7XG4iLCIvL1RoZSBmb2xsb3dpbmcgYXJlIGRlZmluZWQgaW4gQ3N0cnVjdFxuLy9UaGVyZSBhcmUganVzdCBwcm92aWRlZCBoZXJlIGZvciBjb21wYXRpYmlsaXR5IHJlYXNvbnNcblxuLy9Qcm92aWRlczogY2FtbF9ibGl0X2JpZ3N0cmluZ190b19iaWdzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmFcbi8vV2Vha2RlZlxudmFyIGNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fYmlnc3RyaW5nID0gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYVxuLy9Qcm92aWRlczogY2FtbF9ibGl0X2JpZ3N0cmluZ190b19zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXNcbi8vV2Vha2RlZlxudmFyIGNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fc3RyaW5nID0gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlc1xuLy9Qcm92aWRlczogY2FtbF9ibGl0X3N0cmluZ190b19iaWdzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhXG4vL1dlYWtkZWZcbnZhciBjYW1sX2JsaXRfc3RyaW5nX3RvX2JpZ3N0cmluZyA9IGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhXG4iLG51bGwsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgRGFuaWVsIEMuIEJ1ZW56bGkgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTQgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuZXh0ZXJuYWwgZm9ybWF0X2ludCA6IHN0cmluZyAtPiBpbnQgLT4gc3RyaW5nID0gXCJjYW1sX2Zvcm1hdF9pbnRcIlxuXG5sZXQgZXJyX25vX3ByZWQgPSBcIlUrMDAwMCBoYXMgbm8gcHJlZGVjZXNzb3JcIlxubGV0IGVycl9ub19zdWNjID0gXCJVKzEwRkZGRiBoYXMgbm8gc3VjY2Vzc29yXCJcbmxldCBlcnJfbm90X3N2IGkgPSBmb3JtYXRfaW50IFwiJVhcIiBpIF4gXCIgaXMgbm90IGFuIFVuaWNvZGUgc2NhbGFyIHZhbHVlXCJcbmxldCBlcnJfbm90X2xhdGluMSB1ID0gXCJVK1wiIF4gZm9ybWF0X2ludCBcIiUwNFhcIiB1IF4gXCIgaXMgbm90IGEgbGF0aW4xIGNoYXJhY3RlclwiXG5cbnR5cGUgdCA9IGludFxuXG5sZXQgbWluID0gMHgwMDAwXG5sZXQgbWF4ID0gMHgxMEZGRkZcbmxldCBsb19ib3VuZCA9IDB4RDdGRlxubGV0IGhpX2JvdW5kID0gMHhFMDAwXG5cbmxldCBib20gPSAweEZFRkZcbmxldCByZXAgPSAweEZGRkRcblxubGV0IHN1Y2MgdSA9XG4gIGlmIHUgPSBsb19ib3VuZCB0aGVuIGhpX2JvdW5kIGVsc2VcbiAgaWYgdSA9IG1heCB0aGVuIGludmFsaWRfYXJnIGVycl9ub19zdWNjIGVsc2VcbiAgdSArIDFcblxubGV0IHByZWQgdSA9XG4gIGlmIHUgPSBoaV9ib3VuZCB0aGVuIGxvX2JvdW5kIGVsc2VcbiAgaWYgdSA9IG1pbiB0aGVuIGludmFsaWRfYXJnIGVycl9ub19wcmVkIGVsc2VcbiAgdSAtIDFcblxubGV0IGlzX3ZhbGlkIGkgPSAobWluIDw9IGkgJiYgaSA8PSBsb19ib3VuZCkgfHwgKGhpX2JvdW5kIDw9IGkgJiYgaSA8PSBtYXgpXG5sZXQgb2ZfaW50IGkgPSBpZiBpc192YWxpZCBpIHRoZW4gaSBlbHNlIGludmFsaWRfYXJnIChlcnJfbm90X3N2IGkpXG5leHRlcm5hbCB1bnNhZmVfb2ZfaW50IDogaW50IC0+IHQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCB0b19pbnQgOiB0IC0+IGludCA9IFwiJWlkZW50aXR5XCJcblxubGV0IGlzX2NoYXIgdSA9IHUgPCAyNTZcbmxldCBvZl9jaGFyIGMgPSBDaGFyLmNvZGUgY1xubGV0IHRvX2NoYXIgdSA9XG4gIGlmIHUgPiAyNTUgdGhlbiBpbnZhbGlkX2FyZyAoZXJyX25vdF9sYXRpbjEgdSkgZWxzZVxuICBDaGFyLnVuc2FmZV9jaHIgdVxuXG5sZXQgdW5zYWZlX3RvX2NoYXIgPSBDaGFyLnVuc2FmZV9jaHJcblxubGV0IGVxdWFsIDogaW50IC0+IGludCAtPiBib29sID0gKCA9IClcbmxldCBjb21wYXJlIDogaW50IC0+IGludCAtPiBpbnQgPSBQZXJ2YXNpdmVzLmNvbXBhcmVcbmxldCBoYXNoID0gdG9faW50XG4iLCIjMiBcInN0ZGxpYi9zeXMubWxwXCJcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogV0FSTklORzogc3lzLm1sIGlzIGdlbmVyYXRlZCBmcm9tIHN5cy5tbHAuICBETyBOT1QgRURJVCBzeXMubWwgb3JcbiAgIHlvdXIgY2hhbmdlcyB3aWxsIGJlIGxvc3QuXG4qKVxuXG50eXBlIGJhY2tlbmRfdHlwZSA9XG4gIHwgTmF0aXZlXG4gIHwgQnl0ZWNvZGVcbiAgfCBPdGhlciBvZiBzdHJpbmdcbigqIFN5c3RlbSBpbnRlcmZhY2UgKilcblxuZXh0ZXJuYWwgZ2V0X2NvbmZpZzogdW5pdCAtPiBzdHJpbmcgKiBpbnQgKiBib29sID0gXCJjYW1sX3N5c19nZXRfY29uZmlnXCJcbmV4dGVybmFsIGdldF9hcmd2OiB1bml0IC0+IHN0cmluZyAqIHN0cmluZyBhcnJheSA9IFwiY2FtbF9zeXNfZ2V0X2FyZ3ZcIlxuZXh0ZXJuYWwgYmlnX2VuZGlhbiA6IHVuaXQgLT4gYm9vbCA9IFwiJWJpZ19lbmRpYW5cIlxuZXh0ZXJuYWwgd29yZF9zaXplIDogdW5pdCAtPiBpbnQgPSBcIiV3b3JkX3NpemVcIlxuZXh0ZXJuYWwgaW50X3NpemUgOiB1bml0IC0+IGludCA9IFwiJWludF9zaXplXCJcbmV4dGVybmFsIG1heF93b3NpemUgOiB1bml0IC0+IGludCA9IFwiJW1heF93b3NpemVcIlxuZXh0ZXJuYWwgdW5peCA6IHVuaXQgLT4gYm9vbCA9IFwiJW9zdHlwZV91bml4XCJcbmV4dGVybmFsIHdpbjMyIDogdW5pdCAtPiBib29sID0gXCIlb3N0eXBlX3dpbjMyXCJcbmV4dGVybmFsIGN5Z3dpbiA6IHVuaXQgLT4gYm9vbCA9IFwiJW9zdHlwZV9jeWd3aW5cIlxuZXh0ZXJuYWwgZ2V0X2JhY2tlbmRfdHlwZSA6IHVuaXQgLT4gYmFja2VuZF90eXBlID0gXCIlYmFja2VuZF90eXBlXCJcblxubGV0IChleGVjdXRhYmxlX25hbWUsIGFyZ3YpID0gZ2V0X2FyZ3YoKVxubGV0IChvc190eXBlLCBfLCBfKSA9IGdldF9jb25maWcoKVxubGV0IGJhY2tlbmRfdHlwZSA9IGdldF9iYWNrZW5kX3R5cGUgKClcbmxldCBiaWdfZW5kaWFuID0gYmlnX2VuZGlhbiAoKVxubGV0IHdvcmRfc2l6ZSA9IHdvcmRfc2l6ZSAoKVxubGV0IGludF9zaXplID0gaW50X3NpemUgKClcbmxldCB1bml4ID0gdW5peCAoKVxubGV0IHdpbjMyID0gd2luMzIgKClcbmxldCBjeWd3aW4gPSBjeWd3aW4gKClcbmxldCBtYXhfYXJyYXlfbGVuZ3RoID0gbWF4X3dvc2l6ZSAoKVxubGV0IG1heF9zdHJpbmdfbGVuZ3RoID0gd29yZF9zaXplIC8gOCAqIG1heF9hcnJheV9sZW5ndGggLSAxXG5leHRlcm5hbCBydW50aW1lX3ZhcmlhbnQgOiB1bml0IC0+IHN0cmluZyA9IFwiY2FtbF9ydW50aW1lX3ZhcmlhbnRcIlxuZXh0ZXJuYWwgcnVudGltZV9wYXJhbWV0ZXJzIDogdW5pdCAtPiBzdHJpbmcgPSBcImNhbWxfcnVudGltZV9wYXJhbWV0ZXJzXCJcblxuZXh0ZXJuYWwgZmlsZV9leGlzdHM6IHN0cmluZyAtPiBib29sID0gXCJjYW1sX3N5c19maWxlX2V4aXN0c1wiXG5leHRlcm5hbCBpc19kaXJlY3RvcnkgOiBzdHJpbmcgLT4gYm9vbCA9IFwiY2FtbF9zeXNfaXNfZGlyZWN0b3J5XCJcbmV4dGVybmFsIHJlbW92ZTogc3RyaW5nIC0+IHVuaXQgPSBcImNhbWxfc3lzX3JlbW92ZVwiXG5leHRlcm5hbCByZW5hbWUgOiBzdHJpbmcgLT4gc3RyaW5nIC0+IHVuaXQgPSBcImNhbWxfc3lzX3JlbmFtZVwiXG5leHRlcm5hbCBnZXRlbnY6IHN0cmluZyAtPiBzdHJpbmcgPSBcImNhbWxfc3lzX2dldGVudlwiXG5cbmxldCBnZXRlbnZfb3B0IHMgPVxuICAoKiBUT0RPOiBleHBvc2UgYSBub24tcmFpc2luZyBwcmltaXRpdmUgZGlyZWN0bHkuICopXG4gIHRyeSBTb21lIChnZXRlbnYgcylcbiAgd2l0aCBOb3RfZm91bmQgLT4gTm9uZVxuXG5leHRlcm5hbCBjb21tYW5kOiBzdHJpbmcgLT4gaW50ID0gXCJjYW1sX3N5c19zeXN0ZW1fY29tbWFuZFwiXG5leHRlcm5hbCB0aW1lOiB1bml0IC0+IChmbG9hdCBbQHVuYm94ZWRdKSA9XG4gIFwiY2FtbF9zeXNfdGltZVwiIFwiY2FtbF9zeXNfdGltZV91bmJveGVkXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIGNoZGlyOiBzdHJpbmcgLT4gdW5pdCA9IFwiY2FtbF9zeXNfY2hkaXJcIlxuZXh0ZXJuYWwgZ2V0Y3dkOiB1bml0IC0+IHN0cmluZyA9IFwiY2FtbF9zeXNfZ2V0Y3dkXCJcbmV4dGVybmFsIHJlYWRkaXIgOiBzdHJpbmcgLT4gc3RyaW5nIGFycmF5ID0gXCJjYW1sX3N5c19yZWFkX2RpcmVjdG9yeVwiXG5cbmxldCBpbnRlcmFjdGl2ZSA9IHJlZiBmYWxzZVxuXG50eXBlIHNpZ25hbF9iZWhhdmlvciA9XG4gICAgU2lnbmFsX2RlZmF1bHRcbiAgfCBTaWduYWxfaWdub3JlXG4gIHwgU2lnbmFsX2hhbmRsZSBvZiAoaW50IC0+IHVuaXQpXG5cbmV4dGVybmFsIHNpZ25hbCA6IGludCAtPiBzaWduYWxfYmVoYXZpb3IgLT4gc2lnbmFsX2JlaGF2aW9yXG4gICAgICAgICAgICAgICAgPSBcImNhbWxfaW5zdGFsbF9zaWduYWxfaGFuZGxlclwiXG5cbmxldCBzZXRfc2lnbmFsIHNpZ19udW0gc2lnX2JlaCA9IGlnbm9yZShzaWduYWwgc2lnX251bSBzaWdfYmVoKVxuXG5sZXQgc2lnYWJydCA9IC0xXG5sZXQgc2lnYWxybSA9IC0yXG5sZXQgc2lnZnBlID0gLTNcbmxldCBzaWdodXAgPSAtNFxubGV0IHNpZ2lsbCA9IC01XG5sZXQgc2lnaW50ID0gLTZcbmxldCBzaWdraWxsID0gLTdcbmxldCBzaWdwaXBlID0gLThcbmxldCBzaWdxdWl0ID0gLTlcbmxldCBzaWdzZWd2ID0gLTEwXG5sZXQgc2lndGVybSA9IC0xMVxubGV0IHNpZ3VzcjEgPSAtMTJcbmxldCBzaWd1c3IyID0gLTEzXG5sZXQgc2lnY2hsZCA9IC0xNFxubGV0IHNpZ2NvbnQgPSAtMTVcbmxldCBzaWdzdG9wID0gLTE2XG5sZXQgc2lndHN0cCA9IC0xN1xubGV0IHNpZ3R0aW4gPSAtMThcbmxldCBzaWd0dG91ID0gLTE5XG5sZXQgc2lndnRhbHJtID0gLTIwXG5sZXQgc2lncHJvZiA9IC0yMVxubGV0IHNpZ2J1cyA9IC0yMlxubGV0IHNpZ3BvbGwgPSAtMjNcbmxldCBzaWdzeXMgPSAtMjRcbmxldCBzaWd0cmFwID0gLTI1XG5sZXQgc2lndXJnID0gLTI2XG5sZXQgc2lneGNwdSA9IC0yN1xubGV0IHNpZ3hmc3ogPSAtMjhcblxuZXhjZXB0aW9uIEJyZWFrXG5cbmxldCBjYXRjaF9icmVhayBvbiA9XG4gIGlmIG9uIHRoZW5cbiAgICBzZXRfc2lnbmFsIHNpZ2ludCAoU2lnbmFsX2hhbmRsZShmdW4gXyAtPiByYWlzZSBCcmVhaykpXG4gIGVsc2VcbiAgICBzZXRfc2lnbmFsIHNpZ2ludCBTaWduYWxfZGVmYXVsdFxuXG5cbmV4dGVybmFsIGVuYWJsZV9ydW50aW1lX3dhcm5pbmdzOiBib29sIC0+IHVuaXQgPVxuICBcImNhbWxfbWxfZW5hYmxlX3J1bnRpbWVfd2FybmluZ3NcIlxuZXh0ZXJuYWwgcnVudGltZV93YXJuaW5nc19lbmFibGVkOiB1bml0IC0+IGJvb2wgPVxuICBcImNhbWxfbWxfcnVudGltZV93YXJuaW5nc19lbmFibGVkXCJcblxuKCogVGhlIHZlcnNpb24gc3RyaW5nIGlzIGZvdW5kIGluIGZpbGUgLi4vVkVSU0lPTiAqKVxuXG5sZXQgb2NhbWxfdmVyc2lvbiA9IFwiNC4wNi4wXCJcblxuKCogT3B0aW1pemF0aW9uICopXG5cbmV4dGVybmFsIG9wYXF1ZV9pZGVudGl0eSA6ICdhIC0+ICdhID0gXCIlb3BhcXVlXCJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtJbnQ2NF06IDY0LWJpdCBpbnRlZ2VycyAqKVxuXG5leHRlcm5hbCBuZWcgOiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X25lZ1wiXG5leHRlcm5hbCBhZGQgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X2FkZFwiXG5leHRlcm5hbCBzdWIgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X3N1YlwiXG5leHRlcm5hbCBtdWwgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X211bFwiXG5leHRlcm5hbCBkaXYgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X2RpdlwiXG5leHRlcm5hbCByZW0gOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X21vZFwiXG5leHRlcm5hbCBsb2dhbmQgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X2FuZFwiXG5leHRlcm5hbCBsb2dvciA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfb3JcIlxuZXh0ZXJuYWwgbG9neG9yIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF94b3JcIlxuZXh0ZXJuYWwgc2hpZnRfbGVmdCA6IGludDY0IC0+IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X2xzbFwiXG5leHRlcm5hbCBzaGlmdF9yaWdodCA6IGludDY0IC0+IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X2FzclwiXG5leHRlcm5hbCBzaGlmdF9yaWdodF9sb2dpY2FsIDogaW50NjQgLT4gaW50IC0+IGludDY0ID0gXCIlaW50NjRfbHNyXCJcbmV4dGVybmFsIG9mX2ludCA6IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X29mX2ludFwiXG5leHRlcm5hbCB0b19pbnQgOiBpbnQ2NCAtPiBpbnQgPSBcIiVpbnQ2NF90b19pbnRcIlxuZXh0ZXJuYWwgb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQ2NFxuICA9IFwiY2FtbF9pbnQ2NF9vZl9mbG9hdFwiIFwiY2FtbF9pbnQ2NF9vZl9mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRvX2Zsb2F0IDogaW50NjQgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50NjRfdG9fZmxvYXRcIiBcImNhbWxfaW50NjRfdG9fZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBvZl9pbnQzMiA6IGludDMyIC0+IGludDY0ID0gXCIlaW50NjRfb2ZfaW50MzJcIlxuZXh0ZXJuYWwgdG9faW50MzIgOiBpbnQ2NCAtPiBpbnQzMiA9IFwiJWludDY0X3RvX2ludDMyXCJcbmV4dGVybmFsIG9mX25hdGl2ZWludCA6IG5hdGl2ZWludCAtPiBpbnQ2NCA9IFwiJWludDY0X29mX25hdGl2ZWludFwiXG5leHRlcm5hbCB0b19uYXRpdmVpbnQgOiBpbnQ2NCAtPiBuYXRpdmVpbnQgPSBcIiVpbnQ2NF90b19uYXRpdmVpbnRcIlxuXG5sZXQgemVybyA9IDBMXG5sZXQgb25lID0gMUxcbmxldCBtaW51c19vbmUgPSAtMUxcbmxldCBzdWNjIG4gPSBhZGQgbiAxTFxubGV0IHByZWQgbiA9IHN1YiBuIDFMXG5sZXQgYWJzIG4gPSBpZiBuID49IDBMIHRoZW4gbiBlbHNlIG5lZyBuXG5sZXQgbWluX2ludCA9IDB4ODAwMDAwMDAwMDAwMDAwMExcbmxldCBtYXhfaW50ID0gMHg3RkZGRkZGRkZGRkZGRkZGTFxubGV0IGxvZ25vdCBuID0gbG9neG9yIG4gKC0xTClcblxuZXh0ZXJuYWwgZm9ybWF0IDogc3RyaW5nIC0+IGludDY0IC0+IHN0cmluZyA9IFwiY2FtbF9pbnQ2NF9mb3JtYXRcIlxubGV0IHRvX3N0cmluZyBuID0gZm9ybWF0IFwiJWRcIiBuXG5cbmV4dGVybmFsIG9mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQ2NCA9IFwiY2FtbF9pbnQ2NF9vZl9zdHJpbmdcIlxuXG5sZXQgb2Zfc3RyaW5nX29wdCBzID1cbiAgKCogVE9ETzogZXhwb3NlIGEgbm9uLXJhaXNpbmcgcHJpbWl0aXZlIGRpcmVjdGx5LiAqKVxuICB0cnkgU29tZSAob2Zfc3RyaW5nIHMpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxuXG5cbmV4dGVybmFsIGJpdHNfb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQ2NFxuICA9IFwiY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0XCIgXCJjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbG9hdF9vZl9iaXRzIDogaW50NjQgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c1wiIFwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzX3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG50eXBlIHQgPSBpbnQ2NFxuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gUGVydmFzaXZlcy5jb21wYXJlIHggeVxubGV0IGVxdWFsICh4OiB0KSAoeTogdCkgPSBjb21wYXJlIHggeSA9IDBcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogVGhlIHJ1bi10aW1lIGxpYnJhcnkgZm9yIGxleGVycyBnZW5lcmF0ZWQgYnkgY2FtbGxleCAqKVxuXG50eXBlIHBvc2l0aW9uID0ge1xuICBwb3NfZm5hbWUgOiBzdHJpbmc7XG4gIHBvc19sbnVtIDogaW50O1xuICBwb3NfYm9sIDogaW50O1xuICBwb3NfY251bSA6IGludDtcbn1cblxubGV0IGR1bW15X3BvcyA9IHtcbiAgcG9zX2ZuYW1lID0gXCJcIjtcbiAgcG9zX2xudW0gPSAwO1xuICBwb3NfYm9sID0gMDtcbiAgcG9zX2NudW0gPSAtMTtcbn1cblxudHlwZSBsZXhidWYgPVxuICB7IHJlZmlsbF9idWZmIDogbGV4YnVmIC0+IHVuaXQ7XG4gICAgbXV0YWJsZSBsZXhfYnVmZmVyIDogYnl0ZXM7XG4gICAgbXV0YWJsZSBsZXhfYnVmZmVyX2xlbiA6IGludDtcbiAgICBtdXRhYmxlIGxleF9hYnNfcG9zIDogaW50O1xuICAgIG11dGFibGUgbGV4X3N0YXJ0X3BvcyA6IGludDtcbiAgICBtdXRhYmxlIGxleF9jdXJyX3BvcyA6IGludDtcbiAgICBtdXRhYmxlIGxleF9sYXN0X3BvcyA6IGludDtcbiAgICBtdXRhYmxlIGxleF9sYXN0X2FjdGlvbiA6IGludDtcbiAgICBtdXRhYmxlIGxleF9lb2ZfcmVhY2hlZCA6IGJvb2w7XG4gICAgbXV0YWJsZSBsZXhfbWVtIDogaW50IGFycmF5O1xuICAgIG11dGFibGUgbGV4X3N0YXJ0X3AgOiBwb3NpdGlvbjtcbiAgICBtdXRhYmxlIGxleF9jdXJyX3AgOiBwb3NpdGlvbjtcbiAgfVxuXG50eXBlIGxleF90YWJsZXMgPVxuICB7IGxleF9iYXNlOiBzdHJpbmc7XG4gICAgbGV4X2JhY2t0cms6IHN0cmluZztcbiAgICBsZXhfZGVmYXVsdDogc3RyaW5nO1xuICAgIGxleF90cmFuczogc3RyaW5nO1xuICAgIGxleF9jaGVjazogc3RyaW5nO1xuICAgIGxleF9iYXNlX2NvZGUgOiBzdHJpbmc7XG4gICAgbGV4X2JhY2t0cmtfY29kZSA6IHN0cmluZztcbiAgICBsZXhfZGVmYXVsdF9jb2RlIDogc3RyaW5nO1xuICAgIGxleF90cmFuc19jb2RlIDogc3RyaW5nO1xuICAgIGxleF9jaGVja19jb2RlIDogc3RyaW5nO1xuICAgIGxleF9jb2RlOiBzdHJpbmc7fVxuXG5leHRlcm5hbCBjX2VuZ2luZSA6IGxleF90YWJsZXMgLT4gaW50IC0+IGxleGJ1ZiAtPiBpbnQgPSBcImNhbWxfbGV4X2VuZ2luZVwiXG5leHRlcm5hbCBjX25ld19lbmdpbmUgOiBsZXhfdGFibGVzIC0+IGludCAtPiBsZXhidWYgLT4gaW50XG4gICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbmV3X2xleF9lbmdpbmVcIlxuXG5sZXQgZW5naW5lIHRibCBzdGF0ZSBidWYgPVxuICBsZXQgcmVzdWx0ID0gY19lbmdpbmUgdGJsIHN0YXRlIGJ1ZiBpblxuICBpZiByZXN1bHQgPj0gMCB0aGVuIGJlZ2luXG4gICAgYnVmLmxleF9zdGFydF9wIDwtIGJ1Zi5sZXhfY3Vycl9wO1xuICAgIGJ1Zi5sZXhfY3Vycl9wIDwtIHtidWYubGV4X2N1cnJfcFxuICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHBvc19jbnVtID0gYnVmLmxleF9hYnNfcG9zICsgYnVmLmxleF9jdXJyX3Bvc307XG4gIGVuZDtcbiAgcmVzdWx0XG5cblxubGV0IG5ld19lbmdpbmUgdGJsIHN0YXRlIGJ1ZiA9XG4gIGxldCByZXN1bHQgPSBjX25ld19lbmdpbmUgdGJsIHN0YXRlIGJ1ZiBpblxuICBpZiByZXN1bHQgPj0gMCB0aGVuIGJlZ2luXG4gICAgYnVmLmxleF9zdGFydF9wIDwtIGJ1Zi5sZXhfY3Vycl9wO1xuICAgIGJ1Zi5sZXhfY3Vycl9wIDwtIHtidWYubGV4X2N1cnJfcFxuICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHBvc19jbnVtID0gYnVmLmxleF9hYnNfcG9zICsgYnVmLmxleF9jdXJyX3Bvc307XG4gIGVuZDtcbiAgcmVzdWx0XG5cblxubGV0IGxleF9yZWZpbGwgcmVhZF9mdW4gYXV4X2J1ZmZlciBsZXhidWYgPVxuICBsZXQgcmVhZCA9XG4gICAgcmVhZF9mdW4gYXV4X2J1ZmZlciAoQnl0ZXMubGVuZ3RoIGF1eF9idWZmZXIpIGluXG4gIGxldCBuID1cbiAgICBpZiByZWFkID4gMFxuICAgIHRoZW4gcmVhZFxuICAgIGVsc2UgKGxleGJ1Zi5sZXhfZW9mX3JlYWNoZWQgPC0gdHJ1ZTsgMCkgaW5cbiAgKCogQ3VycmVudCBzdGF0ZSBvZiB0aGUgYnVmZmVyOlxuICAgICAgICA8LS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0+XG4gICAgICAgIHwgIGp1bmsgfCAgICAgIHZhbGlkIGRhdGEgICAgIHwgICBqdW5rICAgIHxcbiAgICAgICAgXiAgICAgICBeICAgICAgICAgICAgICAgICAgICAgXiAgICAgICAgICAgXlxuICAgICAgICAwICAgIHN0YXJ0X3BvcyAgICAgICAgICAgICBidWZmZXJfZW5kICAgIEJ5dGVzLmxlbmd0aCBidWZmZXJcbiAgKilcbiAgaWYgbGV4YnVmLmxleF9idWZmZXJfbGVuICsgbiA+IEJ5dGVzLmxlbmd0aCBsZXhidWYubGV4X2J1ZmZlciB0aGVuIGJlZ2luXG4gICAgKCogVGhlcmUgaXMgbm90IGVub3VnaCBzcGFjZSBhdCB0aGUgZW5kIG9mIHRoZSBidWZmZXIgKilcbiAgICBpZiBsZXhidWYubGV4X2J1ZmZlcl9sZW4gLSBsZXhidWYubGV4X3N0YXJ0X3BvcyArIG5cbiAgICAgICA8PSBCeXRlcy5sZW5ndGggbGV4YnVmLmxleF9idWZmZXJcbiAgICB0aGVuIGJlZ2luXG4gICAgICAoKiBCdXQgdGhlcmUgaXMgZW5vdWdoIHNwYWNlIGlmIHdlIHJlY2xhaW0gdGhlIGp1bmsgYXQgdGhlIGJlZ2lubmluZ1xuICAgICAgICAgb2YgdGhlIGJ1ZmZlciAqKVxuICAgICAgQnl0ZXMuYmxpdCBsZXhidWYubGV4X2J1ZmZlciBsZXhidWYubGV4X3N0YXJ0X3Bvc1xuICAgICAgICAgICAgICAgICAgbGV4YnVmLmxleF9idWZmZXIgMFxuICAgICAgICAgICAgICAgICAgKGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zKVxuICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAoKiBXZSBtdXN0IGdyb3cgdGhlIGJ1ZmZlci4gIERvdWJsaW5nIGl0cyBzaXplIHdpbGwgcHJvdmlkZSBlbm91Z2hcbiAgICAgICAgIHNwYWNlIHNpbmNlIG4gPD0gU3RyaW5nLmxlbmd0aCBhdXhfYnVmZmVyIDw9IFN0cmluZy5sZW5ndGggYnVmZmVyLlxuICAgICAgICAgV2F0Y2ggb3V0IGZvciBzdHJpbmcgbGVuZ3RoIG92ZXJmbG93LCB0aG91Z2guICopXG4gICAgICBsZXQgbmV3bGVuID1cbiAgICAgICAgbWluICgyICogQnl0ZXMubGVuZ3RoIGxleGJ1Zi5sZXhfYnVmZmVyKSBTeXMubWF4X3N0cmluZ19sZW5ndGggaW5cbiAgICAgIGlmIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zICsgbiA+IG5ld2xlblxuICAgICAgdGhlbiBmYWlsd2l0aCBcIkxleGluZy5sZXhfcmVmaWxsOiBjYW5ub3QgZ3JvdyBidWZmZXJcIjtcbiAgICAgIGxldCBuZXdidWYgPSBCeXRlcy5jcmVhdGUgbmV3bGVuIGluXG4gICAgICAoKiBDb3B5IHRoZSB2YWxpZCBkYXRhIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5ldyBidWZmZXIgKilcbiAgICAgIEJ5dGVzLmJsaXQgbGV4YnVmLmxleF9idWZmZXIgbGV4YnVmLmxleF9zdGFydF9wb3NcbiAgICAgICAgICAgICAgICAgIG5ld2J1ZiAwXG4gICAgICAgICAgICAgICAgICAobGV4YnVmLmxleF9idWZmZXJfbGVuIC0gbGV4YnVmLmxleF9zdGFydF9wb3MpO1xuICAgICAgbGV4YnVmLmxleF9idWZmZXIgPC0gbmV3YnVmXG4gICAgZW5kO1xuICAgICgqIFJlYWxsb2NhdGlvbiBvciBub3QsIHdlIGhhdmUgc2hpZnRlZCB0aGUgZGF0YSBsZWZ0IGJ5XG4gICAgICAgc3RhcnRfcG9zIGNoYXJhY3RlcnM7IHVwZGF0ZSB0aGUgcG9zaXRpb25zICopXG4gICAgbGV0IHMgPSBsZXhidWYubGV4X3N0YXJ0X3BvcyBpblxuICAgIGxleGJ1Zi5sZXhfYWJzX3BvcyA8LSBsZXhidWYubGV4X2Fic19wb3MgKyBzO1xuICAgIGxleGJ1Zi5sZXhfY3Vycl9wb3MgPC0gbGV4YnVmLmxleF9jdXJyX3BvcyAtIHM7XG4gICAgbGV4YnVmLmxleF9zdGFydF9wb3MgPC0gMDtcbiAgICBsZXhidWYubGV4X2xhc3RfcG9zIDwtIGxleGJ1Zi5sZXhfbGFzdF9wb3MgLSBzO1xuICAgIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiA8LSBsZXhidWYubGV4X2J1ZmZlcl9sZW4gLSBzIDtcbiAgICBsZXQgdCA9IGxleGJ1Zi5sZXhfbWVtIGluXG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCB0LTEgZG9cbiAgICAgIGxldCB2ID0gdC4oaSkgaW5cbiAgICAgIGlmIHYgPj0gMCB0aGVuXG4gICAgICAgIHQuKGkpIDwtIHYtc1xuICAgIGRvbmVcbiAgZW5kO1xuICAoKiBUaGVyZSBpcyBub3cgZW5vdWdoIHNwYWNlIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciAqKVxuICBCeXRlcy5ibGl0IGF1eF9idWZmZXIgMCBsZXhidWYubGV4X2J1ZmZlciBsZXhidWYubGV4X2J1ZmZlcl9sZW4gbjtcbiAgbGV4YnVmLmxleF9idWZmZXJfbGVuIDwtIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiArIG5cblxubGV0IHplcm9fcG9zID0ge1xuICBwb3NfZm5hbWUgPSBcIlwiO1xuICBwb3NfbG51bSA9IDE7XG4gIHBvc19ib2wgPSAwO1xuICBwb3NfY251bSA9IDA7XG59XG5cbmxldCBmcm9tX2Z1bmN0aW9uIGYgPVxuICB7IHJlZmlsbF9idWZmID0gbGV4X3JlZmlsbCBmIChCeXRlcy5jcmVhdGUgNTEyKTtcbiAgICBsZXhfYnVmZmVyID0gQnl0ZXMuY3JlYXRlIDEwMjQ7XG4gICAgbGV4X2J1ZmZlcl9sZW4gPSAwO1xuICAgIGxleF9hYnNfcG9zID0gMDtcbiAgICBsZXhfc3RhcnRfcG9zID0gMDtcbiAgICBsZXhfY3Vycl9wb3MgPSAwO1xuICAgIGxleF9sYXN0X3BvcyA9IDA7XG4gICAgbGV4X2xhc3RfYWN0aW9uID0gMDtcbiAgICBsZXhfbWVtID0gW3x8XTtcbiAgICBsZXhfZW9mX3JlYWNoZWQgPSBmYWxzZTtcbiAgICBsZXhfc3RhcnRfcCA9IHplcm9fcG9zO1xuICAgIGxleF9jdXJyX3AgPSB6ZXJvX3BvcztcbiAgfVxuXG5sZXQgZnJvbV9jaGFubmVsIGljID1cbiAgZnJvbV9mdW5jdGlvbiAoZnVuIGJ1ZiBuIC0+IGlucHV0IGljIGJ1ZiAwIG4pXG5cbmxldCBmcm9tX3N0cmluZyBzID1cbiAgeyByZWZpbGxfYnVmZiA9IChmdW4gbGV4YnVmIC0+IGxleGJ1Zi5sZXhfZW9mX3JlYWNoZWQgPC0gdHJ1ZSk7XG4gICAgbGV4X2J1ZmZlciA9IEJ5dGVzLm9mX3N0cmluZyBzOyAoKiBoYXZlIHRvIG1ha2UgYSBjb3B5IGZvciBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHVuc2FmZS1zdHJpbmcgbW9kZSAqKVxuICAgIGxleF9idWZmZXJfbGVuID0gU3RyaW5nLmxlbmd0aCBzO1xuICAgIGxleF9hYnNfcG9zID0gMDtcbiAgICBsZXhfc3RhcnRfcG9zID0gMDtcbiAgICBsZXhfY3Vycl9wb3MgPSAwO1xuICAgIGxleF9sYXN0X3BvcyA9IDA7XG4gICAgbGV4X2xhc3RfYWN0aW9uID0gMDtcbiAgICBsZXhfbWVtID0gW3x8XTtcbiAgICBsZXhfZW9mX3JlYWNoZWQgPSB0cnVlO1xuICAgIGxleF9zdGFydF9wID0gemVyb19wb3M7XG4gICAgbGV4X2N1cnJfcCA9IHplcm9fcG9zO1xuICB9XG5cbmxldCBsZXhlbWUgbGV4YnVmID1cbiAgbGV0IGxlbiA9IGxleGJ1Zi5sZXhfY3Vycl9wb3MgLSBsZXhidWYubGV4X3N0YXJ0X3BvcyBpblxuICBCeXRlcy5zdWJfc3RyaW5nIGxleGJ1Zi5sZXhfYnVmZmVyIGxleGJ1Zi5sZXhfc3RhcnRfcG9zIGxlblxuXG5sZXQgc3ViX2xleGVtZSBsZXhidWYgaTEgaTIgPVxuICBsZXQgbGVuID0gaTItaTEgaW5cbiAgQnl0ZXMuc3ViX3N0cmluZyBsZXhidWYubGV4X2J1ZmZlciBpMSBsZW5cblxubGV0IHN1Yl9sZXhlbWVfb3B0IGxleGJ1ZiBpMSBpMiA9XG4gIGlmIGkxID49IDAgdGhlbiBiZWdpblxuICAgIGxldCBsZW4gPSBpMi1pMSBpblxuICAgIFNvbWUgKEJ5dGVzLnN1Yl9zdHJpbmcgbGV4YnVmLmxleF9idWZmZXIgaTEgbGVuKVxuICBlbmQgZWxzZSBiZWdpblxuICAgIE5vbmVcbiAgZW5kXG5cbmxldCBzdWJfbGV4ZW1lX2NoYXIgbGV4YnVmIGkgPSBCeXRlcy5nZXQgbGV4YnVmLmxleF9idWZmZXIgaVxuXG5sZXQgc3ViX2xleGVtZV9jaGFyX29wdCBsZXhidWYgaSA9XG4gIGlmIGkgPj0gMCB0aGVuXG4gICAgU29tZSAoQnl0ZXMuZ2V0IGxleGJ1Zi5sZXhfYnVmZmVyIGkpXG4gIGVsc2VcbiAgICBOb25lXG5cblxubGV0IGxleGVtZV9jaGFyIGxleGJ1ZiBpID1cbiAgQnl0ZXMuZ2V0IGxleGJ1Zi5sZXhfYnVmZmVyIChsZXhidWYubGV4X3N0YXJ0X3BvcyArIGkpXG5cbmxldCBsZXhlbWVfc3RhcnQgbGV4YnVmID0gbGV4YnVmLmxleF9zdGFydF9wLnBvc19jbnVtXG5sZXQgbGV4ZW1lX2VuZCBsZXhidWYgPSBsZXhidWYubGV4X2N1cnJfcC5wb3NfY251bVxuXG5sZXQgbGV4ZW1lX3N0YXJ0X3AgbGV4YnVmID0gbGV4YnVmLmxleF9zdGFydF9wXG5sZXQgbGV4ZW1lX2VuZF9wIGxleGJ1ZiA9IGxleGJ1Zi5sZXhfY3Vycl9wXG5cbmxldCBuZXdfbGluZSBsZXhidWYgPVxuICBsZXQgbGNwID0gbGV4YnVmLmxleF9jdXJyX3AgaW5cbiAgbGV4YnVmLmxleF9jdXJyX3AgPC0geyBsY3Agd2l0aFxuICAgIHBvc19sbnVtID0gbGNwLnBvc19sbnVtICsgMTtcbiAgICBwb3NfYm9sID0gbGNwLnBvc19jbnVtO1xuICB9XG5cblxuXG4oKiBEaXNjYXJkIGRhdGEgbGVmdCBpbiBsZXhlciBidWZmZXIuICopXG5cbmxldCBmbHVzaF9pbnB1dCBsYiA9XG4gIGxiLmxleF9jdXJyX3BvcyA8LSAwO1xuICBsYi5sZXhfYWJzX3BvcyA8LSAwO1xuICBsYi5sZXhfY3Vycl9wIDwtIHtsYi5sZXhfY3Vycl9wIHdpdGggcG9zX2NudW0gPSAwfTtcbiAgbGIubGV4X2J1ZmZlcl9sZW4gPC0gMDtcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICBCZW5vaXQgVmF1Z29uLCBFTlNUQSAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTQgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3NcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgKCogVG9vbHMgdG8gbWFuaXB1bGF0ZSBzY2FubmluZyBzZXQgb2YgY2hhcnMgKHNlZSAlWy4uLl0pICopXG5cbnR5cGUgbXV0YWJsZV9jaGFyX3NldCA9IGJ5dGVzXG5cbigqIENyZWF0ZSBhIGZyZXNoLCBlbXB0eSwgbXV0YWJsZSBjaGFyIHNldC4gKilcbmxldCBjcmVhdGVfY2hhcl9zZXQgKCkgPSBCeXRlcy5tYWtlIDMyICdcXDAwMCdcblxuKCogQWRkIGEgY2hhciBpbiBhIG11dGFibGUgY2hhciBzZXQuICopXG5sZXQgYWRkX2luX2NoYXJfc2V0IGNoYXJfc2V0IGMgPVxuICBsZXQgaW5kID0gaW50X29mX2NoYXIgYyBpblxuICBsZXQgc3RyX2luZCA9IGluZCBsc3IgMyBhbmQgbWFzayA9IDEgbHNsIChpbmQgbGFuZCAwYjExMSkgaW5cbiAgQnl0ZXMuc2V0IGNoYXJfc2V0IHN0cl9pbmRcbiAgICAoY2hhcl9vZl9pbnQgKGludF9vZl9jaGFyIChCeXRlcy5nZXQgY2hhcl9zZXQgc3RyX2luZCkgbG9yIG1hc2spKVxuXG5sZXQgZnJlZXplX2NoYXJfc2V0IGNoYXJfc2V0ID1cbiAgQnl0ZXMudG9fc3RyaW5nIGNoYXJfc2V0XG5cbigqIENvbXB1dGUgdGhlIGNvbXBsZW1lbnQgb2YgYSBjaGFyIHNldC4gKilcbmxldCByZXZfY2hhcl9zZXQgY2hhcl9zZXQgPVxuICBsZXQgY2hhcl9zZXQnID0gY3JlYXRlX2NoYXJfc2V0ICgpIGluXG4gIGZvciBpID0gMCB0byAzMSBkb1xuICAgIEJ5dGVzLnNldCBjaGFyX3NldCcgaVxuICAgICAgKGNoYXJfb2ZfaW50IChpbnRfb2ZfY2hhciAoU3RyaW5nLmdldCBjaGFyX3NldCBpKSBseG9yIDB4RkYpKTtcbiAgZG9uZTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBjaGFyX3NldCdcblxuKCogUmV0dXJuIHRydWUgaWYgYSBgYycgaXMgaW4gYGNoYXJfc2V0Jy4gKilcbmxldCBpc19pbl9jaGFyX3NldCBjaGFyX3NldCBjID1cbiAgbGV0IGluZCA9IGludF9vZl9jaGFyIGMgaW5cbiAgbGV0IHN0cl9pbmQgPSBpbmQgbHNyIDMgYW5kIG1hc2sgPSAxIGxzbCAoaW5kIGxhbmQgMGIxMTEpIGluXG4gIChpbnRfb2ZfY2hhciAoU3RyaW5nLmdldCBjaGFyX3NldCBzdHJfaW5kKSBsYW5kIG1hc2spIDw+IDBcblxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICgqIElnbm9yZWQgcGFyYW0gY29udmVyc2lvbiAqKVxuXG4oKiBHQURUIHVzZWQgdG8gYWJzdHJhY3QgYW4gZXhpc3RlbnRpYWwgdHlwZSBwYXJhbWV0ZXIuICopXG4oKiBTZWUgcGFyYW1fZm9ybWF0X29mX2lnbm9yZWRfZm9ybWF0LiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgcGFyYW1fZm9ybWF0X2ViYiA9IFBhcmFtX2Zvcm1hdF9FQkIgOlxuICAgICgneCAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgcGFyYW1fZm9ybWF0X2ViYlxuXG4oKiBDb21wdXRlIGEgcGFkZGluZyBhc3NvY2lhdGVkIHRvIGEgcGFkX29wdGlvbiAoc2VlIFwiJV80MmRcIikuICopXG5sZXQgcGFkX29mX3BhZF9vcHQgcGFkX29wdCA9IG1hdGNoIHBhZF9vcHQgd2l0aFxuICB8IE5vbmUgLT4gTm9fcGFkZGluZ1xuICB8IFNvbWUgd2lkdGggLT4gTGl0X3BhZGRpbmcgKFJpZ2h0LCB3aWR0aClcblxuKCogQ29tcHV0ZSBhIHByZWNpc2lvbiBhc3NvY2lhdGVkIHRvIGEgcHJlY19vcHRpb24gKHNlZSBcIiVfLjQyZlwiKS4gKilcbmxldCBwcmVjX29mX3ByZWNfb3B0IHByZWNfb3B0ID0gbWF0Y2ggcHJlY19vcHQgd2l0aFxuICB8IE5vbmUgLT4gTm9fcHJlY2lzaW9uXG4gIHwgU29tZSBuZGVjIC0+IExpdF9wcmVjaXNpb24gbmRlY1xuXG4oKiBUdXJuIGFuIGlnbm9yZWQgcGFyYW0gaW50byBpdHMgZXF1aXZhbGVudCBub3QtaWdub3JlZCBmb3JtYXQgbm9kZS4gKilcbigqIFVzZWQgZm9yIGZvcm1hdCBwcmV0dHktcHJpbnRpbmcgYW5kIFNjYW5mLiAqKVxubGV0IHBhcmFtX2Zvcm1hdF9vZl9pZ25vcmVkX2Zvcm1hdCA6IHR5cGUgYSBiIGMgZCBlIGYgeCB5IC5cbiAgICAoYSwgYiwgYywgZCwgeSwgeCkgaWdub3JlZCAtPiAoeCwgYiwgYywgeSwgZSwgZikgZm10IC0+XG4gICAgICAoYSwgYiwgYywgZCwgZSwgZikgcGFyYW1fZm9ybWF0X2ViYiA9XG5mdW4gaWduIGZtdCAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfY2hhciAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKENoYXIgZm10KVxuICB8IElnbm9yZWRfY2FtbF9jaGFyIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoQ2FtbF9jaGFyIGZtdClcbiAgfCBJZ25vcmVkX3N0cmluZyBwYWRfb3B0IC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoU3RyaW5nIChwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBmbXQpKVxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgcGFkX29wdCAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKENhbWxfc3RyaW5nIChwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBmbXQpKVxuICB8IElnbm9yZWRfaW50IChpY29udiwgcGFkX29wdCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChJbnQgKGljb252LCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBOb19wcmVjaXNpb24sIGZtdCkpXG4gIHwgSWdub3JlZF9pbnQzMiAoaWNvbnYsIHBhZF9vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKEludDMyIChpY29udiwgcGFkX29mX3BhZF9vcHQgcGFkX29wdCwgTm9fcHJlY2lzaW9uLCBmbXQpKVxuICB8IElnbm9yZWRfbmF0aXZlaW50IChpY29udiwgcGFkX29wdCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCXG4gICAgICAoTmF0aXZlaW50IChpY29udiwgcGFkX29mX3BhZF9vcHQgcGFkX29wdCwgTm9fcHJlY2lzaW9uLCBmbXQpKVxuICB8IElnbm9yZWRfaW50NjQgKGljb252LCBwYWRfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkJcbiAgICAgIChJbnQ2NCAoaWNvbnYsIHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIE5vX3ByZWNpc2lvbiwgZm10KSlcbiAgfCBJZ25vcmVkX2Zsb2F0IChwYWRfb3B0LCBwcmVjX29wdCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCXG4gICAgICAoRmxvYXQgKEZsb2F0X2YsIHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIHByZWNfb2ZfcHJlY19vcHQgcHJlY19vcHQsIGZtdCkpXG4gIHwgSWdub3JlZF9ib29sIHBhZF9vcHQgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChCb29sIChwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBmbXQpKVxuICB8IElnbm9yZWRfZm9ybWF0X2FyZyAocGFkX29wdCwgZm10dHkpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoRm9ybWF0X2FyZyAocGFkX29wdCwgZm10dHksIGZtdCkpXG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKHBhZF9vcHQsIGZtdHR5KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkJcbiAgICAgIChGb3JtYXRfc3Vic3QgKHBhZF9vcHQsIGZtdHR5LCBmbXQpKVxuICB8IElnbm9yZWRfcmVhZGVyIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoUmVhZGVyIGZtdClcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgZm10KSlcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgY291bnRlciAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGZtdCkpXG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKFNjYW5fbmV4dF9jaGFyIGZtdClcblxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogVHlwZXMgKilcblxudHlwZSAoJ2IsICdjKSBhY2NfZm9ybWF0dGluZ19nZW4gPVxuICB8IEFjY19vcGVuX3RhZyBvZiAoJ2IsICdjKSBhY2NcbiAgfCBBY2Nfb3Blbl9ib3ggb2YgKCdiLCAnYykgYWNjXG5cbigqIFJldmVyc2VkIGxpc3Qgb2YgcHJpbnRpbmcgYXRvbXMuICopXG4oKiBVc2VkIHRvIGFjY3VtdWxhdGUgcHJpbnRmIGFyZ3VtZW50cy4gKilcbmFuZCAoJ2IsICdjKSBhY2MgPVxuICB8IEFjY19mb3JtYXR0aW5nX2xpdCBvZiAoJ2IsICdjKSBhY2MgKiBmb3JtYXR0aW5nX2xpdFxuICAgICAgKCogU3BlY2lhbCBmbXR0aW5nIChib3gpICopXG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIG9mICgnYiwgJ2MpIGFjYyAqICgnYiwgJ2MpIGFjY19mb3JtYXR0aW5nX2dlblxuICAgICAgKCogU3BlY2lhbCBmbXR0aW5nIChib3gpICopXG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIG9mICgnYiwgJ2MpIGFjYyAqIHN0cmluZyAgICAgKCogTGl0ZXJhbCBzdHJpbmcgKilcbiAgfCBBY2NfY2hhcl9saXRlcmFsICAgb2YgKCdiLCAnYykgYWNjICogY2hhciAgICAgICAoKiBMaXRlcmFsIGNoYXIgKilcbiAgfCBBY2NfZGF0YV9zdHJpbmcgICAgb2YgKCdiLCAnYykgYWNjICogc3RyaW5nICAgICAoKiBHZW5lcmF0ZWQgc3RyaW5nICopXG4gIHwgQWNjX2RhdGFfY2hhciAgICAgIG9mICgnYiwgJ2MpIGFjYyAqIGNoYXIgICAgICAgKCogR2VuZXJhdGVkIGNoYXIgKilcbiAgfCBBY2NfZGVsYXkgICAgICAgICAgb2YgKCdiLCAnYykgYWNjICogKCdiIC0+ICdjKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRGVsYXllZCBwcmludGluZyAoJWEsICV0KSAqKVxuICB8IEFjY19mbHVzaCAgICAgICAgICBvZiAoJ2IsICdjKSBhY2MgICAgICAgICAgICAgICgqIEZsdXNoICopXG4gIHwgQWNjX2ludmFsaWRfYXJnICAgIG9mICgnYiwgJ2MpIGFjYyAqIHN0cmluZ1xuICAgICAgKCogUmFpc2UgSW52YWxpZF9hcmd1bWVudCBtc2cgKilcbiAgfCBFbmRfb2ZfYWNjXG5cbigqIExpc3Qgb2YgaGV0ZXJvZ2VuZW91cyB2YWx1ZXMuICopXG4oKiBVc2VkIHRvIGFjY3VtdWxhdGUgc2NhbmYgY2FsbGJhY2sgYXJndW1lbnRzLiAqKVxudHlwZSAoJ2EsICdiKSBoZXRlcl9saXN0ID1cbiAgfCBDb25zIDogJ2MgKiAoJ2EsICdiKSBoZXRlcl9saXN0IC0+ICgnYyAtPiAnYSwgJ2IpIGhldGVyX2xpc3RcbiAgfCBOaWwgOiAoJ2IsICdiKSBoZXRlcl9saXN0XG5cbigqIEV4aXN0ZW50aWFsIEJsYWNrIEJveGVzLiAqKVxuKCogVXNlZCB0byBhYnN0cmFjdCBzb21lIGV4aXN0ZW50aWFsIHR5cGUgcGFyYW1ldGVycy4gKilcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGEgcGFkZGluZyBhbmQgYW4gZm10dHkuICopXG4oKiBTZWUgdGhlIHR5cGVfcGFkZGluZyBmdW5jdGlvbi4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhZGRpbmdfZm10dHlfZWJiID0gUGFkZGluZ19mbXR0eV9FQkIgOlxuICAgICAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5IC0+XG4gICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYWRkaW5nX2ZtdHR5X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYSBwYWRkaW5nLCBhIHByZWNpc2lvbiBhbmQgYW4gZm10dHkuICopXG4oKiBTZWUgdGhlIHR5cGVfcGFkcHJlYyBmdW5jdGlvbi4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhZHByZWNfZm10dHlfZWJiID0gUGFkcHJlY19mbXR0eV9FQkIgOlxuICAgICAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCAneikgcHJlY2lzaW9uICogKCd6LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5IC0+XG4gICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYWRwcmVjX2ZtdHR5X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYSBwYWRkaW5nIGFuZCBhbiBmbXQuICopXG4oKiBTZWUgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgYW5kIHBhcnNlX2Zvcm1hdCBmdW5jdGlvbnMuICopXG50eXBlICgnYSwgJ2IsICdjLCAnZSwgJ2YpIHBhZGRpbmdfZm10X2ViYiA9IFBhZGRpbmdfZm10X0VCQiA6XG4gICAgIChfLCAneCAtPiAnYSkgcGFkZGluZyAqXG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgKCd4LCAnYiwgJ2MsICdlLCAnZikgcGFkZGluZ19mbXRfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHByZWNpc2lvbiBhbmQgYW4gZm10LiAqKVxuKCogU2VlIG1ha2VfcHJlY2lzaW9uX2ZtdF9lYmIgYW5kIHBhcnNlX2Zvcm1hdCBmdW5jdGlvbnMuICopXG50eXBlICgnYSwgJ2IsICdjLCAnZSwgJ2YpIHByZWNpc2lvbl9mbXRfZWJiID0gUHJlY2lzaW9uX2ZtdF9FQkIgOlxuICAgICAoXywgJ3ggLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgKCd4LCAnYiwgJ2MsICdlLCAnZikgcHJlY2lzaW9uX2ZtdF9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGEgcGFkZGluZywgYSBwcmVjaXNpb24gYW5kIGFuIGZtdC4gKilcbigqIFNlZSBtYWtlX3BhZHByZWNfZm10X2ViYiBhbmQgcGFyc2VfZm9ybWF0IGZ1bmN0aW9ucy4gKilcbnR5cGUgKCdwLCAnYiwgJ2MsICdlLCAnZikgcGFkcHJlY19mbXRfZWJiID0gUGFkcHJlY19mbXRfRUJCIDpcbiAgICAgKCd4LCAneSkgcGFkZGluZyAqICgneSwgJ3AgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgKCdwLCAnYiwgJ2MsICdlLCAnZikgcGFkcHJlY19mbXRfZWJiXG5cbigqIEFic3RyYWN0IHRoZSAnYSBhbmQgJ2QgcGFyYW1ldGVycyBvZiBhbiBmbXQuICopXG4oKiBPdXRwdXQgdHlwZSBvZiB0aGUgZm9ybWF0IHBhcnNpbmcgZnVuY3Rpb24uICopXG50eXBlICgnYiwgJ2MsICdlLCAnZikgZm10X2ViYiA9IEZtdF9FQkIgOlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICgnYiwgJ2MsICdlLCAnZikgZm10X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYW4gZm10dHkgYW5kIGFuIGZtdC4gKilcbigqIFNlZSB0aGUgdHlwZV9mb3JtYXRfZ2VuIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10X2ZtdHR5X2ViYiA9IEZtdF9mbXR0eV9FQkIgOlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICd5LCAneCkgZm10ICpcbiAgICAgKCd4LCAnYiwgJ2MsICd5LCAnZSwgJ2YpIGZtdHR5IC0+XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRfZm10dHlfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhbiBmbXR0eSBhbmQgYW4gZm10LiAqKVxuKCogU2VlIHRoZSB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBmdW5jdGlvbi4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5X2ZtdF9lYmIgPSBGbXR0eV9mbXRfRUJCIDpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAneSwgJ3gpIGZtdHR5ICpcbiAgICAgKCd4LCAnYiwgJ2MsICd5LCAnZSwgJ2YpIGZtdF9mbXR0eV9lYmIgLT5cbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5X2ZtdF9lYmJcblxuKCogQWJzdHJhY3QgYWxsIGZtdHR5IHR5cGUgcGFyYW1ldGVycy4gKilcbigqIFVzZWQgdG8gY29tcGFyZSBmb3JtYXQgdHlwZXMuICopXG50eXBlIGZtdHR5X2ViYiA9IEZtdHR5X0VCQiA6ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSAtPiBmbXR0eV9lYmJcblxuKCogQWJzdHJhY3QgYWxsIHBhZGRpbmcgdHlwZSBwYXJhbWV0ZXJzLiAqKVxuKCogVXNlZCB0byBjb21wYXJlIHBhZGRpbmdzLiAqKVxudHlwZSBwYWRkaW5nX2ViYiA9IFBhZGRpbmdfRUJCIDogKCdhLCAnYikgcGFkZGluZyAtPiBwYWRkaW5nX2ViYlxuXG4oKiBBYnN0cmFjdCBhbGwgcHJlY2lzaW9uIHR5cGUgcGFyYW1ldGVycy4gKilcbigqIFVzZWQgdG8gY29tcGFyZSBwcmVjaXNpb25zLiAqKVxudHlwZSBwcmVjaXNpb25fZWJiID0gUHJlY2lzaW9uX0VCQiA6ICgnYSwgJ2IpIHByZWNpc2lvbiAtPiBwcmVjaXNpb25fZWJiXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQ29uc3RhbnRzICopXG5cbigqIERlZmF1bHQgcHJlY2lzaW9uIGZvciBmbG9hdCBwcmludGluZy4gKilcbmxldCBkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiA9IC02XG4gICgqIEZvciAlaCBhbmQgJUggZm9ybWF0cywgYSBuZWdhdGl2ZSBwcmVjaXNpb24gbWVhbnMgXCJhcyBtYW55IGRpZ2l0cyBhc1xuICAgICBuZWNlc3NhcnlcIi4gIEZvciB0aGUgb3RoZXIgRlAgZm9ybWF0cywgd2UgdGFrZSB0aGUgYWJzb2x1dGUgdmFsdWVcbiAgICAgb2YgdGhlIHByZWNpc2lvbiwgaGVuY2UgNiBkaWdpdHMgYnkgZGVmYXVsdC4gKilcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBFeHRlcm5hbHMgKilcblxuZXh0ZXJuYWwgZm9ybWF0X2Zsb2F0OiBzdHJpbmcgLT4gZmxvYXQgLT4gc3RyaW5nXG4gID0gXCJjYW1sX2Zvcm1hdF9mbG9hdFwiXG5leHRlcm5hbCBmb3JtYXRfaW50OiBzdHJpbmcgLT4gaW50IC0+IHN0cmluZ1xuICA9IFwiY2FtbF9mb3JtYXRfaW50XCJcbmV4dGVybmFsIGZvcm1hdF9pbnQzMjogc3RyaW5nIC0+IGludDMyIC0+IHN0cmluZ1xuICA9IFwiY2FtbF9pbnQzMl9mb3JtYXRcIlxuZXh0ZXJuYWwgZm9ybWF0X25hdGl2ZWludDogc3RyaW5nIC0+IG5hdGl2ZWludCAtPiBzdHJpbmdcbiAgPSBcImNhbWxfbmF0aXZlaW50X2Zvcm1hdFwiXG5leHRlcm5hbCBmb3JtYXRfaW50NjQ6IHN0cmluZyAtPiBpbnQ2NCAtPiBzdHJpbmdcbiAgPSBcImNhbWxfaW50NjRfZm9ybWF0XCJcbmV4dGVybmFsIGhleHN0cmluZ19vZl9mbG9hdDogZmxvYXQgLT4gaW50IC0+IGNoYXIgLT4gc3RyaW5nXG4gID0gXCJjYW1sX2hleHN0cmluZ19vZl9mbG9hdFwiXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAoKiBUb29scyB0byBwcmV0dHktcHJpbnQgZm9ybWF0cyAqKVxuXG4oKiBUeXBlIG9mIGV4dGVuc2libGUgY2hhcmFjdGVyIGJ1ZmZlcnMuICopXG50eXBlIGJ1ZmZlciA9IHtcbiAgbXV0YWJsZSBpbmQgOiBpbnQ7XG4gIG11dGFibGUgYnl0ZXMgOiBieXRlcztcbn1cblxuKCogQ3JlYXRlIGEgZnJlc2ggYnVmZmVyLiAqKVxubGV0IGJ1ZmZlcl9jcmVhdGUgaW5pdF9zaXplID0geyBpbmQgPSAwOyBieXRlcyA9IEJ5dGVzLmNyZWF0ZSBpbml0X3NpemUgfVxuXG4oKiBDaGVjayBzaXplIG9mIHRoZSBidWZmZXIgYW5kIGdyb3cgaXQgaWYgbmVlZGVkLiAqKVxubGV0IGJ1ZmZlcl9jaGVja19zaXplIGJ1ZiBvdmVyaGVhZCA9XG4gIGxldCBsZW4gPSBCeXRlcy5sZW5ndGggYnVmLmJ5dGVzIGluXG4gIGxldCBtaW5fbGVuID0gYnVmLmluZCArIG92ZXJoZWFkIGluXG4gIGlmIG1pbl9sZW4gPiBsZW4gdGhlbiAoXG4gICAgbGV0IG5ld19sZW4gPSBtYXggKGxlbiAqIDIpIG1pbl9sZW4gaW5cbiAgICBsZXQgbmV3X3N0ciA9IEJ5dGVzLmNyZWF0ZSBuZXdfbGVuIGluXG4gICAgQnl0ZXMuYmxpdCBidWYuYnl0ZXMgMCBuZXdfc3RyIDAgbGVuO1xuICAgIGJ1Zi5ieXRlcyA8LSBuZXdfc3RyO1xuICApXG5cbigqIEFkZCB0aGUgY2hhcmFjdGVyIGBjJyB0byB0aGUgYnVmZmVyIGBidWYnLiAqKVxubGV0IGJ1ZmZlcl9hZGRfY2hhciBidWYgYyA9XG4gIGJ1ZmZlcl9jaGVja19zaXplIGJ1ZiAxO1xuICBCeXRlcy5zZXQgYnVmLmJ5dGVzIGJ1Zi5pbmQgYztcbiAgYnVmLmluZCA8LSBidWYuaW5kICsgMVxuXG4oKiBBZGQgdGhlIHN0cmluZyBgcycgdG8gdGhlIGJ1ZmZlciBgYnVmJy4gKilcbmxldCBidWZmZXJfYWRkX3N0cmluZyBidWYgcyA9XG4gIGxldCBzdHJfbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGJ1ZmZlcl9jaGVja19zaXplIGJ1ZiBzdHJfbGVuO1xuICBTdHJpbmcuYmxpdCBzIDAgYnVmLmJ5dGVzIGJ1Zi5pbmQgc3RyX2xlbjtcbiAgYnVmLmluZCA8LSBidWYuaW5kICsgc3RyX2xlblxuXG4oKiBHZXQgdGhlIGNvbnRlbnQgb2YgdGhlIGJ1ZmZlci4gKilcbmxldCBidWZmZXJfY29udGVudHMgYnVmID1cbiAgQnl0ZXMuc3ViX3N0cmluZyBidWYuYnl0ZXMgMCBidWYuaW5kXG5cbigqKiopXG5cbigqIENvbnZlcnQgYW4gaW50ZWdlciBjb252ZXJzaW9uIHRvIGNoYXIuICopXG5sZXQgY2hhcl9vZl9pY29udiBpY29udiA9IG1hdGNoIGljb252IHdpdGhcbiAgfCBJbnRfZCB8IEludF9wZCB8IEludF9zZCAtPiAnZCcgfCBJbnRfaSB8IEludF9waSB8IEludF9zaSAtPiAnaSdcbiAgfCBJbnRfeCB8IEludF9DeCAtPiAneCcgfCBJbnRfWCB8IEludF9DWCAtPiAnWCcgfCBJbnRfbyB8IEludF9DbyAtPiAnbydcbiAgfCBJbnRfdSAtPiAndSdcblxuKCogQ29udmVydCBhIGZsb2F0IGNvbnZlcnNpb24gdG8gY2hhci4gKilcbmxldCBjaGFyX29mX2Zjb252IGZjb252ID0gbWF0Y2ggZmNvbnYgd2l0aFxuICB8IEZsb2F0X2YgfCBGbG9hdF9wZiB8IEZsb2F0X3NmIC0+ICdmJyB8IEZsb2F0X2UgfCBGbG9hdF9wZSB8IEZsb2F0X3NlIC0+ICdlJ1xuICB8IEZsb2F0X0UgfCBGbG9hdF9wRSB8IEZsb2F0X3NFIC0+ICdFJyB8IEZsb2F0X2cgfCBGbG9hdF9wZyB8IEZsb2F0X3NnIC0+ICdnJ1xuICB8IEZsb2F0X0cgfCBGbG9hdF9wRyB8IEZsb2F0X3NHIC0+ICdHJyB8IEZsb2F0X0YgLT4gJ0YnXG4gIHwgRmxvYXRfaCB8IEZsb2F0X3BoIHwgRmxvYXRfc2ggLT4gJ2gnIHwgRmxvYXRfSCB8IEZsb2F0X3BIIHwgRmxvYXRfc0ggLT4gJ0gnXG5cblxuKCogQ29udmVydCBhIHNjYW5uaW5nIGNvdW50ZXIgdG8gY2hhci4gKilcbmxldCBjaGFyX29mX2NvdW50ZXIgY291bnRlciA9IG1hdGNoIGNvdW50ZXIgd2l0aFxuICB8IExpbmVfY291bnRlciAgLT4gJ2wnXG4gIHwgQ2hhcl9jb3VudGVyICAtPiAnbidcbiAgfCBUb2tlbl9jb3VudGVyIC0+ICdOJ1xuXG4oKioqKVxuXG4oKiBQcmludCBhIGNoYXJfc2V0IGluIGEgYnVmZmVyIHdpdGggdGhlIE9DYW1sIGZvcm1hdCBsZXhpY2FsIGNvbnZlbnRpb24uICopXG5sZXQgYnByaW50X2NoYXJfc2V0IGJ1ZiBjaGFyX3NldCA9XG4gIGxldCByZWMgcHJpbnRfc3RhcnQgc2V0ID1cbiAgICBsZXQgaXNfYWxvbmUgYyA9XG4gICAgICBsZXQgYmVmb3JlLCBhZnRlciA9IENoYXIuKGNociAoY29kZSBjIC0gMSksIGNociAoY29kZSBjICsgMSkpIGluXG4gICAgICBpc19pbl9jaGFyX3NldCBzZXQgY1xuICAgICAgJiYgbm90IChpc19pbl9jaGFyX3NldCBzZXQgYmVmb3JlICYmIGlzX2luX2NoYXJfc2V0IHNldCBhZnRlcikgaW5cbiAgICBpZiBpc19hbG9uZSAnXScgdGhlbiBidWZmZXJfYWRkX2NoYXIgYnVmICddJztcbiAgICBwcmludF9vdXQgc2V0IDE7XG4gICAgaWYgaXNfYWxvbmUgJy0nIHRoZW4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnLSc7XG4gIGFuZCBwcmludF9vdXQgc2V0IGkgPVxuICAgIGlmIGkgPCAyNTYgdGhlblxuICAgICAgaWYgaXNfaW5fY2hhcl9zZXQgc2V0IChjaGFyX29mX2ludCBpKSB0aGVuIHByaW50X2ZpcnN0IHNldCBpXG4gICAgICBlbHNlIHByaW50X291dCBzZXQgKGkgKyAxKVxuICBhbmQgcHJpbnRfZmlyc3Qgc2V0IGkgPVxuICAgIG1hdGNoIGNoYXJfb2ZfaW50IGkgd2l0aFxuICAgIHwgJ1xcMjU1JyAtPiBwcmludF9jaGFyIGJ1ZiAyNTU7XG4gICAgfCAnXScgfCAnLScgLT4gcHJpbnRfb3V0IHNldCAoaSArIDEpO1xuICAgIHwgXyAtPiBwcmludF9zZWNvbmQgc2V0IChpICsgMSk7XG4gIGFuZCBwcmludF9zZWNvbmQgc2V0IGkgPVxuICAgIGlmIGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgaSkgdGhlblxuICAgICAgbWF0Y2ggY2hhcl9vZl9pbnQgaSB3aXRoXG4gICAgICB8ICdcXDI1NScgLT5cbiAgICAgICAgcHJpbnRfY2hhciBidWYgMjU0O1xuICAgICAgICBwcmludF9jaGFyIGJ1ZiAyNTU7XG4gICAgICB8ICddJyB8ICctJyB3aGVuIG5vdCAoaXNfaW5fY2hhcl9zZXQgc2V0IChjaGFyX29mX2ludCAoaSArIDEpKSkgLT5cbiAgICAgICAgcHJpbnRfY2hhciBidWYgKGkgLSAxKTtcbiAgICAgICAgcHJpbnRfb3V0IHNldCAoaSArIDEpO1xuICAgICAgfCBfIHdoZW4gbm90IChpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IChpICsgMSkpKSAtPlxuICAgICAgICBwcmludF9jaGFyIGJ1ZiAoaSAtIDEpO1xuICAgICAgICBwcmludF9jaGFyIGJ1ZiBpO1xuICAgICAgICBwcmludF9vdXQgc2V0IChpICsgMik7XG4gICAgICB8IF8gLT5cbiAgICAgICAgcHJpbnRfaW4gc2V0IChpIC0gMSkgKGkgKyAyKTtcbiAgICBlbHNlIChcbiAgICAgIHByaW50X2NoYXIgYnVmIChpIC0gMSk7XG4gICAgICBwcmludF9vdXQgc2V0IChpICsgMSk7XG4gICAgKVxuICBhbmQgcHJpbnRfaW4gc2V0IGkgaiA9XG4gICAgaWYgaiA9IDI1NiB8fCBub3QgKGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgaikpIHRoZW4gKFxuICAgICAgcHJpbnRfY2hhciBidWYgaTtcbiAgICAgIHByaW50X2NoYXIgYnVmIChpbnRfb2ZfY2hhciAnLScpO1xuICAgICAgcHJpbnRfY2hhciBidWYgKGogLSAxKTtcbiAgICAgIGlmIGogPCAyNTYgdGhlbiBwcmludF9vdXQgc2V0IChqICsgMSk7XG4gICAgKSBlbHNlXG4gICAgICBwcmludF9pbiBzZXQgaSAoaiArIDEpO1xuICBhbmQgcHJpbnRfY2hhciBidWYgaSA9IG1hdGNoIGNoYXJfb2ZfaW50IGkgd2l0aFxuICAgIHwgJyUnIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBidWZmZXJfYWRkX2NoYXIgYnVmICclJztcbiAgICB8ICdAJyAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnQCc7XG4gICAgfCBjICAgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiBjO1xuICBpblxuICBidWZmZXJfYWRkX2NoYXIgYnVmICdbJztcbiAgcHJpbnRfc3RhcnQgKFxuICAgIGlmIGlzX2luX2NoYXJfc2V0IGNoYXJfc2V0ICdcXDAwMCdcbiAgICB0aGVuICggYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnXic7IHJldl9jaGFyX3NldCBjaGFyX3NldCApXG4gICAgZWxzZSBjaGFyX3NldFxuICApO1xuICBidWZmZXJfYWRkX2NoYXIgYnVmICddJ1xuXG4oKioqKVxuXG4oKiBQcmludCBhIHBhZHR5IGluIGEgYnVmZmVyIHdpdGggdGhlIGZvcm1hdC1saWtlIHN5bnRheC4gKilcbmxldCBicHJpbnRfcGFkdHkgYnVmIHBhZHR5ID0gbWF0Y2ggcGFkdHkgd2l0aFxuICB8IExlZnQgIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJy0nXG4gIHwgUmlnaHQgLT4gKClcbiAgfCBaZXJvcyAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICcwJ1xuXG4oKiBQcmludCB0aGUgJ18nIG9mIGFuIGlnbm9yZWQgZmxhZyBpZiBuZWVkZWQuICopXG5sZXQgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWcgPVxuICBpZiBpZ25fZmxhZyB0aGVuIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ18nXG5cbigqKiopXG5cbmxldCBicHJpbnRfcGFkX29wdCBidWYgcGFkX29wdCA9IG1hdGNoIHBhZF9vcHQgd2l0aFxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIHdpZHRoIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiAoc3RyaW5nX29mX2ludCB3aWR0aClcblxuKCoqKilcblxuKCogUHJpbnQgcGFkZGluZyBpbiBhIGJ1ZmZlciB3aXRoIHRoZSBmb3JtYXQtbGlrZSBzeW50YXguICopXG5sZXQgYnByaW50X3BhZGRpbmcgOiB0eXBlIGEgYiAuIGJ1ZmZlciAtPiAoYSwgYikgcGFkZGluZyAtPiB1bml0ID1cbmZ1biBidWYgcGFkIC0+IG1hdGNoIHBhZCB3aXRoXG4gIHwgTm9fcGFkZGluZyAtPiAoKVxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgbikgLT5cbiAgICBicHJpbnRfcGFkdHkgYnVmIHBhZHR5O1xuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiAoc3RyaW5nX29mX2ludCBuKTtcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSAtPlxuICAgIGJwcmludF9wYWR0eSBidWYgcGFkdHk7XG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKidcblxuKCogUHJpbnQgcHJlY2lzaW9uIGluIGEgYnVmZmVyIHdpdGggdGhlIGZvcm1hdC1saWtlIHN5bnRheC4gKilcbmxldCBicHJpbnRfcHJlY2lzaW9uIDogdHlwZSBhIGIgLiBidWZmZXIgLT4gKGEsIGIpIHByZWNpc2lvbiAtPiB1bml0ID1cbiAgZnVuIGJ1ZiBwcmVjIC0+IG1hdGNoIHByZWMgd2l0aFxuICB8IE5vX3ByZWNpc2lvbiAtPiAoKVxuICB8IExpdF9wcmVjaXNpb24gbiAtPlxuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJy4nO1xuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiAoc3RyaW5nX29mX2ludCBuKTtcbiAgfCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiLipcIlxuXG4oKioqKVxuXG4oKiBQcmludCB0aGUgb3B0aW9uYWwgJysnLCAnICcgb3IgJyMnIGFzc29jaWF0ZWQgdG8gYW4gaW50IGNvbnZlcnNpb24uICopXG5sZXQgYnByaW50X2ljb252X2ZsYWcgYnVmIGljb252ID0gbWF0Y2ggaWNvbnYgd2l0aFxuICB8IEludF9wZCB8IEludF9waSAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICcrJ1xuICB8IEludF9zZCB8IEludF9zaSAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICcgJ1xuICB8IEludF9DeCB8IEludF9DWCB8IEludF9DbyAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICcjJ1xuICB8IEludF9kIHwgSW50X2kgfCBJbnRfeCB8IEludF9YIHwgSW50X28gfCBJbnRfdSAtPiAoKVxuXG4oKiBQcmludCBhbiBjb21wbGV0ZSBpbnQgZm9ybWF0IGluIGEgYnVmZmVyIChleDogXCIlMy4qZFwiKS4gKilcbmxldCBicHJpbnRfaW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWMgPVxuICBidWZmZXJfYWRkX2NoYXIgYnVmICclJztcbiAgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gIGJwcmludF9pY29udl9mbGFnIGJ1ZiBpY29udjtcbiAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDtcbiAgYnByaW50X3ByZWNpc2lvbiBidWYgcHJlYztcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAoY2hhcl9vZl9pY29udiBpY29udilcblxuKCogUHJpbnQgYSBjb21wbGV0ZSBpbnQzMiwgbmF0aXZlaW50IG9yIGludDY0IGZvcm1hdCBpbiBhIGJ1ZmZlci4gKilcbmxldCBicHJpbnRfYWx0aW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWMgYyA9XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnO1xuICBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgYnByaW50X2ljb252X2ZsYWcgYnVmIGljb252O1xuICBicHJpbnRfcGFkZGluZyBidWYgcGFkO1xuICBicHJpbnRfcHJlY2lzaW9uIGJ1ZiBwcmVjO1xuICBidWZmZXJfYWRkX2NoYXIgYnVmIGM7XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpXG5cbigqKiopXG5cbigqIFByaW50IHRoZSBvcHRpb25hbCAnKycgYXNzb2NpYXRlZCB0byBhIGZsb2F0IGNvbnZlcnNpb24uICopXG5sZXQgYnByaW50X2Zjb252X2ZsYWcgYnVmIGZjb252ID0gbWF0Y2ggZmNvbnYgd2l0aFxuICB8IEZsb2F0X3BmIHwgRmxvYXRfcGUgfCBGbG9hdF9wRVxuICB8IEZsb2F0X3BnIHwgRmxvYXRfcEcgfCBGbG9hdF9waCB8IEZsb2F0X3BIIC0+XG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKydcbiAgfCBGbG9hdF9zZiB8IEZsb2F0X3NlIHwgRmxvYXRfc0VcbiAgfCBGbG9hdF9zZyB8IEZsb2F0X3NHIHwgRmxvYXRfc2ggfCBGbG9hdF9zSCAtPlxuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyAnXG4gIHwgRmxvYXRfZiB8IEZsb2F0X2UgfCBGbG9hdF9FXG4gIHwgRmxvYXRfZyB8IEZsb2F0X0cgfCBGbG9hdF9GIHwgRmxvYXRfaCB8IEZsb2F0X0ggLT5cbiAgICAoKVxuXG4oKiBQcmludCBhIGNvbXBsZXRlIGZsb2F0IGZvcm1hdCBpbiBhIGJ1ZmZlciAoZXg6IFwiJSsqLjNmXCIpLiAqKVxubGV0IGJwcmludF9mbG9hdF9mbXQgYnVmIGlnbl9mbGFnIGZjb252IHBhZCBwcmVjID1cbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gIGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICBicHJpbnRfZmNvbnZfZmxhZyBidWYgZmNvbnY7XG4gIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7XG4gIGJwcmludF9wcmVjaXNpb24gYnVmIHByZWM7XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgKGNoYXJfb2ZfZmNvbnYgZmNvbnYpXG5cbigqIENvbXB1dGUgdGhlIGxpdGVyYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgZm9ybWF0dGluZ19saXQuICopXG4oKiBBbHNvIHVzZWQgYnkgUHJpbnRmIGFuZCBTY2FuZiB3aGVyZSBmb3JtYXR0aW5nIGlzIG5vdCBpbnRlcnByZXRlZC4gKilcbmxldCBzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm9ybWF0dGluZ19saXQgPSBtYXRjaCBmb3JtYXR0aW5nX2xpdCB3aXRoXG4gIHwgQ2xvc2VfYm94ICAgICAgICAgICAgLT4gXCJAXVwiXG4gIHwgQ2xvc2VfdGFnICAgICAgICAgICAgLT4gXCJAfVwiXG4gIHwgQnJlYWsgKHN0ciwgXywgXykgICAgLT4gc3RyXG4gIHwgRkZsdXNoICAgICAgICAgICAgICAgLT4gXCJAP1wiXG4gIHwgRm9yY2VfbmV3bGluZSAgICAgICAgLT4gXCJAXFxuXCJcbiAgfCBGbHVzaF9uZXdsaW5lICAgICAgICAtPiBcIkAuXCJcbiAgfCBNYWdpY19zaXplIChzdHIsIF8pICAtPiBzdHJcbiAgfCBFc2NhcGVkX2F0ICAgICAgICAgICAtPiBcIkBAXCJcbiAgfCBFc2NhcGVkX3BlcmNlbnQgICAgICAtPiBcIkAlXCJcbiAgfCBTY2FuX2luZGljIGMgLT4gXCJAXCIgXiAoU3RyaW5nLm1ha2UgMSBjKVxuXG4oKiBDb21wdXRlIHRoZSBsaXRlcmFsIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGZvcm1hdHRpbmcuICopXG4oKiBBbHNvIHVzZWQgYnkgUHJpbnRmIGFuZCBTY2FuZiB3aGVyZSBmb3JtYXR0aW5nIGlzIG5vdCBpbnRlcnByZXRlZC4gKilcbmxldCBzdHJpbmdfb2ZfZm9ybWF0dGluZ19nZW4gOiB0eXBlIGEgYiBjIGQgZSBmIC5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm9ybWF0dGluZ19nZW4gLT4gc3RyaW5nID1cbiAgZnVuIGZvcm1hdHRpbmdfZ2VuIC0+IG1hdGNoIGZvcm1hdHRpbmdfZ2VuIHdpdGhcbiAgfCBPcGVuX3RhZyAoRm9ybWF0IChfLCBzdHIpKSAtPiBzdHJcbiAgfCBPcGVuX2JveCAoRm9ybWF0IChfLCBzdHIpKSAtPiBzdHJcblxuKCoqKilcblxuKCogUHJpbnQgYSBsaXRlcmFsIGNoYXIgaW4gYSBidWZmZXIsIGVzY2FwZSAnJScgYnkgXCIlJVwiLiAqKVxubGV0IGJwcmludF9jaGFyX2xpdGVyYWwgYnVmIGNociA9IG1hdGNoIGNociB3aXRoXG4gIHwgJyUnIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiUlXCJcbiAgfCBfIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgY2hyXG5cbigqIFByaW50IGEgbGl0ZXJhbCBzdHJpbmcgaW4gYSBidWZmZXIsIGVzY2FwZSBhbGwgJyUnIGJ5IFwiJSVcIi4gKilcbmxldCBicHJpbnRfc3RyaW5nX2xpdGVyYWwgYnVmIHN0ciA9XG4gIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHN0ciAtIDEgZG9cbiAgICBicHJpbnRfY2hhcl9saXRlcmFsIGJ1ZiBzdHIuW2ldXG4gIGRvbmVcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IHByZXR0eS1wcmludGluZyAqKVxuXG4oKiBQcmludCBhIGNvbXBsZXRlIGZvcm1hdCB0eXBlIChhbiBmbXR0eSkgaW4gYSBidWZmZXIuICopXG5sZXQgcmVjIGJwcmludF9mbXR0eSA6IHR5cGUgYSBiIGMgZCBlIGYgZyBoIGkgaiBrIGwgLlxuICAgIGJ1ZmZlciAtPiAoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgaiwgaywgbCkgZm10dHlfcmVsIC0+IHVuaXQgPVxuZnVuIGJ1ZiBmbXR0eSAtPiBtYXRjaCBmbXR0eSB3aXRoXG4gIHwgQ2hhcl90eSByZXN0ICAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJWNcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBTdHJpbmdfdHkgcmVzdCAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlc1wiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEludF90eSByZXN0ICAgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVpXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgSW50MzJfdHkgcmVzdCAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJWxpXCI7IGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlbmlcIjsgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEludDY0X3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVMaVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgRmxvYXRfdHkgcmVzdCAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJWZcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBCb29sX3R5IHJlc3QgICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlQlwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEFscGhhX3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVhXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgVGhldGFfdHkgcmVzdCAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJXRcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBBbnlfdHkgcmVzdCAgICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlP1wiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IFJlYWRlcl90eSByZXN0ICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVyXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG5cbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0IC0+XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJV9yXCI7XG4gICAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuXG4gIHwgRm9ybWF0X2FyZ190eSAoc3ViX2ZtdHR5LCByZXN0KSAtPlxuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiV7XCI7IGJwcmludF9mbXR0eSBidWYgc3ViX2ZtdHR5O1xuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiV9XCI7IGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHN1Yl9mbXR0eSwgXywgcmVzdCkgLT5cbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlKFwiOyBicHJpbnRfZm10dHkgYnVmIHN1Yl9mbXR0eTtcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlKVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG5cbiAgfCBFbmRfb2ZfZm10dHkgLT4gKClcblxuKCoqKilcblxubGV0IHJlYyBpbnRfb2ZfY3VzdG9tX2FyaXR5IDogdHlwZSBhIGIgYyAuXG4gIChhLCBiLCBjKSBjdXN0b21fYXJpdHkgLT4gaW50ID1cbiAgZnVuY3Rpb25cbiAgfCBDdXN0b21femVybyAtPiAwXG4gIHwgQ3VzdG9tX3N1Y2MgeCAtPiAxICsgaW50X29mX2N1c3RvbV9hcml0eSB4XG5cbigqIFByaW50IGEgY29tcGxldGUgZm9ybWF0IGluIGEgYnVmZmVyLiAqKVxubGV0IGJwcmludF9mbXQgYnVmIGZtdCA9XG4gIGxldCByZWMgZm10aXRlciA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAgICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiBib29sIC0+IHVuaXQgPVxuICBmdW4gZm10IGlnbl9mbGFnIC0+IG1hdGNoIGZtdCB3aXRoXG4gICAgfCBTdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ3MnO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ1MnO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuXG4gICAgfCBJbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfaW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWM7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgIGJwcmludF9hbHRpbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYyAnbCc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfYWx0aW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWMgJ24nO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgSW50NjQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfYWx0aW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWMgJ0wnO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfZmxvYXRfZm10IGJ1ZiBpZ25fZmxhZyBmY29udiBwYWQgcHJlYztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcblxuICAgIHwgQ2hhciByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICdjJzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQ2FtbF9jaGFyIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ0MnOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBCb29sIChwYWQsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkZGluZyBidWYgcGFkOyBidWZmZXJfYWRkX2NoYXIgYnVmICdCJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEFscGhhIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ2EnOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBUaGV0YSByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICd0JzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQ3VzdG9tIChhcml0eSwgXywgcmVzdCkgLT5cbiAgICAgIGZvciBfaSA9IDEgdG8gaW50X29mX2N1c3RvbV9hcml0eSBhcml0eSBkb1xuICAgICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJz8nO1xuICAgICAgZG9uZTtcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IFJlYWRlciByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICdyJzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgRmx1c2ggcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJSFcIjtcbiAgICAgIGZtdGl0ZXIgcmVzdCBpZ25fZmxhZztcblxuICAgIHwgU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgLT5cbiAgICAgIGJwcmludF9zdHJpbmdfbGl0ZXJhbCBidWYgc3RyO1xuICAgICAgZm10aXRlciByZXN0IGlnbl9mbGFnO1xuICAgIHwgQ2hhcl9saXRlcmFsIChjaHIsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfY2hhcl9saXRlcmFsIGJ1ZiBjaHI7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG5cbiAgICB8IEZvcm1hdF9hcmcgKHBhZF9vcHQsIGZtdHR5LCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZF9vcHQgYnVmIHBhZF9vcHQ7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ3snO1xuICAgICAgYnByaW50X2ZtdHR5IGJ1ZiBmbXR0eTsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ30nO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBmbXR0eSwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRfb3B0IGJ1ZiBwYWRfb3B0OyBidWZmZXJfYWRkX2NoYXIgYnVmICcoJztcbiAgICAgIGJwcmludF9mbXR0eSBidWYgZm10dHk7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBidWZmZXJfYWRkX2NoYXIgYnVmICcpJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcblxuICAgIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRfb3B0IGJ1ZiB3aWR0aF9vcHQ7IGJwcmludF9jaGFyX3NldCBidWYgY2hhcl9zZXQ7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAoY2hhcl9vZl9jb3VudGVyIGNvdW50ZXIpO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3N0cmluZ19saXRlcmFsIGJ1ZiBcIjBjXCI7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcblxuICAgIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAtPlxuICAgICAgbGV0IFBhcmFtX2Zvcm1hdF9FQkIgZm10JyA9IHBhcmFtX2Zvcm1hdF9vZl9pZ25vcmVkX2Zvcm1hdCBpZ24gcmVzdCBpblxuICAgICAgZm10aXRlciBmbXQnIHRydWU7XG5cbiAgICB8IEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCByZXN0KSAtPlxuICAgICAgYnByaW50X3N0cmluZ19saXRlcmFsIGJ1ZiAoc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQpO1xuICAgICAgZm10aXRlciByZXN0IGlnbl9mbGFnO1xuICAgIHwgRm9ybWF0dGluZ19nZW4gKGZtdGluZ19nZW4sIHJlc3QpIC0+XG4gICAgICBicHJpbnRfc3RyaW5nX2xpdGVyYWwgYnVmIFwiQHtcIjtcbiAgICAgIGJwcmludF9zdHJpbmdfbGl0ZXJhbCBidWYgKHN0cmluZ19vZl9mb3JtYXR0aW5nX2dlbiBmbXRpbmdfZ2VuKTtcbiAgICAgIGZtdGl0ZXIgcmVzdCBpZ25fZmxhZztcblxuICAgIHwgRW5kX29mX2Zvcm1hdCAtPiAoKVxuXG4gIGluIGZtdGl0ZXIgZm10IGZhbHNlXG5cbigqKiopXG5cbigqIENvbnZlcnQgYSBmb3JtYXQgdG8gc3RyaW5nLiAqKVxubGV0IHN0cmluZ19vZl9mbXQgZm10ID1cbiAgbGV0IGJ1ZiA9IGJ1ZmZlcl9jcmVhdGUgMTYgaW5cbiAgYnByaW50X2ZtdCBidWYgZm10O1xuICBidWZmZXJfY29udGVudHMgYnVmXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIFR5cGUgZXh0cmFjdGlvbiAqKVxuXG50eXBlIChfLCBfKSBlcSA9IFJlZmwgOiAoJ2EsICdhKSBlcVxuXG4oKiBJbnZhcmlhbnQ6IHRoaXMgZnVuY3Rpb24gaXMgdGhlIGlkZW50aXR5IG9uIHZhbHVlcy5cblxuICAgSW4gcGFydGljdWxhciwgaWYgKHR5MSwgdHkyKSBoYXZlIGVxdWFsIHZhbHVlcywgdGhlblxuICAgKHRyYW5zIChzeW1tIHR5MSkgdHkyKSByZXNwZWN0cyB0aGUgJ3RyYW5zJyBwcmVjb25kaXRpb24uICopXG5sZXQgcmVjIHN5bW0gOiB0eXBlIGExIGIxIGMxIGQxIGUxIGYxIGEyIGIyIGMyIGQyIGUyIGYyIC5cbiAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgIGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5X3JlbFxuLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIsXG4gICAgYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10dHlfcmVsXG49IGZ1bmN0aW9uXG4gIHwgQ2hhcl90eSByZXN0IC0+IENoYXJfdHkgKHN5bW0gcmVzdClcbiAgfCBJbnRfdHkgcmVzdCAtPiBJbnRfdHkgKHN5bW0gcmVzdClcbiAgfCBJbnQzMl90eSByZXN0IC0+IEludDMyX3R5IChzeW1tIHJlc3QpXG4gIHwgSW50NjRfdHkgcmVzdCAtPiBJbnQ2NF90eSAoc3ltbSByZXN0KVxuICB8IE5hdGl2ZWludF90eSByZXN0IC0+IE5hdGl2ZWludF90eSAoc3ltbSByZXN0KVxuICB8IEZsb2F0X3R5IHJlc3QgLT4gRmxvYXRfdHkgKHN5bW0gcmVzdClcbiAgfCBCb29sX3R5IHJlc3QgLT4gQm9vbF90eSAoc3ltbSByZXN0KVxuICB8IFN0cmluZ190eSByZXN0IC0+IFN0cmluZ190eSAoc3ltbSByZXN0KVxuICB8IFRoZXRhX3R5IHJlc3QgLT4gVGhldGFfdHkgKHN5bW0gcmVzdClcbiAgfCBBbHBoYV90eSByZXN0IC0+IEFscGhhX3R5IChzeW1tIHJlc3QpXG4gIHwgQW55X3R5IHJlc3QgLT4gQW55X3R5IChzeW1tIHJlc3QpXG4gIHwgUmVhZGVyX3R5IHJlc3QgLT4gUmVhZGVyX3R5IChzeW1tIHJlc3QpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPiBJZ25vcmVkX3JlYWRlcl90eSAoc3ltbSByZXN0KVxuICB8IEZvcm1hdF9hcmdfdHkgKHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9hcmdfdHkgKHR5LCBzeW1tIHJlc3QpXG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgcmVzdCkgLT5cbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5MiwgdHkxLCBzeW1tIHJlc3QpXG4gIHwgRW5kX29mX2ZtdHR5IC0+IEVuZF9vZl9mbXR0eVxuXG5sZXQgcmVjIGZtdHR5X3JlbF9kZXQgOiB0eXBlIGExIGIgYyBkMSBlMSBmMSBhMiBkMiBlMiBmMiAuXG4gIChhMSwgYiwgYywgZDEsIGUxLCBmMSxcbiAgIGEyLCBiLCBjLCBkMiwgZTIsIGYyKSBmbXR0eV9yZWwgLT5cbiAgICAoKGYxLCBmMikgZXEgLT4gKGExLCBhMikgZXEpXG4gICogKChhMSwgYTIpIGVxIC0+IChmMSwgZjIpIGVxKVxuICAqICgoZTEsIGUyKSBlcSAtPiAoZDEsIGQyKSBlcSlcbiAgKiAoKGQxLCBkMikgZXEgLT4gKGUxLCBlMikgZXEpXG49IGZ1bmN0aW9uXG4gIHwgRW5kX29mX2ZtdHR5IC0+XG4gICAgKGZ1biBSZWZsIC0+IFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IFJlZmwpXG4gIHwgQ2hhcl90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IFN0cmluZ190eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEludF90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEludDMyX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgSW50NjRfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBGbG9hdF90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEJvb2xfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcblxuICB8IFRoZXRhX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgQWxwaGFfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBBbnlfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBSZWFkZXJfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBlZCBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGRlIFJlZmwgaW4gUmVmbClcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGVkIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZGUgUmVmbCBpbiBSZWZsKVxuICB8IEZvcm1hdF9hcmdfdHkgKF90eSwgcmVzdCkgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgcmVzdCkgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICBsZXQgdHkgPSB0cmFucyAoc3ltbSB0eTEpIHR5MiBpblxuICAgIGxldCBhZywgZ2EsIGRqLCBqZCA9IGZtdHR5X3JlbF9kZXQgdHkgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIGxldCBSZWZsID0gYWcgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBnYSBSZWZsIGluIGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBlZCBSZWZsIGluIGxldCBSZWZsID0gZGogUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBqZCBSZWZsIGluIGxldCBSZWZsID0gZGUgUmVmbCBpbiBSZWZsKVxuXG4oKiBQcmVjb25kaXRpb246IHdlIGFzc3VtZSB0aGF0IHRoZSB0d28gZm10dHlfcmVsIGFyZ3VtZW50cyBoYXZlIGVxdWFsXG4gICB2YWx1ZXMgKGF0IHBvc3NpYmx5IGRpc3RpbmN0IHR5cGVzKTsgdGhpcyBpbnZhcmlhbnQgY29tZXMgZnJvbSB0aGUgd2F5XG4gICBmbXR0eV9yZWwgd2l0bmVzc2VzIGFyZSBwcm9kdWNlZCBieSB0aGUgdHlwZS1jaGVja2VyXG5cbiAgIFRoZSBjb2RlIGJlbG93IHVzZXMgKGFzc2VydCBmYWxzZSkgd2hlbiB0aGlzIGFzc3VtcHRpb24gaXMgYnJva2VuLiBUaGVcbiAgIGNvZGUgcGF0dGVybiBpcyB0aGUgZm9sbG93aW5nOlxuXG4gICAgIHwgRm9vIHgsIEZvbyB5IC0+XG4gICAgICAgKCogY2FzZSB3aGVyZSBpbmRlZWQgYm90aCB2YWx1ZXNcbiAgICAgICAgICBzdGFydCB3aXRoIGNvbnN0cnVjdG9yIEZvbyAqKVxuICAgICB8IEZvbyBfLCBfXG4gICAgIHwgXywgRm9vIF8gLT5cbiAgICAgICAoKiBkaWZmZXJlbnQgaGVhZCBjb25zdHJ1Y3RvcnM6IGJyb2tlbiBwcmVjb25kaXRpb24gKilcbiAgICAgICBhc3NlcnQgZmFsc2VcbiopXG5hbmQgdHJhbnMgOiB0eXBlXG4gIGExIGIxIGMxIGQxIGUxIGYxXG4gIGEyIGIyIGMyIGQyIGUyIGYyXG4gIGEzIGIzIGMzIGQzIGUzIGYzXG4uXG4gICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSxcbiAgICBhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eV9yZWxcbi0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyLFxuICAgIGEzLCBiMywgYzMsIGQzLCBlMywgZjMpIGZtdHR5X3JlbFxuLT4gKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgYTMsIGIzLCBjMywgZDMsIGUzLCBmMykgZm10dHlfcmVsXG49IGZ1biB0eTEgdHkyIC0+IG1hdGNoIHR5MSwgdHkyIHdpdGhcbiAgfCBDaGFyX3R5IHJlc3QxLCBDaGFyX3R5IHJlc3QyIC0+IENoYXJfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IFN0cmluZ190eSByZXN0MSwgU3RyaW5nX3R5IHJlc3QyIC0+IFN0cmluZ190eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgQm9vbF90eSByZXN0MSwgQm9vbF90eSByZXN0MiAtPiBCb29sX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBJbnRfdHkgcmVzdDEsIEludF90eSByZXN0MiAtPiBJbnRfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEludDMyX3R5IHJlc3QxLCBJbnQzMl90eSByZXN0MiAtPiBJbnQzMl90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgSW50NjRfdHkgcmVzdDEsIEludDY0X3R5IHJlc3QyIC0+IEludDY0X3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdDEsIE5hdGl2ZWludF90eSByZXN0MiAtPiBOYXRpdmVpbnRfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEZsb2F0X3R5IHJlc3QxLCBGbG9hdF90eSByZXN0MiAtPiBGbG9hdF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG5cbiAgfCBBbHBoYV90eSByZXN0MSwgQWxwaGFfdHkgcmVzdDIgLT4gQWxwaGFfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEFscGhhX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgQWxwaGFfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IFRoZXRhX3R5IHJlc3QxLCBUaGV0YV90eSByZXN0MiAtPiBUaGV0YV90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgVGhldGFfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBUaGV0YV90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgQW55X3R5IHJlc3QxLCBBbnlfdHkgcmVzdDIgLT4gQW55X3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBBbnlfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBBbnlfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IFJlYWRlcl90eSByZXN0MSwgUmVhZGVyX3R5IHJlc3QyIC0+IFJlYWRlcl90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgUmVhZGVyX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgUmVhZGVyX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0MSwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdDIgLT5cbiAgICBJZ25vcmVkX3JlYWRlcl90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBJZ25vcmVkX3JlYWRlcl90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgRm9ybWF0X2FyZ190eSAodHkxLCByZXN0MSksIEZvcm1hdF9hcmdfdHkgKHR5MiwgcmVzdDIpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHJhbnMgdHkxIHR5MiwgdHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgRm9ybWF0X2FyZ190eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIEZvcm1hdF9hcmdfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxMSwgdHkxMiwgcmVzdDEpLFxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkyMSwgdHkyMiwgcmVzdDIpIC0+XG4gICAgbGV0IHR5ID0gdHJhbnMgKHN5bW0gdHkxMikgdHkyMSBpblxuICAgIGxldCBfLCBmMiwgXywgZjQgPSBmbXR0eV9yZWxfZGV0IHR5IGluXG4gICAgbGV0IFJlZmwgPSBmMiBSZWZsIGluXG4gICAgbGV0IFJlZmwgPSBmNCBSZWZsIGluXG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTExLCB0eTIyLCB0cmFucyByZXN0MSByZXN0MilcbiAgfCBGb3JtYXRfc3Vic3RfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBGb3JtYXRfc3Vic3RfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IEVuZF9vZl9mbXR0eSwgRW5kX29mX2ZtdHR5IC0+IEVuZF9vZl9mbXR0eVxuICB8IEVuZF9vZl9mbXR0eSwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBFbmRfb2ZfZm10dHkgLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCByZWMgZm10dHlfb2ZfZm9ybWF0dGluZ19nZW4gOiB0eXBlIGEgYiBjIGQgZSBmIC5cbiAgKGEsIGIsIGMsIGQsIGUsIGYpIGZvcm1hdHRpbmdfZ2VuIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbmZ1biBmb3JtYXR0aW5nX2dlbiAtPiBtYXRjaCBmb3JtYXR0aW5nX2dlbiB3aXRoXG4gIHwgT3Blbl90YWcgKEZvcm1hdCAoZm10LCBfKSkgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IE9wZW5fYm94IChGb3JtYXQgKGZtdCwgXykpIC0+IGZtdHR5X29mX2ZtdCBmbXRcblxuKCogRXh0cmFjdCB0aGUgdHlwZSByZXByZXNlbnRhdGlvbiAoYW4gZm10dHkpIG9mIGEgZm9ybWF0LiAqKVxuYW5kIGZtdHR5X29mX2ZtdCA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG5mdW4gZm10dHkgLT4gbWF0Y2ggZm10dHkgd2l0aFxuICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIChTdHJpbmdfdHkgKGZtdHR5X29mX2ZtdCByZXN0KSlcbiAgfCBDYW1sX3N0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIChTdHJpbmdfdHkgKGZtdHR5X29mX2ZtdCByZXN0KSlcblxuICB8IEludCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCB0eV9yZXN0ID0gZm10dHlfb2ZfZm10IHJlc3QgaW5cbiAgICBsZXQgcHJlY190eSA9IGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSBwcmVjIChJbnRfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG4gIHwgSW50MzIgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoSW50MzJfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG4gIHwgTmF0aXZlaW50IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IHR5X3Jlc3QgPSBmbXR0eV9vZl9mbXQgcmVzdCBpblxuICAgIGxldCBwcmVjX3R5ID0gZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IHByZWMgKE5hdGl2ZWludF90eSB0eV9yZXN0KSBpblxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIHByZWNfdHlcbiAgfCBJbnQ2NCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCB0eV9yZXN0ID0gZm10dHlfb2ZfZm10IHJlc3QgaW5cbiAgICBsZXQgcHJlY190eSA9IGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSBwcmVjIChJbnQ2NF90eSB0eV9yZXN0KSBpblxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIHByZWNfdHlcbiAgfCBGbG9hdCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCB0eV9yZXN0ID0gZm10dHlfb2ZfZm10IHJlc3QgaW5cbiAgICBsZXQgcHJlY190eSA9IGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSBwcmVjIChGbG9hdF90eSB0eV9yZXN0KSBpblxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIHByZWNfdHlcblxuICB8IENoYXIgcmVzdCAgICAgICAgICAgICAgICAgIC0+IENoYXJfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IENhbWxfY2hhciByZXN0ICAgICAgICAgICAgIC0+IENoYXJfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IEJvb2wgKHBhZCwgcmVzdCkgICAgICAgICAgIC0+IGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIChCb29sX3R5IChmbXR0eV9vZl9mbXQgcmVzdCkpXG4gIHwgQWxwaGEgcmVzdCAgICAgICAgICAgICAgICAgLT4gQWxwaGFfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IFRoZXRhIHJlc3QgICAgICAgICAgICAgICAgIC0+IFRoZXRhX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBDdXN0b20gKGFyaXR5LCBfLCByZXN0KSAgICAtPiBmbXR0eV9vZl9jdXN0b20gYXJpdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IFJlYWRlciByZXN0ICAgICAgICAgICAgICAgIC0+IFJlYWRlcl90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG5cbiAgfCBGb3JtYXRfYXJnIChfLCB0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0eSwgZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgRm9ybWF0X3N1YnN0IChfLCB0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5LCB0eSwgZm10dHlfb2ZfZm10IHJlc3QpXG5cbiAgfCBGbHVzaCByZXN0ICAgICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgcmVzdFxuICB8IFN0cmluZ19saXRlcmFsIChfLCByZXN0KSAgIC0+IGZtdHR5X29mX2ZtdCByZXN0XG4gIHwgQ2hhcl9saXRlcmFsIChfLCByZXN0KSAgICAgLT4gZm10dHlfb2ZfZm10IHJlc3RcblxuICB8IFNjYW5fY2hhcl9zZXQgKF8sIF8sIHJlc3QpIC0+IFN0cmluZ190eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgU2Nhbl9nZXRfY291bnRlciAoXywgcmVzdCkgLT4gSW50X3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBTY2FuX25leHRfY2hhciByZXN0ICAgICAgICAtPiBDaGFyX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpICAtPiBmbXR0eV9vZl9pZ25vcmVkX2Zvcm1hdCBpZ24gcmVzdFxuICB8IEZvcm1hdHRpbmdfbGl0IChfLCByZXN0KSAgIC0+IGZtdHR5X29mX2ZtdCByZXN0XG4gIHwgRm9ybWF0dGluZ19nZW4gKGZtdGluZ19nZW4sIHJlc3QpICAtPlxuICAgIGNvbmNhdF9mbXR0eSAoZm10dHlfb2ZfZm9ybWF0dGluZ19nZW4gZm10aW5nX2dlbikgKGZtdHR5X29mX2ZtdCByZXN0KVxuXG4gIHwgRW5kX29mX2Zvcm1hdCAgICAgICAgICAgICAgLT4gRW5kX29mX2ZtdHR5XG5cbmFuZCBmbXR0eV9vZl9jdXN0b20gOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gIChhLCB4LCB5KSBjdXN0b21fYXJpdHkgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICh5LCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG5mdW4gYXJpdHkgZm10dHkgLT4gbWF0Y2ggYXJpdHkgd2l0aFxuICB8IEN1c3RvbV96ZXJvIC0+IGZtdHR5XG4gIHwgQ3VzdG9tX3N1Y2MgYXJpdHkgLT4gQW55X3R5IChmbXR0eV9vZl9jdXN0b20gYXJpdHkgZm10dHkpXG5cbigqIEV4dHJhY3QgdGhlIGZtdHR5IG9mIGFuIGlnbm9yZWQgcGFyYW1ldGVyIGZvbGxvd2VkIGJ5IHRoZSByZXN0IG9mXG4gICB0aGUgZm9ybWF0LiAqKVxuYW5kIGZtdHR5X29mX2lnbm9yZWRfZm9ybWF0IDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAgIChhLCBiLCBjLCBkLCB5LCB4KSBpZ25vcmVkIC0+XG4gICAgKHgsIGIsIGMsIHksIGUsIGYpIGZtdCAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG5mdW4gaWduIGZtdCAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfY2hhciAgICAgICAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfY2FtbF9jaGFyICAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfc3RyaW5nIF8gICAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgXyAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfaW50IChfLCBfKSAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfaW50MzIgKF8sIF8pICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfbmF0aXZlaW50IChfLCBfKSAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfaW50NjQgKF8sIF8pICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfZmxvYXQgKF8sIF8pICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfYm9vbCBfICAgICAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfZm9ybWF0X2FyZyBfICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IChfLCBmbXR0eSkgLT4gY29uY2F0X2ZtdHR5IGZtdHR5IChmbXR0eV9vZl9mbXQgZm10KVxuICB8IElnbm9yZWRfcmVhZGVyICAgICAgICAgICAgICAgICAgLT4gSWdub3JlZF9yZWFkZXJfdHkgKGZtdHR5X29mX2ZtdCBmbXQpXG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IF8gICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIF8gICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG5cbigqIEFkZCBhbiBJbnRfdHkgbm9kZSBpZiBwYWRkaW5nIGlzIHRha2VuIGFzIGFuIGV4dHJhIGFyZ3VtZW50IChleDogXCIlKnNcIikuICopXG5hbmQgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSA6IHR5cGUgeCBhIGIgYyBkIGUgZiAuXG4gICAgKHgsIGEpIHBhZGRpbmcgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+ICh4LCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG4gIGZ1biBwYWQgZm10dHkgLT4gbWF0Y2ggcGFkIHdpdGhcbiAgICB8IE5vX3BhZGRpbmcgICAgLT4gZm10dHlcbiAgICB8IExpdF9wYWRkaW5nIF8gLT4gZm10dHlcbiAgICB8IEFyZ19wYWRkaW5nIF8gLT4gSW50X3R5IGZtdHR5XG5cbigqIEFkZCBhbiBJbnRfdHkgbm9kZSBpZiBwcmVjaXNpb24gaXMgdGFrZW4gYXMgYW4gZXh0cmEgYXJndW1lbnQgKGV4OiBcIiUuKmZcIikuKilcbmFuZCBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgOiB0eXBlIHggYSBiIGMgZCBlIGYgLlxuICAgICh4LCBhKSBwcmVjaXNpb24gLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+ICh4LCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG4gIGZ1biBwcmVjIGZtdHR5IC0+IG1hdGNoIHByZWMgd2l0aFxuICAgIHwgTm9fcHJlY2lzaW9uICAgIC0+IGZtdHR5XG4gICAgfCBMaXRfcHJlY2lzaW9uIF8gLT4gZm10dHlcbiAgICB8IEFyZ19wcmVjaXNpb24gICAtPiBJbnRfdHkgZm10dHlcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXQgdHlwaW5nICopXG5cbigqIEV4Y2VwdGlvbiByYWlzZWQgd2hlbiBhIGZvcm1hdCBkb2VzIG5vdCBtYXRjaCBhIGdpdmVuIGZvcm1hdCB0eXBlLiAqKVxuZXhjZXB0aW9uIFR5cGVfbWlzbWF0Y2hcblxuKCogVHlwZSBhIHBhZGRpbmcuICopXG4oKiBUYWtlIGFuIEludF90eSBmcm9tIHRoZSBmbXR0eSBpZiB0aGUgaW50ZWdlciBzaG91bGQgYmUga2VwdCBhcyBhcmd1bWVudC4gKilcbigqIFJhaXNlIFR5cGVfbWlzbWF0Y2ggaW4gY2FzZSBvZiB0eXBlIG1pc21hdGNoLiAqKVxubGV0IHR5cGVfcGFkZGluZyA6IHR5cGUgYSBiIGMgZCBlIGYgeCB5IC5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT5cbiAgICAgIChhLCBiLCBjLCBkLCBlLCBmKSBwYWRkaW5nX2ZtdHR5X2ViYiA9XG5mdW4gcGFkIGZtdHR5IC0+IG1hdGNoIHBhZCwgZm10dHkgd2l0aFxuICB8IE5vX3BhZGRpbmcsIF8gLT4gUGFkZGluZ19mbXR0eV9FQkIgKE5vX3BhZGRpbmcsIGZtdHR5KVxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIF8gLT4gUGFkZGluZ19mbXR0eV9FQkIgKExpdF9wYWRkaW5nIChwYWR0eSx3KSxmbXR0eSlcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgSW50X3R5IHJlc3QgLT4gUGFkZGluZ19mbXR0eV9FQkIgKEFyZ19wYWRkaW5nIHBhZHR5LHJlc3QpXG4gIHwgXyAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbigqIENvbnZlcnQgYSAodXBhZGRpbmcsIHVwcmVjaXNpb24pIHRvIGEgKHBhZGRpbmcsIHByZWNpc2lvbikuICopXG4oKiBUYWtlIG9uZSBvciB0d28gSW50X3R5IGZyb20gdGhlIGZtdHR5IGlmIG5lZWRlZC4gKilcbigqIFJhaXNlIFR5cGVfbWlzbWF0Y2ggaW4gY2FzZSBvZiB0eXBlIG1pc21hdGNoLiAqKVxubGV0IHR5cGVfcGFkcHJlYyA6IHR5cGUgYSBiIGMgZCBlIGYgeCB5IHogLlxuICAoeCwgeSkgcGFkZGluZyAtPiAoeSwgeikgcHJlY2lzaW9uIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBwYWRwcmVjX2ZtdHR5X2ViYiA9XG5mdW4gcGFkIHByZWMgZm10dHkgLT4gbWF0Y2ggcHJlYywgdHlwZV9wYWRkaW5nIHBhZCBmbXR0eSB3aXRoXG4gIHwgTm9fcHJlY2lzaW9uLCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCByZXN0KSAtPlxuICAgIFBhZHByZWNfZm10dHlfRUJCIChwYWQsIE5vX3ByZWNpc2lvbiwgcmVzdClcbiAgfCBMaXRfcHJlY2lzaW9uIHAsIFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIHJlc3QpIC0+XG4gICAgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgTGl0X3ByZWNpc2lvbiBwLCByZXN0KVxuICB8IEFyZ19wcmVjaXNpb24sIFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIEludF90eSByZXN0KSAtPlxuICAgIFBhZHByZWNfZm10dHlfRUJCIChwYWQsIEFyZ19wcmVjaXNpb24sIHJlc3QpXG4gIHwgXywgUGFkZGluZ19mbXR0eV9FQkIgKF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcblxuKCogVHlwZSBhIGZvcm1hdCBhY2NvcmRpbmcgdG8gYW4gZm10dHkuICopXG4oKiBJZiB0eXBpbmcgc3VjY2VlZCwgZ2VuZXJhdGUgYSBjb3B5IG9mIHRoZSBmb3JtYXQgd2l0aCB0aGUgc2FtZVxuICAgIHR5cGUgcGFyYW1ldGVycyBhcyB0aGUgZm10dHkuICopXG4oKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhbiBlcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCByZWMgdHlwZV9mb3JtYXQgOlxuICB0eXBlIGExIGIxIGMxIGQxIGUxIGYxXG4gICAgICAgYTIgYjIgYzIgZDIgZTIgZjIgIC5cbiAgICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdFxuICAtPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlcbiAgLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdFxuPSBmdW4gZm10IGZtdHR5IC0+IG1hdGNoIHR5cGVfZm9ybWF0X2dlbiBmbXQgZm10dHkgd2l0aFxuICB8IEZtdF9mbXR0eV9FQkIgKGZtdCcsIEVuZF9vZl9mbXR0eSkgLT4gZm10J1xuICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG5hbmQgdHlwZV9mb3JtYXRfZ2VuIDpcbiAgdHlwZSBhMSBiMSBjMSBkMSBlMSBmMVxuICAgICAgIGEyIGIyIGMyIGQyIGUyIGYyICAuXG4gICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmbXRcbiAgLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5XG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXRfZm10dHlfZWJiXG49IGZ1biBmbXQgZm10dHkgLT4gbWF0Y2ggZm10LCBmbXR0eSB3aXRoXG4gIHwgQ2hhciBmbXRfcmVzdCwgQ2hhcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKENoYXIgZm10JywgZm10dHknKVxuICB8IENhbWxfY2hhciBmbXRfcmVzdCwgQ2hhcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKENhbWxfY2hhciBmbXQnLCBmbXR0eScpXG4gIHwgU3RyaW5nIChwYWQsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRkaW5nIHBhZCBmbXR0eSB3aXRoXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCBTdHJpbmdfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKFN0cmluZyAocGFkLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IENhbWxfc3RyaW5nIChwYWQsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRkaW5nIHBhZCBmbXR0eSB3aXRoXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCBTdHJpbmdfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKENhbWxfc3RyaW5nIChwYWQsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAoXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkcHJlYyBwYWQgcHJlYyBmbXR0eSB3aXRoXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBwcmVjLCBJbnRfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKEludCAoaWNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZHByZWMgcGFkIHByZWMgZm10dHkgd2l0aFxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgcHJlYywgSW50MzJfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKEludDMyIChpY29udiwgcGFkLCBwcmVjLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKF8sIF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZHByZWMgcGFkIHByZWMgZm10dHkgd2l0aFxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgcHJlYywgTmF0aXZlaW50X3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgSW50NjQgKGljb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIEludDY0X3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZHByZWMgcGFkIHByZWMgZm10dHkgd2l0aFxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgcHJlYywgRmxvYXRfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKF8sIF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEJvb2wgKHBhZCwgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZGRpbmcgcGFkIGZtdHR5IHdpdGhcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIEJvb2xfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKEJvb2wgKHBhZCwgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBGbHVzaCBmbXRfcmVzdCwgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGbHVzaCBmbXQnLCBmbXR0eScpXG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCAoc3RyLCBmbXRfcmVzdCksIGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoU3RyaW5nX2xpdGVyYWwgKHN0ciwgZm10JyksIGZtdHR5JylcbiAgfCBDaGFyX2xpdGVyYWwgKGNociwgZm10X3Jlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKENoYXJfbGl0ZXJhbCAoY2hyLCBmbXQnKSwgZm10dHknKVxuXG4gIHwgRm9ybWF0X2FyZyAocGFkX29wdCwgc3ViX2ZtdHR5LCBmbXRfcmVzdCksXG4gICAgRm9ybWF0X2FyZ190eSAoc3ViX2ZtdHR5JywgZm10dHlfcmVzdCkgLT5cbiAgICBpZiBGbXR0eV9FQkIgc3ViX2ZtdHR5IDw+IEZtdHR5X0VCQiBzdWJfZm10dHknIHRoZW4gcmFpc2UgVHlwZV9taXNtYXRjaDtcbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRm9ybWF0X2FyZyAocGFkX29wdCwgc3ViX2ZtdHR5JywgZm10JyksIGZtdHR5JylcbiAgfCBGb3JtYXRfc3Vic3QgKHBhZF9vcHQsIHN1Yl9mbXR0eSwgZm10X3Jlc3QpLFxuICAgIEZvcm1hdF9zdWJzdF90eSAoc3ViX2ZtdHR5MSwgX3N1Yl9mbXR0eTIsIGZtdHR5X3Jlc3QpIC0+XG4gICAgaWYgRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViX2ZtdHR5KSA8PiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWJfZm10dHkxKSB0aGVuXG4gICAgICByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID1cbiAgICAgIHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCAoZXJhc2VfcmVsIGZtdHR5X3Jlc3QpXG4gICAgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGb3JtYXRfc3Vic3QgKHBhZF9vcHQsIHN1Yl9mbXR0eTEsIGZtdCcpLCBmbXR0eScpXG4gICgqIFByaW50ZiBhbmQgRm9ybWF0IHNwZWNpZmljIGNvbnN0cnVjdG9yczogKilcbiAgfCBBbHBoYSBmbXRfcmVzdCwgQWxwaGFfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChBbHBoYSBmbXQnLCBmbXR0eScpXG4gIHwgVGhldGEgZm10X3Jlc3QsIFRoZXRhX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoVGhldGEgZm10JywgZm10dHknKVxuXG4gICgqIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3RvcnM6ICopXG4gIHwgRm9ybWF0dGluZ19saXQgKGZvcm1hdHRpbmdfbGl0LCBmbXRfcmVzdCksIGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRm9ybWF0dGluZ19saXQgKGZvcm1hdHRpbmdfbGl0LCBmbXQnKSwgZm10dHknKVxuICB8IEZvcm1hdHRpbmdfZ2VuIChmb3JtYXR0aW5nX2dlbiwgZm10X3Jlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgdHlwZV9mb3JtYXR0aW5nX2dlbiBmb3JtYXR0aW5nX2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0XG5cbiAgKCogU2NhbmYgc3BlY2lmaWMgY29uc3RydWN0b3JzOiAqKVxuICB8IFJlYWRlciBmbXRfcmVzdCwgUmVhZGVyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoUmVhZGVyIGZtdCcsIGZtdHR5JylcbiAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBmbXRfcmVzdCksIFN0cmluZ190eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIGZtdCcpLCBmbXR0eScpXG4gIHwgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10X3Jlc3QpLCBJbnRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBmbXQnKSwgZm10dHknKVxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCksIGZtdHR5X3Jlc3QgLT5cbiAgICB0eXBlX2lnbm9yZWRfcGFyYW0gaWduIHJlc3QgZm10dHlfcmVzdFxuXG4gIHwgRW5kX29mX2Zvcm1hdCwgZm10dHlfcmVzdCAtPiBGbXRfZm10dHlfRUJCIChFbmRfb2ZfZm9ybWF0LCBmbXR0eV9yZXN0KVxuXG4gIHwgXyAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbmFuZCB0eXBlX2Zvcm1hdHRpbmdfZ2VuIDogdHlwZSBhMSBhMyBiMSBiMyBjMSBjMyBkMSBkMyBlMSBlMiBlMyBmMSBmMiBmMyAuXG4gICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZvcm1hdHRpbmdfZ2VuIC0+XG4gICAgKGYxLCBiMSwgYzEsIGUxLCBlMiwgZjIpIGZtdCAtPlxuICAgIChhMywgYjMsIGMzLCBkMywgZTMsIGYzKSBmbXR0eSAtPlxuICAgIChhMywgYjMsIGMzLCBkMywgZTMsIGYzKSBmbXRfZm10dHlfZWJiID1cbmZ1biBmb3JtYXR0aW5nX2dlbiBmbXQwIGZtdHR5MCAtPiBtYXRjaCBmb3JtYXR0aW5nX2dlbiB3aXRoXG4gIHwgT3Blbl90YWcgKEZvcm1hdCAoZm10MSwgc3RyKSkgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10MiwgZm10dHkyKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQxIGZtdHR5MCBpblxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQzLCBmbXR0eTMpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdDAgZm10dHkyIGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdDIsIHN0cikpLCBmbXQzKSwgZm10dHkzKVxuICB8IE9wZW5fYm94IChGb3JtYXQgKGZtdDEsIHN0cikpIC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdDIsIGZtdHR5MikgPSB0eXBlX2Zvcm1hdF9nZW4gZm10MSBmbXR0eTAgaW5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10MywgZm10dHkzKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQwIGZtdHR5MiBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQyLCBzdHIpKSwgZm10MyksIGZtdHR5MylcblxuKCogVHlwZSBhbiBJZ25vcmVkX3BhcmFtIG5vZGUgYWNjb3JkaW5nIHRvIGFuIGZtdHR5LiAqKVxuYW5kIHR5cGVfaWdub3JlZF9wYXJhbSA6IHR5cGUgcCBxIHggeSB6IHQgdSB2IGEgYiBjIGQgZSBmIC5cbiAgICAoeCwgeSwgeiwgdCwgcSwgcCkgaWdub3JlZCAtPlxuICAgIChwLCB5LCB6LCBxLCB1LCB2KSBmbXQgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10X2ZtdHR5X2ViYiA9XG5mdW4gaWduIGZtdCBmbXR0eSAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfY2hhciAgICAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfY2FtbF9jaGFyICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfc3RyaW5nIF8gICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgXyAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfaW50IF8gICAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfaW50MzIgXyAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfbmF0aXZlaW50IF8gICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfaW50NjQgXyAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfZmxvYXQgXyAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfYm9vbCBfICAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCBfICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBfIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfZm9ybWF0X2FyZyAocGFkX29wdCwgc3ViX2ZtdHR5KSAtPlxuICAgIHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgKElnbm9yZWRfZm9ybWF0X2FyZyAocGFkX29wdCwgc3ViX2ZtdHR5KSkgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKHBhZF9vcHQsIHN1Yl9mbXR0eSkgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5JywgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSkgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5IGZtdCBmbXR0eSBpblxuICAgIEZtdF9mbXR0eV9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfZm9ybWF0X3N1YnN0IChwYWRfb3B0LCBzdWJfZm10dHknKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbXQnKSxcbiAgICAgICAgICAgICAgICAgICBmbXR0eScpXG4gIHwgSWdub3JlZF9yZWFkZXIgLT4gKFxuICAgIG1hdGNoIGZtdHR5IHdpdGhcbiAgICB8IElnbm9yZWRfcmVhZGVyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX3JlYWRlciwgZm10JyksIGZtdHR5JylcbiAgICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG5cbmFuZCB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIDogdHlwZSBhMSBhMiBiMSBiMiBjMSBjMiBkMSBkMiBlMSBlMiBmMSBmMiAuXG4gICAgKGEyLCBiMiwgYzIsIGQyLCBkMiwgYTIpIGlnbm9yZWQgLT5cbiAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10IC0+XG4gICAgKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5IC0+XG4gICAgKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdF9mbXR0eV9lYmJcbj0gZnVuIGlnbiBmbXQgZm10dHkgLT5cbiAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10IGZtdHR5IGluXG4gIEZtdF9mbXR0eV9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbiwgZm10JyksIGZtdHR5JylcblxuKCogVHlwaW5nIG9mIHRoZSBjb21wbGV4IGNhc2U6IFwiJV8oLi4uJSlcIi4gKilcbmFuZCB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiA6IHR5cGUgdyB4IHkgeiBwIHMgdCB1IGEgYiBjIGQgZSBmIC5cbiAgICAodywgeCwgeSwgeiwgcywgcCkgZm10dHkgLT5cbiAgICAocCwgeCwgeSwgcywgdCwgdSkgZm10IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eV9mbXRfZWJiID1cbmZ1biBzdWJfZm10dHkgZm10IGZtdHR5IC0+IG1hdGNoIHN1Yl9mbXR0eSwgZm10dHkgd2l0aFxuICB8IENoYXJfdHkgc3ViX2ZtdHR5X3Jlc3QsIENoYXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoQ2hhcl90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgU3RyaW5nX3R5IHN1Yl9mbXR0eV9yZXN0LCBTdHJpbmdfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoU3RyaW5nX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBJbnRfdHkgc3ViX2ZtdHR5X3Jlc3QsIEludF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChJbnRfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEludDMyX3R5IHN1Yl9mbXR0eV9yZXN0LCBJbnQzMl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChJbnQzMl90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgTmF0aXZlaW50X3R5IHN1Yl9mbXR0eV9yZXN0LCBOYXRpdmVpbnRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoTmF0aXZlaW50X3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBJbnQ2NF90eSBzdWJfZm10dHlfcmVzdCwgSW50NjRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoSW50NjRfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEZsb2F0X3R5IHN1Yl9mbXR0eV9yZXN0LCBGbG9hdF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChGbG9hdF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgQm9vbF90eSBzdWJfZm10dHlfcmVzdCwgQm9vbF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChCb29sX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBBbHBoYV90eSBzdWJfZm10dHlfcmVzdCwgQWxwaGFfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoQWxwaGFfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IFRoZXRhX3R5IHN1Yl9mbXR0eV9yZXN0LCBUaGV0YV90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChUaGV0YV90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgUmVhZGVyX3R5IHN1Yl9mbXR0eV9yZXN0LCBSZWFkZXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoUmVhZGVyX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSBzdWJfZm10dHlfcmVzdCwgSWdub3JlZF9yZWFkZXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoSWdub3JlZF9yZWFkZXJfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuXG4gIHwgRm9ybWF0X2FyZ190eSAoc3ViMl9mbXR0eSwgc3ViX2ZtdHR5X3Jlc3QpLFxuICAgIEZvcm1hdF9hcmdfdHkgKHN1YjJfZm10dHknLCBmbXR0eV9yZXN0KSAtPlxuICAgIGlmIEZtdHR5X0VCQiBzdWIyX2ZtdHR5IDw+IEZtdHR5X0VCQiBzdWIyX2ZtdHR5JyB0aGVuIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChGb3JtYXRfYXJnX3R5IChzdWIyX2ZtdHR5Jywgc3ViX2ZtdHR5X3Jlc3QnKSwgZm10JylcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHN1YjFfZm10dHksICBzdWIyX2ZtdHR5LCAgc3ViX2ZtdHR5X3Jlc3QpLFxuICAgIEZvcm1hdF9zdWJzdF90eSAoc3ViMV9mbXR0eScsIHN1YjJfZm10dHknLCBmbXR0eV9yZXN0KSAtPlxuICAgICgqIFRPRE8gZGVmaW5lIEZtdHR5X3JlbF9FQkIgdG8gcmVtb3ZlIHRob3NlIGVyYXNlX3JlbCAqKVxuICAgIGlmIEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1YjFfZm10dHkpIDw+IEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1YjFfZm10dHknKVxuICAgIHRoZW4gcmFpc2UgVHlwZV9taXNtYXRjaDtcbiAgICBpZiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWIyX2ZtdHR5KSA8PiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWIyX2ZtdHR5JylcbiAgICB0aGVuIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgbGV0IHN1Yl9mbXR0eScgPSB0cmFucyAoc3ltbSBzdWIxX2ZtdHR5Jykgc3ViMl9mbXR0eScgaW5cbiAgICBsZXQgXywgZjIsIF8sIGY0ID0gZm10dHlfcmVsX2RldCBzdWJfZm10dHknIGluXG4gICAgbGV0IFJlZmwgPSBmMiBSZWZsIGluXG4gICAgbGV0IFJlZmwgPSBmNCBSZWZsIGluXG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gKGVyYXNlX3JlbCBzdWJfZm10dHlfcmVzdCkgZm10IGZtdHR5X3Jlc3RcbiAgICBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEZvcm1hdF9zdWJzdF90eSAoc3ViMV9mbXR0eScsIHN1YjJfZm10dHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltbSBzdWJfZm10dHlfcmVzdCcpLFxuICAgICAgICAgICAgICAgICAgIGZtdCcpXG4gIHwgRW5kX29mX2ZtdHR5LCBmbXR0eSAtPlxuICAgIEZtdHR5X2ZtdF9FQkIgKEVuZF9vZl9mbXR0eSwgdHlwZV9mb3JtYXRfZ2VuIGZtdCBmbXR0eSlcbiAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcblxuKCogVGhpcyBpbXBsZW1lbnRhdGlvbiBvZiBgcmVjYXN0YCBpcyBhIGJpdCBkaXNhcHBvaW50aW5nLiBUaGVcbiAgIGludmFyaWFudCBwcm92aWRlZCBieSB0aGUgdHlwZSBhcmUgdmVyeSBzdHJvbmc6IHRoZSBpbnB1dCBmb3JtYXQnc1xuICAgdHlwZSBpcyBpbiByZWxhdGlvbiB0byB0aGUgb3V0cHV0IHR5cGUncyBhcyB3aXRuZXNzZWQgYnkgdGhlXG4gICBmbXR0eV9yZWwgYXJndW1lbnQuIE9uZSB3b3VsZCBhdCBmaXJzdCBleHBlY3QgdGhpcyBmdW5jdGlvbiB0byBiZVxuICAgdG90YWwsIGFuZCBpbXBsZW1lbnRhYmxlIGJ5IGV4aGF1c3RpdmUgcGF0dGVybiBtYXRjaGluZy4gSW5zdGVhZCxcbiAgIHdlIHJldXNlIHRoZSBoaWdobHkgcGFydGlhbCBhbmQgbXVjaCBsZXNzIHdlbGwtZGVmaW5lZCBmdW5jdGlvblxuICAgYHR5cGVfZm9ybWF0YCB0aGF0IGhhcyBsb3N0IGFsbCBrbm93bGVkZ2Ugb2YgdGhlIGNvcnJlc3BvbmRlbmNlXG4gICBiZXR3ZWVuIHRoZSBhcmd1bWVudCdzIHR5cGVzLlxuXG4gICBCZXNpZGVzIHRoZSBmYWN0IHRoYXQgdGhpcyBmdW5jdGlvbiByZXVzZXMgYSBsb3Qgb2YgdGhlXG4gICBgdHlwZV9mb3JtYXRgIGxvZ2ljIChlZy46IHNlZWluZyBJbnRfdHkgaW4gdGhlIGZtdHR5IHBhcmFtZXRlciBkb2VzXG4gICBub3QgbGV0IHlvdSBtYXRjaCBvbiBJbnQgb25seSwgYXMgeW91IG1heSBpbiBmYWN0IGhhdmUgRmxvYXRcbiAgIChBcmdfcGFkZGluZywgLi4uKSAoXCIlLipkXCIpIGJlZ2lubmluZyB3aXRoIGFuIEludF90eSksIGl0IGlzIGFsc29cbiAgIGEgcGFydGlhbCBmdW5jdGlvbiwgYmVjYXVzZSB0aGUgdHlwaW5nIGluZm9ybWF0aW9uIGluIGEgZm9ybWF0IGlzXG4gICBub3QgcXVpdGUgZW5vdWdoIHRvIHJlY29uc3RydWN0IGl0IHVuYW1iaWd1b3VzbHkuIEZvciBleGFtcGxlLCB0aGVcbiAgIGZvcm1hdCB0eXBlcyBvZiBcIiVkJV9yXCIgYW5kIFwiJV9yJWRcIiBoYXZlIHRoZSBzYW1lIGZvcm1hdDZcbiAgIHBhcmFtZXRlcnMsIGJ1dCB0aGV5IGFyZSBub3QgYXQgYWxsIGV4Y2hhbmdlYWJsZSwgYW5kIHB1dHRpbmcgb25lXG4gICBpbiBwbGFjZSBvZiB0aGUgb3RoZXIgbXVzdCByZXN1bHQgaW4gYSBkeW5hbWljIGZhaWx1cmUuXG5cbiAgIEdpdmVuIHRoYXQ6XG4gICAtIHdlJ2QgaGF2ZSB0byBkdXBsaWNhdGUgYSBsb3Qgb2Ygbm9uLXRyaXZpYWwgdHlwaW5nIGxvZ2ljIGZyb20gdHlwZV9mb3JtYXRcbiAgIC0gdGhpcyB3b3VsZG4ndCBldmVuIGVsaW1pbmF0ZSAoYWxsKSB0aGUgZHluYW1pYyBmYWlsdXJlc1xuICAgd2UgZGVjaWRlZCB0byBqdXN0IHJldXNlIHR5cGVfZm9ybWF0IGRpcmVjdGx5IGZvciBub3cuXG4qKVxubGV0IHJlY2FzdCA6XG4gIHR5cGUgYTEgYjEgYzEgZDEgZTEgZjFcbiAgICAgICBhMiBiMiBjMiBkMiBlMiBmMlxuICAuXG4gICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmbXRcbiAgLT4gKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgICBhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eV9yZWxcbiAgLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdFxuPSBmdW4gZm10IGZtdHR5IC0+XG4gIHR5cGVfZm9ybWF0IGZtdCAoZXJhc2VfcmVsIChzeW1tIGZtdHR5KSlcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogUHJpbnRpbmcgdG9vbHMgKilcblxuKCogQWRkIHBhZGRpbmcgc3BhY2VzIGFyb3VuZCBhIHN0cmluZy4gKilcbmxldCBmaXhfcGFkZGluZyBwYWR0eSB3aWR0aCBzdHIgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbGV0IHdpZHRoLCBwYWR0eSA9XG4gICAgYWJzIHdpZHRoLFxuICAgICgqIHdoaWxlIGxpdGVyYWwgcGFkZGluZyB3aWR0aHMgYXJlIGFsd2F5cyBub24tbmVnYXRpdmUsXG4gICAgICAgZHluYW1pY2FsbHktc2V0IHdpZHRocyAoQXJnX3BhZGRpbmcsIGVnLiAlKmQpIG1heSBiZSBuZWdhdGl2ZTtcbiAgICAgICB3ZSBpbnRlcnByZXQgdGhvc2UgYXMgc3BlY2lmeWluZyBhIHBhZGRpbmctdG8tdGhlLWxlZnQ7IHRoaXNcbiAgICAgICBtZWFucyB0aGF0ICcwJyBtYXkgZ2V0IGRyb3BwZWQgZXZlbiBpZiBpdCB3YXMgZXhwbGljaXRseSBzZXQsXG4gICAgICAgYnV0OlxuICAgICAgIC0gdGhpcyBpcyB3aGF0IHRoZSBsZWdhY3kgaW1wbGVtZW50YXRpb24gZG9lcywgYW5kXG4gICAgICAgICB3ZSBwcmVzZXJ2ZSBjb21wYXRpYmlsaXR5IGlmIHBvc3NpYmxlXG4gICAgICAgLSB3ZSBjb3VsZCBvbmx5IHNpZ25hbCB0aGlzIGlzc3VlIGJ5IGZhaWxpbmcgYXQgcnVudGltZSxcbiAgICAgICAgIHdoaWNoIGlzIG5vdCB2ZXJ5IG5pY2UuLi4gKilcbiAgICBpZiB3aWR0aCA8IDAgdGhlbiBMZWZ0IGVsc2UgcGFkdHkgaW5cbiAgaWYgd2lkdGggPD0gbGVuIHRoZW4gc3RyIGVsc2VcbiAgICBsZXQgcmVzID0gQnl0ZXMubWFrZSB3aWR0aCAoaWYgcGFkdHkgPSBaZXJvcyB0aGVuICcwJyBlbHNlICcgJykgaW5cbiAgICBiZWdpbiBtYXRjaCBwYWR0eSB3aXRoXG4gICAgfCBMZWZ0ICAtPiBTdHJpbmcuYmxpdCBzdHIgMCByZXMgMCBsZW5cbiAgICB8IFJpZ2h0IC0+IFN0cmluZy5ibGl0IHN0ciAwIHJlcyAod2lkdGggLSBsZW4pIGxlblxuICAgIHwgWmVyb3Mgd2hlbiBsZW4gPiAwICYmIChzdHIuWzBdID0gJysnIHx8IHN0ci5bMF0gPSAnLScgfHwgc3RyLlswXSA9ICcgJykgLT5cbiAgICAgIEJ5dGVzLnNldCByZXMgMCBzdHIuWzBdO1xuICAgICAgU3RyaW5nLmJsaXQgc3RyIDEgcmVzICh3aWR0aCAtIGxlbiArIDEpIChsZW4gLSAxKVxuICAgIHwgWmVyb3Mgd2hlbiBsZW4gPiAxICYmIHN0ci5bMF0gPSAnMCcgJiYgKHN0ci5bMV0gPSAneCcgfHwgc3RyLlsxXSA9ICdYJykgLT5cbiAgICAgIEJ5dGVzLnNldCByZXMgMSBzdHIuWzFdO1xuICAgICAgU3RyaW5nLmJsaXQgc3RyIDIgcmVzICh3aWR0aCAtIGxlbiArIDIpIChsZW4gLSAyKVxuICAgIHwgWmVyb3MgLT5cbiAgICAgIFN0cmluZy5ibGl0IHN0ciAwIHJlcyAod2lkdGggLSBsZW4pIGxlblxuICAgIGVuZDtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuXG4oKiBBZGQgJzAnIHBhZGRpbmcgdG8gaW50LCBpbnQzMiwgbmF0aXZlaW50IG9yIGludDY0IHN0cmluZyByZXByZXNlbnRhdGlvbi4gKilcbmxldCBmaXhfaW50X3ByZWNpc2lvbiBwcmVjIHN0ciA9XG4gIGxldCBwcmVjID0gYWJzIHByZWMgaW5cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIG1hdGNoIHN0ci5bMF0gd2l0aFxuICB8ICgnKycgfCAnLScgfCAnICcpIGFzIGMgd2hlbiBwcmVjICsgMSA+IGxlbiAtPlxuICAgIGxldCByZXMgPSBCeXRlcy5tYWtlIChwcmVjICsgMSkgJzAnIGluXG4gICAgQnl0ZXMuc2V0IHJlcyAwIGM7XG4gICAgU3RyaW5nLmJsaXQgc3RyIDEgcmVzIChwcmVjIC0gbGVuICsgMikgKGxlbiAtIDEpO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG4gIHwgJzAnIHdoZW4gcHJlYyArIDIgPiBsZW4gJiYgbGVuID4gMSAmJiAoc3RyLlsxXSA9ICd4JyB8fCBzdHIuWzFdID0gJ1gnKSAtPlxuICAgIGxldCByZXMgPSBCeXRlcy5tYWtlIChwcmVjICsgMikgJzAnIGluXG4gICAgQnl0ZXMuc2V0IHJlcyAxIHN0ci5bMV07XG4gICAgU3RyaW5nLmJsaXQgc3RyIDIgcmVzIChwcmVjIC0gbGVuICsgNCkgKGxlbiAtIDIpO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG4gIHwgJzAnIC4uICc5JyB8ICdhJyAuLiAnZicgfCAnQScgLi4gJ0YnIHdoZW4gcHJlYyA+IGxlbiAtPlxuICAgIGxldCByZXMgPSBCeXRlcy5tYWtlIHByZWMgJzAnIGluXG4gICAgU3RyaW5nLmJsaXQgc3RyIDAgcmVzIChwcmVjIC0gbGVuKSBsZW47XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcbiAgfCBfIC0+XG4gICAgc3RyXG5cbigqIEVzY2FwZSBhIHN0cmluZyBhY2NvcmRpbmcgdG8gdGhlIE9DYW1sIGxleGluZyBjb252ZW50aW9uLiAqKVxubGV0IHN0cmluZ190b19jYW1sX3N0cmluZyBzdHIgPVxuICBsZXQgc3RyID0gU3RyaW5nLmVzY2FwZWQgc3RyIGluXG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbGV0IHJlcyA9IEJ5dGVzLm1ha2UgKGwgKyAyKSAnXFxcIicgaW5cbiAgU3RyaW5nLnVuc2FmZV9ibGl0IHN0ciAwIHJlcyAxIGw7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG5cbigqIEdlbmVyYXRlIHRoZSBmb3JtYXRfaW50L2ludDMyL25hdGl2ZWludC9pbnQ2NCBmaXJzdCBhcmd1bWVudFxuICAgZnJvbSBhbiBpbnRfY29udi4gKilcbmxldCBmb3JtYXRfb2ZfaWNvbnYgPSBmdW5jdGlvblxuICB8IEludF9kIC0+IFwiJWRcIiB8IEludF9wZCAtPiBcIiUrZFwiIHwgSW50X3NkIC0+IFwiJSBkXCJcbiAgfCBJbnRfaSAtPiBcIiVpXCIgfCBJbnRfcGkgLT4gXCIlK2lcIiB8IEludF9zaSAtPiBcIiUgaVwiXG4gIHwgSW50X3ggLT4gXCIleFwiIHwgSW50X0N4IC0+IFwiJSN4XCJcbiAgfCBJbnRfWCAtPiBcIiVYXCIgfCBJbnRfQ1ggLT4gXCIlI1hcIlxuICB8IEludF9vIC0+IFwiJW9cIiB8IEludF9DbyAtPiBcIiUjb1wiXG4gIHwgSW50X3UgLT4gXCIldVwiXG5cbmxldCBmb3JtYXRfb2ZfaWNvbnZMID0gZnVuY3Rpb25cbiAgfCBJbnRfZCAtPiBcIiVMZFwiIHwgSW50X3BkIC0+IFwiJStMZFwiIHwgSW50X3NkIC0+IFwiJSBMZFwiXG4gIHwgSW50X2kgLT4gXCIlTGlcIiB8IEludF9waSAtPiBcIiUrTGlcIiB8IEludF9zaSAtPiBcIiUgTGlcIlxuICB8IEludF94IC0+IFwiJUx4XCIgfCBJbnRfQ3ggLT4gXCIlI0x4XCJcbiAgfCBJbnRfWCAtPiBcIiVMWFwiIHwgSW50X0NYIC0+IFwiJSNMWFwiXG4gIHwgSW50X28gLT4gXCIlTG9cIiB8IEludF9DbyAtPiBcIiUjTG9cIlxuICB8IEludF91IC0+IFwiJUx1XCJcblxubGV0IGZvcm1hdF9vZl9pY29udmwgPSBmdW5jdGlvblxuICB8IEludF9kIC0+IFwiJWxkXCIgfCBJbnRfcGQgLT4gXCIlK2xkXCIgfCBJbnRfc2QgLT4gXCIlIGxkXCJcbiAgfCBJbnRfaSAtPiBcIiVsaVwiIHwgSW50X3BpIC0+IFwiJStsaVwiIHwgSW50X3NpIC0+IFwiJSBsaVwiXG4gIHwgSW50X3ggLT4gXCIlbHhcIiB8IEludF9DeCAtPiBcIiUjbHhcIlxuICB8IEludF9YIC0+IFwiJWxYXCIgfCBJbnRfQ1ggLT4gXCIlI2xYXCJcbiAgfCBJbnRfbyAtPiBcIiVsb1wiIHwgSW50X0NvIC0+IFwiJSNsb1wiXG4gIHwgSW50X3UgLT4gXCIlbHVcIlxuXG5sZXQgZm9ybWF0X29mX2ljb252biA9IGZ1bmN0aW9uXG4gIHwgSW50X2QgLT4gXCIlbmRcIiB8IEludF9wZCAtPiBcIiUrbmRcIiB8IEludF9zZCAtPiBcIiUgbmRcIlxuICB8IEludF9pIC0+IFwiJW5pXCIgfCBJbnRfcGkgLT4gXCIlK25pXCIgfCBJbnRfc2kgLT4gXCIlIG5pXCJcbiAgfCBJbnRfeCAtPiBcIiVueFwiIHwgSW50X0N4IC0+IFwiJSNueFwiXG4gIHwgSW50X1ggLT4gXCIlblhcIiB8IEludF9DWCAtPiBcIiUjblhcIlxuICB8IEludF9vIC0+IFwiJW5vXCIgfCBJbnRfQ28gLT4gXCIlI25vXCJcbiAgfCBJbnRfdSAtPiBcIiVudVwiXG5cbigqIEdlbmVyYXRlIHRoZSBmb3JtYXRfZmxvYXQgZmlyc3QgYXJndW1lbnQgZm9ybSBhIGZsb2F0X2NvbnYuICopXG5sZXQgZm9ybWF0X29mX2Zjb252IGZjb252IHByZWMgPVxuICBpZiBmY29udiA9IEZsb2F0X0YgdGhlbiBcIiUuMTJnXCIgZWxzZVxuICAgIGxldCBwcmVjID0gYWJzIHByZWMgaW5cbiAgICBsZXQgc3ltYiA9IGNoYXJfb2ZfZmNvbnYgZmNvbnYgaW5cbiAgICBsZXQgYnVmID0gYnVmZmVyX2NyZWF0ZSAxNiBpblxuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnO1xuICAgIGJwcmludF9mY29udl9mbGFnIGJ1ZiBmY29udjtcbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmICcuJztcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgKHN0cmluZ19vZl9pbnQgcHJlYyk7XG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiBzeW1iO1xuICAgIGJ1ZmZlcl9jb250ZW50cyBidWZcblxuKCogQ29udmVydCBhbiBpbnRlZ2VyIHRvIGEgc3RyaW5nIGFjY29yZGluZyB0byBhIGNvbnZlcnNpb24uICopXG5sZXQgY29udmVydF9pbnQgaWNvbnYgbiA9IGZvcm1hdF9pbnQgKGZvcm1hdF9vZl9pY29udiBpY29udikgblxubGV0IGNvbnZlcnRfaW50MzIgaWNvbnYgbiA9IGZvcm1hdF9pbnQzMiAoZm9ybWF0X29mX2ljb252bCBpY29udikgblxubGV0IGNvbnZlcnRfbmF0aXZlaW50IGljb252IG4gPSBmb3JtYXRfbmF0aXZlaW50IChmb3JtYXRfb2ZfaWNvbnZuIGljb252KSBuXG5sZXQgY29udmVydF9pbnQ2NCBpY29udiBuID0gZm9ybWF0X2ludDY0IChmb3JtYXRfb2ZfaWNvbnZMIGljb252KSBuXG5cbigqIENvbnZlcnQgYSBmbG9hdCB0byBzdHJpbmcuICopXG4oKiBGaXggc3BlY2lhbCBjYXNlIG9mIFwiT0NhbWwgZmxvYXQgZm9ybWF0XCIuICopXG5sZXQgY29udmVydF9mbG9hdCBmY29udiBwcmVjIHggPVxuICBtYXRjaCBmY29udiB3aXRoXG4gIHwgRmxvYXRfaCB8IEZsb2F0X3BoIHwgRmxvYXRfc2ggfCBGbG9hdF9IIHwgRmxvYXRfcEggfCBGbG9hdF9zSCAtPlxuICAgIGxldCBzaWduID1cbiAgICAgIG1hdGNoIGZjb252IHdpdGhcbiAgICAgIHwgRmxvYXRfcGggfCBGbG9hdF9wSCAtPiAnKydcbiAgICAgIHwgRmxvYXRfc2ggfCBGbG9hdF9zSCAtPiAnICdcbiAgICAgIHwgXyAtPiAnLScgaW5cbiAgICBsZXQgc3RyID0gaGV4c3RyaW5nX29mX2Zsb2F0IHggcHJlYyBzaWduIGluXG4gICAgYmVnaW4gbWF0Y2ggZmNvbnYgd2l0aFxuICAgIHwgRmxvYXRfSCB8IEZsb2F0X3BIIHwgRmxvYXRfc0ggLT4gU3RyaW5nLnVwcGVyY2FzZV9hc2NpaSBzdHJcbiAgICB8IF8gLT4gc3RyXG4gICAgZW5kXG4gIHwgXyAtPlxuICAgIGxldCBzdHIgPSBmb3JtYXRfZmxvYXQgKGZvcm1hdF9vZl9mY29udiBmY29udiBwcmVjKSB4IGluXG4gICAgaWYgZmNvbnYgPD4gRmxvYXRfRiB0aGVuIHN0ciBlbHNlXG4gICAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgICAgIGxldCByZWMgaXNfdmFsaWQgaSA9XG4gICAgICAgIGlmIGkgPSBsZW4gdGhlbiBmYWxzZSBlbHNlXG4gICAgICAgICAgbWF0Y2ggc3RyLltpXSB3aXRoXG4gICAgICAgICAgfCAnLicgfCAnZScgfCAnRScgLT4gdHJ1ZVxuICAgICAgICAgIHwgXyAtPiBpc192YWxpZCAoaSArIDEpXG4gICAgICBpblxuICAgICAgbWF0Y2ggY2xhc3NpZnlfZmxvYXQgeCB3aXRoXG4gICAgICB8IEZQX25vcm1hbCB8IEZQX3N1Ym5vcm1hbCB8IEZQX3plcm8gLT5cbiAgICAgICAgaWYgaXNfdmFsaWQgMCB0aGVuIHN0ciBlbHNlIHN0ciBeIFwiLlwiXG4gICAgICB8IEZQX2luZmluaXRlIC0+XG4gICAgICAgIGlmIHggPCAwLjAgdGhlbiBcIm5lZ19pbmZpbml0eVwiIGVsc2UgXCJpbmZpbml0eVwiXG4gICAgICB8IEZQX25hbiAtPiBcIm5hblwiXG5cbigqIENvbnZlcnQgYSBjaGFyIHRvIGEgc3RyaW5nIGFjY29yZGluZyB0byB0aGUgT0NhbWwgbGV4aWNhbCBjb252ZW50aW9uLiAqKVxubGV0IGZvcm1hdF9jYW1sX2NoYXIgYyA9XG4gIGxldCBzdHIgPSBDaGFyLmVzY2FwZWQgYyBpblxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIGxldCByZXMgPSBCeXRlcy5tYWtlIChsICsgMikgJ1xcJycgaW5cbiAgU3RyaW5nLnVuc2FmZV9ibGl0IHN0ciAwIHJlcyAxIGw7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG5cbigqIENvbnZlcnQgYSBmb3JtYXQgdHlwZSB0byBzdHJpbmcgKilcbmxldCBzdHJpbmdfb2ZfZm10dHkgZm10dHkgPVxuICBsZXQgYnVmID0gYnVmZmVyX2NyZWF0ZSAxNiBpblxuICBicHJpbnRfZm10dHkgYnVmIGZtdHR5O1xuICBidWZmZXJfY29udGVudHMgYnVmXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAoKiBHZW5lcmljIHByaW50aW5nIGZ1bmN0aW9uICopXG5cbigqIE1ha2UgYSBnZW5lcmljIHByaW50aW5nIGZ1bmN0aW9uLiAqKVxuKCogVXNlZCB0byBnZW5lcmF0ZSBQcmludGYgYW5kIEZvcm1hdCBwcmludGluZyBmdW5jdGlvbnMuICopXG4oKiBQYXJhbWV0ZXJzOlxuICAgICBrOiBhIGNvbnRpbnVhdGlvbiBmaW5hbGx5IGFwcGxpZWQgdG8gdGhlIG91dHB1dCBzdHJlYW0gYW5kIHRoZSBhY2N1bXVsYXRvci5cbiAgICAgbzogdGhlIG91dHB1dCBzdHJlYW0gKHNlZSBrLCAlYSBhbmQgJXQpLlxuICAgICBhY2M6IHJldiBsaXN0IG9mIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXNoLCBmb3JtYXR0aW5nLCAuLi4pLlxuICAgICBmbXQ6IHRoZSBmb3JtYXQuICopXG5sZXQgcmVjIG1ha2VfcHJpbnRmIDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gICAgKGIgLT4gKGIsIGMpIGFjYyAtPiBmKSAtPiBiIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IGEgPVxuZnVuIGsgbyBhY2MgZm10IC0+IG1hdGNoIGZtdCB3aXRoXG4gIHwgQ2hhciByZXN0IC0+XG4gICAgZnVuIGMgLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfY2hhciAoYWNjLCBjKSBpblxuICAgICAgbWFrZV9wcmludGYgayBvIG5ld19hY2MgcmVzdFxuICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgZnVuIGMgLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfc3RyaW5nIChhY2MsIGZvcm1hdF9jYW1sX2NoYXIgYykgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyBuZXdfYWNjIHJlc3RcbiAgfCBTdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBtYWtlX3BhZGRpbmcgayBvIGFjYyByZXN0IHBhZCAoZnVuIHN0ciAtPiBzdHIpXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBtYWtlX3BhZGRpbmcgayBvIGFjYyByZXN0IHBhZCBzdHJpbmdfdG9fY2FtbF9zdHJpbmdcbiAgfCBJbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24gayBvIGFjYyByZXN0IHBhZCBwcmVjIGNvbnZlcnRfaW50IGljb252XG4gIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24gayBvIGFjYyByZXN0IHBhZCBwcmVjIGNvbnZlcnRfaW50MzIgaWNvbnZcbiAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24gayBvIGFjYyByZXN0IHBhZCBwcmVjIGNvbnZlcnRfbmF0aXZlaW50IGljb252XG4gIHwgSW50NjQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24gayBvIGFjYyByZXN0IHBhZCBwcmVjIGNvbnZlcnRfaW50NjQgaWNvbnZcbiAgfCBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBtYWtlX2Zsb2F0X3BhZGRpbmdfcHJlY2lzaW9uIGsgbyBhY2MgcmVzdCBwYWQgcHJlYyBmY29udlxuICB8IEJvb2wgKHBhZCwgcmVzdCkgLT5cbiAgICBtYWtlX3BhZGRpbmcgayBvIGFjYyByZXN0IHBhZCBzdHJpbmdfb2ZfYm9vbFxuICB8IEFscGhhIHJlc3QgLT5cbiAgICBmdW4gZiB4IC0+IG1ha2VfcHJpbnRmIGsgbyAoQWNjX2RlbGF5IChhY2MsIGZ1biBvIC0+IGYgbyB4KSkgcmVzdFxuICB8IFRoZXRhIHJlc3QgLT5cbiAgICBmdW4gZiAtPiBtYWtlX3ByaW50ZiBrIG8gKEFjY19kZWxheSAoYWNjLCBmKSkgcmVzdFxuICB8IEN1c3RvbSAoYXJpdHksIGYsIHJlc3QpIC0+XG4gICAgbWFrZV9jdXN0b20gayBvIGFjYyByZXN0IGFyaXR5IChmICgpKVxuICB8IFJlYWRlciBfIC0+XG4gICAgKCogVGhpcyBjYXNlIGlzIGltcG9zc2libGUsIGJ5IHR5cGluZyBvZiBmb3JtYXRzLiAqKVxuICAgICgqIEluZGVlZCwgc2luY2UgcHJpbnRmIGFuZCBjby4gdGFrZSBhIGZvcm1hdDQgYXMgYXJndW1lbnQsIHRoZSAnZCBhbmQgJ2VcbiAgICAgICB0eXBlIHBhcmFtZXRlcnMgb2YgZm10IGFyZSBvYnZpb3VzbHkgZXF1YWxzLiBUaGUgUmVhZGVyIGlzIHRoZVxuICAgICAgIG9ubHkgY29uc3RydWN0b3Igd2hpY2ggdG91Y2ggJ2QgYW5kICdlIHR5cGUgcGFyYW1ldGVycyBvZiB0aGUgZm9ybWF0XG4gICAgICAgdHlwZSwgaXQgYWRkcyBhbiAoLT4pIHRvIHRoZSAnZCBwYXJhbWV0ZXJzLiBDb25zZXF1ZW50bHksIGEgZm9ybWF0NFxuICAgICAgIGNhbm5vdCBjb250YWluIGEgUmVhZGVyIG5vZGUsIGV4Y2VwdCBpbiB0aGUgc3ViLWZvcm1hdCBhc3NvY2lhdGVkIHRvXG4gICAgICAgYW4gJXsuLi4lfS4gSXQncyBub3QgYSBwcm9ibGVtIGJlY2F1c2UgbWFrZV9wcmludGYgZG8gbm90IGNhbGxcbiAgICAgICBpdHNlbGYgcmVjdXJzaXZlbHkgb24gdGhlIHN1Yi1mb3JtYXQgYXNzb2NpYXRlZCB0byAley4uLiV9LiAqKVxuICAgIGFzc2VydCBmYWxzZVxuICB8IEZsdXNoIHJlc3QgLT5cbiAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19mbHVzaCBhY2MpIHJlc3RcblxuICB8IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIC0+XG4gICAgbWFrZV9wcmludGYgayBvIChBY2Nfc3RyaW5nX2xpdGVyYWwgKGFjYywgc3RyKSkgcmVzdFxuICB8IENoYXJfbGl0ZXJhbCAoY2hyLCByZXN0KSAtPlxuICAgIG1ha2VfcHJpbnRmIGsgbyAoQWNjX2NoYXJfbGl0ZXJhbCAoYWNjLCBjaHIpKSByZXN0XG5cbiAgfCBGb3JtYXRfYXJnIChfLCBzdWJfZm10dHksIHJlc3QpIC0+XG4gICAgbGV0IHR5ID0gc3RyaW5nX29mX2ZtdHR5IHN1Yl9mbXR0eSBpblxuICAgIChmdW4gc3RyIC0+XG4gICAgICBpZ25vcmUgc3RyO1xuICAgICAgbWFrZV9wcmludGYgayBvIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgdHkpKSByZXN0KVxuICB8IEZvcm1hdF9zdWJzdCAoXywgZm10dHksIHJlc3QpIC0+XG4gICAgZnVuIChGb3JtYXQgKGZtdCwgXykpIC0+IG1ha2VfcHJpbnRmIGsgbyBhY2NcbiAgICAgIChjb25jYXRfZm10IChyZWNhc3QgZm10IGZtdHR5KSByZXN0KVxuXG4gIHwgU2Nhbl9jaGFyX3NldCAoXywgXywgcmVzdCkgLT5cbiAgICBsZXQgbmV3X2FjYyA9IEFjY19pbnZhbGlkX2FyZyAoYWNjLCBcIlByaW50ZjogYmFkIGNvbnZlcnNpb24gJVtcIikgaW5cbiAgICBmdW4gXyAtPiBtYWtlX3ByaW50ZiBrIG8gbmV3X2FjYyByZXN0XG4gIHwgU2Nhbl9nZXRfY291bnRlciAoXywgcmVzdCkgLT5cbiAgICAoKiBUaGlzIGNhc2Ugc2hvdWxkIGJlIHJlZnVzZWQgZm9yIFByaW50Zi4gKilcbiAgICAoKiBBY2NlcHRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS4gKilcbiAgICAoKiBJbnRlcnByZXQgJWwsICVuIGFuZCAlTCBhcyAldS4gKilcbiAgICBmdW4gbiAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9zdHJpbmcgKGFjYywgZm9ybWF0X2ludCBcIiV1XCIgbikgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyBuZXdfYWNjIHJlc3RcbiAgfCBTY2FuX25leHRfY2hhciByZXN0IC0+XG4gICAgZnVuIGMgLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfY2hhciAoYWNjLCBjKSBpblxuICAgICAgbWFrZV9wcmludGYgayBvIG5ld19hY2MgcmVzdFxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICBtYWtlX2lnbm9yZWRfcGFyYW0gayBvIGFjYyBpZ24gcmVzdFxuXG4gIHwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpIC0+XG4gICAgbWFrZV9wcmludGYgayBvIChBY2NfZm9ybWF0dGluZ19saXQgKGFjYywgZm10aW5nX2xpdCkpIHJlc3RcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgIGxldCBrJyBrb2Mga2FjYyA9XG4gICAgICBtYWtlX3ByaW50ZiBrIGtvYyAoQWNjX2Zvcm1hdHRpbmdfZ2VuIChhY2MsIEFjY19vcGVuX3RhZyBrYWNjKSkgcmVzdCBpblxuICAgIG1ha2VfcHJpbnRmIGsnIG8gRW5kX29mX2FjYyBmbXQnXG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICBsZXQgaycga29jIGthY2MgPVxuICAgICAgbWFrZV9wcmludGYgayBrb2MgKEFjY19mb3JtYXR0aW5nX2dlbiAoYWNjLCBBY2Nfb3Blbl9ib3gga2FjYykpIHJlc3QgaW5cbiAgICBtYWtlX3ByaW50ZiBrJyBvIEVuZF9vZl9hY2MgZm10J1xuXG4gIHwgRW5kX29mX2Zvcm1hdCAtPlxuICAgIGsgbyBhY2NcblxuKCogRGVsYXkgdGhlIGVycm9yIChJbnZhbGlkX2FyZ3VtZW50IFwiUHJpbnRmOiBiYWQgY29udmVyc2lvbiAlX1wiKS4gKilcbigqIEdlbmVyYXRlIGZ1bmN0aW9ucyB0byB0YWtlIHJlbWFpbmluZyBhcmd1bWVudHMgKGFmdGVyIHRoZSBcIiVfXCIpLiAqKVxuYW5kIG1ha2VfaWdub3JlZF9wYXJhbSA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgICAoYiAtPiAoYiwgYykgYWNjIC0+IGYpIC0+IGIgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCB5LCB4KSBpZ25vcmVkIC0+XG4gICAgKHgsIGIsIGMsIHksIGUsIGYpIGZtdCAtPiBhID1cbmZ1biBrIG8gYWNjIGlnbiBmbXQgLT4gbWF0Y2ggaWduIHdpdGhcbiAgfCBJZ25vcmVkX2NoYXIgICAgICAgICAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBvIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAgICAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBvIGFjYyBmbXRcbiAgfCBJZ25vcmVkX3N0cmluZyBfICAgICAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBvIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIF8gICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBvIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2ludCAoXywgXykgICAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBvIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2ludDMyIChfLCBfKSAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBvIGFjYyBmbXRcbiAgfCBJZ25vcmVkX25hdGl2ZWludCAoXywgXykgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBvIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2ludDY0IChfLCBfKSAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBvIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2Zsb2F0IChfLCBfKSAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBvIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2Jvb2wgXyAgICAgICAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBvIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgXyAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBvIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAoXywgZm10dHkpIC0+IG1ha2VfZnJvbV9mbXR0eSBrIG8gYWNjIGZtdHR5IGZtdFxuICB8IElnbm9yZWRfcmVhZGVyICAgICAgICAgICAgICAgICAgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IF8gICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgbyBhY2MgZm10XG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIF8gICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgbyBhY2MgZm10XG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgbyBhY2MgZm10XG5cblxuKCogU3BlY2lhbCBjYXNlIG9mIHByaW50ZiBcIiVfKFwiLiAqKVxuYW5kIG1ha2VfZnJvbV9mbXR0eSA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgICAoYiAtPiAoYiwgYykgYWNjIC0+IGYpIC0+IGIgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCB5LCB4KSBmbXR0eSAtPlxuICAgICh4LCBiLCBjLCB5LCBlLCBmKSBmbXQgLT4gYSA9XG5mdW4gayBvIGFjYyBmbXR0eSBmbXQgLT4gbWF0Y2ggZm10dHkgd2l0aFxuICB8IENoYXJfdHkgcmVzdCAgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIG8gYWNjIHJlc3QgZm10XG4gIHwgU3RyaW5nX3R5IHJlc3QgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgbyBhY2MgcmVzdCBmbXRcbiAgfCBJbnRfdHkgcmVzdCAgICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBvIGFjYyByZXN0IGZtdFxuICB8IEludDMyX3R5IHJlc3QgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIG8gYWNjIHJlc3QgZm10XG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgbyBhY2MgcmVzdCBmbXRcbiAgfCBJbnQ2NF90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBvIGFjYyByZXN0IGZtdFxuICB8IEZsb2F0X3R5IHJlc3QgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIG8gYWNjIHJlc3QgZm10XG4gIHwgQm9vbF90eSByZXN0ICAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgbyBhY2MgcmVzdCBmbXRcbiAgfCBBbHBoYV90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIG8gYWNjIHJlc3QgZm10XG4gIHwgVGhldGFfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgbyBhY2MgcmVzdCBmbXRcbiAgfCBBbnlfdHkgcmVzdCAgICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBvIGFjYyByZXN0IGZtdFxuICB8IFJlYWRlcl90eSBfICAgICAgICAgICAgIC0+IGFzc2VydCBmYWxzZVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IF8gICAgIC0+IGFzc2VydCBmYWxzZVxuICB8IEZvcm1hdF9hcmdfdHkgKF8sIHJlc3QpIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIG8gYWNjIHJlc3QgZm10XG4gIHwgRW5kX29mX2ZtdHR5ICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIG8gYWNjIGZtdFxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgbGV0IHR5ID0gdHJhbnMgKHN5bW0gdHkxKSB0eTIgaW5cbiAgICBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBvIGFjYyAoY29uY2F0X2ZtdHR5IHR5IHJlc3QpIGZtdFxuXG4oKiBJbnNlcnQgYW4gQWNjX2ludmFsaWRfYXJnIGluIHRoZSBhY2N1bXVsYXRvciBhbmQgY29udGludWUgdG8gZ2VuZXJhdGVcbiAgIGNsb3N1cmVzIHRvIGdldCB0aGUgcmVtYWluaW5nIGFyZ3VtZW50cy4gKilcbmFuZCBtYWtlX2ludmFsaWRfYXJnIDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gICAgKGIgLT4gKGIsIGMpIGFjYyAtPiBmKSAtPiBiIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IGEgPVxuZnVuIGsgbyBhY2MgZm10IC0+XG4gIG1ha2VfcHJpbnRmIGsgbyAoQWNjX2ludmFsaWRfYXJnIChhY2MsIFwiUHJpbnRmOiBiYWQgY29udmVyc2lvbiAlX1wiKSkgZm10XG5cbigqIEZpeCBwYWRkaW5nLCB0YWtlIGl0IGFzIGFuIGV4dHJhIGludGVnZXIgYXJndW1lbnQgaWYgbmVlZGVkLiAqKVxuYW5kIG1ha2VfcGFkZGluZyA6IHR5cGUgeCB6IGEgYiBjIGQgZSBmIC5cbiAgICAoYiAtPiAoYiwgYykgYWNjIC0+IGYpIC0+IGIgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAoeCwgeiAtPiBhKSBwYWRkaW5nIC0+ICh6IC0+IHN0cmluZykgLT4geCA9XG4gIGZ1biBrIG8gYWNjIGZtdCBwYWQgdHJhbnMgLT4gbWF0Y2ggcGFkIHdpdGhcbiAgfCBOb19wYWRkaW5nIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfc3RyaW5nIChhY2MsIHRyYW5zIHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gbmV3X2FjYyBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHdpZHRoKSAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCBmaXhfcGFkZGluZyBwYWR0eSB3aWR0aCAodHJhbnMgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gbmV3X2FjYyBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSAtPlxuICAgIGZ1biB3IHggLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfc3RyaW5nIChhY2MsIGZpeF9wYWRkaW5nIHBhZHR5IHcgKHRyYW5zIHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayBvIG5ld19hY2MgZm10XG5cbigqIEZpeCBwYWRkaW5nIGFuZCBwcmVjaXNpb24gZm9yIGludCwgaW50MzIsIG5hdGl2ZWludCBvciBpbnQ2NC4gKilcbigqIFRha2Ugb25lIG9yIHR3byBleHRyYSBpbnRlZ2VyIGFyZ3VtZW50cyBpZiBuZWVkZWQuICopXG5hbmQgbWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24gOiB0eXBlIHggeSB6IGEgYiBjIGQgZSBmIC5cbiAgICAoYiAtPiAoYiwgYykgYWNjIC0+IGYpIC0+IGIgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoeSwgeiAtPiBhKSBwcmVjaXNpb24gLT4gKGludF9jb252IC0+IHogLT4gc3RyaW5nKSAtPlxuICAgIGludF9jb252IC0+IHggPVxuICBmdW4gayBvIGFjYyBmbXQgcGFkIHByZWMgdHJhbnMgaWNvbnYgLT4gbWF0Y2ggcGFkLCBwcmVjIHdpdGhcbiAgfCBOb19wYWRkaW5nLCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IHRyYW5zIGljb252IHggaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IE5vX3BhZGRpbmcsIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IE5vX3BhZGRpbmcsIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gcCB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAodHJhbnMgaWNvbnYgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayBvIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB3IHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3ICh0cmFucyBpY29udiB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayBvIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB3IHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHcgcCB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcblxuKCogQ29udmVydCBhIGZsb2F0LCBmaXggcGFkZGluZyBhbmQgcHJlY2lzaW9uIGlmIG5lZWRlZC4gKilcbigqIFRha2UgdGhlIGZsb2F0IGFyZ3VtZW50IGFuZCBvbmUgb3IgdHdvIGV4dHJhIGludGVnZXIgYXJndW1lbnRzIGlmIG5lZWRlZC4gKilcbmFuZCBtYWtlX2Zsb2F0X3BhZGRpbmdfcHJlY2lzaW9uIDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAgIChiIC0+IChiLCBjKSBhY2MgLT4gZikgLT4gYiAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgICh4LCB5KSBwYWRkaW5nIC0+ICh5LCBmbG9hdCAtPiBhKSBwcmVjaXNpb24gLT4gZmxvYXRfY29udiAtPiB4ID1cbiAgZnVuIGsgbyBhY2MgZm10IHBhZCBwcmVjIGZjb252IC0+IG1hdGNoIHBhZCwgcHJlYyB3aXRoXG4gIHwgTm9fcGFkZGluZywgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBjb252ZXJ0X2Zsb2F0IGZjb252IGRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uIHggaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IE5vX3BhZGRpbmcsIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gY29udmVydF9mbG9hdCBmY29udiBwIHggaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IE5vX3BhZGRpbmcsIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gcCB4IC0+XG4gICAgICBsZXQgc3RyID0gY29udmVydF9mbG9hdCBmY29udiBwIHggaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gY29udmVydF9mbG9hdCBmY29udiBkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiB4IGluXG4gICAgICBsZXQgc3RyJyA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgc3RyIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHInKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gcCB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoY29udmVydF9mbG9hdCBmY29udiBwIHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHcgeCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgZGVmYXVsdF9mbG9hdF9wcmVjaXNpb24geCBpblxuICAgICAgbGV0IHN0cicgPSBmaXhfcGFkZGluZyBwYWR0eSB3IHN0ciBpblxuICAgICAgbWFrZV9wcmludGYgayBvIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyJykpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoY29udmVydF9mbG9hdCBmY29udiBwIHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB3IHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayBvIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG5hbmQgbWFrZV9jdXN0b20gOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gIChiIC0+IChiLCBjKSBhY2MgLT4gZikgLT4gYiAtPiAoYiwgYykgYWNjIC0+XG4gIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgKGEsIHgsIHkpIGN1c3RvbV9hcml0eSAtPiB4IC0+IHkgPVxuICBmdW4gayBvIGFjYyByZXN0IGFyaXR5IGYgLT4gbWF0Y2ggYXJpdHkgd2l0aFxuICB8IEN1c3RvbV96ZXJvIC0+IG1ha2VfcHJpbnRmIGsgbyAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIGYpKSByZXN0XG4gIHwgQ3VzdG9tX3N1Y2MgYXJpdHkgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbWFrZV9jdXN0b20gayBvIGFjYyByZXN0IGFyaXR5IChmIHgpXG5cbmxldCBjb25zdCB4IF8gPSB4XG5cbmxldCByZWMgbWFrZV9pcHJpbnRmIDogdHlwZSBhIGIgYyBkIGUgZi5cbiAgKGIgLT4gZikgLT4gYiAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IGEgPVxuICBmdW4gayBvIGZtdCAtPiBtYXRjaCBmbXQgd2l0aFxuICAgIHwgQ2hhciByZXN0IC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBDYW1sX2NoYXIgcmVzdCAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU3RyaW5nIChOb19wYWRkaW5nLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU3RyaW5nIChMaXRfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU3RyaW5nIChBcmdfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdCkpXG4gICAgfCBDYW1sX3N0cmluZyAoTm9fcGFkZGluZywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IENhbWxfc3RyaW5nIChMaXRfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQ2FtbF9zdHJpbmcgKEFyZ19wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KSlcbiAgICB8IEludCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gcmVzdCBwYWQgcHJlY1xuICAgIHwgSW50MzIgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IE5hdGl2ZWludCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gcmVzdCBwYWQgcHJlY1xuICAgIHwgSW50NjQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IEZsb2F0IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIGsgbyByZXN0IHBhZCBwcmVjXG4gICAgfCBCb29sIChOb19wYWRkaW5nLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQm9vbCAoTGl0X3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IEJvb2wgKEFyZ19wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KSlcbiAgICB8IEFscGhhIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpKVxuICAgIHwgVGhldGEgcmVzdCAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQ3VzdG9tIChhcml0eSwgXywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfY3VzdG9tX2FyaXR5IGsgbyByZXN0IGFyaXR5XG4gICAgfCBSZWFkZXIgXyAtPlxuICAgICAgICAoKiBUaGlzIGNhc2UgaXMgaW1wb3NzaWJsZSwgYnkgdHlwaW5nIG9mIGZvcm1hdHMuICBTZWUgdGhlXG4gICAgICAgICAgIG5vdGUgaW4gdGhlIGNvcnJlc3BvbmRpbmcgY2FzZSBmb3IgbWFrZV9wcmludGYuICopXG4gICAgICAgIGFzc2VydCBmYWxzZVxuICAgIHwgRmx1c2ggcmVzdCAtPlxuICAgICAgICBtYWtlX2lwcmludGYgayBvIHJlc3RcbiAgICB8IFN0cmluZ19saXRlcmFsIChfLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lwcmludGYgayBvIHJlc3RcbiAgICB8IENoYXJfbGl0ZXJhbCAoXywgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyByZXN0XG4gICAgfCBGb3JtYXRfYXJnIChfLCBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgRm9ybWF0X3N1YnN0IChfLCBmbXR0eSwgcmVzdCkgLT5cbiAgICAgICAgZnVuIChGb3JtYXQgKGZtdCwgXykpIC0+XG4gICAgICAgICAgbWFrZV9pcHJpbnRmIGsgb1xuICAgICAgICAgICAgKGNvbmNhdF9mbXQgKHJlY2FzdCBmbXQgZm10dHkpIHJlc3QpXG4gICAgfCBTY2FuX2NoYXJfc2V0IChfLCBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU2Nhbl9nZXRfY291bnRlciAoXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pZ25vcmVkX3BhcmFtIChmdW4geCBfIC0+IGsgeCkgbyAoRW5kX29mX2FjYykgaWduIHJlc3RcbiAgICB8IEZvcm1hdHRpbmdfbGl0IChfLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lwcmludGYgayBvIHJlc3RcbiAgICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX3RhZyAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiAoZnVuIGtvYyAtPiBtYWtlX2lwcmludGYgayBrb2MgcmVzdCkgbyBmbXQnXG4gICAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lwcmludGYgKGZ1biBrb2MgLT4gbWFrZV9pcHJpbnRmIGsga29jIHJlc3QpIG8gZm10J1xuICAgIHwgRW5kX29mX2Zvcm1hdCAtPlxuICAgICAgICBrIG9cbmFuZCBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiA6XG4gIHR5cGUgeCB5IHogYSBiIGMgZCBlIGYuXG4gIChiIC0+IGYpIC0+IGIgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAoeCwgeSkgcGFkZGluZyAtPiAoeSwgeiAtPiBhKSBwcmVjaXNpb24gLT4geCA9XG4gIGZ1biBrIG8gZm10IHBhZCBwcmVjIC0+IG1hdGNoIHBhZCwgcHJlYyB3aXRoXG4gICAgfCBOb19wYWRkaW5nICAgLCBOb19wcmVjaXNpb24gICAgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KVxuICAgIHwgTm9fcGFkZGluZyAgICwgTGl0X3ByZWNpc2lvbiBfIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdClcbiAgICB8IE5vX3BhZGRpbmcgICAsIEFyZ19wcmVjaXNpb24gICAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSlcbiAgICB8IExpdF9wYWRkaW5nIF8sIE5vX3ByZWNpc2lvbiAgICAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpXG4gICAgfCBMaXRfcGFkZGluZyBfLCBMaXRfcHJlY2lzaW9uIF8gLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KVxuICAgIHwgTGl0X3BhZGRpbmcgXywgQXJnX3ByZWNpc2lvbiAgIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpKVxuICAgIHwgQXJnX3BhZGRpbmcgXywgTm9fcHJlY2lzaW9uICAgIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpKVxuICAgIHwgQXJnX3BhZGRpbmcgXywgTGl0X3ByZWNpc2lvbiBfIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpKVxuICAgIHwgQXJnX3BhZGRpbmcgXywgQXJnX3ByZWNpc2lvbiAgIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSkpXG5hbmQgZm5fb2ZfY3VzdG9tX2FyaXR5IDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAoYiAtPiBmKSAtPiBiIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gKGEsIHgsIHkpIGN1c3RvbV9hcml0eSAtPiB5ID1cbiAgZnVuIGsgbyBmbXQgLT4gZnVuY3Rpb25cbiAgICB8IEN1c3RvbV96ZXJvIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiBrIG8gZm10XG4gICAgfCBDdXN0b21fc3VjYyBhcml0eSAtPlxuICAgICAgICBjb25zdCAoZm5fb2ZfY3VzdG9tX2FyaXR5IGsgbyBmbXQgYXJpdHkpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIENvbnRpbnVhdGlvbnMgZm9yIG1ha2VfcHJpbnRmICopXG5cbigqIFJlY3Vyc2l2ZWx5IG91dHB1dCBhbiBcImFjY3VtdWxhdG9yXCIgY29udGFpbmluZyBhIHJldmVyc2VkIGxpc3Qgb2ZcbiAgIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXMsIC4uLikgaW4gYW4gb3V0cHV0X3N0cmVhbS4gKilcbigqIFVzZWQgYXMgYSBjb250aW51YXRpb24gb2YgbWFrZV9wcmludGYuICopXG5sZXQgcmVjIG91dHB1dF9hY2MgbyBhY2MgPSBtYXRjaCBhY2Mgd2l0aFxuICB8IEFjY19mb3JtYXR0aW5nX2xpdCAocCwgZm10aW5nX2xpdCkgLT5cbiAgICBsZXQgcyA9IHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgb3V0cHV0X2FjYyBvIHA7IG91dHB1dF9zdHJpbmcgbyBzO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgb3V0cHV0X2FjYyBvIHA7IG91dHB1dF9zdHJpbmcgbyBcIkB7XCI7IG91dHB1dF9hY2MgbyBhY2MnO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fYm94IGFjYycpIC0+XG4gICAgb3V0cHV0X2FjYyBvIHA7IG91dHB1dF9zdHJpbmcgbyBcIkBbXCI7IG91dHB1dF9hY2MgbyBhY2MnO1xuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gb3V0cHV0X2FjYyBvIHA7IG91dHB1dF9zdHJpbmcgbyBzXG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAocCwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChwLCBjKSAgICAgLT4gb3V0cHV0X2FjYyBvIHA7IG91dHB1dF9jaGFyIG8gY1xuICB8IEFjY19kZWxheSAocCwgZikgICAgICAgICAtPiBvdXRwdXRfYWNjIG8gcDsgZiBvXG4gIHwgQWNjX2ZsdXNoIHAgICAgICAgICAgICAgIC0+IG91dHB1dF9hY2MgbyBwOyBmbHVzaCBvXG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IG91dHB1dF9hY2MgbyBwOyBpbnZhbGlkX2FyZyBtc2c7XG4gIHwgRW5kX29mX2FjYyAgICAgICAgICAgICAgIC0+ICgpXG5cbigqIFJlY3Vyc2l2ZWx5IG91dHB1dCBhbiBcImFjY3VtdWxhdG9yXCIgY29udGFpbmluZyBhIHJldmVyc2VkIGxpc3Qgb2ZcbiAgIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXMsIC4uLikgaW4gYSBidWZmZXIuICopXG4oKiBVc2VkIGFzIGEgY29udGludWF0aW9uIG9mIG1ha2VfcHJpbnRmLiAqKVxubGV0IHJlYyBidWZwdXRfYWNjIGIgYWNjID0gbWF0Y2ggYWNjIHdpdGhcbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgKHAsIGZtdGluZ19saXQpIC0+XG4gICAgbGV0IHMgPSBzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIGJ1ZnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIHM7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl90YWcgYWNjJykgLT5cbiAgICBidWZwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBcIkB7XCI7IGJ1ZnB1dF9hY2MgYiBhY2MnO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fYm94IGFjYycpIC0+XG4gICAgYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgXCJAW1wiOyBidWZwdXRfYWNjIGIgYWNjJztcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKHAsIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChwLCBzKSAgIC0+IGJ1ZnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIHNcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChwLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKHAsIGMpICAgICAtPiBidWZwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9jaGFyIGIgY1xuICB8IEFjY19kZWxheSAocCwgZikgICAgICAgICAtPiBidWZwdXRfYWNjIGIgcDsgZiBiXG4gIHwgQWNjX2ZsdXNoIHAgICAgICAgICAgICAgIC0+IGJ1ZnB1dF9hY2MgYiBwO1xuICB8IEFjY19pbnZhbGlkX2FyZyAocCwgbXNnKSAtPiBidWZwdXRfYWNjIGIgcDsgaW52YWxpZF9hcmcgbXNnO1xuICB8IEVuZF9vZl9hY2MgICAgICAgICAgICAgICAtPiAoKVxuXG4oKiBSZWN1cnNpdmVseSBvdXRwdXQgYW4gXCJhY2N1bXVsYXRvclwiIGNvbnRhaW5pbmcgYSByZXZlcnNlZCBsaXN0IG9mXG4gICBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzLCAuLi4pIGluIGEgYnVmZmVyLiAqKVxuKCogRGlmZmVyIGZyb20gYnVmcHV0X2FjYyBieSB0aGUgaW50ZXJwcmV0YXRpb24gb2YgJWEgYW5kICV0LiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBtYWtlX3ByaW50Zi4gKilcbmxldCByZWMgc3RycHV0X2FjYyBiIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmbXRpbmdfbGl0KSAtPlxuICAgIGxldCBzID0gc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQgaW5cbiAgICBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBzO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgXCJAe1wiOyBzdHJwdXRfYWNjIGIgYWNjJztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX2JveCBhY2MnKSAtPlxuICAgIHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIFwiQFtcIjsgc3RycHV0X2FjYyBiIGFjYyc7XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBzXG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAocCwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChwLCBjKSAgICAgLT4gc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfY2hhciBiIGNcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgKGYgKCkpXG4gIHwgQWNjX2ZsdXNoIHAgICAgICAgICAgICAgIC0+IHN0cnB1dF9hY2MgYiBwO1xuICB8IEFjY19pbnZhbGlkX2FyZyAocCwgbXNnKSAtPiBzdHJwdXRfYWNjIGIgcDsgaW52YWxpZF9hcmcgbXNnO1xuICB8IEVuZF9vZl9hY2MgICAgICAgICAgICAgICAtPiAoKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBFcnJvciBtYW5hZ2VtZW50ICopXG5cbigqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGEgcHJldHR5LXByaW50ZWQgZXJyb3IgbWVzc2FnZS4gKilcbmxldCBmYWlsd2l0aF9tZXNzYWdlIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgMjU2IGluXG4gIGxldCBrICgpIGFjYyA9IHN0cnB1dF9hY2MgYnVmIGFjYzsgZmFpbHdpdGggKEJ1ZmZlci5jb250ZW50cyBidWYpIGluXG4gIG1ha2VfcHJpbnRmIGsgKCkgRW5kX29mX2FjYyBmbXRcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXR0aW5nIHRvb2xzICopXG5cbigqIENvbnZlcnQgYSBzdHJpbmcgdG8gYW4gb3BlbiBibG9jayBkZXNjcmlwdGlvbiAoaW5kZW50LCBibG9ja190eXBlKSAqKVxubGV0IG9wZW5fYm94X29mX3N0cmluZyBzdHIgPVxuICBpZiBzdHIgPSBcIlwiIHRoZW4gKDAsIFBwX2JveCkgZWxzZVxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICAgIGxldCBpbnZhbGlkX2JveCAoKSA9IGZhaWx3aXRoX21lc3NhZ2UgXCJpbnZhbGlkIGJveCBkZXNjcmlwdGlvbiAlU1wiIHN0ciBpblxuICAgIGxldCByZWMgcGFyc2Vfc3BhY2VzIGkgPVxuICAgICAgaWYgaSA9IGxlbiB0aGVuIGkgZWxzZVxuICAgICAgICBtYXRjaCBzdHIuW2ldIHdpdGhcbiAgICAgICAgfCAnICcgfCAnXFx0JyAtPiBwYXJzZV9zcGFjZXMgKGkgKyAxKVxuICAgICAgICB8IF8gLT4gaVxuICAgIGFuZCBwYXJzZV9sd29yZCBpIGogPVxuICAgICAgaWYgaiA9IGxlbiB0aGVuIGogZWxzZVxuICAgICAgICBtYXRjaCBzdHIuW2pdIHdpdGhcbiAgICAgICAgfCAnYScgLi4gJ3onIC0+IHBhcnNlX2x3b3JkIGkgKGogKyAxKVxuICAgICAgICB8IF8gLT4galxuICAgIGFuZCBwYXJzZV9pbnQgaSBqID1cbiAgICAgIGlmIGogPSBsZW4gdGhlbiBqIGVsc2VcbiAgICAgICAgbWF0Y2ggc3RyLltqXSB3aXRoXG4gICAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPiBwYXJzZV9pbnQgaSAoaiArIDEpXG4gICAgICAgIHwgXyAtPiBqIGluXG4gICAgbGV0IHdzdGFydCA9IHBhcnNlX3NwYWNlcyAwIGluXG4gICAgbGV0IHdlbmQgPSBwYXJzZV9sd29yZCB3c3RhcnQgd3N0YXJ0IGluXG4gICAgbGV0IGJveF9uYW1lID0gU3RyaW5nLnN1YiBzdHIgd3N0YXJ0ICh3ZW5kIC0gd3N0YXJ0KSBpblxuICAgIGxldCBuc3RhcnQgPSBwYXJzZV9zcGFjZXMgd2VuZCBpblxuICAgIGxldCBuZW5kID0gcGFyc2VfaW50IG5zdGFydCBuc3RhcnQgaW5cbiAgICBsZXQgaW5kZW50ID1cbiAgICAgIGlmIG5zdGFydCA9IG5lbmQgdGhlbiAwIGVsc2VcbiAgICAgICAgdHJ5IGludF9vZl9zdHJpbmcgKFN0cmluZy5zdWIgc3RyIG5zdGFydCAobmVuZCAtIG5zdGFydCkpXG4gICAgICAgIHdpdGggRmFpbHVyZSBfIC0+IGludmFsaWRfYm94ICgpIGluXG4gICAgbGV0IGV4cF9lbmQgPSBwYXJzZV9zcGFjZXMgbmVuZCBpblxuICAgIGlmIGV4cF9lbmQgPD4gbGVuIHRoZW4gaW52YWxpZF9ib3ggKCk7XG4gICAgbGV0IGJveF90eXBlID0gbWF0Y2ggYm94X25hbWUgd2l0aFxuICAgICAgfCBcIlwiIHwgXCJiXCIgLT4gUHBfYm94XG4gICAgICB8IFwiaFwiICAgICAgLT4gUHBfaGJveFxuICAgICAgfCBcInZcIiAgICAgIC0+IFBwX3Zib3hcbiAgICAgIHwgXCJodlwiICAgICAtPiBQcF9odmJveFxuICAgICAgfCBcImhvdlwiICAgIC0+IFBwX2hvdmJveFxuICAgICAgfCBfICAgICAgICAtPiBpbnZhbGlkX2JveCAoKSBpblxuICAgIChpbmRlbnQsIGJveF90eXBlKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFBhcnNpbmcgdG9vbHMgKilcblxuKCogQ3JlYXRlIGEgcGFkZGluZ19mbXRfZWJiIGZyb20gYSBwYWRkaW5nIGFuZCBhIGZvcm1hdC4gKilcbigqIENvcHkgdGhlIHBhZGRpbmcgdG8gZGlzam9pbiB0aGUgdHlwZSBwYXJhbWV0ZXJzIG9mIGFyZ3VtZW50IGFuZCByZXN1bHQuICopXG5sZXQgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgOiB0eXBlIHggeSAuXG4gICAgKHgsIHkpIHBhZGRpbmcgLT4gKF8sIF8sIF8sIF8sIF8sIF8pIGZtdCAtPlxuICAgICAgKF8sIF8sIF8sIF8sIF8pIHBhZGRpbmdfZm10X2ViYiA9XG5mdW4gcGFkIGZtdCAtPiBtYXRjaCBwYWQgd2l0aFxuICB8IE5vX3BhZGRpbmcgICAgICAgICAtPiBQYWRkaW5nX2ZtdF9FQkIgKE5vX3BhZGRpbmcsIGZtdClcbiAgfCBMaXRfcGFkZGluZyAocywgdykgLT4gUGFkZGluZ19mbXRfRUJCIChMaXRfcGFkZGluZyAocywgdyksIGZtdClcbiAgfCBBcmdfcGFkZGluZyBzICAgICAgLT4gUGFkZGluZ19mbXRfRUJCIChBcmdfcGFkZGluZyBzLCBmbXQpXG5cbigqIENyZWF0ZSBhIHByZWNpc2lvbl9mbXRfZWJiIGZyb20gYSBwcmVjaXNpb24gYW5kIGEgZm9ybWF0LiAqKVxuKCogQ29weSB0aGUgcHJlY2lzaW9uIHRvIGRpc2pvaW4gdGhlIHR5cGUgcGFyYW1ldGVycyBvZiBhcmd1bWVudCBhbmQgcmVzdWx0LiAqKVxubGV0IG1ha2VfcHJlY2lzaW9uX2ZtdF9lYmIgOiB0eXBlIHggeSAuXG4gICAgKHgsIHkpIHByZWNpc2lvbiAtPiAoXywgXywgXywgXywgXywgXykgZm10IC0+XG4gICAgICAoXywgXywgXywgXywgXykgcHJlY2lzaW9uX2ZtdF9lYmIgPVxuZnVuIHByZWMgZm10IC0+IG1hdGNoIHByZWMgd2l0aFxuICB8IE5vX3ByZWNpc2lvbiAgICAtPiBQcmVjaXNpb25fZm10X0VCQiAoTm9fcHJlY2lzaW9uLCBmbXQpXG4gIHwgTGl0X3ByZWNpc2lvbiBwIC0+IFByZWNpc2lvbl9mbXRfRUJCIChMaXRfcHJlY2lzaW9uIHAsIGZtdClcbiAgfCBBcmdfcHJlY2lzaW9uICAgLT4gUHJlY2lzaW9uX2ZtdF9FQkIgKEFyZ19wcmVjaXNpb24sIGZtdClcblxuKCogQ3JlYXRlIGEgcGFkcHJlY19mbXRfZWJiIGZyb20gYSBwYWRkaW5nLCBhIHByZWNpc2lvbiBhbmQgYSBmb3JtYXQuICopXG4oKiBDb3B5IHRoZSBwYWRkaW5nIGFuZCB0aGUgcHJlY2lzaW9uIHRvIGRpc2pvaW4gdHlwZSBwYXJhbWV0ZXJzIG9mIGFyZ3VtZW50c1xuICAgYW5kIHJlc3VsdC4gKilcbmxldCBtYWtlX3BhZHByZWNfZm10X2ViYiA6IHR5cGUgeCB5IHogdCAuXG4gICAgKHgsIHkpIHBhZGRpbmcgLT4gKHosIHQpIHByZWNpc2lvbiAtPlxuICAgIChfLCBfLCBfLCBfLCBfLCBfKSBmbXQgLT5cbiAgICAoXywgXywgXywgXywgXykgcGFkcHJlY19mbXRfZWJiID1cbmZ1biBwYWQgcHJlYyBmbXQgLT5cbiAgbGV0IFByZWNpc2lvbl9mbXRfRUJCIChwcmVjLCBmbXQnKSA9IG1ha2VfcHJlY2lzaW9uX2ZtdF9lYmIgcHJlYyBmbXQgaW5cbiAgbWF0Y2ggcGFkIHdpdGhcbiAgfCBOb19wYWRkaW5nICAgICAgICAgLT4gUGFkcHJlY19mbXRfRUJCIChOb19wYWRkaW5nLCBwcmVjLCBmbXQnKVxuICB8IExpdF9wYWRkaW5nIChzLCB3KSAtPiBQYWRwcmVjX2ZtdF9FQkIgKExpdF9wYWRkaW5nIChzLCB3KSwgcHJlYywgZm10JylcbiAgfCBBcmdfcGFkZGluZyBzICAgICAgLT4gUGFkcHJlY19mbXRfRUJCIChBcmdfcGFkZGluZyBzLCBwcmVjLCBmbXQnKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXQgcGFyc2luZyAqKVxuXG4oKiBQYXJzZSBhIHN0cmluZyByZXByZXNlbnRpbmcgYSBmb3JtYXQgYW5kIGNyZWF0ZSBhIGZtdF9lYmIuICopXG4oKiBSYWlzZSBbRmFpbHVyZV0gaW4gY2FzZSBvZiBpbnZhbGlkIGZvcm1hdC4gKilcbmxldCBmbXRfZWJiX29mX3N0cmluZyA/bGVnYWN5X2JlaGF2aW9yIHN0ciA9XG4gICgqIFBhcmFtZXRlcnMgbmFtaW5nIGNvbnZlbnRpb246ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIGxpdF9zdGFydDogc3RhcnQgb2YgdGhlIGxpdGVyYWwgc2VxdWVuY2UuICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gc3RyX2luZDogY3VycmVudCBpbmRleCBpbiB0aGUgc3RyaW5nLiAgICAgICAgICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBlbmRfaW5kOiBlbmQgb2YgdGhlIGN1cnJlbnQgKHN1Yi0pZm9ybWF0LiAgICAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIHBjdF9pbmQ6IGluZGV4IG9mIHRoZSAnJScgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgICAgICAqKVxuICAoKiAgIC0gemVybzogIGlzIHRoZSAnMCcgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBtaW51czogaXMgdGhlICctJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIHBsdXM6ICBpcyB0aGUgJysnIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gaGFzaDogIGlzIHRoZSAnIycgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBzcGFjZTogaXMgdGhlICcgJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIGlnbjogICBpcyB0aGUgJ18nIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gcGFkOiBwYWRkaW5nIG9mIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICAgICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBwcmVjOiBwcmVjaXNpb24gb2YgdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIHN5bWI6IGNoYXIgcmVwcmVzZW50aW5nIHRoZSBjb252ZXJzaW9uICgnYycsICdzJywgJ2QnLCAuLi4pLiAqKVxuICAoKiAgIC0gY2hhcl9zZXQ6IHNldCBvZiBjaGFyYWN0ZXJzIGFzIGJpdG1hcCAoc2VlIHNjYW5mICVbLi4uXSkuICAgICopXG5cbiAgbGV0IGxlZ2FjeV9iZWhhdmlvciA9IG1hdGNoIGxlZ2FjeV9iZWhhdmlvciB3aXRoXG4gICAgfCBTb21lIGZsYWcgLT4gZmxhZ1xuICAgIHwgTm9uZSAtPiB0cnVlXG4gICgqICBXaGVuIHRoaXMgZmxhZyBpcyBlbmFibGVkLCB0aGUgZm9ybWF0IHBhcnNlciB0cmllcyB0byBiZWhhdmUgYXNcbiAgICAgIHRoZSA8NC4wMiBpbXBsZW1lbnRhdGlvbnMsIGluIHBhcnRpY3VsYXIgaXQgaWdub3JlcyBtb3N0IGJlbmluZVxuICAgICAgbm9uc2Vuc2ljYWwgZm9ybWF0LiBXaGVuIHRoZSBmbGFnIGlzIGRpc2FibGVkLCBpdCB3aWxsIHJlamVjdCBhbnlcbiAgICAgIGZvcm1hdCB0aGF0IGlzIG5vdCBhY2NlcHRlZCBieSB0aGUgc3BlY2lmaWNhdGlvbi5cblxuICAgICAgQSB0eXBpY2FsIGV4YW1wbGUgd291bGQgYmUgXCIlKyBkXCI6IHNwZWNpZnlpbmcgYm90aCAnKycgKGlmIHRoZVxuICAgICAgbnVtYmVyIGlzIHBvc2l0aXZlLCBwYWQgd2l0aCBhICcrJyB0byBnZXQgdGhlIHNhbWUgd2lkdGggYXNcbiAgICAgIG5lZ2F0aXZlIG51bWJlcnMpIGFuZCAnICcgKGlmIHRoZSBudW1iZXIgaXMgcG9zaXRpdmUsIHBhZCB3aXRoXG4gICAgICBhIHNwYWNlKSBkb2VzIG5vdCBtYWtlIHNlbnNlLCBidXQgdGhlIGxlZ2FjeSAoPCA0LjAyKVxuICAgICAgaW1wbGVtZW50YXRpb24gd2FzIGhhcHB5IHRvIGp1c3QgaWdub3JlIHRoZSBzcGFjZS5cbiAgKilcbiAgaW5cblxuICAoKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhIGZyaWVuZGx5IGVycm9yIG1lc3NhZ2UuICopXG4gIGxldCBpbnZhbGlkX2Zvcm1hdF9tZXNzYWdlIHN0cl9pbmQgbXNnID1cbiAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCAlc1wiXG4gICAgICBzdHIgc3RyX2luZCBtc2dcbiAgaW5cblxuICAoKiBVc2VkIHdoZW4gdGhlIGVuZCBvZiB0aGUgZm9ybWF0IChvciB0aGUgY3VycmVudCBzdWItZm9ybWF0KSB3YXMgZW5jb3VudGVyZWRcbiAgICAgIHVuZXhwZWN0ZWRseS4gKilcbiAgbGV0IHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kID1cbiAgICBpbnZhbGlkX2Zvcm1hdF9tZXNzYWdlIGVuZF9pbmRcbiAgICAgIFwidW5leHBlY3RlZCBlbmQgb2YgZm9ybWF0XCJcbiAgaW5cblxuICAoKiBVc2VkIGZvciAlMGM6IG5vIG90aGVyIHdpZHRocyBhcmUgaW1wbGVtZW50ZWQgKilcbiAgbGV0IGludmFsaWRfbm9ubnVsbF9jaGFyX3dpZHRoIHN0cl9pbmQgPVxuICAgIGludmFsaWRfZm9ybWF0X21lc3NhZ2Ugc3RyX2luZFxuICAgICAgXCJub24temVybyB3aWR0aHMgYXJlIHVuc3VwcG9ydGVkIGZvciAlYyBjb252ZXJzaW9uc1wiXG4gIGluXG4gICgqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGEgZnJpZW5kbHkgZXJyb3IgbWVzc2FnZSBhYm91dCBhbiBvcHRpb24gZGVwZW5kZW5jeVxuICAgICBwcm9ibGVtLiAqKVxuICBsZXQgaW52YWxpZF9mb3JtYXRfd2l0aG91dCBzdHJfaW5kIGMgcyA9XG4gICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgJyVjJyB3aXRob3V0ICVzXCJcbiAgICAgIHN0ciBzdHJfaW5kIGMgc1xuICBpblxuXG4gICgqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGEgZnJpZW5kbHkgZXJyb3IgbWVzc2FnZSBhYm91dCBhbiB1bmV4cGVjdGVkXG4gICAgIGNoYXJhY3Rlci4gKilcbiAgbGV0IGV4cGVjdGVkX2NoYXJhY3RlciBzdHJfaW5kIGV4cGVjdGVkIHJlYWQgPVxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgJXMgZXhwZWN0ZWQsIHJlYWQgJUNcIlxuICAgICAgc3RyIHN0cl9pbmQgZXhwZWN0ZWQgcmVhZFxuICBpblxuXG4gICgqIFBhcnNlIHRoZSBzdHJpbmcgZnJvbSBiZWdfaW5kIChpbmNsdWRlZCkgdG8gZW5kX2luZCAoZXhjbHVkZWQpLiAqKVxuICBsZXQgcmVjIHBhcnNlIDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIGJlZ19pbmQgZW5kX2luZCAtPiBwYXJzZV9saXRlcmFsIGJlZ19pbmQgYmVnX2luZCBlbmRfaW5kXG5cbiAgKCogUmVhZCBsaXRlcmFsIGNoYXJhY3RlcnMgdXAgdG8gJyUnIG9yICdAJyBzcGVjaWFsIGNoYXJhY3RlcnMuICopXG4gIGFuZCBwYXJzZV9saXRlcmFsIDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBsaXRfc3RhcnQgc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiBhZGRfbGl0ZXJhbCBsaXRfc3RhcnQgc3RyX2luZCBFbmRfb2ZfZm9ybWF0IGVsc2VcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnJScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZV9mb3JtYXQgc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICAgIGFkZF9saXRlcmFsIGxpdF9zdGFydCBzdHJfaW5kIGZtdF9yZXN0XG4gICAgICB8ICdAJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlX2FmdGVyX2F0IChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBhZGRfbGl0ZXJhbCBsaXRfc3RhcnQgc3RyX2luZCBmbXRfcmVzdFxuICAgICAgfCBfIC0+XG4gICAgICAgIHBhcnNlX2xpdGVyYWwgbGl0X3N0YXJ0IChzdHJfaW5kICsgMSkgZW5kX2luZFxuXG4gICgqIFBhcnNlIGEgZm9ybWF0IGFmdGVyICclJyAqKVxuICBhbmQgcGFyc2VfZm9ybWF0IDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgZW5kX2luZCAtPiBwYXJzZV9pZ24gcGN0X2luZCAocGN0X2luZCArIDEpIGVuZF9pbmRcblxuICBhbmQgcGFyc2VfaWduIDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICdfJyAtPiBwYXJzZV9mbGFncyBwY3RfaW5kIChzdHJfaW5kKzEpIGVuZF9pbmQgdHJ1ZVxuICAgICAgfCBfIC0+IHBhcnNlX2ZsYWdzIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIGZhbHNlXG5cbiAgYW5kIHBhcnNlX2ZsYWdzIDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiXG4gID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIGlnbiAtPlxuICAgIGxldCB6ZXJvID0gcmVmIGZhbHNlIGFuZCBtaW51cyA9IHJlZiBmYWxzZVxuICAgIGFuZCBwbHVzID0gcmVmIGZhbHNlIGFuZCBzcGFjZSA9IHJlZiBmYWxzZVxuICAgIGFuZCBoYXNoID0gcmVmIGZhbHNlIGluXG4gICAgbGV0IHNldF9mbGFnIHN0cl9pbmQgZmxhZyA9XG4gICAgICAoKiBpbiBsZWdhY3kgbW9kZSwgZHVwbGljYXRlIGZsYWdzIGFyZSBhY2NlcHRlZCAqKVxuICAgICAgaWYgIWZsYWcgJiYgbm90IGxlZ2FjeV9iZWhhdmlvciB0aGVuXG4gICAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCBkdXBsaWNhdGUgZmxhZyAlQ1wiXG4gICAgICAgICAgc3RyIHN0cl9pbmQgc3RyLltzdHJfaW5kXTtcbiAgICAgIGZsYWcgOj0gdHJ1ZTtcbiAgICBpblxuICAgIGxldCByZWMgcmVhZF9mbGFncyBzdHJfaW5kID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBiZWdpbiBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJzAnIC0+IHNldF9mbGFnIHN0cl9pbmQgemVybzsgIHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCAnLScgLT4gc2V0X2ZsYWcgc3RyX2luZCBtaW51czsgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8ICcrJyAtPiBzZXRfZmxhZyBzdHJfaW5kIHBsdXM7ICByZWFkX2ZsYWdzIChzdHJfaW5kICsgMSlcbiAgICAgIHwgJyMnIC0+IHNldF9mbGFnIHN0cl9pbmQgaGFzaDsgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8ICcgJyAtPiBzZXRfZmxhZyBzdHJfaW5kIHNwYWNlOyByZWFkX2ZsYWdzIChzdHJfaW5kICsgMSlcbiAgICAgIHwgXyAtPlxuICAgICAgICBwYXJzZV9wYWRkaW5nIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kXG4gICAgICAgICAgIXplcm8gIW1pbnVzICFwbHVzICFoYXNoICFzcGFjZSBpZ25cbiAgICAgIGVuZFxuICAgIGluXG4gICAgcmVhZF9mbGFncyBzdHJfaW5kXG5cbiAgKCogVHJ5IHRvIHJlYWQgYSBkaWdpdGFsIG9yIGEgJyonIHBhZGRpbmcuICopXG4gIGFuZCBwYXJzZV9wYWRkaW5nIDogdHlwZSBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT5cbiAgICAgICAgKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgemVybyBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBsZXQgcGFkdHkgPSBtYXRjaCB6ZXJvLCBtaW51cyB3aXRoXG4gICAgICB8IGZhbHNlLCBmYWxzZSAtPiBSaWdodFxuICAgICAgfCBmYWxzZSwgdHJ1ZSAgLT4gTGVmdFxuICAgICAgfCAgdHJ1ZSwgZmFsc2UgLT4gWmVyb3NcbiAgICAgIHwgIHRydWUsIHRydWUgIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIExlZnRcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJy0nIFwiMFwiIGluXG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIC0+XG4gICAgICBsZXQgbmV3X2luZCwgd2lkdGggPSBwYXJzZV9wb3NpdGl2ZSBzdHJfaW5kIGVuZF9pbmQgMCBpblxuICAgICAgcGFyc2VfYWZ0ZXJfcGFkZGluZyBwY3RfaW5kIG5ld19pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgIChMaXRfcGFkZGluZyAocGFkdHksIHdpZHRoKSlcbiAgICB8ICcqJyAtPlxuICAgICAgcGFyc2VfYWZ0ZXJfcGFkZGluZyBwY3RfaW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2VcbiAgICAgICAgaWduIChBcmdfcGFkZGluZyBwYWR0eSlcbiAgICB8IF8gLT5cbiAgICAgIGJlZ2luIG1hdGNoIHBhZHR5IHdpdGhcbiAgICAgIHwgTGVmdCAgLT5cbiAgICAgICAgaWYgbm90IGxlZ2FjeV9iZWhhdmlvciB0aGVuXG4gICAgICAgICAgaW52YWxpZF9mb3JtYXRfd2l0aG91dCAoc3RyX2luZCAtIDEpICctJyBcInBhZGRpbmdcIjtcbiAgICAgICAgcGFyc2VfYWZ0ZXJfcGFkZGluZyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgICAgTm9fcGFkZGluZ1xuICAgICAgfCBaZXJvcyAtPlxuICAgICAgICAgKCogYSAnMCcgcGFkZGluZyBpbmRpY2F0aW9uIG5vdCBmb2xsb3dlZCBieSBhbnl0aGluZyBzaG91bGRcbiAgICAgICAgICAgYmUgaW50ZXJwcmV0ZWQgYXMgYSBSaWdodCBwYWRkaW5nIG9mIHdpZHRoIDAuIFRoaXMgaXMgdXNlZFxuICAgICAgICAgICBieSBzY2FubmluZyBjb252ZXJzaW9ucyAlMHMgYW5kICUwYyAqKVxuICAgICAgICBwYXJzZV9hZnRlcl9wYWRkaW5nIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgICAoTGl0X3BhZGRpbmcgKFJpZ2h0LCAwKSlcbiAgICAgIHwgUmlnaHQgLT5cbiAgICAgICAgcGFyc2VfYWZ0ZXJfcGFkZGluZyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgICAgTm9fcGFkZGluZ1xuICAgICAgZW5kXG5cbiAgKCogSXMgcHJlY2lzaW9uIGRlZmluZWQ/ICopXG4gIGFuZCBwYXJzZV9hZnRlcl9wYWRkaW5nIDogdHlwZSB4IGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT5cbiAgICAgICAgKHgsIF8pIHBhZGRpbmcgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWQgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJy4nIC0+XG4gICAgICBwYXJzZV9wcmVjaXNpb24gcGN0X2luZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICBwYWRcbiAgICB8IHN5bWIgLT5cbiAgICAgIHBhcnNlX2NvbnZlcnNpb24gcGN0X2luZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWRcbiAgICAgICAgTm9fcHJlY2lzaW9uIHBhZCBzeW1iXG5cbiAgKCogUmVhZCB0aGUgZGlnaXRhbCBvciAnKicgcHJlY2lzaW9uLiAqKVxuICBhbmQgcGFyc2VfcHJlY2lzaW9uIDogdHlwZSB4IGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT5cbiAgICAgICAgKHgsIF8pIHBhZGRpbmcgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWQgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIGxldCBwYXJzZV9saXRlcmFsIG1pbnVzIHN0cl9pbmQgPVxuICAgICAgbGV0IG5ld19pbmQsIHByZWMgPSBwYXJzZV9wb3NpdGl2ZSBzdHJfaW5kIGVuZF9pbmQgMCBpblxuICAgICAgcGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIHBjdF9pbmQgbmV3X2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgcGFkIChMaXRfcHJlY2lzaW9uIHByZWMpIGluXG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIC0+IHBhcnNlX2xpdGVyYWwgbWludXMgc3RyX2luZFxuICAgIHwgKCcrJyB8ICctJykgYXMgc3ltYiB3aGVuIGxlZ2FjeV9iZWhhdmlvciAtPlxuICAgICAgKCogTGVnYWN5IG1vZGUgd291bGQgYWNjZXB0IGFuZCBpZ25vcmUgJysnIG9yICctJyBiZWZvcmUgdGhlXG4gICAgICAgICBpbnRlZ2VyIGRlc2NyaWJpbmcgdGhlIGRlc2lyZWQgcHJlY2lzaW9uOyBub3RlIHRoYXQgdGhpc1xuICAgICAgICAgY2Fubm90IGhhcHBlbiBmb3IgcGFkZGluZyB3aWR0aCwgYXMgJysnIGFuZCAnLScgYWxyZWFkeSBoYXZlXG4gICAgICAgICBhIHNlbWFudGljcyB0aGVyZS5cblxuICAgICAgICAgVGhhdCBzYWlkLCB0aGUgaWRlYSAoc3VwcG9ydGVkIGJ5IHRoaXMgdHdlYWspIHRoYXQgd2lkdGggYW5kXG4gICAgICAgICBwcmVjaXNpb24gbGl0ZXJhbHMgYXJlIFwiaW50ZWdlciBsaXRlcmFsc1wiIGluIHRoZSBPQ2FtbCBzZW5zZSBpc1xuICAgICAgICAgc3RpbGwgYmxhdGFudGx5IHdyb25nLCBhcyAxMjNfNDU2IG9yIDB4RkYgYXJlIHJlamVjdGVkLiAqKVxuICAgICAgcGFyc2VfbGl0ZXJhbCAobWludXMgfHwgc3ltYiA9ICctJykgKHN0cl9pbmQgKyAxKVxuICAgIHwgJyonIC0+XG4gICAgICBwYXJzZV9hZnRlcl9wcmVjaXNpb24gcGN0X2luZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlXG4gICAgICAgIGlnbiBwYWQgQXJnX3ByZWNpc2lvblxuICAgIHwgXyAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW5cbiAgICAgICAgKCogbm90ZSB0aGF0IGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBkaWQgbm90IGlnbm9yZSAnLicgd2l0aG91dFxuICAgICAgICAgICBhIG51bWJlciAoYXMgaXQgZG9lcyBmb3IgcGFkZGluZyBpbmRpY2F0aW9ucyksIGJ1dFxuICAgICAgICAgICBpbnRlcnByZXRzIGl0IGFzICcuMCcgKilcbiAgICAgICAgcGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgICBwYWQgKExpdF9wcmVjaXNpb24gMClcbiAgICAgIGVsc2VcbiAgICAgICAgaW52YWxpZF9mb3JtYXRfd2l0aG91dCAoc3RyX2luZCAtIDEpICcuJyBcInByZWNpc2lvblwiXG5cbiAgKCogVHJ5IHRvIHJlYWQgdGhlIGNvbnZlcnNpb24uICopXG4gIGFuZCBwYXJzZV9hZnRlcl9wcmVjaXNpb24gOiB0eXBlIHggeSB6IHQgZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPlxuICAgICAgICAoeCwgeSkgcGFkZGluZyAtPiAoeiwgdCkgcHJlY2lzaW9uIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkIHByZWMgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIGxldCBwYXJzZV9jb252ICh0eXBlIHUpICh0eXBlIHYpIChwYWRwcmVjIDogKHUsIHYpIHBhZGRpbmcpID1cbiAgICAgIHBhcnNlX2NvbnZlcnNpb24gcGN0X2luZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWRcbiAgICAgICAgcHJlYyBwYWRwcmVjIHN0ci5bc3RyX2luZF0gaW5cbiAgICAoKiBpbiBsZWdhY3kgbW9kZSwgc29tZSBmb3JtYXRzICglcyBhbmQgJVMpIGFjY2VwdCBhIHdlaXJkIG1peCBvZlxuICAgICAgIHBhZGRpbmcgYW5kIHByZWNpc2lvbiwgd2hpY2ggaXMgbWVyZ2VkIGFzIGEgc2luZ2xlIHBhZGRpbmdcbiAgICAgICBpbmZvcm1hdGlvbi4gRm9yIGV4YW1wbGUsIGluICUuMTBzIHRoZSBwcmVjaXNpb24gaXMgaW1wbGljaXRseVxuICAgICAgIHVuZGVyc3Rvb2QgYXMgcGFkZGluZyAlMTBzLCBidXQgdGhlIGxlZnQtcGFkZGluZyBjb21wb25lbnQgbWF5XG4gICAgICAgYmUgc3BlY2lmaWVkIGVpdGhlciBhcyBhIGxlZnQgcGFkZGluZyBvciBhIG5lZ2F0aXZlIHByZWNpc2lvbjpcbiAgICAgICAlLS4zcyBhbmQgJS4tM3MgYXJlIGVxdWl2YWxlbnQgdG8gJS0zcyAqKVxuICAgIG1hdGNoIHBhZCB3aXRoXG4gICAgfCBOb19wYWRkaW5nIC0+IChcbiAgICAgIG1hdGNoIG1pbnVzLCBwcmVjIHdpdGhcbiAgICAgICAgfCBfLCBOb19wcmVjaXNpb24gLT4gcGFyc2VfY29udiBOb19wYWRkaW5nXG4gICAgICAgIHwgZmFsc2UsIExpdF9wcmVjaXNpb24gbiAtPiBwYXJzZV9jb252IChMaXRfcGFkZGluZyAoUmlnaHQsIG4pKVxuICAgICAgICB8IHRydWUsIExpdF9wcmVjaXNpb24gbiAtPiBwYXJzZV9jb252IChMaXRfcGFkZGluZyAoTGVmdCwgbikpXG4gICAgICAgIHwgZmFsc2UsIEFyZ19wcmVjaXNpb24gLT4gcGFyc2VfY29udiAoQXJnX3BhZGRpbmcgUmlnaHQpXG4gICAgICAgIHwgdHJ1ZSwgQXJnX3ByZWNpc2lvbiAtPiBwYXJzZV9jb252IChBcmdfcGFkZGluZyBMZWZ0KVxuICAgIClcbiAgICB8IHBhZCAtPiBwYXJzZV9jb252IHBhZFxuXG4gICgqIENhc2UgYW5hbHlzaXMgb24gY29udmVyc2lvbi4gKilcbiAgYW5kIHBhcnNlX2NvbnZlcnNpb24gOiB0eXBlIHggeSB6IHQgdSB2IGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+ICh4LCB5KSBwYWRkaW5nIC0+XG4gICAgICAgICh6LCB0KSBwcmVjaXNpb24gLT4gKHUsIHYpIHBhZGRpbmcgLT4gY2hhciAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZCBwcmVjIHBhZHByZWMgc3ltYiAtPlxuICAgICgqIEZsYWdzIHVzZWQgdG8gY2hlY2sgb3B0aW9uIHVzYWdlcy9jb21wYXRpYmlsaXRpZXMuICopXG4gICAgbGV0IHBsdXNfdXNlZCAgPSByZWYgZmFsc2UgYW5kIGhhc2hfdXNlZCA9IHJlZiBmYWxzZVxuICAgIGFuZCBzcGFjZV91c2VkID0gcmVmIGZhbHNlIGFuZCBpZ25fdXNlZCAgID0gcmVmIGZhbHNlXG4gICAgYW5kIHBhZF91c2VkICAgPSByZWYgZmFsc2UgYW5kIHByZWNfdXNlZCAgPSByZWYgZmFsc2UgaW5cblxuICAgICgqIEFjY2VzcyB0byBvcHRpb25zLCB1cGRhdGUgZmxhZ3MuICopXG4gICAgbGV0IGdldF9wbHVzICAgICgpID0gcGx1c191c2VkICA6PSB0cnVlOyBwbHVzXG4gICAgYW5kIGdldF9oYXNoICAgKCkgPSBoYXNoX3VzZWQgOj0gdHJ1ZTsgaGFzaFxuICAgIGFuZCBnZXRfc3BhY2UgICAoKSA9IHNwYWNlX3VzZWQgOj0gdHJ1ZTsgc3BhY2VcbiAgICBhbmQgZ2V0X2lnbiAgICAgKCkgPSBpZ25fdXNlZCAgIDo9IHRydWU7IGlnblxuICAgIGFuZCBnZXRfcGFkICAgICAoKSA9IHBhZF91c2VkICAgOj0gdHJ1ZTsgcGFkXG4gICAgYW5kIGdldF9wcmVjICAgICgpID0gcHJlY191c2VkICA6PSB0cnVlOyBwcmVjXG4gICAgYW5kIGdldF9wYWRwcmVjICgpID0gcGFkX3VzZWQgICA6PSB0cnVlOyBwYWRwcmVjIGluXG5cbiAgICBsZXQgZ2V0X2ludF9wYWQgKCkgPVxuICAgICAgKCogJTUuM2QgaXMgYWNjZXB0ZWQgYW5kIG1lYW5pbmdmdWw6IHBhZCB0byBsZW5ndGggNSB3aXRoXG4gICAgICAgICBzcGFjZXMsIGJ1dCBmaXJzdCBwYWQgd2l0aCB6ZXJvcyB1cHRvIGxlbmd0aCAzICgwLXBhZGRpbmdcbiAgICAgICAgIGlzIHRoZSBpbnRlcnByZXRhdGlvbiBvZiBcInByZWNpc2lvblwiIGZvciBpbnRlZ2VyIGZvcm1hdHMpLlxuXG4gICAgICAgICAlMDUuM2QgaXMgcmVkdW5kYW50OiBwYWQgdG8gbGVuZ3RoIDUgKndpdGggemVyb3MqLCBidXRcbiAgICAgICAgIGZpcnN0IHBhZCB3aXRoIHplcm9zLi4uIFRvIGFkZCBpbnN1bHQgdG8gdGhlIGluanVyeSwgdGhlXG4gICAgICAgICBsZWdhY3kgaW1wbGVtZW50YXRpb24gaWdub3JlcyB0aGUgMC1wYWRkaW5nIGluZGljYXRpb24gYW5kXG4gICAgICAgICBkb2VzIHRoZSA1IHBhZGRpbmcgd2l0aCBzcGFjZXMgaW5zdGVhZC4gV2UgcmV1c2UgdGhpc1xuICAgICAgICAgaW50ZXJwcmV0YXRpb24gZm9yIGNvbXBhdGliaWxpdHksIGJ1dCBzdGF0aWNhbGx5IHJlamVjdCB0aGlzXG4gICAgICAgICBmb3JtYXQgd2hlbiB0aGUgbGVnYWN5IG1vZGUgaXMgZGlzYWJsZWQsIHRvIHByb3RlY3Qgc3RyaWN0XG4gICAgICAgICB1c2VycyBmcm9tIHRoaXMgY29ybmVyIGNhc2UuICopXG4gICAgICAgbWF0Y2ggZ2V0X3BhZCAoKSwgZ2V0X3ByZWMgKCkgd2l0aFxuICAgICAgICAgfCBwYWQsIE5vX3ByZWNpc2lvbiAtPiBwYWRcbiAgICAgICAgIHwgTm9fcGFkZGluZywgXyAgICAgLT4gTm9fcGFkZGluZ1xuICAgICAgICAgfCBMaXRfcGFkZGluZyAoWmVyb3MsIG4pLCBfIC0+XG4gICAgICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIExpdF9wYWRkaW5nIChSaWdodCwgbilcbiAgICAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJzAnIFwicHJlY2lzaW9uXCJcbiAgICAgICAgIHwgQXJnX3BhZGRpbmcgWmVyb3MsIF8gLT5cbiAgICAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gQXJnX3BhZGRpbmcgUmlnaHRcbiAgICAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJzAnIFwicHJlY2lzaW9uXCJcbiAgICAgICAgIHwgTGl0X3BhZGRpbmcgXyBhcyBwYWQsIF8gLT4gcGFkXG4gICAgICAgICB8IEFyZ19wYWRkaW5nIF8gYXMgcGFkLCBfIC0+IHBhZCBpblxuXG4gICAgKCogQ2hlY2sgdGhhdCBwYWR0eSA8PiBaZXJvcy4gKilcbiAgICBsZXQgY2hlY2tfbm9fMCBzeW1iICh0eXBlIGEpICh0eXBlIGIpIChwYWQgOiAoYSwgYikgcGFkZGluZykgPVxuICAgICAgbWF0Y2ggcGFkIHdpdGhcbiAgICAgIHwgTm9fcGFkZGluZyAtPiBwYWRcbiAgICAgIHwgTGl0X3BhZGRpbmcgKChMZWZ0IHwgUmlnaHQpLCBfKSAtPiBwYWRcbiAgICAgIHwgQXJnX3BhZGRpbmcgKExlZnQgfCBSaWdodCkgLT4gcGFkXG4gICAgICB8IExpdF9wYWRkaW5nIChaZXJvcywgd2lkdGgpIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIExpdF9wYWRkaW5nIChSaWdodCwgd2lkdGgpXG4gICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCIwXCJcbiAgICAgIHwgQXJnX3BhZGRpbmcgWmVyb3MgLT5cbiAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gQXJnX3BhZGRpbmcgUmlnaHRcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIjBcIlxuICAgIGluXG5cbiAgICAoKiBHZXQgcGFkZGluZyBhcyBhIHBhZF9vcHRpb24gKHNlZSBcIiVfXCIsIFwiJXtcIiwgXCIlKFwiIGFuZCBcIiVbXCIpLlxuICAgICAgIChubyBuZWVkIGZvciBsZWdhY3kgbW9kZSB0d2Vha2luZywgdGhvc2Ugd2VyZSByZWplY3RlZCBieSB0aGVcbiAgICAgICBsZWdhY3kgcGFyc2VyIGFzIHdlbGwpICopXG4gICAgbGV0IG9wdF9vZl9wYWQgYyAodHlwZSBhKSAodHlwZSBiKSAocGFkIDogKGEsIGIpIHBhZGRpbmcpID0gbWF0Y2ggcGFkIHdpdGhcbiAgICAgIHwgTm9fcGFkZGluZyAtPiBOb25lXG4gICAgICB8IExpdF9wYWRkaW5nIChSaWdodCwgd2lkdGgpIC0+IFNvbWUgd2lkdGhcbiAgICAgIHwgTGl0X3BhZGRpbmcgKFplcm9zLCB3aWR0aCkgLT5cbiAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gU29tZSB3aWR0aFxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBjIFwiJzAnXCJcbiAgICAgIHwgTGl0X3BhZGRpbmcgKExlZnQsIHdpZHRoKSAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBTb21lIHdpZHRoXG4gICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIGMgXCInLSdcIlxuICAgICAgfCBBcmdfcGFkZGluZyBfIC0+IGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBjIFwiJyonXCJcbiAgICBpblxuICAgIGxldCBnZXRfcGFkX29wdCBjID0gb3B0X29mX3BhZCBjIChnZXRfcGFkICgpKSBpblxuICAgIGxldCBnZXRfcGFkcHJlY19vcHQgYyA9IG9wdF9vZl9wYWQgYyAoZ2V0X3BhZHByZWMgKCkpIGluXG5cbiAgICAoKiBHZXQgcHJlY2lzaW9uIGFzIGEgcHJlY19vcHRpb24gKHNlZSBcIiVfZlwiKS5cbiAgICAgICAobm8gbmVlZCBmb3IgbGVnYWN5IG1vZGUgdHdlYWtpbmcsIHRob3NlIHdlcmUgcmVqZWN0ZWQgYnkgdGhlXG4gICAgICAgbGVnYWN5IHBhcnNlciBhcyB3ZWxsKSAqKVxuICAgIGxldCBnZXRfcHJlY19vcHQgKCkgPSBtYXRjaCBnZXRfcHJlYyAoKSB3aXRoXG4gICAgICB8IE5vX3ByZWNpc2lvbiAgICAgICAtPiBOb25lXG4gICAgICB8IExpdF9wcmVjaXNpb24gbmRlYyAtPiBTb21lIG5kZWNcbiAgICAgIHwgQXJnX3ByZWNpc2lvbiAgICAgIC0+IGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnXycgXCInKidcIlxuICAgIGluXG5cbiAgICBsZXQgZm10X3Jlc3VsdCA9IG1hdGNoIHN5bWIgd2l0aFxuICAgIHwgJywnIC0+XG4gICAgICBwYXJzZSBzdHJfaW5kIGVuZF9pbmRcbiAgICB8ICdjJyAtPlxuICAgICAgbGV0IGNoYXJfZm9ybWF0IGZtdF9yZXN0ID0gKCogJWMgKilcbiAgICAgICAgaWYgZ2V0X2lnbiAoKVxuICAgICAgICB0aGVuIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfY2hhciwgZm10X3Jlc3QpKVxuICAgICAgICBlbHNlIEZtdF9FQkIgKENoYXIgZm10X3Jlc3QpXG4gICAgICBpblxuICAgICAgbGV0IHNjYW5fZm9ybWF0IGZtdF9yZXN0ID0gKCogJTBjICopXG4gICAgICAgIGlmIGdldF9pZ24gKClcbiAgICAgICAgdGhlbiBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX3NjYW5fbmV4dF9jaGFyLCBmbXRfcmVzdCkpXG4gICAgICAgIGVsc2UgRm10X0VCQiAoU2Nhbl9uZXh0X2NoYXIgZm10X3Jlc3QpXG4gICAgICBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGJlZ2luIG1hdGNoIGdldF9wYWRfb3B0ICdjJyB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBjaGFyX2Zvcm1hdCBmbXRfcmVzdFxuICAgICAgICB8IFNvbWUgMCAtPiBzY2FuX2Zvcm1hdCBmbXRfcmVzdFxuICAgICAgICB8IFNvbWUgX24gLT5cbiAgICAgICAgICAgaWYgbm90IGxlZ2FjeV9iZWhhdmlvclxuICAgICAgICAgICB0aGVuIGludmFsaWRfbm9ubnVsbF9jaGFyX3dpZHRoIHN0cl9pbmRcbiAgICAgICAgICAgZWxzZSAoKiBsZWdhY3kgaWdub3JlcyAlYyB3aWR0aHMgKikgY2hhcl9mb3JtYXQgZm10X3Jlc3RcbiAgICAgIGVuZFxuICAgIHwgJ0MnIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfY2FtbF9jaGFyLGZtdF9yZXN0KSlcbiAgICAgIGVsc2UgRm10X0VCQiAoQ2FtbF9jaGFyIGZtdF9yZXN0KVxuICAgIHwgJ3MnIC0+XG4gICAgICBsZXQgcGFkID0gY2hlY2tfbm9fMCBzeW1iIChnZXRfcGFkcHJlYyAoKSkgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX3N0cmluZyAoZ2V0X3BhZHByZWNfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkZGluZ19mbXRfRUJCIChwYWQnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZGRpbmdfZm10X2ViYiBwYWQgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoU3RyaW5nIChwYWQnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ1MnIC0+XG4gICAgICBsZXQgcGFkID0gY2hlY2tfbm9fMCBzeW1iIChnZXRfcGFkcHJlYyAoKSkgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2NhbWxfc3RyaW5nIChnZXRfcGFkcHJlY19vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRkaW5nX2ZtdF9FQkIgKHBhZCcsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkZGluZ19mbXRfZWJiIHBhZCBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChDYW1sX3N0cmluZyAocGFkJywgZm10X3Jlc3QnKSlcbiAgICB8ICdkJyB8ICdpJyB8ICd4JyB8ICdYJyB8ICdvJyB8ICd1JyAtPlxuICAgICAgbGV0IGljb252ID0gY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgKGdldF9wbHVzICgpKSAoZ2V0X2hhc2ggKCkpXG4gICAgICAgIChnZXRfc3BhY2UgKCkpIHN5bWIgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2ludCAoaWNvbnYsIGdldF9wYWRfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9pbnRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEludCAoaWNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ04nIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgbGV0IGNvdW50ZXIgPSBUb2tlbl9jb3VudGVyIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgY291bnRlciBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIEZtdF9FQkIgKFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGZtdF9yZXN0KSlcbiAgICB8ICdsJyB8ICduJyB8ICdMJyB3aGVuIHN0cl9pbmQ9ZW5kX2luZCB8fCBub3QgKGlzX2ludF9iYXNlIHN0ci5bc3RyX2luZF0pIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgbGV0IGNvdW50ZXIgPSBjb3VudGVyX29mX2NoYXIgc3ltYiBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIGNvdW50ZXIgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBGbXRfRUJCIChTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBmbXRfcmVzdCkpXG4gICAgfCAnbCcgLT5cbiAgICAgIGxldCBpY29udiA9XG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCAoc3RyX2luZCArIDEpIChnZXRfcGx1cyAoKSkgKGdldF9oYXNoICgpKVxuICAgICAgICAgIChnZXRfc3BhY2UgKCkpIHN0ci5bc3RyX2luZF0gaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2ludDMyIChpY29udiwgZ2V0X3BhZF9vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRwcmVjX2ZtdF9FQkIgKHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZHByZWNfZm10X2ViYiAoZ2V0X2ludF9wYWQgKCkpIChnZXRfcHJlYyAoKSkgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoSW50MzIgKGljb252LCBwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSlcbiAgICB8ICduJyAtPlxuICAgICAgbGV0IGljb252ID1cbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIChzdHJfaW5kICsgMSkgKGdldF9wbHVzICgpKVxuICAgICAgICAgIChnZXRfaGFzaCAoKSkgKGdldF9zcGFjZSAoKSkgc3RyLltzdHJfaW5kXSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfbmF0aXZlaW50IChpY29udiwgZ2V0X3BhZF9vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRwcmVjX2ZtdF9FQkIgKHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZHByZWNfZm10X2ViYiAoZ2V0X2ludF9wYWQgKCkpIChnZXRfcHJlYyAoKSkgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoTmF0aXZlaW50IChpY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnTCcgLT5cbiAgICAgIGxldCBpY29udiA9XG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCAoc3RyX2luZCArIDEpIChnZXRfcGx1cyAoKSkgKGdldF9oYXNoICgpKVxuICAgICAgICAgIChnZXRfc3BhY2UgKCkpIHN0ci5bc3RyX2luZF0gaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2ludDY0IChpY29udiwgZ2V0X3BhZF9vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRwcmVjX2ZtdF9FQkIgKHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZHByZWNfZm10X2ViYiAoZ2V0X2ludF9wYWQgKCkpIChnZXRfcHJlYyAoKSkgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoSW50NjQgKGljb252LCBwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSlcbiAgICB8ICdmJyB8ICdlJyB8ICdFJyB8ICdnJyB8ICdHJyB8ICdGJyB8ICdoJyB8ICdIJyAtPlxuICAgICAgbGV0IGZjb252ID0gY29tcHV0ZV9mbG9hdF9jb252IHBjdF9pbmQgc3RyX2luZCAoZ2V0X3BsdXMgKCkpXG4gICAgICAgIChnZXRfc3BhY2UgKCkpIHN5bWIgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2Zsb2F0IChnZXRfcGFkX29wdCAnXycsIGdldF9wcmVjX29wdCAoKSkgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9wYWQgKCkpIChnZXRfcHJlYyAoKSkgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoRmxvYXQgKGZjb252LCBwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSlcbiAgICB8ICdiJyB8ICdCJyAtPlxuICAgICAgbGV0IHBhZCA9IGNoZWNrX25vXzAgc3ltYiAoZ2V0X3BhZHByZWMgKCkpIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9ib29sIChnZXRfcGFkcHJlY19vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRkaW5nX2ZtdF9FQkIgKHBhZCcsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkZGluZ19mbXRfZWJiIHBhZCBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChCb29sIChwYWQnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ2EnIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgRm10X0VCQiAoQWxwaGEgZm10X3Jlc3QpXG4gICAgfCAndCcgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChUaGV0YSBmbXRfcmVzdClcbiAgICB8ICdyJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlbiBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX3JlYWRlciwgZm10X3Jlc3QpKVxuICAgICAgZWxzZSBGbXRfRUJCIChSZWFkZXIgZm10X3Jlc3QpXG4gICAgfCAnIScgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChGbHVzaCBmbXRfcmVzdClcbiAgICB8ICgnJScgfCAnQCcpIGFzIGMgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChDaGFyX2xpdGVyYWwgKGMsIGZtdF9yZXN0KSlcbiAgICB8ICd7JyAtPlxuICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCBzdHJfaW5kIGVuZF9pbmQgJ30nIGluXG4gICAgICBsZXQgRm10X0VCQiBzdWJfZm10ID0gcGFyc2Ugc3RyX2luZCBzdWJfZW5kIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdWJfZW5kICsgMikgZW5kX2luZCBpblxuICAgICAgbGV0IHN1Yl9mbXR0eSA9IGZtdHR5X29mX2ZtdCBzdWJfZm10IGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2Zvcm1hdF9hcmcgKGdldF9wYWRfb3B0ICdfJywgc3ViX2ZtdHR5KSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdF9hcmcgKGdldF9wYWRfb3B0ICd7Jywgc3ViX2ZtdHR5LCBmbXRfcmVzdCkpXG4gICAgfCAnKCcgLT5cbiAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgc3RyX2luZCBlbmRfaW5kICcpJyBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3ViX2VuZCArIDIpIGVuZF9pbmQgaW5cbiAgICAgIGxldCBGbXRfRUJCIHN1Yl9mbXQgPSBwYXJzZSBzdHJfaW5kIHN1Yl9lbmQgaW5cbiAgICAgIGxldCBzdWJfZm10dHkgPSBmbXR0eV9vZl9mbXQgc3ViX2ZtdCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9mb3JtYXRfc3Vic3QgKGdldF9wYWRfb3B0ICdfJywgc3ViX2ZtdHR5KSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdF9zdWJzdCAoZ2V0X3BhZF9vcHQgJygnLCBzdWJfZm10dHksIGZtdF9yZXN0KSlcbiAgICB8ICdbJyAtPlxuICAgICAgbGV0IG5leHRfaW5kLCBjaGFyX3NldCA9IHBhcnNlX2NoYXJfc2V0IHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBuZXh0X2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgKGdldF9wYWRfb3B0ICdfJywgY2hhcl9zZXQpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoU2Nhbl9jaGFyX3NldCAoZ2V0X3BhZF9vcHQgJ1snLCBjaGFyX3NldCwgZm10X3Jlc3QpKVxuICAgIHwgJy0nIHwgJysnIHwgJyMnIHwgJyAnIHwgJ18nIC0+XG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsIFxcXG4gICAgICAgICBmbGFnICVDIGlzIG9ubHkgYWxsb3dlZCBhZnRlciB0aGUgJyUlJywgYmVmb3JlIHBhZGRpbmcgYW5kIHByZWNpc2lvblwiXG4gICAgICAgIHN0ciBwY3RfaW5kIHN5bWJcbiAgICB8IF8gLT5cbiAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgXFxcbiAgICAgICAgIGludmFsaWQgY29udmVyc2lvbiBcXFwiJSUlY1xcXCJcIiBzdHIgKHN0cl9pbmQgLSAxKSBzeW1iXG4gICAgaW5cbiAgICAoKiBDaGVjayBmb3IgdW51c2VkIG9wdGlvbnMsIGFuZCByZWplY3QgdGhlbSBhcyBpbmNvbXBhdGlibGUuXG5cbiAgICAgICBTdWNoIGNoZWNrcyBuZWVkIHRvIGJlIGRpc2FibGVkIGluIGxlZ2FjeSBtb2RlLCBhcyB0aGUgbGVnYWN5XG4gICAgICAgcGFyc2VyIHNpbGVudGx5IGlnbm9yZWQgaW5jb21wYXRpYmxlIGZsYWdzLiAqKVxuICAgIGlmIG5vdCBsZWdhY3lfYmVoYXZpb3IgdGhlbiBiZWdpblxuICAgIGlmIG5vdCAhcGx1c191c2VkICYmIHBsdXMgdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInKydcIjtcbiAgICBpZiBub3QgIWhhc2hfdXNlZCAmJiBoYXNoIHRoZW5cbiAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJyMnXCI7XG4gICAgaWYgbm90ICFzcGFjZV91c2VkICYmIHNwYWNlIHRoZW5cbiAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJyAnXCI7XG4gICAgaWYgbm90ICFwYWRfdXNlZCAgJiYgUGFkZGluZ19FQkIgcGFkIDw+IFBhZGRpbmdfRUJCIE5vX3BhZGRpbmcgdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCJgcGFkZGluZydcIjtcbiAgICBpZiBub3QgIXByZWNfdXNlZCAmJiBQcmVjaXNpb25fRUJCIHByZWMgPD4gUHJlY2lzaW9uX0VCQiBOb19wcmVjaXNpb24gdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIChpZiBpZ24gdGhlbiAnXycgZWxzZSBzeW1iKVxuICAgICAgICBcImBwcmVjaXNpb24nXCI7XG4gICAgaWYgaWduICYmIHBsdXMgdGhlbiBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJ18nIFwiJysnXCI7XG4gICAgZW5kO1xuICAgICgqIHRoaXMgbGFzdCB0ZXN0IG11c3Qgbm90IGJlIGRpc2FibGVkIGluIGxlZ2FjeSBtb2RlLFxuICAgICAgIGFzIGlnbm9yaW5nIGl0IHdvdWxkIHR5cGljYWxseSByZXN1bHQgaW4gYSBkaWZmZXJlbnQgdHlwaW5nXG4gICAgICAgdGhhbiB3aGF0IHRoZSBsZWdhY3kgcGFyc2VyIHVzZWQgKilcbiAgICBpZiBub3QgIWlnbl91c2VkICYmIGlnbiB0aGVuXG4gICAgICBiZWdpbiBtYXRjaCBzeW1iIHdpdGhcbiAgICAgICAgKCogYXJndW1lbnQtbGVzcyBmb3JtYXRzIGNhbiBzYWZlbHkgYmUgaWdub3JlZCBpbiBsZWdhY3kgbW9kZSAqKVxuICAgICAgICB8ICgnQCcgfCAnJScgfCAnIScgfCAnLCcpIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+ICgpXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJ18nXCJcbiAgICAgIGVuZDtcbiAgICBmbXRfcmVzdWx0XG5cbiAgKCogUGFyc2UgZm9ybWF0dGluZyBpbmZvcm1hdGlvbnMgKGFmdGVyICdAJykuICopXG4gIGFuZCBwYXJzZV9hZnRlcl9hdCA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIEZtdF9FQkIgKENoYXJfbGl0ZXJhbCAoJ0AnLCBFbmRfb2ZfZm9ybWF0KSlcbiAgICBlbHNlXG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ1snIC0+XG4gICAgICAgIHBhcnNlX3RhZyBmYWxzZSAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICAgIHwgJ10nIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChDbG9zZV9ib3gsIGZtdF9yZXN0KSlcbiAgICAgIHwgJ3snIC0+XG4gICAgICAgIHBhcnNlX3RhZyB0cnVlIChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCAnfScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKENsb3NlX3RhZywgZm10X3Jlc3QpKVxuICAgICAgfCAnLCcgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEJyZWFrIChcIkAsXCIsIDAsIDApLCBmbXRfcmVzdCkpXG4gICAgICB8ICcgJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoQnJlYWsgKFwiQCBcIiwgMSwgMCksIGZtdF9yZXN0KSlcbiAgICAgIHwgJzsnIC0+XG4gICAgICAgIHBhcnNlX2dvb2RfYnJlYWsgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8ICc/JyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoRkZsdXNoLCBmbXRfcmVzdCkpXG4gICAgICB8ICdcXG4nIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChGb3JjZV9uZXdsaW5lLCBmbXRfcmVzdCkpXG4gICAgICB8ICcuJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoRmx1c2hfbmV3bGluZSwgZm10X3Jlc3QpKVxuICAgICAgfCAnPCcgLT5cbiAgICAgICAgcGFyc2VfbWFnaWNfc2l6ZSAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICAgIHwgJ0AnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChFc2NhcGVkX2F0LCBmbXRfcmVzdCkpXG4gICAgICB8ICclJyB3aGVuIHN0cl9pbmQgKyAxIDwgZW5kX2luZCAmJiBzdHIuW3N0cl9pbmQgKyAxXSA9ICclJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMikgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoRXNjYXBlZF9wZXJjZW50LCBmbXRfcmVzdCkpXG4gICAgICB8ICclJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChDaGFyX2xpdGVyYWwgKCdAJywgZm10X3Jlc3QpKVxuICAgICAgfCBjIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChTY2FuX2luZGljIGMsIGZtdF9yZXN0KSlcblxuICBhbmQgY2hlY2tfb3Blbl9ib3ggOiB0eXBlIGEgYiBjIGQgZSBmIC4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiB1bml0ID1cbiAgZnVuIGZtdCAtPiBtYXRjaCBmbXQgd2l0aFxuICAgIHwgU3RyaW5nX2xpdGVyYWwgKHN0ciwgRW5kX29mX2Zvcm1hdCkgLT4gKFxuICAgICAgdHJ5IGlnbm9yZSAob3Blbl9ib3hfb2Zfc3RyaW5nIHN0cikgd2l0aCBGYWlsdXJlIF8gLT5cbiAgICAgICAgKCgqIEVtaXQgd2FybmluZzogaW52YWxpZCBvcGVuIGJveCAqKSlcbiAgICApXG4gICAgfCBfIC0+ICgpXG5cbiAgKCogVHJ5IHRvIHJlYWQgdGhlIG9wdGlvbmFsIDxuYW1lPiBhZnRlciBcIkB7XCIgb3IgXCJAW1wiLiAqKVxuICBhbmQgcGFyc2VfdGFnIDogdHlwZSBlIGYgLiBib29sIC0+IGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gaXNfb3Blbl90YWcgc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgdHJ5XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnPCcgLT5cbiAgICAgICAgbGV0IGluZCA9IFN0cmluZy5pbmRleF9mcm9tIHN0ciAoc3RyX2luZCArIDEpICc+JyBpblxuICAgICAgICBpZiBpbmQgPj0gZW5kX2luZCB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgICAgbGV0IHN1Yl9zdHIgPSBTdHJpbmcuc3ViIHN0ciBzdHJfaW5kIChpbmQgLSBzdHJfaW5kICsgMSkgaW5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBsZXQgRm10X0VCQiBzdWJfZm10ID0gcGFyc2Ugc3RyX2luZCAoaW5kICsgMSkgaW5cbiAgICAgICAgbGV0IHN1Yl9mb3JtYXQgPSBGb3JtYXQgKHN1Yl9mbXQsIHN1Yl9zdHIpIGluXG4gICAgICAgIGxldCBmb3JtYXR0aW5nID0gaWYgaXNfb3Blbl90YWcgdGhlbiBPcGVuX3RhZyBzdWJfZm9ybWF0IGVsc2UgKFxuICAgICAgICAgIGNoZWNrX29wZW5fYm94IHN1Yl9mbXQ7XG4gICAgICAgICAgT3Blbl9ib3ggc3ViX2Zvcm1hdCkgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19nZW4gKGZvcm1hdHRpbmcsIGZtdF9yZXN0KSlcbiAgICAgIHwgXyAtPlxuICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGxldCBzdWJfZm9ybWF0ID0gRm9ybWF0IChFbmRfb2ZfZm9ybWF0LCBcIlwiKSBpblxuICAgICAgbGV0IGZvcm1hdHRpbmcgPVxuICAgICAgICBpZiBpc19vcGVuX3RhZyB0aGVuIE9wZW5fdGFnIHN1Yl9mb3JtYXQgZWxzZSBPcGVuX2JveCBzdWJfZm9ybWF0IGluXG4gICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2dlbiAoZm9ybWF0dGluZywgZm10X3Jlc3QpKVxuXG4gICgqIFRyeSB0byByZWFkIHRoZSBvcHRpb25hbCA8d2lkdGggb2Zmc2V0PiBhZnRlciBcIkA7XCIuICopXG4gIGFuZCBwYXJzZV9nb29kX2JyZWFrIDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIGxldCBuZXh0X2luZCwgZm9ybWF0dGluZ19saXQgPVxuICAgICAgdHJ5XG4gICAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHx8IHN0ci5bc3RyX2luZF0gPD4gJzwnIHRoZW4gcmFpc2UgTm90X2ZvdW5kO1xuICAgICAgICBsZXQgc3RyX2luZF8xID0gcGFyc2Vfc3BhY2VzIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBtYXRjaCBzdHIuW3N0cl9pbmRfMV0gd2l0aFxuICAgICAgICB8ICcwJyAuLiAnOScgfCAnLScgLT4gKFxuICAgICAgICAgIGxldCBzdHJfaW5kXzIsIHdpZHRoID0gcGFyc2VfaW50ZWdlciBzdHJfaW5kXzEgZW5kX2luZCBpblxuICAgICAgICAgICAgbGV0IHN0cl9pbmRfMyA9IHBhcnNlX3NwYWNlcyBzdHJfaW5kXzIgZW5kX2luZCBpblxuICAgICAgICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXzNdIHdpdGhcbiAgICAgICAgICAgICAgfCAnPicgLT5cbiAgICAgICAgICAgICAgICBsZXQgcyA9IFN0cmluZy5zdWIgc3RyIChzdHJfaW5kLTIpIChzdHJfaW5kXzMtc3RyX2luZCszKSBpblxuICAgICAgICAgICAgICAgIHN0cl9pbmRfMyArIDEsIEJyZWFrIChzLCB3aWR0aCwgMClcbiAgICAgICAgICAgICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+XG4gICAgICAgICAgICAgICAgbGV0IHN0cl9pbmRfNCwgb2Zmc2V0ID0gcGFyc2VfaW50ZWdlciBzdHJfaW5kXzMgZW5kX2luZCBpblxuICAgICAgICAgICAgICAgIGxldCBzdHJfaW5kXzUgPSBwYXJzZV9zcGFjZXMgc3RyX2luZF80IGVuZF9pbmQgaW5cbiAgICAgICAgICAgICAgICBpZiBzdHIuW3N0cl9pbmRfNV0gPD4gJz4nIHRoZW4gcmFpc2UgTm90X2ZvdW5kO1xuICAgICAgICAgICAgICAgIGxldCBzID0gU3RyaW5nLnN1YiBzdHIgKHN0cl9pbmQtMikgKHN0cl9pbmRfNS1zdHJfaW5kKzMpIGluXG4gICAgICAgICAgICAgICAgc3RyX2luZF81ICsgMSwgQnJlYWsgKHMsIHdpZHRoLCBvZmZzZXQpXG4gICAgICAgICAgICAgIHwgXyAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgICAgKVxuICAgICAgICB8IF8gLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB3aXRoIE5vdF9mb3VuZCB8IEZhaWx1cmUgXyAtPlxuICAgICAgICBzdHJfaW5kLCBCcmVhayAoXCJAO1wiLCAxLCAwKVxuICAgIGluXG4gICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBuZXh0X2luZCBlbmRfaW5kIGluXG4gICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKGZvcm1hdHRpbmdfbGl0LCBmbXRfcmVzdCkpXG5cbiAgKCogUGFyc2UgdGhlIHNpemUgaW4gYSA8bj4uICopXG4gIGFuZCBwYXJzZV9tYWdpY19zaXplIDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIG1hdGNoXG4gICAgICB0cnlcbiAgICAgICAgbGV0IHN0cl9pbmRfMSA9IHBhcnNlX3NwYWNlcyBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXzFdIHdpdGhcbiAgICAgICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+XG4gICAgICAgICAgbGV0IHN0cl9pbmRfMiwgc2l6ZSA9IHBhcnNlX2ludGVnZXIgc3RyX2luZF8xIGVuZF9pbmQgaW5cbiAgICAgICAgICBsZXQgc3RyX2luZF8zID0gcGFyc2Vfc3BhY2VzIHN0cl9pbmRfMiBlbmRfaW5kIGluXG4gICAgICAgICAgaWYgc3RyLltzdHJfaW5kXzNdIDw+ICc+JyB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgICAgICBsZXQgcyA9IFN0cmluZy5zdWIgc3RyIChzdHJfaW5kIC0gMikgKHN0cl9pbmRfMyAtIHN0cl9pbmQgKyAzKSBpblxuICAgICAgICAgIFNvbWUgKHN0cl9pbmRfMyArIDEsIE1hZ2ljX3NpemUgKHMsIHNpemUpKVxuICAgICAgICB8IF8gLT4gTm9uZVxuICAgICAgd2l0aCBOb3RfZm91bmQgfCBGYWlsdXJlIF8gLT5cbiAgICAgICAgTm9uZVxuICAgIHdpdGhcbiAgICB8IFNvbWUgKG5leHRfaW5kLCBmb3JtYXR0aW5nX2xpdCkgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgbmV4dF9pbmQgZW5kX2luZCBpblxuICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKGZvcm1hdHRpbmdfbGl0LCBmbXRfcmVzdCkpXG4gICAgfCBOb25lIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKFNjYW5faW5kaWMgJzwnLCBmbXRfcmVzdCkpXG5cbiAgKCogUGFyc2UgYW5kIGNvbnN0cnVjdCBhIGNoYXIgc2V0LiAqKVxuICBhbmQgcGFyc2VfY2hhcl9zZXQgc3RyX2luZCBlbmRfaW5kID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuXG4gICAgbGV0IGNoYXJfc2V0ID0gY3JlYXRlX2NoYXJfc2V0ICgpIGluXG4gICAgbGV0IGFkZF9jaGFyIGMgPVxuICAgICAgYWRkX2luX2NoYXJfc2V0IGNoYXJfc2V0IGM7XG4gICAgaW5cbiAgICBsZXQgYWRkX3JhbmdlIGMgYycgPVxuICAgICAgZm9yIGkgPSBpbnRfb2ZfY2hhciBjIHRvIGludF9vZl9jaGFyIGMnIGRvXG4gICAgICAgIGFkZF9pbl9jaGFyX3NldCBjaGFyX3NldCAoY2hhcl9vZl9pbnQgaSk7XG4gICAgICBkb25lO1xuICAgIGluXG5cbiAgICBsZXQgZmFpbF9zaW5nbGVfcGVyY2VudCBzdHJfaW5kID1cbiAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogJyUlJyBhbG9uZSBpcyBub3QgYWNjZXB0ZWQgaW4gY2hhcmFjdGVyIHNldHMsIFxcXG4gICAgICAgICB1c2UgJSUlJSBpbnN0ZWFkIGF0IHBvc2l0aW9uICVkLlwiIHN0ciBzdHJfaW5kXG4gICAgaW5cblxuICAgICgqIFBhcnNlIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBjaGFyIHNldC4gKilcbiAgICBsZXQgcmVjIHBhcnNlX2NoYXJfc2V0X3N0YXJ0IHN0cl9pbmQgZW5kX2luZCA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbGV0IGMgPSBzdHIuW3N0cl9pbmRdIGluXG4gICAgICBwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIChzdHJfaW5kICsgMSkgZW5kX2luZCBjXG5cbiAgICAoKiBQYXJzZSB0aGUgY29udGVudCBvZiBhIGNoYXIgc2V0IHVudGlsIHRoZSBmaXJzdCAnXScuICopXG4gICAgYW5kIHBhcnNlX2NoYXJfc2V0X2NvbnRlbnQgc3RyX2luZCBlbmRfaW5kID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ10nIC0+XG4gICAgICAgIHN0cl9pbmQgKyAxXG4gICAgICB8ICctJyAtPlxuICAgICAgICBhZGRfY2hhciAnLSc7XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2NvbnRlbnQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8IGMgLT5cbiAgICAgICAgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuXG4gICAgKCogVGVzdCBmb3IgcmFuZ2UgaW4gY2hhciBzZXQuICopXG4gICAgYW5kIHBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIgc3RyX2luZCBlbmRfaW5kIGMgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnXScgLT5cbiAgICAgICAgYWRkX2NoYXIgYztcbiAgICAgICAgc3RyX2luZCArIDFcbiAgICAgIHwgJy0nIC0+XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2FmdGVyX21pbnVzIChzdHJfaW5kICsgMSkgZW5kX2luZCBjXG4gICAgICB8ICgnJScgfCAnQCcpIGFzIGMnIHdoZW4gYyA9ICclJyAtPlxuICAgICAgICBhZGRfY2hhciBjJztcbiAgICAgICAgcGFyc2VfY2hhcl9zZXRfY29udGVudCAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICAgIHwgYycgLT5cbiAgICAgICAgaWYgYyA9ICclJyB0aGVuIGZhaWxfc2luZ2xlX3BlcmNlbnQgc3RyX2luZDtcbiAgICAgICAgKCogbm90ZSB0aGF0ICdAJyBhbG9uZSBpcyBhY2NlcHRlZCwgYXMgZG9uZSBieSB0aGUgbGVnYWN5XG4gICAgICAgICAgIGltcGxlbWVudGF0aW9uOyB0aGUgZG9jdW1lbnRhdGlvbiBzcGVjaWZpY2FsbHkgcmVxdWlyZXMgJUBcbiAgICAgICAgICAgc28gd2UgY291bGQgd2FybiBvbiB0aGF0ICopXG4gICAgICAgIGFkZF9jaGFyIGM7XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGMnXG5cbiAgICAoKiBNYW5hZ2UgcmFuZ2UgaW4gY2hhciBzZXQgKGV4Y2VwdCBpZiB0aGUgJy0nIHRoZSBsYXN0IGNoYXIgYmVmb3JlICddJykgKilcbiAgICBhbmQgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfbWludXMgc3RyX2luZCBlbmRfaW5kIGMgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnXScgLT5cbiAgICAgICAgYWRkX2NoYXIgYztcbiAgICAgICAgYWRkX2NoYXIgJy0nO1xuICAgICAgICBzdHJfaW5kICsgMVxuICAgICAgfCAnJScgLT5cbiAgICAgICAgaWYgc3RyX2luZCArIDEgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICAgIGJlZ2luIG1hdGNoIHN0ci5bc3RyX2luZCArIDFdIHdpdGhcbiAgICAgICAgICB8ICgnJScgfCAnQCcpIGFzIGMnIC0+XG4gICAgICAgICAgICBhZGRfcmFuZ2UgYyBjJztcbiAgICAgICAgICAgIHBhcnNlX2NoYXJfc2V0X2NvbnRlbnQgKHN0cl9pbmQgKyAyKSBlbmRfaW5kXG4gICAgICAgICAgfCBfIC0+IGZhaWxfc2luZ2xlX3BlcmNlbnQgc3RyX2luZFxuICAgICAgICBlbmRcbiAgICAgIHwgYycgLT5cbiAgICAgICAgYWRkX3JhbmdlIGMgYyc7XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2NvbnRlbnQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgaW5cbiAgICBsZXQgc3RyX2luZCwgcmV2ZXJzZSA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICAgIHwgJ14nIC0+IHN0cl9pbmQgKyAxLCB0cnVlXG4gICAgICAgIHwgXyAtPiBzdHJfaW5kLCBmYWxzZSBpblxuICAgIGxldCBuZXh0X2luZCA9IHBhcnNlX2NoYXJfc2V0X3N0YXJ0IHN0cl9pbmQgZW5kX2luZCBpblxuICAgIGxldCBjaGFyX3NldCA9IGZyZWV6ZV9jaGFyX3NldCBjaGFyX3NldCBpblxuICAgIG5leHRfaW5kLCAoaWYgcmV2ZXJzZSB0aGVuIHJldl9jaGFyX3NldCBjaGFyX3NldCBlbHNlIGNoYXJfc2V0KVxuXG4gICgqIENvbnN1bWUgYWxsIG5leHQgc3BhY2VzLCByYWlzZSBhbiBGYWlsdXJlIGlmIGVuZF9pbmQgaXMgcmVhY2hlZC4gKilcbiAgYW5kIHBhcnNlX3NwYWNlcyBzdHJfaW5kIGVuZF9pbmQgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgaWYgc3RyLltzdHJfaW5kXSA9ICcgJyB0aGVuIHBhcnNlX3NwYWNlcyAoc3RyX2luZCArIDEpIGVuZF9pbmQgZWxzZSBzdHJfaW5kXG5cbiAgKCogUmVhZCBhIHBvc2l0aXZlIGludGVnZXIgZnJvbSB0aGUgc3RyaW5nLCByYWlzZSBhIEZhaWx1cmUgaWYgZW5kX2luZCBpc1xuICAgICByZWFjaGVkLiAqKVxuICBhbmQgcGFyc2VfcG9zaXRpdmUgc3RyX2luZCBlbmRfaW5kIGFjYyA9XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICB8ICcwJyAuLiAnOScgYXMgYyAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBhY2MgKiAxMCArIChpbnRfb2ZfY2hhciBjIC0gaW50X29mX2NoYXIgJzAnKSBpblxuICAgICAgaWYgbmV3X2FjYyA+IFN5cy5tYXhfc3RyaW5nX2xlbmd0aCB0aGVuXG4gICAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBpbnRlZ2VyICVkIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbGltaXQgJWRcIlxuICAgICAgICAgIHN0ciBuZXdfYWNjIFN5cy5tYXhfc3RyaW5nX2xlbmd0aFxuICAgICAgZWxzZVxuICAgICAgICBwYXJzZV9wb3NpdGl2ZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgbmV3X2FjY1xuICAgIHwgXyAtPiBzdHJfaW5kLCBhY2NcblxuICAoKiBSZWFkIGEgcG9zaXRpdmUgb3IgbmVnYXRpdmUgaW50ZWdlciBmcm9tIHRoZSBzdHJpbmcsIHJhaXNlIGEgRmFpbHVyZVxuICAgICBpZiBlbmRfaW5kIGlzIHJlYWNoZWQuICopXG4gIGFuZCBwYXJzZV9pbnRlZ2VyIHN0cl9pbmQgZW5kX2luZCA9XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICB8ICcwJyAuLiAnOScgLT4gcGFyc2VfcG9zaXRpdmUgc3RyX2luZCBlbmRfaW5kIDBcbiAgICB8ICctJyAtPiAoXG4gICAgICBpZiBzdHJfaW5kICsgMSA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZCArIDFdIHdpdGhcbiAgICAgIHwgJzAnIC4uICc5JyAtPlxuICAgICAgICBsZXQgbmV4dF9pbmQsIG4gPSBwYXJzZV9wb3NpdGl2ZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgMCBpblxuICAgICAgICBuZXh0X2luZCwgLW5cbiAgICAgIHwgYyAtPlxuICAgICAgICBleHBlY3RlZF9jaGFyYWN0ZXIgKHN0cl9pbmQgKyAxKSBcImRpZ2l0XCIgY1xuICAgIClcbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgKCogQWRkIGEgbGl0ZXJhbCB0byBhIGZvcm1hdCBmcm9tIGEgbGl0ZXJhbCBjaGFyYWN0ZXIgc3ViLXNlcXVlbmNlLiAqKVxuICBhbmQgYWRkX2xpdGVyYWwgOiB0eXBlIGEgZCBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiAoYSwgXywgXywgZCwgZSwgZikgZm10IC0+XG4gICAgICAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBsaXRfc3RhcnQgc3RyX2luZCBmbXQgLT4gbWF0Y2ggc3RyX2luZCAtIGxpdF9zdGFydCB3aXRoXG4gICAgfCAwICAgIC0+IEZtdF9FQkIgZm10XG4gICAgfCAxICAgIC0+IEZtdF9FQkIgKENoYXJfbGl0ZXJhbCAoc3RyLltsaXRfc3RhcnRdLCBmbXQpKVxuICAgIHwgc2l6ZSAtPiBGbXRfRUJCIChTdHJpbmdfbGl0ZXJhbCAoU3RyaW5nLnN1YiBzdHIgbGl0X3N0YXJ0IHNpemUsIGZtdCkpXG5cbiAgKCogU2VhcmNoIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgc3ViLWZvcm1hdFxuICAgICAoaS5lLiB0aGUgY29ycmVzcG9uZGluZyBcIiV9XCIgb3IgXCIlKVwiKSAqKVxuICBhbmQgc2VhcmNoX3N1YmZvcm1hdF9lbmQgc3RyX2luZCBlbmRfaW5kIGMgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW5cbiAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogdW5jbG9zZWQgc3ViLWZvcm1hdCwgXFxcbiAgICAgICAgIGV4cGVjdGVkIFxcXCIlJSVjXFxcIiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkXCIgc3RyIGMgZW5kX2luZDtcbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICB8ICclJyAtPlxuICAgICAgaWYgc3RyX2luZCArIDEgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBpZiBzdHIuW3N0cl9pbmQgKyAxXSA9IGMgdGhlbiAoKiBFbmQgb2YgZm9ybWF0IGZvdW5kICopIHN0cl9pbmQgZWxzZVxuICAgICAgICBiZWdpbiBtYXRjaCBzdHIuW3N0cl9pbmQgKyAxXSB3aXRoXG4gICAgICAgIHwgJ18nIC0+XG4gICAgICAgICAgKCogU2VhcmNoIGZvciBcIiVfKFwiIG9yIFwiJV97XCIuICopXG4gICAgICAgICAgaWYgc3RyX2luZCArIDIgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggc3RyLltzdHJfaW5kICsgMl0gd2l0aFxuICAgICAgICAgIHwgJ3snIC0+XG4gICAgICAgICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMykgZW5kX2luZCAnfScgaW5cbiAgICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgICAgfCAnKCcgLT5cbiAgICAgICAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAzKSBlbmRfaW5kICcpJyBpblxuICAgICAgICAgICAgc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN1Yl9lbmQgKyAyKSBlbmRfaW5kIGNcbiAgICAgICAgICB8IF8gLT4gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAzKSBlbmRfaW5kIGNcbiAgICAgICAgICBlbmRcbiAgICAgICAgfCAneycgLT5cbiAgICAgICAgICAoKiAley4uLiV9IHN1Yi1mb3JtYXQgZm91bmQuICopXG4gICAgICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDIpIGVuZF9pbmQgJ30nIGluXG4gICAgICAgICAgc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN1Yl9lbmQgKyAyKSBlbmRfaW5kIGNcbiAgICAgICAgfCAnKCcgLT5cbiAgICAgICAgICAoKiAlKC4uLiUpIHN1Yi1mb3JtYXQgZm91bmQuICopXG4gICAgICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDIpIGVuZF9pbmQgJyknIGluXG4gICAgICAgICAgc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN1Yl9lbmQgKyAyKSBlbmRfaW5kIGNcbiAgICAgICAgfCAnfScgLT5cbiAgICAgICAgICAoKiBFcnJvcjogJSguLi4lfS4gKilcbiAgICAgICAgICBleHBlY3RlZF9jaGFyYWN0ZXIgKHN0cl9pbmQgKyAxKSBcImNoYXJhY3RlciAnKSdcIiAnfSdcbiAgICAgICAgfCAnKScgLT5cbiAgICAgICAgICAoKiBFcnJvcjogJXsuLi4lKS4gKilcbiAgICAgICAgICBleHBlY3RlZF9jaGFyYWN0ZXIgKHN0cl9pbmQgKyAxKSBcImNoYXJhY3RlciAnfSdcIiAnKSdcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAyKSBlbmRfaW5kIGNcbiAgICAgICAgZW5kXG4gICAgfCBfIC0+IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBjXG5cbiAgKCogQ2hlY2sgaWYgc3ltYiBpcyBhIHZhbGlkIGludCBjb252ZXJzaW9uIGFmdGVyIFwiJWxcIiwgXCIlblwiIG9yIFwiJUxcIiAqKVxuICBhbmQgaXNfaW50X2Jhc2Ugc3ltYiA9IG1hdGNoIHN5bWIgd2l0aFxuICAgIHwgJ2QnIHwgJ2knIHwgJ3gnIHwgJ1gnIHwgJ28nIHwgJ3UnIC0+IHRydWVcbiAgICB8IF8gLT4gZmFsc2VcblxuICAoKiBDb252ZXJ0IGEgY2hhciAobCwgbiBvciBMKSB0byBpdHMgYXNzb2NpYXRlZCBjb3VudGVyLiAqKVxuICBhbmQgY291bnRlcl9vZl9jaGFyIHN5bWIgPSBtYXRjaCBzeW1iIHdpdGhcbiAgICB8ICdsJyAtPiBMaW5lX2NvdW50ZXIgIHwgJ24nIC0+IENoYXJfY291bnRlclxuICAgIHwgJ0wnIC0+IFRva2VuX2NvdW50ZXIgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG4gICgqIENvbnZlcnQgKHBsdXMsIHN5bWIpIHRvIGl0cyBhc3NvY2lhdGVkIGludF9jb252LiAqKVxuICBhbmQgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBoYXNoIHNwYWNlIHN5bWIgPVxuICAgIG1hdGNoIHBsdXMsIGhhc2gsIHNwYWNlLCBzeW1iIHdpdGhcbiAgICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICdkJyAtPiBJbnRfZCAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnaScgLT4gSW50X2lcbiAgICB8IGZhbHNlLCBmYWxzZSwgIHRydWUsICdkJyAtPiBJbnRfc2QgfCBmYWxzZSwgZmFsc2UsICB0cnVlLCAnaScgLT4gSW50X3NpXG4gICAgfCAgdHJ1ZSwgZmFsc2UsIGZhbHNlLCAnZCcgLT4gSW50X3BkIHwgIHRydWUsIGZhbHNlLCBmYWxzZSwgJ2knIC0+IEludF9waVxuICAgIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ3gnIC0+IEludF94ICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICdYJyAtPiBJbnRfWFxuICAgIHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ3gnIC0+IEludF9DeCB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICdYJyAtPiBJbnRfQ1hcbiAgICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICdvJyAtPiBJbnRfb1xuICAgIHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ28nIC0+IEludF9Db1xuICAgIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ3UnIC0+IEludF91XG4gICAgfCBfLCB0cnVlLCBfLCAneCcgd2hlbiBsZWdhY3lfYmVoYXZpb3IgLT4gSW50X0N4XG4gICAgfCBfLCB0cnVlLCBfLCAnWCcgd2hlbiBsZWdhY3lfYmVoYXZpb3IgLT4gSW50X0NYXG4gICAgfCBfLCB0cnVlLCBfLCAnbycgd2hlbiBsZWdhY3lfYmVoYXZpb3IgLT4gSW50X0NvXG4gICAgfCBfLCB0cnVlLCBfLCAoJ2QnIHwgJ2knIHwgJ3UnKSAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gKCogaWdub3JlICopXG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgZmFsc2Ugc3BhY2Ugc3ltYlxuICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicjJ1wiXG4gICAgfCB0cnVlLCBfLCB0cnVlLCBfIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlblxuICAgICAgICAoKiBwbHVzIGFuZCBzcGFjZTogbGVnYWN5IGltcGxlbWVudGF0aW9uIHByZWZlcnMgcGx1cyAqKVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIGhhc2ggZmFsc2Ugc3ltYlxuICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJyAnIFwiJysnXCJcbiAgICB8IGZhbHNlLCBfLCB0cnVlLCBfICAgIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiAoKiBpZ25vcmUgKilcbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBoYXNoIGZhbHNlIHN5bWJcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInICdcIlxuICAgIHwgdHJ1ZSwgXywgZmFsc2UsIF8gICAgLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuICgqIGlnbm9yZSAqKVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCBmYWxzZSBoYXNoIHNwYWNlIHN5bWJcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInKydcIlxuICAgIHwgZmFsc2UsIF8sIGZhbHNlLCBfIC0+IGFzc2VydCBmYWxzZVxuXG4gICgqIENvbnZlcnQgKHBsdXMsIHN5bWIpIHRvIGl0cyBhc3NvY2lhdGVkIGZsb2F0X2NvbnYuICopXG4gIGFuZCBjb21wdXRlX2Zsb2F0X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgc3BhY2Ugc3ltYiA9XG4gIG1hdGNoIHBsdXMsIHNwYWNlLCBzeW1iIHdpdGhcbiAgICB8IGZhbHNlLCBmYWxzZSwgJ2YnIC0+IEZsb2F0X2YgIHwgZmFsc2UsIGZhbHNlLCAnZScgLT4gRmxvYXRfZVxuICAgIHwgZmFsc2UsICB0cnVlLCAnZicgLT4gRmxvYXRfc2YgfCBmYWxzZSwgIHRydWUsICdlJyAtPiBGbG9hdF9zZVxuICAgIHwgIHRydWUsIGZhbHNlLCAnZicgLT4gRmxvYXRfcGYgfCAgdHJ1ZSwgZmFsc2UsICdlJyAtPiBGbG9hdF9wZVxuICAgIHwgZmFsc2UsIGZhbHNlLCAnRScgLT4gRmxvYXRfRSAgfCBmYWxzZSwgZmFsc2UsICdnJyAtPiBGbG9hdF9nXG4gICAgfCBmYWxzZSwgIHRydWUsICdFJyAtPiBGbG9hdF9zRSB8IGZhbHNlLCAgdHJ1ZSwgJ2cnIC0+IEZsb2F0X3NnXG4gICAgfCAgdHJ1ZSwgZmFsc2UsICdFJyAtPiBGbG9hdF9wRSB8ICB0cnVlLCBmYWxzZSwgJ2cnIC0+IEZsb2F0X3BnXG4gICAgfCBmYWxzZSwgZmFsc2UsICdHJyAtPiBGbG9hdF9HXG4gICAgfCBmYWxzZSwgIHRydWUsICdHJyAtPiBGbG9hdF9zR1xuICAgIHwgIHRydWUsIGZhbHNlLCAnRycgLT4gRmxvYXRfcEdcbiAgICB8IGZhbHNlLCBmYWxzZSwgJ2gnIC0+IEZsb2F0X2hcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgJ2gnIC0+IEZsb2F0X3NoXG4gICAgfCAgdHJ1ZSwgZmFsc2UsICdoJyAtPiBGbG9hdF9waFxuICAgIHwgZmFsc2UsIGZhbHNlLCAnSCcgLT4gRmxvYXRfSFxuICAgIHwgZmFsc2UsICB0cnVlLCAnSCcgLT4gRmxvYXRfc0hcbiAgICB8ICB0cnVlLCBmYWxzZSwgJ0gnIC0+IEZsb2F0X3BIXG4gICAgfCBmYWxzZSwgZmFsc2UsICdGJyAtPiBGbG9hdF9GXG4gICAgfCAgdHJ1ZSwgIHRydWUsIF8gLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuXG4gICAgICAgICgqIHBsdXMgYW5kIHNwYWNlOiBsZWdhY3kgaW1wbGVtZW50YXRpb24gcHJlZmVycyBwbHVzICopXG4gICAgICAgIGNvbXB1dGVfZmxvYXRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBmYWxzZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnICcgXCInKydcIlxuICAgIHwgZmFsc2UsICB0cnVlLCBfIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiAoKiBpZ25vcmUgKilcbiAgICAgICAgY29tcHV0ZV9mbG9hdF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIGZhbHNlIHN5bWJcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInICdcIlxuICAgIHwgIHRydWUsIGZhbHNlLCBfIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiAoKiBpZ25vcmUgKilcbiAgICAgICAgY29tcHV0ZV9mbG9hdF9jb252IHBjdF9pbmQgc3RyX2luZCBmYWxzZSBzcGFjZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJysnXCJcbiAgICB8IGZhbHNlLCBmYWxzZSwgXyAtPiBhc3NlcnQgZmFsc2VcblxuICAoKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhIGZyaWVuZGx5IGVycm9yIG1lc3NhZ2UgYWJvdXQgaW5jb21wYXRpYmxlIG9wdGlvbnMuKilcbiAgYW5kIGluY29tcGF0aWJsZV9mbGFnIDogdHlwZSBhIC4gaW50IC0+IGludCAtPiBjaGFyIC0+IHN0cmluZyAtPiBhID1cbiAgICBmdW4gcGN0X2luZCBzdHJfaW5kIHN5bWIgb3B0aW9uIC0+XG4gICAgICBsZXQgc3ViZm10ID0gU3RyaW5nLnN1YiBzdHIgcGN0X2luZCAoc3RyX2luZCAtIHBjdF9pbmQpIGluXG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsIFxcXG4gICAgICAgICAlcyBpcyBpbmNvbXBhdGlibGUgd2l0aCAnJWMnIGluIHN1Yi1mb3JtYXQgJVNcIlxuICAgICAgICBzdHIgcGN0X2luZCBvcHRpb24gc3ltYiBzdWJmbXRcblxuICBpbiBwYXJzZSAwIChTdHJpbmcubGVuZ3RoIHN0cilcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICgqIEd1YXJkZWQgc3RyaW5nIHRvIGZvcm1hdCBjb252ZXJzaW9ucyAqKVxuXG4oKiBDb252ZXJ0IGEgc3RyaW5nIHRvIGEgZm9ybWF0IGFjY29yZGluZyB0byBhbiBmbXR0eS4gKilcbigqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGFuIGVycm9yIG1lc3NhZ2UgaW4gY2FzZSBvZiB0eXBlIG1pc21hdGNoLiAqKVxubGV0IGZvcm1hdF9vZl9zdHJpbmdfZm10dHkgc3RyIGZtdHR5ID1cbiAgbGV0IEZtdF9FQkIgZm10ID0gZm10X2ViYl9vZl9zdHJpbmcgc3RyIGluXG4gIHRyeSBGb3JtYXQgKHR5cGVfZm9ybWF0IGZtdCBmbXR0eSwgc3RyKVxuICB3aXRoIFR5cGVfbWlzbWF0Y2ggLT5cbiAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICBcImJhZCBpbnB1dDogZm9ybWF0IHR5cGUgbWlzbWF0Y2ggYmV0d2VlbiAlUyBhbmQgJVNcIlxuICAgICAgc3RyIChzdHJpbmdfb2ZfZm10dHkgZm10dHkpXG5cbigqIENvbnZlcnQgYSBzdHJpbmcgdG8gYSBmb3JtYXQgY29tcGF0aWJsZSB3aXRoIGFuIG90aGVyIGZvcm1hdC4gKilcbigqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGFuIGVycm9yIG1lc3NhZ2UgaW4gY2FzZSBvZiB0eXBlIG1pc21hdGNoLiAqKVxubGV0IGZvcm1hdF9vZl9zdHJpbmdfZm9ybWF0IHN0ciAoRm9ybWF0IChmbXQnLCBzdHInKSkgPVxuICBsZXQgRm10X0VCQiBmbXQgPSBmbXRfZWJiX29mX3N0cmluZyBzdHIgaW5cbiAgdHJ5IEZvcm1hdCAodHlwZV9mb3JtYXQgZm10IChmbXR0eV9vZl9mbXQgZm10JyksIHN0cilcbiAgd2l0aCBUeXBlX21pc21hdGNoIC0+XG4gICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgXCJiYWQgaW5wdXQ6IGZvcm1hdCB0eXBlIG1pc21hdGNoIGJldHdlZW4gJVMgYW5kICVTXCIgc3RyIHN0cidcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBQcmludGZcblxubGV0IHByaW50ZXJzID0gcmVmIFtdXG5cbmxldCBsb2NmbXQgPSBmb3JtYXRfb2Zfc3RyaW5nIFwiRmlsZSBcXFwiJXNcXFwiLCBsaW5lICVkLCBjaGFyYWN0ZXJzICVkLSVkOiAlc1wiXG5cbmxldCBmaWVsZCB4IGkgPVxuICBsZXQgZiA9IE9iai5maWVsZCB4IGkgaW5cbiAgaWYgbm90IChPYmouaXNfYmxvY2sgZikgdGhlblxuICAgIHNwcmludGYgXCIlZFwiIChPYmoubWFnaWMgZiA6IGludCkgICAgICAgICAgICgqIGNhbiBhbHNvIGJlIGEgY2hhciAqKVxuICBlbHNlIGlmIE9iai50YWcgZiA9IE9iai5zdHJpbmdfdGFnIHRoZW5cbiAgICBzcHJpbnRmIFwiJVNcIiAoT2JqLm1hZ2ljIGYgOiBzdHJpbmcpXG4gIGVsc2UgaWYgT2JqLnRhZyBmID0gT2JqLmRvdWJsZV90YWcgdGhlblxuICAgIHN0cmluZ19vZl9mbG9hdCAoT2JqLm1hZ2ljIGYgOiBmbG9hdClcbiAgZWxzZVxuICAgIFwiX1wiXG5cbmxldCByZWMgb3RoZXJfZmllbGRzIHggaSA9XG4gIGlmIGkgPj0gT2JqLnNpemUgeCB0aGVuIFwiXCJcbiAgZWxzZSBzcHJpbnRmIFwiLCAlcyVzXCIgKGZpZWxkIHggaSkgKG90aGVyX2ZpZWxkcyB4IChpKzEpKVxuXG5sZXQgZmllbGRzIHggPVxuICBtYXRjaCBPYmouc2l6ZSB4IHdpdGhcbiAgfCAwIC0+IFwiXCJcbiAgfCAxIC0+IFwiXCJcbiAgfCAyIC0+IHNwcmludGYgXCIoJXMpXCIgKGZpZWxkIHggMSlcbiAgfCBfIC0+IHNwcmludGYgXCIoJXMlcylcIiAoZmllbGQgeCAxKSAob3RoZXJfZmllbGRzIHggMilcblxubGV0IHRvX3N0cmluZyB4ID1cbiAgbGV0IHJlYyBjb252ID0gZnVuY3Rpb25cbiAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAgIChtYXRjaCB0cnkgaGQgeCB3aXRoIF8gLT4gTm9uZSB3aXRoXG4gICAgICAgIHwgU29tZSBzIC0+IHNcbiAgICAgICAgfCBOb25lIC0+IGNvbnYgdGwpXG4gICAgfCBbXSAtPlxuICAgICAgICBtYXRjaCB4IHdpdGhcbiAgICAgICAgfCBPdXRfb2ZfbWVtb3J5IC0+IFwiT3V0IG9mIG1lbW9yeVwiXG4gICAgICAgIHwgU3RhY2tfb3ZlcmZsb3cgLT4gXCJTdGFjayBvdmVyZmxvd1wiXG4gICAgICAgIHwgTWF0Y2hfZmFpbHVyZShmaWxlLCBsaW5lLCBjaGFyKSAtPlxuICAgICAgICAgICAgc3ByaW50ZiBsb2NmbXQgZmlsZSBsaW5lIGNoYXIgKGNoYXIrNSkgXCJQYXR0ZXJuIG1hdGNoaW5nIGZhaWxlZFwiXG4gICAgICAgIHwgQXNzZXJ0X2ZhaWx1cmUoZmlsZSwgbGluZSwgY2hhcikgLT5cbiAgICAgICAgICAgIHNwcmludGYgbG9jZm10IGZpbGUgbGluZSBjaGFyIChjaGFyKzYpIFwiQXNzZXJ0aW9uIGZhaWxlZFwiXG4gICAgICAgIHwgVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGUoZmlsZSwgbGluZSwgY2hhcikgLT5cbiAgICAgICAgICAgIHNwcmludGYgbG9jZm10IGZpbGUgbGluZSBjaGFyIChjaGFyKzYpIFwiVW5kZWZpbmVkIHJlY3Vyc2l2ZSBtb2R1bGVcIlxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIGxldCB4ID0gT2JqLnJlcHIgeCBpblxuICAgICAgICAgICAgaWYgT2JqLnRhZyB4IDw+IDAgdGhlblxuICAgICAgICAgICAgICAoT2JqLm1hZ2ljIChPYmouZmllbGQgeCAwKSA6IHN0cmluZylcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbGV0IGNvbnN0cnVjdG9yID1cbiAgICAgICAgICAgICAgICAoT2JqLm1hZ2ljIChPYmouZmllbGQgKE9iai5maWVsZCB4IDApIDApIDogc3RyaW5nKSBpblxuICAgICAgICAgICAgICBjb25zdHJ1Y3RvciBeIChmaWVsZHMgeCkgaW5cbiAgY29udiAhcHJpbnRlcnNcblxubGV0IHByaW50IGZjdCBhcmcgPVxuICB0cnlcbiAgICBmY3QgYXJnXG4gIHdpdGggeCAtPlxuICAgIGVwcmludGYgXCJVbmNhdWdodCBleGNlcHRpb246ICVzXFxuXCIgKHRvX3N0cmluZyB4KTtcbiAgICBmbHVzaCBzdGRlcnI7XG4gICAgcmFpc2UgeFxuXG5sZXQgY2F0Y2ggZmN0IGFyZyA9XG4gIHRyeVxuICAgIGZjdCBhcmdcbiAgd2l0aCB4IC0+XG4gICAgZmx1c2ggc3Rkb3V0O1xuICAgIGVwcmludGYgXCJVbmNhdWdodCBleGNlcHRpb246ICVzXFxuXCIgKHRvX3N0cmluZyB4KTtcbiAgICBleGl0IDJcblxudHlwZSByYXdfYmFja3RyYWNlX3Nsb3RcbnR5cGUgcmF3X2JhY2t0cmFjZVxuXG5leHRlcm5hbCBnZXRfcmF3X2JhY2t0cmFjZTpcbiAgdW5pdCAtPiByYXdfYmFja3RyYWNlID0gXCJjYW1sX2dldF9leGNlcHRpb25fcmF3X2JhY2t0cmFjZVwiXG5cbmV4dGVybmFsIHJhaXNlX3dpdGhfYmFja3RyYWNlOiBleG4gLT4gcmF3X2JhY2t0cmFjZSAtPiAnYVxuICA9IFwiJXJhaXNlX3dpdGhfYmFja3RyYWNlXCJcblxudHlwZSBiYWNrdHJhY2Vfc2xvdCA9XG4gIHwgS25vd25fbG9jYXRpb24gb2Yge1xuICAgICAgaXNfcmFpc2UgICAgOiBib29sO1xuICAgICAgZmlsZW5hbWUgICAgOiBzdHJpbmc7XG4gICAgICBsaW5lX251bWJlciA6IGludDtcbiAgICAgIHN0YXJ0X2NoYXIgIDogaW50O1xuICAgICAgZW5kX2NoYXIgICAgOiBpbnQ7XG4gICAgICBpc19pbmxpbmUgICA6IGJvb2w7XG4gICAgfVxuICB8IFVua25vd25fbG9jYXRpb24gb2Yge1xuICAgICAgaXNfcmFpc2UgOiBib29sXG4gICAgfVxuXG4oKiB0byBhdm9pZCB3YXJuaW5nICopXG5sZXQgXyA9IFtLbm93bl9sb2NhdGlvbiB7IGlzX3JhaXNlID0gZmFsc2U7IGZpbGVuYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZV9udW1iZXIgPSAwOyBzdGFydF9jaGFyID0gMDsgZW5kX2NoYXIgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpc19pbmxpbmUgPSBmYWxzZSB9O1xuICAgICAgICAgVW5rbm93bl9sb2NhdGlvbiB7IGlzX3JhaXNlID0gZmFsc2UgfV1cblxuZXh0ZXJuYWwgY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3Q6XG4gIHJhd19iYWNrdHJhY2Vfc2xvdCAtPiBiYWNrdHJhY2Vfc2xvdCA9IFwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdFwiXG5cbmV4dGVybmFsIGNvbnZlcnRfcmF3X2JhY2t0cmFjZTpcbiAgcmF3X2JhY2t0cmFjZSAtPiBiYWNrdHJhY2Vfc2xvdCBhcnJheSA9IFwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2VcIlxuXG5sZXQgY29udmVydF9yYXdfYmFja3RyYWNlIGJ0ID1cbiAgdHJ5IFNvbWUgKGNvbnZlcnRfcmF3X2JhY2t0cmFjZSBidClcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG5sZXQgZm9ybWF0X2JhY2t0cmFjZV9zbG90IHBvcyBzbG90ID1cbiAgbGV0IGluZm8gaXNfcmFpc2UgPVxuICAgIGlmIGlzX3JhaXNlIHRoZW5cbiAgICAgIGlmIHBvcyA9IDAgdGhlbiBcIlJhaXNlZCBhdFwiIGVsc2UgXCJSZS1yYWlzZWQgYXRcIlxuICAgIGVsc2VcbiAgICAgIGlmIHBvcyA9IDAgdGhlbiBcIlJhaXNlZCBieSBwcmltaXRpdmUgb3BlcmF0aW9uIGF0XCIgZWxzZSBcIkNhbGxlZCBmcm9tXCJcbiAgaW5cbiAgbWF0Y2ggc2xvdCB3aXRoXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBsIC0+XG4gICAgICBpZiBsLmlzX3JhaXNlIHRoZW5cbiAgICAgICAgKCogY29tcGlsZXItaW5zZXJ0ZWQgcmUtcmFpc2UsIHNraXBwZWQgKikgTm9uZVxuICAgICAgZWxzZVxuICAgICAgICBTb21lIChzcHJpbnRmIFwiJXMgdW5rbm93biBsb2NhdGlvblwiIChpbmZvIGZhbHNlKSlcbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+XG4gICAgICBTb21lIChzcHJpbnRmIFwiJXMgZmlsZSBcXFwiJXNcXFwiJXMsIGxpbmUgJWQsIGNoYXJhY3RlcnMgJWQtJWRcIlxuICAgICAgICAgICAgICAoaW5mbyBsLmlzX3JhaXNlKSBsLmZpbGVuYW1lXG4gICAgICAgICAgICAgIChpZiBsLmlzX2lubGluZSB0aGVuIFwiIChpbmxpbmVkKVwiIGVsc2UgXCJcIilcbiAgICAgICAgICAgICAgbC5saW5lX251bWJlciBsLnN0YXJ0X2NoYXIgbC5lbmRfY2hhcilcblxubGV0IHByaW50X2V4Y2VwdGlvbl9iYWNrdHJhY2Ugb3V0Y2hhbiBiYWNrdHJhY2UgPVxuICBtYXRjaCBiYWNrdHJhY2Ugd2l0aFxuICB8IE5vbmUgLT5cbiAgICAgIGZwcmludGYgb3V0Y2hhblxuICAgICAgICBcIihQcm9ncmFtIG5vdCBsaW5rZWQgd2l0aCAtZywgY2Fubm90IHByaW50IHN0YWNrIGJhY2t0cmFjZSlcXG5cIlxuICB8IFNvbWUgYSAtPlxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBhIC0gMSBkb1xuICAgICAgICBtYXRjaCBmb3JtYXRfYmFja3RyYWNlX3Nsb3QgaSBhLihpKSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgICAgfCBTb21lIHN0ciAtPiBmcHJpbnRmIG91dGNoYW4gXCIlc1xcblwiIHN0clxuICAgICAgZG9uZVxuXG5sZXQgcHJpbnRfcmF3X2JhY2t0cmFjZSBvdXRjaGFuIHJhd19iYWNrdHJhY2UgPVxuICBwcmludF9leGNlcHRpb25fYmFja3RyYWNlIG91dGNoYW4gKGNvbnZlcnRfcmF3X2JhY2t0cmFjZSByYXdfYmFja3RyYWNlKVxuXG4oKiBjb25mdXNpbmdseSBuYW1lZDogcHJpbnRzIHRoZSBnbG9iYWwgY3VycmVudCBiYWNrdHJhY2UgKilcbmxldCBwcmludF9iYWNrdHJhY2Ugb3V0Y2hhbiA9XG4gIHByaW50X3Jhd19iYWNrdHJhY2Ugb3V0Y2hhbiAoZ2V0X3Jhd19iYWNrdHJhY2UgKCkpXG5cbmxldCBiYWNrdHJhY2VfdG9fc3RyaW5nIGJhY2t0cmFjZSA9XG4gIG1hdGNoIGJhY2t0cmFjZSB3aXRoXG4gIHwgTm9uZSAtPlxuICAgICBcIihQcm9ncmFtIG5vdCBsaW5rZWQgd2l0aCAtZywgY2Fubm90IHByaW50IHN0YWNrIGJhY2t0cmFjZSlcXG5cIlxuICB8IFNvbWUgYSAtPlxuICAgICAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIDEwMjQgaW5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggYSAtIDEgZG9cbiAgICAgICAgbWF0Y2ggZm9ybWF0X2JhY2t0cmFjZV9zbG90IGkgYS4oaSkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgIHwgU29tZSBzdHIgLT4gYnByaW50ZiBiIFwiJXNcXG5cIiBzdHJcbiAgICAgIGRvbmU7XG4gICAgICBCdWZmZXIuY29udGVudHMgYlxuXG5sZXQgcmF3X2JhY2t0cmFjZV90b19zdHJpbmcgcmF3X2JhY2t0cmFjZSA9XG4gIGJhY2t0cmFjZV90b19zdHJpbmcgKGNvbnZlcnRfcmF3X2JhY2t0cmFjZSByYXdfYmFja3RyYWNlKVxuXG5sZXQgYmFja3RyYWNlX3Nsb3RfaXNfcmFpc2UgPSBmdW5jdGlvblxuICB8IEtub3duX2xvY2F0aW9uIGwgLT4gbC5pc19yYWlzZVxuICB8IFVua25vd25fbG9jYXRpb24gbCAtPiBsLmlzX3JhaXNlXG5cbmxldCBiYWNrdHJhY2Vfc2xvdF9pc19pbmxpbmUgPSBmdW5jdGlvblxuICB8IEtub3duX2xvY2F0aW9uIGwgLT4gbC5pc19pbmxpbmVcbiAgfCBVbmtub3duX2xvY2F0aW9uIF8gLT4gZmFsc2VcblxudHlwZSBsb2NhdGlvbiA9IHtcbiAgZmlsZW5hbWUgOiBzdHJpbmc7XG4gIGxpbmVfbnVtYmVyIDogaW50O1xuICBzdGFydF9jaGFyIDogaW50O1xuICBlbmRfY2hhciA6IGludDtcbn1cblxubGV0IGJhY2t0cmFjZV9zbG90X2xvY2F0aW9uID0gZnVuY3Rpb25cbiAgfCBVbmtub3duX2xvY2F0aW9uIF8gLT4gTm9uZVxuICB8IEtub3duX2xvY2F0aW9uIGwgLT5cbiAgICBTb21lIHtcbiAgICAgIGZpbGVuYW1lICAgID0gbC5maWxlbmFtZTtcbiAgICAgIGxpbmVfbnVtYmVyID0gbC5saW5lX251bWJlcjtcbiAgICAgIHN0YXJ0X2NoYXIgID0gbC5zdGFydF9jaGFyO1xuICAgICAgZW5kX2NoYXIgICAgPSBsLmVuZF9jaGFyO1xuICAgIH1cblxubGV0IGJhY2t0cmFjZV9zbG90cyByYXdfYmFja3RyYWNlID1cbiAgKCogVGhlIGRvY3VtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBndWFyYW50ZWVzIHRoYXQgU29tZSBpc1xuICAgICByZXR1cm5lZCBvbmx5IGlmIGEgcGFydCBvZiB0aGUgdHJhY2UgaXMgdXNhYmxlLiBUaGlzIGdpdmVzIHVzXG4gICAgIGEgYml0IG1vcmUgd29yayB0aGFuIGp1c3QgY29udmVydF9yYXdfYmFja3RyYWNlLCBidXQgaXQgbWFrZXMgdGhlXG4gICAgIEFQSSBtb3JlIHVzZXItZnJpZW5kbHkgLS0gb3RoZXJ3aXNlIG1vc3QgdXNlcnMgd291bGQgaGF2ZSB0b1xuICAgICByZWltcGxlbWVudCB0aGUgXCJQcm9ncmFtIG5vdCBsaW5rZWQgd2l0aCAtZywgc29ycnlcIiBsb2dpY1xuICAgICB0aGVtc2VsdmVzLiAqKVxuICBtYXRjaCBjb252ZXJ0X3Jhd19iYWNrdHJhY2UgcmF3X2JhY2t0cmFjZSB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgYmFja3RyYWNlIC0+XG4gICAgICBsZXQgdXNhYmxlX3Nsb3QgPSBmdW5jdGlvblxuICAgICAgICB8IFVua25vd25fbG9jYXRpb24gXyAtPiBmYWxzZVxuICAgICAgICB8IEtub3duX2xvY2F0aW9uIF8gLT4gdHJ1ZSBpblxuICAgICAgbGV0IHJlYyBleGlzdHNfdXNhYmxlID0gZnVuY3Rpb25cbiAgICAgICAgfCAoLTEpIC0+IGZhbHNlXG4gICAgICAgIHwgaSAtPiB1c2FibGVfc2xvdCBiYWNrdHJhY2UuKGkpIHx8IGV4aXN0c191c2FibGUgKGkgLSAxKSBpblxuICAgICAgaWYgZXhpc3RzX3VzYWJsZSAoQXJyYXkubGVuZ3RoIGJhY2t0cmFjZSAtIDEpXG4gICAgICB0aGVuIFNvbWUgYmFja3RyYWNlXG4gICAgICBlbHNlIE5vbmVcblxubW9kdWxlIFNsb3QgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gYmFja3RyYWNlX3Nsb3RcbiAgbGV0IGZvcm1hdCA9IGZvcm1hdF9iYWNrdHJhY2Vfc2xvdFxuICBsZXQgaXNfcmFpc2UgPSBiYWNrdHJhY2Vfc2xvdF9pc19yYWlzZVxuICBsZXQgaXNfaW5saW5lID0gYmFja3RyYWNlX3Nsb3RfaXNfaW5saW5lXG4gIGxldCBsb2NhdGlvbiA9IGJhY2t0cmFjZV9zbG90X2xvY2F0aW9uXG5lbmRcblxuZXh0ZXJuYWwgcmF3X2JhY2t0cmFjZV9sZW5ndGggOlxuICByYXdfYmFja3RyYWNlIC0+IGludCA9IFwiY2FtbF9yYXdfYmFja3RyYWNlX2xlbmd0aFwiIFtAQG5vYWxsb2NdXG5cbmV4dGVybmFsIGdldF9yYXdfYmFja3RyYWNlX3Nsb3QgOlxuICByYXdfYmFja3RyYWNlIC0+IGludCAtPiByYXdfYmFja3RyYWNlX3Nsb3QgPSBcImNhbWxfcmF3X2JhY2t0cmFjZV9zbG90XCJcblxuZXh0ZXJuYWwgZ2V0X3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90IDpcbiAgcmF3X2JhY2t0cmFjZV9zbG90IC0+IHJhd19iYWNrdHJhY2Vfc2xvdCBvcHRpb25cbiAgPSBcImNhbWxfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3RcIlxuXG4oKiBjb25mdXNpbmdseSBuYW1lZDpcbiAgIHJldHVybnMgdGhlICpzdHJpbmcqIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdsb2JhbCBjdXJyZW50IGJhY2t0cmFjZSAqKVxubGV0IGdldF9iYWNrdHJhY2UgKCkgPSByYXdfYmFja3RyYWNlX3RvX3N0cmluZyAoZ2V0X3Jhd19iYWNrdHJhY2UgKCkpXG5cbmV4dGVybmFsIHJlY29yZF9iYWNrdHJhY2U6IGJvb2wgLT4gdW5pdCA9IFwiY2FtbF9yZWNvcmRfYmFja3RyYWNlXCJcbmV4dGVybmFsIGJhY2t0cmFjZV9zdGF0dXM6IHVuaXQgLT4gYm9vbCA9IFwiY2FtbF9iYWNrdHJhY2Vfc3RhdHVzXCJcblxubGV0IHJlZ2lzdGVyX3ByaW50ZXIgZm4gPVxuICBwcmludGVycyA6PSBmbiA6OiAhcHJpbnRlcnNcblxuZXh0ZXJuYWwgZ2V0X2NhbGxzdGFjazogaW50IC0+IHJhd19iYWNrdHJhY2UgPSBcImNhbWxfZ2V0X2N1cnJlbnRfY2FsbHN0YWNrXCJcblxubGV0IGV4bl9zbG90IHggPVxuICBsZXQgeCA9IE9iai5yZXByIHggaW5cbiAgaWYgT2JqLnRhZyB4ID0gMCB0aGVuIE9iai5maWVsZCB4IDAgZWxzZSB4XG5cbmxldCBleG5fc2xvdF9pZCB4ID1cbiAgbGV0IHNsb3QgPSBleG5fc2xvdCB4IGluXG4gIChPYmoub2JqIChPYmouZmllbGQgc2xvdCAxKSA6IGludClcblxubGV0IGV4bl9zbG90X25hbWUgeCA9XG4gIGxldCBzbG90ID0gZXhuX3Nsb3QgeCBpblxuICAoT2JqLm9iaiAoT2JqLmZpZWxkIHNsb3QgMCkgOiBzdHJpbmcpXG5cblxubGV0IHVuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyID0gcmVmIE5vbmVcblxubGV0IHNldF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlciBmbiA9IHVuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIDo9IFNvbWUgZm5cblxubGV0IGVtcHR5X2JhY2t0cmFjZSA6IHJhd19iYWNrdHJhY2UgPSBPYmoub2JqIChPYmoubmV3X2Jsb2NrIE9iai5hYnN0cmFjdF90YWcgMClcblxubGV0IHRyeV9nZXRfcmF3X2JhY2t0cmFjZSAoKSA9XG4gIHRyeVxuICAgIGdldF9yYXdfYmFja3RyYWNlICgpXG4gIHdpdGggXyAoKiBPdXRfb2ZfbWVtb3J5PyAqKSAtPlxuICAgIGVtcHR5X2JhY2t0cmFjZVxuXG5sZXQgaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvbicgZXhuIGRlYnVnZ2VyX2luX3VzZSA9XG4gIHRyeVxuICAgICgqIEdldCB0aGUgYmFja3RyYWNlIG5vdywgaW4gY2FzZSBvbmUgb2YgdGhlIFthdF9leGl0XSBmdW5jdGlvblxuICAgICAgIGRlc3Ryb3lzIGl0LiAqKVxuICAgIGxldCByYXdfYmFja3RyYWNlID1cbiAgICAgIGlmIGRlYnVnZ2VyX2luX3VzZSAoKiBTYW1lIHRlc3QgYXMgaW4gW2J5dGVydW4vcHJpbnRleGMuY10gKikgdGhlblxuICAgICAgICBlbXB0eV9iYWNrdHJhY2VcbiAgICAgIGVsc2VcbiAgICAgICAgdHJ5X2dldF9yYXdfYmFja3RyYWNlICgpXG4gICAgaW5cbiAgICAodHJ5IFBlcnZhc2l2ZXMuZG9fYXRfZXhpdCAoKSB3aXRoIF8gLT4gKCkpO1xuICAgIG1hdGNoICF1bmNhdWdodF9leGNlcHRpb25faGFuZGxlciB3aXRoXG4gICAgfCBOb25lIC0+XG4gICAgICAgIGVwcmludGYgXCJGYXRhbCBlcnJvcjogZXhjZXB0aW9uICVzXFxuXCIgKHRvX3N0cmluZyBleG4pO1xuICAgICAgICBwcmludF9yYXdfYmFja3RyYWNlIHN0ZGVyciByYXdfYmFja3RyYWNlO1xuICAgICAgICBmbHVzaCBzdGRlcnJcbiAgICB8IFNvbWUgaGFuZGxlciAtPlxuICAgICAgICB0cnlcbiAgICAgICAgICBoYW5kbGVyIGV4biByYXdfYmFja3RyYWNlXG4gICAgICAgIHdpdGggZXhuJyAtPlxuICAgICAgICAgIGxldCByYXdfYmFja3RyYWNlJyA9IHRyeV9nZXRfcmF3X2JhY2t0cmFjZSAoKSBpblxuICAgICAgICAgIGVwcmludGYgXCJGYXRhbCBlcnJvcjogZXhjZXB0aW9uICVzXFxuXCIgKHRvX3N0cmluZyBleG4pO1xuICAgICAgICAgIHByaW50X3Jhd19iYWNrdHJhY2Ugc3RkZXJyIHJhd19iYWNrdHJhY2U7XG4gICAgICAgICAgZXByaW50ZiBcIkZhdGFsIGVycm9yIGluIHVuY2F1Z2h0IGV4Y2VwdGlvbiBoYW5kbGVyOiBleGNlcHRpb24gJXNcXG5cIlxuICAgICAgICAgICAgKHRvX3N0cmluZyBleG4nKTtcbiAgICAgICAgICBwcmludF9yYXdfYmFja3RyYWNlIHN0ZGVyciByYXdfYmFja3RyYWNlJztcbiAgICAgICAgICBmbHVzaCBzdGRlcnJcbiAgd2l0aFxuICAgIHwgT3V0X29mX21lbW9yeSAtPlxuICAgICAgICBwcmVycl9lbmRsaW5lXG4gICAgICAgICAgXCJGYXRhbCBlcnJvcjogb3V0IG9mIG1lbW9yeSBpbiB1bmNhdWdodCBleGNlcHRpb24gaGFuZGxlclwiXG5cbigqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGJ5IFtjYW1sX2ZhdGFsX3VuY2F1Z2h0X2V4Y2VwdGlvbl0gaW5cbiAgIFtieXRlcnVuL3ByaW50ZXhjLmNdIHdoaWNoIGV4cGVjdHMgbm8gZXhjZXB0aW9uIGlzIHJhaXNlZC4gKilcbmxldCBoYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uIGV4biBkZWJ1Z2dlcl9pbl91c2UgPVxuICB0cnlcbiAgICBoYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uJyBleG4gZGVidWdnZXJfaW5fdXNlXG4gIHdpdGggXyAtPlxuICAgICgqIFRoZXJlIGlzIG5vdCBtdWNoIHdlIGNhbiBkbyBhdCB0aGlzIHBvaW50ICopXG4gICAgKClcblxuZXh0ZXJuYWwgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgOiBzdHJpbmcgLT4gJ2EgLT4gdW5pdFxuICA9IFwiY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZVwiXG5cbmxldCAoKSA9XG4gIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIFwiUHJpbnRleGMuaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvblwiXG4gICAgaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvblxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgIFhhdmllciBMZXJveSBhbmQgRGFtaWVuIERvbGlnZXosIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5sZXQgZ2VuZXJpY19xdW90ZSBxdW90ZXF1b3RlIHMgPVxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgKGwgKyAyMCkgaW5cbiAgQnVmZmVyLmFkZF9jaGFyIGIgJ1xcJyc7XG4gIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgIGlmIHMuW2ldID0gJ1xcJydcbiAgICB0aGVuIEJ1ZmZlci5hZGRfc3RyaW5nIGIgcXVvdGVxdW90ZVxuICAgIGVsc2UgQnVmZmVyLmFkZF9jaGFyIGIgIHMuW2ldXG4gIGRvbmU7XG4gIEJ1ZmZlci5hZGRfY2hhciBiICdcXCcnO1xuICBCdWZmZXIuY29udGVudHMgYlxuXG4oKiBUaGlzIGZ1bmN0aW9uIGltcGxlbWVudHMgdGhlIE9wZW4gR3JvdXAgc3BlY2lmaWNhdGlvbiBmb3VuZCBoZXJlOlxuICBbWzFdXSBodHRwOi8vcHVicy5vcGVuZ3JvdXAub3JnL29ubGluZXB1YnMvOTY5OTkxOTc5OS91dGlsaXRpZXMvYmFzZW5hbWUuaHRtbFxuICBJbiBzdGVwIDEgb2YgW1sxXV0sIHdlIGNob29zZSB0byByZXR1cm4gXCIuXCIgZm9yIGVtcHR5IGlucHV0LlxuICAgIChmb3IgY29tcGF0aWJpbGl0eSB3aXRoIHByZXZpb3VzIHZlcnNpb25zIG9mIE9DYW1sKVxuICBJbiBzdGVwIDIsIHdlIGNob29zZSB0byBwcm9jZXNzIFwiLy9cIiBub3JtYWxseS5cbiAgU3RlcCA2IGlzIG5vdCBpbXBsZW1lbnRlZDogd2UgY29uc2lkZXIgdGhhdCB0aGUgW3N1ZmZpeF0gb3BlcmFuZCBpc1xuICAgIGFsd2F5cyBhYnNlbnQuICBTdWZmaXhlcyBhcmUgaGFuZGxlZCBieSBbY2hvcF9zdWZmaXhdIGFuZCBbY2hvcF9leHRlbnNpb25dLlxuKilcbmxldCBnZW5lcmljX2Jhc2VuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZSBuYW1lID1cbiAgbGV0IHJlYyBmaW5kX2VuZCBuID1cbiAgICBpZiBuIDwgMCB0aGVuIFN0cmluZy5zdWIgbmFtZSAwIDFcbiAgICBlbHNlIGlmIGlzX2Rpcl9zZXAgbmFtZSBuIHRoZW4gZmluZF9lbmQgKG4gLSAxKVxuICAgIGVsc2UgZmluZF9iZWcgbiAobiArIDEpXG4gIGFuZCBmaW5kX2JlZyBuIHAgPVxuICAgIGlmIG4gPCAwIHRoZW4gU3RyaW5nLnN1YiBuYW1lIDAgcFxuICAgIGVsc2UgaWYgaXNfZGlyX3NlcCBuYW1lIG4gdGhlbiBTdHJpbmcuc3ViIG5hbWUgKG4gKyAxKSAocCAtIG4gLSAxKVxuICAgIGVsc2UgZmluZF9iZWcgKG4gLSAxKSBwXG4gIGluXG4gIGlmIG5hbWUgPSBcIlwiXG4gIHRoZW4gY3VycmVudF9kaXJfbmFtZVxuICBlbHNlIGZpbmRfZW5kIChTdHJpbmcubGVuZ3RoIG5hbWUgLSAxKVxuXG4oKiBUaGlzIGZ1bmN0aW9uIGltcGxlbWVudHMgdGhlIE9wZW4gR3JvdXAgc3BlY2lmaWNhdGlvbiBmb3VuZCBoZXJlOlxuICBbWzJdXSBodHRwOi8vcHVicy5vcGVuZ3JvdXAub3JnL29ubGluZXB1YnMvOTY5OTkxOTc5OS91dGlsaXRpZXMvZGlybmFtZS5odG1sXG4gIEluIHN0ZXAgNiBvZiBbWzJdXSwgd2UgY2hvb3NlIHRvIHByb2Nlc3MgXCIvL1wiIG5vcm1hbGx5LlxuKilcbmxldCBnZW5lcmljX2Rpcm5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lIG5hbWUgPVxuICBsZXQgcmVjIHRyYWlsaW5nX3NlcCBuID1cbiAgICBpZiBuIDwgMCB0aGVuIFN0cmluZy5zdWIgbmFtZSAwIDFcbiAgICBlbHNlIGlmIGlzX2Rpcl9zZXAgbmFtZSBuIHRoZW4gdHJhaWxpbmdfc2VwIChuIC0gMSlcbiAgICBlbHNlIGJhc2UgblxuICBhbmQgYmFzZSBuID1cbiAgICBpZiBuIDwgMCB0aGVuIGN1cnJlbnRfZGlyX25hbWVcbiAgICBlbHNlIGlmIGlzX2Rpcl9zZXAgbmFtZSBuIHRoZW4gaW50ZXJtZWRpYXRlX3NlcCBuXG4gICAgZWxzZSBiYXNlIChuIC0gMSlcbiAgYW5kIGludGVybWVkaWF0ZV9zZXAgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCAxXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIGludGVybWVkaWF0ZV9zZXAgKG4gLSAxKVxuICAgIGVsc2UgU3RyaW5nLnN1YiBuYW1lIDAgKG4gKyAxKVxuICBpblxuICBpZiBuYW1lID0gXCJcIlxuICB0aGVuIGN1cnJlbnRfZGlyX25hbWVcbiAgZWxzZSB0cmFpbGluZ19zZXAgKFN0cmluZy5sZW5ndGggbmFtZSAtIDEpXG5cbm1vZHVsZSBVbml4ID0gc3RydWN0XG4gIGxldCBjdXJyZW50X2Rpcl9uYW1lID0gXCIuXCJcbiAgbGV0IHBhcmVudF9kaXJfbmFtZSA9IFwiLi5cIlxuICBsZXQgZGlyX3NlcCA9IFwiL1wiXG4gIGxldCBpc19kaXJfc2VwIHMgaSA9IHMuW2ldID0gJy8nXG4gIGxldCBpc19yZWxhdGl2ZSBuID0gU3RyaW5nLmxlbmd0aCBuIDwgMSB8fCBuLlswXSA8PiAnLydcbiAgbGV0IGlzX2ltcGxpY2l0IG4gPVxuICAgIGlzX3JlbGF0aXZlIG5cbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMiB8fCBTdHJpbmcuc3ViIG4gMCAyIDw+IFwiLi9cIilcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMyB8fCBTdHJpbmcuc3ViIG4gMCAzIDw+IFwiLi4vXCIpXG4gIGxldCBjaGVja19zdWZmaXggbmFtZSBzdWZmID1cbiAgICBTdHJpbmcubGVuZ3RoIG5hbWUgPj0gU3RyaW5nLmxlbmd0aCBzdWZmICYmXG4gICAgU3RyaW5nLnN1YiBuYW1lIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBTdHJpbmcubGVuZ3RoIHN1ZmYpXG4gICAgICAgICAgICAgICAgICAgIChTdHJpbmcubGVuZ3RoIHN1ZmYpID0gc3VmZlxuICBsZXQgdGVtcF9kaXJfbmFtZSA9XG4gICAgdHJ5IFN5cy5nZXRlbnYgXCJUTVBESVJcIiB3aXRoIE5vdF9mb3VuZCAtPiBcIi90bXBcIlxuICBsZXQgcXVvdGUgPSBnZW5lcmljX3F1b3RlIFwiJ1xcXFwnJ1wiXG4gIGxldCBiYXNlbmFtZSA9IGdlbmVyaWNfYmFzZW5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lXG4gIGxldCBkaXJuYW1lID0gZ2VuZXJpY19kaXJuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZVxuZW5kXG5cbm1vZHVsZSBXaW4zMiA9IHN0cnVjdFxuICBsZXQgY3VycmVudF9kaXJfbmFtZSA9IFwiLlwiXG4gIGxldCBwYXJlbnRfZGlyX25hbWUgPSBcIi4uXCJcbiAgbGV0IGRpcl9zZXAgPSBcIlxcXFxcIlxuICBsZXQgaXNfZGlyX3NlcCBzIGkgPSBsZXQgYyA9IHMuW2ldIGluIGMgPSAnLycgfHwgYyA9ICdcXFxcJyB8fCBjID0gJzonXG4gIGxldCBpc19yZWxhdGl2ZSBuID1cbiAgICAoU3RyaW5nLmxlbmd0aCBuIDwgMSB8fCBuLlswXSA8PiAnLycpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDEgfHwgbi5bMF0gPD4gJ1xcXFwnKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAyIHx8IG4uWzFdIDw+ICc6JylcbiAgbGV0IGlzX2ltcGxpY2l0IG4gPVxuICAgIGlzX3JlbGF0aXZlIG5cbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMiB8fCBTdHJpbmcuc3ViIG4gMCAyIDw+IFwiLi9cIilcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMiB8fCBTdHJpbmcuc3ViIG4gMCAyIDw+IFwiLlxcXFxcIilcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMyB8fCBTdHJpbmcuc3ViIG4gMCAzIDw+IFwiLi4vXCIpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDMgfHwgU3RyaW5nLnN1YiBuIDAgMyA8PiBcIi4uXFxcXFwiKVxuICBsZXQgY2hlY2tfc3VmZml4IG5hbWUgc3VmZiA9XG4gICBTdHJpbmcubGVuZ3RoIG5hbWUgPj0gU3RyaW5nLmxlbmd0aCBzdWZmICYmXG4gICAobGV0IHMgPSBTdHJpbmcuc3ViIG5hbWUgKFN0cmluZy5sZW5ndGggbmFtZSAtIFN0cmluZy5sZW5ndGggc3VmZilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoU3RyaW5nLmxlbmd0aCBzdWZmKSBpblxuICAgIFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgcyA9IFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgc3VmZilcbiAgbGV0IHRlbXBfZGlyX25hbWUgPVxuICAgIHRyeSBTeXMuZ2V0ZW52IFwiVEVNUFwiIHdpdGggTm90X2ZvdW5kIC0+IFwiLlwiXG4gIGxldCBxdW90ZSBzID1cbiAgICBsZXQgbCA9IFN0cmluZy5sZW5ndGggcyBpblxuICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAobCArIDIwKSBpblxuICAgIEJ1ZmZlci5hZGRfY2hhciBiICdcXFwiJztcbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbCB0aGVuIEJ1ZmZlci5hZGRfY2hhciBiICdcXFwiJyBlbHNlXG4gICAgICBtYXRjaCBzLltpXSB3aXRoXG4gICAgICB8ICdcXFwiJyAtPiBsb29wX2JzIDAgaTtcbiAgICAgIHwgJ1xcXFwnIC0+IGxvb3BfYnMgMCBpO1xuICAgICAgfCBjICAgIC0+IEJ1ZmZlci5hZGRfY2hhciBiIGM7IGxvb3AgKGkrMSk7XG4gICAgYW5kIGxvb3BfYnMgbiBpID1cbiAgICAgIGlmIGkgPSBsIHRoZW4gYmVnaW5cbiAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXCInO1xuICAgICAgICBhZGRfYnMgbjtcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIG1hdGNoIHMuW2ldIHdpdGhcbiAgICAgICAgfCAnXFxcIicgLT4gYWRkX2JzICgyKm4rMSk7IEJ1ZmZlci5hZGRfY2hhciBiICdcXFwiJzsgbG9vcCAoaSsxKTtcbiAgICAgICAgfCAnXFxcXCcgLT4gbG9vcF9icyAobisxKSAoaSsxKTtcbiAgICAgICAgfCBfICAgIC0+IGFkZF9icyBuOyBsb29wIGlcbiAgICAgIGVuZFxuICAgIGFuZCBhZGRfYnMgbiA9IGZvciBfaiA9IDEgdG8gbiBkbyBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcXCc7IGRvbmVcbiAgICBpblxuICAgIGxvb3AgMDtcbiAgICBCdWZmZXIuY29udGVudHMgYlxuICBsZXQgaGFzX2RyaXZlIHMgPVxuICAgIGxldCBpc19sZXR0ZXIgPSBmdW5jdGlvblxuICAgICAgfCAnQScgLi4gJ1onIHwgJ2EnIC4uICd6JyAtPiB0cnVlXG4gICAgICB8IF8gLT4gZmFsc2VcbiAgICBpblxuICAgIFN0cmluZy5sZW5ndGggcyA+PSAyICYmIGlzX2xldHRlciBzLlswXSAmJiBzLlsxXSA9ICc6J1xuICBsZXQgZHJpdmVfYW5kX3BhdGggcyA9XG4gICAgaWYgaGFzX2RyaXZlIHNcbiAgICB0aGVuIChTdHJpbmcuc3ViIHMgMCAyLCBTdHJpbmcuc3ViIHMgMiAoU3RyaW5nLmxlbmd0aCBzIC0gMikpXG4gICAgZWxzZSAoXCJcIiwgcylcbiAgbGV0IGRpcm5hbWUgcyA9XG4gICAgbGV0IChkcml2ZSwgcGF0aCkgPSBkcml2ZV9hbmRfcGF0aCBzIGluXG4gICAgbGV0IGRpciA9IGdlbmVyaWNfZGlybmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWUgcGF0aCBpblxuICAgIGRyaXZlIF4gZGlyXG4gIGxldCBiYXNlbmFtZSBzID1cbiAgICBsZXQgKF9kcml2ZSwgcGF0aCkgPSBkcml2ZV9hbmRfcGF0aCBzIGluXG4gICAgZ2VuZXJpY19iYXNlbmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWUgcGF0aFxuZW5kXG5cbm1vZHVsZSBDeWd3aW4gPSBzdHJ1Y3RcbiAgbGV0IGN1cnJlbnRfZGlyX25hbWUgPSBcIi5cIlxuICBsZXQgcGFyZW50X2Rpcl9uYW1lID0gXCIuLlwiXG4gIGxldCBkaXJfc2VwID0gXCIvXCJcbiAgbGV0IGlzX2Rpcl9zZXAgPSBXaW4zMi5pc19kaXJfc2VwXG4gIGxldCBpc19yZWxhdGl2ZSA9IFdpbjMyLmlzX3JlbGF0aXZlXG4gIGxldCBpc19pbXBsaWNpdCA9IFdpbjMyLmlzX2ltcGxpY2l0XG4gIGxldCBjaGVja19zdWZmaXggPSBXaW4zMi5jaGVja19zdWZmaXhcbiAgbGV0IHRlbXBfZGlyX25hbWUgPSBVbml4LnRlbXBfZGlyX25hbWVcbiAgbGV0IHF1b3RlID0gVW5peC5xdW90ZVxuICBsZXQgYmFzZW5hbWUgPSBnZW5lcmljX2Jhc2VuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZVxuICBsZXQgZGlybmFtZSA9IGdlbmVyaWNfZGlybmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWVcbmVuZFxuXG5sZXQgKGN1cnJlbnRfZGlyX25hbWUsIHBhcmVudF9kaXJfbmFtZSwgZGlyX3NlcCwgaXNfZGlyX3NlcCxcbiAgICAgaXNfcmVsYXRpdmUsIGlzX2ltcGxpY2l0LCBjaGVja19zdWZmaXgsIHRlbXBfZGlyX25hbWUsIHF1b3RlLCBiYXNlbmFtZSxcbiAgICAgZGlybmFtZSkgPVxuICBtYXRjaCBTeXMub3NfdHlwZSB3aXRoXG4gIHwgXCJXaW4zMlwiIC0+XG4gICAgICAoV2luMzIuY3VycmVudF9kaXJfbmFtZSwgV2luMzIucGFyZW50X2Rpcl9uYW1lLCBXaW4zMi5kaXJfc2VwLFxuICAgICAgIFdpbjMyLmlzX2Rpcl9zZXAsXG4gICAgICAgV2luMzIuaXNfcmVsYXRpdmUsIFdpbjMyLmlzX2ltcGxpY2l0LCBXaW4zMi5jaGVja19zdWZmaXgsXG4gICAgICAgV2luMzIudGVtcF9kaXJfbmFtZSwgV2luMzIucXVvdGUsIFdpbjMyLmJhc2VuYW1lLCBXaW4zMi5kaXJuYW1lKVxuICB8IFwiQ3lnd2luXCIgLT5cbiAgICAgIChDeWd3aW4uY3VycmVudF9kaXJfbmFtZSwgQ3lnd2luLnBhcmVudF9kaXJfbmFtZSwgQ3lnd2luLmRpcl9zZXAsXG4gICAgICAgQ3lnd2luLmlzX2Rpcl9zZXAsXG4gICAgICAgQ3lnd2luLmlzX3JlbGF0aXZlLCBDeWd3aW4uaXNfaW1wbGljaXQsIEN5Z3dpbi5jaGVja19zdWZmaXgsXG4gICAgICAgQ3lnd2luLnRlbXBfZGlyX25hbWUsIEN5Z3dpbi5xdW90ZSwgQ3lnd2luLmJhc2VuYW1lLCBDeWd3aW4uZGlybmFtZSlcbiAgfCBfIC0+ICgqIG5vcm1hbGx5IFwiVW5peFwiICopXG4gICAgICAoVW5peC5jdXJyZW50X2Rpcl9uYW1lLCBVbml4LnBhcmVudF9kaXJfbmFtZSwgVW5peC5kaXJfc2VwLFxuICAgICAgIFVuaXguaXNfZGlyX3NlcCxcbiAgICAgICBVbml4LmlzX3JlbGF0aXZlLCBVbml4LmlzX2ltcGxpY2l0LCBVbml4LmNoZWNrX3N1ZmZpeCxcbiAgICAgICBVbml4LnRlbXBfZGlyX25hbWUsIFVuaXgucXVvdGUsIFVuaXguYmFzZW5hbWUsIFVuaXguZGlybmFtZSlcblxubGV0IGNvbmNhdCBkaXJuYW1lIGZpbGVuYW1lID1cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIGRpcm5hbWUgaW5cbiAgaWYgbCA9IDAgfHwgaXNfZGlyX3NlcCBkaXJuYW1lIChsLTEpXG4gIHRoZW4gZGlybmFtZSBeIGZpbGVuYW1lXG4gIGVsc2UgZGlybmFtZSBeIGRpcl9zZXAgXiBmaWxlbmFtZVxuXG5sZXQgY2hvcF9zdWZmaXggbmFtZSBzdWZmID1cbiAgbGV0IG4gPSBTdHJpbmcubGVuZ3RoIG5hbWUgLSBTdHJpbmcubGVuZ3RoIHN1ZmYgaW5cbiAgaWYgbiA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkZpbGVuYW1lLmNob3Bfc3VmZml4XCIgZWxzZSBTdHJpbmcuc3ViIG5hbWUgMCBuXG5cbmxldCBleHRlbnNpb25fbGVuIG5hbWUgPVxuICBsZXQgcmVjIGNoZWNrIGkwIGkgPVxuICAgIGlmIGkgPCAwIHx8IGlzX2Rpcl9zZXAgbmFtZSBpIHRoZW4gMFxuICAgIGVsc2UgaWYgbmFtZS5baV0gPSAnLicgdGhlbiBjaGVjayBpMCAoaSAtIDEpXG4gICAgZWxzZSBTdHJpbmcubGVuZ3RoIG5hbWUgLSBpMFxuICBpblxuICBsZXQgcmVjIHNlYXJjaF9kb3QgaSA9XG4gICAgaWYgaSA8IDAgfHwgaXNfZGlyX3NlcCBuYW1lIGkgdGhlbiAwXG4gICAgZWxzZSBpZiBuYW1lLltpXSA9ICcuJyB0aGVuIGNoZWNrIGkgKGkgLSAxKVxuICAgIGVsc2Ugc2VhcmNoX2RvdCAoaSAtIDEpXG4gIGluXG4gIHNlYXJjaF9kb3QgKFN0cmluZy5sZW5ndGggbmFtZSAtIDEpXG5cbmxldCBleHRlbnNpb24gbmFtZSA9XG4gIGxldCBsID0gZXh0ZW5zaW9uX2xlbiBuYW1lIGluXG4gIGlmIGwgPSAwIHRoZW4gXCJcIiBlbHNlIFN0cmluZy5zdWIgbmFtZSAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gbCkgbFxuXG5sZXQgY2hvcF9leHRlbnNpb24gbmFtZSA9XG4gIGxldCBsID0gZXh0ZW5zaW9uX2xlbiBuYW1lIGluXG4gIGlmIGwgPSAwIHRoZW4gaW52YWxpZF9hcmcgXCJGaWxlbmFtZS5jaG9wX2V4dGVuc2lvblwiXG4gIGVsc2UgU3RyaW5nLnN1YiBuYW1lIDAgKFN0cmluZy5sZW5ndGggbmFtZSAtIGwpXG5cbmxldCByZW1vdmVfZXh0ZW5zaW9uIG5hbWUgPVxuICBsZXQgbCA9IGV4dGVuc2lvbl9sZW4gbmFtZSBpblxuICBpZiBsID0gMCB0aGVuIG5hbWUgZWxzZSBTdHJpbmcuc3ViIG5hbWUgMCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gbClcblxuZXh0ZXJuYWwgb3Blbl9kZXNjOiBzdHJpbmcgLT4gb3Blbl9mbGFnIGxpc3QgLT4gaW50IC0+IGludCA9IFwiY2FtbF9zeXNfb3BlblwiXG5leHRlcm5hbCBjbG9zZV9kZXNjOiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9zeXNfY2xvc2VcIlxuXG5sZXQgcHJuZyA9IGxhenkoUmFuZG9tLlN0YXRlLm1ha2Vfc2VsZl9pbml0ICgpKVxuXG5sZXQgdGVtcF9maWxlX25hbWUgdGVtcF9kaXIgcHJlZml4IHN1ZmZpeCA9XG4gIGxldCBybmQgPSAoUmFuZG9tLlN0YXRlLmJpdHMgKExhenkuZm9yY2UgcHJuZykpIGxhbmQgMHhGRkZGRkYgaW5cbiAgY29uY2F0IHRlbXBfZGlyIChQcmludGYuc3ByaW50ZiBcIiVzJTA2eCVzXCIgcHJlZml4IHJuZCBzdWZmaXgpXG5cblxubGV0IGN1cnJlbnRfdGVtcF9kaXJfbmFtZSA9IHJlZiB0ZW1wX2Rpcl9uYW1lXG5cbmxldCBzZXRfdGVtcF9kaXJfbmFtZSBzID0gY3VycmVudF90ZW1wX2Rpcl9uYW1lIDo9IHNcbmxldCBnZXRfdGVtcF9kaXJfbmFtZSAoKSA9ICFjdXJyZW50X3RlbXBfZGlyX25hbWVcblxubGV0IHRlbXBfZmlsZSA/KHRlbXBfZGlyID0gIWN1cnJlbnRfdGVtcF9kaXJfbmFtZSkgcHJlZml4IHN1ZmZpeCA9XG4gIGxldCByZWMgdHJ5X25hbWUgY291bnRlciA9XG4gICAgbGV0IG5hbWUgPSB0ZW1wX2ZpbGVfbmFtZSB0ZW1wX2RpciBwcmVmaXggc3VmZml4IGluXG4gICAgdHJ5XG4gICAgICBjbG9zZV9kZXNjKG9wZW5fZGVzYyBuYW1lIFtPcGVuX3dyb25seTsgT3Blbl9jcmVhdDsgT3Blbl9leGNsXSAwbzYwMCk7XG4gICAgICBuYW1lXG4gICAgd2l0aCBTeXNfZXJyb3IgXyBhcyBlIC0+XG4gICAgICBpZiBjb3VudGVyID49IDEwMDAgdGhlbiByYWlzZSBlIGVsc2UgdHJ5X25hbWUgKGNvdW50ZXIgKyAxKVxuICBpbiB0cnlfbmFtZSAwXG5cbmxldCBvcGVuX3RlbXBfZmlsZSA/KG1vZGUgPSBbT3Blbl90ZXh0XSkgPyhwZXJtcyA9IDBvNjAwKVxuICAgICAgICAgICAgICAgICAgID8odGVtcF9kaXIgPSAhY3VycmVudF90ZW1wX2Rpcl9uYW1lKSBwcmVmaXggc3VmZml4ID1cbiAgbGV0IHJlYyB0cnlfbmFtZSBjb3VudGVyID1cbiAgICBsZXQgbmFtZSA9IHRlbXBfZmlsZV9uYW1lIHRlbXBfZGlyIHByZWZpeCBzdWZmaXggaW5cbiAgICB0cnlcbiAgICAgIChuYW1lLFxuICAgICAgIG9wZW5fb3V0X2dlbiAoT3Blbl93cm9ubHk6Ok9wZW5fY3JlYXQ6Ok9wZW5fZXhjbDo6bW9kZSkgcGVybXMgbmFtZSlcbiAgICB3aXRoIFN5c19lcnJvciBfIGFzIGUgLT5cbiAgICAgIGlmIGNvdW50ZXIgPj0gMTAwMCB0aGVuIHJhaXNlIGUgZWxzZSB0cnlfbmFtZSAoY291bnRlciArIDEpXG4gIGluIHRyeV9uYW1lIDBcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMDIgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQ29tcGxleCBudW1iZXJzICopXG5cbnR5cGUgdCA9IHsgcmU6IGZsb2F0OyBpbTogZmxvYXQgfVxuXG5sZXQgemVybyA9IHsgcmUgPSAwLjA7IGltID0gMC4wIH1cbmxldCBvbmUgPSB7IHJlID0gMS4wOyBpbSA9IDAuMCB9XG5sZXQgaSA9IHsgcmUgPSAwLjA7IGltID0gMS4wIH1cblxubGV0IGFkZCB4IHkgPSB7IHJlID0geC5yZSArLiB5LnJlOyBpbSA9IHguaW0gKy4geS5pbSB9XG5cbmxldCBzdWIgeCB5ID0geyByZSA9IHgucmUgLS4geS5yZTsgaW0gPSB4LmltIC0uIHkuaW0gfVxuXG5sZXQgbmVnIHggPSB7IHJlID0gLS4geC5yZTsgaW0gPSAtLiB4LmltIH1cblxubGV0IGNvbmogeCA9IHsgcmUgPSB4LnJlOyBpbSA9IC0uIHguaW0gfVxuXG5sZXQgbXVsIHggeSA9IHsgcmUgPSB4LnJlICouIHkucmUgLS4geC5pbSAqLiB5LmltO1xuICAgICAgICAgICAgICAgIGltID0geC5yZSAqLiB5LmltICsuIHguaW0gKi4geS5yZSB9XG5cbmxldCBkaXYgeCB5ID1cbiAgaWYgYWJzX2Zsb2F0IHkucmUgPj0gYWJzX2Zsb2F0IHkuaW0gdGhlblxuICAgIGxldCByID0geS5pbSAvLiB5LnJlIGluXG4gICAgbGV0IGQgPSB5LnJlICsuIHIgKi4geS5pbSBpblxuICAgIHsgcmUgPSAoeC5yZSArLiByICouIHguaW0pIC8uIGQ7XG4gICAgICBpbSA9ICh4LmltIC0uIHIgKi4geC5yZSkgLy4gZCB9XG4gIGVsc2VcbiAgICBsZXQgciA9IHkucmUgLy4geS5pbSBpblxuICAgIGxldCBkID0geS5pbSArLiByICouIHkucmUgaW5cbiAgICB7IHJlID0gKHIgKi4geC5yZSArLiB4LmltKSAvLiBkO1xuICAgICAgaW0gPSAociAqLiB4LmltIC0uIHgucmUpIC8uIGQgfVxuXG5sZXQgaW52IHggPSBkaXYgb25lIHhcblxubGV0IG5vcm0yIHggPSB4LnJlICouIHgucmUgKy4geC5pbSAqLiB4LmltXG5cbmxldCBub3JtIHggPVxuICAoKiBXYXRjaCBvdXQgZm9yIG92ZXJmbG93IGluIGNvbXB1dGluZyByZV4yICsgaW1eMiAqKVxuICBsZXQgciA9IGFic19mbG9hdCB4LnJlIGFuZCBpID0gYWJzX2Zsb2F0IHguaW0gaW5cbiAgaWYgciA9IDAuMCB0aGVuIGlcbiAgZWxzZSBpZiBpID0gMC4wIHRoZW4gclxuICBlbHNlIGlmIHIgPj0gaSB0aGVuXG4gICAgbGV0IHEgPSBpIC8uIHIgaW4gciAqLiBzcXJ0KDEuMCArLiBxICouIHEpXG4gIGVsc2VcbiAgICBsZXQgcSA9IHIgLy4gaSBpbiBpICouIHNxcnQoMS4wICsuIHEgKi4gcSlcblxubGV0IGFyZyB4ID0gYXRhbjIgeC5pbSB4LnJlXG5cbmxldCBwb2xhciBuIGEgPSB7IHJlID0gY29zIGEgKi4gbjsgaW0gPSBzaW4gYSAqLiBuIH1cblxubGV0IHNxcnQgeCA9XG4gIGlmIHgucmUgPSAwLjAgJiYgeC5pbSA9IDAuMCB0aGVuIHsgcmUgPSAwLjA7IGltID0gMC4wIH1cbiAgZWxzZSBiZWdpblxuICAgIGxldCByID0gYWJzX2Zsb2F0IHgucmUgYW5kIGkgPSBhYnNfZmxvYXQgeC5pbSBpblxuICAgIGxldCB3ID1cbiAgICAgIGlmIHIgPj0gaSB0aGVuIGJlZ2luXG4gICAgICAgIGxldCBxID0gaSAvLiByIGluXG4gICAgICAgIHNxcnQocikgKi4gc3FydCgwLjUgKi4gKDEuMCArLiBzcXJ0KDEuMCArLiBxICouIHEpKSlcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIGxldCBxID0gciAvLiBpIGluXG4gICAgICAgIHNxcnQoaSkgKi4gc3FydCgwLjUgKi4gKHEgKy4gc3FydCgxLjAgKy4gcSAqLiBxKSkpXG4gICAgICBlbmQgaW5cbiAgICBpZiB4LnJlID49IDAuMFxuICAgIHRoZW4geyByZSA9IHc7ICBpbSA9IDAuNSAqLiB4LmltIC8uIHcgfVxuICAgIGVsc2UgeyByZSA9IDAuNSAqLiBpIC8uIHc7ICBpbSA9IGlmIHguaW0gPj0gMC4wIHRoZW4gdyBlbHNlIC0uIHcgfVxuICBlbmRcblxubGV0IGV4cCB4ID1cbiAgbGV0IGUgPSBleHAgeC5yZSBpbiB7IHJlID0gZSAqLiBjb3MgeC5pbTsgaW0gPSBlICouIHNpbiB4LmltIH1cblxubGV0IGxvZyB4ID0geyByZSA9IGxvZyAobm9ybSB4KTsgaW0gPSBhdGFuMiB4LmltIHgucmUgfVxuXG5sZXQgcG93IHggeSA9IGV4cCAobXVsIHkgKGxvZyB4KSlcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICBCZW5vaXQgVmF1Z29uLCBFTlNUQSAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTQgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogUGFkZGluZyBwb3NpdGlvbi4gKilcbnR5cGUgcGFkdHkgPVxuICB8IExlZnQgICAoKiBUZXh0IGlzIGxlZnQganVzdGlmaWVkICgnLScgb3B0aW9uKS4gICAgICAgICAgICAgICAqKVxuICB8IFJpZ2h0ICAoKiBUZXh0IGlzIHJpZ2h0IGp1c3RpZmllZCAobm8gJy0nIG9wdGlvbikuICAgICAgICAgICAqKVxuICB8IFplcm9zICAoKiBUZXh0IGlzIHJpZ2h0IGp1c3RpZmllZCBieSB6ZXJvcyAoc2VlICcwJyBvcHRpb24pLiAqKVxuXG4oKioqKVxuXG4oKiBJbnRlZ2VyIGNvbnZlcnNpb24uICopXG50eXBlIGludF9jb252ID1cbiAgfCBJbnRfZCB8IEludF9wZCB8IEludF9zZCAgICAgICAgKCogICVkIHwgJStkIHwgJSBkICAqKVxuICB8IEludF9pIHwgSW50X3BpIHwgSW50X3NpICAgICAgICAoKiAgJWkgfCAlK2kgfCAlIGkgICopXG4gIHwgSW50X3ggfCBJbnRfQ3ggICAgICAgICAgICAgICAgICgqICAleCB8ICUjeCAgICAgICAgKilcbiAgfCBJbnRfWCB8IEludF9DWCAgICAgICAgICAgICAgICAgKCogICVYIHwgJSNYICAgICAgICAqKVxuICB8IEludF9vIHwgSW50X0NvICAgICAgICAgICAgICAgICAoKiAgJW8gfCAlI28gICAgICAgICopXG4gIHwgSW50X3UgICAgICAgICAgICAgICAgICAgICAgICAgICgqICAldSAgICAgICAgICAgICAgKilcblxuKCogRmxvYXQgY29udmVyc2lvbi4gKilcbnR5cGUgZmxvYXRfY29udiA9XG4gIHwgRmxvYXRfZiB8IEZsb2F0X3BmIHwgRmxvYXRfc2YgICgqICAlZiB8ICUrZiB8ICUgZiAgKilcbiAgfCBGbG9hdF9lIHwgRmxvYXRfcGUgfCBGbG9hdF9zZSAgKCogICVlIHwgJStlIHwgJSBlICAqKVxuICB8IEZsb2F0X0UgfCBGbG9hdF9wRSB8IEZsb2F0X3NFICAoKiAgJUUgfCAlK0UgfCAlIEUgICopXG4gIHwgRmxvYXRfZyB8IEZsb2F0X3BnIHwgRmxvYXRfc2cgICgqICAlZyB8ICUrZyB8ICUgZyAgKilcbiAgfCBGbG9hdF9HIHwgRmxvYXRfcEcgfCBGbG9hdF9zRyAgKCogICVHIHwgJStHIHwgJSBHICAqKVxuICB8IEZsb2F0X0YgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJUYgICAgICAgICAgICAgICopXG4gIHwgRmxvYXRfaCB8IEZsb2F0X3BoIHwgRmxvYXRfc2ggICgqICAlaCB8ICUraCB8ICUgaCAgKilcbiAgfCBGbG9hdF9IIHwgRmxvYXRfcEggfCBGbG9hdF9zSCAgKCogICVIIHwgJStIIHwgJSBIICAqKVxuXG4oKioqKVxuXG4oKiBDaGFyIHNldHMgKHNlZSAlWy4uLl0pIGFyZSBiaXRtYXBzIGltcGxlbWVudGVkIGFzIDMyLWNoYXIgc3RyaW5ncy4gKilcbnR5cGUgY2hhcl9zZXQgPSBzdHJpbmdcblxuKCoqKilcblxuKCogQ291bnRlciB1c2VkIGluIFNjYW5mLiAqKVxudHlwZSBjb3VudGVyID1cbiAgfCBMaW5lX2NvdW50ZXIgICAgICgqICAlbCAgICAgICopXG4gIHwgQ2hhcl9jb3VudGVyICAgICAoKiAgJW4gICAgICAqKVxuICB8IFRva2VuX2NvdW50ZXIgICAgKCogICVOLCAlTCAgKilcblxuKCoqKilcblxuKCogUGFkZGluZyBvZiBzdHJpbmdzIGFuZCBudW1iZXJzLiAqKVxudHlwZSAoJ2EsICdiKSBwYWRkaW5nID1cbiAgKCogTm8gcGFkZGluZyAoZXg6IFwiJWRcIikgKilcbiAgfCBOb19wYWRkaW5nICA6ICgnYSwgJ2EpIHBhZGRpbmdcbiAgKCogTGl0ZXJhbCBwYWRkaW5nIChleDogXCIlOGRcIikgKilcbiAgfCBMaXRfcGFkZGluZyA6IHBhZHR5ICogaW50IC0+ICgnYSwgJ2EpIHBhZGRpbmdcbiAgKCogUGFkZGluZyBhcyBleHRyYSBhcmd1bWVudCAoZXg6IFwiJSpkXCIpICopXG4gIHwgQXJnX3BhZGRpbmcgOiBwYWR0eSAtPiAoaW50IC0+ICdhLCAnYSkgcGFkZGluZ1xuXG4oKiBTb21lIGZvcm1hdHMsIHN1Y2ggYXMgJV9kLFxuICAgb25seSBhY2NlcHQgYW4gb3B0aW9uYWwgbnVtYmVyIGFzIHBhZGRpbmcgb3B0aW9uIChubyBleHRyYSBhcmd1bWVudCkgKilcbnR5cGUgcGFkX29wdGlvbiA9IGludCBvcHRpb25cblxuKCogUHJlY2lzaW9uIG9mIGZsb2F0cyBhbmQgJzAnLXBhZGRpbmcgb2YgaW50ZWdlcnMuICopXG50eXBlICgnYSwgJ2IpIHByZWNpc2lvbiA9XG4gICgqIE5vIHByZWNpc2lvbiAoZXg6IFwiJWZcIikgKilcbiAgfCBOb19wcmVjaXNpb24gOiAoJ2EsICdhKSBwcmVjaXNpb25cbiAgKCogTGl0ZXJhbCBwcmVjaXNpb24gKGV4OiBcIiUuM2ZcIikgKilcbiAgfCBMaXRfcHJlY2lzaW9uIDogaW50IC0+ICgnYSwgJ2EpIHByZWNpc2lvblxuICAoKiBQcmVjaXNpb24gYXMgZXh0cmEgYXJndW1lbnQgKGV4OiBcIiUuKmZcIikgKilcbiAgfCBBcmdfcHJlY2lzaW9uIDogKGludCAtPiAnYSwgJ2EpIHByZWNpc2lvblxuXG4oKiBTb21lIGZvcm1hdHMsIHN1Y2ggYXMgJV9mLFxuICAgb25seSBhY2NlcHQgYW4gb3B0aW9uYWwgbnVtYmVyIGFzIHByZWNpc2lvbiBvcHRpb24gKG5vIGV4dHJhIGFyZ3VtZW50KSAqKVxudHlwZSBwcmVjX29wdGlvbiA9IGludCBvcHRpb25cblxuKCogc2VlIHRoZSBDdXN0b20gZm9ybWF0IGNvbWJpbmF0b3IgKilcbnR5cGUgKCdhLCAnYiwgJ2MpIGN1c3RvbV9hcml0eSA9XG4gIHwgQ3VzdG9tX3plcm8gOiAoJ2EsIHN0cmluZywgJ2EpIGN1c3RvbV9hcml0eVxuICB8IEN1c3RvbV9zdWNjIDogKCdhLCAnYiwgJ2MpIGN1c3RvbV9hcml0eSAtPlxuICAgICgnYSwgJ3ggLT4gJ2IsICd4IC0+ICdjKSBjdXN0b21fYXJpdHlcblxuKCoqKilcblxuKCogICAgICAgIFJlbGF0aW9uYWwgZm9ybWF0IHR5cGVzXG5cbkluIHRoZSBmaXJzdCBmb3JtYXQrZ2FkdHMgaW1wbGVtZW50YXRpb24sIHRoZSB0eXBlIGZvciAlKC4uJSkgaW4gdGhlXG5mbXQgR0FEVCB3YXMgYXMgZm9sbG93czpcblxufCBGb3JtYXRfc3Vic3QgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgcGFkX29wdGlvbiAqICgnZDEsICdxMSwgJ2QyLCAncTIpIHJlYWRlcl9uYl91bmlmaWVyICpcbiAgICAoJ3gsICdiLCAnYywgJ2QxLCAncTEsICd1KSBmbXR0eSAqXG4gICAgKCd1LCAnYiwgJ2MsICdxMSwgJ2UxLCAnZikgZm10IC0+XG4gICAgICAoKCd4LCAnYiwgJ2MsICdkMiwgJ3EyLCAndSkgZm9ybWF0NiAtPiAneCwgJ2IsICdjLCAnZDEsICdlMSwgJ2YpIGZtdFxuXG5Ob3RpY2UgdGhhdCB0aGUgJ3UgcGFyYW1ldGVyIGluICdmIHBvc2l0aW9uIGluIHRoZSBmb3JtYXQgYXJndW1lbnRcbigoJ3gsIC4uLCAndSkgZm9ybWF0NiAtPiAuLikgaXMgZXF1YWwgdG8gdGhlICd1IHBhcmFtZXRlciBpbiAnYVxucG9zaXRpb24gaW4gdGhlIGZvcm1hdCB0YWlsICgoJ3UsIC4uLCAnZikgZm10KS4gVGhpcyBtZWFucyB0aGF0IHRoZVxudHlwZSBvZiB0aGUgZXhwZWN0ZWQgZm9ybWF0IHBhcmFtZXRlciBkZXBlbmRzIG9mIHdoZXJlIHRoZSAlKC4uLiUpXG5hcmUgaW4gdGhlIGZvcm1hdCBzdHJpbmc6XG5cbiAgIyBQcmludGYucHJpbnRmIFwiJSglKVwiXG4gIC0gOiAodW5pdCwgb3V0X2NoYW5uZWwsIHVuaXQsICdfYSwgJ19hLCB1bml0KVxuICAgICAgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZvcm1hdDYgLT4gdW5pdFxuICA9IDxmdW4+XG4gICMgUHJpbnRmLnByaW50ZiBcIiUoJSklZFwiXG4gIC0gOiAoaW50IC0+IHVuaXQsIG91dF9jaGFubmVsLCB1bml0LCAnX2EsICdfYSwgaW50IC0+IHVuaXQpXG4gICAgICBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuZm9ybWF0NiAtPiBpbnQgLT4gdW5pdFxuICA9IDxmdW4+XG5cbk9uIHRoZSBjb250cmFyeSwgdGhlIGxlZ2FjeSB0eXBlciBnaXZlcyBhIGNsZXZlciB0eXBlIHRoYXQgZG9lcyBub3RcbmRlcGVuZCBvbiB0aGUgcG9zaXRpb24gb2YgJSguLiUpIGluIHRoZSBmb3JtYXQgc3RyaW5nLiBGb3IgZXhhbXBsZSxcbiUoJSkgd2lsbCBoYXZlIHRoZSBwb2x5bW9ycGhpYyB0eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKTogaXQgY2FuXG5iZSBjb25jYXRlbmF0ZWQgdG8gYW55IGZvcm1hdCB0eXBlLCBhbmQgb25seSBlbmZvcmNlcyB0aGUgY29uc3RyYWludFxudGhhdCBpdHMgJ2EgYW5kICdmIHBhcmFtZXRlcnMgYXJlIGVxdWFsIChubyBmb3JtYXQgYXJndW1lbnRzKSBhbmQgJ2RcbmFuZCAnZSBhcmUgZXF1YWwgKG5vIHJlYWRlciBhcmd1bWVudCkuXG5cblRoZSB3ZWFrZW5pbmcgb2YgdGhpcyBwYXJhbWV0ZXIgdHlwZSBpbiB0aGUgR0FEVCB2ZXJzaW9uIGJyb2tlIHVzZXJcbmNvZGUgKGluIGZhY3QgaXQgZXNzZW50aWFsbHkgbWFkZSAlKC4uLiUpIHVudXNhYmxlIGV4Y2VwdCBhdCB0aGUgbGFzdFxucG9zaXRpb24gb2YgYSBmb3JtYXQpLiBJbiBwYXJ0aWN1bGFyLCB0aGUgZm9sbG93aW5nIHdvdWxkIG5vdCB3b3JrXG5hbnltb3JlOlxuXG4gIGZ1biBzZXAgLT5cbiAgICBGb3JtYXQucHJpbnRmIFwiZm9vJSglKWJhciUoJSliYXpcIiBzZXAgc2VwXG5cbkFzIHRoZSB0eXBlLWNoZWNrZXIgd291bGQgcmVxdWlyZSB0d28gKmluY29tcGF0aWJsZSogdHlwZXMgZm9yIHRoZSAlKCUpXG5pbiBkaWZmZXJlbnQgcG9zaXRpb25zLlxuXG5UaGUgc29sdXRpb24gdG8gcmVnYWluIGEgZ2VuZXJhbCB0eXBlIGZvciAlKC4uJSkgaXMgdG8gZ2VuZXJhbGl6ZSB0aGlzXG50ZWNobmlxdWUsIG5vdCBvbmx5IG9uIHRoZSAnZCwgJ2UgcGFyYW1ldGVycywgYnV0IG9uIGFsbCBzaXhcbnBhcmFtZXRlcnMgb2YgYSBmb3JtYXQ6IHdlIGludHJvZHVjZSBhIFwicmVsYXRpb25hbFwiIHR5cGVcbiAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbndob3NlIHZhbHVlcyBhcmUgcHJvb2ZzIHRoYXQgKCdhMSwgLi4sICdmMSkgYW5kICgnYTIsIC4uLCAnZjIpIG1vcmFsbHlcbmNvcnJlc3BvbmQgdG8gdGhlIHNhbWUgZm9ybWF0IHR5cGU6ICdhMSBpcyBvYnRhaW5lZCBmcm9tICdmMSwnYjEsJ2MxXG5pbiB0aGUgZXhhY3Qgc2FtZSB3YXkgdGhhdCAnYTIgaXMgb2J0YWluZWQgZnJvbSAnZjIsJ2IyLCdjMiwgZXRjLlxuXG5Gb3IgZXhhbXBsZSwgdGhlIHJlbGF0aW9uIGJldHdlZW4gdHdvIGZvcm1hdCB0eXBlcyBiZWdpbm5pbmcgd2l0aCBhIENoYXJcbnBhcmFtZXRlciBpcyBhcyBmb2xsb3dzOlxuXG58IENoYXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYyAgKilcbiAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgKGNoYXIgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgY2hhciAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcblxuSW4gdGhlIGdlbmVyYWwgY2FzZSwgdGhlIHRlcm0gc3RydWN0dXJlIG9mIGZtdHR5X3JlbCBpcyAoYWxtb3N0WzFdKVxuaXNvbW9ycGhpYyB0byB0aGUgZm10dHkgb2YgdGhlIHByZXZpb3VzIGltcGxlbWVudGF0aW9uOiBldmVyeVxuY29uc3RydWN0b3IgaXMgcmUtcmVhZCB3aXRoIGEgYmluYXJ5LCByZWxhdGlvbmFsIHR5cGUsIGluc3RlYWQgb2YgdGhlXG5wcmV2aW91cyB1bmFyeSB0eXBpbmcuIGZtdHR5IGNhbiB0aGVuIGJlIHJlLWRlZmluZWQgYXMgdGhlIGRpYWdvbmFsIG9mXG5mbXR0eV9yZWw6XG5cbiAgdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgPVxuICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmLFxuICAgICAgICAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eV9yZWxcblxuT25jZSB3ZSBoYXZlIHRoaXMgZm10dHlfcmVsIHR5cGUgaW4gcGxhY2UsIHdlIGNhbiBnaXZlIHRoZSBtb3JlXG5nZW5lcmFsIHR5cGUgdG8gJSguLi4lKTpcblxufCBGb3JtYXRfc3Vic3QgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgcGFkX29wdGlvbiAqXG4gICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICdnMiwgJ2IsICdjLCAnajIsICdkLCAnYSkgZm10dHlfcmVsICpcbiAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMiwgJ2IsICdjLCAnajIsICdlLCAnZikgZm10XG5cbldlIGFjY2VwdCBhbnkgZm9ybWF0ICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NikgKHRoaXMgaXNcbmNvbXBsZXRlbHkgdW5yZWxhdGVkIHRvIHRoZSB0eXBlIG9mIHRoZSBjdXJyZW50IGZvcm1hdCksIGJ1dCBhbHNvXG5yZXF1aXJlIGEgcHJvb2YgdGhhdCB0aGlzIGZvcm1hdCBpcyBpbiByZWxhdGlvbiB0byBhbm90aGVyIGZvcm1hdCB0aGF0XG5pcyBjb25jYXRlbmFibGUgdG8gdGhlIGZvcm1hdCB0YWlsLiBXaGVuIGV4ZWN1dGluZyBhICUoLi4uJSkgZm9ybWF0XG4oaW4gY2FtbGludGVybmFsRm9ybWF0Lm1sOm1ha2VfcHJpbnRmIG9yIHNjYW5mLm1sOm1ha2Vfc2NhbmYpLCB3ZVxudHJhbnN0eXBlIHRoZSBmb3JtYXQgYWxvbmcgdGhpcyByZWxhdGlvbiB1c2luZyB0aGUgJ3JlY2FzdCcgZnVuY3Rpb25cbnRvIHRyYW5zcG9zZSBiZXR3ZWVuIHJlbGF0ZWQgZm9ybWF0IHR5cGVzLlxuXG4gIHZhbCByZWNhc3QgOlxuICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSkgZm10XG4gIC0+ICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIC0+ICgnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXRcblxuTk9URSBbMV06IHRoZSB0eXBpbmcgb2YgRm9ybWF0X3N1YnN0X3R5IHJlcXVpcmVzIG5vdCBvbmUgZm9ybWF0IHR5cGUsIGJ1dFxudHdvLCBvbmUgdG8gZXN0YWJsaXNoIHRoZSBsaW5rIGJldHdlZW4gdGhlIGZvcm1hdCBhcmd1bWVudCBhbmQgdGhlXG5maXJzdCBzaXggcGFyYW1ldGVycywgYW5kIHRoZSBvdGhlciBmb3IgdGhlIGxpbmsgYmV0d2VlbiB0aGUgZm9ybWF0XG5hcmd1bWVudCBhbmQgdGhlIGxhc3Qgc2l4IHBhcmFtZXRlcnMuXG5cbnwgRm9ybWF0X3N1YnN0X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUoLi4uJSkgKilcbiAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgJ2cxLCAnYjEsICdjMSwgJ2oxLCAnZDEsICdhMSkgZm10dHlfcmVsICpcbiAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgJ2cyLCAnYjIsICdjMiwgJ2oyLCAnZDIsICdhMikgZm10dHlfcmVsICpcbiAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2UxLCAnZjEsXG4gICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMiwgJ2IyLCAnYzIsICdqMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG5XaGVuIHdlIGdlbmVyYXRlIGEgZm9ybWF0IEFTVCwgd2UgZ2VuZXJhdGUgZXhhY3RseSB0aGUgc2FtZSB3aXRuZXNzXG5mb3IgYm90aCByZWxhdGlvbnMsIGFuZCB0aGUgd2l0bmVzcy1jb252ZXJzaW9uIGZ1bmN0aW9ucyBpblxuY2FtbGludGVybmFsRm9ybWF0IGRvIHJlbHkgb24gdGhpcyBpbnZhcmlhbnQuIEZvciBleGFtcGxlLCB0aGVcbmZ1bmN0aW9uIHRoYXQgcHJvdmVzIHRoYXQgdGhlIHJlbGF0aW9uIGlzIHRyYW5zaXRpdmVcblxuICB2YWwgdHJhbnMgOlxuICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICAtPiAoJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMixcbiAgICAgICdhMywgJ2IzLCAnYzMsICdkMywgJ2UzLCAnZjMpIGZtdHR5X3JlbFxuICAtPiAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICdhMywgJ2IzLCAnYzMsICdkMywgJ2UzLCAnZjMpIGZtdHR5X3JlbFxuXG5kb2VzIGFzc3VtZSB0aGF0IHRoZSB0d28gaW5wdXRzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSB0ZXJtIHN0cnVjdHVyZVxuKGFuZCBpcyBvbmx5IGV2ZXJ5IHVzZWQgZm9yIGFyZ3VtZW50IHdpdG5lc3NlcyBvZiB0aGVcbkZvcm1hdF9zdWJzdF90eSBjb25zdHJ1Y3RvcikuXG4qKVxuXG4oKiBUeXBlIG9mIGEgYmxvY2sgdXNlZCBieSB0aGUgRm9ybWF0IHByZXR0eS1wcmludGVyLiAqKVxudHlwZSBibG9ja190eXBlID1cbiAgfCBQcF9oYm94ICAgKCogSG9yaXpvbnRhbCBibG9jayBubyBsaW5lIGJyZWFraW5nICopXG4gIHwgUHBfdmJveCAgICgqIFZlcnRpY2FsIGJsb2NrIGVhY2ggYnJlYWsgbGVhZHMgdG8gYSBuZXcgbGluZSAqKVxuICB8IFBwX2h2Ym94ICAoKiBIb3Jpem9udGFsLXZlcnRpY2FsIGJsb2NrOiBzYW1lIGFzIHZib3gsIGV4Y2VwdCBpZiB0aGlzIGJsb2NrXG4gICAgICAgICAgICAgICAgIGlzIHNtYWxsIGVub3VnaCB0byBmaXQgb24gYSBzaW5nbGUgbGluZSAqKVxuICB8IFBwX2hvdmJveCAoKiBIb3Jpem9udGFsIG9yIFZlcnRpY2FsIGJsb2NrOiBicmVha3MgbGVhZCB0byBuZXcgbGluZVxuICAgICAgICAgICAgICAgICBvbmx5IHdoZW4gbmVjZXNzYXJ5IHRvIHByaW50IHRoZSBjb250ZW50IG9mIHRoZSBibG9jayAqKVxuICB8IFBwX2JveCAgICAoKiBIb3Jpem9udGFsIG9yIEluZGVudCBibG9jazogYnJlYWtzIGxlYWQgdG8gbmV3IGxpbmVcbiAgICAgICAgICAgICAgICAgb25seSB3aGVuIG5lY2Vzc2FyeSB0byBwcmludCB0aGUgY29udGVudCBvZiB0aGUgYmxvY2ssIG9yXG4gICAgICAgICAgICAgICAgIHdoZW4gaXQgbGVhZHMgdG8gYSBuZXcgaW5kZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgbGluZSAqKVxuICB8IFBwX2ZpdHMgICAoKiBJbnRlcm5hbCB1c2FnZTogd2hlbiBhIGJsb2NrIGZpdHMgb24gYSBzaW5nbGUgbGluZSAqKVxuXG4oKiBGb3JtYXR0aW5nIGVsZW1lbnQgdXNlZCBieSB0aGUgRm9ybWF0IHByZXR0eS1wcmludGVyLiAqKVxudHlwZSBmb3JtYXR0aW5nX2xpdCA9XG4gIHwgQ2xvc2VfYm94ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBdICAgKilcbiAgfCBDbG9zZV90YWcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQH0gICAqKVxuICB8IEJyZWFrIG9mIHN0cmluZyAqIGludCAqIGludCAgICAgICAgICAoKiBALCB8IEAgIHwgQDsgfCBAOzw+ICopXG4gIHwgRkZsdXNoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEA/ICAgKilcbiAgfCBGb3JjZV9uZXdsaW5lICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQFxcbiAgKilcbiAgfCBGbHVzaF9uZXdsaW5lICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQC4gICAqKVxuICB8IE1hZ2ljX3NpemUgb2Ygc3RyaW5nICogaW50ICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAPG4+ICopXG4gIHwgRXNjYXBlZF9hdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBAICAgKilcbiAgfCBFc2NhcGVkX3BlcmNlbnQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQCUlICAqKVxuICB8IFNjYW5faW5kaWMgb2YgY2hhciAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAWCAgICopXG5cbigqIEZvcm1hdHRpbmcgZWxlbWVudCB1c2VkIGJ5IHRoZSBGb3JtYXQgcHJldHR5LXByaW50ZXIuICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXR0aW5nX2dlbiA9XG4gIHwgT3Blbl90YWcgOiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPiAgICAgICgqIEB7ICAgKilcbiAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0dGluZ19nZW5cbiAgfCBPcGVuX2JveCA6ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+ICAgICAgKCogQFsgICAqKVxuICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXR0aW5nX2dlblxuXG4oKioqKVxuXG4oKiBMaXN0IG9mIGZvcm1hdCB0eXBlIGVsZW1lbnRzLiAqKVxuKCogSW4gcGFydGljdWxhciB1c2VkIHRvIHJlcHJlc2VudCAlKC4uLiUpIGFuZCAley4uLiV9IGNvbnRlbnRzLiAqKVxuYW5kICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSA9XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmLFxuICAgICAgJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHlfcmVsXG5hbmQgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCA9XG4gIHwgQ2hhcl90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVjICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoY2hhciAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGNoYXIgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgU3RyaW5nX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVzICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoc3RyaW5nIC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgc3RyaW5nIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IEludF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlZCAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGludCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGludCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBJbnQzMl90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWxkICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChpbnQzMiAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGludDMyIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IE5hdGl2ZWludF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlbmQgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKG5hdGl2ZWludCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIG5hdGl2ZWludCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBJbnQ2NF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJUxkICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChpbnQ2NCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGludDY0IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IEZsb2F0X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlZiAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGZsb2F0IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgZmxvYXQgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgQm9vbF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVCICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoYm9vbCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGJvb2wgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG5cbiAgfCBGb3JtYXRfYXJnX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXsuLi4lfSAqKVxuICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZtdHR5ICpcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMilcbiAgICAgICAgICAgZm10dHlfcmVsXG4gIHwgRm9ybWF0X3N1YnN0X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUoLi4uJSkgKilcbiAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsLFxuICAgICAgICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2QxLCAnYTEpIGZtdHR5X3JlbCAqXG4gICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgICAnZzIsICdiMiwgJ2MyLCAnajIsICdkMiwgJ2EyKSBmbXR0eV9yZWwgKlxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2cxLCAnYjEsICdjMSwgJ2oxLCAnZTEsICdmMSxcbiAgICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzIsICdiMiwgJ2MyLCAnajIsICdlMiwgJ2YyKVxuICAgICAgICAgICBmbXR0eV9yZWxcblxuICAoKiBQcmludGYgYW5kIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3RvcnMuICopXG4gIHwgQWxwaGFfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVhICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoKCdiMSAtPiAneCAtPiAnYzEpIC0+ICd4IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgKCdiMiAtPiAneCAtPiAnYzIpIC0+ICd4IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IFRoZXRhX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAldCAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnYjEgLT4gJ2MxKSAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICgnYjIgLT4gJ2MyKSAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBBbnlfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFVzZWQgZm9yIGN1c3RvbSBmb3JtYXRzICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgneCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICd4IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG4gICgqIFNjYW5mIHNwZWNpZmljIGNvbnN0cnVjdG9yLiAqKVxuICB8IFJlYWRlcl90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlciAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCd4IC0+ICdhMSwgJ2IxLCAnYzEsICgnYjEgLT4gJ3gpIC0+ICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ3ggLT4gJ2EyLCAnYjIsICdjMiwgKCdiMiAtPiAneCkgLT4gJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfciAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICgnYjEgLT4gJ3gpIC0+ICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgKCdiMiAtPiAneCkgLT4gJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG5cbiAgfCBFbmRfb2ZfZm10dHkgOlxuICAgICAgKCdmMSwgJ2IxLCAnYzEsICdkMSwgJ2QxLCAnZjEsXG4gICAgICAgJ2YyLCAnYjIsICdjMiwgJ2QyLCAnZDIsICdmMikgZm10dHlfcmVsXG5cbigqKiopXG5cbigqIExpc3Qgb2YgZm9ybWF0IGVsZW1lbnRzLiAqKVxuYW5kICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgPVxuICB8IENoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVjICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgIChjaGFyIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IENhbWxfY2hhciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVDICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgIChjaGFyIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IFN0cmluZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVzICopXG4gICAgICAoJ3gsIHN0cmluZyAtPiAnYSkgcGFkZGluZyAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IENhbWxfc3RyaW5nIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVTICopXG4gICAgICAoJ3gsIHN0cmluZyAtPiAnYSkgcGFkZGluZyAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEludCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBpbnQgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBJbnQzMiA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlbFtkaXhYdW9dICopXG4gICAgICBpbnRfY29udiAqICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksIGludDMyIC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgTmF0aXZlaW50IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJW5bZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBuYXRpdmVpbnQgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBJbnQ2NCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlTFtkaXhYdW9dICopXG4gICAgICBpbnRfY29udiAqICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksIGludDY0IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgRmxvYXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJVtmZUVnR0ZdICopXG4gICAgICBmbG9hdF9jb252ICogKCd4LCAneSkgcGFkZGluZyAqICgneSwgZmxvYXQgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBCb29sIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlW2JCXSAqKVxuICAgICAgKCd4LCBib29sIC0+ICdhKSBwYWRkaW5nICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgRmx1c2ggOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSEgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuXG4gIHwgU3RyaW5nX2xpdGVyYWwgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogYWJjICopXG4gICAgICBzdHJpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBDaGFyX2xpdGVyYWwgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiB4ICopXG4gICAgICBjaGFyICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgfCBGb3JtYXRfYXJnIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAley4uLiV9ICopXG4gICAgICBwYWRfb3B0aW9uICogKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZtdHR5ICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEZvcm1hdF9zdWJzdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUoLi4uJSkgKilcbiAgICAgIHBhZF9vcHRpb24gKlxuICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICAgJ2cyLCAnYiwgJ2MsICdqMiwgJ2QsICdhKSBmbXR0eV9yZWwgKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMiwgJ2IsICdjLCAnajIsICdlLCAnZikgZm10XG5cbiAgKCogUHJpbnRmIGFuZCBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3IuICopXG4gIHwgQWxwaGEgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWEgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCgnYiAtPiAneCAtPiAnYykgLT4gJ3ggLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgVGhldGEgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXQgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCgnYiAtPiAnYykgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgKCogRm9ybWF0IHNwZWNpZmljIGNvbnN0cnVjdG9yOiAqKVxuICB8IEZvcm1hdHRpbmdfbGl0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBfICopXG4gICAgICBmb3JtYXR0aW5nX2xpdCAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEZvcm1hdHRpbmdfZ2VuIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAXyAqKVxuICAgICAgKCdhMSwgJ2IsICdjLCAnZDEsICdlMSwgJ2YxKSBmb3JtYXR0aW5nX2dlbiAqXG4gICAgICAoJ2YxLCAnYiwgJ2MsICdlMSwgJ2UyLCAnZjIpIGZtdCAtPiAoJ2ExLCAnYiwgJ2MsICdkMSwgJ2UyLCAnZjIpIGZtdFxuXG4gICgqIFNjYW5mIHNwZWNpZmljIGNvbnN0cnVjdG9yczogKilcbiAgfCBSZWFkZXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlciAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3ggLT4gJ2EsICdiLCAnYywgKCdiIC0+ICd4KSAtPiAnZCwgJ2UsICdmKSBmbXRcbiAgfCBTY2FuX2NoYXJfc2V0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlWy4uLl0gKilcbiAgICAgIHBhZF9vcHRpb24gKiBjaGFyX3NldCAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKHN0cmluZyAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBTY2FuX2dldF9jb3VudGVyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlW25sTkxdICopXG4gICAgICBjb3VudGVyICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoaW50IC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IFNjYW5fbmV4dF9jaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUwYyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgKGNoYXIgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgSWdub3JlZF9wYXJhbSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV8gKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ3ksICd4KSBpZ25vcmVkICogKCd4LCAnYiwgJ2MsICd5LCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgKCogQ3VzdG9tIHByaW50aW5nIGZvcm1hdCAoUFIjNjQ1MiwgR1BSIzE0MClcblxuICAgICBXZSBpbmNsdWRlIGEgdHlwZSBDdXN0b20gb2YgXCJjdXN0b20gY29udmVydGVyc1wiLCB3aGVyZSBhblxuICAgICBhcmJpdHJhcnkgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gY29udmVydCBvbmUgb3IgbW9yZVxuICAgICBhcmd1bWVudHMuIFRoZXJlIGlzIG5vIHN5bnRheCBmb3IgY3VzdG9tIGNvbnZlcnRlcnMsIGl0IGlzIG9ubHlcbiAgICAgaW50ZW5kZWQgZm9yIGN1c3RvbSBwcm9jZXNzb3JzIHRoYXQgd2lzaCB0byByZWx5IG9uIHRoZVxuICAgICBzdGRsaWItZGVmaW5lZCBmb3JtYXQgR0FEVHMuXG5cbiAgICAgRm9yIGluc3RhbmNlIGEgcHJlLXByb2Nlc3NvciBjb3VsZCBjaG9vc2UgdG8gaW50ZXJwcmV0IHN0cmluZ3NcbiAgICAgcHJlZml4ZWQgd2l0aCBbXCIhXCJdIGFzIGZvcm1hdCBzdHJpbmdzIHdoZXJlIFsle3sgLi4uIH19XSBpc1xuICAgICBhIHNwZWNpYWwgZm9ybSB0byBwYXNzIGEgdG9fc3RyaW5nIGZ1bmN0aW9uLCBzbyB0aGF0IG9uZSBjb3VsZFxuICAgICB3cml0ZTpcblxuICAgICB7W1xuICAgICAgIHR5cGUgdCA9IHsgeCA6IGludDsgeSA6IGludCB9XG5cbiAgICAgICBsZXQgc3RyaW5nX29mX3QgdCA9IFByaW50Zi5zcHJpbnRmIFwieyB4ID0gJWQ7IHkgPSAlZCB9XCIgdC54IHQueVxuXG4gICAgICAgUHJpbnRmLnByaW50ZiAhXCJ0ID0gJXt7c3RyaW5nX29mX3R9fVwiIHsgeCA9IDQyOyB5ID0gNDIgfVxuICAgICBdfVxuICAqKVxuICB8IEN1c3RvbSA6XG4gICAgICAoJ2EsICd4LCAneSkgY3VzdG9tX2FyaXR5ICogKHVuaXQgLT4gJ3gpICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgKCd5LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuXG4gICgqIGVuZCBvZiBhIGZvcm1hdCBzcGVjaWZpY2F0aW9uICopXG4gIHwgRW5kX29mX2Zvcm1hdCA6XG4gICAgICAgICgnZiwgJ2IsICdjLCAnZSwgJ2UsICdmKSBmbXRcblxuKCoqKilcblxuKCogVHlwZSBmb3IgaWdub3JlZCBwYXJhbWV0ZXJzIChzZWUgXCIlX1wiKS4gKilcbmFuZCAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgaWdub3JlZCA9XG4gIHwgSWdub3JlZF9jaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9jICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfY2FtbF9jaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfQyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX3N0cmluZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX3MgKilcbiAgICAgIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX1MgKilcbiAgICAgIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2ludCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX2QgKilcbiAgICAgIGludF9jb252ICogcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfaW50MzIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfbGQgKilcbiAgICAgIGludF9jb252ICogcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfbmF0aXZlaW50IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfbmQgKilcbiAgICAgIGludF9jb252ICogcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfaW50NjQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfTGQgKilcbiAgICAgIGludF9jb252ICogcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfZmxvYXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfZiAqKVxuICAgICAgcGFkX29wdGlvbiAqIHByZWNfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9ib29sIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9CICopXG4gICAgICBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV97Li4uJX0gKilcbiAgICAgIHBhZF9vcHRpb24gKiAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm10dHkgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlXyguLi4lKSAqKVxuICAgICAgcGFkX29wdGlvbiAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgaWdub3JlZFxuICB8IElnbm9yZWRfcmVhZGVyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfciAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICgnYiAtPiAneCkgLT4gJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfWy4uLl0gKilcbiAgICAgIHBhZF9vcHRpb24gKiBjaGFyX3NldCAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfW25sTkxdICopXG4gICAgICBjb3VudGVyIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV8wYyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcblxuYW5kICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2ID1cbiAgRm9ybWF0IG9mICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgKiBzdHJpbmdcblxubGV0IHJlYyBlcmFzZV9yZWwgOiB0eXBlIGEgYiBjIGQgZSBmIGcgaCBpIGogayBsIC5cbiAgKGEsIGIsIGMsIGQsIGUsIGYsXG4gICBnLCBoLCBpLCBqLCBrLCBsKSBmbXR0eV9yZWwgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5XG49IGZ1bmN0aW9uXG4gIHwgQ2hhcl90eSByZXN0IC0+XG4gICAgQ2hhcl90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgU3RyaW5nX3R5IHJlc3QgLT5cbiAgICBTdHJpbmdfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEludF90eSByZXN0IC0+XG4gICAgSW50X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBJbnQzMl90eSByZXN0IC0+XG4gICAgSW50MzJfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEludDY0X3R5IHJlc3QgLT5cbiAgICBJbnQ2NF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgLT5cbiAgICBOYXRpdmVpbnRfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEZsb2F0X3R5IHJlc3QgLT5cbiAgICBGbG9hdF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgQm9vbF90eSByZXN0IC0+XG4gICAgQm9vbF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgRm9ybWF0X2FyZ190eSAodHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHksIGVyYXNlX3JlbCByZXN0KVxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCBfdHkyLCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTEsIGVyYXNlX3JlbCByZXN0KVxuICB8IEFscGhhX3R5IHJlc3QgLT5cbiAgICBBbHBoYV90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgVGhldGFfdHkgcmVzdCAtPlxuICAgIFRoZXRhX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBBbnlfdHkgcmVzdCAtPlxuICAgIEFueV90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgUmVhZGVyX3R5IHJlc3QgLT5cbiAgICBSZWFkZXJfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QgLT5cbiAgICBJZ25vcmVkX3JlYWRlcl90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgRW5kX29mX2ZtdHR5IC0+IEVuZF9vZl9mbXR0eVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCB0eXBlIGNvbmNhdGVuYXRpb24gKilcblxuKCogQ29uY2F0ZW5hdGUgdHdvIGZvcm1hdCB0eXBlcy4gKilcbigqIFVzZWQgYnk6XG4gICAqIHJlYWRlcl9uYl91bmlmaWVyX29mX2ZtdHR5IHRvIGNvdW50IHJlYWRlcnMgaW4gYW4gZm10dHksXG4gICAqIFNjYW5mLnRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgdG8gZXh0cmFjdCByZWFkZXJzIGluc2lkZSAlKC4uLiUpLFxuICAgKiBDYW1saW50ZXJuYWxGb3JtYXQuZm10dHlfb2ZfaWdub3JlZF9mb3JtYXQgdG8gZXh0cmFjdCBmb3JtYXQgdHlwZS4gKilcblxuKCpcbmxldCByZWMgY29uY2F0X2ZtdHR5IDogdHlwZSBhIGIgYyBkIGUgZiBnIGggLlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPlxuICAgIChmLCBiLCBjLCBlLCBnLCBoKSBmbXR0eSAtPlxuICAgIChhLCBiLCBjLCBkLCBnLCBoKSBmbXR0eSA9XG4qKVxubGV0IHJlYyBjb25jYXRfZm10dHkgOlxuICB0eXBlIGExIGIxIGMxIGQxIGUxIGYxXG4gICAgICAgYTIgYjIgYzIgZDIgZTIgZjJcbiAgICAgICBnMSBqMSBnMiBqMlxuICAuXG4gICAgKGcxLCBiMSwgYzEsIGoxLCBkMSwgYTEsXG4gICAgIGcyLCBiMiwgYzIsIGoyLCBkMiwgYTIpIGZtdHR5X3JlbCAtPlxuICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgICBhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eV9yZWwgLT5cbiAgICAoZzEsIGIxLCBjMSwgajEsIGUxLCBmMSxcbiAgICAgZzIsIGIyLCBjMiwgajIsIGUyLCBmMikgZm10dHlfcmVsID1cbmZ1biBmbXR0eTEgZm10dHkyIC0+IG1hdGNoIGZtdHR5MSB3aXRoXG4gIHwgQ2hhcl90eSByZXN0IC0+XG4gICAgQ2hhcl90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IFN0cmluZ190eSByZXN0IC0+XG4gICAgU3RyaW5nX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgSW50X3R5IHJlc3QgLT5cbiAgICBJbnRfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBJbnQzMl90eSByZXN0IC0+XG4gICAgSW50MzJfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPlxuICAgIE5hdGl2ZWludF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEludDY0X3R5IHJlc3QgLT5cbiAgICBJbnQ2NF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEZsb2F0X3R5IHJlc3QgLT5cbiAgICBGbG9hdF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEJvb2xfdHkgcmVzdCAtPlxuICAgIEJvb2xfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBBbHBoYV90eSByZXN0IC0+XG4gICAgQWxwaGFfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBUaGV0YV90eSByZXN0IC0+XG4gICAgVGhldGFfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBBbnlfdHkgcmVzdCAtPlxuICAgIEFueV90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IFJlYWRlcl90eSByZXN0IC0+XG4gICAgUmVhZGVyX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPlxuICAgIElnbm9yZWRfcmVhZGVyX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgRm9ybWF0X2FyZ190eSAodHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHksIGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBFbmRfb2ZfZm10dHkgLT4gZm10dHkyXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXQgY29uY2F0ZW5hdGlvbiAqKVxuXG4oKiBDb25jYXRlbmF0ZSB0d28gZm9ybWF0cy4gKilcbmxldCByZWMgY29uY2F0X2ZtdCA6IHR5cGUgYSBiIGMgZCBlIGYgZyBoIC5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgKGYsIGIsIGMsIGUsIGcsIGgpIGZtdCAtPlxuICAgIChhLCBiLCBjLCBkLCBnLCBoKSBmbXQgPVxuZnVuIGZtdDEgZm10MiAtPiBtYXRjaCBmbXQxIHdpdGhcbiAgfCBTdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBTdHJpbmcgKHBhZCwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBDYW1sX3N0cmluZyAocGFkLCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBJbnQgKGljb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEludDMyIChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIEludDMyIChpY29udiwgcGFkLCBwcmVjLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgQ2hhciAocmVzdCkgLT5cbiAgICBDaGFyIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBDYW1sX2NoYXIgcmVzdCAtPlxuICAgIENhbWxfY2hhciAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQm9vbCAocGFkLCByZXN0KSAtPlxuICAgIEJvb2wgKHBhZCwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQWxwaGEgcmVzdCAtPlxuICAgIEFscGhhIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBUaGV0YSByZXN0IC0+XG4gICAgVGhldGEgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEN1c3RvbSAoYXJpdHksIGYsIHJlc3QpIC0+XG4gICAgQ3VzdG9tIChhcml0eSwgZiwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgUmVhZGVyIHJlc3QgLT5cbiAgICBSZWFkZXIgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEZsdXNoIHJlc3QgLT5cbiAgICBGbHVzaCAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSAtPlxuICAgIFN0cmluZ19saXRlcmFsIChzdHIsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IENoYXJfbGl0ZXJhbCAoY2hyLCByZXN0KSAtPlxuICAgIENoYXJfbGl0ZXJhbCAgIChjaHIsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgRm9ybWF0X2FyZyAocGFkLCBmbXR0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnICAgKHBhZCwgZm10dHksIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEZvcm1hdF9zdWJzdCAocGFkLCBmbXR0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfc3Vic3QgKHBhZCwgZm10dHksIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgcmVzdCkgLT5cbiAgICBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCByZXN0KSAtPlxuICAgIFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IFNjYW5fbmV4dF9jaGFyIChyZXN0KSAtPlxuICAgIFNjYW5fbmV4dF9jaGFyIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpIC0+XG4gICAgSWdub3JlZF9wYXJhbSAoaWduLCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCByZXN0KSAtPlxuICAgIEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBGb3JtYXR0aW5nX2dlbiAoZm10aW5nX2dlbiwgcmVzdCkgLT5cbiAgICBGb3JtYXR0aW5nX2dlbiAoZm10aW5nX2dlbiwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBFbmRfb2ZfZm9ybWF0IC0+XG4gICAgZm10MlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiB0eXBlICdhIG9wdGlvbiA9IE5vbmUgfCBTb21lIG9mICdhICopXG5cbigqIEV4Y2VwdGlvbnMgKilcblxuZXh0ZXJuYWwgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgOiBzdHJpbmcgLT4gJ2EgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWVcIlxuXG5sZXQgKCkgPVxuICAoKiBmb3IgYXNtcnVuL2ZhaWwuYyAqKVxuICByZWdpc3Rlcl9uYW1lZF92YWx1ZSBcIlBlcnZhc2l2ZXMuYXJyYXlfYm91bmRfZXJyb3JcIlxuICAgIChJbnZhbGlkX2FyZ3VtZW50IFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKVxuXG5cbmV4dGVybmFsIHJhaXNlIDogZXhuIC0+ICdhID0gXCIlcmFpc2VcIlxuZXh0ZXJuYWwgcmFpc2Vfbm90cmFjZSA6IGV4biAtPiAnYSA9IFwiJXJhaXNlX25vdHJhY2VcIlxuXG5sZXQgZmFpbHdpdGggcyA9IHJhaXNlKEZhaWx1cmUgcylcbmxldCBpbnZhbGlkX2FyZyBzID0gcmFpc2UoSW52YWxpZF9hcmd1bWVudCBzKVxuXG5leGNlcHRpb24gRXhpdFxuXG4oKiBDb21wb3NpdGlvbiBvcGVyYXRvcnMgKilcblxuZXh0ZXJuYWwgKCB8PiApIDogJ2EgLT4gKCdhIC0+ICdiKSAtPiAnYiA9IFwiJXJldmFwcGx5XCJcbmV4dGVybmFsICggQEAgKSA6ICgnYSAtPiAnYikgLT4gJ2EgLT4gJ2IgPSBcIiVhcHBseVwiXG5cbigqIERlYnVnZ2luZyAqKVxuXG5leHRlcm5hbCBfX0xPQ19fIDogc3RyaW5nID0gXCIlbG9jX0xPQ1wiXG5leHRlcm5hbCBfX0ZJTEVfXyA6IHN0cmluZyA9IFwiJWxvY19GSUxFXCJcbmV4dGVybmFsIF9fTElORV9fIDogaW50ID0gXCIlbG9jX0xJTkVcIlxuZXh0ZXJuYWwgX19NT0RVTEVfXyA6IHN0cmluZyA9IFwiJWxvY19NT0RVTEVcIlxuZXh0ZXJuYWwgX19QT1NfXyA6IHN0cmluZyAqIGludCAqIGludCAqIGludCA9IFwiJWxvY19QT1NcIlxuXG5leHRlcm5hbCBfX0xPQ19PRl9fIDogJ2EgLT4gc3RyaW5nICogJ2EgPSBcIiVsb2NfTE9DXCJcbmV4dGVybmFsIF9fTElORV9PRl9fIDogJ2EgLT4gaW50ICogJ2EgPSBcIiVsb2NfTElORVwiXG5leHRlcm5hbCBfX1BPU19PRl9fIDogJ2EgLT4gKHN0cmluZyAqIGludCAqIGludCAqIGludCkgKiAnYSA9IFwiJWxvY19QT1NcIlxuXG4oKiBDb21wYXJpc29ucyAqKVxuXG5leHRlcm5hbCAoID0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVlcXVhbFwiXG5leHRlcm5hbCAoIDw+ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbm90ZXF1YWxcIlxuZXh0ZXJuYWwgKCA8ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbGVzc3RoYW5cIlxuZXh0ZXJuYWwgKCA+ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZ3JlYXRlcnRoYW5cIlxuZXh0ZXJuYWwgKCA8PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWxlc3NlcXVhbFwiXG5leHRlcm5hbCAoID49ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZ3JlYXRlcmVxdWFsXCJcbmV4dGVybmFsIGNvbXBhcmUgOiAnYSAtPiAnYSAtPiBpbnQgPSBcIiVjb21wYXJlXCJcblxubGV0IG1pbiB4IHkgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxubGV0IG1heCB4IHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuXG5leHRlcm5hbCAoID09ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZXFcIlxuZXh0ZXJuYWwgKCAhPSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJW5vdGVxXCJcblxuKCogQm9vbGVhbiBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIG5vdCA6IGJvb2wgLT4gYm9vbCA9IFwiJWJvb2xub3RcIlxuZXh0ZXJuYWwgKCAmICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVhbmRcIlxuZXh0ZXJuYWwgKCAmJiApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1YW5kXCJcbmV4dGVybmFsICggb3IgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdW9yXCJcbmV4dGVybmFsICggfHwgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdW9yXCJcblxuKCogSW50ZWdlciBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsICggfi0gKSA6IGludCAtPiBpbnQgPSBcIiVuZWdpbnRcIlxuZXh0ZXJuYWwgKCB+KyApIDogaW50IC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHN1Y2MgOiBpbnQgLT4gaW50ID0gXCIlc3VjY2ludFwiXG5leHRlcm5hbCBwcmVkIDogaW50IC0+IGludCA9IFwiJXByZWRpbnRcIlxuZXh0ZXJuYWwgKCArICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFkZGludFwiXG5leHRlcm5hbCAoIC0gKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlc3ViaW50XCJcbmV4dGVybmFsICggKiApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtdWxpbnRcIlxuZXh0ZXJuYWwgKCAvICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWRpdmludFwiXG5leHRlcm5hbCAoIG1vZCApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtb2RpbnRcIlxuXG5sZXQgYWJzIHggPSBpZiB4ID49IDAgdGhlbiB4IGVsc2UgLXhcblxuZXh0ZXJuYWwgKCBsYW5kICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFuZGludFwiXG5leHRlcm5hbCAoIGxvciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVvcmludFwiXG5leHRlcm5hbCAoIGx4b3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIleG9yaW50XCJcblxubGV0IGxub3QgeCA9IHggbHhvciAoLTEpXG5cbmV4dGVybmFsICggbHNsICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzbGludFwiXG5leHRlcm5hbCAoIGxzciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc3JpbnRcIlxuZXh0ZXJuYWwgKCBhc3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYXNyaW50XCJcblxubGV0IG1heF9pbnQgPSAoLTEpIGxzciAxXG5sZXQgbWluX2ludCA9IG1heF9pbnQgKyAxXG5cbigqIEZsb2F0aW5nLXBvaW50IG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgKCB+LS4gKSA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlbmVnZmxvYXRcIlxuZXh0ZXJuYWwgKCB+Ky4gKSA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgKCArLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVhZGRmbG9hdFwiXG5leHRlcm5hbCAoIC0uICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJXN1YmZsb2F0XCJcbmV4dGVybmFsICggKi4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlbXVsZmxvYXRcIlxuZXh0ZXJuYWwgKCAvLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVkaXZmbG9hdFwiXG5leHRlcm5hbCAoICoqICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9wb3dlcl9mbG9hdFwiIFwicG93XCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGV4cCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cF9mbG9hdFwiIFwiZXhwXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGV4cG0xIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwbTFfZmxvYXRcIiBcImNhbWxfZXhwbTFcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Fjb3NfZmxvYXRcIiBcImFjb3NcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2FzaW5fZmxvYXRcIiBcImFzaW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW5fZmxvYXRcIiBcImF0YW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbjIgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuMl9mbG9hdFwiIFwiYXRhbjJcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgaHlwb3QgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICAgICAgICAgICAgICAgPSBcImNhbWxfaHlwb3RfZmxvYXRcIiBcImNhbWxfaHlwb3RcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zX2Zsb2F0XCIgXCJjb3NcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc2hfZmxvYXRcIiBcImNvc2hcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nX2Zsb2F0XCIgXCJsb2dcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nMTAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cxMF9mbG9hdFwiIFwibG9nMTBcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nMXAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cxcF9mbG9hdFwiIFwiY2FtbF9sb2cxcFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzaW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5fZmxvYXRcIiBcInNpblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzaW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc2luaF9mbG9hdFwiIFwic2luaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzcXJ0IDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc3FydF9mbG9hdFwiIFwic3FydFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0YW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5fZmxvYXRcIiBcInRhblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0YW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdGFuaF9mbG9hdFwiIFwidGFuaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjZWlsIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY2VpbF9mbG9hdFwiIFwiY2VpbFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbG9vciA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Zsb29yX2Zsb2F0XCIgXCJmbG9vclwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhYnNfZmxvYXQgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJWFic2Zsb2F0XCJcbmV4dGVybmFsIGNvcHlzaWduIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2NvcHlzaWduX2Zsb2F0XCIgXCJjYW1sX2NvcHlzaWduXCJcbiAgICAgICAgICAgICAgICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBtb2RfZmxvYXQgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbW9kX2Zsb2F0XCIgXCJmbW9kXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZyZXhwIDogZmxvYXQgLT4gZmxvYXQgKiBpbnQgPSBcImNhbWxfZnJleHBfZmxvYXRcIlxuZXh0ZXJuYWwgbGRleHAgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gKGludCBbQHVudGFnZ2VkXSkgLT4gKGZsb2F0IFtAdW5ib3hlZF0pID1cbiAgXCJjYW1sX2xkZXhwX2Zsb2F0XCIgXCJjYW1sX2xkZXhwX2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbW9kZiA6IGZsb2F0IC0+IGZsb2F0ICogZmxvYXQgPSBcImNhbWxfbW9kZl9mbG9hdFwiXG5leHRlcm5hbCBmbG9hdCA6IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0b2ZpbnRcIlxuZXh0ZXJuYWwgZmxvYXRfb2ZfaW50IDogaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRvZmludFwiXG5leHRlcm5hbCB0cnVuY2F0ZSA6IGZsb2F0IC0+IGludCA9IFwiJWludG9mZmxvYXRcIlxuZXh0ZXJuYWwgaW50X29mX2Zsb2F0IDogZmxvYXQgLT4gaW50ID0gXCIlaW50b2ZmbG9hdFwiXG5leHRlcm5hbCBmbG9hdF9vZl9iaXRzIDogaW50NjQgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c1wiIFwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzX3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxubGV0IGluZmluaXR5ID1cbiAgZmxvYXRfb2ZfYml0cyAweDdGX0YwXzAwXzAwXzAwXzAwXzAwXzAwTFxubGV0IG5lZ19pbmZpbml0eSA9XG4gIGZsb2F0X29mX2JpdHMgMHhGRl9GMF8wMF8wMF8wMF8wMF8wMF8wMExcbmxldCBuYW4gPVxuICBmbG9hdF9vZl9iaXRzIDB4N0ZfRjBfMDBfMDBfMDBfMDBfMDBfMDFMXG5sZXQgbWF4X2Zsb2F0ID1cbiAgZmxvYXRfb2ZfYml0cyAweDdGX0VGX0ZGX0ZGX0ZGX0ZGX0ZGX0ZGTFxubGV0IG1pbl9mbG9hdCA9XG4gIGZsb2F0X29mX2JpdHMgMHgwMF8xMF8wMF8wMF8wMF8wMF8wMF8wMExcbmxldCBlcHNpbG9uX2Zsb2F0ID1cbiAgZmxvYXRfb2ZfYml0cyAweDNDX0IwXzAwXzAwXzAwXzAwXzAwXzAwTFxuXG50eXBlIGZwY2xhc3MgPVxuICAgIEZQX25vcm1hbFxuICB8IEZQX3N1Ym5vcm1hbFxuICB8IEZQX3plcm9cbiAgfCBGUF9pbmZpbml0ZVxuICB8IEZQX25hblxuZXh0ZXJuYWwgY2xhc3NpZnlfZmxvYXQgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gZnBjbGFzcyA9XG4gIFwiY2FtbF9jbGFzc2lmeV9mbG9hdFwiIFwiY2FtbF9jbGFzc2lmeV9mbG9hdF91bmJveGVkXCIgW0BAbm9hbGxvY11cblxuKCogU3RyaW5nIGFuZCBieXRlIHNlcXVlbmNlIG9wZXJhdGlvbnMgLS0gbW9yZSBpbiBtb2R1bGVzIFN0cmluZyBhbmQgQnl0ZXMgKilcblxuZXh0ZXJuYWwgc3RyaW5nX2xlbmd0aCA6IHN0cmluZyAtPiBpbnQgPSBcIiVzdHJpbmdfbGVuZ3RoXCJcbmV4dGVybmFsIGJ5dGVzX2xlbmd0aCA6IGJ5dGVzIC0+IGludCA9IFwiJWJ5dGVzX2xlbmd0aFwiXG5leHRlcm5hbCBieXRlc19jcmVhdGUgOiBpbnQgLT4gYnl0ZXMgPSBcImNhbWxfY3JlYXRlX2J5dGVzXCJcbmV4dGVybmFsIHN0cmluZ19ibGl0IDogc3RyaW5nIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfc3RyaW5nXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIGJ5dGVzX2JsaXQgOiBieXRlcyAtPiBpbnQgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9ibGl0X2J5dGVzXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIGJ5dGVzX3Vuc2FmZV90b19zdHJpbmcgOiBieXRlcyAtPiBzdHJpbmcgPSBcIiVieXRlc190b19zdHJpbmdcIlxuXG5sZXQgKCBeICkgczEgczIgPVxuICBsZXQgbDEgPSBzdHJpbmdfbGVuZ3RoIHMxIGFuZCBsMiA9IHN0cmluZ19sZW5ndGggczIgaW5cbiAgbGV0IHMgPSBieXRlc19jcmVhdGUgKGwxICsgbDIpIGluXG4gIHN0cmluZ19ibGl0IHMxIDAgcyAwIGwxO1xuICBzdHJpbmdfYmxpdCBzMiAwIHMgbDEgbDI7XG4gIGJ5dGVzX3Vuc2FmZV90b19zdHJpbmcgc1xuXG4oKiBDaGFyYWN0ZXIgb3BlcmF0aW9ucyAtLSBtb3JlIGluIG1vZHVsZSBDaGFyICopXG5cbmV4dGVybmFsIGludF9vZl9jaGFyIDogY2hhciAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCB1bnNhZmVfY2hhcl9vZl9pbnQgOiBpbnQgLT4gY2hhciA9IFwiJWlkZW50aXR5XCJcbmxldCBjaGFyX29mX2ludCBuID1cbiAgaWYgbiA8IDAgfHwgbiA+IDI1NSB0aGVuIGludmFsaWRfYXJnIFwiY2hhcl9vZl9pbnRcIiBlbHNlIHVuc2FmZV9jaGFyX29mX2ludCBuXG5cbigqIFVuaXQgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBpZ25vcmUgOiAnYSAtPiB1bml0ID0gXCIlaWdub3JlXCJcblxuKCogUGFpciBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIGZzdCA6ICdhICogJ2IgLT4gJ2EgPSBcIiVmaWVsZDBcIlxuZXh0ZXJuYWwgc25kIDogJ2EgKiAnYiAtPiAnYiA9IFwiJWZpZWxkMVwiXG5cbigqIFJlZmVyZW5jZXMgKilcblxudHlwZSAnYSByZWYgPSB7IG11dGFibGUgY29udGVudHMgOiAnYSB9XG5leHRlcm5hbCByZWYgOiAnYSAtPiAnYSByZWYgPSBcIiVtYWtlbXV0YWJsZVwiXG5leHRlcm5hbCAoICEgKSA6ICdhIHJlZiAtPiAnYSA9IFwiJWZpZWxkMFwiXG5leHRlcm5hbCAoIDo9ICkgOiAnYSByZWYgLT4gJ2EgLT4gdW5pdCA9IFwiJXNldGZpZWxkMFwiXG5leHRlcm5hbCBpbmNyIDogaW50IHJlZiAtPiB1bml0ID0gXCIlaW5jclwiXG5leHRlcm5hbCBkZWNyIDogaW50IHJlZiAtPiB1bml0ID0gXCIlZGVjclwiXG5cbigqIFJlc3VsdCB0eXBlICopXG5cbnR5cGUgKCdhLCdiKSByZXN1bHQgPSBPayBvZiAnYSB8IEVycm9yIG9mICdiXG5cbigqIFN0cmluZyBjb252ZXJzaW9uIGZ1bmN0aW9ucyAqKVxuXG5leHRlcm5hbCBmb3JtYXRfaW50IDogc3RyaW5nIC0+IGludCAtPiBzdHJpbmcgPSBcImNhbWxfZm9ybWF0X2ludFwiXG5leHRlcm5hbCBmb3JtYXRfZmxvYXQgOiBzdHJpbmcgLT4gZmxvYXQgLT4gc3RyaW5nID0gXCJjYW1sX2Zvcm1hdF9mbG9hdFwiXG5cbmxldCBzdHJpbmdfb2ZfYm9vbCBiID1cbiAgaWYgYiB0aGVuIFwidHJ1ZVwiIGVsc2UgXCJmYWxzZVwiXG5sZXQgYm9vbF9vZl9zdHJpbmcgPSBmdW5jdGlvblxuICB8IFwidHJ1ZVwiIC0+IHRydWVcbiAgfCBcImZhbHNlXCIgLT4gZmFsc2VcbiAgfCBfIC0+IGludmFsaWRfYXJnIFwiYm9vbF9vZl9zdHJpbmdcIlxuXG5sZXQgYm9vbF9vZl9zdHJpbmdfb3B0ID0gZnVuY3Rpb25cbiAgfCBcInRydWVcIiAtPiBTb21lIHRydWVcbiAgfCBcImZhbHNlXCIgLT4gU29tZSBmYWxzZVxuICB8IF8gLT4gTm9uZVxuXG5sZXQgc3RyaW5nX29mX2ludCBuID1cbiAgZm9ybWF0X2ludCBcIiVkXCIgblxuXG5leHRlcm5hbCBpbnRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludCA9IFwiY2FtbF9pbnRfb2Zfc3RyaW5nXCJcblxubGV0IGludF9vZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBwcm92aWRlIHRoaXMgZGlyZWN0bHkgYXMgYSBub24tcmFpc2luZyBwcmltaXRpdmUuICopXG4gIHRyeSBTb21lIChpbnRfb2Zfc3RyaW5nIHMpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxuZXh0ZXJuYWwgc3RyaW5nX2dldCA6IHN0cmluZyAtPiBpbnQgLT4gY2hhciA9IFwiJXN0cmluZ19zYWZlX2dldFwiXG5cbmxldCB2YWxpZF9mbG9hdF9sZXhlbSBzID1cbiAgbGV0IGwgPSBzdHJpbmdfbGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPj0gbCB0aGVuIHMgXiBcIi5cIiBlbHNlXG4gICAgbWF0Y2ggc3RyaW5nX2dldCBzIGkgd2l0aFxuICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPiBsb29wIChpICsgMSlcbiAgICB8IF8gLT4gc1xuICBpblxuICBsb29wIDBcblxubGV0IHN0cmluZ19vZl9mbG9hdCBmID0gdmFsaWRfZmxvYXRfbGV4ZW0gKGZvcm1hdF9mbG9hdCBcIiUuMTJnXCIgZilcblxuZXh0ZXJuYWwgZmxvYXRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGZsb2F0ID0gXCJjYW1sX2Zsb2F0X29mX3N0cmluZ1wiXG5cbmxldCBmbG9hdF9vZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBwcm92aWRlIHRoaXMgZGlyZWN0bHkgYXMgYSBub24tcmFpc2luZyBwcmltaXRpdmUuICopXG4gIHRyeSBTb21lIChmbG9hdF9vZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG4oKiBMaXN0IG9wZXJhdGlvbnMgLS0gbW9yZSBpbiBtb2R1bGUgTGlzdCAqKVxuXG5sZXQgcmVjICggQCApIGwxIGwyID1cbiAgbWF0Y2ggbDEgd2l0aFxuICAgIFtdIC0+IGwyXG4gIHwgaGQgOjogdGwgLT4gaGQgOjogKHRsIEAgbDIpXG5cbigqIEkvTyBvcGVyYXRpb25zICopXG5cbnR5cGUgaW5fY2hhbm5lbFxudHlwZSBvdXRfY2hhbm5lbFxuXG5leHRlcm5hbCBvcGVuX2Rlc2NyaXB0b3Jfb3V0IDogaW50IC0+IG91dF9jaGFubmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXRcIlxuZXh0ZXJuYWwgb3Blbl9kZXNjcmlwdG9yX2luIDogaW50IC0+IGluX2NoYW5uZWwgPSBcImNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luXCJcblxubGV0IHN0ZGluID0gb3Blbl9kZXNjcmlwdG9yX2luIDBcbmxldCBzdGRvdXQgPSBvcGVuX2Rlc2NyaXB0b3Jfb3V0IDFcbmxldCBzdGRlcnIgPSBvcGVuX2Rlc2NyaXB0b3Jfb3V0IDJcblxuKCogR2VuZXJhbCBvdXRwdXQgZnVuY3Rpb25zICopXG5cbnR5cGUgb3Blbl9mbGFnID1cbiAgICBPcGVuX3Jkb25seSB8IE9wZW5fd3Jvbmx5IHwgT3Blbl9hcHBlbmRcbiAgfCBPcGVuX2NyZWF0IHwgT3Blbl90cnVuYyB8IE9wZW5fZXhjbFxuICB8IE9wZW5fYmluYXJ5IHwgT3Blbl90ZXh0IHwgT3Blbl9ub25ibG9ja1xuXG5leHRlcm5hbCBvcGVuX2Rlc2MgOiBzdHJpbmcgLT4gb3Blbl9mbGFnIGxpc3QgLT4gaW50IC0+IGludCA9IFwiY2FtbF9zeXNfb3BlblwiXG5cbmV4dGVybmFsIHNldF9vdXRfY2hhbm5lbF9uYW1lOiBvdXRfY2hhbm5lbCAtPiBzdHJpbmcgLT4gdW5pdCA9XG4gIFwiY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lXCJcblxubGV0IG9wZW5fb3V0X2dlbiBtb2RlIHBlcm0gbmFtZSA9XG4gIGxldCBjID0gb3Blbl9kZXNjcmlwdG9yX291dChvcGVuX2Rlc2MgbmFtZSBtb2RlIHBlcm0pIGluXG4gIHNldF9vdXRfY2hhbm5lbF9uYW1lIGMgbmFtZTtcbiAgY1xuXG5sZXQgb3Blbl9vdXQgbmFtZSA9XG4gIG9wZW5fb3V0X2dlbiBbT3Blbl93cm9ubHk7IE9wZW5fY3JlYXQ7IE9wZW5fdHJ1bmM7IE9wZW5fdGV4dF0gMG82NjYgbmFtZVxuXG5sZXQgb3Blbl9vdXRfYmluIG5hbWUgPVxuICBvcGVuX291dF9nZW4gW09wZW5fd3Jvbmx5OyBPcGVuX2NyZWF0OyBPcGVuX3RydW5jOyBPcGVuX2JpbmFyeV0gMG82NjYgbmFtZVxuXG5leHRlcm5hbCBmbHVzaCA6IG91dF9jaGFubmVsIC0+IHVuaXQgPSBcImNhbWxfbWxfZmx1c2hcIlxuXG5leHRlcm5hbCBvdXRfY2hhbm5lbHNfbGlzdCA6IHVuaXQgLT4gb3V0X2NoYW5uZWwgbGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfb3V0X2NoYW5uZWxzX2xpc3RcIlxuXG5sZXQgZmx1c2hfYWxsICgpID1cbiAgbGV0IHJlYyBpdGVyID0gZnVuY3Rpb25cbiAgICAgIFtdIC0+ICgpXG4gICAgfCBhOjpsIC0+XG4gICAgICAgIGJlZ2luIHRyeVxuICAgICAgICAgICAgZmx1c2ggYVxuICAgICAgICB3aXRoIFN5c19lcnJvciBfIC0+XG4gICAgICAgICAgKCkgKCogaWdub3JlIGNoYW5uZWxzIGNsb3NlZCBkdXJpbmcgYSBwcmVjZWRpbmcgZmx1c2guICopXG4gICAgICAgIGVuZDtcbiAgICAgICAgaXRlciBsXG4gIGluIGl0ZXIgKG91dF9jaGFubmVsc19saXN0ICgpKVxuXG5leHRlcm5hbCB1bnNhZmVfb3V0cHV0IDogb3V0X2NoYW5uZWwgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX291dHB1dF9ieXRlc1wiXG5leHRlcm5hbCB1bnNhZmVfb3V0cHV0X3N0cmluZyA6IG91dF9jaGFubmVsIC0+IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX291dHB1dFwiXG5cbmV4dGVybmFsIG91dHB1dF9jaGFyIDogb3V0X2NoYW5uZWwgLT4gY2hhciAtPiB1bml0ID0gXCJjYW1sX21sX291dHB1dF9jaGFyXCJcblxubGV0IG91dHB1dF9ieXRlcyBvYyBzID1cbiAgdW5zYWZlX291dHB1dCBvYyBzIDAgKGJ5dGVzX2xlbmd0aCBzKVxuXG5sZXQgb3V0cHV0X3N0cmluZyBvYyBzID1cbiAgdW5zYWZlX291dHB1dF9zdHJpbmcgb2MgcyAwIChzdHJpbmdfbGVuZ3RoIHMpXG5cbmxldCBvdXRwdXQgb2MgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGJ5dGVzX2xlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJvdXRwdXRcIlxuICBlbHNlIHVuc2FmZV9vdXRwdXQgb2MgcyBvZnMgbGVuXG5cbmxldCBvdXRwdXRfc3Vic3RyaW5nIG9jIHMgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBzdHJpbmdfbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIm91dHB1dF9zdWJzdHJpbmdcIlxuICBlbHNlIHVuc2FmZV9vdXRwdXRfc3RyaW5nIG9jIHMgb2ZzIGxlblxuXG5leHRlcm5hbCBvdXRwdXRfYnl0ZSA6IG91dF9jaGFubmVsIC0+IGludCAtPiB1bml0ID0gXCJjYW1sX21sX291dHB1dF9jaGFyXCJcbmV4dGVybmFsIG91dHB1dF9iaW5hcnlfaW50IDogb3V0X2NoYW5uZWwgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfbWxfb3V0cHV0X2ludFwiXG5cbmV4dGVybmFsIG1hcnNoYWxfdG9fY2hhbm5lbCA6IG91dF9jaGFubmVsIC0+ICdhIC0+IHVuaXQgbGlzdCAtPiB1bml0XG4gICAgID0gXCJjYW1sX291dHB1dF92YWx1ZVwiXG5sZXQgb3V0cHV0X3ZhbHVlIGNoYW4gdiA9IG1hcnNoYWxfdG9fY2hhbm5lbCBjaGFuIHYgW11cblxuZXh0ZXJuYWwgc2Vla19vdXQgOiBvdXRfY2hhbm5lbCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX291dFwiXG5leHRlcm5hbCBwb3Nfb3V0IDogb3V0X2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX3Bvc19vdXRcIlxuZXh0ZXJuYWwgb3V0X2NoYW5uZWxfbGVuZ3RoIDogb3V0X2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZVwiXG5leHRlcm5hbCBjbG9zZV9vdXRfY2hhbm5lbCA6IG91dF9jaGFubmVsIC0+IHVuaXQgPSBcImNhbWxfbWxfY2xvc2VfY2hhbm5lbFwiXG5sZXQgY2xvc2Vfb3V0IG9jID0gZmx1c2ggb2M7IGNsb3NlX291dF9jaGFubmVsIG9jXG5sZXQgY2xvc2Vfb3V0X25vZXJyIG9jID1cbiAgKHRyeSBmbHVzaCBvYyB3aXRoIF8gLT4gKCkpO1xuICAodHJ5IGNsb3NlX291dF9jaGFubmVsIG9jIHdpdGggXyAtPiAoKSlcbmV4dGVybmFsIHNldF9iaW5hcnlfbW9kZV9vdXQgOiBvdXRfY2hhbm5lbCAtPiBib29sIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfc2V0X2JpbmFyeV9tb2RlXCJcblxuKCogR2VuZXJhbCBpbnB1dCBmdW5jdGlvbnMgKilcblxuZXh0ZXJuYWwgc2V0X2luX2NoYW5uZWxfbmFtZTogaW5fY2hhbm5lbCAtPiBzdHJpbmcgLT4gdW5pdCA9XG4gIFwiY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lXCJcblxubGV0IG9wZW5faW5fZ2VuIG1vZGUgcGVybSBuYW1lID1cbiAgbGV0IGMgPSBvcGVuX2Rlc2NyaXB0b3JfaW4ob3Blbl9kZXNjIG5hbWUgbW9kZSBwZXJtKSBpblxuICBzZXRfaW5fY2hhbm5lbF9uYW1lIGMgbmFtZTtcbiAgY1xuXG5sZXQgb3Blbl9pbiBuYW1lID1cbiAgb3Blbl9pbl9nZW4gW09wZW5fcmRvbmx5OyBPcGVuX3RleHRdIDAgbmFtZVxuXG5sZXQgb3Blbl9pbl9iaW4gbmFtZSA9XG4gIG9wZW5faW5fZ2VuIFtPcGVuX3Jkb25seTsgT3Blbl9iaW5hcnldIDAgbmFtZVxuXG5leHRlcm5hbCBpbnB1dF9jaGFyIDogaW5fY2hhbm5lbCAtPiBjaGFyID0gXCJjYW1sX21sX2lucHV0X2NoYXJcIlxuXG5leHRlcm5hbCB1bnNhZmVfaW5wdXQgOiBpbl9jaGFubmVsIC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gaW50XG4gICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfaW5wdXRcIlxuXG5sZXQgaW5wdXQgaWMgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGJ5dGVzX2xlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJpbnB1dFwiXG4gIGVsc2UgdW5zYWZlX2lucHV0IGljIHMgb2ZzIGxlblxuXG5sZXQgcmVjIHVuc2FmZV9yZWFsbHlfaW5wdXQgaWMgcyBvZnMgbGVuID1cbiAgaWYgbGVuIDw9IDAgdGhlbiAoKSBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSB1bnNhZmVfaW5wdXQgaWMgcyBvZnMgbGVuIGluXG4gICAgaWYgciA9IDBcbiAgICB0aGVuIHJhaXNlIEVuZF9vZl9maWxlXG4gICAgZWxzZSB1bnNhZmVfcmVhbGx5X2lucHV0IGljIHMgKG9mcyArIHIpIChsZW4gLSByKVxuICBlbmRcblxubGV0IHJlYWxseV9pbnB1dCBpYyBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gYnl0ZXNfbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcInJlYWxseV9pbnB1dFwiXG4gIGVsc2UgdW5zYWZlX3JlYWxseV9pbnB1dCBpYyBzIG9mcyBsZW5cblxubGV0IHJlYWxseV9pbnB1dF9zdHJpbmcgaWMgbGVuID1cbiAgbGV0IHMgPSBieXRlc19jcmVhdGUgbGVuIGluXG4gIHJlYWxseV9pbnB1dCBpYyBzIDAgbGVuO1xuICBieXRlc191bnNhZmVfdG9fc3RyaW5nIHNcblxuZXh0ZXJuYWwgaW5wdXRfc2Nhbl9saW5lIDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfaW5wdXRfc2Nhbl9saW5lXCJcblxubGV0IGlucHV0X2xpbmUgY2hhbiA9XG4gIGxldCByZWMgYnVpbGRfcmVzdWx0IGJ1ZiBwb3MgPSBmdW5jdGlvblxuICAgIFtdIC0+IGJ1ZlxuICB8IGhkIDo6IHRsIC0+XG4gICAgICBsZXQgbGVuID0gYnl0ZXNfbGVuZ3RoIGhkIGluXG4gICAgICBieXRlc19ibGl0IGhkIDAgYnVmIChwb3MgLSBsZW4pIGxlbjtcbiAgICAgIGJ1aWxkX3Jlc3VsdCBidWYgKHBvcyAtIGxlbikgdGwgaW5cbiAgbGV0IHJlYyBzY2FuIGFjY3UgbGVuID1cbiAgICBsZXQgbiA9IGlucHV0X3NjYW5fbGluZSBjaGFuIGluXG4gICAgaWYgbiA9IDAgdGhlbiBiZWdpbiAgICAgICAgICAgICAgICAgICAoKiBuID0gMDogd2UgYXJlIGF0IEVPRiAqKVxuICAgICAgbWF0Y2ggYWNjdSB3aXRoXG4gICAgICAgIFtdIC0+IHJhaXNlIEVuZF9vZl9maWxlXG4gICAgICB8IF8gIC0+IGJ1aWxkX3Jlc3VsdCAoYnl0ZXNfY3JlYXRlIGxlbikgbGVuIGFjY3VcbiAgICBlbmQgZWxzZSBpZiBuID4gMCB0aGVuIGJlZ2luICAgICAgICAgICgqIG4gPiAwOiBuZXdsaW5lIGZvdW5kIGluIGJ1ZmZlciAqKVxuICAgICAgbGV0IHJlcyA9IGJ5dGVzX2NyZWF0ZSAobiAtIDEpIGluXG4gICAgICBpZ25vcmUgKHVuc2FmZV9pbnB1dCBjaGFuIHJlcyAwIChuIC0gMSkpO1xuICAgICAgaWdub3JlIChpbnB1dF9jaGFyIGNoYW4pOyAgICAgICAgICAgKCogc2tpcCB0aGUgbmV3bGluZSAqKVxuICAgICAgbWF0Y2ggYWNjdSB3aXRoXG4gICAgICAgIFtdIC0+IHJlc1xuICAgICAgfCAgXyAtPiBsZXQgbGVuID0gbGVuICsgbiAtIDEgaW5cbiAgICAgICAgICAgICAgYnVpbGRfcmVzdWx0IChieXRlc19jcmVhdGUgbGVuKSBsZW4gKHJlcyA6OiBhY2N1KVxuICAgIGVuZCBlbHNlIGJlZ2luICAgICAgICAgICAgICAgICAgICAgICAgKCogbiA8IDA6IG5ld2xpbmUgbm90IGZvdW5kICopXG4gICAgICBsZXQgYmVnID0gYnl0ZXNfY3JlYXRlICgtbikgaW5cbiAgICAgIGlnbm9yZSh1bnNhZmVfaW5wdXQgY2hhbiBiZWcgMCAoLW4pKTtcbiAgICAgIHNjYW4gKGJlZyA6OiBhY2N1KSAobGVuIC0gbilcbiAgICBlbmRcbiAgaW4gYnl0ZXNfdW5zYWZlX3RvX3N0cmluZyAoc2NhbiBbXSAwKVxuXG5leHRlcm5hbCBpbnB1dF9ieXRlIDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfaW5wdXRfY2hhclwiXG5leHRlcm5hbCBpbnB1dF9iaW5hcnlfaW50IDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfaW5wdXRfaW50XCJcbmV4dGVybmFsIGlucHV0X3ZhbHVlIDogaW5fY2hhbm5lbCAtPiAnYSA9IFwiY2FtbF9pbnB1dF92YWx1ZVwiXG5leHRlcm5hbCBzZWVrX2luIDogaW5fY2hhbm5lbCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX2luXCJcbmV4dGVybmFsIHBvc19pbiA6IGluX2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX3Bvc19pblwiXG5leHRlcm5hbCBpbl9jaGFubmVsX2xlbmd0aCA6IGluX2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZVwiXG5leHRlcm5hbCBjbG9zZV9pbiA6IGluX2NoYW5uZWwgLT4gdW5pdCA9IFwiY2FtbF9tbF9jbG9zZV9jaGFubmVsXCJcbmxldCBjbG9zZV9pbl9ub2VyciBpYyA9ICh0cnkgY2xvc2VfaW4gaWMgd2l0aCBfIC0+ICgpKVxuZXh0ZXJuYWwgc2V0X2JpbmFyeV9tb2RlX2luIDogaW5fY2hhbm5lbCAtPiBib29sIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9zZXRfYmluYXJ5X21vZGVcIlxuXG4oKiBPdXRwdXQgZnVuY3Rpb25zIG9uIHN0YW5kYXJkIG91dHB1dCAqKVxuXG5sZXQgcHJpbnRfY2hhciBjID0gb3V0cHV0X2NoYXIgc3Rkb3V0IGNcbmxldCBwcmludF9zdHJpbmcgcyA9IG91dHB1dF9zdHJpbmcgc3Rkb3V0IHNcbmxldCBwcmludF9ieXRlcyBzID0gb3V0cHV0X2J5dGVzIHN0ZG91dCBzXG5sZXQgcHJpbnRfaW50IGkgPSBvdXRwdXRfc3RyaW5nIHN0ZG91dCAoc3RyaW5nX29mX2ludCBpKVxubGV0IHByaW50X2Zsb2F0IGYgPSBvdXRwdXRfc3RyaW5nIHN0ZG91dCAoc3RyaW5nX29mX2Zsb2F0IGYpXG5sZXQgcHJpbnRfZW5kbGluZSBzID1cbiAgb3V0cHV0X3N0cmluZyBzdGRvdXQgczsgb3V0cHV0X2NoYXIgc3Rkb3V0ICdcXG4nOyBmbHVzaCBzdGRvdXRcbmxldCBwcmludF9uZXdsaW5lICgpID0gb3V0cHV0X2NoYXIgc3Rkb3V0ICdcXG4nOyBmbHVzaCBzdGRvdXRcblxuKCogT3V0cHV0IGZ1bmN0aW9ucyBvbiBzdGFuZGFyZCBlcnJvciAqKVxuXG5sZXQgcHJlcnJfY2hhciBjID0gb3V0cHV0X2NoYXIgc3RkZXJyIGNcbmxldCBwcmVycl9zdHJpbmcgcyA9IG91dHB1dF9zdHJpbmcgc3RkZXJyIHNcbmxldCBwcmVycl9ieXRlcyBzID0gb3V0cHV0X2J5dGVzIHN0ZGVyciBzXG5sZXQgcHJlcnJfaW50IGkgPSBvdXRwdXRfc3RyaW5nIHN0ZGVyciAoc3RyaW5nX29mX2ludCBpKVxubGV0IHByZXJyX2Zsb2F0IGYgPSBvdXRwdXRfc3RyaW5nIHN0ZGVyciAoc3RyaW5nX29mX2Zsb2F0IGYpXG5sZXQgcHJlcnJfZW5kbGluZSBzID1cbiAgb3V0cHV0X3N0cmluZyBzdGRlcnIgczsgb3V0cHV0X2NoYXIgc3RkZXJyICdcXG4nOyBmbHVzaCBzdGRlcnJcbmxldCBwcmVycl9uZXdsaW5lICgpID0gb3V0cHV0X2NoYXIgc3RkZXJyICdcXG4nOyBmbHVzaCBzdGRlcnJcblxuKCogSW5wdXQgZnVuY3Rpb25zIG9uIHN0YW5kYXJkIGlucHV0ICopXG5cbmxldCByZWFkX2xpbmUgKCkgPSBmbHVzaCBzdGRvdXQ7IGlucHV0X2xpbmUgc3RkaW5cbmxldCByZWFkX2ludCAoKSA9IGludF9vZl9zdHJpbmcocmVhZF9saW5lKCkpXG5sZXQgcmVhZF9pbnRfb3B0ICgpID0gaW50X29mX3N0cmluZ19vcHQocmVhZF9saW5lKCkpXG5sZXQgcmVhZF9mbG9hdCAoKSA9IGZsb2F0X29mX3N0cmluZyhyZWFkX2xpbmUoKSlcbmxldCByZWFkX2Zsb2F0X29wdCAoKSA9IGZsb2F0X29mX3N0cmluZ19vcHQocmVhZF9saW5lKCkpXG5cbigqIE9wZXJhdGlvbnMgb24gbGFyZ2UgZmlsZXMgKilcblxubW9kdWxlIExhcmdlRmlsZSA9XG4gIHN0cnVjdFxuICAgIGV4dGVybmFsIHNlZWtfb3V0IDogb3V0X2NoYW5uZWwgLT4gaW50NjQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX291dF82NFwiXG4gICAgZXh0ZXJuYWwgcG9zX291dCA6IG91dF9jaGFubmVsIC0+IGludDY0ID0gXCJjYW1sX21sX3Bvc19vdXRfNjRcIlxuICAgIGV4dGVybmFsIG91dF9jaGFubmVsX2xlbmd0aCA6IG91dF9jaGFubmVsIC0+IGludDY0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZV82NFwiXG4gICAgZXh0ZXJuYWwgc2Vla19pbiA6IGluX2NoYW5uZWwgLT4gaW50NjQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX2luXzY0XCJcbiAgICBleHRlcm5hbCBwb3NfaW4gOiBpbl9jaGFubmVsIC0+IGludDY0ID0gXCJjYW1sX21sX3Bvc19pbl82NFwiXG4gICAgZXh0ZXJuYWwgaW5fY2hhbm5lbF9sZW5ndGggOiBpbl9jaGFubmVsIC0+IGludDY0ID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZV82NFwiXG4gIGVuZFxuXG4oKiBGb3JtYXRzICopXG5cbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDZcbiAgID0gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mb3JtYXQ2XG4gICA9IEZvcm1hdCBvZiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZtdFxuICAgICAgICAgICAgICAgKiBzdHJpbmdcblxudHlwZSAoJ2EsICdiLCAnYywgJ2QpIGZvcm1hdDQgPSAoJ2EsICdiLCAnYywgJ2MsICdjLCAnZCkgZm9ybWF0NlxuXG50eXBlICgnYSwgJ2IsICdjKSBmb3JtYXQgPSAoJ2EsICdiLCAnYywgJ2MpIGZvcm1hdDRcblxubGV0IHN0cmluZ19vZl9mb3JtYXQgKEZvcm1hdCAoX2ZtdCwgc3RyKSkgPSBzdHJcblxuZXh0ZXJuYWwgZm9ybWF0X29mX3N0cmluZyA6XG4gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT5cbiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA9IFwiJWlkZW50aXR5XCJcblxubGV0ICggXl4gKSAoRm9ybWF0IChmbXQxLCBzdHIxKSkgKEZvcm1hdCAoZm10Miwgc3RyMikpID1cbiAgRm9ybWF0IChDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuY29uY2F0X2ZtdCBmbXQxIGZtdDIsXG4gICAgICAgICAgc3RyMSBeIFwiJSxcIiBeIHN0cjIpXG5cbigqIE1pc2NlbGxhbmVvdXMgKilcblxuZXh0ZXJuYWwgc3lzX2V4aXQgOiBpbnQgLT4gJ2EgPSBcImNhbWxfc3lzX2V4aXRcIlxuXG5sZXQgZXhpdF9mdW5jdGlvbiA9IHJlZiBmbHVzaF9hbGxcblxubGV0IGF0X2V4aXQgZiA9XG4gIGxldCBnID0gIWV4aXRfZnVuY3Rpb24gaW5cbiAgZXhpdF9mdW5jdGlvbiA6PSAoZnVuICgpIC0+IGYoKTsgZygpKVxuXG5sZXQgZG9fYXRfZXhpdCAoKSA9ICghZXhpdF9mdW5jdGlvbikgKClcblxubGV0IGV4aXQgcmV0Y29kZSA9XG4gIGRvX2F0X2V4aXQgKCk7XG4gIHN5c19leGl0IHJldGNvZGVcblxubGV0IF8gPSByZWdpc3Rlcl9uYW1lZF92YWx1ZSBcIlBlcnZhc2l2ZXMuZG9fYXRfZXhpdFwiIGRvX2F0X2V4aXRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTGlzdCBvcGVyYXRpb25zICopXG5cbmxldCByZWMgbGVuZ3RoX2F1eCBsZW4gPSBmdW5jdGlvblxuICAgIFtdIC0+IGxlblxuICB8IF86OmwgLT4gbGVuZ3RoX2F1eCAobGVuICsgMSkgbFxuXG5sZXQgbGVuZ3RoIGwgPSBsZW5ndGhfYXV4IDAgbFxuXG5sZXQgY29ucyBhIGwgPSBhOjpsXG5cbmxldCBoZCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFpbHdpdGggXCJoZFwiXG4gIHwgYTo6XyAtPiBhXG5cbmxldCB0bCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFpbHdpdGggXCJ0bFwiXG4gIHwgXzo6bCAtPiBsXG5cbmxldCBudGggbCBuID1cbiAgaWYgbiA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkxpc3QubnRoXCIgZWxzZVxuICBsZXQgcmVjIG50aF9hdXggbCBuID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IGZhaWx3aXRoIFwibnRoXCJcbiAgICB8IGE6OmwgLT4gaWYgbiA9IDAgdGhlbiBhIGVsc2UgbnRoX2F1eCBsIChuLTEpXG4gIGluIG50aF9hdXggbCBuXG5cbmxldCBudGhfb3B0IGwgbiA9XG4gIGlmIG4gPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJMaXN0Lm50aFwiIGVsc2VcbiAgbGV0IHJlYyBudGhfYXV4IGwgbiA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBOb25lXG4gICAgfCBhOjpsIC0+IGlmIG4gPSAwIHRoZW4gU29tZSBhIGVsc2UgbnRoX2F1eCBsIChuLTEpXG4gIGluIG50aF9hdXggbCBuXG5cbmxldCBhcHBlbmQgPSAoQClcblxubGV0IHJlYyByZXZfYXBwZW5kIGwxIGwyID1cbiAgbWF0Y2ggbDEgd2l0aFxuICAgIFtdIC0+IGwyXG4gIHwgYSA6OiBsIC0+IHJldl9hcHBlbmQgbCAoYSA6OiBsMilcblxubGV0IHJldiBsID0gcmV2X2FwcGVuZCBsIFtdXG5cbmxldCByZWMgaW5pdF90YWlscmVjX2F1eCBhY2MgaSBuIGYgPVxuICBpZiBpID49IG4gdGhlbiBhY2NcbiAgZWxzZSBpbml0X3RhaWxyZWNfYXV4IChmIGkgOjogYWNjKSAoaSsxKSBuIGZcblxubGV0IHJlYyBpbml0X2F1eCBpIG4gZiA9XG4gIGlmIGkgPj0gbiB0aGVuIFtdXG4gIGVsc2VcbiAgICBsZXQgciA9IGYgaSBpblxuICAgIHIgOjogaW5pdF9hdXggKGkrMSkgbiBmXG5cbmxldCBpbml0IGxlbiBmID1cbiAgaWYgbGVuIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiTGlzdC5pbml0XCIgZWxzZVxuICBpZiBsZW4gPiAxMF8wMDAgdGhlbiByZXYgKGluaXRfdGFpbHJlY19hdXggW10gMCBsZW4gZilcbiAgZWxzZSBpbml0X2F1eCAwIGxlbiBmXG5cbmxldCByZWMgZmxhdHRlbiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW11cbiAgfCBsOjpyIC0+IGwgQCBmbGF0dGVuIHJcblxubGV0IGNvbmNhdCA9IGZsYXR0ZW5cblxubGV0IHJlYyBtYXAgZiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW11cbiAgfCBhOjpsIC0+IGxldCByID0gZiBhIGluIHIgOjogbWFwIGYgbFxuXG5sZXQgcmVjIG1hcGkgaSBmID0gZnVuY3Rpb25cbiAgICBbXSAtPiBbXVxuICB8IGE6OmwgLT4gbGV0IHIgPSBmIGkgYSBpbiByIDo6IG1hcGkgKGkgKyAxKSBmIGxcblxubGV0IG1hcGkgZiBsID0gbWFwaSAwIGYgbFxuXG5sZXQgcmV2X21hcCBmIGwgPVxuICBsZXQgcmVjIHJtYXBfZiBhY2N1ID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGFjY3VcbiAgICB8IGE6OmwgLT4gcm1hcF9mIChmIGEgOjogYWNjdSkgbFxuICBpblxuICBybWFwX2YgW10gbFxuXG5cbmxldCByZWMgaXRlciBmID0gZnVuY3Rpb25cbiAgICBbXSAtPiAoKVxuICB8IGE6OmwgLT4gZiBhOyBpdGVyIGYgbFxuXG5sZXQgcmVjIGl0ZXJpIGkgZiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gKClcbiAgfCBhOjpsIC0+IGYgaSBhOyBpdGVyaSAoaSArIDEpIGYgbFxuXG5sZXQgaXRlcmkgZiBsID0gaXRlcmkgMCBmIGxcblxubGV0IHJlYyBmb2xkX2xlZnQgZiBhY2N1IGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgICBbXSAtPiBhY2N1XG4gIHwgYTo6bCAtPiBmb2xkX2xlZnQgZiAoZiBhY2N1IGEpIGxcblxubGV0IHJlYyBmb2xkX3JpZ2h0IGYgbCBhY2N1ID1cbiAgbWF0Y2ggbCB3aXRoXG4gICAgW10gLT4gYWNjdVxuICB8IGE6OmwgLT4gZiBhIChmb2xkX3JpZ2h0IGYgbCBhY2N1KVxuXG5sZXQgcmVjIG1hcDIgZiBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBbXVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gbGV0IHIgPSBmIGExIGEyIGluIHIgOjogbWFwMiBmIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5tYXAyXCJcblxubGV0IHJldl9tYXAyIGYgbDEgbDIgPVxuICBsZXQgcmVjIHJtYXAyX2YgYWNjdSBsMSBsMiA9XG4gICAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIHwgKFtdLCBbXSkgLT4gYWNjdVxuICAgIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBybWFwMl9mIChmIGExIGEyIDo6IGFjY3UpIGwxIGwyXG4gICAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LnJldl9tYXAyXCJcbiAgaW5cbiAgcm1hcDJfZiBbXSBsMSBsMlxuXG5cbmxldCByZWMgaXRlcjIgZiBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiAoKVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gZiBhMSBhMjsgaXRlcjIgZiBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuaXRlcjJcIlxuXG5sZXQgcmVjIGZvbGRfbGVmdDIgZiBhY2N1IGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IGFjY3VcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IGZvbGRfbGVmdDIgZiAoZiBhY2N1IGExIGEyKSBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuZm9sZF9sZWZ0MlwiXG5cbmxldCByZWMgZm9sZF9yaWdodDIgZiBsMSBsMiBhY2N1ID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IGFjY3VcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IGYgYTEgYTIgKGZvbGRfcmlnaHQyIGYgbDEgbDIgYWNjdSlcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LmZvbGRfcmlnaHQyXCJcblxubGV0IHJlYyBmb3JfYWxsIHAgPSBmdW5jdGlvblxuICAgIFtdIC0+IHRydWVcbiAgfCBhOjpsIC0+IHAgYSAmJiBmb3JfYWxsIHAgbFxuXG5sZXQgcmVjIGV4aXN0cyBwID0gZnVuY3Rpb25cbiAgICBbXSAtPiBmYWxzZVxuICB8IGE6OmwgLT4gcCBhIHx8IGV4aXN0cyBwIGxcblxubGV0IHJlYyBmb3JfYWxsMiBwIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IHRydWVcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IHAgYTEgYTIgJiYgZm9yX2FsbDIgcCBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuZm9yX2FsbDJcIlxuXG5sZXQgcmVjIGV4aXN0czIgcCBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBmYWxzZVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gcCBhMSBhMiB8fCBleGlzdHMyIHAgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LmV4aXN0czJcIlxuXG5sZXQgcmVjIG1lbSB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBmYWxzZVxuICB8IGE6OmwgLT4gY29tcGFyZSBhIHggPSAwIHx8IG1lbSB4IGxcblxubGV0IHJlYyBtZW1xIHggPSBmdW5jdGlvblxuICAgIFtdIC0+IGZhbHNlXG4gIHwgYTo6bCAtPiBhID09IHggfHwgbWVtcSB4IGxcblxubGV0IHJlYyBhc3NvYyB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCAoYSxiKTo6bCAtPiBpZiBjb21wYXJlIGEgeCA9IDAgdGhlbiBiIGVsc2UgYXNzb2MgeCBsXG5cbmxldCByZWMgYXNzb2Nfb3B0IHggPSBmdW5jdGlvblxuICAgIFtdIC0+IE5vbmVcbiAgfCAoYSxiKTo6bCAtPiBpZiBjb21wYXJlIGEgeCA9IDAgdGhlbiBTb21lIGIgZWxzZSBhc3NvY19vcHQgeCBsXG5cbmxldCByZWMgYXNzcSB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCAoYSxiKTo6bCAtPiBpZiBhID09IHggdGhlbiBiIGVsc2UgYXNzcSB4IGxcblxubGV0IHJlYyBhc3NxX29wdCB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBOb25lXG4gIHwgKGEsYik6OmwgLT4gaWYgYSA9PSB4IHRoZW4gU29tZSBiIGVsc2UgYXNzcV9vcHQgeCBsXG5cbmxldCByZWMgbWVtX2Fzc29jIHggPSBmdW5jdGlvblxuICB8IFtdIC0+IGZhbHNlXG4gIHwgKGEsIF8pIDo6IGwgLT4gY29tcGFyZSBhIHggPSAwIHx8IG1lbV9hc3NvYyB4IGxcblxubGV0IHJlYyBtZW1fYXNzcSB4ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBmYWxzZVxuICB8IChhLCBfKSA6OiBsIC0+IGEgPT0geCB8fCBtZW1fYXNzcSB4IGxcblxubGV0IHJlYyByZW1vdmVfYXNzb2MgeCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gW11cbiAgfCAoYSwgXyBhcyBwYWlyKSA6OiBsIC0+XG4gICAgICBpZiBjb21wYXJlIGEgeCA9IDAgdGhlbiBsIGVsc2UgcGFpciA6OiByZW1vdmVfYXNzb2MgeCBsXG5cbmxldCByZWMgcmVtb3ZlX2Fzc3EgeCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gW11cbiAgfCAoYSwgXyBhcyBwYWlyKSA6OiBsIC0+IGlmIGEgPT0geCB0aGVuIGwgZWxzZSBwYWlyIDo6IHJlbW92ZV9hc3NxIHggbFxuXG5sZXQgcmVjIGZpbmQgcCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgeCA6OiBsIC0+IGlmIHAgeCB0aGVuIHggZWxzZSBmaW5kIHAgbFxuXG5sZXQgcmVjIGZpbmRfb3B0IHAgPSBmdW5jdGlvblxuICB8IFtdIC0+IE5vbmVcbiAgfCB4IDo6IGwgLT4gaWYgcCB4IHRoZW4gU29tZSB4IGVsc2UgZmluZF9vcHQgcCBsXG5cbmxldCBmaW5kX2FsbCBwID1cbiAgbGV0IHJlYyBmaW5kIGFjY3UgPSBmdW5jdGlvblxuICB8IFtdIC0+IHJldiBhY2N1XG4gIHwgeCA6OiBsIC0+IGlmIHAgeCB0aGVuIGZpbmQgKHggOjogYWNjdSkgbCBlbHNlIGZpbmQgYWNjdSBsIGluXG4gIGZpbmQgW11cblxubGV0IGZpbHRlciA9IGZpbmRfYWxsXG5cbmxldCBwYXJ0aXRpb24gcCBsID1cbiAgbGV0IHJlYyBwYXJ0IHllcyBubyA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gKHJldiB5ZXMsIHJldiBubylcbiAgfCB4IDo6IGwgLT4gaWYgcCB4IHRoZW4gcGFydCAoeCA6OiB5ZXMpIG5vIGwgZWxzZSBwYXJ0IHllcyAoeCA6OiBubykgbCBpblxuICBwYXJ0IFtdIFtdIGxcblxubGV0IHJlYyBzcGxpdCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gKFtdLCBbXSlcbiAgfCAoeCx5KTo6bCAtPlxuICAgICAgbGV0IChyeCwgcnkpID0gc3BsaXQgbCBpbiAoeDo6cngsIHk6OnJ5KVxuXG5sZXQgcmVjIGNvbWJpbmUgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gW11cbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IChhMSwgYTIpIDo6IGNvbWJpbmUgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LmNvbWJpbmVcIlxuXG4oKiogc29ydGluZyAqKVxuXG5sZXQgcmVjIG1lcmdlIGNtcCBsMSBsMiA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gIHwgW10sIGwyIC0+IGwyXG4gIHwgbDEsIFtdIC0+IGwxXG4gIHwgaDEgOjogdDEsIGgyIDo6IHQyIC0+XG4gICAgICBpZiBjbXAgaDEgaDIgPD0gMFxuICAgICAgdGhlbiBoMSA6OiBtZXJnZSBjbXAgdDEgbDJcbiAgICAgIGVsc2UgaDIgOjogbWVyZ2UgY21wIGwxIHQyXG5cblxubGV0IHJlYyBjaG9wIGsgbCA9XG4gIGlmIGsgPSAwIHRoZW4gbCBlbHNlIGJlZ2luXG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBfOjp0IC0+IGNob3AgKGstMSkgdFxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgZW5kXG5cblxubGV0IHN0YWJsZV9zb3J0IGNtcCBsID1cbiAgbGV0IHJlYyByZXZfbWVyZ2UgbDEgbDIgYWNjdSA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtdLCBsMiAtPiByZXZfYXBwZW5kIGwyIGFjY3VcbiAgICB8IGwxLCBbXSAtPiByZXZfYXBwZW5kIGwxIGFjY3VcbiAgICB8IGgxOjp0MSwgaDI6OnQyIC0+XG4gICAgICAgIGlmIGNtcCBoMSBoMiA8PSAwXG4gICAgICAgIHRoZW4gcmV2X21lcmdlIHQxIGwyIChoMTo6YWNjdSlcbiAgICAgICAgZWxzZSByZXZfbWVyZ2UgbDEgdDIgKGgyOjphY2N1KVxuICBpblxuICBsZXQgcmVjIHJldl9tZXJnZV9yZXYgbDEgbDIgYWNjdSA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtdLCBsMiAtPiByZXZfYXBwZW5kIGwyIGFjY3VcbiAgICB8IGwxLCBbXSAtPiByZXZfYXBwZW5kIGwxIGFjY3VcbiAgICB8IGgxOjp0MSwgaDI6OnQyIC0+XG4gICAgICAgIGlmIGNtcCBoMSBoMiA+IDBcbiAgICAgICAgdGhlbiByZXZfbWVyZ2VfcmV2IHQxIGwyIChoMTo6YWNjdSlcbiAgICAgICAgZWxzZSByZXZfbWVyZ2VfcmV2IGwxIHQyIChoMjo6YWNjdSlcbiAgaW5cbiAgbGV0IHJlYyBzb3J0IG4gbCA9XG4gICAgbWF0Y2ggbiwgbCB3aXRoXG4gICAgfCAyLCB4MSA6OiB4MiA6OiBfIC0+XG4gICAgICAgaWYgY21wIHgxIHgyIDw9IDAgdGhlbiBbeDE7IHgyXSBlbHNlIFt4MjsgeDFdXG4gICAgfCAzLCB4MSA6OiB4MiA6OiB4MyA6OiBfIC0+XG4gICAgICAgaWYgY21wIHgxIHgyIDw9IDAgdGhlbiBiZWdpblxuICAgICAgICAgaWYgY21wIHgyIHgzIDw9IDAgdGhlbiBbeDE7IHgyOyB4M11cbiAgICAgICAgIGVsc2UgaWYgY21wIHgxIHgzIDw9IDAgdGhlbiBbeDE7IHgzOyB4Ml1cbiAgICAgICAgIGVsc2UgW3gzOyB4MTsgeDJdXG4gICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgIGlmIGNtcCB4MSB4MyA8PSAwIHRoZW4gW3gyOyB4MTsgeDNdXG4gICAgICAgICBlbHNlIGlmIGNtcCB4MiB4MyA8PSAwIHRoZW4gW3gyOyB4MzsgeDFdXG4gICAgICAgICBlbHNlIFt4MzsgeDI7IHgxXVxuICAgICAgIGVuZFxuICAgIHwgbiwgbCAtPlxuICAgICAgIGxldCBuMSA9IG4gYXNyIDEgaW5cbiAgICAgICBsZXQgbjIgPSBuIC0gbjEgaW5cbiAgICAgICBsZXQgbDIgPSBjaG9wIG4xIGwgaW5cbiAgICAgICBsZXQgczEgPSByZXZfc29ydCBuMSBsIGluXG4gICAgICAgbGV0IHMyID0gcmV2X3NvcnQgbjIgbDIgaW5cbiAgICAgICByZXZfbWVyZ2VfcmV2IHMxIHMyIFtdXG4gIGFuZCByZXZfc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogXyAtPlxuICAgICAgIGlmIGNtcCB4MSB4MiA+IDAgdGhlbiBbeDE7IHgyXSBlbHNlIFt4MjsgeDFdXG4gICAgfCAzLCB4MSA6OiB4MiA6OiB4MyA6OiBfIC0+XG4gICAgICAgaWYgY21wIHgxIHgyID4gMCB0aGVuIGJlZ2luXG4gICAgICAgICBpZiBjbXAgeDIgeDMgPiAwIHRoZW4gW3gxOyB4MjsgeDNdXG4gICAgICAgICBlbHNlIGlmIGNtcCB4MSB4MyA+IDAgdGhlbiBbeDE7IHgzOyB4Ml1cbiAgICAgICAgIGVsc2UgW3gzOyB4MTsgeDJdXG4gICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgIGlmIGNtcCB4MSB4MyA+IDAgdGhlbiBbeDI7IHgxOyB4M11cbiAgICAgICAgIGVsc2UgaWYgY21wIHgyIHgzID4gMCB0aGVuIFt4MjsgeDM7IHgxXVxuICAgICAgICAgZWxzZSBbeDM7IHgyOyB4MV1cbiAgICAgICBlbmRcbiAgICB8IG4sIGwgLT5cbiAgICAgICBsZXQgbjEgPSBuIGFzciAxIGluXG4gICAgICAgbGV0IG4yID0gbiAtIG4xIGluXG4gICAgICAgbGV0IGwyID0gY2hvcCBuMSBsIGluXG4gICAgICAgbGV0IHMxID0gc29ydCBuMSBsIGluXG4gICAgICAgbGV0IHMyID0gc29ydCBuMiBsMiBpblxuICAgICAgIHJldl9tZXJnZSBzMSBzMiBbXVxuICBpblxuICBsZXQgbGVuID0gbGVuZ3RoIGwgaW5cbiAgaWYgbGVuIDwgMiB0aGVuIGwgZWxzZSBzb3J0IGxlbiBsXG5cblxubGV0IHNvcnQgPSBzdGFibGVfc29ydFxubGV0IGZhc3Rfc29ydCA9IHN0YWJsZV9zb3J0XG5cbigqIE5vdGU6IG9uIGEgbGlzdCBvZiBsZW5ndGggYmV0d2VlbiBhYm91dCAxMDAwMDAgKGRlcGVuZGluZyBvbiB0aGUgbWlub3JcbiAgIGhlYXAgc2l6ZSBhbmQgdGhlIHR5cGUgb2YgdGhlIGxpc3QpIGFuZCBTeXMubWF4X2FycmF5X3NpemUsIGl0IGlzXG4gICBhY3R1YWxseSBmYXN0ZXIgdG8gdXNlIHRoZSBmb2xsb3dpbmcsIGJ1dCBpdCBtaWdodCBhbHNvIHVzZSBtb3JlIG1lbW9yeVxuICAgYmVjYXVzZSB0aGUgYXJndW1lbnQgbGlzdCBjYW5ub3QgYmUgZGVhbGxvY2F0ZWQgaW5jcmVtZW50YWxseS5cblxuICAgQWxzbywgdGhlcmUgc2VlbXMgdG8gYmUgYSBidWcgaW4gdGhpcyBjb2RlIG9yIGluIHRoZVxuICAgaW1wbGVtZW50YXRpb24gb2Ygb2JqX3RydW5jYXRlLlxuXG5leHRlcm5hbCBvYmpfdHJ1bmNhdGUgOiAnYSBhcnJheSAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9vYmpfdHJ1bmNhdGVcIlxuXG5sZXQgYXJyYXlfdG9fbGlzdF9pbl9wbGFjZSBhID1cbiAgbGV0IGwgPSBBcnJheS5sZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgYWNjdSBuIHAgPVxuICAgIGlmIHAgPD0gMCB0aGVuIGFjY3UgZWxzZSBiZWdpblxuICAgICAgaWYgcCA9IG4gdGhlbiBiZWdpblxuICAgICAgICBvYmpfdHJ1bmNhdGUgYSBwO1xuICAgICAgICBsb29wIChhLihwLTEpIDo6IGFjY3UpIChuLTEwMDApIChwLTEpXG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBsb29wIChhLihwLTEpIDo6IGFjY3UpIG4gKHAtMSlcbiAgICAgIGVuZFxuICAgIGVuZFxuICBpblxuICBsb29wIFtdIChsLTEwMDApIGxcblxuXG5sZXQgc3RhYmxlX3NvcnQgY21wIGwgPVxuICBsZXQgYSA9IEFycmF5Lm9mX2xpc3QgbCBpblxuICBBcnJheS5zdGFibGVfc29ydCBjbXAgYTtcbiAgYXJyYXlfdG9fbGlzdF9pbl9wbGFjZSBhXG5cbiopXG5cblxuKCoqIHNvcnRpbmcgKyByZW1vdmluZyBkdXBsaWNhdGVzICopXG5cbmxldCBzb3J0X3VuaXEgY21wIGwgPVxuICBsZXQgcmVjIHJldl9tZXJnZSBsMSBsMiBhY2N1ID1cbiAgICBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgW10sIGwyIC0+IHJldl9hcHBlbmQgbDIgYWNjdVxuICAgIHwgbDEsIFtdIC0+IHJldl9hcHBlbmQgbDEgYWNjdVxuICAgIHwgaDE6OnQxLCBoMjo6dDIgLT5cbiAgICAgICAgbGV0IGMgPSBjbXAgaDEgaDIgaW5cbiAgICAgICAgaWYgYyA9IDAgdGhlbiByZXZfbWVyZ2UgdDEgdDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICAgIHRoZW4gcmV2X21lcmdlIHQxIGwyIChoMTo6YWNjdSlcbiAgICAgICAgZWxzZSByZXZfbWVyZ2UgbDEgdDIgKGgyOjphY2N1KVxuICBpblxuICBsZXQgcmVjIHJldl9tZXJnZV9yZXYgbDEgbDIgYWNjdSA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtdLCBsMiAtPiByZXZfYXBwZW5kIGwyIGFjY3VcbiAgICB8IGwxLCBbXSAtPiByZXZfYXBwZW5kIGwxIGFjY3VcbiAgICB8IGgxOjp0MSwgaDI6OnQyIC0+XG4gICAgICAgIGxldCBjID0gY21wIGgxIGgyIGluXG4gICAgICAgIGlmIGMgPSAwIHRoZW4gcmV2X21lcmdlX3JldiB0MSB0MiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgaWYgYyA+IDBcbiAgICAgICAgdGhlbiByZXZfbWVyZ2VfcmV2IHQxIGwyIChoMTo6YWNjdSlcbiAgICAgICAgZWxzZSByZXZfbWVyZ2VfcmV2IGwxIHQyIChoMjo6YWNjdSlcbiAgaW5cbiAgbGV0IHJlYyBzb3J0IG4gbCA9XG4gICAgbWF0Y2ggbiwgbCB3aXRoXG4gICAgfCAyLCB4MSA6OiB4MiA6OiBfIC0+XG4gICAgICAgbGV0IGMgPSBjbXAgeDEgeDIgaW5cbiAgICAgICBpZiBjID0gMCB0aGVuIFt4MV1cbiAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW4gW3gxOyB4Ml0gZWxzZSBbeDI7IHgxXVxuICAgIHwgMywgeDEgOjogeDIgOjogeDMgOjogXyAtPlxuICAgICAgIGxldCBjID0gY21wIHgxIHgyIGluXG4gICAgICAgaWYgYyA9IDAgdGhlbiBiZWdpblxuICAgICAgICAgbGV0IGMgPSBjbXAgeDIgeDMgaW5cbiAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gyXVxuICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuIFt4MjsgeDNdIGVsc2UgW3gzOyB4Ml1cbiAgICAgICBlbmQgZWxzZSBpZiBjIDwgMCB0aGVuIGJlZ2luXG4gICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDE7IHgyXVxuICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuIFt4MTsgeDI7IHgzXVxuICAgICAgICAgZWxzZSBsZXQgYyA9IGNtcCB4MSB4MyBpblxuICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDE7IHgyXVxuICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuIFt4MTsgeDM7IHgyXVxuICAgICAgICAgZWxzZSBbeDM7IHgxOyB4Ml1cbiAgICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICAgbGV0IGMgPSBjbXAgeDEgeDMgaW5cbiAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gyOyB4MV1cbiAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDI7IHgxOyB4M11cbiAgICAgICAgIGVsc2UgbGV0IGMgPSBjbXAgeDIgeDMgaW5cbiAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gyOyB4MV1cbiAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDI7IHgzOyB4MV1cbiAgICAgICAgIGVsc2UgW3gzOyB4MjsgeDFdXG4gICAgICAgZW5kXG4gICAgfCBuLCBsIC0+XG4gICAgICAgbGV0IG4xID0gbiBhc3IgMSBpblxuICAgICAgIGxldCBuMiA9IG4gLSBuMSBpblxuICAgICAgIGxldCBsMiA9IGNob3AgbjEgbCBpblxuICAgICAgIGxldCBzMSA9IHJldl9zb3J0IG4xIGwgaW5cbiAgICAgICBsZXQgczIgPSByZXZfc29ydCBuMiBsMiBpblxuICAgICAgIHJldl9tZXJnZV9yZXYgczEgczIgW11cbiAgYW5kIHJldl9zb3J0IG4gbCA9XG4gICAgbWF0Y2ggbiwgbCB3aXRoXG4gICAgfCAyLCB4MSA6OiB4MiA6OiBfIC0+XG4gICAgICAgbGV0IGMgPSBjbXAgeDEgeDIgaW5cbiAgICAgICBpZiBjID0gMCB0aGVuIFt4MV1cbiAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW4gW3gxOyB4Ml0gZWxzZSBbeDI7IHgxXVxuICAgIHwgMywgeDEgOjogeDIgOjogeDMgOjogXyAtPlxuICAgICAgIGxldCBjID0gY21wIHgxIHgyIGluXG4gICAgICAgaWYgYyA9IDAgdGhlbiBiZWdpblxuICAgICAgICAgbGV0IGMgPSBjbXAgeDIgeDMgaW5cbiAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gyXVxuICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuIFt4MjsgeDNdIGVsc2UgW3gzOyB4Ml1cbiAgICAgICBlbmQgZWxzZSBpZiBjID4gMCB0aGVuIGJlZ2luXG4gICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDE7IHgyXVxuICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuIFt4MTsgeDI7IHgzXVxuICAgICAgICAgZWxzZSBsZXQgYyA9IGNtcCB4MSB4MyBpblxuICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDE7IHgyXVxuICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuIFt4MTsgeDM7IHgyXVxuICAgICAgICAgZWxzZSBbeDM7IHgxOyB4Ml1cbiAgICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICAgbGV0IGMgPSBjbXAgeDEgeDMgaW5cbiAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gyOyB4MV1cbiAgICAgICAgIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDI7IHgxOyB4M11cbiAgICAgICAgIGVsc2UgbGV0IGMgPSBjbXAgeDIgeDMgaW5cbiAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gyOyB4MV1cbiAgICAgICAgIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDI7IHgzOyB4MV1cbiAgICAgICAgIGVsc2UgW3gzOyB4MjsgeDFdXG4gICAgICAgZW5kXG4gICAgfCBuLCBsIC0+XG4gICAgICAgbGV0IG4xID0gbiBhc3IgMSBpblxuICAgICAgIGxldCBuMiA9IG4gLSBuMSBpblxuICAgICAgIGxldCBsMiA9IGNob3AgbjEgbCBpblxuICAgICAgIGxldCBzMSA9IHNvcnQgbjEgbCBpblxuICAgICAgIGxldCBzMiA9IHNvcnQgbjIgbDIgaW5cbiAgICAgICByZXZfbWVyZ2UgczEgczIgW11cbiAgaW5cbiAgbGV0IGxlbiA9IGxlbmd0aCBsIGluXG4gIGlmIGxlbiA8IDIgdGhlbiBsIGVsc2Ugc29ydCBsZW4gbFxuXG5sZXQgcmVjIGNvbXBhcmVfbGVuZ3RocyBsMSBsMiA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gIHwgW10sIFtdIC0+IDBcbiAgfCBbXSwgXyAtPiAtMVxuICB8IF8sIFtdIC0+IDFcbiAgfCBfIDo6IGwxLCBfIDo6IGwyIC0+IGNvbXBhcmVfbGVuZ3RocyBsMSBsMlxuOztcblxubGV0IHJlYyBjb21wYXJlX2xlbmd0aF93aXRoIGwgbiA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+XG4gICAgaWYgbiA9IDAgdGhlbiAwIGVsc2VcbiAgICAgIGlmIG4gPiAwIHRoZW4gLTEgZWxzZSAxXG4gIHwgXyA6OiBsIC0+XG4gICAgaWYgbiA8PSAwIHRoZW4gMSBlbHNlXG4gICAgICBjb21wYXJlX2xlbmd0aF93aXRoIGwgKG4tMSlcbjs7XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIENoYXJhY3RlciBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIGNvZGU6IGNoYXIgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgdW5zYWZlX2NocjogaW50IC0+IGNoYXIgPSBcIiVpZGVudGl0eVwiXG5cbmxldCBjaHIgbiA9XG4gIGlmIG4gPCAwIHx8IG4gPiAyNTUgdGhlbiBpbnZhbGlkX2FyZyBcIkNoYXIuY2hyXCIgZWxzZSB1bnNhZmVfY2hyIG5cblxuZXh0ZXJuYWwgYnl0ZXNfY3JlYXRlOiBpbnQgLT4gYnl0ZXMgPSBcImNhbWxfY3JlYXRlX2J5dGVzXCJcbmV4dGVybmFsIGJ5dGVzX3Vuc2FmZV9zZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiJWJ5dGVzX3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3RvX3N0cmluZyA6IGJ5dGVzIC0+IHN0cmluZyA9IFwiJWJ5dGVzX3RvX3N0cmluZ1wiXG5cbmxldCBlc2NhcGVkID0gZnVuY3Rpb25cbiAgfCAnXFwnJyAtPiBcIlxcXFwnXCJcbiAgfCAnXFxcXCcgLT4gXCJcXFxcXFxcXFwiXG4gIHwgJ1xcbicgLT4gXCJcXFxcblwiXG4gIHwgJ1xcdCcgLT4gXCJcXFxcdFwiXG4gIHwgJ1xccicgLT4gXCJcXFxcclwiXG4gIHwgJ1xcYicgLT4gXCJcXFxcYlwiXG4gIHwgJyAnIC4uICd+JyBhcyBjIC0+XG4gICAgICBsZXQgcyA9IGJ5dGVzX2NyZWF0ZSAxIGluXG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMCBjO1xuICAgICAgdW5zYWZlX3RvX3N0cmluZyBzXG4gIHwgYyAtPlxuICAgICAgbGV0IG4gPSBjb2RlIGMgaW5cbiAgICAgIGxldCBzID0gYnl0ZXNfY3JlYXRlIDQgaW5cbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAwICdcXFxcJztcbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAxICh1bnNhZmVfY2hyICg0OCArIG4gLyAxMDApKTtcbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAyICh1bnNhZmVfY2hyICg0OCArIChuIC8gMTApIG1vZCAxMCkpO1xuICAgICAgYnl0ZXNfdW5zYWZlX3NldCBzIDMgKHVuc2FmZV9jaHIgKDQ4ICsgbiBtb2QgMTApKTtcbiAgICAgIHVuc2FmZV90b19zdHJpbmcgc1xuXG5sZXQgbG93ZXJjYXNlIGMgPVxuICBpZiAoYyA+PSAnQScgJiYgYyA8PSAnWicpXG4gIHx8IChjID49ICdcXDE5MicgJiYgYyA8PSAnXFwyMTQnKVxuICB8fCAoYyA+PSAnXFwyMTYnICYmIGMgPD0gJ1xcMjIyJylcbiAgdGhlbiB1bnNhZmVfY2hyKGNvZGUgYyArIDMyKVxuICBlbHNlIGNcblxubGV0IHVwcGVyY2FzZSBjID1cbiAgaWYgKGMgPj0gJ2EnICYmIGMgPD0gJ3onKVxuICB8fCAoYyA+PSAnXFwyMjQnICYmIGMgPD0gJ1xcMjQ2JylcbiAgfHwgKGMgPj0gJ1xcMjQ4JyAmJiBjIDw9ICdcXDI1NCcpXG4gIHRoZW4gdW5zYWZlX2Nocihjb2RlIGMgLSAzMilcbiAgZWxzZSBjXG5cbmxldCBsb3dlcmNhc2VfYXNjaWkgYyA9XG4gIGlmIChjID49ICdBJyAmJiBjIDw9ICdaJylcbiAgdGhlbiB1bnNhZmVfY2hyKGNvZGUgYyArIDMyKVxuICBlbHNlIGNcblxubGV0IHVwcGVyY2FzZV9hc2NpaSBjID1cbiAgaWYgKGMgPj0gJ2EnICYmIGMgPD0gJ3onKVxuICB0aGVuIHVuc2FmZV9jaHIoY29kZSBjIC0gMzIpXG4gIGVsc2UgY1xuXG50eXBlIHQgPSBjaGFyXG5cbmxldCBjb21wYXJlIGMxIGMyID0gY29kZSBjMSAtIGNvZGUgYzJcbmxldCBlcXVhbCAoYzE6IHQpIChjMjogdCkgPSBjb21wYXJlIGMxIGMyID0gMFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBCeXRlIHNlcXVlbmNlIG9wZXJhdGlvbnMgKilcblxuKCogV0FSTklORzogU29tZSBmdW5jdGlvbnMgaW4gdGhpcyBmaWxlIGFyZSBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCBmb3JcbiAgIGVmZmljaWVuY3kgcmVhc29ucy4gV2hlbiB5b3UgbW9kaWZ5IHRoZSBvbmUgaW4gdGhpcyBmaWxlIHlvdSBuZWVkIHRvXG4gICBtb2RpZnkgaXRzIGR1cGxpY2F0ZSBpbiBzdHJpbmcubWwuXG4gICBUaGVzZSBmdW5jdGlvbnMgaGF2ZSBhIFwiZHVwbGljYXRlZFwiIGNvbW1lbnQgYWJvdmUgdGhlaXIgZGVmaW5pdGlvbi5cbiopXG5cbmV4dGVybmFsIGxlbmd0aCA6IGJ5dGVzIC0+IGludCA9IFwiJWJ5dGVzX2xlbmd0aFwiXG5leHRlcm5hbCBzdHJpbmdfbGVuZ3RoIDogc3RyaW5nIC0+IGludCA9IFwiJXN0cmluZ19sZW5ndGhcIlxuZXh0ZXJuYWwgZ2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgPSBcIiVieXRlc19zYWZlX2dldFwiXG5leHRlcm5hbCBzZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlYnl0ZXNfc2FmZV9zZXRcIlxuZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+IGJ5dGVzID0gXCJjYW1sX2NyZWF0ZV9ieXRlc1wiXG5leHRlcm5hbCB1bnNhZmVfZ2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgPSBcIiVieXRlc191bnNhZmVfZ2V0XCJcbmV4dGVybmFsIHVuc2FmZV9zZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlYnl0ZXNfdW5zYWZlX3NldFwiXG5leHRlcm5hbCB1bnNhZmVfZmlsbCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gY2hhciAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9maWxsX2J5dGVzXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIHVuc2FmZV90b19zdHJpbmcgOiBieXRlcyAtPiBzdHJpbmcgPSBcIiVieXRlc190b19zdHJpbmdcIlxuZXh0ZXJuYWwgdW5zYWZlX29mX3N0cmluZyA6IHN0cmluZyAtPiBieXRlcyA9IFwiJWJ5dGVzX29mX3N0cmluZ1wiXG5cbmV4dGVybmFsIHVuc2FmZV9ibGl0IDogYnl0ZXMgLT4gaW50IC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9ieXRlc1wiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB1bnNhZmVfYmxpdF9zdHJpbmcgOiBzdHJpbmcgLT4gaW50IC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuXG5sZXQgbWFrZSBuIGMgPVxuICBsZXQgcyA9IGNyZWF0ZSBuIGluXG4gIHVuc2FmZV9maWxsIHMgMCBuIGM7XG4gIHNcblxubGV0IGluaXQgbiBmID1cbiAgbGV0IHMgPSBjcmVhdGUgbiBpblxuICBmb3IgaSA9IDAgdG8gbiAtIDEgZG9cbiAgICB1bnNhZmVfc2V0IHMgaSAoZiBpKVxuICBkb25lO1xuICBzXG5cbmxldCBlbXB0eSA9IGNyZWF0ZSAwXG5cbmxldCBjb3B5IHMgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHMgaW5cbiAgbGV0IHIgPSBjcmVhdGUgbGVuIGluXG4gIHVuc2FmZV9ibGl0IHMgMCByIDAgbGVuO1xuICByXG5cbmxldCB0b19zdHJpbmcgYiA9IHVuc2FmZV90b19zdHJpbmcgKGNvcHkgYilcbmxldCBvZl9zdHJpbmcgcyA9IGNvcHkgKHVuc2FmZV9vZl9zdHJpbmcgcylcblxubGV0IHN1YiBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5zdWIgLyBCeXRlcy5zdWJcIlxuICBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbGVuIGluXG4gICAgdW5zYWZlX2JsaXQgcyBvZnMgciAwIGxlbjtcbiAgICByXG4gIGVuZFxuXG5sZXQgc3ViX3N0cmluZyBiIG9mcyBsZW4gPSB1bnNhZmVfdG9fc3RyaW5nIChzdWIgYiBvZnMgbGVuKVxuXG4oKiBhZGRpdGlvbiB3aXRoIGFuIG92ZXJmbG93IGNoZWNrICopXG5sZXQgKCsrKSBhIGIgPVxuICBsZXQgYyA9IGEgKyBiIGluXG4gIG1hdGNoIGEgPCAwLCBiIDwgMCwgYyA8IDAgd2l0aFxuICB8IHRydWUgLCB0cnVlICwgZmFsc2VcbiAgfCBmYWxzZSwgZmFsc2UsIHRydWUgIC0+IGludmFsaWRfYXJnIFwiQnl0ZXMuZXh0ZW5kXCIgKCogb3ZlcmZsb3cgKilcbiAgfCBfIC0+IGNcblxubGV0IGV4dGVuZCBzIGxlZnQgcmlnaHQgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHMgKysgbGVmdCArKyByaWdodCBpblxuICBsZXQgciA9IGNyZWF0ZSBsZW4gaW5cbiAgbGV0IChzcmNvZmYsIGRzdG9mZikgPSBpZiBsZWZ0IDwgMCB0aGVuIC1sZWZ0LCAwIGVsc2UgMCwgbGVmdCBpblxuICBsZXQgY3B5bGVuID0gbWluIChsZW5ndGggcyAtIHNyY29mZikgKGxlbiAtIGRzdG9mZikgaW5cbiAgaWYgY3B5bGVuID4gMCB0aGVuIHVuc2FmZV9ibGl0IHMgc3Jjb2ZmIHIgZHN0b2ZmIGNweWxlbjtcbiAgclxuXG5sZXQgZmlsbCBzIG9mcyBsZW4gYyA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBsZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLmZpbGwgLyBCeXRlcy5maWxsXCJcbiAgZWxzZSB1bnNhZmVfZmlsbCBzIG9mcyBsZW4gY1xuXG5sZXQgYmxpdCBzMSBvZnMxIHMyIG9mczIgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBvZnMxIDwgMCB8fCBvZnMxID4gbGVuZ3RoIHMxIC0gbGVuXG4gICAgICAgICAgICAgfHwgb2ZzMiA8IDAgfHwgb2ZzMiA+IGxlbmd0aCBzMiAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQnl0ZXMuYmxpdFwiXG4gIGVsc2UgdW5zYWZlX2JsaXQgczEgb2ZzMSBzMiBvZnMyIGxlblxuXG5sZXQgYmxpdF9zdHJpbmcgczEgb2ZzMSBzMiBvZnMyIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgb2ZzMSA8IDAgfHwgb2ZzMSA+IHN0cmluZ19sZW5ndGggczEgLSBsZW5cbiAgICAgICAgICAgICB8fCBvZnMyIDwgMCB8fCBvZnMyID4gbGVuZ3RoIHMyIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuYmxpdCAvIEJ5dGVzLmJsaXRfc3RyaW5nXCJcbiAgZWxzZSB1bnNhZmVfYmxpdF9zdHJpbmcgczEgb2ZzMSBzMiBvZnMyIGxlblxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGl0ZXIgZiBhID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaXRlcmkgZiBhID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmIGkgKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbmxldCBlbnN1cmVfZ2UgKHg6aW50KSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIGludmFsaWRfYXJnIFwiQnl0ZXMuY29uY2F0XCJcblxubGV0IHJlYyBzdW1fbGVuZ3RocyBhY2Mgc2VwbGVuID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBhY2NcbiAgfCBoZCA6OiBbXSAtPiBsZW5ndGggaGQgKyBhY2NcbiAgfCBoZCA6OiB0bCAtPiBzdW1fbGVuZ3RocyAoZW5zdXJlX2dlIChsZW5ndGggaGQgKyBzZXBsZW4gKyBhY2MpIGFjYykgc2VwbGVuIHRsXG5cbmxldCByZWMgdW5zYWZlX2JsaXRzIGRzdCBwb3Mgc2VwIHNlcGxlbiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZHN0XG4gIHwgaGQgOjogW10gLT5cbiAgICB1bnNhZmVfYmxpdCBoZCAwIGRzdCBwb3MgKGxlbmd0aCBoZCk7IGRzdFxuICB8IGhkIDo6IHRsIC0+XG4gICAgdW5zYWZlX2JsaXQgaGQgMCBkc3QgcG9zIChsZW5ndGggaGQpO1xuICAgIHVuc2FmZV9ibGl0IHNlcCAwIGRzdCAocG9zICsgbGVuZ3RoIGhkKSBzZXBsZW47XG4gICAgdW5zYWZlX2JsaXRzIGRzdCAocG9zICsgbGVuZ3RoIGhkICsgc2VwbGVuKSBzZXAgc2VwbGVuIHRsXG5cbmxldCBjb25jYXQgc2VwID0gZnVuY3Rpb25cbiAgICBbXSAtPiBlbXB0eVxuICB8IGwgLT4gbGV0IHNlcGxlbiA9IGxlbmd0aCBzZXAgaW5cbiAgICAgICAgICB1bnNhZmVfYmxpdHNcbiAgICAgICAgICAgIChjcmVhdGUgKHN1bV9sZW5ndGhzIDAgc2VwbGVuIGwpKVxuICAgICAgICAgICAgMCBzZXAgc2VwbGVuIGxcblxubGV0IGNhdCBzMSBzMiA9XG4gIGxldCBsMSA9IGxlbmd0aCBzMSBpblxuICBsZXQgbDIgPSBsZW5ndGggczIgaW5cbiAgbGV0IHIgPSBjcmVhdGUgKGwxICsgbDIpIGluXG4gIHVuc2FmZV9ibGl0IHMxIDAgciAwIGwxO1xuICB1bnNhZmVfYmxpdCBzMiAwIHIgbDEgbDI7XG4gIHJcblxuXG5leHRlcm5hbCBjaGFyX2NvZGU6IGNoYXIgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgY2hhcl9jaHI6IGludCAtPiBjaGFyID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgaXNfc3BhY2UgPSBmdW5jdGlvblxuICB8ICcgJyB8ICdcXDAxMicgfCAnXFxuJyB8ICdcXHInIHwgJ1xcdCcgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxubGV0IHRyaW0gcyA9XG4gIGxldCBsZW4gPSBsZW5ndGggcyBpblxuICBsZXQgaSA9IHJlZiAwIGluXG4gIHdoaWxlICFpIDwgbGVuICYmIGlzX3NwYWNlICh1bnNhZmVfZ2V0IHMgIWkpIGRvXG4gICAgaW5jciBpXG4gIGRvbmU7XG4gIGxldCBqID0gcmVmIChsZW4gLSAxKSBpblxuICB3aGlsZSAhaiA+PSAhaSAmJiBpc19zcGFjZSAodW5zYWZlX2dldCBzICFqKSBkb1xuICAgIGRlY3IgalxuICBkb25lO1xuICBpZiAhaiA+PSAhaSB0aGVuXG4gICAgc3ViIHMgIWkgKCFqIC0gIWkgKyAxKVxuICBlbHNlXG4gICAgZW1wdHlcblxubGV0IGVzY2FwZWQgcyA9XG4gIGxldCBuID0gcmVmIDAgaW5cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBzIC0gMSBkb1xuICAgIG4gOj0gIW4gK1xuICAgICAgKG1hdGNoIHVuc2FmZV9nZXQgcyBpIHdpdGhcbiAgICAgICB8ICdcXFwiJyB8ICdcXFxcJyB8ICdcXG4nIHwgJ1xcdCcgfCAnXFxyJyB8ICdcXGInIC0+IDJcbiAgICAgICB8ICcgJyAuLiAnficgLT4gMVxuICAgICAgIHwgXyAtPiA0KVxuICBkb25lO1xuICBpZiAhbiA9IGxlbmd0aCBzIHRoZW4gY29weSBzIGVsc2UgYmVnaW5cbiAgICBsZXQgcycgPSBjcmVhdGUgIW4gaW5cbiAgICBuIDo9IDA7XG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aCBzIC0gMSBkb1xuICAgICAgYmVnaW4gbWF0Y2ggdW5zYWZlX2dldCBzIGkgd2l0aFxuICAgICAgfCAoJ1xcXCInIHwgJ1xcXFwnKSBhcyBjIC0+XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7IGluY3IgbjsgdW5zYWZlX3NldCBzJyAhbiBjXG4gICAgICB8ICdcXG4nIC0+XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7IGluY3IgbjsgdW5zYWZlX3NldCBzJyAhbiAnbidcbiAgICAgIHwgJ1xcdCcgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuICd0J1xuICAgICAgfCAnXFxyJyAtPlxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnOyBpbmNyIG47IHVuc2FmZV9zZXQgcycgIW4gJ3InXG4gICAgICB8ICdcXGInIC0+XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7IGluY3IgbjsgdW5zYWZlX3NldCBzJyAhbiAnYidcbiAgICAgIHwgKCcgJyAuLiAnficpIGFzIGMgLT4gdW5zYWZlX3NldCBzJyAhbiBjXG4gICAgICB8IGMgLT5cbiAgICAgICAgICBsZXQgYSA9IGNoYXJfY29kZSBjIGluXG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7XG4gICAgICAgICAgaW5jciBuO1xuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gKGNoYXJfY2hyICg0OCArIGEgLyAxMDApKTtcbiAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAoY2hhcl9jaHIgKDQ4ICsgKGEgLyAxMCkgbW9kIDEwKSk7XG4gICAgICAgICAgaW5jciBuO1xuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gKGNoYXJfY2hyICg0OCArIGEgbW9kIDEwKSk7XG4gICAgICBlbmQ7XG4gICAgICBpbmNyIG5cbiAgICBkb25lO1xuICAgIHMnXG4gIGVuZFxuXG5sZXQgbWFwIGYgcyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgbCA9IDAgdGhlbiBzIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsIGluXG4gICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvIHVuc2FmZV9zZXQgciBpIChmICh1bnNhZmVfZ2V0IHMgaSkpIGRvbmU7XG4gICAgclxuICBlbmRcblxubGV0IG1hcGkgZiBzID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBsID0gMCB0aGVuIHMgZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG8gdW5zYWZlX3NldCByIGkgKGYgaSAodW5zYWZlX2dldCBzIGkpKSBkb25lO1xuICAgIHJcbiAgZW5kXG5cbmxldCB1cHBlcmNhc2VfYXNjaWkgcyA9IG1hcCBDaGFyLnVwcGVyY2FzZV9hc2NpaSBzXG5sZXQgbG93ZXJjYXNlX2FzY2lpIHMgPSBtYXAgQ2hhci5sb3dlcmNhc2VfYXNjaWkgc1xuXG5sZXQgYXBwbHkxIGYgcyA9XG4gIGlmIGxlbmd0aCBzID0gMCB0aGVuIHMgZWxzZSBiZWdpblxuICAgIGxldCByID0gY29weSBzIGluXG4gICAgdW5zYWZlX3NldCByIDAgKGYodW5zYWZlX2dldCBzIDApKTtcbiAgICByXG4gIGVuZFxuXG5sZXQgY2FwaXRhbGl6ZV9hc2NpaSBzID0gYXBwbHkxIENoYXIudXBwZXJjYXNlX2FzY2lpIHNcbmxldCB1bmNhcGl0YWxpemVfYXNjaWkgcyA9IGFwcGx5MSBDaGFyLmxvd2VyY2FzZV9hc2NpaSBzXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmVjIGluZGV4X3JlYyBzIGxpbSBpIGMgPVxuICBpZiBpID49IGxpbSB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIGkgZWxzZSBpbmRleF9yZWMgcyBsaW0gKGkgKyAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaW5kZXggcyBjID0gaW5kZXhfcmVjIHMgKGxlbmd0aCBzKSAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByZWMgaW5kZXhfcmVjX29wdCBzIGxpbSBpIGMgPVxuICBpZiBpID49IGxpbSB0aGVuIE5vbmUgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBTb21lIGkgZWxzZSBpbmRleF9yZWNfb3B0IHMgbGltIChpICsgMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGluZGV4X29wdCBzIGMgPSBpbmRleF9yZWNfb3B0IHMgKGxlbmd0aCBzKSAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpbmRleF9mcm9tIHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLmluZGV4X2Zyb20gLyBCeXRlcy5pbmRleF9mcm9tXCIgZWxzZVxuICBpbmRleF9yZWMgcyBsIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGluZGV4X2Zyb21fb3B0IHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLmluZGV4X2Zyb21fb3B0IC8gQnl0ZXMuaW5kZXhfZnJvbV9vcHRcIiBlbHNlXG4gIGluZGV4X3JlY19vcHQgcyBsIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJlYyByaW5kZXhfcmVjIHMgaSBjID1cbiAgaWYgaSA8IDAgdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBpIGVsc2UgcmluZGV4X3JlYyBzIChpIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJpbmRleCBzIGMgPSByaW5kZXhfcmVjIHMgKGxlbmd0aCBzIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJpbmRleF9mcm9tIHMgaSBjID1cbiAgaWYgaSA8IC0xIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJpbmRleF9mcm9tIC8gQnl0ZXMucmluZGV4X2Zyb21cIlxuICBlbHNlXG4gICAgcmluZGV4X3JlYyBzIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJlYyByaW5kZXhfcmVjX29wdCBzIGkgYyA9XG4gIGlmIGkgPCAwIHRoZW4gTm9uZSBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIFNvbWUgaSBlbHNlIHJpbmRleF9yZWNfb3B0IHMgKGkgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmluZGV4X29wdCBzIGMgPSByaW5kZXhfcmVjX29wdCBzIChsZW5ndGggcyAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByaW5kZXhfZnJvbV9vcHQgcyBpIGMgPVxuICBpZiBpIDwgLTEgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmluZGV4X2Zyb21fb3B0IC8gQnl0ZXMucmluZGV4X2Zyb21fb3B0XCJcbiAgZWxzZVxuICAgIHJpbmRleF9yZWNfb3B0IHMgaSBjXG5cblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBjb250YWluc19mcm9tIHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcuY29udGFpbnNfZnJvbSAvIEJ5dGVzLmNvbnRhaW5zX2Zyb21cIlxuICBlbHNlXG4gICAgdHJ5IGlnbm9yZSAoaW5kZXhfcmVjIHMgbCBpIGMpOyB0cnVlIHdpdGggTm90X2ZvdW5kIC0+IGZhbHNlXG5cblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBjb250YWlucyBzIGMgPSBjb250YWluc19mcm9tIHMgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmNvbnRhaW5zX2Zyb20gcyBpIGMgPVxuICBpZiBpIDwgMCB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yY29udGFpbnNfZnJvbSAvIEJ5dGVzLnJjb250YWluc19mcm9tXCJcbiAgZWxzZVxuICAgIHRyeSBpZ25vcmUgKHJpbmRleF9yZWMgcyBpIGMpOyB0cnVlIHdpdGggTm90X2ZvdW5kIC0+IGZhbHNlXG5cblxudHlwZSB0ID0gYnl0ZXNcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFBlcnZhc2l2ZXMuY29tcGFyZSB4IHlcbmV4dGVybmFsIGVxdWFsIDogdCAtPiB0IC0+IGJvb2wgPSBcImNhbWxfYnl0ZXNfZXF1YWxcIlxuXG4oKiBEZXByZWNhdGVkIGZ1bmN0aW9ucyBpbXBsZW1lbnRlZCB2aWEgb3RoZXIgZGVwcmVjYXRlZCBmdW5jdGlvbnMgKilcbltAQEBvY2FtbC53YXJuaW5nIFwiLTNcIl1cbmxldCB1cHBlcmNhc2UgcyA9IG1hcCBDaGFyLnVwcGVyY2FzZSBzXG5sZXQgbG93ZXJjYXNlIHMgPSBtYXAgQ2hhci5sb3dlcmNhc2Ugc1xuXG5sZXQgY2FwaXRhbGl6ZSBzID0gYXBwbHkxIENoYXIudXBwZXJjYXNlIHNcbmxldCB1bmNhcGl0YWxpemUgcyA9IGFwcGx5MSBDaGFyLmxvd2VyY2FzZSBzXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBHYWxsaXVtLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE0IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFN0cmluZyBvcGVyYXRpb25zLCBiYXNlZCBvbiBieXRlIHNlcXVlbmNlIG9wZXJhdGlvbnMgKilcblxuKCogV0FSTklORzogU29tZSBmdW5jdGlvbnMgaW4gdGhpcyBmaWxlIGFyZSBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sIGZvclxuICAgZWZmaWNpZW5jeSByZWFzb25zLiBXaGVuIHlvdSBtb2RpZnkgdGhlIG9uZSBpbiB0aGlzIGZpbGUgeW91IG5lZWQgdG9cbiAgIG1vZGlmeSBpdHMgZHVwbGljYXRlIGluIGJ5dGVzLm1sLlxuICAgVGhlc2UgZnVuY3Rpb25zIGhhdmUgYSBcImR1cGxpY2F0ZWRcIiBjb21tZW50IGFib3ZlIHRoZWlyIGRlZmluaXRpb24uXG4qKVxuXG5leHRlcm5hbCBsZW5ndGggOiBzdHJpbmcgLT4gaW50ID0gXCIlc3RyaW5nX2xlbmd0aFwiXG5leHRlcm5hbCBnZXQgOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgPSBcIiVzdHJpbmdfc2FmZV9nZXRcIlxuZXh0ZXJuYWwgc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJXN0cmluZ19zYWZlX3NldFwiXG5leHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gYnl0ZXMgPSBcImNhbWxfY3JlYXRlX3N0cmluZ1wiXG5leHRlcm5hbCB1bnNhZmVfZ2V0IDogc3RyaW5nIC0+IGludCAtPiBjaGFyID0gXCIlc3RyaW5nX3Vuc2FmZV9nZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyIC0+IHVuaXQgPSBcIiVzdHJpbmdfdW5zYWZlX3NldFwiXG5leHRlcm5hbCB1bnNhZmVfYmxpdCA6IHN0cmluZyAtPiBpbnQgLT4gIGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdW5zYWZlX2ZpbGwgOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IGNoYXIgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfZmlsbF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuXG5tb2R1bGUgQiA9IEJ5dGVzXG5cbmxldCBidHMgPSBCLnVuc2FmZV90b19zdHJpbmdcbmxldCBib3MgPSBCLnVuc2FmZV9vZl9zdHJpbmdcblxubGV0IG1ha2UgbiBjID1cbiAgQi5tYWtlIG4gYyB8PiBidHNcbmxldCBpbml0IG4gZiA9XG4gIEIuaW5pdCBuIGYgfD4gYnRzXG5sZXQgY29weSBzID1cbiAgQi5jb3B5IChib3MgcykgfD4gYnRzXG5sZXQgc3ViIHMgb2ZzIGxlbiA9XG4gIEIuc3ViIChib3Mgcykgb2ZzIGxlbiB8PiBidHNcbmxldCBmaWxsID1cbiAgQi5maWxsXG5sZXQgYmxpdCA9XG4gIEIuYmxpdF9zdHJpbmdcblxubGV0IGVuc3VyZV9nZSAoeDppbnQpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgaW52YWxpZF9hcmcgXCJTdHJpbmcuY29uY2F0XCJcblxubGV0IHJlYyBzdW1fbGVuZ3RocyBhY2Mgc2VwbGVuID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBhY2NcbiAgfCBoZCA6OiBbXSAtPiBsZW5ndGggaGQgKyBhY2NcbiAgfCBoZCA6OiB0bCAtPiBzdW1fbGVuZ3RocyAoZW5zdXJlX2dlIChsZW5ndGggaGQgKyBzZXBsZW4gKyBhY2MpIGFjYykgc2VwbGVuIHRsXG5cbmxldCByZWMgdW5zYWZlX2JsaXRzIGRzdCBwb3Mgc2VwIHNlcGxlbiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZHN0XG4gIHwgaGQgOjogW10gLT5cbiAgICB1bnNhZmVfYmxpdCBoZCAwIGRzdCBwb3MgKGxlbmd0aCBoZCk7IGRzdFxuICB8IGhkIDo6IHRsIC0+XG4gICAgdW5zYWZlX2JsaXQgaGQgMCBkc3QgcG9zIChsZW5ndGggaGQpO1xuICAgIHVuc2FmZV9ibGl0IHNlcCAwIGRzdCAocG9zICsgbGVuZ3RoIGhkKSBzZXBsZW47XG4gICAgdW5zYWZlX2JsaXRzIGRzdCAocG9zICsgbGVuZ3RoIGhkICsgc2VwbGVuKSBzZXAgc2VwbGVuIHRsXG5cbmxldCBjb25jYXQgc2VwID0gZnVuY3Rpb25cbiAgICBbXSAtPiBcIlwiXG4gIHwgbCAtPiBsZXQgc2VwbGVuID0gbGVuZ3RoIHNlcCBpbiBidHMgQEBcbiAgICAgICAgICB1bnNhZmVfYmxpdHNcbiAgICAgICAgICAgIChCLmNyZWF0ZSAoc3VtX2xlbmd0aHMgMCBzZXBsZW4gbCkpXG4gICAgICAgICAgICAwIHNlcCBzZXBsZW4gbFxuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaXRlciBmIHMgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvIGYgKHVuc2FmZV9nZXQgcyBpKSBkb25lXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpdGVyaSBmIHMgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvIGYgaSAodW5zYWZlX2dldCBzIGkpIGRvbmVcblxubGV0IG1hcCBmIHMgPVxuICBCLm1hcCBmIChib3MgcykgfD4gYnRzXG5sZXQgbWFwaSBmIHMgPVxuICBCLm1hcGkgZiAoYm9zIHMpIHw+IGJ0c1xuXG4oKiBCZXdhcmU6IHdlIGNhbm5vdCB1c2UgQi50cmltIG9yIEIuZXNjYXBlIGJlY2F1c2UgdGhleSBhbHdheXMgbWFrZSBhXG4gICBjb3B5LCBidXQgU3RyaW5nLm1saSBzcGVsbHMgb3V0IHNvbWUgY2FzZXMgd2hlcmUgd2UgYXJlIG5vdCBhbGxvd2VkXG4gICB0byBtYWtlIGEgY29weS4gKilcblxubGV0IGlzX3NwYWNlID0gZnVuY3Rpb25cbiAgfCAnICcgfCAnXFwwMTInIHwgJ1xcbicgfCAnXFxyJyB8ICdcXHQnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cbmxldCB0cmltIHMgPVxuICBpZiBzID0gXCJcIiB0aGVuIHNcbiAgZWxzZSBpZiBpc19zcGFjZSAodW5zYWZlX2dldCBzIDApIHx8IGlzX3NwYWNlICh1bnNhZmVfZ2V0IHMgKGxlbmd0aCBzIC0gMSkpXG4gICAgdGhlbiBidHMgKEIudHJpbSAoYm9zIHMpKVxuICBlbHNlIHNcblxubGV0IGVzY2FwZWQgcyA9XG4gIGxldCByZWMgbmVlZHNfZXNjYXBlIGkgPVxuICAgIGlmIGkgPj0gbGVuZ3RoIHMgdGhlbiBmYWxzZSBlbHNlXG4gICAgICBtYXRjaCB1bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICB8ICdcXFwiJyB8ICdcXFxcJyB8ICdcXG4nIHwgJ1xcdCcgfCAnXFxyJyB8ICdcXGInIC0+IHRydWVcbiAgICAgIHwgJyAnIC4uICd+JyAtPiBuZWVkc19lc2NhcGUgKGkrMSlcbiAgICAgIHwgXyAtPiB0cnVlXG4gIGluXG4gIGlmIG5lZWRzX2VzY2FwZSAwIHRoZW5cbiAgICBidHMgKEIuZXNjYXBlZCAoYm9zIHMpKVxuICBlbHNlXG4gICAgc1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmVjIGluZGV4X3JlYyBzIGxpbSBpIGMgPVxuICBpZiBpID49IGxpbSB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIGkgZWxzZSBpbmRleF9yZWMgcyBsaW0gKGkgKyAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpbmRleCBzIGMgPSBpbmRleF9yZWMgcyAobGVuZ3RoIHMpIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmVjIGluZGV4X3JlY19vcHQgcyBsaW0gaSBjID1cbiAgaWYgaSA+PSBsaW0gdGhlbiBOb25lIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gU29tZSBpIGVsc2UgaW5kZXhfcmVjX29wdCBzIGxpbSAoaSArIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGluZGV4X29wdCBzIGMgPSBpbmRleF9yZWNfb3B0IHMgKGxlbmd0aCBzKSAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGluZGV4X2Zyb20gcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuaW5kZXhfZnJvbSAvIEJ5dGVzLmluZGV4X2Zyb21cIiBlbHNlXG4gICAgaW5kZXhfcmVjIHMgbCBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGluZGV4X2Zyb21fb3B0IHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLmluZGV4X2Zyb21fb3B0IC8gQnl0ZXMuaW5kZXhfZnJvbV9vcHRcIiBlbHNlXG4gIGluZGV4X3JlY19vcHQgcyBsIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmVjIHJpbmRleF9yZWMgcyBpIGMgPVxuICBpZiBpIDwgMCB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIGkgZWxzZSByaW5kZXhfcmVjIHMgKGkgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByaW5kZXggcyBjID0gcmluZGV4X3JlYyBzIChsZW5ndGggcyAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJpbmRleF9mcm9tIHMgaSBjID1cbiAgaWYgaSA8IC0xIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJpbmRleF9mcm9tIC8gQnl0ZXMucmluZGV4X2Zyb21cIlxuICBlbHNlXG4gICAgcmluZGV4X3JlYyBzIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmVjIHJpbmRleF9yZWNfb3B0IHMgaSBjID1cbiAgaWYgaSA8IDAgdGhlbiBOb25lIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gU29tZSBpIGVsc2UgcmluZGV4X3JlY19vcHQgcyAoaSAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJpbmRleF9vcHQgcyBjID0gcmluZGV4X3JlY19vcHQgcyAobGVuZ3RoIHMgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByaW5kZXhfZnJvbV9vcHQgcyBpIGMgPVxuICBpZiBpIDwgLTEgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmluZGV4X2Zyb21fb3B0IC8gQnl0ZXMucmluZGV4X2Zyb21fb3B0XCJcbiAgZWxzZVxuICAgIHJpbmRleF9yZWNfb3B0IHMgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBjb250YWluc19mcm9tIHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcuY29udGFpbnNfZnJvbSAvIEJ5dGVzLmNvbnRhaW5zX2Zyb21cIlxuICBlbHNlXG4gICAgdHJ5IGlnbm9yZSAoaW5kZXhfcmVjIHMgbCBpIGMpOyB0cnVlIHdpdGggTm90X2ZvdW5kIC0+IGZhbHNlXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBjb250YWlucyBzIGMgPSBjb250YWluc19mcm9tIHMgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByY29udGFpbnNfZnJvbSBzIGkgYyA9XG4gIGlmIGkgPCAwIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJjb250YWluc19mcm9tIC8gQnl0ZXMucmNvbnRhaW5zX2Zyb21cIlxuICBlbHNlXG4gICAgdHJ5IGlnbm9yZSAocmluZGV4X3JlYyBzIGkgYyk7IHRydWUgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcblxubGV0IHVwcGVyY2FzZV9hc2NpaSBzID1cbiAgQi51cHBlcmNhc2VfYXNjaWkgKGJvcyBzKSB8PiBidHNcbmxldCBsb3dlcmNhc2VfYXNjaWkgcyA9XG4gIEIubG93ZXJjYXNlX2FzY2lpIChib3MgcykgfD4gYnRzXG5sZXQgY2FwaXRhbGl6ZV9hc2NpaSBzID1cbiAgQi5jYXBpdGFsaXplX2FzY2lpIChib3MgcykgfD4gYnRzXG5sZXQgdW5jYXBpdGFsaXplX2FzY2lpIHMgPVxuICBCLnVuY2FwaXRhbGl6ZV9hc2NpaSAoYm9zIHMpIHw+IGJ0c1xuXG50eXBlIHQgPSBzdHJpbmdcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFBlcnZhc2l2ZXMuY29tcGFyZSB4IHlcbmV4dGVybmFsIGVxdWFsIDogc3RyaW5nIC0+IHN0cmluZyAtPiBib29sID0gXCJjYW1sX3N0cmluZ19lcXVhbFwiXG5cbmxldCBzcGxpdF9vbl9jaGFyIHNlcCBzID1cbiAgbGV0IHIgPSByZWYgW10gaW5cbiAgbGV0IGogPSByZWYgKGxlbmd0aCBzKSBpblxuICBmb3IgaSA9IGxlbmd0aCBzIC0gMSBkb3dudG8gMCBkb1xuICAgIGlmIHVuc2FmZV9nZXQgcyBpID0gc2VwIHRoZW4gYmVnaW5cbiAgICAgIHIgOj0gc3ViIHMgKGkgKyAxKSAoIWogLSBpIC0gMSkgOjogIXI7XG4gICAgICBqIDo9IGlcbiAgICBlbmRcbiAgZG9uZTtcbiAgc3ViIHMgMCAhaiA6OiAhclxuXG4oKiBEZXByZWNhdGVkIGZ1bmN0aW9ucyBpbXBsZW1lbnRlZCB2aWEgb3RoZXIgZGVwcmVjYXRlZCBmdW5jdGlvbnMgKilcbltAQEBvY2FtbC53YXJuaW5nIFwiLTNcIl1cbmxldCB1cHBlcmNhc2UgcyA9XG4gIEIudXBwZXJjYXNlIChib3MgcykgfD4gYnRzXG5sZXQgbG93ZXJjYXNlIHMgPVxuICBCLmxvd2VyY2FzZSAoYm9zIHMpIHw+IGJ0c1xubGV0IGNhcGl0YWxpemUgcyA9XG4gIEIuY2FwaXRhbGl6ZSAoYm9zIHMpIHw+IGJ0c1xubGV0IHVuY2FwaXRhbGl6ZSBzID1cbiAgQi51bmNhcGl0YWxpemUgKGJvcyBzKSB8PiBidHNcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtOYXRpdmVpbnRdOiBwcm9jZXNzb3ItbmF0aXZlIGludGVnZXJzICopXG5cbmV4dGVybmFsIG5lZzogbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9uZWdcIlxuZXh0ZXJuYWwgYWRkOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9hZGRcIlxuZXh0ZXJuYWwgc3ViOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9zdWJcIlxuZXh0ZXJuYWwgbXVsOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9tdWxcIlxuZXh0ZXJuYWwgZGl2OiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9kaXZcIlxuZXh0ZXJuYWwgcmVtOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9tb2RcIlxuZXh0ZXJuYWwgbG9nYW5kOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9hbmRcIlxuZXh0ZXJuYWwgbG9nb3I6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X29yXCJcbmV4dGVybmFsIGxvZ3hvcjogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfeG9yXCJcbmV4dGVybmFsIHNoaWZ0X2xlZnQ6IG5hdGl2ZWludCAtPiBpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2xzbFwiXG5leHRlcm5hbCBzaGlmdF9yaWdodDogbmF0aXZlaW50IC0+IGludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfYXNyXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0X2xvZ2ljYWw6IG5hdGl2ZWludCAtPiBpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2xzclwiXG5leHRlcm5hbCBvZl9pbnQ6IGludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfb2ZfaW50XCJcbmV4dGVybmFsIHRvX2ludDogbmF0aXZlaW50IC0+IGludCA9IFwiJW5hdGl2ZWludF90b19pbnRcIlxuZXh0ZXJuYWwgb2ZfZmxvYXQgOiBmbG9hdCAtPiBuYXRpdmVpbnRcbiAgPSBcImNhbWxfbmF0aXZlaW50X29mX2Zsb2F0XCIgXCJjYW1sX25hdGl2ZWludF9vZl9mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRvX2Zsb2F0IDogbmF0aXZlaW50IC0+IGZsb2F0XG4gID0gXCJjYW1sX25hdGl2ZWludF90b19mbG9hdFwiIFwiY2FtbF9uYXRpdmVpbnRfdG9fZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBvZl9pbnQzMjogaW50MzIgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X29mX2ludDMyXCJcbmV4dGVybmFsIHRvX2ludDMyOiBuYXRpdmVpbnQgLT4gaW50MzIgPSBcIiVuYXRpdmVpbnRfdG9faW50MzJcIlxuXG5sZXQgemVybyA9IDBuXG5sZXQgb25lID0gMW5cbmxldCBtaW51c19vbmUgPSAtMW5cbmxldCBzdWNjIG4gPSBhZGQgbiAxblxubGV0IHByZWQgbiA9IHN1YiBuIDFuXG5sZXQgYWJzIG4gPSBpZiBuID49IDBuIHRoZW4gbiBlbHNlIG5lZyBuXG5sZXQgc2l6ZSA9IFN5cy53b3JkX3NpemVcbmxldCBtaW5faW50ID0gc2hpZnRfbGVmdCAxbiAoc2l6ZSAtIDEpXG5sZXQgbWF4X2ludCA9IHN1YiBtaW5faW50IDFuXG5sZXQgbG9nbm90IG4gPSBsb2d4b3IgbiAoLTFuKVxuXG5leHRlcm5hbCBmb3JtYXQgOiBzdHJpbmcgLT4gbmF0aXZlaW50IC0+IHN0cmluZyA9IFwiY2FtbF9uYXRpdmVpbnRfZm9ybWF0XCJcbmxldCB0b19zdHJpbmcgbiA9IGZvcm1hdCBcIiVkXCIgblxuXG5leHRlcm5hbCBvZl9zdHJpbmc6IHN0cmluZyAtPiBuYXRpdmVpbnQgPSBcImNhbWxfbmF0aXZlaW50X29mX3N0cmluZ1wiXG5cbmxldCBvZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBleHBvc2UgYSBub24tcmFpc2luZyBwcmltaXRpdmUgZGlyZWN0bHkuICopXG4gIHRyeSBTb21lIChvZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG50eXBlIHQgPSBuYXRpdmVpbnRcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFBlcnZhc2l2ZXMuY29tcGFyZSB4IHlcbmxldCBlcXVhbCAoeDogdCkgKHk6IHQpID0gY29tcGFyZSB4IHkgPSAwXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1lcmdpbmcgYW5kIHNvcnRpbmcgKilcblxub3BlbiBBcnJheVxuXG5sZXQgcmVjIG1lcmdlIG9yZGVyIGwxIGwyID1cbiAgbWF0Y2ggbDEgd2l0aFxuICAgIFtdIC0+IGwyXG4gIHwgaDEgOjogdDEgLT5cbiAgICAgIG1hdGNoIGwyIHdpdGhcbiAgICAgICAgW10gLT4gbDFcbiAgICAgIHwgaDIgOjogdDIgLT5cbiAgICAgICAgICBpZiBvcmRlciBoMSBoMlxuICAgICAgICAgIHRoZW4gaDEgOjogbWVyZ2Ugb3JkZXIgdDEgbDJcbiAgICAgICAgICBlbHNlIGgyIDo6IG1lcmdlIG9yZGVyIGwxIHQyXG5cbmxldCBsaXN0IG9yZGVyIGwgPVxuICBsZXQgcmVjIGluaXRsaXN0ID0gZnVuY3Rpb25cbiAgICAgIFtdIC0+IFtdXG4gICAgfCBbZV0gLT4gW1tlXV1cbiAgICB8IGUxOjplMjo6cmVzdCAtPlxuICAgICAgICAoaWYgb3JkZXIgZTEgZTIgdGhlbiBbZTE7ZTJdIGVsc2UgW2UyO2UxXSkgOjogaW5pdGxpc3QgcmVzdCBpblxuICBsZXQgcmVjIG1lcmdlMiA9IGZ1bmN0aW9uXG4gICAgICBsMTo6bDI6OnJlc3QgLT4gbWVyZ2Ugb3JkZXIgbDEgbDIgOjogbWVyZ2UyIHJlc3RcbiAgICB8IHggLT4geCBpblxuICBsZXQgcmVjIG1lcmdlYWxsID0gZnVuY3Rpb25cbiAgICAgIFtdIC0+IFtdXG4gICAgfCBbbF0gLT4gbFxuICAgIHwgbGxpc3QgLT4gbWVyZ2VhbGwgKG1lcmdlMiBsbGlzdCkgaW5cbiAgbWVyZ2VhbGwoaW5pdGxpc3QgbClcblxubGV0IHN3YXAgYXJyIGkgaiA9XG4gIGxldCB0bXAgPSB1bnNhZmVfZ2V0IGFyciBpIGluXG4gIHVuc2FmZV9zZXQgYXJyIGkgKHVuc2FmZV9nZXQgYXJyIGopO1xuICB1bnNhZmVfc2V0IGFyciBqIHRtcFxuXG4oKiBUaGVyZSBpcyBhIGtub3duIHBlcmZvcm1hbmNlIGJ1ZyBpbiB0aGUgY29kZSBiZWxvdy4gIElmIHlvdSBmaW5kXG4gICBpdCwgZG9uJ3QgYm90aGVyIHJlcG9ydGluZyBpdC4gIFlvdSdyZSBub3Qgc3VwcG9zZWQgdG8gdXNlIHRoaXNcbiAgIG1vZHVsZSBhbnl3YXkuICopXG5sZXQgYXJyYXkgY21wIGFyciA9XG4gIGxldCByZWMgcXNvcnQgbG8gaGkgPVxuICAgIGlmIGhpIC0gbG8gPj0gNiB0aGVuIGJlZ2luXG4gICAgICBsZXQgbWlkID0gKGxvICsgaGkpIGxzciAxIGluXG4gICAgICAoKiBTZWxlY3QgbWVkaWFuIHZhbHVlIGZyb20gYW1vbmcgTE8sIE1JRCwgYW5kIEhJLiBSZWFycmFuZ2VcbiAgICAgICAgIExPIGFuZCBISSBzbyB0aGUgdGhyZWUgdmFsdWVzIGFyZSBzb3J0ZWQuIFRoaXMgbG93ZXJzIHRoZVxuICAgICAgICAgcHJvYmFiaWxpdHkgb2YgcGlja2luZyBhIHBhdGhvbG9naWNhbCBwaXZvdC4gIEl0IGFsc29cbiAgICAgICAgIGF2b2lkcyBleHRyYSBjb21wYXJpc29ucyBvbiBpIGFuZCBqIGluIHRoZSB0d28gdGlnaHQgXCJ3aGlsZVwiXG4gICAgICAgICBsb29wcyBiZWxvdy4gKilcbiAgICAgIGlmIGNtcCAodW5zYWZlX2dldCBhcnIgbWlkKSAodW5zYWZlX2dldCBhcnIgbG8pIHRoZW4gc3dhcCBhcnIgbWlkIGxvO1xuICAgICAgaWYgY21wICh1bnNhZmVfZ2V0IGFyciBoaSkgKHVuc2FmZV9nZXQgYXJyIG1pZCkgdGhlbiBiZWdpblxuICAgICAgICBzd2FwIGFyciBtaWQgaGk7XG4gICAgICAgIGlmIGNtcCAodW5zYWZlX2dldCBhcnIgbWlkKSAodW5zYWZlX2dldCBhcnIgbG8pIHRoZW4gc3dhcCBhcnIgbWlkIGxvXG4gICAgICBlbmQ7XG4gICAgICBsZXQgcGl2b3QgPSB1bnNhZmVfZ2V0IGFyciBtaWQgaW5cbiAgICAgIGxldCBpID0gcmVmIChsbyArIDEpIGFuZCBqID0gcmVmIChoaSAtIDEpIGluXG4gICAgICBpZiBub3QgKGNtcCBwaXZvdCAodW5zYWZlX2dldCBhcnIgaGkpKVxuICAgICAgICAgfHwgbm90IChjbXAgKHVuc2FmZV9nZXQgYXJyIGxvKSBwaXZvdClcbiAgICAgIHRoZW4gcmFpc2UgKEludmFsaWRfYXJndW1lbnQgXCJTb3J0LmFycmF5XCIpO1xuICAgICAgd2hpbGUgIWkgPCAhaiBkb1xuICAgICAgICB3aGlsZSBub3QgKGNtcCBwaXZvdCAodW5zYWZlX2dldCBhcnIgIWkpKSBkbyBpbmNyIGkgZG9uZTtcbiAgICAgICAgd2hpbGUgbm90IChjbXAgKHVuc2FmZV9nZXQgYXJyICFqKSBwaXZvdCkgZG8gZGVjciBqIGRvbmU7XG4gICAgICAgIGlmICFpIDwgIWogdGhlbiBzd2FwIGFyciAhaSAhajtcbiAgICAgICAgaW5jciBpOyBkZWNyIGpcbiAgICAgIGRvbmU7XG4gICAgICAoKiBSZWN1cnNpb24gb24gc21hbGxlciBoYWxmLCB0YWlsLWNhbGwgb24gbGFyZ2VyIGhhbGYgKilcbiAgICAgIGlmICFqIC0gbG8gPD0gaGkgLSAhaSB0aGVuIGJlZ2luXG4gICAgICAgIHFzb3J0IGxvICFqOyBxc29ydCAhaSBoaVxuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgcXNvcnQgIWkgaGk7IHFzb3J0IGxvICFqXG4gICAgICBlbmRcbiAgICBlbmQgaW5cbiAgcXNvcnQgMCAoQXJyYXkubGVuZ3RoIGFyciAtIDEpO1xuICAoKiBGaW5pc2ggc29ydGluZyBieSBpbnNlcnRpb24gc29ydCAqKVxuICBmb3IgaSA9IDEgdG8gQXJyYXkubGVuZ3RoIGFyciAtIDEgZG9cbiAgICBsZXQgdmFsX2kgPSAodW5zYWZlX2dldCBhcnIgaSkgaW5cbiAgICBpZiBub3QgKGNtcCAodW5zYWZlX2dldCBhcnIgKGkgLSAxKSkgdmFsX2kpIHRoZW4gYmVnaW5cbiAgICAgIHVuc2FmZV9zZXQgYXJyIGkgKHVuc2FmZV9nZXQgYXJyIChpIC0gMSkpO1xuICAgICAgbGV0IGogPSByZWYgKGkgLSAxKSBpblxuICAgICAgd2hpbGUgIWogPj0gMSAmJiBub3QgKGNtcCAodW5zYWZlX2dldCBhcnIgKCFqIC0gMSkpIHZhbF9pKSBkb1xuICAgICAgICB1bnNhZmVfc2V0IGFyciAhaiAodW5zYWZlX2dldCBhcnIgKCFqIC0gMSkpO1xuICAgICAgICBkZWNyIGpcbiAgICAgIGRvbmU7XG4gICAgICB1bnNhZmVfc2V0IGFyciAhaiB2YWxfaVxuICAgIGVuZFxuICBkb25lXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgZXh0ZXJuX2ZsYWdzID1cbiAgICBOb19zaGFyaW5nXG4gIHwgQ2xvc3VyZXNcbiAgfCBDb21wYXRfMzJcbigqIG5vdGU6IHRoaXMgdHlwZSBkZWZpbml0aW9uIGlzIHVzZWQgaW4gJ2J5dGVydW4vZGVidWdnZXIuYycgKilcblxuZXh0ZXJuYWwgdG9fY2hhbm5lbDogb3V0X2NoYW5uZWwgLT4gJ2EgLT4gZXh0ZXJuX2ZsYWdzIGxpc3QgLT4gdW5pdFxuICAgID0gXCJjYW1sX291dHB1dF92YWx1ZVwiXG5leHRlcm5hbCB0b19ieXRlczogJ2EgLT4gZXh0ZXJuX2ZsYWdzIGxpc3QgLT4gYnl0ZXNcbiAgICA9IFwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nXCJcbmV4dGVybmFsIHRvX3N0cmluZzogJ2EgLT4gZXh0ZXJuX2ZsYWdzIGxpc3QgLT4gc3RyaW5nXG4gICAgPSBcImNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZ1wiXG5leHRlcm5hbCB0b19idWZmZXJfdW5zYWZlOlxuICAgICAgYnl0ZXMgLT4gaW50IC0+IGludCAtPiAnYSAtPiBleHRlcm5fZmxhZ3MgbGlzdCAtPiBpbnRcbiAgICA9IFwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnVmZmVyXCJcblxubGV0IHRvX2J1ZmZlciBidWZmIG9mcyBsZW4gdiBmbGFncyA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBCeXRlcy5sZW5ndGggYnVmZiAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiTWFyc2hhbC50b19idWZmZXI6IHN1YnN0cmluZyBvdXQgb2YgYm91bmRzXCJcbiAgZWxzZSB0b19idWZmZXJfdW5zYWZlIGJ1ZmYgb2ZzIGxlbiB2IGZsYWdzXG5cbigqIFRoZSBmdW5jdGlvbnMgYmVsb3cgdXNlIGJ5dGUgc2VxdWVuY2VzIGFzIGlucHV0LCBuZXZlciB1c2luZyBhbnlcbiAgIG11dGF0aW9uLiBJdCBtYWtlcyBzZW5zZSB0byB1c2Ugbm9uLW11dGF0ZWQgW2J5dGVzXSByYXRoZXIgdGhhblxuICAgW3N0cmluZ10sIGJlY2F1c2Ugd2UgcmVhbGx5IHdvcmsgd2l0aCBzZXF1ZW5jZXMgb2YgYnl0ZXMsIG5vdFxuICAgYSB0ZXh0IHJlcHJlc2VudGF0aW9uLlxuKilcblxuZXh0ZXJuYWwgZnJvbV9jaGFubmVsOiBpbl9jaGFubmVsIC0+ICdhID0gXCJjYW1sX2lucHV0X3ZhbHVlXCJcbmV4dGVybmFsIGZyb21fYnl0ZXNfdW5zYWZlOiBieXRlcyAtPiBpbnQgLT4gJ2FcbiAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2lucHV0X3ZhbHVlX2Zyb21fc3RyaW5nXCJcbmV4dGVybmFsIGRhdGFfc2l6ZV91bnNhZmU6IGJ5dGVzIC0+IGludCAtPiBpbnQgPSBcImNhbWxfbWFyc2hhbF9kYXRhX3NpemVcIlxuXG5sZXQgaGVhZGVyX3NpemUgPSAyMFxubGV0IGRhdGFfc2l6ZSBidWZmIG9mcyA9XG4gIGlmIG9mcyA8IDAgfHwgb2ZzID4gQnl0ZXMubGVuZ3RoIGJ1ZmYgLSBoZWFkZXJfc2l6ZVxuICB0aGVuIGludmFsaWRfYXJnIFwiTWFyc2hhbC5kYXRhX3NpemVcIlxuICBlbHNlIGRhdGFfc2l6ZV91bnNhZmUgYnVmZiBvZnNcbmxldCB0b3RhbF9zaXplIGJ1ZmYgb2ZzID0gaGVhZGVyX3NpemUgKyBkYXRhX3NpemUgYnVmZiBvZnNcblxubGV0IGZyb21fYnl0ZXMgYnVmZiBvZnMgPVxuICBpZiBvZnMgPCAwIHx8IG9mcyA+IEJ5dGVzLmxlbmd0aCBidWZmIC0gaGVhZGVyX3NpemVcbiAgdGhlbiBpbnZhbGlkX2FyZyBcIk1hcnNoYWwuZnJvbV9ieXRlc1wiXG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgbGVuID0gZGF0YV9zaXplX3Vuc2FmZSBidWZmIG9mcyBpblxuICAgIGlmIG9mcyA+IEJ5dGVzLmxlbmd0aCBidWZmIC0gKGhlYWRlcl9zaXplICsgbGVuKVxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJNYXJzaGFsLmZyb21fYnl0ZXNcIlxuICAgIGVsc2UgZnJvbV9ieXRlc191bnNhZmUgYnVmZiBvZnNcbiAgZW5kXG5cbmxldCBmcm9tX3N0cmluZyBidWZmIG9mcyA9XG4gICgqIEJ5dGVzLnVuc2FmZV9vZl9zdHJpbmcgaXMgc2FmZSBoZXJlLCBhcyB0aGUgcHJvZHVjZWQgYnl0ZVxuICAgICBzZXF1ZW5jZSBpcyBuZXZlciBtdXRhdGVkICopXG4gIGZyb21fYnl0ZXMgKEJ5dGVzLnVuc2FmZV9vZl9zdHJpbmcgYnVmZikgb2ZzXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE9wZXJhdGlvbnMgb24gaW50ZXJuYWwgcmVwcmVzZW50YXRpb25zIG9mIHZhbHVlcyAqKVxuXG50eXBlIHRcblxuZXh0ZXJuYWwgcmVwciA6ICdhIC0+IHQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBvYmogOiB0IC0+ICdhID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgbWFnaWMgOiAnYSAtPiAnYiA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIGlzX2ludCA6IHQgLT4gYm9vbCA9IFwiJW9ial9pc19pbnRcIlxubGV0IFtAaW5saW5lIGFsd2F5c10gaXNfYmxvY2sgYSA9IG5vdCAoaXNfaW50IGEpXG5leHRlcm5hbCB0YWcgOiB0IC0+IGludCA9IFwiY2FtbF9vYmpfdGFnXCJcbmV4dGVybmFsIHNldF90YWcgOiB0IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX29ial9zZXRfdGFnXCJcbmV4dGVybmFsIHNpemUgOiB0IC0+IGludCA9IFwiJW9ial9zaXplXCJcbmV4dGVybmFsIHJlYWNoYWJsZV93b3JkcyA6IHQgLT4gaW50ID0gXCJjYW1sX29ial9yZWFjaGFibGVfd29yZHNcIlxuZXh0ZXJuYWwgZmllbGQgOiB0IC0+IGludCAtPiB0ID0gXCIlb2JqX2ZpZWxkXCJcbmV4dGVybmFsIHNldF9maWVsZCA6IHQgLT4gaW50IC0+IHQgLT4gdW5pdCA9IFwiJW9ial9zZXRfZmllbGRcIlxuZXh0ZXJuYWwgZmxvYXRhcnJheV9nZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCA9IFwiY2FtbF9mbG9hdGFycmF5X2dldFwiXG5leHRlcm5hbCBmbG9hdGFycmF5X3NldCA6XG4gICAgZmxvYXRhcnJheSAtPiBpbnQgLT4gZmxvYXQgLT4gdW5pdCA9IFwiY2FtbF9mbG9hdGFycmF5X3NldFwiXG5sZXQgW0BpbmxpbmUgYWx3YXlzXSBkb3VibGVfZmllbGQgeCBpID0gZmxvYXRhcnJheV9nZXQgKG9iaiB4IDogZmxvYXRhcnJheSkgaVxubGV0IFtAaW5saW5lIGFsd2F5c10gc2V0X2RvdWJsZV9maWVsZCB4IGkgdiA9XG4gIGZsb2F0YXJyYXlfc2V0IChvYmogeCA6IGZsb2F0YXJyYXkpIGkgdlxuZXh0ZXJuYWwgbmV3X2Jsb2NrIDogaW50IC0+IGludCAtPiB0ID0gXCJjYW1sX29ial9ibG9ja1wiXG5leHRlcm5hbCBkdXAgOiB0IC0+IHQgPSBcImNhbWxfb2JqX2R1cFwiXG5leHRlcm5hbCB0cnVuY2F0ZSA6IHQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfb2JqX3RydW5jYXRlXCJcbmV4dGVybmFsIGFkZF9vZmZzZXQgOiB0IC0+IEludDMyLnQgLT4gdCA9IFwiY2FtbF9vYmpfYWRkX29mZnNldFwiXG5cbmxldCBtYXJzaGFsIChvYmogOiB0KSA9XG4gIE1hcnNoYWwudG9fYnl0ZXMgb2JqIFtdXG5sZXQgdW5tYXJzaGFsIHN0ciBwb3MgPVxuICAoTWFyc2hhbC5mcm9tX2J5dGVzIHN0ciBwb3MsIHBvcyArIE1hcnNoYWwudG90YWxfc2l6ZSBzdHIgcG9zKVxuXG5sZXQgZmlyc3Rfbm9uX2NvbnN0YW50X2NvbnN0cnVjdG9yX3RhZyA9IDBcbmxldCBsYXN0X25vbl9jb25zdGFudF9jb25zdHJ1Y3Rvcl90YWcgPSAyNDVcblxubGV0IGxhenlfdGFnID0gMjQ2XG5sZXQgY2xvc3VyZV90YWcgPSAyNDdcbmxldCBvYmplY3RfdGFnID0gMjQ4XG5sZXQgaW5maXhfdGFnID0gMjQ5XG5sZXQgZm9yd2FyZF90YWcgPSAyNTBcblxubGV0IG5vX3NjYW5fdGFnID0gMjUxXG5cbmxldCBhYnN0cmFjdF90YWcgPSAyNTFcbmxldCBzdHJpbmdfdGFnID0gMjUyXG5sZXQgZG91YmxlX3RhZyA9IDI1M1xubGV0IGRvdWJsZV9hcnJheV90YWcgPSAyNTRcbmxldCBjdXN0b21fdGFnID0gMjU1XG5sZXQgZmluYWxfdGFnID0gY3VzdG9tX3RhZ1xuXG5cbmxldCBpbnRfdGFnID0gMTAwMFxubGV0IG91dF9vZl9oZWFwX3RhZyA9IDEwMDFcbmxldCB1bmFsaWduZWRfdGFnID0gMTAwMlxuXG5sZXQgZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIHggPVxuICBsZXQgeCA9IHJlcHIgeCBpblxuICBsZXQgc2xvdCA9XG4gICAgaWYgKGlzX2Jsb2NrIHgpICYmICh0YWcgeCkgPD4gb2JqZWN0X3RhZyAmJiAoc2l6ZSB4KSA+PSAxIHRoZW4gZmllbGQgeCAwXG4gICAgZWxzZSB4XG4gIGluXG4gIGxldCBuYW1lID1cbiAgICBpZiAoaXNfYmxvY2sgc2xvdCkgJiYgKHRhZyBzbG90KSA9IG9iamVjdF90YWcgdGhlbiBmaWVsZCBzbG90IDBcbiAgICBlbHNlIGludmFsaWRfYXJnIFwiT2JqLmV4dGVuc2lvbl9jb25zdHJ1Y3RvclwiXG4gIGluXG4gICAgaWYgKHRhZyBuYW1lKSA9IHN0cmluZ190YWcgdGhlbiAob2JqIHNsb3QgOiBleHRlbnNpb25fY29uc3RydWN0b3IpXG4gICAgZWxzZSBpbnZhbGlkX2FyZyBcIk9iai5leHRlbnNpb25fY29uc3RydWN0b3JcIlxuXG5sZXQgW0BpbmxpbmUgYWx3YXlzXSBleHRlbnNpb25fbmFtZSAoc2xvdCA6IGV4dGVuc2lvbl9jb25zdHJ1Y3RvcikgPVxuICAob2JqIChmaWVsZCAocmVwciBzbG90KSAwKSA6IHN0cmluZylcblxubGV0IFtAaW5saW5lIGFsd2F5c10gZXh0ZW5zaW9uX2lkIChzbG90IDogZXh0ZW5zaW9uX2NvbnN0cnVjdG9yKSA9XG4gIChvYmogKGZpZWxkIChyZXByIHNsb3QpIDEpIDogaW50KVxuXG5tb2R1bGUgRXBoZW1lcm9uID0gc3RydWN0XG4gIHR5cGUgb2JqX3QgPSB0XG5cbiAgdHlwZSB0ICgqKiBlcGhlbWVyb24gKilcblxuICBleHRlcm5hbCBjcmVhdGU6IGludCAtPiB0ID0gXCJjYW1sX2VwaGVfY3JlYXRlXCJcblxuICBsZXQgbGVuZ3RoIHggPSBzaXplKHJlcHIgeCkgLSAyXG5cbiAgZXh0ZXJuYWwgZ2V0X2tleTogdCAtPiBpbnQgLT4gb2JqX3Qgb3B0aW9uID0gXCJjYW1sX2VwaGVfZ2V0X2tleVwiXG4gIGV4dGVybmFsIGdldF9rZXlfY29weTogdCAtPiBpbnQgLT4gb2JqX3Qgb3B0aW9uID0gXCJjYW1sX2VwaGVfZ2V0X2tleV9jb3B5XCJcbiAgZXh0ZXJuYWwgc2V0X2tleTogdCAtPiBpbnQgLT4gb2JqX3QgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX3NldF9rZXlcIlxuICBleHRlcm5hbCB1bnNldF9rZXk6IHQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfZXBoZV91bnNldF9rZXlcIlxuICBleHRlcm5hbCBjaGVja19rZXk6IHQgLT4gaW50IC0+IGJvb2wgPSBcImNhbWxfZXBoZV9jaGVja19rZXlcIlxuICBleHRlcm5hbCBibGl0X2tleSA6IHQgLT4gaW50IC0+IHQgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgPSBcImNhbWxfZXBoZV9ibGl0X2tleVwiXG5cbiAgZXh0ZXJuYWwgZ2V0X2RhdGE6IHQgLT4gb2JqX3Qgb3B0aW9uID0gXCJjYW1sX2VwaGVfZ2V0X2RhdGFcIlxuICBleHRlcm5hbCBnZXRfZGF0YV9jb3B5OiB0IC0+IG9ial90IG9wdGlvbiA9IFwiY2FtbF9lcGhlX2dldF9kYXRhX2NvcHlcIlxuICBleHRlcm5hbCBzZXRfZGF0YTogdCAtPiBvYmpfdCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfc2V0X2RhdGFcIlxuICBleHRlcm5hbCB1bnNldF9kYXRhOiB0IC0+IHVuaXQgPSBcImNhbWxfZXBoZV91bnNldF9kYXRhXCJcbiAgZXh0ZXJuYWwgY2hlY2tfZGF0YTogdCAtPiBib29sID0gXCJjYW1sX2VwaGVfY2hlY2tfZGF0YVwiXG4gIGV4dGVybmFsIGJsaXRfZGF0YSA6IHQgLT4gdCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfYmxpdF9kYXRhXCJcblxuXG5lbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQXJyYXkgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBsZW5ndGggOiAnYSBhcnJheSAtPiBpbnQgPSBcIiVhcnJheV9sZW5ndGhcIlxuZXh0ZXJuYWwgZ2V0OiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgPSBcIiVhcnJheV9zYWZlX2dldFwiXG5leHRlcm5hbCBzZXQ6ICdhIGFycmF5IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCIlYXJyYXlfc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2dldDogJ2EgYXJyYXkgLT4gaW50IC0+ICdhID0gXCIlYXJyYXlfdW5zYWZlX2dldFwiXG5leHRlcm5hbCB1bnNhZmVfc2V0OiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiJWFycmF5X3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgbWFrZTogaW50IC0+ICdhIC0+ICdhIGFycmF5ID0gXCJjYW1sX21ha2VfdmVjdFwiXG5leHRlcm5hbCBjcmVhdGU6IGludCAtPiAnYSAtPiAnYSBhcnJheSA9IFwiY2FtbF9tYWtlX3ZlY3RcIlxuZXh0ZXJuYWwgdW5zYWZlX3N1YiA6ICdhIGFycmF5IC0+IGludCAtPiBpbnQgLT4gJ2EgYXJyYXkgPSBcImNhbWxfYXJyYXlfc3ViXCJcbmV4dGVybmFsIGFwcGVuZF9wcmltIDogJ2EgYXJyYXkgLT4gJ2EgYXJyYXkgLT4gJ2EgYXJyYXkgPSBcImNhbWxfYXJyYXlfYXBwZW5kXCJcbmV4dGVybmFsIGNvbmNhdCA6ICdhIGFycmF5IGxpc3QgLT4gJ2EgYXJyYXkgPSBcImNhbWxfYXJyYXlfY29uY2F0XCJcbmV4dGVybmFsIHVuc2FmZV9ibGl0IDpcbiAgJ2EgYXJyYXkgLT4gaW50IC0+ICdhIGFycmF5IC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9hcnJheV9ibGl0XCJcbmV4dGVybmFsIGNyZWF0ZV9mbG9hdDogaW50IC0+IGZsb2F0IGFycmF5ID0gXCJjYW1sX21ha2VfZmxvYXRfdmVjdFwiXG5sZXQgbWFrZV9mbG9hdCA9IGNyZWF0ZV9mbG9hdFxuXG5tb2R1bGUgRmxvYXRhcnJheSA9IHN0cnVjdFxuICBleHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gZmxvYXRhcnJheSA9IFwiY2FtbF9mbG9hdGFycmF5X2NyZWF0ZVwiXG4gIGV4dGVybmFsIGxlbmd0aCA6IGZsb2F0YXJyYXkgLT4gaW50ID0gXCIlZmxvYXRhcnJheV9sZW5ndGhcIlxuICBleHRlcm5hbCBnZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0YXJyYXlfc2FmZV9nZXRcIlxuICBleHRlcm5hbCBzZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCAtPiB1bml0ID0gXCIlZmxvYXRhcnJheV9zYWZlX3NldFwiXG4gIGV4dGVybmFsIHVuc2FmZV9nZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0YXJyYXlfdW5zYWZlX2dldFwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCAtPiB1bml0XG4gICAgICA9IFwiJWZsb2F0YXJyYXlfdW5zYWZlX3NldFwiXG5lbmRcblxubGV0IGluaXQgbCBmID1cbiAgaWYgbCA9IDAgdGhlbiBbfHxdIGVsc2VcbiAgaWYgbCA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmluaXRcIlxuICAoKiBTZWUgIzY1NzUuIFdlIGNvdWxkIGFsc28gY2hlY2sgZm9yIG1heGltdW0gYXJyYXkgc2l6ZSwgYnV0IHRoaXMgZGVwZW5kc1xuICAgICBvbiB3aGV0aGVyIHdlIGNyZWF0ZSBhIGZsb2F0IGFycmF5IG9yIGEgcmVndWxhciBvbmUuLi4gKilcbiAgZWxzZVxuICAgbGV0IHJlcyA9IGNyZWF0ZSBsIChmIDApIGluXG4gICBmb3IgaSA9IDEgdG8gcHJlZCBsIGRvXG4gICAgIHVuc2FmZV9zZXQgcmVzIGkgKGYgaSlcbiAgIGRvbmU7XG4gICByZXNcblxubGV0IG1ha2VfbWF0cml4IHN4IHN5IGluaXQgPVxuICBsZXQgcmVzID0gY3JlYXRlIHN4IFt8fF0gaW5cbiAgZm9yIHggPSAwIHRvIHByZWQgc3ggZG9cbiAgICB1bnNhZmVfc2V0IHJlcyB4IChjcmVhdGUgc3kgaW5pdClcbiAgZG9uZTtcbiAgcmVzXG5cbmxldCBjcmVhdGVfbWF0cml4ID0gbWFrZV9tYXRyaXhcblxubGV0IGNvcHkgYSA9XG4gIGxldCBsID0gbGVuZ3RoIGEgaW4gaWYgbCA9IDAgdGhlbiBbfHxdIGVsc2UgdW5zYWZlX3N1YiBhIDAgbFxuXG5sZXQgYXBwZW5kIGExIGEyID1cbiAgbGV0IGwxID0gbGVuZ3RoIGExIGluXG4gIGlmIGwxID0gMCB0aGVuIGNvcHkgYTJcbiAgZWxzZSBpZiBsZW5ndGggYTIgPSAwIHRoZW4gdW5zYWZlX3N1YiBhMSAwIGwxXG4gIGVsc2UgYXBwZW5kX3ByaW0gYTEgYTJcblxubGV0IHN1YiBhIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIGEgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LnN1YlwiXG4gIGVsc2UgdW5zYWZlX3N1YiBhIG9mcyBsZW5cblxubGV0IGZpbGwgYSBvZnMgbGVuIHYgPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIGEgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmZpbGxcIlxuICBlbHNlIGZvciBpID0gb2ZzIHRvIG9mcyArIGxlbiAtIDEgZG8gdW5zYWZlX3NldCBhIGkgdiBkb25lXG5cbmxldCBibGl0IGExIG9mczEgYTIgb2ZzMiBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IG9mczEgPCAwIHx8IG9mczEgPiBsZW5ndGggYTEgLSBsZW5cbiAgICAgICAgICAgICB8fCBvZnMyIDwgMCB8fCBvZnMyID4gbGVuZ3RoIGEyIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5ibGl0XCJcbiAgZWxzZSB1bnNhZmVfYmxpdCBhMSBvZnMxIGEyIG9mczIgbGVuXG5cbmxldCBpdGVyIGYgYSA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZih1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG5sZXQgaXRlcjIgZiBhIGIgPVxuICBpZiBsZW5ndGggYSA8PiBsZW5ndGggYiB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJBcnJheS5pdGVyMjogYXJyYXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIlxuICBlbHNlXG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmICh1bnNhZmVfZ2V0IGEgaSkgKHVuc2FmZV9nZXQgYiBpKSBkb25lXG5cbmxldCBtYXAgZiBhID1cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBpZiBsID0gMCB0aGVuIFt8fF0gZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGwgKGYodW5zYWZlX2dldCBhIDApKSBpblxuICAgIGZvciBpID0gMSB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYodW5zYWZlX2dldCBhIGkpKVxuICAgIGRvbmU7XG4gICAgclxuICBlbmRcblxubGV0IG1hcDIgZiBhIGIgPVxuICBsZXQgbGEgPSBsZW5ndGggYSBpblxuICBsZXQgbGIgPSBsZW5ndGggYiBpblxuICBpZiBsYSA8PiBsYiB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJBcnJheS5tYXAyOiBhcnJheXMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiXG4gIGVsc2UgYmVnaW5cbiAgICBpZiBsYSA9IDAgdGhlbiBbfHxdIGVsc2UgYmVnaW5cbiAgICAgIGxldCByID0gY3JlYXRlIGxhIChmICh1bnNhZmVfZ2V0IGEgMCkgKHVuc2FmZV9nZXQgYiAwKSkgaW5cbiAgICAgIGZvciBpID0gMSB0byBsYSAtIDEgZG9cbiAgICAgICAgdW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgYSBpKSAodW5zYWZlX2dldCBiIGkpKVxuICAgICAgZG9uZTtcbiAgICAgIHJcbiAgICBlbmRcbiAgZW5kXG5cbmxldCBpdGVyaSBmIGEgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgaSAodW5zYWZlX2dldCBhIGkpIGRvbmVcblxubGV0IG1hcGkgZiBhID1cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBpZiBsID0gMCB0aGVuIFt8fF0gZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGwgKGYgMCAodW5zYWZlX2dldCBhIDApKSBpblxuICAgIGZvciBpID0gMSB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYgaSAodW5zYWZlX2dldCBhIGkpKVxuICAgIGRvbmU7XG4gICAgclxuICBlbmRcblxubGV0IHRvX2xpc3QgYSA9XG4gIGxldCByZWMgdG9saXN0IGkgcmVzID1cbiAgICBpZiBpIDwgMCB0aGVuIHJlcyBlbHNlIHRvbGlzdCAoaSAtIDEpICh1bnNhZmVfZ2V0IGEgaSA6OiByZXMpIGluXG4gIHRvbGlzdCAobGVuZ3RoIGEgLSAxKSBbXVxuXG4oKiBDYW5ub3QgdXNlIExpc3QubGVuZ3RoIGhlcmUgYmVjYXVzZSB0aGUgTGlzdCBtb2R1bGUgZGVwZW5kcyBvbiBBcnJheS4gKilcbmxldCByZWMgbGlzdF9sZW5ndGggYWNjdSA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gYWNjdVxuICB8IF86OnQgLT4gbGlzdF9sZW5ndGggKHN1Y2MgYWNjdSkgdFxuXG5sZXQgb2ZfbGlzdCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW3x8XVxuICB8IGhkOjp0bCBhcyBsIC0+XG4gICAgICBsZXQgYSA9IGNyZWF0ZSAobGlzdF9sZW5ndGggMCBsKSBoZCBpblxuICAgICAgbGV0IHJlYyBmaWxsIGkgPSBmdW5jdGlvblxuICAgICAgICAgIFtdIC0+IGFcbiAgICAgICAgfCBoZDo6dGwgLT4gdW5zYWZlX3NldCBhIGkgaGQ7IGZpbGwgKGkrMSkgdGwgaW5cbiAgICAgIGZpbGwgMSB0bFxuXG5sZXQgZm9sZF9sZWZ0IGYgeCBhID1cbiAgbGV0IHIgPSByZWYgeCBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvXG4gICAgciA6PSBmICFyICh1bnNhZmVfZ2V0IGEgaSlcbiAgZG9uZTtcbiAgIXJcblxubGV0IGZvbGRfcmlnaHQgZiBhIHggPVxuICBsZXQgciA9IHJlZiB4IGluXG4gIGZvciBpID0gbGVuZ3RoIGEgLSAxIGRvd250byAwIGRvXG4gICAgciA6PSBmICh1bnNhZmVfZ2V0IGEgaSkgIXJcbiAgZG9uZTtcbiAgIXJcblxubGV0IGV4aXN0cyBwIGEgPVxuICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IGEgaSkgdGhlbiB0cnVlXG4gICAgZWxzZSBsb29wIChzdWNjIGkpIGluXG4gIGxvb3AgMFxuXG5sZXQgZm9yX2FsbCBwIGEgPVxuICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIHRydWVcbiAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgYSBpKSB0aGVuIGxvb3AgKHN1Y2MgaSlcbiAgICBlbHNlIGZhbHNlIGluXG4gIGxvb3AgMFxuXG5sZXQgbWVtIHggYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICBlbHNlIGlmIGNvbXBhcmUgKHVuc2FmZV9nZXQgYSBpKSB4ID0gMCB0aGVuIHRydWVcbiAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgaW5cbiAgbG9vcCAwXG5cbmxldCBtZW1xIHggYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICBlbHNlIGlmIHggPT0gKHVuc2FmZV9nZXQgYSBpKSB0aGVuIHRydWVcbiAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgaW5cbiAgbG9vcCAwXG5cbmV4Y2VwdGlvbiBCb3R0b20gb2YgaW50XG5sZXQgc29ydCBjbXAgYSA9XG4gIGxldCBtYXhzb24gbCBpID1cbiAgICBsZXQgaTMxID0gaStpK2krMSBpblxuICAgIGxldCB4ID0gcmVmIGkzMSBpblxuICAgIGlmIGkzMSsyIDwgbCB0aGVuIGJlZ2luXG4gICAgICBpZiBjbXAgKGdldCBhIGkzMSkgKGdldCBhIChpMzErMSkpIDwgMCB0aGVuIHggOj0gaTMxKzE7XG4gICAgICBpZiBjbXAgKGdldCBhICF4KSAoZ2V0IGEgKGkzMSsyKSkgPCAwIHRoZW4geCA6PSBpMzErMjtcbiAgICAgICF4XG4gICAgZW5kIGVsc2VcbiAgICAgIGlmIGkzMSsxIDwgbCAmJiBjbXAgKGdldCBhIGkzMSkgKGdldCBhIChpMzErMSkpIDwgMFxuICAgICAgdGhlbiBpMzErMVxuICAgICAgZWxzZSBpZiBpMzEgPCBsIHRoZW4gaTMxIGVsc2UgcmFpc2UgKEJvdHRvbSBpKVxuICBpblxuICBsZXQgcmVjIHRyaWNrbGVkb3duIGwgaSBlID1cbiAgICBsZXQgaiA9IG1heHNvbiBsIGkgaW5cbiAgICBpZiBjbXAgKGdldCBhIGopIGUgPiAwIHRoZW4gYmVnaW5cbiAgICAgIHNldCBhIGkgKGdldCBhIGopO1xuICAgICAgdHJpY2tsZWRvd24gbCBqIGU7XG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgIHNldCBhIGkgZTtcbiAgICBlbmQ7XG4gIGluXG4gIGxldCB0cmlja2xlIGwgaSBlID0gdHJ5IHRyaWNrbGVkb3duIGwgaSBlIHdpdGggQm90dG9tIGkgLT4gc2V0IGEgaSBlIGluXG4gIGxldCByZWMgYnViYmxlZG93biBsIGkgPVxuICAgIGxldCBqID0gbWF4c29uIGwgaSBpblxuICAgIHNldCBhIGkgKGdldCBhIGopO1xuICAgIGJ1YmJsZWRvd24gbCBqXG4gIGluXG4gIGxldCBidWJibGUgbCBpID0gdHJ5IGJ1YmJsZWRvd24gbCBpIHdpdGggQm90dG9tIGkgLT4gaSBpblxuICBsZXQgcmVjIHRyaWNrbGV1cCBpIGUgPVxuICAgIGxldCBmYXRoZXIgPSAoaSAtIDEpIC8gMyBpblxuICAgIGFzc2VydCAoaSA8PiBmYXRoZXIpO1xuICAgIGlmIGNtcCAoZ2V0IGEgZmF0aGVyKSBlIDwgMCB0aGVuIGJlZ2luXG4gICAgICBzZXQgYSBpIChnZXQgYSBmYXRoZXIpO1xuICAgICAgaWYgZmF0aGVyID4gMCB0aGVuIHRyaWNrbGV1cCBmYXRoZXIgZSBlbHNlIHNldCBhIDAgZTtcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgc2V0IGEgaSBlO1xuICAgIGVuZDtcbiAgaW5cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBmb3IgaSA9IChsICsgMSkgLyAzIC0gMSBkb3dudG8gMCBkbyB0cmlja2xlIGwgaSAoZ2V0IGEgaSk7IGRvbmU7XG4gIGZvciBpID0gbCAtIDEgZG93bnRvIDIgZG9cbiAgICBsZXQgZSA9IChnZXQgYSBpKSBpblxuICAgIHNldCBhIGkgKGdldCBhIDApO1xuICAgIHRyaWNrbGV1cCAoYnViYmxlIGkgMCkgZTtcbiAgZG9uZTtcbiAgaWYgbCA+IDEgdGhlbiAobGV0IGUgPSAoZ2V0IGEgMSkgaW4gc2V0IGEgMSAoZ2V0IGEgMCk7IHNldCBhIDAgZSlcblxuXG5sZXQgY3V0b2ZmID0gNVxubGV0IHN0YWJsZV9zb3J0IGNtcCBhID1cbiAgbGV0IG1lcmdlIHNyYzFvZnMgc3JjMWxlbiBzcmMyIHNyYzJvZnMgc3JjMmxlbiBkc3QgZHN0b2ZzID1cbiAgICBsZXQgc3JjMXIgPSBzcmMxb2ZzICsgc3JjMWxlbiBhbmQgc3JjMnIgPSBzcmMyb2ZzICsgc3JjMmxlbiBpblxuICAgIGxldCByZWMgbG9vcCBpMSBzMSBpMiBzMiBkID1cbiAgICAgIGlmIGNtcCBzMSBzMiA8PSAwIHRoZW4gYmVnaW5cbiAgICAgICAgc2V0IGRzdCBkIHMxO1xuICAgICAgICBsZXQgaTEgPSBpMSArIDEgaW5cbiAgICAgICAgaWYgaTEgPCBzcmMxciB0aGVuXG4gICAgICAgICAgbG9vcCBpMSAoZ2V0IGEgaTEpIGkyIHMyIChkICsgMSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJsaXQgc3JjMiBpMiBkc3QgKGQgKyAxKSAoc3JjMnIgLSBpMilcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIHNldCBkc3QgZCBzMjtcbiAgICAgICAgbGV0IGkyID0gaTIgKyAxIGluXG4gICAgICAgIGlmIGkyIDwgc3JjMnIgdGhlblxuICAgICAgICAgIGxvb3AgaTEgczEgaTIgKGdldCBzcmMyIGkyKSAoZCArIDEpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBibGl0IGEgaTEgZHN0IChkICsgMSkgKHNyYzFyIC0gaTEpXG4gICAgICBlbmRcbiAgICBpbiBsb29wIHNyYzFvZnMgKGdldCBhIHNyYzFvZnMpIHNyYzJvZnMgKGdldCBzcmMyIHNyYzJvZnMpIGRzdG9mcztcbiAgaW5cbiAgbGV0IGlzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuID1cbiAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgbGV0IGUgPSAoZ2V0IGEgKHNyY29mcyArIGkpKSBpblxuICAgICAgbGV0IGogPSByZWYgKGRzdG9mcyArIGkgLSAxKSBpblxuICAgICAgd2hpbGUgKCFqID49IGRzdG9mcyAmJiBjbXAgKGdldCBkc3QgIWopIGUgPiAwKSBkb1xuICAgICAgICBzZXQgZHN0ICghaiArIDEpIChnZXQgZHN0ICFqKTtcbiAgICAgICAgZGVjciBqO1xuICAgICAgZG9uZTtcbiAgICAgIHNldCBkc3QgKCFqICsgMSkgZTtcbiAgICBkb25lO1xuICBpblxuICBsZXQgcmVjIHNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gPVxuICAgIGlmIGxlbiA8PSBjdXRvZmYgdGhlbiBpc29ydHRvIHNyY29mcyBkc3QgZHN0b2ZzIGxlbiBlbHNlIGJlZ2luXG4gICAgICBsZXQgbDEgPSBsZW4gLyAyIGluXG4gICAgICBsZXQgbDIgPSBsZW4gLSBsMSBpblxuICAgICAgc29ydHRvIChzcmNvZnMgKyBsMSkgZHN0IChkc3RvZnMgKyBsMSkgbDI7XG4gICAgICBzb3J0dG8gc3Jjb2ZzIGEgKHNyY29mcyArIGwyKSBsMTtcbiAgICAgIG1lcmdlIChzcmNvZnMgKyBsMikgbDEgZHN0IChkc3RvZnMgKyBsMSkgbDIgZHN0IGRzdG9mcztcbiAgICBlbmQ7XG4gIGluXG4gIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgaWYgbCA8PSBjdXRvZmYgdGhlbiBpc29ydHRvIDAgYSAwIGwgZWxzZSBiZWdpblxuICAgIGxldCBsMSA9IGwgLyAyIGluXG4gICAgbGV0IGwyID0gbCAtIGwxIGluXG4gICAgbGV0IHQgPSBtYWtlIGwyIChnZXQgYSAwKSBpblxuICAgIHNvcnR0byBsMSB0IDAgbDI7XG4gICAgc29ydHRvIDAgYSBsMiBsMTtcbiAgICBtZXJnZSBsMiBsMSB0IDAgbDIgYSAwO1xuICBlbmRcblxuXG5sZXQgZmFzdF9zb3J0ID0gc3RhYmxlX3NvcnRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtJbnQzMl06IDMyLWJpdCBpbnRlZ2VycyAqKVxuXG5leHRlcm5hbCBuZWcgOiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX25lZ1wiXG5leHRlcm5hbCBhZGQgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX2FkZFwiXG5leHRlcm5hbCBzdWIgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX3N1YlwiXG5leHRlcm5hbCBtdWwgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX211bFwiXG5leHRlcm5hbCBkaXYgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX2RpdlwiXG5leHRlcm5hbCByZW0gOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX21vZFwiXG5leHRlcm5hbCBsb2dhbmQgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX2FuZFwiXG5leHRlcm5hbCBsb2dvciA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfb3JcIlxuZXh0ZXJuYWwgbG9neG9yIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl94b3JcIlxuZXh0ZXJuYWwgc2hpZnRfbGVmdCA6IGludDMyIC0+IGludCAtPiBpbnQzMiA9IFwiJWludDMyX2xzbFwiXG5leHRlcm5hbCBzaGlmdF9yaWdodCA6IGludDMyIC0+IGludCAtPiBpbnQzMiA9IFwiJWludDMyX2FzclwiXG5leHRlcm5hbCBzaGlmdF9yaWdodF9sb2dpY2FsIDogaW50MzIgLT4gaW50IC0+IGludDMyID0gXCIlaW50MzJfbHNyXCJcbmV4dGVybmFsIG9mX2ludCA6IGludCAtPiBpbnQzMiA9IFwiJWludDMyX29mX2ludFwiXG5leHRlcm5hbCB0b19pbnQgOiBpbnQzMiAtPiBpbnQgPSBcIiVpbnQzMl90b19pbnRcIlxuZXh0ZXJuYWwgb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQzMlxuICA9IFwiY2FtbF9pbnQzMl9vZl9mbG9hdFwiIFwiY2FtbF9pbnQzMl9vZl9mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRvX2Zsb2F0IDogaW50MzIgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50MzJfdG9fZmxvYXRcIiBcImNhbWxfaW50MzJfdG9fZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBiaXRzX29mX2Zsb2F0IDogZmxvYXQgLT4gaW50MzJcbiAgPSBcImNhbWxfaW50MzJfYml0c19vZl9mbG9hdFwiIFwiY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZmxvYXRfb2ZfYml0cyA6IGludDMyIC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHNcIiBcImNhbWxfaW50MzJfZmxvYXRfb2ZfYml0c191bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxubGV0IHplcm8gPSAwbFxubGV0IG9uZSA9IDFsXG5sZXQgbWludXNfb25lID0gLTFsXG5sZXQgc3VjYyBuID0gYWRkIG4gMWxcbmxldCBwcmVkIG4gPSBzdWIgbiAxbFxubGV0IGFicyBuID0gaWYgbiA+PSAwbCB0aGVuIG4gZWxzZSBuZWcgblxubGV0IG1pbl9pbnQgPSAweDgwMDAwMDAwbFxubGV0IG1heF9pbnQgPSAweDdGRkZGRkZGbFxubGV0IGxvZ25vdCBuID0gbG9neG9yIG4gKC0xbClcblxuZXh0ZXJuYWwgZm9ybWF0IDogc3RyaW5nIC0+IGludDMyIC0+IHN0cmluZyA9IFwiY2FtbF9pbnQzMl9mb3JtYXRcIlxubGV0IHRvX3N0cmluZyBuID0gZm9ybWF0IFwiJWRcIiBuXG5cbmV4dGVybmFsIG9mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQzMiA9IFwiY2FtbF9pbnQzMl9vZl9zdHJpbmdcIlxuXG5sZXQgb2Zfc3RyaW5nX29wdCBzID1cbiAgKCogVE9ETzogZXhwb3NlIGEgbm9uLXJhaXNpbmcgcHJpbWl0aXZlIGRpcmVjdGx5LiAqKVxuICB0cnkgU29tZSAob2Zfc3RyaW5nIHMpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxudHlwZSB0ID0gaW50MzJcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFBlcnZhc2l2ZXMuY29tcGFyZSB4IHlcbmxldCBlcXVhbCAoeDogdCkgKHk6IHQpID0gY29tcGFyZSB4IHkgPSAwXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFRoZSBwYXJzaW5nIGVuZ2luZSAqKVxuXG5vcGVuIExleGluZ1xuXG4oKiBJbnRlcm5hbCBpbnRlcmZhY2UgdG8gdGhlIHBhcnNpbmcgZW5naW5lICopXG5cbnR5cGUgcGFyc2VyX2VudiA9XG4gIHsgbXV0YWJsZSBzX3N0YWNrIDogaW50IGFycmF5OyAgICAgICAgKCogU3RhdGVzICopXG4gICAgbXV0YWJsZSB2X3N0YWNrIDogT2JqLnQgYXJyYXk7ICAgICAgKCogU2VtYW50aWMgYXR0cmlidXRlcyAqKVxuICAgIG11dGFibGUgc3ltYl9zdGFydF9zdGFjayA6IHBvc2l0aW9uIGFycmF5OyAoKiBTdGFydCBwb3NpdGlvbnMgKilcbiAgICBtdXRhYmxlIHN5bWJfZW5kX3N0YWNrIDogcG9zaXRpb24gYXJyYXk7ICAgKCogRW5kIHBvc2l0aW9ucyAqKVxuICAgIG11dGFibGUgc3RhY2tzaXplIDogaW50OyAgICAgICAgICAgICgqIFNpemUgb2YgdGhlIHN0YWNrcyAqKVxuICAgIG11dGFibGUgc3RhY2tiYXNlIDogaW50OyAgICAgICAgICAgICgqIEJhc2Ugc3AgZm9yIGN1cnJlbnQgcGFyc2UgKilcbiAgICBtdXRhYmxlIGN1cnJfY2hhciA6IGludDsgICAgICAgICAgICAoKiBMYXN0IHRva2VuIHJlYWQgKilcbiAgICBtdXRhYmxlIGx2YWwgOiBPYmoudDsgICAgICAgICAgICAgICAoKiBJdHMgc2VtYW50aWMgYXR0cmlidXRlICopXG4gICAgbXV0YWJsZSBzeW1iX3N0YXJ0IDogcG9zaXRpb247ICAgICAgKCogU3RhcnQgcG9zLiBvZiB0aGUgY3VycmVudCBzeW1ib2wqKVxuICAgIG11dGFibGUgc3ltYl9lbmQgOiBwb3NpdGlvbjsgICAgICAgICgqIEVuZCBwb3MuIG9mIHRoZSBjdXJyZW50IHN5bWJvbCAqKVxuICAgIG11dGFibGUgYXNwIDogaW50OyAgICAgICAgICAgICAgICAgICgqIFRoZSBzdGFjayBwb2ludGVyIGZvciBhdHRyaWJ1dGVzICopXG4gICAgbXV0YWJsZSBydWxlX2xlbiA6IGludDsgICAgICAgICAgICAgKCogTnVtYmVyIG9mIHJocyBpdGVtcyBpbiB0aGUgcnVsZSAqKVxuICAgIG11dGFibGUgcnVsZV9udW1iZXIgOiBpbnQ7ICAgICAgICAgICgqIFJ1bGUgbnVtYmVyIHRvIHJlZHVjZSBieSAqKVxuICAgIG11dGFibGUgc3AgOiBpbnQ7ICAgICAgICAgICAgICAgICAgICgqIFNhdmVkIHNwIGZvciBwYXJzZV9lbmdpbmUgKilcbiAgICBtdXRhYmxlIHN0YXRlIDogaW50OyAgICAgICAgICAgICAgICAoKiBTYXZlZCBzdGF0ZSBmb3IgcGFyc2VfZW5naW5lICopXG4gICAgbXV0YWJsZSBlcnJmbGFnIDogaW50IH0gICAgICAgICAgICAgKCogU2F2ZWQgZXJyb3IgZmxhZyBmb3IgcGFyc2VfZW5naW5lICopXG5cbnR5cGUgcGFyc2VfdGFibGVzID1cbiAgeyBhY3Rpb25zIDogKHBhcnNlcl9lbnYgLT4gT2JqLnQpIGFycmF5O1xuICAgIHRyYW5zbF9jb25zdCA6IGludCBhcnJheTtcbiAgICB0cmFuc2xfYmxvY2sgOiBpbnQgYXJyYXk7XG4gICAgbGhzIDogc3RyaW5nO1xuICAgIGxlbiA6IHN0cmluZztcbiAgICBkZWZyZWQgOiBzdHJpbmc7XG4gICAgZGdvdG8gOiBzdHJpbmc7XG4gICAgc2luZGV4IDogc3RyaW5nO1xuICAgIHJpbmRleCA6IHN0cmluZztcbiAgICBnaW5kZXggOiBzdHJpbmc7XG4gICAgdGFibGVzaXplIDogaW50O1xuICAgIHRhYmxlIDogc3RyaW5nO1xuICAgIGNoZWNrIDogc3RyaW5nO1xuICAgIGVycm9yX2Z1bmN0aW9uIDogc3RyaW5nIC0+IHVuaXQ7XG4gICAgbmFtZXNfY29uc3QgOiBzdHJpbmc7XG4gICAgbmFtZXNfYmxvY2sgOiBzdHJpbmcgfVxuXG5leGNlcHRpb24gWVlleGl0IG9mIE9iai50XG5leGNlcHRpb24gUGFyc2VfZXJyb3JcblxudHlwZSBwYXJzZXJfaW5wdXQgPVxuICAgIFN0YXJ0XG4gIHwgVG9rZW5fcmVhZFxuICB8IFN0YWNrc19ncm93bl8xXG4gIHwgU3RhY2tzX2dyb3duXzJcbiAgfCBTZW1hbnRpY19hY3Rpb25fY29tcHV0ZWRcbiAgfCBFcnJvcl9kZXRlY3RlZFxuXG50eXBlIHBhcnNlcl9vdXRwdXQgPVxuICAgIFJlYWRfdG9rZW5cbiAgfCBSYWlzZV9wYXJzZV9lcnJvclxuICB8IEdyb3dfc3RhY2tzXzFcbiAgfCBHcm93X3N0YWNrc18yXG4gIHwgQ29tcHV0ZV9zZW1hbnRpY19hY3Rpb25cbiAgfCBDYWxsX2Vycm9yX2Z1bmN0aW9uXG5cbigqIHRvIGF2b2lkIHdhcm5pbmdzICopXG5sZXQgXyA9IFtSZWFkX3Rva2VuOyBSYWlzZV9wYXJzZV9lcnJvcjsgR3Jvd19zdGFja3NfMTsgR3Jvd19zdGFja3NfMjtcbiAgICAgICAgIENvbXB1dGVfc2VtYW50aWNfYWN0aW9uOyBDYWxsX2Vycm9yX2Z1bmN0aW9uXVxuXG5leHRlcm5hbCBwYXJzZV9lbmdpbmUgOlxuICAgIHBhcnNlX3RhYmxlcyAtPiBwYXJzZXJfZW52IC0+IHBhcnNlcl9pbnB1dCAtPiBPYmoudCAtPiBwYXJzZXJfb3V0cHV0XG4gICAgPSBcImNhbWxfcGFyc2VfZW5naW5lXCJcblxuZXh0ZXJuYWwgc2V0X3RyYWNlOiBib29sIC0+IGJvb2xcbiAgICA9IFwiY2FtbF9zZXRfcGFyc2VyX3RyYWNlXCJcblxubGV0IGVudiA9XG4gIHsgc19zdGFjayA9IEFycmF5Lm1ha2UgMTAwIDA7XG4gICAgdl9zdGFjayA9IEFycmF5Lm1ha2UgMTAwIChPYmoucmVwciAoKSk7XG4gICAgc3ltYl9zdGFydF9zdGFjayA9IEFycmF5Lm1ha2UgMTAwIGR1bW15X3BvcztcbiAgICBzeW1iX2VuZF9zdGFjayA9IEFycmF5Lm1ha2UgMTAwIGR1bW15X3BvcztcbiAgICBzdGFja3NpemUgPSAxMDA7XG4gICAgc3RhY2tiYXNlID0gMDtcbiAgICBjdXJyX2NoYXIgPSAwO1xuICAgIGx2YWwgPSBPYmoucmVwciAoKTtcbiAgICBzeW1iX3N0YXJ0ID0gZHVtbXlfcG9zO1xuICAgIHN5bWJfZW5kID0gZHVtbXlfcG9zO1xuICAgIGFzcCA9IDA7XG4gICAgcnVsZV9sZW4gPSAwO1xuICAgIHJ1bGVfbnVtYmVyID0gMDtcbiAgICBzcCA9IDA7XG4gICAgc3RhdGUgPSAwO1xuICAgIGVycmZsYWcgPSAwIH1cblxubGV0IGdyb3dfc3RhY2tzKCkgPVxuICBsZXQgb2xkc2l6ZSA9IGVudi5zdGFja3NpemUgaW5cbiAgbGV0IG5ld3NpemUgPSBvbGRzaXplICogMiBpblxuICBsZXQgbmV3X3MgPSBBcnJheS5tYWtlIG5ld3NpemUgMFxuICBhbmQgbmV3X3YgPSBBcnJheS5tYWtlIG5ld3NpemUgKE9iai5yZXByICgpKVxuICBhbmQgbmV3X3N0YXJ0ID0gQXJyYXkubWFrZSBuZXdzaXplIGR1bW15X3Bvc1xuICBhbmQgbmV3X2VuZCA9IEFycmF5Lm1ha2UgbmV3c2l6ZSBkdW1teV9wb3MgaW5cbiAgICBBcnJheS5ibGl0IGVudi5zX3N0YWNrIDAgbmV3X3MgMCBvbGRzaXplO1xuICAgIGVudi5zX3N0YWNrIDwtIG5ld19zO1xuICAgIEFycmF5LmJsaXQgZW52LnZfc3RhY2sgMCBuZXdfdiAwIG9sZHNpemU7XG4gICAgZW52LnZfc3RhY2sgPC0gbmV3X3Y7XG4gICAgQXJyYXkuYmxpdCBlbnYuc3ltYl9zdGFydF9zdGFjayAwIG5ld19zdGFydCAwIG9sZHNpemU7XG4gICAgZW52LnN5bWJfc3RhcnRfc3RhY2sgPC0gbmV3X3N0YXJ0O1xuICAgIEFycmF5LmJsaXQgZW52LnN5bWJfZW5kX3N0YWNrIDAgbmV3X2VuZCAwIG9sZHNpemU7XG4gICAgZW52LnN5bWJfZW5kX3N0YWNrIDwtIG5ld19lbmQ7XG4gICAgZW52LnN0YWNrc2l6ZSA8LSBuZXdzaXplXG5cbmxldCBjbGVhcl9wYXJzZXIoKSA9XG4gIEFycmF5LmZpbGwgZW52LnZfc3RhY2sgMCBlbnYuc3RhY2tzaXplIChPYmoucmVwciAoKSk7XG4gIGVudi5sdmFsIDwtIE9iai5yZXByICgpXG5cbmxldCBjdXJyZW50X2xvb2thaGVhZF9mdW4gPSByZWYgKGZ1biAoXyA6IE9iai50KSAtPiBmYWxzZSlcblxubGV0IHl5cGFyc2UgdGFibGVzIHN0YXJ0IGxleGVyIGxleGJ1ZiA9XG4gIGxldCByZWMgbG9vcCBjbWQgYXJnID1cbiAgICBtYXRjaCBwYXJzZV9lbmdpbmUgdGFibGVzIGVudiBjbWQgYXJnIHdpdGhcbiAgICAgIFJlYWRfdG9rZW4gLT5cbiAgICAgICAgbGV0IHQgPSBPYmoucmVwcihsZXhlciBsZXhidWYpIGluXG4gICAgICAgIGVudi5zeW1iX3N0YXJ0IDwtIGxleGJ1Zi5sZXhfc3RhcnRfcDtcbiAgICAgICAgZW52LnN5bWJfZW5kIDwtIGxleGJ1Zi5sZXhfY3Vycl9wO1xuICAgICAgICBsb29wIFRva2VuX3JlYWQgdFxuICAgIHwgUmFpc2VfcGFyc2VfZXJyb3IgLT5cbiAgICAgICAgcmFpc2UgUGFyc2VfZXJyb3JcbiAgICB8IENvbXB1dGVfc2VtYW50aWNfYWN0aW9uIC0+XG4gICAgICAgIGxldCAoYWN0aW9uLCB2YWx1ZSkgPVxuICAgICAgICAgIHRyeVxuICAgICAgICAgICAgKFNlbWFudGljX2FjdGlvbl9jb21wdXRlZCwgdGFibGVzLmFjdGlvbnMuKGVudi5ydWxlX251bWJlcikgZW52KVxuICAgICAgICAgIHdpdGggUGFyc2VfZXJyb3IgLT5cbiAgICAgICAgICAgIChFcnJvcl9kZXRlY3RlZCwgT2JqLnJlcHIgKCkpIGluXG4gICAgICAgIGxvb3AgYWN0aW9uIHZhbHVlXG4gICAgfCBHcm93X3N0YWNrc18xIC0+XG4gICAgICAgIGdyb3dfc3RhY2tzKCk7IGxvb3AgU3RhY2tzX2dyb3duXzEgKE9iai5yZXByICgpKVxuICAgIHwgR3Jvd19zdGFja3NfMiAtPlxuICAgICAgICBncm93X3N0YWNrcygpOyBsb29wIFN0YWNrc19ncm93bl8yIChPYmoucmVwciAoKSlcbiAgICB8IENhbGxfZXJyb3JfZnVuY3Rpb24gLT5cbiAgICAgICAgdGFibGVzLmVycm9yX2Z1bmN0aW9uIFwic3ludGF4IGVycm9yXCI7XG4gICAgICAgIGxvb3AgRXJyb3JfZGV0ZWN0ZWQgKE9iai5yZXByICgpKSBpblxuICBsZXQgaW5pdF9hc3AgPSBlbnYuYXNwXG4gIGFuZCBpbml0X3NwID0gZW52LnNwXG4gIGFuZCBpbml0X3N0YWNrYmFzZSA9IGVudi5zdGFja2Jhc2VcbiAgYW5kIGluaXRfc3RhdGUgPSBlbnYuc3RhdGVcbiAgYW5kIGluaXRfY3Vycl9jaGFyID0gZW52LmN1cnJfY2hhclxuICBhbmQgaW5pdF9sdmFsID0gZW52Lmx2YWxcbiAgYW5kIGluaXRfZXJyZmxhZyA9IGVudi5lcnJmbGFnIGluXG4gIGVudi5zdGFja2Jhc2UgPC0gZW52LnNwICsgMTtcbiAgZW52LmN1cnJfY2hhciA8LSBzdGFydDtcbiAgZW52LnN5bWJfZW5kIDwtIGxleGJ1Zi5sZXhfY3Vycl9wO1xuICB0cnlcbiAgICBsb29wIFN0YXJ0IChPYmoucmVwciAoKSlcbiAgd2l0aCBleG4gLT5cbiAgICBsZXQgY3Vycl9jaGFyID0gZW52LmN1cnJfY2hhciBpblxuICAgIGVudi5hc3AgPC0gaW5pdF9hc3A7XG4gICAgZW52LnNwIDwtIGluaXRfc3A7XG4gICAgZW52LnN0YWNrYmFzZSA8LSBpbml0X3N0YWNrYmFzZTtcbiAgICBlbnYuc3RhdGUgPC0gaW5pdF9zdGF0ZTtcbiAgICBlbnYuY3Vycl9jaGFyIDwtIGluaXRfY3Vycl9jaGFyO1xuICAgIGVudi5sdmFsIDwtIGluaXRfbHZhbDtcbiAgICBlbnYuZXJyZmxhZyA8LSBpbml0X2VycmZsYWc7XG4gICAgbWF0Y2ggZXhuIHdpdGhcbiAgICAgIFlZZXhpdCB2IC0+XG4gICAgICAgIE9iai5tYWdpYyB2XG4gICAgfCBfIC0+XG4gICAgICAgIGN1cnJlbnRfbG9va2FoZWFkX2Z1biA6PVxuICAgICAgICAgIChmdW4gdG9rIC0+XG4gICAgICAgICAgICBpZiBPYmouaXNfYmxvY2sgdG9rXG4gICAgICAgICAgICB0aGVuIHRhYmxlcy50cmFuc2xfYmxvY2suKE9iai50YWcgdG9rKSA9IGN1cnJfY2hhclxuICAgICAgICAgICAgZWxzZSB0YWJsZXMudHJhbnNsX2NvbnN0LihPYmoubWFnaWMgdG9rKSA9IGN1cnJfY2hhcik7XG4gICAgICAgIHJhaXNlIGV4blxuXG5sZXQgcGVla192YWwgZW52IG4gPVxuICBPYmoubWFnaWMgZW52LnZfc3RhY2suKGVudi5hc3AgLSBuKVxuXG5sZXQgc3ltYm9sX3N0YXJ0X3BvcyAoKSA9XG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpIDw9IDAgdGhlbiBlbnYuc3ltYl9lbmRfc3RhY2suKGVudi5hc3ApXG4gICAgZWxzZSBiZWdpblxuICAgICAgbGV0IHN0ID0gZW52LnN5bWJfc3RhcnRfc3RhY2suKGVudi5hc3AgLSBpICsgMSkgaW5cbiAgICAgIGxldCBlbiA9IGVudi5zeW1iX2VuZF9zdGFjay4oZW52LmFzcCAtIGkgKyAxKSBpblxuICAgICAgaWYgc3QgPD4gZW4gdGhlbiBzdCBlbHNlIGxvb3AgKGkgLSAxKVxuICAgIGVuZFxuICBpblxuICBsb29wIGVudi5ydWxlX2xlblxuXG5sZXQgc3ltYm9sX2VuZF9wb3MgKCkgPSBlbnYuc3ltYl9lbmRfc3RhY2suKGVudi5hc3ApXG5sZXQgcmhzX3N0YXJ0X3BvcyBuID0gZW52LnN5bWJfc3RhcnRfc3RhY2suKGVudi5hc3AgLSAoZW52LnJ1bGVfbGVuIC0gbikpXG5sZXQgcmhzX2VuZF9wb3MgbiA9IGVudi5zeW1iX2VuZF9zdGFjay4oZW52LmFzcCAtIChlbnYucnVsZV9sZW4gLSBuKSlcblxubGV0IHN5bWJvbF9zdGFydCAoKSA9IChzeW1ib2xfc3RhcnRfcG9zICgpKS5wb3NfY251bVxubGV0IHN5bWJvbF9lbmQgKCkgPSAoc3ltYm9sX2VuZF9wb3MgKCkpLnBvc19jbnVtXG5sZXQgcmhzX3N0YXJ0IG4gPSAocmhzX3N0YXJ0X3BvcyBuKS5wb3NfY251bVxubGV0IHJoc19lbmQgbiA9IChyaHNfZW5kX3BvcyBuKS5wb3NfY251bVxuXG5sZXQgaXNfY3VycmVudF9sb29rYWhlYWQgdG9rID1cbiAgKCFjdXJyZW50X2xvb2thaGVhZF9mdW4pKE9iai5yZXByIHRvaylcblxubGV0IHBhcnNlX2Vycm9yIChfIDogc3RyaW5nKSA9ICgpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFNldHMgb3ZlciBvcmRlcmVkIHR5cGVzICopXG5cbm1vZHVsZSB0eXBlIE9yZGVyZWRUeXBlID1cbiAgc2lnXG4gICAgdHlwZSB0XG4gICAgdmFsIGNvbXBhcmU6IHQgLT4gdCAtPiBpbnRcbiAgZW5kXG5cbm1vZHVsZSB0eXBlIFMgPVxuICBzaWdcbiAgICB0eXBlIGVsdFxuICAgIHR5cGUgdFxuICAgIHZhbCBlbXB0eTogdFxuICAgIHZhbCBpc19lbXB0eTogdCAtPiBib29sXG4gICAgdmFsIG1lbTogZWx0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBhZGQ6IGVsdCAtPiB0IC0+IHRcbiAgICB2YWwgc2luZ2xldG9uOiBlbHQgLT4gdFxuICAgIHZhbCByZW1vdmU6IGVsdCAtPiB0IC0+IHRcbiAgICB2YWwgdW5pb246IHQgLT4gdCAtPiB0XG4gICAgdmFsIGludGVyOiB0IC0+IHQgLT4gdFxuICAgIHZhbCBkaWZmOiB0IC0+IHQgLT4gdFxuICAgIHZhbCBjb21wYXJlOiB0IC0+IHQgLT4gaW50XG4gICAgdmFsIGVxdWFsOiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBzdWJzZXQ6IHQgLT4gdCAtPiBib29sXG4gICAgdmFsIGl0ZXI6IChlbHQgLT4gdW5pdCkgLT4gdCAtPiB1bml0XG4gICAgdmFsIG1hcDogKGVsdCAtPiBlbHQpIC0+IHQgLT4gdFxuICAgIHZhbCBmb2xkOiAoZWx0IC0+ICdhIC0+ICdhKSAtPiB0IC0+ICdhIC0+ICdhXG4gICAgdmFsIGZvcl9hbGw6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBib29sXG4gICAgdmFsIGV4aXN0czogKGVsdCAtPiBib29sKSAtPiB0IC0+IGJvb2xcbiAgICB2YWwgZmlsdGVyOiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gdFxuICAgIHZhbCBwYXJ0aXRpb246IChlbHQgLT4gYm9vbCkgLT4gdCAtPiB0ICogdFxuICAgIHZhbCBjYXJkaW5hbDogdCAtPiBpbnRcbiAgICB2YWwgZWxlbWVudHM6IHQgLT4gZWx0IGxpc3RcbiAgICB2YWwgbWluX2VsdDogdCAtPiBlbHRcbiAgICB2YWwgbWluX2VsdF9vcHQ6IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBtYXhfZWx0OiB0IC0+IGVsdFxuICAgIHZhbCBtYXhfZWx0X29wdDogdCAtPiBlbHQgb3B0aW9uXG4gICAgdmFsIGNob29zZTogdCAtPiBlbHRcbiAgICB2YWwgY2hvb3NlX29wdDogdCAtPiBlbHQgb3B0aW9uXG4gICAgdmFsIHNwbGl0OiBlbHQgLT4gdCAtPiB0ICogYm9vbCAqIHRcbiAgICB2YWwgZmluZDogZWx0IC0+IHQgLT4gZWx0XG4gICAgdmFsIGZpbmRfb3B0OiBlbHQgLT4gdCAtPiBlbHQgb3B0aW9uXG4gICAgdmFsIGZpbmRfZmlyc3Q6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBlbHRcbiAgICB2YWwgZmluZF9maXJzdF9vcHQ6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBlbHQgb3B0aW9uXG4gICAgdmFsIGZpbmRfbGFzdDogKGVsdCAtPiBib29sKSAtPiB0IC0+IGVsdFxuICAgIHZhbCBmaW5kX2xhc3Rfb3B0OiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBvZl9saXN0OiBlbHQgbGlzdCAtPiB0XG4gIGVuZFxuXG5tb2R1bGUgTWFrZShPcmQ6IE9yZGVyZWRUeXBlKSA9XG4gIHN0cnVjdFxuICAgIHR5cGUgZWx0ID0gT3JkLnRcbiAgICB0eXBlIHQgPSBFbXB0eSB8IE5vZGUgb2Yge2w6dDsgdjplbHQ7IHI6dDsgaDppbnR9XG5cbiAgICAoKiBTZXRzIGFyZSByZXByZXNlbnRlZCBieSBiYWxhbmNlZCBiaW5hcnkgdHJlZXMgKHRoZSBoZWlnaHRzIG9mIHRoZVxuICAgICAgIGNoaWxkcmVuIGRpZmZlciBieSBhdCBtb3N0IDIgKilcblxuICAgIGxldCBoZWlnaHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAwXG4gICAgICB8IE5vZGUge2h9IC0+IGhcblxuICAgICgqIENyZWF0ZXMgYSBuZXcgbm9kZSB3aXRoIGxlZnQgc29uIGwsIHZhbHVlIHYgYW5kIHJpZ2h0IHNvbiByLlxuICAgICAgIFdlIG11c3QgaGF2ZSBhbGwgZWxlbWVudHMgb2YgbCA8IHYgPCBhbGwgZWxlbWVudHMgb2Ygci5cbiAgICAgICBsIGFuZCByIG11c3QgYmUgYmFsYW5jZWQgYW5kIHwgaGVpZ2h0IGwgLSBoZWlnaHQgciB8IDw9IDIuXG4gICAgICAgSW5saW5lIGV4cGFuc2lvbiBvZiBoZWlnaHQgZm9yIGJldHRlciBzcGVlZC4gKilcblxuICAgIGxldCBjcmVhdGUgbCB2IHIgPVxuICAgICAgbGV0IGhsID0gbWF0Y2ggbCB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBsZXQgaHIgPSBtYXRjaCByIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIE5vZGV7bDsgdjsgcjsgaD0oaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEpfVxuXG4gICAgKCogU2FtZSBhcyBjcmVhdGUsIGJ1dCBwZXJmb3JtcyBvbmUgc3RlcCBvZiByZWJhbGFuY2luZyBpZiBuZWNlc3NhcnkuXG4gICAgICAgQXNzdW1lcyBsIGFuZCByIGJhbGFuY2VkIGFuZCB8IGhlaWdodCBsIC0gaGVpZ2h0IHIgfCA8PSAzLlxuICAgICAgIElubGluZSBleHBhbnNpb24gb2YgY3JlYXRlIGZvciBiZXR0ZXIgc3BlZWQgaW4gdGhlIG1vc3QgZnJlcXVlbnQgY2FzZVxuICAgICAgIHdoZXJlIG5vIHJlYmFsYW5jaW5nIGlzIHJlcXVpcmVkLiAqKVxuXG4gICAgbGV0IGJhbCBsIHYgciA9XG4gICAgICBsZXQgaGwgPSBtYXRjaCBsIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIGxldCBociA9IG1hdGNoIHIgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgaWYgaGwgPiBociArIDIgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIlNldC5iYWxcIlxuICAgICAgICB8IE5vZGV7bD1sbDsgdj1sdjsgcj1scn0gLT5cbiAgICAgICAgICAgIGlmIGhlaWdodCBsbCA+PSBoZWlnaHQgbHIgdGhlblxuICAgICAgICAgICAgICBjcmVhdGUgbGwgbHYgKGNyZWF0ZSBsciB2IHIpXG4gICAgICAgICAgICBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIG1hdGNoIGxyIHdpdGhcbiAgICAgICAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIlNldC5iYWxcIlxuICAgICAgICAgICAgICB8IE5vZGV7bD1scmw7IHY9bHJ2OyByPWxycn0tPlxuICAgICAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbGwgbHYgbHJsKSBscnYgKGNyZWF0ZSBscnIgdiByKVxuICAgICAgICAgICAgZW5kXG4gICAgICBlbmQgZWxzZSBpZiBociA+IGhsICsgMiB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIHIgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LmJhbFwiXG4gICAgICAgIHwgTm9kZXtsPXJsOyB2PXJ2OyByPXJyfSAtPlxuICAgICAgICAgICAgaWYgaGVpZ2h0IHJyID49IGhlaWdodCBybCB0aGVuXG4gICAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGwgdiBybCkgcnYgcnJcbiAgICAgICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbWF0Y2ggcmwgd2l0aFxuICAgICAgICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LmJhbFwiXG4gICAgICAgICAgICAgIHwgTm9kZXtsPXJsbDsgdj1ybHY7IHI9cmxyfSAtPlxuICAgICAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB2IHJsbCkgcmx2IChjcmVhdGUgcmxyIHJ2IHJyKVxuICAgICAgICAgICAgZW5kXG4gICAgICBlbmQgZWxzZVxuICAgICAgICBOb2Rle2w7IHY7IHI7IGg9KGlmIGhsID49IGhyIHRoZW4gaGwgKyAxIGVsc2UgaHIgKyAxKX1cblxuICAgICgqIEluc2VydGlvbiBvZiBvbmUgZWxlbWVudCAqKVxuXG4gICAgbGV0IHJlYyBhZGQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vZGV7bD1FbXB0eTsgdj14OyByPUVtcHR5OyBoPTF9XG4gICAgICB8IE5vZGV7bDsgdjsgcn0gYXMgdCAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiB0IGVsc2VcbiAgICAgICAgICBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgbGwgPSBhZGQgeCBsIGluXG4gICAgICAgICAgICBpZiBsID09IGxsIHRoZW4gdCBlbHNlIGJhbCBsbCB2IHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgcnIgPSBhZGQgeCByIGluXG4gICAgICAgICAgICBpZiByID09IHJyIHRoZW4gdCBlbHNlIGJhbCBsIHYgcnJcblxuICAgIGxldCBzaW5nbGV0b24geCA9IE5vZGV7bD1FbXB0eTsgdj14OyByPUVtcHR5OyBoPTF9XG5cbiAgICAoKiBCZXdhcmU6IHRob3NlIHR3byBmdW5jdGlvbnMgYXNzdW1lIHRoYXQgdGhlIGFkZGVkIHYgaXMgKnN0cmljdGx5KlxuICAgICAgIHNtYWxsZXIgKG9yIGJpZ2dlcikgdGhhbiBhbGwgdGhlIHByZXNlbnQgZWxlbWVudHMgaW4gdGhlIHRyZWU7IGl0XG4gICAgICAgZG9lcyBub3QgdGVzdCBmb3IgZXF1YWxpdHkgd2l0aCB0aGUgY3VycmVudCBtaW4gKG9yIG1heCkgZWxlbWVudC5cbiAgICAgICBJbmRlZWQsIHRoZXkgYXJlIG9ubHkgdXNlZCBkdXJpbmcgdGhlIFwiam9pblwiIG9wZXJhdGlvbiB3aGljaFxuICAgICAgIHJlc3BlY3RzIHRoaXMgcHJlY29uZGl0aW9uLlxuICAgICopXG5cbiAgICBsZXQgcmVjIGFkZF9taW5fZWxlbWVudCB4ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gc2luZ2xldG9uIHhcbiAgICAgIHwgTm9kZSB7bDsgdjsgcn0gLT5cbiAgICAgICAgYmFsIChhZGRfbWluX2VsZW1lbnQgeCBsKSB2IHJcblxuICAgIGxldCByZWMgYWRkX21heF9lbGVtZW50IHggPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBzaW5nbGV0b24geFxuICAgICAgfCBOb2RlIHtsOyB2OyByfSAtPlxuICAgICAgICBiYWwgbCB2IChhZGRfbWF4X2VsZW1lbnQgeCByKVxuXG4gICAgKCogU2FtZSBhcyBjcmVhdGUgYW5kIGJhbCwgYnV0IG5vIGFzc3VtcHRpb25zIGFyZSBtYWRlIG9uIHRoZVxuICAgICAgIHJlbGF0aXZlIGhlaWdodHMgb2YgbCBhbmQgci4gKilcblxuICAgIGxldCByZWMgam9pbiBsIHYgciA9XG4gICAgICBtYXRjaCAobCwgcikgd2l0aFxuICAgICAgICAoRW1wdHksIF8pIC0+IGFkZF9taW5fZWxlbWVudCB2IHJcbiAgICAgIHwgKF8sIEVtcHR5KSAtPiBhZGRfbWF4X2VsZW1lbnQgdiBsXG4gICAgICB8IChOb2Rle2w9bGw7IHY9bHY7IHI9bHI7IGg9bGh9LCBOb2Rle2w9cmw7IHY9cnY7IHI9cnI7IGg9cmh9KSAtPlxuICAgICAgICAgIGlmIGxoID4gcmggKyAyIHRoZW4gYmFsIGxsIGx2IChqb2luIGxyIHYgcikgZWxzZVxuICAgICAgICAgIGlmIHJoID4gbGggKyAyIHRoZW4gYmFsIChqb2luIGwgdiBybCkgcnYgcnIgZWxzZVxuICAgICAgICAgIGNyZWF0ZSBsIHYgclxuXG4gICAgKCogU21hbGxlc3QgYW5kIGdyZWF0ZXN0IGVsZW1lbnQgb2YgYSBzZXQgKilcblxuICAgIGxldCByZWMgbWluX2VsdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2Rle2w9RW1wdHk7IHZ9IC0+IHZcbiAgICAgIHwgTm9kZXtsfSAtPiBtaW5fZWx0IGxcblxuICAgIGxldCByZWMgbWluX2VsdF9vcHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb25lXG4gICAgICB8IE5vZGV7bD1FbXB0eTsgdn0gLT4gU29tZSB2XG4gICAgICB8IE5vZGV7bH0gLT4gbWluX2VsdF9vcHQgbFxuXG4gICAgbGV0IHJlYyBtYXhfZWx0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGV7djsgcj1FbXB0eX0gLT4gdlxuICAgICAgfCBOb2Rle3J9IC0+IG1heF9lbHQgclxuXG4gICAgbGV0IHJlYyBtYXhfZWx0X29wdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgTm9kZXt2OyByPUVtcHR5fSAtPiBTb21lIHZcbiAgICAgIHwgTm9kZXtyfSAtPiBtYXhfZWx0X29wdCByXG5cbiAgICAoKiBSZW1vdmUgdGhlIHNtYWxsZXN0IGVsZW1lbnQgb2YgdGhlIGdpdmVuIHNldCAqKVxuXG4gICAgbGV0IHJlYyByZW1vdmVfbWluX2VsdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LnJlbW92ZV9taW5fZWx0XCJcbiAgICAgIHwgTm9kZXtsPUVtcHR5OyByfSAtPiByXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gYmFsIChyZW1vdmVfbWluX2VsdCBsKSB2IHJcblxuICAgICgqIE1lcmdlIHR3byB0cmVlcyBsIGFuZCByIGludG8gb25lLlxuICAgICAgIEFsbCBlbGVtZW50cyBvZiBsIG11c3QgcHJlY2VkZSB0aGUgZWxlbWVudHMgb2Ygci5cbiAgICAgICBBc3N1bWUgfCBoZWlnaHQgbCAtIGhlaWdodCByIHwgPD0gMi4gKilcblxuICAgIGxldCBtZXJnZSB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+IGJhbCB0MSAobWluX2VsdCB0MikgKHJlbW92ZV9taW5fZWx0IHQyKVxuXG4gICAgKCogTWVyZ2UgdHdvIHRyZWVzIGwgYW5kIHIgaW50byBvbmUuXG4gICAgICAgQWxsIGVsZW1lbnRzIG9mIGwgbXVzdCBwcmVjZWRlIHRoZSBlbGVtZW50cyBvZiByLlxuICAgICAgIE5vIGFzc3VtcHRpb24gb24gdGhlIGhlaWdodHMgb2YgbCBhbmQgci4gKilcblxuICAgIGxldCBjb25jYXQgdDEgdDIgPVxuICAgICAgbWF0Y2ggKHQxLCB0Mikgd2l0aFxuICAgICAgICAoRW1wdHksIHQpIC0+IHRcbiAgICAgIHwgKHQsIEVtcHR5KSAtPiB0XG4gICAgICB8IChfLCBfKSAtPiBqb2luIHQxIChtaW5fZWx0IHQyKSAocmVtb3ZlX21pbl9lbHQgdDIpXG5cbiAgICAoKiBTcGxpdHRpbmcuICBzcGxpdCB4IHMgcmV0dXJucyBhIHRyaXBsZSAobCwgcHJlc2VudCwgcikgd2hlcmVcbiAgICAgICAgLSBsIGlzIHRoZSBzZXQgb2YgZWxlbWVudHMgb2YgcyB0aGF0IGFyZSA8IHhcbiAgICAgICAgLSByIGlzIHRoZSBzZXQgb2YgZWxlbWVudHMgb2YgcyB0aGF0IGFyZSA+IHhcbiAgICAgICAgLSBwcmVzZW50IGlzIGZhbHNlIGlmIHMgY29udGFpbnMgbm8gZWxlbWVudCBlcXVhbCB0byB4LFxuICAgICAgICAgIG9yIHRydWUgaWYgcyBjb250YWlucyBhbiBlbGVtZW50IGVxdWFsIHRvIHguICopXG5cbiAgICBsZXQgcmVjIHNwbGl0IHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIChFbXB0eSwgZmFsc2UsIEVtcHR5KVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIChsLCB0cnVlLCByKVxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IChsbCwgcHJlcywgcmwpID0gc3BsaXQgeCBsIGluIChsbCwgcHJlcywgam9pbiBybCB2IHIpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IChsciwgcHJlcywgcnIpID0gc3BsaXQgeCByIGluIChqb2luIGwgdiBsciwgcHJlcywgcnIpXG5cbiAgICAoKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgc2V0IG9wZXJhdGlvbnMgKilcblxuICAgIGxldCBlbXB0eSA9IEVtcHR5XG5cbiAgICBsZXQgaXNfZW1wdHkgPSBmdW5jdGlvbiBFbXB0eSAtPiB0cnVlIHwgXyAtPiBmYWxzZVxuXG4gICAgbGV0IHJlYyBtZW0geCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGZhbHNlXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGMgPSAwIHx8IG1lbSB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHJlYyByZW1vdmUgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IChOb2Rle2w7IHY7IHJ9IGFzIHQpIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIG1lcmdlIGwgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgICAgbGV0IGxsID0gcmVtb3ZlIHggbCBpblxuICAgICAgICAgICAgICBpZiBsID09IGxsIHRoZW4gdFxuICAgICAgICAgICAgICBlbHNlIGJhbCBsbCB2IHJcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbGV0IHJyID0gcmVtb3ZlIHggciBpblxuICAgICAgICAgICAgICBpZiByID09IHJyIHRoZW4gdFxuICAgICAgICAgICAgICBlbHNlIGJhbCBsIHYgcnJcblxuICAgIGxldCByZWMgdW5pb24gczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgICAoRW1wdHksIHQyKSAtPiB0MlxuICAgICAgfCAodDEsIEVtcHR5KSAtPiB0MVxuICAgICAgfCAoTm9kZXtsPWwxOyB2PXYxOyByPXIxOyBoPWgxfSwgTm9kZXtsPWwyOyB2PXYyOyByPXIyOyBoPWgyfSkgLT5cbiAgICAgICAgICBpZiBoMSA+PSBoMiB0aGVuXG4gICAgICAgICAgICBpZiBoMiA9IDEgdGhlbiBhZGQgdjIgczEgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBsZXQgKGwyLCBfLCByMikgPSBzcGxpdCB2MSBzMiBpblxuICAgICAgICAgICAgICBqb2luICh1bmlvbiBsMSBsMikgdjEgKHVuaW9uIHIxIHIyKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgaWYgaDEgPSAxIHRoZW4gYWRkIHYxIHMyIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbGV0IChsMSwgXywgcjEpID0gc3BsaXQgdjIgczEgaW5cbiAgICAgICAgICAgICAgam9pbiAodW5pb24gbDEgbDIpIHYyICh1bmlvbiByMSByMilcbiAgICAgICAgICAgIGVuZFxuXG4gICAgbGV0IHJlYyBpbnRlciBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgXykgLT4gRW1wdHlcbiAgICAgIHwgKF8sIEVtcHR5KSAtPiBFbXB0eVxuICAgICAgfCAoTm9kZXtsPWwxOyB2PXYxOyByPXIxfSwgdDIpIC0+XG4gICAgICAgICAgbWF0Y2ggc3BsaXQgdjEgdDIgd2l0aFxuICAgICAgICAgICAgKGwyLCBmYWxzZSwgcjIpIC0+XG4gICAgICAgICAgICAgIGNvbmNhdCAoaW50ZXIgbDEgbDIpIChpbnRlciByMSByMilcbiAgICAgICAgICB8IChsMiwgdHJ1ZSwgcjIpIC0+XG4gICAgICAgICAgICAgIGpvaW4gKGludGVyIGwxIGwyKSB2MSAoaW50ZXIgcjEgcjIpXG5cbiAgICBsZXQgcmVjIGRpZmYgczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgICAoRW1wdHksIF8pIC0+IEVtcHR5XG4gICAgICB8ICh0MSwgRW1wdHkpIC0+IHQxXG4gICAgICB8IChOb2Rle2w9bDE7IHY9djE7IHI9cjF9LCB0MikgLT5cbiAgICAgICAgICBtYXRjaCBzcGxpdCB2MSB0MiB3aXRoXG4gICAgICAgICAgICAobDIsIGZhbHNlLCByMikgLT5cbiAgICAgICAgICAgICAgam9pbiAoZGlmZiBsMSBsMikgdjEgKGRpZmYgcjEgcjIpXG4gICAgICAgICAgfCAobDIsIHRydWUsIHIyKSAtPlxuICAgICAgICAgICAgICBjb25jYXQgKGRpZmYgbDEgbDIpIChkaWZmIHIxIHIyKVxuXG4gICAgdHlwZSBlbnVtZXJhdGlvbiA9IEVuZCB8IE1vcmUgb2YgZWx0ICogdCAqIGVudW1lcmF0aW9uXG5cbiAgICBsZXQgcmVjIGNvbnNfZW51bSBzIGUgPVxuICAgICAgbWF0Y2ggcyB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBjb25zX2VudW0gbCAoTW9yZSh2LCByLCBlKSlcblxuICAgIGxldCByZWMgY29tcGFyZV9hdXggZTEgZTIgPVxuICAgICAgICBtYXRjaCAoZTEsIGUyKSB3aXRoXG4gICAgICAgIChFbmQsIEVuZCkgLT4gMFxuICAgICAgfCAoRW5kLCBfKSAgLT4gLTFcbiAgICAgIHwgKF8sIEVuZCkgLT4gMVxuICAgICAgfCAoTW9yZSh2MSwgcjEsIGUxKSwgTW9yZSh2MiwgcjIsIGUyKSkgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHYxIHYyIGluXG4gICAgICAgICAgaWYgYyA8PiAwXG4gICAgICAgICAgdGhlbiBjXG4gICAgICAgICAgZWxzZSBjb21wYXJlX2F1eCAoY29uc19lbnVtIHIxIGUxKSAoY29uc19lbnVtIHIyIGUyKVxuXG4gICAgbGV0IGNvbXBhcmUgczEgczIgPVxuICAgICAgY29tcGFyZV9hdXggKGNvbnNfZW51bSBzMSBFbmQpIChjb25zX2VudW0gczIgRW5kKVxuXG4gICAgbGV0IGVxdWFsIHMxIHMyID1cbiAgICAgIGNvbXBhcmUgczEgczIgPSAwXG5cbiAgICBsZXQgcmVjIHN1YnNldCBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIEVtcHR5LCBfIC0+XG4gICAgICAgICAgdHJ1ZVxuICAgICAgfCBfLCBFbXB0eSAtPlxuICAgICAgICAgIGZhbHNlXG4gICAgICB8IE5vZGUge2w9bDE7IHY9djE7IHI9cjF9LCAoTm9kZSB7bD1sMjsgdj12Mjsgcj1yMn0gYXMgdDIpIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB2MSB2MiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW5cbiAgICAgICAgICAgIHN1YnNldCBsMSBsMiAmJiBzdWJzZXQgcjEgcjJcbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIHN1YnNldCAoTm9kZSB7bD1sMTsgdj12MTsgcj1FbXB0eTsgaD0wfSkgbDIgJiYgc3Vic2V0IHIxIHQyXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgc3Vic2V0IChOb2RlIHtsPUVtcHR5OyB2PXYxOyByPXIxOyBoPTB9KSByMiAmJiBzdWJzZXQgbDEgdDJcblxuICAgIGxldCByZWMgaXRlciBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gKClcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBpdGVyIGYgbDsgZiB2OyBpdGVyIGYgclxuXG4gICAgbGV0IHJlYyBmb2xkIGYgcyBhY2N1ID1cbiAgICAgIG1hdGNoIHMgd2l0aFxuICAgICAgICBFbXB0eSAtPiBhY2N1XG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gZm9sZCBmIHIgKGYgdiAoZm9sZCBmIGwgYWNjdSkpXG5cbiAgICBsZXQgcmVjIGZvcl9hbGwgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHRydWVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBwIHYgJiYgZm9yX2FsbCBwIGwgJiYgZm9yX2FsbCBwIHJcblxuICAgIGxldCByZWMgZXhpc3RzIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBmYWxzZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IHAgdiB8fCBleGlzdHMgcCBsIHx8IGV4aXN0cyBwIHJcblxuICAgIGxldCByZWMgZmlsdGVyIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBFbXB0eVxuICAgICAgfCAoTm9kZXtsOyB2OyByfSkgYXMgdCAtPlxuICAgICAgICAgICgqIGNhbGwgW3BdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IGwnID0gZmlsdGVyIHAgbCBpblxuICAgICAgICAgIGxldCBwdiA9IHAgdiBpblxuICAgICAgICAgIGxldCByJyA9IGZpbHRlciBwIHIgaW5cbiAgICAgICAgICBpZiBwdiB0aGVuXG4gICAgICAgICAgICBpZiBsPT1sJyAmJiByPT1yJyB0aGVuIHQgZWxzZSBqb2luIGwnIHYgcidcbiAgICAgICAgICBlbHNlIGNvbmNhdCBsJyByJ1xuXG4gICAgbGV0IHJlYyBwYXJ0aXRpb24gcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IChFbXB0eSwgRW1wdHkpXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICAoKiBjYWxsIFtwXSBpbiB0aGUgZXhwZWN0ZWQgbGVmdC10by1yaWdodCBvcmRlciAqKVxuICAgICAgICAgIGxldCAobHQsIGxmKSA9IHBhcnRpdGlvbiBwIGwgaW5cbiAgICAgICAgICBsZXQgcHYgPSBwIHYgaW5cbiAgICAgICAgICBsZXQgKHJ0LCByZikgPSBwYXJ0aXRpb24gcCByIGluXG4gICAgICAgICAgaWYgcHZcbiAgICAgICAgICB0aGVuIChqb2luIGx0IHYgcnQsIGNvbmNhdCBsZiByZilcbiAgICAgICAgICBlbHNlIChjb25jYXQgbHQgcnQsIGpvaW4gbGYgdiByZilcblxuICAgIGxldCByZWMgY2FyZGluYWwgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAwXG4gICAgICB8IE5vZGV7bDsgcn0gLT4gY2FyZGluYWwgbCArIDEgKyBjYXJkaW5hbCByXG5cbiAgICBsZXQgcmVjIGVsZW1lbnRzX2F1eCBhY2N1ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IGVsZW1lbnRzX2F1eCAodiA6OiBlbGVtZW50c19hdXggYWNjdSByKSBsXG5cbiAgICBsZXQgZWxlbWVudHMgcyA9XG4gICAgICBlbGVtZW50c19hdXggW10gc1xuXG4gICAgbGV0IGNob29zZSA9IG1pbl9lbHRcblxuICAgIGxldCBjaG9vc2Vfb3B0ID0gbWluX2VsdF9vcHRcblxuICAgIGxldCByZWMgZmluZCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gdlxuICAgICAgICAgIGVsc2UgZmluZCB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X2F1eCB2MCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICB2MFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdjAgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3QgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdiBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0IGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X29wdF9hdXggdjAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgU29tZSB2MFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2IGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2MCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9vcHQgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2IGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0IGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3RfYXV4IHYwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHYwXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2IGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdjAgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0IGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3Rfb3B0X2F1eCB2MCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBTb21lIHYwXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdiBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2MCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0X29wdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdiBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0IGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX29wdCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIFNvbWUgdlxuICAgICAgICAgIGVsc2UgZmluZF9vcHQgeCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCB0cnlfam9pbiBsIHYgciA9XG4gICAgICAoKiBbam9pbiBsIHYgcl0gY2FuIG9ubHkgYmUgY2FsbGVkIHdoZW4gKGVsZW1lbnRzIG9mIGwgPCB2IDxcbiAgICAgICAgIGVsZW1lbnRzIG9mIHIpOyB1c2UgW3RyeV9qb2luIGwgdiByXSB3aGVuIHRoaXMgcHJvcGVydHkgbWF5XG4gICAgICAgICBub3QgaG9sZCwgYnV0IHlvdSBob3BlIGl0IGRvZXMgaG9sZCBpbiB0aGUgY29tbW9uIGNhc2UgKilcbiAgICAgIGlmIChsID0gRW1wdHkgfHwgT3JkLmNvbXBhcmUgKG1heF9lbHQgbCkgdiA8IDApXG4gICAgICAmJiAociA9IEVtcHR5IHx8IE9yZC5jb21wYXJlIHYgKG1pbl9lbHQgcikgPCAwKVxuICAgICAgdGhlbiBqb2luIGwgdiByXG4gICAgICBlbHNlIHVuaW9uIGwgKGFkZCB2IHIpXG5cbiAgICBsZXQgcmVjIG1hcCBmID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgTm9kZXtsOyB2OyByfSBhcyB0IC0+XG4gICAgICAgICAoKiBlbmZvcmNlIGxlZnQtdG8tcmlnaHQgZXZhbHVhdGlvbiBvcmRlciAqKVxuICAgICAgICAgbGV0IGwnID0gbWFwIGYgbCBpblxuICAgICAgICAgbGV0IHYnID0gZiB2IGluXG4gICAgICAgICBsZXQgcicgPSBtYXAgZiByIGluXG4gICAgICAgICBpZiBsID09IGwnICYmIHYgPT0gdicgJiYgciA9PSByJyB0aGVuIHRcbiAgICAgICAgIGVsc2UgdHJ5X2pvaW4gbCcgdicgcidcblxuICAgIGxldCBvZl9zb3J0ZWRfbGlzdCBsID1cbiAgICAgIGxldCByZWMgc3ViIG4gbCA9XG4gICAgICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgICAgICB8IDAsIGwgLT4gRW1wdHksIGxcbiAgICAgICAgfCAxLCB4MCA6OiBsIC0+IE5vZGUge2w9RW1wdHk7IHY9eDA7IHI9RW1wdHk7IGg9MX0sIGxcbiAgICAgICAgfCAyLCB4MCA6OiB4MSA6OiBsIC0+XG4gICAgICAgICAgICBOb2Rle2w9Tm9kZXtsPUVtcHR5OyB2PXgwOyByPUVtcHR5OyBoPTF9OyB2PXgxOyByPUVtcHR5OyBoPTJ9LCBsXG4gICAgICAgIHwgMywgeDAgOjogeDEgOjogeDIgOjogbCAtPlxuICAgICAgICAgICAgTm9kZXtsPU5vZGV7bD1FbXB0eTsgdj14MDsgcj1FbXB0eTsgaD0xfTsgdj14MTtcbiAgICAgICAgICAgICAgICAgcj1Ob2Rle2w9RW1wdHk7IHY9eDI7IHI9RW1wdHk7IGg9MX07IGg9Mn0sIGxcbiAgICAgICAgfCBuLCBsIC0+XG4gICAgICAgICAgbGV0IG5sID0gbiAvIDIgaW5cbiAgICAgICAgICBsZXQgbGVmdCwgbCA9IHN1YiBubCBsIGluXG4gICAgICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICAgICAgfCBbXSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICB8IG1pZCA6OiBsIC0+XG4gICAgICAgICAgICBsZXQgcmlnaHQsIGwgPSBzdWIgKG4gLSBubCAtIDEpIGwgaW5cbiAgICAgICAgICAgIGNyZWF0ZSBsZWZ0IG1pZCByaWdodCwgbFxuICAgICAgaW5cbiAgICAgIGZzdCAoc3ViIChMaXN0Lmxlbmd0aCBsKSBsKVxuXG4gICAgbGV0IG9mX2xpc3QgbCA9XG4gICAgICBtYXRjaCBsIHdpdGhcbiAgICAgIHwgW10gLT4gZW1wdHlcbiAgICAgIHwgW3gwXSAtPiBzaW5nbGV0b24geDBcbiAgICAgIHwgW3gwOyB4MV0gLT4gYWRkIHgxIChzaW5nbGV0b24geDApXG4gICAgICB8IFt4MDsgeDE7IHgyXSAtPiBhZGQgeDIgKGFkZCB4MSAoc2luZ2xldG9uIHgwKSlcbiAgICAgIHwgW3gwOyB4MTsgeDI7IHgzXSAtPiBhZGQgeDMgKGFkZCB4MiAoYWRkIHgxIChzaW5nbGV0b24geDApKSlcbiAgICAgIHwgW3gwOyB4MTsgeDI7IHgzOyB4NF0gLT4gYWRkIHg0IChhZGQgeDMgKGFkZCB4MiAoYWRkIHgxIChzaW5nbGV0b24geDApKSkpXG4gICAgICB8IF8gLT4gb2Zfc29ydGVkX2xpc3QgKExpc3Quc29ydF91bmlxIE9yZC5jb21wYXJlIGwpXG4gIGVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5tb2R1bGUgdHlwZSBPcmRlcmVkVHlwZSA9XG4gIHNpZ1xuICAgIHR5cGUgdFxuICAgIHZhbCBjb21wYXJlOiB0IC0+IHQgLT4gaW50XG4gIGVuZFxuXG5tb2R1bGUgdHlwZSBTID1cbiAgc2lnXG4gICAgdHlwZSBrZXlcbiAgICB0eXBlICsnYSB0XG4gICAgdmFsIGVtcHR5OiAnYSB0XG4gICAgdmFsIGlzX2VtcHR5OiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgbWVtOiAga2V5IC0+ICdhIHQgLT4gYm9vbFxuICAgIHZhbCBhZGQ6IGtleSAtPiAnYSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgdXBkYXRlOiBrZXkgLT4gKCdhIG9wdGlvbiAtPiAnYSBvcHRpb24pIC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBzaW5nbGV0b246IGtleSAtPiAnYSAtPiAnYSB0XG4gICAgdmFsIHJlbW92ZToga2V5IC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBtZXJnZTpcbiAgICAgICAgICAoa2V5IC0+ICdhIG9wdGlvbiAtPiAnYiBvcHRpb24gLT4gJ2Mgb3B0aW9uKSAtPiAnYSB0IC0+ICdiIHQgLT4gJ2MgdFxuICAgIHZhbCB1bmlvbjogKGtleSAtPiAnYSAtPiAnYSAtPiAnYSBvcHRpb24pIC0+ICdhIHQgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIGNvbXBhcmU6ICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIHQgLT4gJ2EgdCAtPiBpbnRcbiAgICB2YWwgZXF1YWw6ICgnYSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+ICdhIHQgLT4gYm9vbFxuICAgIHZhbCBpdGVyOiAoa2V5IC0+ICdhIC0+IHVuaXQpIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmb2xkOiAoa2V5IC0+ICdhIC0+ICdiIC0+ICdiKSAtPiAnYSB0IC0+ICdiIC0+ICdiXG4gICAgdmFsIGZvcl9hbGw6IChrZXkgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiBib29sXG4gICAgdmFsIGV4aXN0czogKGtleSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgZmlsdGVyOiAoa2V5IC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBwYXJ0aXRpb246IChrZXkgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0ICogJ2EgdFxuICAgIHZhbCBjYXJkaW5hbDogJ2EgdCAtPiBpbnRcbiAgICB2YWwgYmluZGluZ3M6ICdhIHQgLT4gKGtleSAqICdhKSBsaXN0XG4gICAgdmFsIG1pbl9iaW5kaW5nOiAnYSB0IC0+IChrZXkgKiAnYSlcbiAgICB2YWwgbWluX2JpbmRpbmdfb3B0OiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIG1heF9iaW5kaW5nOiAnYSB0IC0+IChrZXkgKiAnYSlcbiAgICB2YWwgbWF4X2JpbmRpbmdfb3B0OiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIGNob29zZTogJ2EgdCAtPiAoa2V5ICogJ2EpXG4gICAgdmFsIGNob29zZV9vcHQ6ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgc3BsaXQ6IGtleSAtPiAnYSB0IC0+ICdhIHQgKiAnYSBvcHRpb24gKiAnYSB0XG4gICAgdmFsIGZpbmQ6IGtleSAtPiAnYSB0IC0+ICdhXG4gICAgdmFsIGZpbmRfb3B0OiBrZXkgLT4gJ2EgdCAtPiAnYSBvcHRpb25cbiAgICB2YWwgZmluZF9maXJzdDogKGtleSAtPiBib29sKSAtPiAnYSB0IC0+IGtleSAqICdhXG4gICAgdmFsIGZpbmRfZmlyc3Rfb3B0OiAoa2V5IC0+IGJvb2wpIC0+ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgZmluZF9sYXN0OiAoa2V5IC0+IGJvb2wpIC0+ICdhIHQgLT4ga2V5ICogJ2FcbiAgICB2YWwgZmluZF9sYXN0X29wdDogKGtleSAtPiBib29sKSAtPiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIG1hcDogKCdhIC0+ICdiKSAtPiAnYSB0IC0+ICdiIHRcbiAgICB2YWwgbWFwaTogKGtleSAtPiAnYSAtPiAnYikgLT4gJ2EgdCAtPiAnYiB0XG4gIGVuZFxuXG5tb2R1bGUgTWFrZShPcmQ6IE9yZGVyZWRUeXBlKSA9IHN0cnVjdFxuXG4gICAgdHlwZSBrZXkgPSBPcmQudFxuXG4gICAgdHlwZSAnYSB0ID1cbiAgICAgICAgRW1wdHlcbiAgICAgIHwgTm9kZSBvZiB7bDonYSB0OyB2OmtleTsgZDonYTsgcjonYSB0OyBoOmludH1cblxuICAgIGxldCBoZWlnaHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAwXG4gICAgICB8IE5vZGUge2h9IC0+IGhcblxuICAgIGxldCBjcmVhdGUgbCB4IGQgciA9XG4gICAgICBsZXQgaGwgPSBoZWlnaHQgbCBhbmQgaHIgPSBoZWlnaHQgciBpblxuICAgICAgTm9kZXtsOyB2PXg7IGQ7IHI7IGg9KGlmIGhsID49IGhyIHRoZW4gaGwgKyAxIGVsc2UgaHIgKyAxKX1cblxuICAgIGxldCBzaW5nbGV0b24geCBkID0gTm9kZXtsPUVtcHR5OyB2PXg7IGQ7IHI9RW1wdHk7IGg9MX1cblxuICAgIGxldCBiYWwgbCB4IGQgciA9XG4gICAgICBsZXQgaGwgPSBtYXRjaCBsIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIGxldCBociA9IG1hdGNoIHIgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgaWYgaGwgPiBociArIDIgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgICB8IE5vZGV7bD1sbDsgdj1sdjsgZD1sZDsgcj1scn0gLT5cbiAgICAgICAgICAgIGlmIGhlaWdodCBsbCA+PSBoZWlnaHQgbHIgdGhlblxuICAgICAgICAgICAgICBjcmVhdGUgbGwgbHYgbGQgKGNyZWF0ZSBsciB4IGQgcilcbiAgICAgICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbWF0Y2ggbHIgd2l0aFxuICAgICAgICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgICAgICAgIHwgTm9kZXtsPWxybDsgdj1scnY7IGQ9bHJkOyByPWxycn0tPlxuICAgICAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbGwgbHYgbGQgbHJsKSBscnYgbHJkIChjcmVhdGUgbHJyIHggZCByKVxuICAgICAgICAgICAgZW5kXG4gICAgICBlbmQgZWxzZSBpZiBociA+IGhsICsgMiB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIHIgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgIHwgTm9kZXtsPXJsOyB2PXJ2OyBkPXJkOyByPXJyfSAtPlxuICAgICAgICAgICAgaWYgaGVpZ2h0IHJyID49IGhlaWdodCBybCB0aGVuXG4gICAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGwgeCBkIHJsKSBydiByZCByclxuICAgICAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBtYXRjaCBybCB3aXRoXG4gICAgICAgICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgICAgICAgfCBOb2Rle2w9cmxsOyB2PXJsdjsgZD1ybGQ7IHI9cmxyfSAtPlxuICAgICAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB4IGQgcmxsKSBybHYgcmxkIChjcmVhdGUgcmxyIHJ2IHJkIHJyKVxuICAgICAgICAgICAgZW5kXG4gICAgICBlbmQgZWxzZVxuICAgICAgICBOb2Rle2w7IHY9eDsgZDsgcjsgaD0oaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEpfVxuXG4gICAgbGV0IGVtcHR5ID0gRW1wdHlcblxuICAgIGxldCBpc19lbXB0eSA9IGZ1bmN0aW9uIEVtcHR5IC0+IHRydWUgfCBfIC0+IGZhbHNlXG5cbiAgICBsZXQgcmVjIGFkZCB4IGRhdGEgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vZGV7bD1FbXB0eTsgdj14OyBkPWRhdGE7IHI9RW1wdHk7IGg9MX1cbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgaH0gYXMgbSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlblxuICAgICAgICAgICAgaWYgZCA9PSBkYXRhIHRoZW4gbSBlbHNlIE5vZGV7bDsgdj14OyBkPWRhdGE7IHI7IGh9XG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgbGwgPSBhZGQgeCBkYXRhIGwgaW5cbiAgICAgICAgICAgIGlmIGwgPT0gbGwgdGhlbiBtIGVsc2UgYmFsIGxsIHYgZCByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IHJyID0gYWRkIHggZGF0YSByIGluXG4gICAgICAgICAgICBpZiByID09IHJyIHRoZW4gbSBlbHNlIGJhbCBsIHYgZCByclxuXG4gICAgbGV0IHJlYyBmaW5kIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBkXG4gICAgICAgICAgZWxzZSBmaW5kIHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3RfYXV4IHYwIGQwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgICh2MCwgZDApXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYgZCBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2MCBkMCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdiBkIGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3QgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3Rfb3B0X2F1eCB2MCBkMCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBTb21lICh2MCwgZDApXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2IGQgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYwIGQwIGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X29wdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2IGQgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHQgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9hdXggdjAgZDAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgKHYwLCBkMClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2IGQgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2MCBkMCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYgZCBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3QgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9vcHRfYXV4IHYwIGQwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIFNvbWUgKHYwLCBkMClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdiBkIGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYwIGQwIGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3Rfb3B0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdiBkIGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHQgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfb3B0IHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gU29tZSBkXG4gICAgICAgICAgZWxzZSBmaW5kX29wdCB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHJlYyBtZW0geCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgZmFsc2VcbiAgICAgIHwgTm9kZSB7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGMgPSAwIHx8IG1lbSB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHJlYyBtaW5fYmluZGluZyA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHtsPUVtcHR5OyB2OyBkfSAtPiAodiwgZClcbiAgICAgIHwgTm9kZSB7bH0gLT4gbWluX2JpbmRpbmcgbFxuXG4gICAgbGV0IHJlYyBtaW5fYmluZGluZ19vcHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb25lXG4gICAgICB8IE5vZGUge2w9RW1wdHk7IHY7IGR9IC0+IFNvbWUgKHYsIGQpXG4gICAgICB8IE5vZGUge2x9LT4gbWluX2JpbmRpbmdfb3B0IGxcblxuICAgIGxldCByZWMgbWF4X2JpbmRpbmcgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZSB7djsgZDsgcj1FbXB0eX0gLT4gKHYsIGQpXG4gICAgICB8IE5vZGUge3J9IC0+IG1heF9iaW5kaW5nIHJcblxuICAgIGxldCByZWMgbWF4X2JpbmRpbmdfb3B0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBOb2RlIHt2OyBkOyByPUVtcHR5fSAtPiBTb21lICh2LCBkKVxuICAgICAgfCBOb2RlIHtyfSAtPiBtYXhfYmluZGluZ19vcHQgclxuXG4gICAgbGV0IHJlYyByZW1vdmVfbWluX2JpbmRpbmcgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5yZW1vdmVfbWluX2VsdFwiXG4gICAgICB8IE5vZGUge2w9RW1wdHk7IHJ9IC0+IHJcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT4gYmFsIChyZW1vdmVfbWluX2JpbmRpbmcgbCkgdiBkIHJcblxuICAgIGxldCBtZXJnZSB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+XG4gICAgICAgICAgbGV0ICh4LCBkKSA9IG1pbl9iaW5kaW5nIHQyIGluXG4gICAgICAgICAgYmFsIHQxIHggZCAocmVtb3ZlX21pbl9iaW5kaW5nIHQyKVxuXG4gICAgbGV0IHJlYyByZW1vdmUgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgRW1wdHlcbiAgICAgIHwgKE5vZGUge2w7IHY7IGQ7IHJ9IGFzIG0pIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIG1lcmdlIGwgclxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IGxsID0gcmVtb3ZlIHggbCBpbiBpZiBsID09IGxsIHRoZW4gbSBlbHNlIGJhbCBsbCB2IGQgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCByciA9IHJlbW92ZSB4IHIgaW4gaWYgciA9PSByciB0aGVuIG0gZWxzZSBiYWwgbCB2IGQgcnJcblxuICAgIGxldCByZWMgdXBkYXRlIHggZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggZiBOb25lIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gRW1wdHlcbiAgICAgICAgICB8IFNvbWUgZGF0YSAtPiBOb2Rle2w9RW1wdHk7IHY9eDsgZD1kYXRhOyByPUVtcHR5OyBoPTF9XG4gICAgICAgICAgZW5kXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHI7IGh9IGFzIG0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gYmVnaW5cbiAgICAgICAgICAgIG1hdGNoIGYgKFNvbWUgZCkgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IG1lcmdlIGwgclxuICAgICAgICAgICAgfCBTb21lIGRhdGEgLT5cbiAgICAgICAgICAgICAgICBpZiBkID09IGRhdGEgdGhlbiBtIGVsc2UgTm9kZXtsOyB2PXg7IGQ9ZGF0YTsgcjsgaH1cbiAgICAgICAgICBlbmQgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgbGwgPSB1cGRhdGUgeCBmIGwgaW5cbiAgICAgICAgICAgIGlmIGwgPT0gbGwgdGhlbiBtIGVsc2UgYmFsIGxsIHYgZCByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IHJyID0gdXBkYXRlIHggZiByIGluXG4gICAgICAgICAgICBpZiByID09IHJyIHRoZW4gbSBlbHNlIGJhbCBsIHYgZCByclxuXG4gICAgbGV0IHJlYyBpdGVyIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAoKVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGl0ZXIgZiBsOyBmIHYgZDsgaXRlciBmIHJcblxuICAgIGxldCByZWMgbWFwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIEVtcHR5XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHI7IGh9IC0+XG4gICAgICAgICAgbGV0IGwnID0gbWFwIGYgbCBpblxuICAgICAgICAgIGxldCBkJyA9IGYgZCBpblxuICAgICAgICAgIGxldCByJyA9IG1hcCBmIHIgaW5cbiAgICAgICAgICBOb2Rle2w9bCc7IHY7IGQ9ZCc7IHI9cic7IGh9XG5cbiAgICBsZXQgcmVjIG1hcGkgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgRW1wdHlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgaH0gLT5cbiAgICAgICAgICBsZXQgbCcgPSBtYXBpIGYgbCBpblxuICAgICAgICAgIGxldCBkJyA9IGYgdiBkIGluXG4gICAgICAgICAgbGV0IHInID0gbWFwaSBmIHIgaW5cbiAgICAgICAgICBOb2Rle2w9bCc7IHY7IGQ9ZCc7IHI9cic7IGh9XG5cbiAgICBsZXQgcmVjIGZvbGQgZiBtIGFjY3UgPVxuICAgICAgbWF0Y2ggbSB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBmb2xkIGYgciAoZiB2IGQgKGZvbGQgZiBsIGFjY3UpKVxuXG4gICAgbGV0IHJlYyBmb3JfYWxsIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiB0cnVlXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IHAgdiBkICYmIGZvcl9hbGwgcCBsICYmIGZvcl9hbGwgcCByXG5cbiAgICBsZXQgcmVjIGV4aXN0cyBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gZmFsc2VcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT4gcCB2IGQgfHwgZXhpc3RzIHAgbCB8fCBleGlzdHMgcCByXG5cbiAgICAoKiBCZXdhcmU6IHRob3NlIHR3byBmdW5jdGlvbnMgYXNzdW1lIHRoYXQgdGhlIGFkZGVkIGsgaXMgKnN0cmljdGx5KlxuICAgICAgIHNtYWxsZXIgKG9yIGJpZ2dlcikgdGhhbiBhbGwgdGhlIHByZXNlbnQga2V5cyBpbiB0aGUgdHJlZTsgaXRcbiAgICAgICBkb2VzIG5vdCB0ZXN0IGZvciBlcXVhbGl0eSB3aXRoIHRoZSBjdXJyZW50IG1pbiAob3IgbWF4KSBrZXkuXG5cbiAgICAgICBJbmRlZWQsIHRoZXkgYXJlIG9ubHkgdXNlZCBkdXJpbmcgdGhlIFwiam9pblwiIG9wZXJhdGlvbiB3aGljaFxuICAgICAgIHJlc3BlY3RzIHRoaXMgcHJlY29uZGl0aW9uLlxuICAgICopXG5cbiAgICBsZXQgcmVjIGFkZF9taW5fYmluZGluZyBrIHggPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBzaW5nbGV0b24gayB4XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgIGJhbCAoYWRkX21pbl9iaW5kaW5nIGsgeCBsKSB2IGQgclxuXG4gICAgbGV0IHJlYyBhZGRfbWF4X2JpbmRpbmcgayB4ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gc2luZ2xldG9uIGsgeFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICBiYWwgbCB2IGQgKGFkZF9tYXhfYmluZGluZyBrIHggcilcblxuICAgICgqIFNhbWUgYXMgY3JlYXRlIGFuZCBiYWwsIGJ1dCBubyBhc3N1bXB0aW9ucyBhcmUgbWFkZSBvbiB0aGVcbiAgICAgICByZWxhdGl2ZSBoZWlnaHRzIG9mIGwgYW5kIHIuICopXG5cbiAgICBsZXQgcmVjIGpvaW4gbCB2IGQgciA9XG4gICAgICBtYXRjaCAobCwgcikgd2l0aFxuICAgICAgICAoRW1wdHksIF8pIC0+IGFkZF9taW5fYmluZGluZyB2IGQgclxuICAgICAgfCAoXywgRW1wdHkpIC0+IGFkZF9tYXhfYmluZGluZyB2IGQgbFxuICAgICAgfCAoTm9kZXtsPWxsOyB2PWx2OyBkPWxkOyByPWxyOyBoPWxofSwgTm9kZXtsPXJsOyB2PXJ2OyBkPXJkOyByPXJyOyBoPXJofSkgLT5cbiAgICAgICAgICBpZiBsaCA+IHJoICsgMiB0aGVuIGJhbCBsbCBsdiBsZCAoam9pbiBsciB2IGQgcikgZWxzZVxuICAgICAgICAgIGlmIHJoID4gbGggKyAyIHRoZW4gYmFsIChqb2luIGwgdiBkIHJsKSBydiByZCByciBlbHNlXG4gICAgICAgICAgY3JlYXRlIGwgdiBkIHJcblxuICAgICgqIE1lcmdlIHR3byB0cmVlcyBsIGFuZCByIGludG8gb25lLlxuICAgICAgIEFsbCBlbGVtZW50cyBvZiBsIG11c3QgcHJlY2VkZSB0aGUgZWxlbWVudHMgb2Ygci5cbiAgICAgICBObyBhc3N1bXB0aW9uIG9uIHRoZSBoZWlnaHRzIG9mIGwgYW5kIHIuICopXG5cbiAgICBsZXQgY29uY2F0IHQxIHQyID1cbiAgICAgIG1hdGNoICh0MSwgdDIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0KSAtPiB0XG4gICAgICB8ICh0LCBFbXB0eSkgLT4gdFxuICAgICAgfCAoXywgXykgLT5cbiAgICAgICAgICBsZXQgKHgsIGQpID0gbWluX2JpbmRpbmcgdDIgaW5cbiAgICAgICAgICBqb2luIHQxIHggZCAocmVtb3ZlX21pbl9iaW5kaW5nIHQyKVxuXG4gICAgbGV0IGNvbmNhdF9vcl9qb2luIHQxIHYgZCB0MiA9XG4gICAgICBtYXRjaCBkIHdpdGhcbiAgICAgIHwgU29tZSBkIC0+IGpvaW4gdDEgdiBkIHQyXG4gICAgICB8IE5vbmUgLT4gY29uY2F0IHQxIHQyXG5cbiAgICBsZXQgcmVjIHNwbGl0IHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIChFbXB0eSwgTm9uZSwgRW1wdHkpXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIChsLCBTb21lIGQsIHIpXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgKGxsLCBwcmVzLCBybCkgPSBzcGxpdCB4IGwgaW4gKGxsLCBwcmVzLCBqb2luIHJsIHYgZCByKVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCAobHIsIHByZXMsIHJyKSA9IHNwbGl0IHggciBpbiAoam9pbiBsIHYgZCBsciwgcHJlcywgcnIpXG5cbiAgICBsZXQgcmVjIG1lcmdlIGYgczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgICAoRW1wdHksIEVtcHR5KSAtPiBFbXB0eVxuICAgICAgfCAoTm9kZSB7bD1sMTsgdj12MTsgZD1kMTsgcj1yMTsgaD1oMX0sIF8pIHdoZW4gaDEgPj0gaGVpZ2h0IHMyIC0+XG4gICAgICAgICAgbGV0IChsMiwgZDIsIHIyKSA9IHNwbGl0IHYxIHMyIGluXG4gICAgICAgICAgY29uY2F0X29yX2pvaW4gKG1lcmdlIGYgbDEgbDIpIHYxIChmIHYxIChTb21lIGQxKSBkMikgKG1lcmdlIGYgcjEgcjIpXG4gICAgICB8IChfLCBOb2RlIHtsPWwyOyB2PXYyOyBkPWQyOyByPXIyfSkgLT5cbiAgICAgICAgICBsZXQgKGwxLCBkMSwgcjEpID0gc3BsaXQgdjIgczEgaW5cbiAgICAgICAgICBjb25jYXRfb3Jfam9pbiAobWVyZ2UgZiBsMSBsMikgdjIgKGYgdjIgZDEgKFNvbWUgZDIpKSAobWVyZ2UgZiByMSByMilcbiAgICAgIHwgXyAtPlxuICAgICAgICAgIGFzc2VydCBmYWxzZVxuXG4gICAgbGV0IHJlYyB1bmlvbiBmIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgIHwgKEVtcHR5LCBzKSB8IChzLCBFbXB0eSkgLT4gc1xuICAgICAgfCAoTm9kZSB7bD1sMTsgdj12MTsgZD1kMTsgcj1yMTsgaD1oMX0sIE5vZGUge2w9bDI7IHY9djI7IGQ9ZDI7IHI9cjI7IGg9aDJ9KSAtPlxuICAgICAgICAgIGlmIGgxID49IGgyIHRoZW5cbiAgICAgICAgICAgIGxldCAobDIsIGQyLCByMikgPSBzcGxpdCB2MSBzMiBpblxuICAgICAgICAgICAgbGV0IGwgPSB1bmlvbiBmIGwxIGwyIGFuZCByID0gdW5pb24gZiByMSByMiBpblxuICAgICAgICAgICAgbWF0Y2ggZDIgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IGpvaW4gbCB2MSBkMSByXG4gICAgICAgICAgICB8IFNvbWUgZDIgLT4gY29uY2F0X29yX2pvaW4gbCB2MSAoZiB2MSBkMSBkMikgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCAobDEsIGQxLCByMSkgPSBzcGxpdCB2MiBzMSBpblxuICAgICAgICAgICAgbGV0IGwgPSB1bmlvbiBmIGwxIGwyIGFuZCByID0gdW5pb24gZiByMSByMiBpblxuICAgICAgICAgICAgbWF0Y2ggZDEgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IGpvaW4gbCB2MiBkMiByXG4gICAgICAgICAgICB8IFNvbWUgZDEgLT4gY29uY2F0X29yX2pvaW4gbCB2MiAoZiB2MiBkMSBkMikgclxuXG4gICAgbGV0IHJlYyBmaWx0ZXIgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IGFzIG0gLT5cbiAgICAgICAgICAoKiBjYWxsIFtwXSBpbiB0aGUgZXhwZWN0ZWQgbGVmdC10by1yaWdodCBvcmRlciAqKVxuICAgICAgICAgIGxldCBsJyA9IGZpbHRlciBwIGwgaW5cbiAgICAgICAgICBsZXQgcHZkID0gcCB2IGQgaW5cbiAgICAgICAgICBsZXQgcicgPSBmaWx0ZXIgcCByIGluXG4gICAgICAgICAgaWYgcHZkIHRoZW4gaWYgbD09bCcgJiYgcj09cicgdGhlbiBtIGVsc2Ugam9pbiBsJyB2IGQgcidcbiAgICAgICAgICBlbHNlIGNvbmNhdCBsJyByJ1xuXG4gICAgbGV0IHJlYyBwYXJ0aXRpb24gcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IChFbXB0eSwgRW1wdHkpXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgKCogY2FsbCBbcF0gaW4gdGhlIGV4cGVjdGVkIGxlZnQtdG8tcmlnaHQgb3JkZXIgKilcbiAgICAgICAgICBsZXQgKGx0LCBsZikgPSBwYXJ0aXRpb24gcCBsIGluXG4gICAgICAgICAgbGV0IHB2ZCA9IHAgdiBkIGluXG4gICAgICAgICAgbGV0IChydCwgcmYpID0gcGFydGl0aW9uIHAgciBpblxuICAgICAgICAgIGlmIHB2ZFxuICAgICAgICAgIHRoZW4gKGpvaW4gbHQgdiBkIHJ0LCBjb25jYXQgbGYgcmYpXG4gICAgICAgICAgZWxzZSAoY29uY2F0IGx0IHJ0LCBqb2luIGxmIHYgZCByZilcblxuICAgIHR5cGUgJ2EgZW51bWVyYXRpb24gPSBFbmQgfCBNb3JlIG9mIGtleSAqICdhICogJ2EgdCAqICdhIGVudW1lcmF0aW9uXG5cbiAgICBsZXQgcmVjIGNvbnNfZW51bSBtIGUgPVxuICAgICAgbWF0Y2ggbSB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGVcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT4gY29uc19lbnVtIGwgKE1vcmUodiwgZCwgciwgZSkpXG5cbiAgICBsZXQgY29tcGFyZSBjbXAgbTEgbTIgPVxuICAgICAgbGV0IHJlYyBjb21wYXJlX2F1eCBlMSBlMiA9XG4gICAgICAgICAgbWF0Y2ggKGUxLCBlMikgd2l0aFxuICAgICAgICAgIChFbmQsIEVuZCkgLT4gMFxuICAgICAgICB8IChFbmQsIF8pICAtPiAtMVxuICAgICAgICB8IChfLCBFbmQpIC0+IDFcbiAgICAgICAgfCAoTW9yZSh2MSwgZDEsIHIxLCBlMSksIE1vcmUodjIsIGQyLCByMiwgZTIpKSAtPlxuICAgICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB2MSB2MiBpblxuICAgICAgICAgICAgaWYgYyA8PiAwIHRoZW4gYyBlbHNlXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCBkMSBkMiBpblxuICAgICAgICAgICAgaWYgYyA8PiAwIHRoZW4gYyBlbHNlXG4gICAgICAgICAgICBjb21wYXJlX2F1eCAoY29uc19lbnVtIHIxIGUxKSAoY29uc19lbnVtIHIyIGUyKVxuICAgICAgaW4gY29tcGFyZV9hdXggKGNvbnNfZW51bSBtMSBFbmQpIChjb25zX2VudW0gbTIgRW5kKVxuXG4gICAgbGV0IGVxdWFsIGNtcCBtMSBtMiA9XG4gICAgICBsZXQgcmVjIGVxdWFsX2F1eCBlMSBlMiA9XG4gICAgICAgICAgbWF0Y2ggKGUxLCBlMikgd2l0aFxuICAgICAgICAgIChFbmQsIEVuZCkgLT4gdHJ1ZVxuICAgICAgICB8IChFbmQsIF8pICAtPiBmYWxzZVxuICAgICAgICB8IChfLCBFbmQpIC0+IGZhbHNlXG4gICAgICAgIHwgKE1vcmUodjEsIGQxLCByMSwgZTEpLCBNb3JlKHYyLCBkMiwgcjIsIGUyKSkgLT5cbiAgICAgICAgICAgIE9yZC5jb21wYXJlIHYxIHYyID0gMCAmJiBjbXAgZDEgZDIgJiZcbiAgICAgICAgICAgIGVxdWFsX2F1eCAoY29uc19lbnVtIHIxIGUxKSAoY29uc19lbnVtIHIyIGUyKVxuICAgICAgaW4gZXF1YWxfYXV4IChjb25zX2VudW0gbTEgRW5kKSAoY29uc19lbnVtIG0yIEVuZClcblxuICAgIGxldCByZWMgY2FyZGluYWwgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAwXG4gICAgICB8IE5vZGUge2w7IHJ9IC0+IGNhcmRpbmFsIGwgKyAxICsgY2FyZGluYWwgclxuXG4gICAgbGV0IHJlYyBiaW5kaW5nc19hdXggYWNjdSA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT4gYmluZGluZ3NfYXV4ICgodiwgZCkgOjogYmluZGluZ3NfYXV4IGFjY3UgcikgbFxuXG4gICAgbGV0IGJpbmRpbmdzIHMgPVxuICAgICAgYmluZGluZ3NfYXV4IFtdIHNcblxuICAgIGxldCBjaG9vc2UgPSBtaW5fYmluZGluZ1xuXG4gICAgbGV0IGNob29zZV9vcHQgPSBtaW5fYmluZGluZ19vcHRcblxuZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgJ2EgdCA9IHsgbXV0YWJsZSBjIDogJ2EgbGlzdDsgbXV0YWJsZSBsZW4gOiBpbnQ7IH1cblxuZXhjZXB0aW9uIEVtcHR5XG5cbmxldCBjcmVhdGUgKCkgPSB7IGMgPSBbXTsgbGVuID0gMDsgfVxuXG5sZXQgY2xlYXIgcyA9IHMuYyA8LSBbXTsgcy5sZW4gPC0gMFxuXG5sZXQgY29weSBzID0geyBjID0gcy5jOyBsZW4gPSBzLmxlbjsgfVxuXG5sZXQgcHVzaCB4IHMgPSBzLmMgPC0geCA6OiBzLmM7IHMubGVuIDwtIHMubGVuICsgMVxuXG5sZXQgcG9wIHMgPVxuICBtYXRjaCBzLmMgd2l0aFxuICB8IGhkOjp0bCAtPiBzLmMgPC0gdGw7IHMubGVuIDwtIHMubGVuIC0gMTsgaGRcbiAgfCBbXSAgICAgLT4gcmFpc2UgRW1wdHlcblxubGV0IHRvcCBzID1cbiAgbWF0Y2ggcy5jIHdpdGhcbiAgfCBoZDo6XyAtPiBoZFxuICB8IFtdICAgICAtPiByYWlzZSBFbXB0eVxuXG5sZXQgaXNfZW1wdHkgcyA9IChzLmMgPSBbXSlcblxubGV0IGxlbmd0aCBzID0gcy5sZW5cblxubGV0IGl0ZXIgZiBzID0gTGlzdC5pdGVyIGYgcy5jXG5cbmxldCBmb2xkIGYgYWNjIHMgPSBMaXN0LmZvbGRfbGVmdCBmIGFjYyBzLmNcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgRnJhbmNvaXMgUG90dGllciwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgSmVyZW1pZSBEaW1pbm8sIEphbmUgU3RyZWV0IEV1cm9wZSAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMDIgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuZXhjZXB0aW9uIEVtcHR5XG5cbnR5cGUgJ2EgY2VsbCA9XG4gIHwgTmlsXG4gIHwgQ29ucyBvZiB7IGNvbnRlbnQ6ICdhOyBtdXRhYmxlIG5leHQ6ICdhIGNlbGwgfVxuXG50eXBlICdhIHQgPSB7XG4gIG11dGFibGUgbGVuZ3RoOiBpbnQ7XG4gIG11dGFibGUgZmlyc3Q6ICdhIGNlbGw7XG4gIG11dGFibGUgbGFzdDogJ2EgY2VsbFxufVxuXG5sZXQgY3JlYXRlICgpID0ge1xuICBsZW5ndGggPSAwO1xuICBmaXJzdCA9IE5pbDtcbiAgbGFzdCA9IE5pbFxufVxuXG5sZXQgY2xlYXIgcSA9XG4gIHEubGVuZ3RoIDwtIDA7XG4gIHEuZmlyc3QgPC0gTmlsO1xuICBxLmxhc3QgPC0gTmlsXG5cbmxldCBhZGQgeCBxID1cbiAgbGV0IGNlbGwgPSBDb25zIHtcbiAgICBjb250ZW50ID0geDtcbiAgICBuZXh0ID0gTmlsXG4gIH0gaW5cbiAgbWF0Y2ggcS5sYXN0IHdpdGhcbiAgfCBOaWwgLT5cbiAgICBxLmxlbmd0aCA8LSAxO1xuICAgIHEuZmlyc3QgPC0gY2VsbDtcbiAgICBxLmxhc3QgPC0gY2VsbFxuICB8IENvbnMgbGFzdCAtPlxuICAgIHEubGVuZ3RoIDwtIHEubGVuZ3RoICsgMTtcbiAgICBsYXN0Lm5leHQgPC0gY2VsbDtcbiAgICBxLmxhc3QgPC0gY2VsbFxuXG5sZXQgcHVzaCA9XG4gIGFkZFxuXG5sZXQgcGVlayBxID1cbiAgbWF0Y2ggcS5maXJzdCB3aXRoXG4gIHwgTmlsIC0+IHJhaXNlIEVtcHR5XG4gIHwgQ29ucyB7IGNvbnRlbnQgfSAtPiBjb250ZW50XG5cbmxldCB0b3AgPVxuICBwZWVrXG5cbmxldCB0YWtlIHEgPVxuICBtYXRjaCBxLmZpcnN0IHdpdGhcbiAgfCBOaWwgLT4gcmFpc2UgRW1wdHlcbiAgfCBDb25zIHsgY29udGVudDsgbmV4dCA9IE5pbCB9IC0+XG4gICAgY2xlYXIgcTtcbiAgICBjb250ZW50XG4gIHwgQ29ucyB7IGNvbnRlbnQ7IG5leHQgfSAtPlxuICAgIHEubGVuZ3RoIDwtIHEubGVuZ3RoIC0gMTtcbiAgICBxLmZpcnN0IDwtIG5leHQ7XG4gICAgY29udGVudFxuXG5sZXQgcG9wID1cbiAgdGFrZVxuXG5sZXQgY29weSA9XG4gIGxldCByZWMgY29weSBxX3JlcyBwcmV2IGNlbGwgPVxuICAgIG1hdGNoIGNlbGwgd2l0aFxuICAgIHwgTmlsIC0+IHFfcmVzLmxhc3QgPC0gcHJldjsgcV9yZXNcbiAgICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICAgIGxldCByZXMgPSBDb25zIHsgY29udGVudDsgbmV4dCA9IE5pbCB9IGluXG4gICAgICBiZWdpbiBtYXRjaCBwcmV2IHdpdGhcbiAgICAgIHwgTmlsIC0+IHFfcmVzLmZpcnN0IDwtIHJlc1xuICAgICAgfCBDb25zIHAgLT4gcC5uZXh0IDwtIHJlc1xuICAgICAgZW5kO1xuICAgICAgY29weSBxX3JlcyByZXMgbmV4dFxuICBpblxuICBmdW4gcSAtPiBjb3B5IHsgbGVuZ3RoID0gcS5sZW5ndGg7IGZpcnN0ID0gTmlsOyBsYXN0ID0gTmlsIH0gTmlsIHEuZmlyc3RcblxubGV0IGlzX2VtcHR5IHEgPVxuICBxLmxlbmd0aCA9IDBcblxubGV0IGxlbmd0aCBxID1cbiAgcS5sZW5ndGhcblxubGV0IGl0ZXIgPVxuICBsZXQgcmVjIGl0ZXIgZiBjZWxsID1cbiAgICBtYXRjaCBjZWxsIHdpdGhcbiAgICB8IE5pbCAtPiAoKVxuICAgIHwgQ29ucyB7IGNvbnRlbnQ7IG5leHQgfSAtPlxuICAgICAgZiBjb250ZW50O1xuICAgICAgaXRlciBmIG5leHRcbiAgaW5cbiAgZnVuIGYgcSAtPiBpdGVyIGYgcS5maXJzdFxuXG5sZXQgZm9sZCA9XG4gIGxldCByZWMgZm9sZCBmIGFjY3UgY2VsbCA9XG4gICAgbWF0Y2ggY2VsbCB3aXRoXG4gICAgfCBOaWwgLT4gYWNjdVxuICAgIHwgQ29ucyB7IGNvbnRlbnQ7IG5leHQgfSAtPlxuICAgICAgbGV0IGFjY3UgPSBmIGFjY3UgY29udGVudCBpblxuICAgICAgZm9sZCBmIGFjY3UgbmV4dFxuICBpblxuICBmdW4gZiBhY2N1IHEgLT4gZm9sZCBmIGFjY3UgcS5maXJzdFxuXG5sZXQgdHJhbnNmZXIgcTEgcTIgPVxuICBpZiBxMS5sZW5ndGggPiAwIHRoZW5cbiAgICBtYXRjaCBxMi5sYXN0IHdpdGhcbiAgICB8IE5pbCAtPlxuICAgICAgcTIubGVuZ3RoIDwtIHExLmxlbmd0aDtcbiAgICAgIHEyLmZpcnN0IDwtIHExLmZpcnN0O1xuICAgICAgcTIubGFzdCA8LSBxMS5sYXN0O1xuICAgICAgY2xlYXIgcTFcbiAgICB8IENvbnMgbGFzdCAtPlxuICAgICAgcTIubGVuZ3RoIDwtIHEyLmxlbmd0aCArIHExLmxlbmd0aDtcbiAgICAgIGxhc3QubmV4dCA8LSBxMS5maXJzdDtcbiAgICAgIHEyLmxhc3QgPC0gcTEubGFzdDtcbiAgICAgIGNsZWFyIHExXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEludGVybmFscyBvZiBmb3JjaW5nIGxhenkgdmFsdWVzLiAqKVxuXG5leGNlcHRpb24gVW5kZWZpbmVkXG5cbmxldCByYWlzZV91bmRlZmluZWQgPSBPYmoucmVwciAoZnVuICgpIC0+IHJhaXNlIFVuZGVmaW5lZClcblxuKCogQXNzdW1lIFtibGtdIGlzIGEgYmxvY2sgd2l0aCB0YWcgbGF6eSAqKVxubGV0IGZvcmNlX2xhenlfYmxvY2sgKGJsayA6ICdhcmcgbGF6eV90KSA9XG4gIGxldCBjbG9zdXJlID0gKE9iai5vYmogKE9iai5maWVsZCAoT2JqLnJlcHIgYmxrKSAwKSA6IHVuaXQgLT4gJ2FyZykgaW5cbiAgT2JqLnNldF9maWVsZCAoT2JqLnJlcHIgYmxrKSAwIHJhaXNlX3VuZGVmaW5lZDtcbiAgdHJ5XG4gICAgbGV0IHJlc3VsdCA9IGNsb3N1cmUgKCkgaW5cbiAgICAoKiBkbyBzZXRfZmllbGQgQkVGT1JFIHNldF90YWcgKilcbiAgICBPYmouc2V0X2ZpZWxkIChPYmoucmVwciBibGspIDAgKE9iai5yZXByIHJlc3VsdCk7XG4gICAgT2JqLnNldF90YWcgKE9iai5yZXByIGJsaykgT2JqLmZvcndhcmRfdGFnO1xuICAgIHJlc3VsdFxuICB3aXRoIGUgLT5cbiAgICBPYmouc2V0X2ZpZWxkIChPYmoucmVwciBibGspIDAgKE9iai5yZXByIChmdW4gKCkgLT4gcmFpc2UgZSkpO1xuICAgIHJhaXNlIGVcblxuXG4oKiBBc3N1bWUgW2Jsa10gaXMgYSBibG9jayB3aXRoIHRhZyBsYXp5ICopXG5sZXQgZm9yY2VfdmFsX2xhenlfYmxvY2sgKGJsayA6ICdhcmcgbGF6eV90KSA9XG4gIGxldCBjbG9zdXJlID0gKE9iai5vYmogKE9iai5maWVsZCAoT2JqLnJlcHIgYmxrKSAwKSA6IHVuaXQgLT4gJ2FyZykgaW5cbiAgT2JqLnNldF9maWVsZCAoT2JqLnJlcHIgYmxrKSAwIHJhaXNlX3VuZGVmaW5lZDtcbiAgbGV0IHJlc3VsdCA9IGNsb3N1cmUgKCkgaW5cbiAgKCogZG8gc2V0X2ZpZWxkIEJFRk9SRSBzZXRfdGFnICopXG4gIE9iai5zZXRfZmllbGQgKE9iai5yZXByIGJsaykgMCAoT2JqLnJlcHIgcmVzdWx0KTtcbiAgT2JqLnNldF90YWcgKE9iai5yZXByIGJsaykgKE9iai5mb3J3YXJkX3RhZyk7XG4gIHJlc3VsdFxuXG5cbigqIFtmb3JjZV0gaXMgbm90IHVzZWQsIHNpbmNlIFtMYXp5LmZvcmNlXSBpcyBkZWNsYXJlZCBhcyBhIHByaW1pdGl2ZVxuICAgd2hvc2UgY29kZSBpbmxpbmVzIHRoZSB0YWcgdGVzdHMgb2YgaXRzIGFyZ3VtZW50LiAgVGhpcyBmdW5jdGlvbiBpc1xuICAgaGVyZSBmb3IgdGhlIHNha2Ugb2YgY29tcGxldGVuZXNzLCBhbmQgZm9yIGRlYnVnZ2luZyBwdXJwb3NlLiAqKVxuXG5sZXQgZm9yY2UgKGx6diA6ICdhcmcgbGF6eV90KSA9XG4gIGxldCB4ID0gT2JqLnJlcHIgbHp2IGluXG4gIGxldCB0ID0gT2JqLnRhZyB4IGluXG4gIGlmIHQgPSBPYmouZm9yd2FyZF90YWcgdGhlbiAoT2JqLm9iaiAoT2JqLmZpZWxkIHggMCkgOiAnYXJnKSBlbHNlXG4gIGlmIHQgPD4gT2JqLmxhenlfdGFnIHRoZW4gKE9iai5vYmogeCA6ICdhcmcpXG4gIGVsc2UgZm9yY2VfbGF6eV9ibG9jayBsenZcblxuXG5sZXQgZm9yY2VfdmFsIChsenYgOiAnYXJnIGxhenlfdCkgPVxuICBsZXQgeCA9IE9iai5yZXByIGx6diBpblxuICBsZXQgdCA9IE9iai50YWcgeCBpblxuICBpZiB0ID0gT2JqLmZvcndhcmRfdGFnIHRoZW4gKE9iai5vYmogKE9iai5maWVsZCB4IDApIDogJ2FyZykgZWxzZVxuICBpZiB0IDw+IE9iai5sYXp5X3RhZyB0aGVuIChPYmoub2JqIHggOiAnYXJnKVxuICBlbHNlIGZvcmNlX3ZhbF9sYXp5X2Jsb2NrIGx6dlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW0xhenldOiBkZWZlcnJlZCBjb21wdXRhdGlvbnMgKilcblxuXG4oKlxuICAgV0FSTklORzogc29tZSBwdXJwbGUgbWFnaWMgaXMgZ29pbmcgb24gaGVyZS4gIERvIG5vdCB0YWtlIHRoaXMgZmlsZVxuICAgYXMgYW4gZXhhbXBsZSBvZiBob3cgdG8gcHJvZ3JhbSBpbiBPQ2FtbC5cbiopXG5cblxuKCogV2UgbWFrZSB1c2Ugb2YgdHdvIHNwZWNpYWwgdGFncyBwcm92aWRlZCBieSB0aGUgcnVudGltZTpcbiAgIFtsYXp5X3RhZ10gYW5kIFtmb3J3YXJkX3RhZ10uXG5cbiAgIEEgdmFsdWUgb2YgdHlwZSBbJ2EgTGF6eS50XSBjYW4gYmUgb25lIG9mIHRocmVlIHRoaW5nczpcbiAgIDEuIEEgYmxvY2sgb2Ygc2l6ZSAxIHdpdGggdGFnIFtsYXp5X3RhZ10uICBJdHMgZmllbGQgaXMgYSBjbG9zdXJlIG9mXG4gICAgICB0eXBlIFt1bml0IC0+ICdhXSB0aGF0IGNvbXB1dGVzIHRoZSB2YWx1ZS5cbiAgIDIuIEEgYmxvY2sgb2Ygc2l6ZSAxIHdpdGggdGFnIFtmb3J3YXJkX3RhZ10uICBJdHMgZmllbGQgaXMgdGhlIHZhbHVlXG4gICAgICBvZiB0eXBlIFsnYV0gdGhhdCB3YXMgY29tcHV0ZWQuXG4gICAzLiBBbnl0aGluZyBlbHNlIGV4Y2VwdCBhIGZsb2F0LiAgVGhpcyBoYXMgdHlwZSBbJ2FdIGFuZCBpcyB0aGUgdmFsdWVcbiAgICAgIHRoYXQgd2FzIGNvbXB1dGVkLlxuICAgRXhjZXB0aW9ucyBhcmUgc3RvcmVkIGluIGZvcm1hdCAoMSkuXG4gICBUaGUgR0Mgd2lsbCBtYWdpY2FsbHkgY2hhbmdlIHRoaW5ncyBmcm9tICgyKSB0byAoMykgYWNjb3JkaW5nIHRvIGl0c1xuICAgZmFuY3kuXG5cbiAgIElmIE9DYW1sIHdhcyBjb25maWd1cmVkIHdpdGggdGhlIC1mbGF0LWZsb2F0LWFycmF5IG9wdGlvbiAod2hpY2ggaXNcbiAgIGN1cnJlbnRseSB0aGUgZGVmYXVsdCksIHRoZSBmb2xsb3dpbmcgaXMgYWxzbyB0cnVlOlxuICAgV2UgY2Fubm90IHVzZSByZXByZXNlbnRhdGlvbiAoMykgZm9yIGEgW2Zsb2F0IExhenkudF0gYmVjYXVzZVxuICAgW2NhbWxfbWFrZV9hcnJheV0gYXNzdW1lcyB0aGF0IG9ubHkgYSBbZmxvYXRdIHZhbHVlIGNhbiBoYXZlIHRhZ1xuICAgW0RvdWJsZV90YWddLlxuXG4gICBXZSBoYXZlIHRvIHVzZSB0aGUgYnVpbHQtaW4gdHlwZSBjb25zdHJ1Y3RvciBbbGF6eV90XSB0b1xuICAgbGV0IHRoZSBjb21waWxlciBpbXBsZW1lbnQgdGhlIHNwZWNpYWwgdHlwaW5nIGFuZCBjb21waWxhdGlvblxuICAgcnVsZXMgZm9yIHRoZSBbbGF6eV0ga2V5d29yZC5cbiopXG5cbnR5cGUgJ2EgdCA9ICdhIGxhenlfdFxuXG5leGNlcHRpb24gVW5kZWZpbmVkID0gQ2FtbGludGVybmFsTGF6eS5VbmRlZmluZWRcblxuZXh0ZXJuYWwgbWFrZV9mb3J3YXJkIDogJ2EgLT4gJ2EgbGF6eV90ID0gXCJjYW1sX2xhenlfbWFrZV9mb3J3YXJkXCJcblxuZXh0ZXJuYWwgZm9yY2UgOiAnYSB0IC0+ICdhID0gXCIlbGF6eV9mb3JjZVwiXG5cbigqIGxldCBmb3JjZSA9IGZvcmNlICopXG5cbmxldCBmb3JjZV92YWwgPSBDYW1saW50ZXJuYWxMYXp5LmZvcmNlX3ZhbFxuXG5sZXQgZnJvbV9mdW4gKGYgOiB1bml0IC0+ICdhcmcpID1cbiAgbGV0IHggPSBPYmoubmV3X2Jsb2NrIE9iai5sYXp5X3RhZyAxIGluXG4gIE9iai5zZXRfZmllbGQgeCAwIChPYmoucmVwciBmKTtcbiAgKE9iai5vYmogeCA6ICdhcmcgdClcblxuXG5sZXQgZnJvbV92YWwgKHYgOiAnYXJnKSA9XG4gIGxldCB0ID0gT2JqLnRhZyAoT2JqLnJlcHIgdikgaW5cbiAgaWYgdCA9IE9iai5mb3J3YXJkX3RhZyB8fCB0ID0gT2JqLmxhenlfdGFnIHx8IHQgPSBPYmouZG91YmxlX3RhZyB0aGVuIGJlZ2luXG4gICAgbWFrZV9mb3J3YXJkIHZcbiAgZW5kIGVsc2UgYmVnaW5cbiAgICAoT2JqLm1hZ2ljIHYgOiAnYXJnIHQpXG4gIGVuZFxuXG5cbmxldCBpc192YWwgKGwgOiAnYXJnIHQpID0gT2JqLnRhZyAoT2JqLnJlcHIgbCkgPD4gT2JqLmxhenlfdGFnXG5cbmxldCBsYXp5X2Zyb21fZnVuID0gZnJvbV9mdW5cblxubGV0IGxhenlfZnJvbV92YWwgPSBmcm9tX3ZhbFxuXG5sZXQgbGF6eV9pc192YWwgPSBpc192YWxcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgRGFuaWVsIGRlIFJhdWdsYXVkcmUsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSAnYSB0ID0gJ2EgY2VsbCBvcHRpb25cbmFuZCAnYSBjZWxsID0geyBtdXRhYmxlIGNvdW50IDogaW50OyBtdXRhYmxlIGRhdGEgOiAnYSBkYXRhIH1cbmFuZCAnYSBkYXRhID1cbiAgICBTZW1wdHlcbiAgfCBTY29ucyBvZiAnYSAqICdhIGRhdGFcbiAgfCBTYXBwIG9mICdhIGRhdGEgKiAnYSBkYXRhXG4gIHwgU2xhenkgb2YgJ2EgZGF0YSBMYXp5LnRcbiAgfCBTZ2VuIG9mICdhIGdlblxuICB8IFNidWZmaW8gOiBidWZmaW8gLT4gY2hhciBkYXRhXG5hbmQgJ2EgZ2VuID0geyBtdXRhYmxlIGN1cnIgOiAnYSBvcHRpb24gb3B0aW9uOyBmdW5jIDogaW50IC0+ICdhIG9wdGlvbiB9XG5hbmQgYnVmZmlvID1cbiAgeyBpYyA6IGluX2NoYW5uZWw7IGJ1ZmYgOiBieXRlczsgbXV0YWJsZSBsZW4gOiBpbnQ7IG11dGFibGUgaW5kIDogaW50IH1cblxuZXhjZXB0aW9uIEZhaWx1cmVcbmV4Y2VwdGlvbiBFcnJvciBvZiBzdHJpbmdcblxubGV0IGNvdW50ID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+IDBcbiAgfCBTb21lIHsgY291bnQgfSAtPiBjb3VudFxubGV0IGRhdGEgPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gU2VtcHR5XG4gIHwgU29tZSB7IGRhdGEgfSAtPiBkYXRhXG5cbmxldCBmaWxsX2J1ZmYgYiA9XG4gIGIubGVuIDwtIGlucHV0IGIuaWMgYi5idWZmIDAgKEJ5dGVzLmxlbmd0aCBiLmJ1ZmYpOyBiLmluZCA8LSAwXG5cblxubGV0IHJlYyBnZXRfZGF0YSA6IHR5cGUgdi4gaW50IC0+IHYgZGF0YSAtPiB2IGRhdGEgPSBmdW4gY291bnQgZCAtPiBtYXRjaCBkIHdpdGhcbiAoKiBSZXR1cm5zIGVpdGhlciBTZW1wdHkgb3IgU2NvbnMoYSwgXykgZXZlbiB3aGVuIGQgaXMgYSBnZW5lcmF0b3JcbiAgICBvciBhIGJ1ZmZlci4gSW4gdGhvc2UgY2FzZXMsIHRoZSBpdGVtIGEgaXMgc2VlbiBhcyBleHRyYWN0ZWQgZnJvbVxuIHRoZSBnZW5lcmF0b3IvYnVmZmVyLlxuIFRoZSBjb3VudCBwYXJhbWV0ZXIgaXMgdXNlZCBmb3IgY2FsbGluZyBgU2dlbi1mdW5jdGlvbnMnLiAgKilcbiAgIFNlbXB0eSB8IFNjb25zIChfLCBfKSAtPiBkXG4gfCBTYXBwIChkMSwgZDIpIC0+XG4gICAgIGJlZ2luIG1hdGNoIGdldF9kYXRhIGNvdW50IGQxIHdpdGhcbiAgICAgICBTY29ucyAoYSwgZDExKSAtPiBTY29ucyAoYSwgU2FwcCAoZDExLCBkMikpXG4gICAgIHwgU2VtcHR5IC0+IGdldF9kYXRhIGNvdW50IGQyXG4gICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICAgZW5kXG4gfCBTZ2VuIHtjdXJyID0gU29tZSBOb25lfSAtPiBTZW1wdHlcbiB8IFNnZW4gKHtjdXJyID0gU29tZShTb21lIGEpfSBhcyBnKSAtPlxuICAgICBnLmN1cnIgPC0gTm9uZTsgU2NvbnMoYSwgZClcbiB8IFNnZW4gZyAtPlxuICAgICBiZWdpbiBtYXRjaCBnLmZ1bmMgY291bnQgd2l0aFxuICAgICAgIE5vbmUgLT4gZy5jdXJyIDwtIFNvbWUoTm9uZSk7IFNlbXB0eVxuICAgICB8IFNvbWUgYSAtPiBTY29ucyhhLCBkKVxuICAgICAgICAgKCogV2FybmluZzogYW55b25lIHVzaW5nIGcgdGhpbmtzIHRoYXQgYW4gaXRlbSBoYXMgYmVlbiByZWFkICopXG4gICAgIGVuZFxuIHwgU2J1ZmZpbyBiIC0+XG4gICAgIGlmIGIuaW5kID49IGIubGVuIHRoZW4gZmlsbF9idWZmIGI7XG4gICAgIGlmIGIubGVuID09IDAgdGhlbiBTZW1wdHkgZWxzZVxuICAgICAgIGxldCByID0gQnl0ZXMudW5zYWZlX2dldCBiLmJ1ZmYgYi5pbmQgaW5cbiAgICAgICAoKiBXYXJuaW5nOiBhbnlvbmUgdXNpbmcgZyB0aGlua3MgdGhhdCBhbiBpdGVtIGhhcyBiZWVuIHJlYWQgKilcbiAgICAgICBiLmluZCA8LSBzdWNjIGIuaW5kOyBTY29ucyhyLCBkKVxuIHwgU2xhenkgZiAtPiBnZXRfZGF0YSBjb3VudCAoTGF6eS5mb3JjZSBmKVxuXG5cbmxldCByZWMgcGVla19kYXRhIDogdHlwZSB2LiB2IGNlbGwgLT4gdiBvcHRpb24gPSBmdW4gcyAtPlxuICgqIGNvbnN1bHQgdGhlIGZpcnN0IGl0ZW0gb2YgcyAqKVxuIG1hdGNoIHMuZGF0YSB3aXRoXG4gICBTZW1wdHkgLT4gTm9uZVxuIHwgU2NvbnMgKGEsIF8pIC0+IFNvbWUgYVxuIHwgU2FwcCAoXywgXykgLT5cbiAgICAgYmVnaW4gbWF0Y2ggZ2V0X2RhdGEgcy5jb3VudCBzLmRhdGEgd2l0aFxuICAgICAgIFNjb25zKGEsIF8pIGFzIGQgLT4gcy5kYXRhIDwtIGQ7IFNvbWUgYVxuICAgICB8IFNlbXB0eSAtPiBOb25lXG4gICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICAgZW5kXG4gfCBTbGF6eSBmIC0+IHMuZGF0YSA8LSAoTGF6eS5mb3JjZSBmKTsgcGVla19kYXRhIHNcbiB8IFNnZW4ge2N1cnIgPSBTb21lIGF9IC0+IGFcbiB8IFNnZW4gZyAtPiBsZXQgeCA9IGcuZnVuYyBzLmNvdW50IGluIGcuY3VyciA8LSBTb21lIHg7IHhcbiB8IFNidWZmaW8gYiAtPlxuICAgICBpZiBiLmluZCA+PSBiLmxlbiB0aGVuIGZpbGxfYnVmZiBiO1xuICAgICBpZiBiLmxlbiA9PSAwIHRoZW4gYmVnaW4gcy5kYXRhIDwtIFNlbXB0eTsgTm9uZSBlbmRcbiAgICAgZWxzZSBTb21lIChCeXRlcy51bnNhZmVfZ2V0IGIuYnVmZiBiLmluZClcblxuXG5sZXQgcGVlayA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSBzIC0+IHBlZWtfZGF0YSBzXG5cblxubGV0IHJlYyBqdW5rX2RhdGEgOiB0eXBlIHYuIHYgY2VsbCAtPiB1bml0ID0gZnVuIHMgLT5cbiAgbWF0Y2ggcy5kYXRhIHdpdGhcbiAgICBTY29ucyAoXywgZCkgLT4gcy5jb3VudCA8LSAoc3VjYyBzLmNvdW50KTsgcy5kYXRhIDwtIGRcbiAgfCBTZ2VuICh7Y3VyciA9IFNvbWUgX30gYXMgZykgLT4gcy5jb3VudCA8LSAoc3VjYyBzLmNvdW50KTsgZy5jdXJyIDwtIE5vbmVcbiAgfCBTYnVmZmlvIGIgLT4gcy5jb3VudCA8LSAoc3VjYyBzLmNvdW50KTsgYi5pbmQgPC0gc3VjYyBiLmluZFxuICB8IF8gLT5cbiAgICAgIG1hdGNoIHBlZWtfZGF0YSBzIHdpdGhcbiAgICAgICAgTm9uZSAtPiAoKVxuICAgICAgfCBTb21lIF8gLT4ganVua19kYXRhIHNcblxuXG5sZXQganVuayA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiAoKVxuICB8IFNvbWUgZGF0YSAtPiBqdW5rX2RhdGEgZGF0YVxuXG5sZXQgcmVjIG5nZXRfZGF0YSBuIHMgPVxuICBpZiBuIDw9IDAgdGhlbiBbXSwgcy5kYXRhLCAwXG4gIGVsc2VcbiAgICBtYXRjaCBwZWVrX2RhdGEgcyB3aXRoXG4gICAgICBTb21lIGEgLT5cbiAgICAgICAganVua19kYXRhIHM7XG4gICAgICAgIGxldCAoYWwsIGQsIGspID0gbmdldF9kYXRhIChwcmVkIG4pIHMgaW4gYSA6OiBhbCwgU2NvbnMgKGEsIGQpLCBzdWNjIGtcbiAgICB8IE5vbmUgLT4gW10sIHMuZGF0YSwgMFxuXG5cbmxldCBucGVla19kYXRhIG4gcyA9XG4gIGxldCAoYWwsIGQsIGxlbikgPSBuZ2V0X2RhdGEgbiBzIGluXG4gIHMuY291bnQgPC0gKHMuY291bnQgLSBsZW4pO1xuICBzLmRhdGEgPC0gZDtcbiAgYWxcblxuXG5sZXQgbnBlZWsgbiA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiBbXVxuICB8IFNvbWUgZCAtPiBucGVla19kYXRhIG4gZFxuXG5sZXQgbmV4dCBzID1cbiAgbWF0Y2ggcGVlayBzIHdpdGhcbiAgICBTb21lIGEgLT4ganVuayBzOyBhXG4gIHwgTm9uZSAtPiByYWlzZSBGYWlsdXJlXG5cblxubGV0IGVtcHR5IHMgPVxuICBtYXRjaCBwZWVrIHMgd2l0aFxuICAgIFNvbWUgXyAtPiByYWlzZSBGYWlsdXJlXG4gIHwgTm9uZSAtPiAoKVxuXG5cbmxldCBpdGVyIGYgc3RybSA9XG4gIGxldCByZWMgZG9fcmVjICgpID1cbiAgICBtYXRjaCBwZWVrIHN0cm0gd2l0aFxuICAgICAgU29tZSBhIC0+IGp1bmsgc3RybTsgaWdub3JlKGYgYSk7IGRvX3JlYyAoKVxuICAgIHwgTm9uZSAtPiAoKVxuICBpblxuICBkb19yZWMgKClcblxuXG4oKiBTdHJlYW0gYnVpbGRpbmcgZnVuY3Rpb25zICopXG5cbmxldCBmcm9tIGYgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTZ2VuIHtjdXJyID0gTm9uZTsgZnVuYyA9IGZ9fVxuXG5sZXQgb2ZfbGlzdCBsID1cbiAgU29tZSB7Y291bnQgPSAwOyBkYXRhID0gTGlzdC5mb2xkX3JpZ2h0IChmdW4geCBsIC0+IFNjb25zICh4LCBsKSkgbCBTZW1wdHl9XG5cblxubGV0IG9mX3N0cmluZyBzID1cbiAgbGV0IGNvdW50ID0gcmVmIDAgaW5cbiAgZnJvbSAoZnVuIF8gLT5cbiAgICAoKiBXZSBjYW5ub3QgdXNlIHRoZSBpbmRleCBwYXNzZWQgYnkgdGhlIFtmcm9tXSBmdW5jdGlvbiBkaXJlY3RseVxuICAgICAgIGJlY2F1c2UgaXQgcmV0dXJucyB0aGUgY3VycmVudCBzdHJlYW0gY291bnQsIHdpdGggYWJzb2x1dGVseSBub1xuICAgICAgIGd1YXJhbnRlZSB0aGF0IGl0IHdpbGwgc3RhcnQgZnJvbSAwLiBGb3IgZXhhbXBsZSwgaW4gdGhlIGNhc2VcbiAgICAgICBvZiBbU3RyZWFtLmljb25zICdjJyAoU3RyZWFtLmZyb21fc3RyaW5nIFwiYWJcIildLCB0aGUgZmlyc3RcbiAgICAgICBhY2Nlc3MgdG8gdGhlIHN0cmluZyB3aWxsIGJlIG1hZGUgd2l0aCBjb3VudCBbMV0gYWxyZWFkeS5cbiAgICAqKVxuICAgIGxldCBjID0gIWNvdW50IGluXG4gICAgaWYgYyA8IFN0cmluZy5sZW5ndGggc1xuICAgIHRoZW4gKGluY3IgY291bnQ7IFNvbWUgcy5bY10pXG4gICAgZWxzZSBOb25lKVxuXG5cbmxldCBvZl9ieXRlcyBzID1cbiAgbGV0IGNvdW50ID0gcmVmIDAgaW5cbiAgZnJvbSAoZnVuIF8gLT5cbiAgICBsZXQgYyA9ICFjb3VudCBpblxuICAgIGlmIGMgPCBCeXRlcy5sZW5ndGggc1xuICAgIHRoZW4gKGluY3IgY291bnQ7IFNvbWUgKEJ5dGVzLmdldCBzIGMpKVxuICAgIGVsc2UgTm9uZSlcblxuXG5sZXQgb2ZfY2hhbm5lbCBpYyA9XG4gIFNvbWUge2NvdW50ID0gMDtcbiAgICAgICAgZGF0YSA9IFNidWZmaW8ge2ljID0gaWM7IGJ1ZmYgPSBCeXRlcy5jcmVhdGUgNDA5NjsgbGVuID0gMDsgaW5kID0gMH19XG5cblxuKCogU3RyZWFtIGV4cHJlc3Npb25zIGJ1aWxkZXJzICopXG5cbmxldCBpYXBwIGkgcyA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNhcHAgKGRhdGEgaSwgZGF0YSBzKX1cbmxldCBpY29ucyBpIHMgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTY29ucyAoaSwgZGF0YSBzKX1cbmxldCBpc2luZyBpID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2NvbnMgKGksIFNlbXB0eSl9XG5cbmxldCBsYXBwIGYgcyA9XG4gIFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNsYXp5IChsYXp5KFNhcHAgKGRhdGEgKGYgKCkpLCBkYXRhIHMpKSl9XG5cbmxldCBsY29ucyBmIHMgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTbGF6eSAobGF6eShTY29ucyAoZiAoKSwgZGF0YSBzKSkpfVxubGV0IGxzaW5nIGYgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTbGF6eSAobGF6eShTY29ucyAoZiAoKSwgU2VtcHR5KSkpfVxuXG5sZXQgc2VtcHR5ID0gTm9uZVxubGV0IHNsYXp5IGYgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTbGF6eSAobGF6eShkYXRhIChmICgpKSkpfVxuXG4oKiBGb3IgZGVidWdnaW5nIHVzZSAqKVxuXG5sZXQgcmVjIGR1bXAgOiB0eXBlIHYuICh2IC0+IHVuaXQpIC0+IHYgdCAtPiB1bml0ID0gZnVuIGYgcyAtPlxuICBwcmludF9zdHJpbmcgXCJ7Y291bnQgPSBcIjtcbiAgcHJpbnRfaW50IChjb3VudCBzKTtcbiAgcHJpbnRfc3RyaW5nIFwiOyBkYXRhID0gXCI7XG4gIGR1bXBfZGF0YSBmIChkYXRhIHMpO1xuICBwcmludF9zdHJpbmcgXCJ9XCI7XG4gIHByaW50X25ld2xpbmUgKClcbmFuZCBkdW1wX2RhdGEgOiB0eXBlIHYuICh2IC0+IHVuaXQpIC0+IHYgZGF0YSAtPiB1bml0ID0gZnVuIGYgLT5cbiAgZnVuY3Rpb25cbiAgICBTZW1wdHkgLT4gcHJpbnRfc3RyaW5nIFwiU2VtcHR5XCJcbiAgfCBTY29ucyAoYSwgZCkgLT5cbiAgICAgIHByaW50X3N0cmluZyBcIlNjb25zIChcIjtcbiAgICAgIGYgYTtcbiAgICAgIHByaW50X3N0cmluZyBcIiwgXCI7XG4gICAgICBkdW1wX2RhdGEgZiBkO1xuICAgICAgcHJpbnRfc3RyaW5nIFwiKVwiXG4gIHwgU2FwcCAoZDEsIGQyKSAtPlxuICAgICAgcHJpbnRfc3RyaW5nIFwiU2FwcCAoXCI7XG4gICAgICBkdW1wX2RhdGEgZiBkMTtcbiAgICAgIHByaW50X3N0cmluZyBcIiwgXCI7XG4gICAgICBkdW1wX2RhdGEgZiBkMjtcbiAgICAgIHByaW50X3N0cmluZyBcIilcIlxuICB8IFNsYXp5IF8gLT4gcHJpbnRfc3RyaW5nIFwiU2xhenlcIlxuICB8IFNnZW4gXyAtPiBwcmludF9zdHJpbmcgXCJTZ2VuXCJcbiAgfCBTYnVmZmlvIF8gLT4gcHJpbnRfc3RyaW5nIFwiU2J1ZmZpb1wiXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICBQaWVycmUgV2VpcyBhbmQgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk5IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEV4dGVuc2libGUgYnVmZmVycyAqKVxuXG50eXBlIHQgPVxuIHttdXRhYmxlIGJ1ZmZlciA6IGJ5dGVzO1xuICBtdXRhYmxlIHBvc2l0aW9uIDogaW50O1xuICBtdXRhYmxlIGxlbmd0aCA6IGludDtcbiAgaW5pdGlhbF9idWZmZXIgOiBieXRlc31cblxubGV0IGNyZWF0ZSBuID1cbiBsZXQgbiA9IGlmIG4gPCAxIHRoZW4gMSBlbHNlIG4gaW5cbiBsZXQgbiA9IGlmIG4gPiBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlbiBTeXMubWF4X3N0cmluZ19sZW5ndGggZWxzZSBuIGluXG4gbGV0IHMgPSBCeXRlcy5jcmVhdGUgbiBpblxuIHtidWZmZXIgPSBzOyBwb3NpdGlvbiA9IDA7IGxlbmd0aCA9IG47IGluaXRpYWxfYnVmZmVyID0gc31cblxubGV0IGNvbnRlbnRzIGIgPSBCeXRlcy5zdWJfc3RyaW5nIGIuYnVmZmVyIDAgYi5wb3NpdGlvblxubGV0IHRvX2J5dGVzIGIgPSBCeXRlcy5zdWIgYi5idWZmZXIgMCBiLnBvc2l0aW9uXG5cbmxldCBzdWIgYiBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGIucG9zaXRpb24gLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkJ1ZmZlci5zdWJcIlxuICBlbHNlIEJ5dGVzLnN1Yl9zdHJpbmcgYi5idWZmZXIgb2ZzIGxlblxuXG5cbmxldCBibGl0IHNyYyBzcmNvZmYgZHN0IGRzdG9mZiBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IHNyY29mZiA8IDAgfHwgc3Jjb2ZmID4gc3JjLnBvc2l0aW9uIC0gbGVuXG4gICAgICAgICAgICAgfHwgZHN0b2ZmIDwgMCB8fCBkc3RvZmYgPiAoQnl0ZXMubGVuZ3RoIGRzdCkgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkJ1ZmZlci5ibGl0XCJcbiAgZWxzZVxuICAgIEJ5dGVzLnVuc2FmZV9ibGl0IHNyYy5idWZmZXIgc3Jjb2ZmIGRzdCBkc3RvZmYgbGVuXG5cblxubGV0IG50aCBiIG9mcyA9XG4gIGlmIG9mcyA8IDAgfHwgb2ZzID49IGIucG9zaXRpb24gdGhlblxuICAgaW52YWxpZF9hcmcgXCJCdWZmZXIubnRoXCJcbiAgZWxzZSBCeXRlcy51bnNhZmVfZ2V0IGIuYnVmZmVyIG9mc1xuXG5cbmxldCBsZW5ndGggYiA9IGIucG9zaXRpb25cblxubGV0IGNsZWFyIGIgPSBiLnBvc2l0aW9uIDwtIDBcblxubGV0IHJlc2V0IGIgPVxuICBiLnBvc2l0aW9uIDwtIDA7IGIuYnVmZmVyIDwtIGIuaW5pdGlhbF9idWZmZXI7XG4gIGIubGVuZ3RoIDwtIEJ5dGVzLmxlbmd0aCBiLmJ1ZmZlclxuXG5sZXQgcmVzaXplIGIgbW9yZSA9XG4gIGxldCBsZW4gPSBiLmxlbmd0aCBpblxuICBsZXQgbmV3X2xlbiA9IHJlZiBsZW4gaW5cbiAgd2hpbGUgYi5wb3NpdGlvbiArIG1vcmUgPiAhbmV3X2xlbiBkbyBuZXdfbGVuIDo9IDIgKiAhbmV3X2xlbiBkb25lO1xuICBpZiAhbmV3X2xlbiA+IFN5cy5tYXhfc3RyaW5nX2xlbmd0aCB0aGVuIGJlZ2luXG4gICAgaWYgYi5wb3NpdGlvbiArIG1vcmUgPD0gU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG4gICAgdGhlbiBuZXdfbGVuIDo9IFN5cy5tYXhfc3RyaW5nX2xlbmd0aFxuICAgIGVsc2UgZmFpbHdpdGggXCJCdWZmZXIuYWRkOiBjYW5ub3QgZ3JvdyBidWZmZXJcIlxuICBlbmQ7XG4gIGxldCBuZXdfYnVmZmVyID0gQnl0ZXMuY3JlYXRlICFuZXdfbGVuIGluXG4gICgqIFBSIzYxNDg6IGxldCdzIGtlZXAgdXNpbmcgW2JsaXRdIHJhdGhlciB0aGFuIFt1bnNhZmVfYmxpdF0gaW5cbiAgICAgdGhpcyB0cmlja3kgZnVuY3Rpb24gdGhhdCBpcyBzbG93IGFueXdheS4gKilcbiAgQnl0ZXMuYmxpdCBiLmJ1ZmZlciAwIG5ld19idWZmZXIgMCBiLnBvc2l0aW9uO1xuICBiLmJ1ZmZlciA8LSBuZXdfYnVmZmVyO1xuICBiLmxlbmd0aCA8LSAhbmV3X2xlblxuXG5sZXQgYWRkX2NoYXIgYiBjID1cbiAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgaWYgcG9zID49IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgMTtcbiAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciBwb3MgYztcbiAgYi5wb3NpdGlvbiA8LSBwb3MgKyAxXG5cbiBsZXQgYWRkX3V0Zl84X3VjaGFyIGIgdSA9IG1hdGNoIFVjaGFyLnRvX2ludCB1IHdpdGhcbiB8IHUgd2hlbiB1IDwgMCAtPiBhc3NlcnQgZmFsc2VcbiB8IHUgd2hlbiB1IDw9IDB4MDA3RiAtPlxuICAgICBhZGRfY2hhciBiIChDaGFyLnVuc2FmZV9jaHIgdSlcbiB8IHUgd2hlbiB1IDw9IDB4MDdGRiAtPlxuICAgICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICAgICBpZiBwb3MgKyAyID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiAyO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgICAgKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4QzAgbG9yICh1IGxzciA2KSkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAxKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4ODAgbG9yICh1IGxhbmQgMHgzRikpKTtcbiAgICAgYi5wb3NpdGlvbiA8LSBwb3MgKyAyXG4gfCB1IHdoZW4gdSA8PSAweEZGRkYgLT5cbiAgICAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgICAgaWYgcG9zICsgMyA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgMztcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICAgIClcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweEUwIGxvciAodSBsc3IgMTIpKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDEpXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHg4MCBsb3IgKCh1IGxzciA2KSBsYW5kIDB4M0YpKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDIpXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHg4MCBsb3IgKHUgbGFuZCAweDNGKSkpO1xuICAgICBiLnBvc2l0aW9uIDwtIHBvcyArIDNcbiB8IHUgd2hlbiB1IDw9IDB4MTBGRkZGIC0+XG4gICAgIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gICAgIGlmIHBvcyArIDQgPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDQ7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyAgICApXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHhGMCBsb3IgKHUgbHNyIDE4KSkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAxKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4ODAgbG9yICgodSBsc3IgMTIpIGxhbmQgMHgzRikpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMilcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweDgwIGxvciAoKHUgbHNyIDYpIGxhbmQgMHgzRikpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMylcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweDgwIGxvciAodSBsYW5kIDB4M0YpKSk7XG4gICAgIGIucG9zaXRpb24gPC0gcG9zICsgNFxuIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuIGxldCBhZGRfdXRmXzE2YmVfdWNoYXIgYiB1ID0gbWF0Y2ggVWNoYXIudG9faW50IHUgd2l0aFxuIHwgdSB3aGVuIHUgPCAwIC0+IGFzc2VydCBmYWxzZVxuIHwgdSB3aGVuIHUgPD0gMHhGRkZGIC0+XG4gICAgIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gICAgIGlmIHBvcyArIDIgPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDI7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyAgICApIChDaGFyLnVuc2FmZV9jaHIgKHUgbHNyIDgpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMSkgKENoYXIudW5zYWZlX2NociAodSBsYW5kIDB4RkYpKTtcbiAgICAgYi5wb3NpdGlvbiA8LSBwb3MgKyAyXG4gfCB1IHdoZW4gdSA8PSAweDEwRkZGRiAtPlxuICAgICBsZXQgdScgPSB1IC0gMHgxMDAwMCBpblxuICAgICBsZXQgaGkgPSAweEQ4MDAgbG9yICh1JyBsc3IgMTApIGluXG4gICAgIGxldCBsbyA9IDB4REMwMCBsb3IgKHUnIGxhbmQgMHgzRkYpIGluXG4gICAgIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gICAgIGlmIHBvcyArIDQgPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDQ7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyAgICApIChDaGFyLnVuc2FmZV9jaHIgKGhpIGxzciA4KSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDEpIChDaGFyLnVuc2FmZV9jaHIgKGhpIGxhbmQgMHhGRikpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAyKSAoQ2hhci51bnNhZmVfY2hyIChsbyBsc3IgOCkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAzKSAoQ2hhci51bnNhZmVfY2hyIChsbyBsYW5kIDB4RkYpKTtcbiAgICAgYi5wb3NpdGlvbiA8LSBwb3MgKyA0XG4gfCBfIC0+IGFzc2VydCBmYWxzZVxuXG4gbGV0IGFkZF91dGZfMTZsZV91Y2hhciBiIHUgPSBtYXRjaCBVY2hhci50b19pbnQgdSB3aXRoXG4gfCB1IHdoZW4gdSA8IDAgLT4gYXNzZXJ0IGZhbHNlXG4gfCB1IHdoZW4gdSA8PSAweEZGRkYgLT5cbiAgICAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgICAgaWYgcG9zICsgMiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgMjtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICAgICkgKENoYXIudW5zYWZlX2NociAodSBsYW5kIDB4RkYpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMSkgKENoYXIudW5zYWZlX2NociAodSBsc3IgOCkpO1xuICAgICBiLnBvc2l0aW9uIDwtIHBvcyArIDJcbiB8IHUgd2hlbiB1IDw9IDB4MTBGRkZGIC0+XG4gICAgIGxldCB1JyA9IHUgLSAweDEwMDAwIGluXG4gICAgIGxldCBoaSA9IDB4RDgwMCBsb3IgKHUnIGxzciAxMCkgaW5cbiAgICAgbGV0IGxvID0gMHhEQzAwIGxvciAodScgbGFuZCAweDNGRikgaW5cbiAgICAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgICAgaWYgcG9zICsgNCA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgNDtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICAgICkgKENoYXIudW5zYWZlX2NociAoaGkgbGFuZCAweEZGKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDEpIChDaGFyLnVuc2FmZV9jaHIgKGhpIGxzciA4KSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDIpIChDaGFyLnVuc2FmZV9jaHIgKGxvIGxhbmQgMHhGRikpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAzKSAoQ2hhci51bnNhZmVfY2hyIChsbyBsc3IgOCkpO1xuICAgICBiLnBvc2l0aW9uIDwtIHBvcyArIDRcbiB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCBhZGRfc3Vic3RyaW5nIGIgcyBvZmZzZXQgbGVuID1cbiAgaWYgb2Zmc2V0IDwgMCB8fCBsZW4gPCAwIHx8IG9mZnNldCA+IFN0cmluZy5sZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQnVmZmVyLmFkZF9zdWJzdHJpbmcvYWRkX3N1YmJ5dGVzXCI7XG4gIGxldCBuZXdfcG9zaXRpb24gPSBiLnBvc2l0aW9uICsgbGVuIGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgbGVuO1xuICBCeXRlcy5ibGl0X3N0cmluZyBzIG9mZnNldCBiLmJ1ZmZlciBiLnBvc2l0aW9uIGxlbjtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9zdWJieXRlcyBiIHMgb2Zmc2V0IGxlbiA9XG4gIGFkZF9zdWJzdHJpbmcgYiAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBzKSBvZmZzZXQgbGVuXG5cbmxldCBhZGRfc3RyaW5nIGIgcyA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IG5ld19wb3NpdGlvbiA9IGIucG9zaXRpb24gKyBsZW4gaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiBsZW47XG4gIEJ5dGVzLmJsaXRfc3RyaW5nIHMgMCBiLmJ1ZmZlciBiLnBvc2l0aW9uIGxlbjtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9ieXRlcyBiIHMgPSBhZGRfc3RyaW5nIGIgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcylcblxubGV0IGFkZF9idWZmZXIgYiBicyA9XG4gIGFkZF9zdWJieXRlcyBiIGJzLmJ1ZmZlciAwIGJzLnBvc2l0aW9uXG5cbigqIHJlYWQgdXAgdG8gW2xlbl0gYnl0ZXMgZnJvbSBbaWNdIGludG8gW2JdLiAqKVxubGV0IHJlYyBhZGRfY2hhbm5lbF9yZWMgYiBpYyBsZW4gPVxuICBpZiBsZW4gPiAwIHRoZW4gKFxuICAgIGxldCBuID0gaW5wdXQgaWMgYi5idWZmZXIgYi5wb3NpdGlvbiBsZW4gaW5cbiAgICBiLnBvc2l0aW9uIDwtIGIucG9zaXRpb24gKyBuO1xuICAgIGlmIG4gPSAwIHRoZW4gcmFpc2UgRW5kX29mX2ZpbGVcbiAgICBlbHNlIGFkZF9jaGFubmVsX3JlYyBiIGljIChsZW4tbikgICAoKiBuIDw9IGxlbiAqKVxuICApXG5cbmxldCBhZGRfY2hhbm5lbCBiIGljIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgbGVuID4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIHRoZW4gICAoKiBQUiM1MDA0ICopXG4gICAgaW52YWxpZF9hcmcgXCJCdWZmZXIuYWRkX2NoYW5uZWxcIjtcbiAgaWYgYi5wb3NpdGlvbiArIGxlbiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgbGVuO1xuICBhZGRfY2hhbm5lbF9yZWMgYiBpYyBsZW5cblxubGV0IG91dHB1dF9idWZmZXIgb2MgYiA9XG4gIG91dHB1dCBvYyBiLmJ1ZmZlciAwIGIucG9zaXRpb25cblxubGV0IGNsb3NpbmcgPSBmdW5jdGlvblxuICB8ICcoJyAtPiAnKSdcbiAgfCAneycgLT4gJ30nXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuKCogb3BlbmluZyBhbmQgY2xvc2luZzogb3BlbiBhbmQgY2xvc2UgY2hhcmFjdGVycywgdHlwaWNhbGx5ICggYW5kIClcbiAgIGs6IGJhbGFuY2Ugb2Ygb3BlbmluZyBhbmQgY2xvc2luZyBjaGFyc1xuICAgczogdGhlIHN0cmluZyB3aGVyZSB3ZSBhcmUgc2VhcmNoaW5nXG4gICBzdGFydDogdGhlIGluZGV4IHdoZXJlIHdlIHN0YXJ0IHRoZSBzZWFyY2guICopXG5sZXQgYWR2YW5jZV90b19jbG9zaW5nIG9wZW5pbmcgY2xvc2luZyBrIHMgc3RhcnQgPVxuICBsZXQgcmVjIGFkdmFuY2UgayBpIGxpbSA9XG4gICAgaWYgaSA+PSBsaW0gdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICAgIGlmIHMuW2ldID0gb3BlbmluZyB0aGVuIGFkdmFuY2UgKGsgKyAxKSAoaSArIDEpIGxpbSBlbHNlXG4gICAgaWYgcy5baV0gPSBjbG9zaW5nIHRoZW5cbiAgICAgIGlmIGsgPSAwIHRoZW4gaSBlbHNlIGFkdmFuY2UgKGsgLSAxKSAoaSArIDEpIGxpbVxuICAgIGVsc2UgYWR2YW5jZSBrIChpICsgMSkgbGltIGluXG4gIGFkdmFuY2UgayBzdGFydCAoU3RyaW5nLmxlbmd0aCBzKVxuXG5sZXQgYWR2YW5jZV90b19ub25fYWxwaGEgcyBzdGFydCA9XG4gIGxldCByZWMgYWR2YW5jZSBpIGxpbSA9XG4gICAgaWYgaSA+PSBsaW0gdGhlbiBsaW0gZWxzZVxuICAgIG1hdGNoIHMuW2ldIHdpdGhcbiAgICB8ICdhJyAuLiAneicgfCAnQScgLi4gJ1onIHwgJzAnIC4uICc5JyB8ICdfJyAtPiBhZHZhbmNlIChpICsgMSkgbGltXG4gICAgfCBfIC0+IGkgaW5cbiAgYWR2YW5jZSBzdGFydCAoU3RyaW5nLmxlbmd0aCBzKVxuXG4oKiBXZSBhcmUganVzdCBhdCB0aGUgYmVnaW5uaW5nIG9mIGFuIGlkZW50IGluIHMsIHN0YXJ0aW5nIGF0IHN0YXJ0LiAqKVxubGV0IGZpbmRfaWRlbnQgcyBzdGFydCBsaW0gPVxuICBpZiBzdGFydCA+PSBsaW0gdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBtYXRjaCBzLltzdGFydF0gd2l0aFxuICAoKiBQYXJlbnRoZXNpemVkIGlkZW50ID8gKilcbiAgfCAnKCcgfCAneycgYXMgYyAtPlxuICAgICBsZXQgbmV3X3N0YXJ0ID0gc3RhcnQgKyAxIGluXG4gICAgIGxldCBzdG9wID0gYWR2YW5jZV90b19jbG9zaW5nIGMgKGNsb3NpbmcgYykgMCBzIG5ld19zdGFydCBpblxuICAgICBTdHJpbmcuc3ViIHMgbmV3X3N0YXJ0IChzdG9wIC0gc3RhcnQgLSAxKSwgc3RvcCArIDFcbiAgKCogUmVndWxhciBpZGVudCAqKVxuICB8IF8gLT5cbiAgICAgbGV0IHN0b3AgPSBhZHZhbmNlX3RvX25vbl9hbHBoYSBzIChzdGFydCArIDEpIGluXG4gICAgIFN0cmluZy5zdWIgcyBzdGFydCAoc3RvcCAtIHN0YXJ0KSwgc3RvcFxuXG4oKiBTdWJzdGl0dXRlICRpZGVudCwgJChpZGVudCksIG9yICR7aWRlbnR9IGluIHMsXG4gICAgYWNjb3JkaW5nIHRvIHRoZSBmdW5jdGlvbiBtYXBwaW5nIGYuICopXG5sZXQgYWRkX3N1YnN0aXR1dGUgYiBmIHMgPVxuICBsZXQgbGltID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCByZWMgc3Vic3QgcHJldmlvdXMgaSA9XG4gICAgaWYgaSA8IGxpbSB0aGVuIGJlZ2luXG4gICAgICBtYXRjaCBzLltpXSB3aXRoXG4gICAgICB8ICckJyBhcyBjdXJyZW50IHdoZW4gcHJldmlvdXMgPSAnXFxcXCcgLT5cbiAgICAgICAgIGFkZF9jaGFyIGIgY3VycmVudDtcbiAgICAgICAgIHN1YnN0ICcgJyAoaSArIDEpXG4gICAgICB8ICckJyAtPlxuICAgICAgICAgbGV0IGogPSBpICsgMSBpblxuICAgICAgICAgbGV0IGlkZW50LCBuZXh0X2kgPSBmaW5kX2lkZW50IHMgaiBsaW0gaW5cbiAgICAgICAgIGFkZF9zdHJpbmcgYiAoZiBpZGVudCk7XG4gICAgICAgICBzdWJzdCAnICcgbmV4dF9pXG4gICAgICB8IGN1cnJlbnQgd2hlbiBwcmV2aW91cyA9PSAnXFxcXCcgLT5cbiAgICAgICAgIGFkZF9jaGFyIGIgJ1xcXFwnO1xuICAgICAgICAgYWRkX2NoYXIgYiBjdXJyZW50O1xuICAgICAgICAgc3Vic3QgJyAnIChpICsgMSlcbiAgICAgIHwgJ1xcXFwnIGFzIGN1cnJlbnQgLT5cbiAgICAgICAgIHN1YnN0IGN1cnJlbnQgKGkgKyAxKVxuICAgICAgfCBjdXJyZW50IC0+XG4gICAgICAgICBhZGRfY2hhciBiIGN1cnJlbnQ7XG4gICAgICAgICBzdWJzdCBjdXJyZW50IChpICsgMSlcbiAgICBlbmQgZWxzZVxuICAgIGlmIHByZXZpb3VzID0gJ1xcXFwnIHRoZW4gYWRkX2NoYXIgYiBwcmV2aW91cyBpblxuICBzdWJzdCAnICcgMFxuXG5sZXQgdHJ1bmNhdGUgYiBsZW4gPVxuICAgIGlmIGxlbiA8IDAgfHwgbGVuID4gbGVuZ3RoIGIgdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJCdWZmZXIudHJ1bmNhdGVcIlxuICAgIGVsc2VcbiAgICAgIGIucG9zaXRpb24gPC0gbGVuXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIFhhdmllciBMZXJveSBhbmQgUGllcnJlIFdlaXMsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdFxuXG5sZXQga2ZwcmludGYgayBvIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9wcmludGYgKGZ1biBvIGFjYyAtPiBvdXRwdXRfYWNjIG8gYWNjOyBrIG8pIG8gRW5kX29mX2FjYyBmbXRcbmxldCBrYnByaW50ZiBrIGIgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX3ByaW50ZiAoZnVuIGIgYWNjIC0+IGJ1ZnB1dF9hY2MgYiBhY2M7IGsgYikgYiBFbmRfb2ZfYWNjIGZtdFxubGV0IGlrZnByaW50ZiBrIG9jIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9pcHJpbnRmIGsgb2MgZm10XG5cbmxldCBmcHJpbnRmIG9jIGZtdCA9IGtmcHJpbnRmIGlnbm9yZSBvYyBmbXRcbmxldCBicHJpbnRmIGIgZm10ID0ga2JwcmludGYgaWdub3JlIGIgZm10XG5sZXQgaWZwcmludGYgb2MgZm10ID0gaWtmcHJpbnRmIGlnbm9yZSBvYyBmbXRcbmxldCBwcmludGYgZm10ID0gZnByaW50ZiBzdGRvdXQgZm10XG5sZXQgZXByaW50ZiBmbXQgPSBmcHJpbnRmIHN0ZGVyciBmbXRcblxubGV0IGtzcHJpbnRmIGsgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBsZXQgaycgKCkgYWNjID1cbiAgICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSA2NCBpblxuICAgIHN0cnB1dF9hY2MgYnVmIGFjYztcbiAgICBrIChCdWZmZXIuY29udGVudHMgYnVmKSBpblxuICBtYWtlX3ByaW50ZiBrJyAoKSBFbmRfb2ZfYWNjIGZtdFxuXG5sZXQgc3ByaW50ZiBmbXQgPSBrc3ByaW50ZiAoZnVuIHMgLT4gcykgZm10XG5cbmxldCBrcHJpbnRmID0ga3NwcmludGZcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSBrZXkgPSBzdHJpbmdcbnR5cGUgZG9jID0gc3RyaW5nXG50eXBlIHVzYWdlX21zZyA9IHN0cmluZ1xudHlwZSBhbm9uX2Z1biA9IChzdHJpbmcgLT4gdW5pdClcblxudHlwZSBzcGVjID1cbiAgfCBVbml0IG9mICh1bml0IC0+IHVuaXQpICAgICAoKiBDYWxsIHRoZSBmdW5jdGlvbiB3aXRoIHVuaXQgYXJndW1lbnQgKilcbiAgfCBCb29sIG9mIChib29sIC0+IHVuaXQpICAgICAoKiBDYWxsIHRoZSBmdW5jdGlvbiB3aXRoIGEgYm9vbCBhcmd1bWVudCAqKVxuICB8IFNldCBvZiBib29sIHJlZiAgICAgICAgICAgICgqIFNldCB0aGUgcmVmZXJlbmNlIHRvIHRydWUgKilcbiAgfCBDbGVhciBvZiBib29sIHJlZiAgICAgICAgICAoKiBTZXQgdGhlIHJlZmVyZW5jZSB0byBmYWxzZSAqKVxuICB8IFN0cmluZyBvZiAoc3RyaW5nIC0+IHVuaXQpICgqIENhbGwgdGhlIGZ1bmN0aW9uIHdpdGggYSBzdHJpbmcgYXJndW1lbnQgKilcbiAgfCBTZXRfc3RyaW5nIG9mIHN0cmluZyByZWYgICAoKiBTZXQgdGhlIHJlZmVyZW5jZSB0byB0aGUgc3RyaW5nIGFyZ3VtZW50ICopXG4gIHwgSW50IG9mIChpbnQgLT4gdW5pdCkgICAgICAgKCogQ2FsbCB0aGUgZnVuY3Rpb24gd2l0aCBhbiBpbnQgYXJndW1lbnQgKilcbiAgfCBTZXRfaW50IG9mIGludCByZWYgICAgICAgICAoKiBTZXQgdGhlIHJlZmVyZW5jZSB0byB0aGUgaW50IGFyZ3VtZW50ICopXG4gIHwgRmxvYXQgb2YgKGZsb2F0IC0+IHVuaXQpICAgKCogQ2FsbCB0aGUgZnVuY3Rpb24gd2l0aCBhIGZsb2F0IGFyZ3VtZW50ICopXG4gIHwgU2V0X2Zsb2F0IG9mIGZsb2F0IHJlZiAgICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gdGhlIGZsb2F0IGFyZ3VtZW50ICopXG4gIHwgVHVwbGUgb2Ygc3BlYyBsaXN0ICAgICAgICAgKCogVGFrZSBzZXZlcmFsIGFyZ3VtZW50cyBhY2NvcmRpbmcgdG8gdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BlYyBsaXN0ICopXG4gIHwgU3ltYm9sIG9mIHN0cmluZyBsaXN0ICogKHN0cmluZyAtPiB1bml0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFRha2Ugb25lIG9mIHRoZSBzeW1ib2xzIGFzIGFyZ3VtZW50IGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGwgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIHN5bWJvbC4gKilcbiAgfCBSZXN0IG9mIChzdHJpbmcgLT4gdW5pdCkgICAoKiBTdG9wIGludGVycHJldGluZyBrZXl3b3JkcyBhbmQgY2FsbCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB3aXRoIGVhY2ggcmVtYWluaW5nIGFyZ3VtZW50ICopXG4gIHwgRXhwYW5kIG9mIChzdHJpbmcgLT4gc3RyaW5nIGFycmF5KSAoKiBJZiB0aGUgcmVtYWluaW5nIGFyZ3VtZW50cyB0byBwcm9jZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmUgb2YgdGhlIGZvcm1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtbXCItZm9vXCI7IFwiYXJnXCJdIEAgcmVzdF0gd2hlcmUgXCJmb29cIiBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJlZCBhcyBbRXhwYW5kIGZdLCB0aGVuIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzIFtmIFwiYXJnXCIgQCByZXN0XSBhcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NlZC4gT25seSBhbGxvd2VkIGluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNdLiAqKVxuXG5leGNlcHRpb24gQmFkIG9mIHN0cmluZ1xuZXhjZXB0aW9uIEhlbHAgb2Ygc3RyaW5nXG5cbnR5cGUgZXJyb3IgPVxuICB8IFVua25vd24gb2Ygc3RyaW5nXG4gIHwgV3Jvbmcgb2Ygc3RyaW5nICogc3RyaW5nICogc3RyaW5nICAoKiBvcHRpb24sIGFjdHVhbCwgZXhwZWN0ZWQgKilcbiAgfCBNaXNzaW5nIG9mIHN0cmluZ1xuICB8IE1lc3NhZ2Ugb2Ygc3RyaW5nXG5cbmV4Y2VwdGlvbiBTdG9wIG9mIGVycm9yICgqIHVzZWQgaW50ZXJuYWxseSAqKVxuXG5vcGVuIFByaW50ZlxuXG5sZXQgcmVjIGFzc29jMyB4IGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCAoeTEsIHkyLCBfKSA6OiBfIHdoZW4geTEgPSB4IC0+IHkyXG4gIHwgXyA6OiB0IC0+IGFzc29jMyB4IHRcblxuXG5sZXQgc3BsaXQgcyA9XG4gIGxldCBpID0gU3RyaW5nLmluZGV4IHMgJz0nIGluXG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgU3RyaW5nLnN1YiBzIDAgaSwgU3RyaW5nLnN1YiBzIChpKzEpIChsZW4tKGkrMSkpXG5cblxubGV0IG1ha2Vfc3ltbGlzdCBwcmVmaXggc2VwIHN1ZmZpeCBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gXCI8bm9uZT5cIlxuICB8IGg6OnQgLT4gKExpc3QuZm9sZF9sZWZ0IChmdW4geCB5IC0+IHggXiBzZXAgXiB5KSAocHJlZml4IF4gaCkgdCkgXiBzdWZmaXhcblxuXG5sZXQgcHJpbnRfc3BlYyBidWYgKGtleSwgc3BlYywgZG9jKSA9XG4gIGlmIFN0cmluZy5sZW5ndGggZG9jID4gMCB0aGVuXG4gICAgbWF0Y2ggc3BlYyB3aXRoXG4gICAgfCBTeW1ib2wgKGwsIF8pIC0+XG4gICAgICAgIGJwcmludGYgYnVmIFwiICAlcyAlcyVzXFxuXCIga2V5IChtYWtlX3N5bWxpc3QgXCJ7XCIgXCJ8XCIgXCJ9XCIgbCkgZG9jXG4gICAgfCBfIC0+XG4gICAgICAgIGJwcmludGYgYnVmIFwiICAlcyAlc1xcblwiIGtleSBkb2NcblxuXG5sZXQgaGVscF9hY3Rpb24gKCkgPSByYWlzZSAoU3RvcCAoVW5rbm93biBcIi1oZWxwXCIpKVxuXG5sZXQgYWRkX2hlbHAgc3BlY2xpc3QgPVxuICBsZXQgYWRkMSA9XG4gICAgdHJ5IGlnbm9yZSAoYXNzb2MzIFwiLWhlbHBcIiBzcGVjbGlzdCk7IFtdXG4gICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgICAgICAgIFtcIi1oZWxwXCIsIFVuaXQgaGVscF9hY3Rpb24sIFwiIERpc3BsYXkgdGhpcyBsaXN0IG9mIG9wdGlvbnNcIl1cbiAgYW5kIGFkZDIgPVxuICAgIHRyeSBpZ25vcmUgKGFzc29jMyBcIi0taGVscFwiIHNwZWNsaXN0KTsgW11cbiAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgICAgICAgW1wiLS1oZWxwXCIsIFVuaXQgaGVscF9hY3Rpb24sIFwiIERpc3BsYXkgdGhpcyBsaXN0IG9mIG9wdGlvbnNcIl1cbiAgaW5cbiAgc3BlY2xpc3QgQCAoYWRkMSBAIGFkZDIpXG5cblxubGV0IHVzYWdlX2IgYnVmIHNwZWNsaXN0IGVycm1zZyA9XG4gIGJwcmludGYgYnVmIFwiJXNcXG5cIiBlcnJtc2c7XG4gIExpc3QuaXRlciAocHJpbnRfc3BlYyBidWYpIChhZGRfaGVscCBzcGVjbGlzdClcblxuXG5sZXQgdXNhZ2Vfc3RyaW5nIHNwZWNsaXN0IGVycm1zZyA9XG4gIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAyMDAgaW5cbiAgdXNhZ2VfYiBiIHNwZWNsaXN0IGVycm1zZztcbiAgQnVmZmVyLmNvbnRlbnRzIGJcblxuXG5sZXQgdXNhZ2Ugc3BlY2xpc3QgZXJybXNnID1cbiAgZXByaW50ZiBcIiVzXCIgKHVzYWdlX3N0cmluZyBzcGVjbGlzdCBlcnJtc2cpXG5cblxubGV0IGN1cnJlbnQgPSByZWYgMFxuXG5sZXQgYm9vbF9vZl9zdHJpbmdfb3B0IHggPVxuICB0cnkgU29tZSAoYm9vbF9vZl9zdHJpbmcgeClcbiAgd2l0aCBJbnZhbGlkX2FyZ3VtZW50IF8gLT4gTm9uZVxuXG5sZXQgaW50X29mX3N0cmluZ19vcHQgeCA9XG4gIHRyeSBTb21lIChpbnRfb2Zfc3RyaW5nIHgpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxubGV0IGZsb2F0X29mX3N0cmluZ19vcHQgeCA9XG4gIHRyeSBTb21lIChmbG9hdF9vZl9zdHJpbmcgeClcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG5sZXQgcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNfYXV4IGFsbG93X2V4cGFuZCBjdXJyZW50IGFyZ3Ygc3BlY2xpc3QgYW5vbmZ1biBlcnJtc2cgPVxuICBsZXQgaW5pdHBvcyA9ICFjdXJyZW50IGluXG4gIGxldCBjb252ZXJ0X2Vycm9yIGVycm9yID1cbiAgICAoKiBjb252ZXJ0IGFuIGludGVybmFsIGVycm9yIHRvIGEgQmFkL0hlbHAgZXhjZXB0aW9uXG4gICAgICAgKm9yKiBhZGQgdGhlIHByb2dyYW0gbmFtZSBhcyBhIHByZWZpeCBhbmQgdGhlIHVzYWdlIG1lc3NhZ2UgYXMgYSBzdWZmaXhcbiAgICAgICB0byBhbiB1c2VyLXJhaXNlZCBCYWQgZXhjZXB0aW9uLlxuICAgICopXG4gICAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIDIwMCBpblxuICAgIGxldCBwcm9nbmFtZSA9IGlmIGluaXRwb3MgPCAoQXJyYXkubGVuZ3RoICFhcmd2KSB0aGVuICFhcmd2Lihpbml0cG9zKSBlbHNlIFwiKD8pXCIgaW5cbiAgICBiZWdpbiBtYXRjaCBlcnJvciB3aXRoXG4gICAgICB8IFVua25vd24gXCItaGVscFwiIC0+ICgpXG4gICAgICB8IFVua25vd24gXCItLWhlbHBcIiAtPiAoKVxuICAgICAgfCBVbmtub3duIHMgLT5cbiAgICAgICAgICBicHJpbnRmIGIgXCIlczogdW5rbm93biBvcHRpb24gJyVzJy5cXG5cIiBwcm9nbmFtZSBzXG4gICAgICB8IE1pc3NpbmcgcyAtPlxuICAgICAgICAgIGJwcmludGYgYiBcIiVzOiBvcHRpb24gJyVzJyBuZWVkcyBhbiBhcmd1bWVudC5cXG5cIiBwcm9nbmFtZSBzXG4gICAgICB8IFdyb25nIChvcHQsIGFyZywgZXhwZWN0ZWQpIC0+XG4gICAgICAgICAgYnByaW50ZiBiIFwiJXM6IHdyb25nIGFyZ3VtZW50ICclcyc7IG9wdGlvbiAnJXMnIGV4cGVjdHMgJXMuXFxuXCJcbiAgICAgICAgICAgICAgICAgIHByb2duYW1lIGFyZyBvcHQgZXhwZWN0ZWRcbiAgICAgIHwgTWVzc2FnZSBzIC0+ICgqIHVzZXIgZXJyb3IgbWVzc2FnZSAqKVxuICAgICAgICAgIGJwcmludGYgYiBcIiVzOiAlcy5cXG5cIiBwcm9nbmFtZSBzXG4gICAgZW5kO1xuICAgIHVzYWdlX2IgYiAhc3BlY2xpc3QgZXJybXNnO1xuICAgIGlmIGVycm9yID0gVW5rbm93biBcIi1oZWxwXCIgfHwgZXJyb3IgPSBVbmtub3duIFwiLS1oZWxwXCJcbiAgICB0aGVuIEhlbHAgKEJ1ZmZlci5jb250ZW50cyBiKVxuICAgIGVsc2UgQmFkIChCdWZmZXIuY29udGVudHMgYilcbiAgaW5cbiAgaW5jciBjdXJyZW50O1xuICB3aGlsZSAhY3VycmVudCA8IChBcnJheS5sZW5ndGggIWFyZ3YpIGRvXG4gICAgYmVnaW4gdHJ5XG4gICAgICBsZXQgcyA9ICFhcmd2LighY3VycmVudCkgaW5cbiAgICAgIGlmIFN0cmluZy5sZW5ndGggcyA+PSAxICYmIHMuWzBdID0gJy0nIHRoZW4gYmVnaW5cbiAgICAgICAgbGV0IGFjdGlvbiwgZm9sbG93ID1cbiAgICAgICAgICB0cnkgYXNzb2MzIHMgIXNwZWNsaXN0LCBOb25lXG4gICAgICAgICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgICAgICB0cnlcbiAgICAgICAgICAgIGxldCBrZXl3b3JkLCBhcmcgPSBzcGxpdCBzIGluXG4gICAgICAgICAgICBhc3NvYzMga2V5d29yZCAhc3BlY2xpc3QsIFNvbWUgYXJnXG4gICAgICAgICAgd2l0aCBOb3RfZm91bmQgLT4gcmFpc2UgKFN0b3AgKFVua25vd24gcykpXG4gICAgICAgIGluXG4gICAgICAgIGxldCBub19hcmcgKCkgPVxuICAgICAgICAgIG1hdGNoIGZvbGxvdyB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgICAgfCBTb21lIGFyZyAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJubyBhcmd1bWVudFwiKSkpIGluXG4gICAgICAgIGxldCBnZXRfYXJnICgpID1cbiAgICAgICAgICBtYXRjaCBmb2xsb3cgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICBpZiAhY3VycmVudCArIDEgPCAoQXJyYXkubGVuZ3RoICFhcmd2KSB0aGVuICFhcmd2LighY3VycmVudCArIDEpXG4gICAgICAgICAgICAgIGVsc2UgcmFpc2UgKFN0b3AgKE1pc3NpbmcgcykpXG4gICAgICAgICAgfCBTb21lIGFyZyAtPiBhcmdcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IGNvbnN1bWVfYXJnICgpID1cbiAgICAgICAgICBtYXRjaCBmb2xsb3cgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBpbmNyIGN1cnJlbnRcbiAgICAgICAgICB8IFNvbWUgXyAtPiAoKVxuICAgICAgICBpblxuICAgICAgICBsZXQgcmVjIHRyZWF0X2FjdGlvbiA9IGZ1bmN0aW9uXG4gICAgICAgIHwgVW5pdCBmIC0+IGYgKCk7XG4gICAgICAgIHwgQm9vbCBmIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggYm9vbF9vZl9zdHJpbmdfb3B0IGFyZyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwiYSBib29sZWFuXCIpKSlcbiAgICAgICAgICAgIHwgU29tZSBzIC0+IGYgc1xuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgU2V0IHIgLT4gbm9fYXJnICgpOyByIDo9IHRydWU7XG4gICAgICAgIHwgQ2xlYXIgciAtPiBub19hcmcgKCk7IHIgOj0gZmFsc2U7XG4gICAgICAgIHwgU3RyaW5nIGYgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBmIGFyZztcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IFN5bWJvbCAoc3ltYiwgZikgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBpZiBMaXN0Lm1lbSBhcmcgc3ltYiB0aGVuIGJlZ2luXG4gICAgICAgICAgICAgIGYgYXJnO1xuICAgICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcIm9uZSBvZjogXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF4gKG1ha2Vfc3ltbGlzdCBcIlwiIFwiIFwiIFwiXCIgc3ltYikpKSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICB8IFNldF9zdHJpbmcgciAtPlxuICAgICAgICAgICAgciA6PSBnZXRfYXJnICgpO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgSW50IGYgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBpbnRfb2Zfc3RyaW5nX29wdCBhcmcgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcImFuIGludGVnZXJcIikpKVxuICAgICAgICAgICAgfCBTb21lIHggLT4gZiB4XG4gICAgICAgICAgICBlbmQ7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBTZXRfaW50IHIgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBpbnRfb2Zfc3RyaW5nX29wdCBhcmcgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcImFuIGludGVnZXJcIikpKVxuICAgICAgICAgICAgfCBTb21lIHggLT4gciA6PSB4XG4gICAgICAgICAgICBlbmQ7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBGbG9hdCBmIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggZmxvYXRfb2Zfc3RyaW5nX29wdCBhcmcgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcImEgZmxvYXRcIikpKVxuICAgICAgICAgICAgfCBTb21lIHggLT4gZiB4XG4gICAgICAgICAgICBlbmQ7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBTZXRfZmxvYXQgciAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGZsb2F0X29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhIGZsb2F0XCIpKSlcbiAgICAgICAgICAgIHwgU29tZSB4IC0+IHIgOj0geFxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgVHVwbGUgc3BlY3MgLT5cbiAgICAgICAgICAgIExpc3QuaXRlciB0cmVhdF9hY3Rpb24gc3BlY3M7XG4gICAgICAgIHwgUmVzdCBmIC0+XG4gICAgICAgICAgICB3aGlsZSAhY3VycmVudCA8IChBcnJheS5sZW5ndGggIWFyZ3YpIC0gMSBkb1xuICAgICAgICAgICAgICBmICFhcmd2LighY3VycmVudCArIDEpO1xuICAgICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgICAgIGRvbmU7XG4gICAgICAgIHwgRXhwYW5kIGYgLT5cbiAgICAgICAgICAgIGlmIG5vdCBhbGxvd19leHBhbmQgdGhlblxuICAgICAgICAgICAgICByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcIkFyZy5FeHBhbmQgaXMgaXMgb25seSBhbGxvd2VkIHdpdGggQXJnLnBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljXCIpO1xuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGxldCBuZXdhcmcgPSBmIGFyZyBpblxuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgICAgICBsZXQgYmVmb3JlID0gQXJyYXkuc3ViICFhcmd2IDAgKCFjdXJyZW50ICsgMSlcbiAgICAgICAgICAgIGFuZCBhZnRlciA9IEFycmF5LnN1YiAhYXJndiAoIWN1cnJlbnQgKyAxKSAoKEFycmF5Lmxlbmd0aCAhYXJndikgLSAhY3VycmVudCAtIDEpIGluXG4gICAgICAgICAgICBhcmd2Oj0gQXJyYXkuY29uY2F0IFtiZWZvcmU7bmV3YXJnO2FmdGVyXTtcbiAgICAgICAgaW5cbiAgICAgICAgdHJlYXRfYWN0aW9uIGFjdGlvbiBlbmRcbiAgICAgIGVsc2UgYW5vbmZ1biBzXG4gICAgd2l0aCB8IEJhZCBtIC0+IHJhaXNlIChjb252ZXJ0X2Vycm9yIChNZXNzYWdlIG0pKTtcbiAgICAgICAgIHwgU3RvcCBlIC0+IHJhaXNlIChjb252ZXJ0X2Vycm9yIGUpO1xuICAgIGVuZDtcbiAgICBpbmNyIGN1cnJlbnRcbiAgZG9uZVxuXG5sZXQgcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWMgY3VycmVudCBhcmd2IHNwZWNsaXN0IGFub25mdW4gZXJybXNnID1cbiAgcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNfYXV4IHRydWUgY3VycmVudCBhcmd2IHNwZWNsaXN0IGFub25mdW4gZXJybXNnXG5cbmxldCBwYXJzZV9hcmd2X2R5bmFtaWMgPyhjdXJyZW50PWN1cnJlbnQpIGFyZ3Ygc3BlY2xpc3QgYW5vbmZ1biBlcnJtc2cgPVxuICBwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pY19hdXggZmFsc2UgY3VycmVudCAocmVmIGFyZ3YpIHNwZWNsaXN0IGFub25mdW4gZXJybXNnXG5cblxubGV0IHBhcnNlX2FyZ3YgPyhjdXJyZW50PWN1cnJlbnQpIGFyZ3Ygc3BlY2xpc3QgYW5vbmZ1biBlcnJtc2cgPVxuICBwYXJzZV9hcmd2X2R5bmFtaWMgfmN1cnJlbnQ6Y3VycmVudCBhcmd2IChyZWYgc3BlY2xpc3QpIGFub25mdW4gZXJybXNnXG5cblxubGV0IHBhcnNlIGwgZiBtc2cgPVxuICB0cnlcbiAgICBwYXJzZV9hcmd2IFN5cy5hcmd2IGwgZiBtc2dcbiAgd2l0aFxuICB8IEJhZCBtc2cgLT4gZXByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDJcbiAgfCBIZWxwIG1zZyAtPiBwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAwXG5cblxubGV0IHBhcnNlX2R5bmFtaWMgbCBmIG1zZyA9XG4gIHRyeVxuICAgIHBhcnNlX2FyZ3ZfZHluYW1pYyBTeXMuYXJndiBsIGYgbXNnXG4gIHdpdGhcbiAgfCBCYWQgbXNnIC0+IGVwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAyXG4gIHwgSGVscCBtc2cgLT4gcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMFxuXG5sZXQgcGFyc2VfZXhwYW5kIGwgZiBtc2cgPVxuICB0cnlcbiAgICBsZXQgYXJndiA9IHJlZiBTeXMuYXJndiBpblxuICAgIGxldCBzcGVjID0gcmVmIGwgaW5cbiAgICBsZXQgY3VycmVudCA9IHJlZiAoIWN1cnJlbnQpIGluXG4gICAgcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWMgY3VycmVudCBhcmd2IHNwZWMgZiBtc2dcbiAgd2l0aFxuICB8IEJhZCBtc2cgLT4gZXByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDJcbiAgfCBIZWxwIG1zZyAtPiBwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAwXG5cblxubGV0IHNlY29uZF93b3JkIHMgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCByZWMgbG9vcCBuID1cbiAgICBpZiBuID49IGxlbiB0aGVuIGxlblxuICAgIGVsc2UgaWYgcy5bbl0gPSAnICcgdGhlbiBsb29wIChuKzEpXG4gICAgZWxzZSBuXG4gIGluXG4gIG1hdGNoIFN0cmluZy5pbmRleCBzICdcXHQnIHdpdGhcbiAgfCBuIC0+IGxvb3AgKG4rMSlcbiAgfCBleGNlcHRpb24gTm90X2ZvdW5kIC0+XG4gICAgICBiZWdpbiBtYXRjaCBTdHJpbmcuaW5kZXggcyAnICcgd2l0aFxuICAgICAgfCBuIC0+IGxvb3AgKG4rMSlcbiAgICAgIHwgZXhjZXB0aW9uIE5vdF9mb3VuZCAtPiBsZW5cbiAgICAgIGVuZFxuXG5cbmxldCBtYXhfYXJnX2xlbiBjdXIgKGt3ZCwgc3BlYywgZG9jKSA9XG4gIG1hdGNoIHNwZWMgd2l0aFxuICB8IFN5bWJvbCBfIC0+IG1heCBjdXIgKFN0cmluZy5sZW5ndGgga3dkKVxuICB8IF8gLT4gbWF4IGN1ciAoU3RyaW5nLmxlbmd0aCBrd2QgKyBzZWNvbmRfd29yZCBkb2MpXG5cblxubGV0IHJlcGxhY2VfbGVhZGluZ190YWIgcyA9XG4gIGxldCBzZWVuID0gcmVmIGZhbHNlIGluXG4gIFN0cmluZy5tYXAgKGZ1bmN0aW9uICdcXHQnIHdoZW4gbm90ICFzZWVuIC0+IHNlZW4gOj0gdHJ1ZTsgJyAnIHwgYyAtPiBjKSBzXG5cbmxldCBhZGRfcGFkZGluZyBsZW4ga3NkID1cbiAgbWF0Y2gga3NkIHdpdGhcbiAgfCAoXywgXywgXCJcIikgLT5cbiAgICAgICgqIERvIG5vdCBwYWQgdW5kb2N1bWVudGVkIG9wdGlvbnMsIHNvIHRoYXQgdGhleSBzdGlsbCBkb24ndCBzaG93IHVwIHdoZW5cbiAgICAgICAqIHJ1biB0aHJvdWdoIFt1c2FnZV0gb3IgW3BhcnNlXS4gKilcbiAgICAgIGtzZFxuICB8IChrd2QsIChTeW1ib2wgXyBhcyBzcGVjKSwgbXNnKSAtPlxuICAgICAgbGV0IGN1dGNvbCA9IHNlY29uZF93b3JkIG1zZyBpblxuICAgICAgbGV0IHNwYWNlcyA9IFN0cmluZy5tYWtlICgobWF4IDAgKGxlbiAtIGN1dGNvbCkpICsgMykgJyAnIGluXG4gICAgICAoa3dkLCBzcGVjLCBcIlxcblwiIF4gc3BhY2VzIF4gcmVwbGFjZV9sZWFkaW5nX3RhYiBtc2cpXG4gIHwgKGt3ZCwgc3BlYywgbXNnKSAtPlxuICAgICAgbGV0IGN1dGNvbCA9IHNlY29uZF93b3JkIG1zZyBpblxuICAgICAgbGV0IGt3ZF9sZW4gPSBTdHJpbmcubGVuZ3RoIGt3ZCBpblxuICAgICAgbGV0IGRpZmYgPSBsZW4gLSBrd2RfbGVuIC0gY3V0Y29sIGluXG4gICAgICBpZiBkaWZmIDw9IDAgdGhlblxuICAgICAgICAoa3dkLCBzcGVjLCByZXBsYWNlX2xlYWRpbmdfdGFiIG1zZylcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IHNwYWNlcyA9IFN0cmluZy5tYWtlIGRpZmYgJyAnIGluXG4gICAgICAgIGxldCBwcmVmaXggPSBTdHJpbmcuc3ViIChyZXBsYWNlX2xlYWRpbmdfdGFiIG1zZykgMCBjdXRjb2wgaW5cbiAgICAgICAgbGV0IHN1ZmZpeCA9IFN0cmluZy5zdWIgbXNnIGN1dGNvbCAoU3RyaW5nLmxlbmd0aCBtc2cgLSBjdXRjb2wpIGluXG4gICAgICAgIChrd2QsIHNwZWMsIHByZWZpeCBeIHNwYWNlcyBeIHN1ZmZpeClcblxuXG5sZXQgYWxpZ24gPyhsaW1pdD1tYXhfaW50KSBzcGVjbGlzdCA9XG4gIGxldCBjb21wbGV0ZWQgPSBhZGRfaGVscCBzcGVjbGlzdCBpblxuICBsZXQgbGVuID0gTGlzdC5mb2xkX2xlZnQgbWF4X2FyZ19sZW4gMCBjb21wbGV0ZWQgaW5cbiAgbGV0IGxlbiA9IG1pbiBsZW4gbGltaXQgaW5cbiAgTGlzdC5tYXAgKGFkZF9wYWRkaW5nIGxlbikgY29tcGxldGVkXG5cbmxldCB0cmltX2NyIHMgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGlmIGxlbiA+IDAgJiYgU3RyaW5nLmdldCBzIChsZW4gLSAxKSA9ICdcXHInIHRoZW5cbiAgICBTdHJpbmcuc3ViIHMgMCAobGVuIC0gMSlcbiAgZWxzZVxuICAgIHNcblxubGV0IHJlYWRfYXV4IHRyaW0gc2VwIGZpbGUgPVxuICBsZXQgaWMgPSBvcGVuX2luX2JpbiBmaWxlIGluXG4gIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIDIwMCBpblxuICBsZXQgd29yZHMgPSByZWYgW10gaW5cbiAgbGV0IHN0YXNoICgpID1cbiAgICBsZXQgd29yZCA9ICAoQnVmZmVyLmNvbnRlbnRzIGJ1ZikgaW5cbiAgICBsZXQgd29yZCA9IGlmIHRyaW0gdGhlbiB0cmltX2NyIHdvcmQgZWxzZSB3b3JkIGluXG4gICAgd29yZHMgOj0gd29yZCA6OiAhd29yZHM7XG4gICAgQnVmZmVyLmNsZWFyIGJ1ZlxuICBpblxuICBsZXQgcmVjIHJlYWQgKCkgPVxuICAgIHRyeVxuICAgICAgbGV0IGMgPSBpbnB1dF9jaGFyIGljIGluXG4gICAgICBpZiBjID0gc2VwIHRoZW4gYmVnaW5cbiAgICAgICAgc3Rhc2ggKCk7IHJlYWQgKClcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgYzsgcmVhZCAoKVxuICAgICAgZW5kXG4gICAgd2l0aCBFbmRfb2ZfZmlsZSAtPlxuICAgICAgaWYgQnVmZmVyLmxlbmd0aCBidWYgPiAwIHRoZW5cbiAgICAgICAgc3Rhc2ggKCkgaW5cbiAgcmVhZCAoKTtcbiAgY2xvc2VfaW4gaWM7XG4gIEFycmF5Lm9mX2xpc3QgKExpc3QucmV2ICF3b3JkcylcblxubGV0IHJlYWRfYXJnID0gcmVhZF9hdXggdHJ1ZSAnXFxuJ1xuXG5sZXQgcmVhZF9hcmcwID0gcmVhZF9hdXggZmFsc2UgJ1xceDAwJ1xuXG5sZXQgd3JpdGVfYXV4IHNlcCBmaWxlIGFyZ3MgPVxuICBsZXQgb2MgPSBvcGVuX291dF9iaW4gZmlsZSBpblxuICBBcnJheS5pdGVyIChmdW4gcyAtPiBmcHJpbnRmIG9jIFwiJXMlY1wiIHMgc2VwKSBhcmdzO1xuICBjbG9zZV9vdXQgb2NcblxubGV0IHdyaXRlX2FyZyA9IHdyaXRlX2F1eCAnXFxuJ1xuXG5sZXQgd3JpdGVfYXJnMCA9IHdyaXRlX2F1eCAnXFx4MDAnXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgc3RhdCA9IHtcbiAgbWlub3Jfd29yZHMgOiBmbG9hdDtcbiAgcHJvbW90ZWRfd29yZHMgOiBmbG9hdDtcbiAgbWFqb3Jfd29yZHMgOiBmbG9hdDtcbiAgbWlub3JfY29sbGVjdGlvbnMgOiBpbnQ7XG4gIG1ham9yX2NvbGxlY3Rpb25zIDogaW50O1xuICBoZWFwX3dvcmRzIDogaW50O1xuICBoZWFwX2NodW5rcyA6IGludDtcbiAgbGl2ZV93b3JkcyA6IGludDtcbiAgbGl2ZV9ibG9ja3MgOiBpbnQ7XG4gIGZyZWVfd29yZHMgOiBpbnQ7XG4gIGZyZWVfYmxvY2tzIDogaW50O1xuICBsYXJnZXN0X2ZyZWUgOiBpbnQ7XG4gIGZyYWdtZW50cyA6IGludDtcbiAgY29tcGFjdGlvbnMgOiBpbnQ7XG4gIHRvcF9oZWFwX3dvcmRzIDogaW50O1xuICBzdGFja19zaXplIDogaW50O1xufVxuXG50eXBlIGNvbnRyb2wgPSB7XG4gIG11dGFibGUgbWlub3JfaGVhcF9zaXplIDogaW50O1xuICBtdXRhYmxlIG1ham9yX2hlYXBfaW5jcmVtZW50IDogaW50O1xuICBtdXRhYmxlIHNwYWNlX292ZXJoZWFkIDogaW50O1xuICBtdXRhYmxlIHZlcmJvc2UgOiBpbnQ7XG4gIG11dGFibGUgbWF4X292ZXJoZWFkIDogaW50O1xuICBtdXRhYmxlIHN0YWNrX2xpbWl0IDogaW50O1xuICBtdXRhYmxlIGFsbG9jYXRpb25fcG9saWN5IDogaW50O1xuICB3aW5kb3dfc2l6ZSA6IGludDtcbn1cblxuZXh0ZXJuYWwgc3RhdCA6IHVuaXQgLT4gc3RhdCA9IFwiY2FtbF9nY19zdGF0XCJcbmV4dGVybmFsIHF1aWNrX3N0YXQgOiB1bml0IC0+IHN0YXQgPSBcImNhbWxfZ2NfcXVpY2tfc3RhdFwiXG5leHRlcm5hbCBjb3VudGVycyA6IHVuaXQgLT4gKGZsb2F0ICogZmxvYXQgKiBmbG9hdCkgPSBcImNhbWxfZ2NfY291bnRlcnNcIlxuZXh0ZXJuYWwgbWlub3Jfd29yZHMgOiB1bml0IC0+IChmbG9hdCBbQHVuYm94ZWRdKVxuICA9IFwiY2FtbF9nY19taW5vcl93b3Jkc1wiIFwiY2FtbF9nY19taW5vcl93b3Jkc191bmJveGVkXCJcbmV4dGVybmFsIGdldCA6IHVuaXQgLT4gY29udHJvbCA9IFwiY2FtbF9nY19nZXRcIlxuZXh0ZXJuYWwgc2V0IDogY29udHJvbCAtPiB1bml0ID0gXCJjYW1sX2djX3NldFwiXG5leHRlcm5hbCBtaW5vciA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9nY19taW5vclwiXG5leHRlcm5hbCBtYWpvcl9zbGljZSA6IGludCAtPiBpbnQgPSBcImNhbWxfZ2NfbWFqb3Jfc2xpY2VcIlxuZXh0ZXJuYWwgbWFqb3IgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfZ2NfbWFqb3JcIlxuZXh0ZXJuYWwgZnVsbF9tYWpvciA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9nY19mdWxsX21ham9yXCJcbmV4dGVybmFsIGNvbXBhY3QgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfZ2NfY29tcGFjdGlvblwiXG5leHRlcm5hbCBnZXRfbWlub3JfZnJlZSA6IHVuaXQgLT4gaW50ID0gXCJjYW1sX2dldF9taW5vcl9mcmVlXCJcbmV4dGVybmFsIGdldF9idWNrZXQgOiBpbnQgLT4gaW50ID0gXCJjYW1sX2dldF9tYWpvcl9idWNrZXRcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZ2V0X2NyZWRpdCA6IHVuaXQgLT4gaW50ID0gXCJjYW1sX2dldF9tYWpvcl9jcmVkaXRcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgaHVnZV9mYWxsYmFja19jb3VudCA6IHVuaXQgLT4gaW50ID0gXCJjYW1sX2djX2h1Z2VfZmFsbGJhY2tfY291bnRcIlxuXG5vcGVuIFByaW50ZlxuXG5sZXQgcHJpbnRfc3RhdCBjID1cbiAgbGV0IHN0ID0gc3RhdCAoKSBpblxuICBmcHJpbnRmIGMgXCJtaW5vcl9jb2xsZWN0aW9uczogJWRcXG5cIiBzdC5taW5vcl9jb2xsZWN0aW9ucztcbiAgZnByaW50ZiBjIFwibWFqb3JfY29sbGVjdGlvbnM6ICVkXFxuXCIgc3QubWFqb3JfY29sbGVjdGlvbnM7XG4gIGZwcmludGYgYyBcImNvbXBhY3Rpb25zOiAgICAgICAlZFxcblwiIHN0LmNvbXBhY3Rpb25zO1xuICBmcHJpbnRmIGMgXCJcXG5cIjtcbiAgbGV0IGwxID0gU3RyaW5nLmxlbmd0aCAoc3ByaW50ZiBcIiUuMGZcIiBzdC5taW5vcl93b3JkcykgaW5cbiAgZnByaW50ZiBjIFwibWlub3Jfd29yZHM6ICAgICUqLjBmXFxuXCIgbDEgc3QubWlub3Jfd29yZHM7XG4gIGZwcmludGYgYyBcInByb21vdGVkX3dvcmRzOiAlKi4wZlxcblwiIGwxIHN0LnByb21vdGVkX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJtYWpvcl93b3JkczogICAgJSouMGZcXG5cIiBsMSBzdC5tYWpvcl93b3JkcztcbiAgZnByaW50ZiBjIFwiXFxuXCI7XG4gIGxldCBsMiA9IFN0cmluZy5sZW5ndGggKHNwcmludGYgXCIlZFwiIHN0LnRvcF9oZWFwX3dvcmRzKSBpblxuICBmcHJpbnRmIGMgXCJ0b3BfaGVhcF93b3JkczogJSpkXFxuXCIgbDIgc3QudG9wX2hlYXBfd29yZHM7XG4gIGZwcmludGYgYyBcImhlYXBfd29yZHM6ICAgICAlKmRcXG5cIiBsMiBzdC5oZWFwX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJsaXZlX3dvcmRzOiAgICAgJSpkXFxuXCIgbDIgc3QubGl2ZV93b3JkcztcbiAgZnByaW50ZiBjIFwiZnJlZV93b3JkczogICAgICUqZFxcblwiIGwyIHN0LmZyZWVfd29yZHM7XG4gIGZwcmludGYgYyBcImxhcmdlc3RfZnJlZTogICAlKmRcXG5cIiBsMiBzdC5sYXJnZXN0X2ZyZWU7XG4gIGZwcmludGYgYyBcImZyYWdtZW50czogICAgICAlKmRcXG5cIiBsMiBzdC5mcmFnbWVudHM7XG4gIGZwcmludGYgYyBcIlxcblwiO1xuICBmcHJpbnRmIGMgXCJsaXZlX2Jsb2NrczogJWRcXG5cIiBzdC5saXZlX2Jsb2NrcztcbiAgZnByaW50ZiBjIFwiZnJlZV9ibG9ja3M6ICVkXFxuXCIgc3QuZnJlZV9ibG9ja3M7XG4gIGZwcmludGYgYyBcImhlYXBfY2h1bmtzOiAlZFxcblwiIHN0LmhlYXBfY2h1bmtzXG5cblxubGV0IGFsbG9jYXRlZF9ieXRlcyAoKSA9XG4gIGxldCAobWksIHBybywgbWEpID0gY291bnRlcnMgKCkgaW5cbiAgKG1pICsuIG1hIC0uIHBybykgKi4gZmxvYXRfb2ZfaW50IChTeXMud29yZF9zaXplIC8gOClcblxuXG5leHRlcm5hbCBmaW5hbGlzZSA6ICgnYSAtPiB1bml0KSAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2ZpbmFsX3JlZ2lzdGVyXCJcbmV4dGVybmFsIGZpbmFsaXNlX2xhc3QgOiAodW5pdCAtPiB1bml0KSAtPiAnYSAtPiB1bml0ID1cbiAgXCJjYW1sX2ZpbmFsX3JlZ2lzdGVyX2NhbGxlZF93aXRob3V0X3ZhbHVlXCJcbmV4dGVybmFsIGZpbmFsaXNlX3JlbGVhc2UgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfZmluYWxfcmVsZWFzZVwiXG5cblxudHlwZSBhbGFybSA9IGJvb2wgcmVmXG50eXBlIGFsYXJtX3JlYyA9IHthY3RpdmUgOiBhbGFybTsgZiA6IHVuaXQgLT4gdW5pdH1cblxubGV0IHJlYyBjYWxsX2FsYXJtIGFyZWMgPVxuICBpZiAhKGFyZWMuYWN0aXZlKSB0aGVuIGJlZ2luXG4gICAgZmluYWxpc2UgY2FsbF9hbGFybSBhcmVjO1xuICAgIGFyZWMuZiAoKTtcbiAgZW5kXG5cblxubGV0IGNyZWF0ZV9hbGFybSBmID1cbiAgbGV0IGFyZWMgPSB7IGFjdGl2ZSA9IHJlZiB0cnVlOyBmID0gZiB9IGluXG4gIGZpbmFsaXNlIGNhbGxfYWxhcm0gYXJlYztcbiAgYXJlYy5hY3RpdmVcblxuXG5sZXQgZGVsZXRlX2FsYXJtIGEgPSBhIDo9IGZhbHNlXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1lc3NhZ2UgZGlnZXN0IChNRDUpICopXG5cbnR5cGUgdCA9IHN0cmluZ1xuXG5sZXQgY29tcGFyZSA9IFN0cmluZy5jb21wYXJlXG5sZXQgZXF1YWwgPSBTdHJpbmcuZXF1YWxcblxuZXh0ZXJuYWwgdW5zYWZlX3N0cmluZzogc3RyaW5nIC0+IGludCAtPiBpbnQgLT4gdCA9IFwiY2FtbF9tZDVfc3RyaW5nXCJcbmV4dGVybmFsIGNoYW5uZWw6IGluX2NoYW5uZWwgLT4gaW50IC0+IHQgPSBcImNhbWxfbWQ1X2NoYW5cIlxuXG5sZXQgc3RyaW5nIHN0ciA9XG4gIHVuc2FmZV9zdHJpbmcgc3RyIDAgKFN0cmluZy5sZW5ndGggc3RyKVxuXG5sZXQgYnl0ZXMgYiA9IHN0cmluZyAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBiKVxuXG5sZXQgc3Vic3RyaW5nIHN0ciBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IFN0cmluZy5sZW5ndGggc3RyIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJEaWdlc3Quc3Vic3RyaW5nXCJcbiAgZWxzZSB1bnNhZmVfc3RyaW5nIHN0ciBvZnMgbGVuXG5cbmxldCBzdWJieXRlcyBiIG9mcyBsZW4gPSBzdWJzdHJpbmcgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgYikgb2ZzIGxlblxuXG5sZXQgZmlsZSBmaWxlbmFtZSA9XG4gIGxldCBpYyA9IG9wZW5faW5fYmluIGZpbGVuYW1lIGluXG4gIG1hdGNoIGNoYW5uZWwgaWMgKC0xKSB3aXRoXG4gICAgfCBkIC0+IGNsb3NlX2luIGljOyBkXG4gICAgfCBleGNlcHRpb24gZSAtPiBjbG9zZV9pbiBpYzsgcmFpc2UgZVxuXG5sZXQgb3V0cHV0IGNoYW4gZGlnZXN0ID1cbiAgb3V0cHV0X3N0cmluZyBjaGFuIGRpZ2VzdFxuXG5sZXQgaW5wdXQgY2hhbiA9IHJlYWxseV9pbnB1dF9zdHJpbmcgY2hhbiAxNlxuXG5sZXQgY2hhcl9oZXggbiA9XG4gIENoYXIudW5zYWZlX2NociAobiArIGlmIG4gPCAxMCB0aGVuIENoYXIuY29kZSAnMCcgZWxzZSAoQ2hhci5jb2RlICdhJyAtIDEwKSlcblxubGV0IHRvX2hleCBkID1cbiAgaWYgU3RyaW5nLmxlbmd0aCBkIDw+IDE2IHRoZW4gaW52YWxpZF9hcmcgXCJEaWdlc3QudG9faGV4XCI7XG4gIGxldCByZXN1bHQgPSBCeXRlcy5jcmVhdGUgMzIgaW5cbiAgZm9yIGkgPSAwIHRvIDE1IGRvXG4gICAgbGV0IHggPSBDaGFyLmNvZGUgZC5baV0gaW5cbiAgICBCeXRlcy51bnNhZmVfc2V0IHJlc3VsdCAoaSoyKSAoY2hhcl9oZXggKHggbHNyIDQpKTtcbiAgICBCeXRlcy51bnNhZmVfc2V0IHJlc3VsdCAoaSoyKzEpIChjaGFyX2hleCAoeCBsYW5kIDB4MGYpKTtcbiAgZG9uZTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXN1bHRcblxubGV0IGZyb21faGV4IHMgPVxuICBpZiBTdHJpbmcubGVuZ3RoIHMgPD4gMzIgdGhlbiBpbnZhbGlkX2FyZyBcIkRpZ2VzdC5mcm9tX2hleFwiO1xuICBsZXQgZGlnaXQgYyA9XG4gICAgbWF0Y2ggYyB3aXRoXG4gICAgfCAnMCcuLic5JyAtPiBDaGFyLmNvZGUgYyAtIENoYXIuY29kZSAnMCdcbiAgICB8ICdBJy4uJ0YnIC0+IENoYXIuY29kZSBjIC0gQ2hhci5jb2RlICdBJyArIDEwXG4gICAgfCAnYScuLidmJyAtPiBDaGFyLmNvZGUgYyAtIENoYXIuY29kZSAnYScgKyAxMFxuICAgIHwgXyAtPiByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcIkRpZ2VzdC5mcm9tX2hleFwiKVxuICBpblxuICBsZXQgYnl0ZSBpID0gZGlnaXQgcy5baV0gbHNsIDQgKyBkaWdpdCBzLltpKzFdIGluXG4gIGxldCByZXN1bHQgPSBCeXRlcy5jcmVhdGUgMTYgaW5cbiAgZm9yIGkgPSAwIHRvIDE1IGRvXG4gICAgQnl0ZXMuc2V0IHJlc3VsdCBpIChDaGFyLmNociAoYnl0ZSAoMiAqIGkpKSk7XG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzdWx0XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFBzZXVkby1yYW5kb20gbnVtYmVyIGdlbmVyYXRvclxuICAgVGhpcyBpcyBhIGxhZ2dlZC1GaWJvbmFjY2kgRig1NSwgMjQsICspIHdpdGggYSBtb2RpZmllZCBhZGRpdGlvblxuICAgZnVuY3Rpb24gdG8gZW5oYW5jZSB0aGUgbWl4aW5nIG9mIGJpdHMuXG4gICBJZiB3ZSB1c2Ugbm9ybWFsIGFkZGl0aW9uLCB0aGUgbG93LW9yZGVyIGJpdCBmYWlscyB0ZXN0cyAxIGFuZCA3XG4gICBvZiB0aGUgRGllaGFyZCB0ZXN0IHN1aXRlLCBhbmQgYml0cyAxIGFuZCAyIGFsc28gZmFpbCB0ZXN0IDcuXG4gICBJZiB3ZSB1c2UgbXVsdGlwbGljYXRpb24gYXMgc3VnZ2VzdGVkIGJ5IE1hcnNhZ2xpYSwgaXQgZG9lc24ndCBmYXJlXG4gICBtdWNoIGJldHRlci5cbiAgIEJ5IG1peGluZyB0aGUgYml0cyBvZiBvbmUgb2YgdGhlIG51bWJlcnMgYmVmb3JlIGFkZGl0aW9uIChYT1IgdGhlXG4gICA1IGhpZ2gtb3JkZXIgYml0cyBpbnRvIHRoZSBsb3ctb3JkZXIgYml0cyksIHdlIGdldCBhIGdlbmVyYXRvciB0aGF0XG4gICBwYXNzZXMgYWxsIHRoZSBEaWVoYXJkIHRlc3RzLlxuKilcblxuZXh0ZXJuYWwgcmFuZG9tX3NlZWQ6IHVuaXQgLT4gaW50IGFycmF5ID0gXCJjYW1sX3N5c19yYW5kb21fc2VlZFwiXG5cbm1vZHVsZSBTdGF0ZSA9IHN0cnVjdFxuXG4gIHR5cGUgdCA9IHsgc3QgOiBpbnQgYXJyYXk7IG11dGFibGUgaWR4IDogaW50IH1cblxuICBsZXQgbmV3X3N0YXRlICgpID0geyBzdCA9IEFycmF5Lm1ha2UgNTUgMDsgaWR4ID0gMCB9XG4gIGxldCBhc3NpZ24gc3QxIHN0MiA9XG4gICAgQXJyYXkuYmxpdCBzdDIuc3QgMCBzdDEuc3QgMCA1NTtcbiAgICBzdDEuaWR4IDwtIHN0Mi5pZHhcblxuXG4gIGxldCBmdWxsX2luaXQgcyBzZWVkID1cbiAgICBsZXQgY29tYmluZSBhY2N1IHggPSBEaWdlc3Quc3RyaW5nIChhY2N1IF4gc3RyaW5nX29mX2ludCB4KSBpblxuICAgIGxldCBleHRyYWN0IGQgPVxuICAgICAgQ2hhci5jb2RlIGQuWzBdICsgKENoYXIuY29kZSBkLlsxXSBsc2wgOCkgKyAoQ2hhci5jb2RlIGQuWzJdIGxzbCAxNilcbiAgICAgICsgKENoYXIuY29kZSBkLlszXSBsc2wgMjQpXG4gICAgaW5cbiAgICBsZXQgc2VlZCA9IGlmIEFycmF5Lmxlbmd0aCBzZWVkID0gMCB0aGVuIFt8IDAgfF0gZWxzZSBzZWVkIGluXG4gICAgbGV0IGwgPSBBcnJheS5sZW5ndGggc2VlZCBpblxuICAgIGZvciBpID0gMCB0byA1NCBkb1xuICAgICAgcy5zdC4oaSkgPC0gaTtcbiAgICBkb25lO1xuICAgIGxldCBhY2N1ID0gcmVmIFwieFwiIGluXG4gICAgZm9yIGkgPSAwIHRvIDU0ICsgbWF4IDU1IGwgZG9cbiAgICAgIGxldCBqID0gaSBtb2QgNTUgaW5cbiAgICAgIGxldCBrID0gaSBtb2QgbCBpblxuICAgICAgYWNjdSA6PSBjb21iaW5lICFhY2N1IHNlZWQuKGspO1xuICAgICAgcy5zdC4oaikgPC0gKHMuc3QuKGopIGx4b3IgZXh0cmFjdCAhYWNjdSkgbGFuZCAweDNGRkZGRkZGOyAgKCogUFIjNTU3NSAqKVxuICAgIGRvbmU7XG4gICAgcy5pZHggPC0gMFxuXG5cbiAgbGV0IG1ha2Ugc2VlZCA9XG4gICAgbGV0IHJlc3VsdCA9IG5ld19zdGF0ZSAoKSBpblxuICAgIGZ1bGxfaW5pdCByZXN1bHQgc2VlZDtcbiAgICByZXN1bHRcblxuXG4gIGxldCBtYWtlX3NlbGZfaW5pdCAoKSA9IG1ha2UgKHJhbmRvbV9zZWVkICgpKVxuXG4gIGxldCBjb3B5IHMgPVxuICAgIGxldCByZXN1bHQgPSBuZXdfc3RhdGUgKCkgaW5cbiAgICBhc3NpZ24gcmVzdWx0IHM7XG4gICAgcmVzdWx0XG5cblxuICAoKiBSZXR1cm5zIDMwIHJhbmRvbSBiaXRzIGFzIGFuIGludGVnZXIgMCA8PSB4IDwgMTA3Mzc0MTgyNCAqKVxuICBsZXQgYml0cyBzID1cbiAgICBzLmlkeCA8LSAocy5pZHggKyAxKSBtb2QgNTU7XG4gICAgbGV0IGN1cnZhbCA9IHMuc3QuKHMuaWR4KSBpblxuICAgIGxldCBuZXd2YWwgPSBzLnN0Ligocy5pZHggKyAyNCkgbW9kIDU1KVxuICAgICAgICAgICAgICAgICArIChjdXJ2YWwgbHhvciAoKGN1cnZhbCBsc3IgMjUpIGxhbmQgMHgxRikpIGluXG4gICAgbGV0IG5ld3ZhbDMwID0gbmV3dmFsIGxhbmQgMHgzRkZGRkZGRiBpbiAgKCogUFIjNTU3NSAqKVxuICAgIHMuc3QuKHMuaWR4KSA8LSBuZXd2YWwzMDtcbiAgICBuZXd2YWwzMFxuXG5cbiAgbGV0IHJlYyBpbnRhdXggcyBuID1cbiAgICBsZXQgciA9IGJpdHMgcyBpblxuICAgIGxldCB2ID0gciBtb2QgbiBpblxuICAgIGlmIHIgLSB2ID4gMHgzRkZGRkZGRiAtIG4gKyAxIHRoZW4gaW50YXV4IHMgbiBlbHNlIHZcblxuICBsZXQgaW50IHMgYm91bmQgPVxuICAgIGlmIGJvdW5kID4gMHgzRkZGRkZGRiB8fCBib3VuZCA8PSAwXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIlJhbmRvbS5pbnRcIlxuICAgIGVsc2UgaW50YXV4IHMgYm91bmRcblxuXG4gIGxldCByZWMgaW50MzJhdXggcyBuID1cbiAgICBsZXQgYjEgPSBJbnQzMi5vZl9pbnQgKGJpdHMgcykgaW5cbiAgICBsZXQgYjIgPSBJbnQzMi5zaGlmdF9sZWZ0IChJbnQzMi5vZl9pbnQgKGJpdHMgcyBsYW5kIDEpKSAzMCBpblxuICAgIGxldCByID0gSW50MzIubG9nb3IgYjEgYjIgaW5cbiAgICBsZXQgdiA9IEludDMyLnJlbSByIG4gaW5cbiAgICBpZiBJbnQzMi5zdWIgciB2ID4gSW50MzIuYWRkIChJbnQzMi5zdWIgSW50MzIubWF4X2ludCBuKSAxbFxuICAgIHRoZW4gaW50MzJhdXggcyBuXG4gICAgZWxzZSB2XG5cbiAgbGV0IGludDMyIHMgYm91bmQgPVxuICAgIGlmIGJvdW5kIDw9IDBsXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIlJhbmRvbS5pbnQzMlwiXG4gICAgZWxzZSBpbnQzMmF1eCBzIGJvdW5kXG5cblxuICBsZXQgcmVjIGludDY0YXV4IHMgbiA9XG4gICAgbGV0IGIxID0gSW50NjQub2ZfaW50IChiaXRzIHMpIGluXG4gICAgbGV0IGIyID0gSW50NjQuc2hpZnRfbGVmdCAoSW50NjQub2ZfaW50IChiaXRzIHMpKSAzMCBpblxuICAgIGxldCBiMyA9IEludDY0LnNoaWZ0X2xlZnQgKEludDY0Lm9mX2ludCAoYml0cyBzIGxhbmQgNykpIDYwIGluXG4gICAgbGV0IHIgPSBJbnQ2NC5sb2dvciBiMSAoSW50NjQubG9nb3IgYjIgYjMpIGluXG4gICAgbGV0IHYgPSBJbnQ2NC5yZW0gciBuIGluXG4gICAgaWYgSW50NjQuc3ViIHIgdiA+IEludDY0LmFkZCAoSW50NjQuc3ViIEludDY0Lm1heF9pbnQgbikgMUxcbiAgICB0aGVuIGludDY0YXV4IHMgblxuICAgIGVsc2UgdlxuXG4gIGxldCBpbnQ2NCBzIGJvdW5kID1cbiAgICBpZiBib3VuZCA8PSAwTFxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJSYW5kb20uaW50NjRcIlxuICAgIGVsc2UgaW50NjRhdXggcyBib3VuZFxuXG5cbiAgbGV0IG5hdGl2ZWludCA9XG4gICAgaWYgTmF0aXZlaW50LnNpemUgPSAzMlxuICAgIHRoZW4gZnVuIHMgYm91bmQgLT4gTmF0aXZlaW50Lm9mX2ludDMyIChpbnQzMiBzIChOYXRpdmVpbnQudG9faW50MzIgYm91bmQpKVxuICAgIGVsc2UgZnVuIHMgYm91bmQgLT4gSW50NjQudG9fbmF0aXZlaW50IChpbnQ2NCBzIChJbnQ2NC5vZl9uYXRpdmVpbnQgYm91bmQpKVxuXG5cbiAgKCogUmV0dXJucyBhIGZsb2F0IDAgPD0geCA8PSAxIHdpdGggYXQgbW9zdCA2MCBiaXRzIG9mIHByZWNpc2lvbi4gKilcbiAgbGV0IHJhd2Zsb2F0IHMgPVxuICAgIGxldCBzY2FsZSA9IDEwNzM3NDE4MjQuMCAgKCogMl4zMCAqKVxuICAgIGFuZCByMSA9IFBlcnZhc2l2ZXMuZmxvYXQgKGJpdHMgcylcbiAgICBhbmQgcjIgPSBQZXJ2YXNpdmVzLmZsb2F0IChiaXRzIHMpXG4gICAgaW4gKHIxIC8uIHNjYWxlICsuIHIyKSAvLiBzY2FsZVxuXG5cbiAgbGV0IGZsb2F0IHMgYm91bmQgPSByYXdmbG9hdCBzICouIGJvdW5kXG5cbiAgbGV0IGJvb2wgcyA9IChiaXRzIHMgbGFuZCAxID0gMClcblxuZW5kXG5cbigqIFRoaXMgaXMgdGhlIHN0YXRlIHlvdSBnZXQgd2l0aCBbaW5pdCAyNzE4MjgxOF0gYW5kIHRoZW4gYXBwbHlpbmdcbiAgIHRoZSBcImxhbmQgMHgzRkZGRkZGRlwiIGZpbHRlciB0byB0aGVtLiAgU2VlICM1NTc1LCAjNTc5MywgIzU5NzcuICopXG5sZXQgZGVmYXVsdCA9IHtcbiAgU3RhdGUuc3QgPSBbfFxuICAgICAgMHgzYWUyNTIyYjsgMHgxZDhkNDYzNDsgMHgxNWI0ZmFkMDsgMHgxOGIxNGFjZTsgMHgxMmY4YTNjNDsgMHgzYjA4NmM0NztcbiAgICAgIDB4MTZkNDY3ZDY7IDB4MTAxZDkxYzc7IDB4MzIxZGYxNzc7IDB4MDE3NmMxOTM7IDB4MWZmNzJiZjE7IDB4MWU4ODkxMDk7XG4gICAgICAweDBiNDY0YjE4OyAweDJiODZiOTdjOyAweDA4OTFkYTQ4OyAweDAzMTM3NDYzOyAweDA4NWFjNWExOyAweDE1ZDYxZjJmO1xuICAgICAgMHgzYmNlZDM1OTsgMHgyOWMxYzEzMjsgMHgzYTg2NzY2ZTsgMHgzNjZkOGM4NjsgMHgxZjViNjIyMjsgMHgzY2UxYjU5ZjtcbiAgICAgIDB4MmViZjc4ZTE7IDB4MjdjZDFiODY7IDB4MjU4ZjNkYzM7IDB4Mzg5YTgxOTQ7IDB4MDJlNGM0NGM7IDB4MThjNDNmN2Q7XG4gICAgICAweDBmNmU1MzRmOyAweDFlN2RmMzU5OyAweDA1NWQwYjdlOyAweDEwZTg0ZTdlOyAweDEyNjE5OGU0OyAweDBlNzcyMmNiO1xuICAgICAgMHgxY2JlZGUyODsgMHgzMzkxYjk2NDsgMHgzZDQwZTkyYTsgMHgwYzU5OTMzZDsgMHgwYjhjZDBiNzsgMHgyNGVmZmYxYztcbiAgICAgIDB4MjgwM2ZkYWE7IDB4MDhlYmM3MmU7IDB4MGY1MjJlMzI7IDB4MDUzOThlZGM7IDB4MjE0NGEwNGM7IDB4MGFlZjNjYmQ7XG4gICAgICAweDAxYWQ0NzE5OyAweDM1YjkzY2Q2OyAweDJhNTU5ZDRmOyAweDFlNmZkNzY4OyAweDI2ZTI3ZjM2OyAweDE4NmYxOGMzO1xuICAgICAgMHgyZmJmOTY3YTtcbiAgICB8XTtcbiAgU3RhdGUuaWR4ID0gMDtcbn1cblxubGV0IGJpdHMgKCkgPSBTdGF0ZS5iaXRzIGRlZmF1bHRcbmxldCBpbnQgYm91bmQgPSBTdGF0ZS5pbnQgZGVmYXVsdCBib3VuZFxubGV0IGludDMyIGJvdW5kID0gU3RhdGUuaW50MzIgZGVmYXVsdCBib3VuZFxubGV0IG5hdGl2ZWludCBib3VuZCA9IFN0YXRlLm5hdGl2ZWludCBkZWZhdWx0IGJvdW5kXG5sZXQgaW50NjQgYm91bmQgPSBTdGF0ZS5pbnQ2NCBkZWZhdWx0IGJvdW5kXG5sZXQgZmxvYXQgc2NhbGUgPSBTdGF0ZS5mbG9hdCBkZWZhdWx0IHNjYWxlXG5sZXQgYm9vbCAoKSA9IFN0YXRlLmJvb2wgZGVmYXVsdFxuXG5sZXQgZnVsbF9pbml0IHNlZWQgPSBTdGF0ZS5mdWxsX2luaXQgZGVmYXVsdCBzZWVkXG5sZXQgaW5pdCBzZWVkID0gU3RhdGUuZnVsbF9pbml0IGRlZmF1bHQgW3wgc2VlZCB8XVxubGV0IHNlbGZfaW5pdCAoKSA9IGZ1bGxfaW5pdCAocmFuZG9tX3NlZWQoKSlcblxuKCogTWFuaXB1bGF0aW5nIHRoZSBjdXJyZW50IHN0YXRlLiAqKVxuXG5sZXQgZ2V0X3N0YXRlICgpID0gU3RhdGUuY29weSBkZWZhdWx0XG5sZXQgc2V0X3N0YXRlIHMgPSBTdGF0ZS5hc3NpZ24gZGVmYXVsdCBzXG5cbigqKioqKioqKioqKioqKioqKioqKlxuXG4oKiBUZXN0IGZ1bmN0aW9ucy4gIE5vdCBpbmNsdWRlZCBpbiB0aGUgbGlicmFyeS5cbiAgIFRoZSBbY2hpc3F1YXJlXSBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkIHdpdGggbiA+IDEwci5cbiAgIEl0IHJldHVybnMgYSB0cmlwbGUgKGxvdywgYWN0dWFsLCBoaWdoKS5cbiAgIElmIGxvdyA8PSBhY3R1YWwgPD0gaGlnaCwgdGhlIFtnXSBmdW5jdGlvbiBwYXNzZWQgdGhlIHRlc3QsXG4gICBvdGhlcndpc2UgaXQgZmFpbGVkLlxuXG4gIFNvbWUgcmVzdWx0czpcblxuaW5pdCAyNzE4MjgxODsgY2hpc3F1YXJlIGludCAxMDAwMDAgMTAwMFxuaW5pdCAyNzE4MjgxODsgY2hpc3F1YXJlIGludCAxMDAwMDAgMTAwXG5pbml0IDI3MTgyODE4OyBjaGlzcXVhcmUgaW50IDEwMDAwMCA1MDAwXG5pbml0IDI3MTgyODE4OyBjaGlzcXVhcmUgaW50IDEwMDAwMDAgMTAwMFxuaW5pdCAyNzE4MjgxODsgY2hpc3F1YXJlIGludCAxMDAwMDAgMTAyNFxuaW5pdCAyOTk3OTI2NDM7IGNoaXNxdWFyZSBpbnQgMTAwMDAwIDEwMjRcbmluaXQgMTQxNDIxMzY7IGNoaXNxdWFyZSBpbnQgMTAwMDAwIDEwMjRcbmluaXQgMjcxODI4MTg7IGluaXRfZGlmZiAxMDI0OyBjaGlzcXVhcmUgZGlmZiAxMDAwMDAgMTAyNFxuaW5pdCAyNzE4MjgxODsgaW5pdF9kaWZmIDEwMDsgY2hpc3F1YXJlIGRpZmYgMTAwMDAwIDEwMFxuaW5pdCAyNzE4MjgxODsgaW5pdF9kaWZmMiAxMDI0OyBjaGlzcXVhcmUgZGlmZjIgMTAwMDAwIDEwMjRcbmluaXQgMjcxODI4MTg7IGluaXRfZGlmZjIgMTAwOyBjaGlzcXVhcmUgZGlmZjIgMTAwMDAwIDEwMFxuaW5pdCAxNDE0MjEzNjsgaW5pdF9kaWZmMiAxMDA7IGNoaXNxdWFyZSBkaWZmMiAxMDAwMDAgMTAwXG5pbml0IDI5OTc5MjY0MzsgaW5pdF9kaWZmMiAxMDA7IGNoaXNxdWFyZSBkaWZmMiAxMDAwMDAgMTAwXG4tIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDkzNi43NTQ0NDY3OTY2MzI0NjUsIDk5Ny41LCAxMDYzLjI0NTU1MzIwMzM2NzU0KVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDgwLiwgODkuNzQwMDAwMDAwMDA1MjM4NywgMTIwLilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg0ODU4LjU3ODY0Mzc2MjY5LCA1MDQ1LjUsIDUxNDEuNDIxMzU2MjM3MzEpXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPVxuKDkzNi43NTQ0NDY3OTY2MzI0NjUsIDk0NC44MDU5OTk5OTk5ODIzMDUsIDEwNjMuMjQ1NTUzMjAzMzY3NTQpXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTYwLiwgMTAxOS4xOTc0NDAwMDAwMDM1NSwgMTA4OC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTYwLiwgMTA1OS4zMTc3NjAwMDAwMDUzNiwgMTA4OC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTYwLiwgMTAzOS45ODQ2Mzk5OTk5OTUxMiwgMTA4OC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTYwLiwgMTA1NC4zODIwNzk5OTk5OTU3NywgMTA4OC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoODAuLCA5MC4wOTYwMDAwMDAwMDUsIDEyMC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTYwLiwgMTA3Ni43ODcyMDAwMDAwMDYxMiwgMTA4OC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoODAuLCA4NS4xNzYwMDAwMDAwMDY3NTIxLCAxMjAuKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDgwLiwgODUuMjE2MDAwMDAwMDAwMzQ5MiwgMTIwLilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg4MC4sIDgwLjYyMjAwMDAwMDAwMzAyNjgsIDEyMC4pXG5cbiopXG5cbigqIFJldHVybiB0aGUgc3VtIG9mIHRoZSBzcXVhcmVzIG9mIHZbaTAsaTFbICopXG5sZXQgcmVjIHN1bXNxIHYgaTAgaTEgPVxuICBpZiBpMCA+PSBpMSB0aGVuIDAuMFxuICBlbHNlIGlmIGkxID0gaTAgKyAxIHRoZW4gUGVydmFzaXZlcy5mbG9hdCB2LihpMCkgKi4gUGVydmFzaXZlcy5mbG9hdCB2LihpMClcbiAgZWxzZSBzdW1zcSB2IGkwICgoaTAraTEpLzIpICsuIHN1bXNxIHYgKChpMCtpMSkvMikgaTFcblxuXG5sZXQgY2hpc3F1YXJlIGcgbiByID1cbiAgaWYgbiA8PSAxMCAqIHIgdGhlbiBpbnZhbGlkX2FyZyBcImNoaXNxdWFyZVwiO1xuICBsZXQgZiA9IEFycmF5Lm1ha2UgciAwIGluXG4gIGZvciBpID0gMSB0byBuIGRvXG4gICAgbGV0IHQgPSBnIHIgaW5cbiAgICBmLih0KSA8LSBmLih0KSArIDFcbiAgZG9uZTtcbiAgbGV0IHQgPSBzdW1zcSBmIDAgclxuICBhbmQgciA9IFBlcnZhc2l2ZXMuZmxvYXQgclxuICBhbmQgbiA9IFBlcnZhc2l2ZXMuZmxvYXQgbiBpblxuICBsZXQgc3IgPSAyLjAgKi4gc3FydCByIGluXG4gIChyIC0uIHNyLCAgIChyICouIHQgLy4gbikgLS4gbiwgICByICsuIHNyKVxuXG5cbigqIFRoaXMgaXMgdG8gdGVzdCBmb3IgbGluZWFyIGRlcGVuZGVuY2llcyBiZXR3ZWVuIHN1Y2Nlc3NpdmUgcmFuZG9tIG51bWJlcnMuXG4qKVxubGV0IHN0ID0gcmVmIDBcbmxldCBpbml0X2RpZmYgciA9IHN0IDo9IGludCByXG5sZXQgZGlmZiByID1cbiAgbGV0IHgxID0gIXN0XG4gIGFuZCB4MiA9IGludCByXG4gIGluXG4gIHN0IDo9IHgyO1xuICBpZiB4MSA+PSB4MiB0aGVuXG4gICAgeDEgLSB4MlxuICBlbHNlXG4gICAgciArIHgxIC0geDJcblxuXG5sZXQgc3QxID0gcmVmIDBcbmFuZCBzdDIgPSByZWYgMFxuXG5cbigqIFRoaXMgaXMgdG8gdGVzdCBmb3IgcXVhZHJhdGljIGRlcGVuZGVuY2llcyBiZXR3ZWVuIHN1Y2Nlc3NpdmUgcmFuZG9tXG4gICBudW1iZXJzLlxuKilcbmxldCBpbml0X2RpZmYyIHIgPSBzdDEgOj0gaW50IHI7IHN0MiA6PSBpbnQgclxubGV0IGRpZmYyIHIgPVxuICBsZXQgeDEgPSAhc3QxXG4gIGFuZCB4MiA9ICFzdDJcbiAgYW5kIHgzID0gaW50IHJcbiAgaW5cbiAgc3QxIDo9IHgyO1xuICBzdDIgOj0geDM7XG4gICh4MyAtIHgyIC0geDIgKyB4MSArIDIqcikgbW9kIHJcblxuXG4qKioqKioqKioqKioqKioqKioqKilcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogSGFzaCB0YWJsZXMgKilcblxuZXh0ZXJuYWwgc2VlZGVkX2hhc2hfcGFyYW0gOlxuICBpbnQgLT4gaW50IC0+IGludCAtPiAnYSAtPiBpbnQgPSBcImNhbWxfaGFzaFwiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBvbGRfaGFzaF9wYXJhbSA6XG4gIGludCAtPiBpbnQgLT4gJ2EgLT4gaW50ID0gXCJjYW1sX2hhc2hfdW5pdl9wYXJhbVwiIFtAQG5vYWxsb2NdXG5cbmxldCBoYXNoIHggPSBzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgMCB4XG5sZXQgaGFzaF9wYXJhbSBuMSBuMiB4ID0gc2VlZGVkX2hhc2hfcGFyYW0gbjEgbjIgMCB4XG5sZXQgc2VlZGVkX2hhc2ggc2VlZCB4ID0gc2VlZGVkX2hhc2hfcGFyYW0gMTAgMTAwIHNlZWQgeFxuXG4oKiBXZSBkbyBkeW5hbWljIGhhc2hpbmcsIGFuZCByZXNpemUgdGhlIHRhYmxlIGFuZCByZWhhc2ggdGhlIGVsZW1lbnRzXG4gICB3aGVuIGJ1Y2tldHMgYmVjb21lIHRvbyBsb25nLiAqKVxuXG50eXBlICgnYSwgJ2IpIHQgPVxuICB7IG11dGFibGUgc2l6ZTogaW50OyAgICAgICAgICAgICAgICAgICAgICAgICgqIG51bWJlciBvZiBlbnRyaWVzICopXG4gICAgbXV0YWJsZSBkYXRhOiAoJ2EsICdiKSBidWNrZXRsaXN0IGFycmF5OyAgKCogdGhlIGJ1Y2tldHMgKilcbiAgICBtdXRhYmxlIHNlZWQ6IGludDsgICAgICAgICAgICAgICAgICAgICAgICAoKiBmb3IgcmFuZG9taXphdGlvbiAqKVxuICAgIG11dGFibGUgaW5pdGlhbF9zaXplOiBpbnQ7ICAgICAgICAgICAgICAgICgqIGluaXRpYWwgYXJyYXkgc2l6ZSAqKVxuICB9XG5cbmFuZCAoJ2EsICdiKSBidWNrZXRsaXN0ID1cbiAgICBFbXB0eVxuICB8IENvbnMgb2YgeyBtdXRhYmxlIGtleTogJ2E7XG4gICAgICAgICAgICAgIG11dGFibGUgZGF0YTogJ2I7XG4gICAgICAgICAgICAgIG11dGFibGUgbmV4dDogKCdhLCAnYikgYnVja2V0bGlzdCB9XG5cbigqIFRoZSBzaWduIG9mIGluaXRpYWxfc2l6ZSBlbmNvZGVzIHRoZSBmYWN0IHRoYXQgYSB0cmF2ZXJzYWwgaXNcbiAgIG9uZ29pbmcgb3Igbm90LlxuXG4gICBUaGlzIGRpc2FibGVzIHRoZSBlZmZpY2llbnQgaW4gcGxhY2UgaW1wbGVtZW50YXRpb24gb2YgcmVzaXppbmcuXG4qKVxuXG5sZXQgb25nb2luZ190cmF2ZXJzYWwgaCA9XG4gIE9iai5zaXplIChPYmoucmVwciBoKSA8IDQgKCogY29tcGF0aWJpbGl0eSB3aXRoIG9sZCBoYXNoIHRhYmxlcyAqKVxuICB8fCBoLmluaXRpYWxfc2l6ZSA8IDBcblxubGV0IGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaCA9XG4gIGguaW5pdGlhbF9zaXplIDwtIC0gaC5pbml0aWFsX3NpemVcblxuKCogVG8gcGljayByYW5kb20gc2VlZHMgaWYgcmVxdWVzdGVkICopXG5cbmxldCByYW5kb21pemVkX2RlZmF1bHQgPVxuICBsZXQgcGFyYW1zID1cbiAgICB0cnkgU3lzLmdldGVudiBcIk9DQU1MUlVOUEFSQU1cIiB3aXRoIE5vdF9mb3VuZCAtPlxuICAgIHRyeSBTeXMuZ2V0ZW52IFwiQ0FNTFJVTlBBUkFNXCIgd2l0aCBOb3RfZm91bmQgLT4gXCJcIiBpblxuICBTdHJpbmcuY29udGFpbnMgcGFyYW1zICdSJ1xuXG5sZXQgcmFuZG9taXplZCA9IHJlZiByYW5kb21pemVkX2RlZmF1bHRcblxubGV0IHJhbmRvbWl6ZSAoKSA9IHJhbmRvbWl6ZWQgOj0gdHJ1ZVxubGV0IGlzX3JhbmRvbWl6ZWQgKCkgPSAhcmFuZG9taXplZFxuXG5sZXQgcHJuZyA9IGxhenkgKFJhbmRvbS5TdGF0ZS5tYWtlX3NlbGZfaW5pdCgpKVxuXG4oKiBDcmVhdGluZyBhIGZyZXNoLCBlbXB0eSB0YWJsZSAqKVxuXG5sZXQgcmVjIHBvd2VyXzJfYWJvdmUgeCBuID1cbiAgaWYgeCA+PSBuIHRoZW4geFxuICBlbHNlIGlmIHggKiAyID4gU3lzLm1heF9hcnJheV9sZW5ndGggdGhlbiB4XG4gIGVsc2UgcG93ZXJfMl9hYm92ZSAoeCAqIDIpIG5cblxubGV0IGNyZWF0ZSA/KHJhbmRvbSA9ICFyYW5kb21pemVkKSBpbml0aWFsX3NpemUgPVxuICBsZXQgcyA9IHBvd2VyXzJfYWJvdmUgMTYgaW5pdGlhbF9zaXplIGluXG4gIGxldCBzZWVkID0gaWYgcmFuZG9tIHRoZW4gUmFuZG9tLlN0YXRlLmJpdHMgKExhenkuZm9yY2UgcHJuZykgZWxzZSAwIGluXG4gIHsgaW5pdGlhbF9zaXplID0gczsgc2l6ZSA9IDA7IHNlZWQgPSBzZWVkOyBkYXRhID0gQXJyYXkubWFrZSBzIEVtcHR5IH1cblxubGV0IGNsZWFyIGggPVxuICBoLnNpemUgPC0gMDtcbiAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBoLmRhdGEgaW5cbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICBoLmRhdGEuKGkpIDwtIEVtcHR5XG4gIGRvbmVcblxubGV0IHJlc2V0IGggPVxuICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIGguZGF0YSBpblxuICBpZiBPYmouc2l6ZSAoT2JqLnJlcHIgaCkgPCA0ICgqIGNvbXBhdGliaWxpdHkgd2l0aCBvbGQgaGFzaCB0YWJsZXMgKilcbiAgICB8fCBsZW4gPSBhYnMgaC5pbml0aWFsX3NpemUgdGhlblxuICAgIGNsZWFyIGhcbiAgZWxzZSBiZWdpblxuICAgIGguc2l6ZSA8LSAwO1xuICAgIGguZGF0YSA8LSBBcnJheS5tYWtlIChhYnMgaC5pbml0aWFsX3NpemUpIEVtcHR5XG4gIGVuZFxuXG5sZXQgY29weV9idWNrZXRsaXN0ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPiBFbXB0eVxuICB8IENvbnMge2tleTsgZGF0YTsgbmV4dH0gLT5cbiAgICAgIGxldCByZWMgbG9vcCBwcmVjID0gZnVuY3Rpb25cbiAgICAgICAgfCBFbXB0eSAtPiAoKVxuICAgICAgICB8IENvbnMge2tleTsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgICAgIGxldCByID0gQ29ucyB7a2V5OyBkYXRhOyBuZXh0fSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggcHJlYyB3aXRoXG4gICAgICAgICAgICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgICAgfCBDb25zIHByZWMgLT4gIHByZWMubmV4dCA8LSByXG4gICAgICAgICAgICBlbmQ7XG4gICAgICAgICAgICBsb29wIHIgbmV4dFxuICAgICAgaW5cbiAgICAgIGxldCByID0gQ29ucyB7a2V5OyBkYXRhOyBuZXh0fSBpblxuICAgICAgbG9vcCByIG5leHQ7XG4gICAgICByXG5cbmxldCBjb3B5IGggPSB7IGggd2l0aCBkYXRhID0gQXJyYXkubWFwIGNvcHlfYnVja2V0bGlzdCBoLmRhdGEgfVxuXG5sZXQgbGVuZ3RoIGggPSBoLnNpemVcblxubGV0IHJlc2l6ZSBpbmRleGZ1biBoID1cbiAgbGV0IG9kYXRhID0gaC5kYXRhIGluXG4gIGxldCBvc2l6ZSA9IEFycmF5Lmxlbmd0aCBvZGF0YSBpblxuICBsZXQgbnNpemUgPSBvc2l6ZSAqIDIgaW5cbiAgaWYgbnNpemUgPCBTeXMubWF4X2FycmF5X2xlbmd0aCB0aGVuIGJlZ2luXG4gICAgbGV0IG5kYXRhID0gQXJyYXkubWFrZSBuc2l6ZSBFbXB0eSBpblxuICAgIGxldCBuZGF0YV90YWlsID0gQXJyYXkubWFrZSBuc2l6ZSBFbXB0eSBpblxuICAgIGxldCBpbnBsYWNlID0gbm90IChvbmdvaW5nX3RyYXZlcnNhbCBoKSBpblxuICAgIGguZGF0YSA8LSBuZGF0YTsgICAgICAgICAgKCogc28gdGhhdCBpbmRleGZ1biBzZWVzIHRoZSBuZXcgYnVja2V0IGNvdW50ICopXG4gICAgbGV0IHJlYyBpbnNlcnRfYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gKClcbiAgICAgIHwgQ29ucyB7a2V5OyBkYXRhOyBuZXh0fSBhcyBjZWxsIC0+XG4gICAgICAgICAgbGV0IGNlbGwgPVxuICAgICAgICAgICAgaWYgaW5wbGFjZSB0aGVuIGNlbGxcbiAgICAgICAgICAgIGVsc2UgQ29ucyB7a2V5OyBkYXRhOyBuZXh0ID0gRW1wdHl9XG4gICAgICAgICAgaW5cbiAgICAgICAgICBsZXQgbmlkeCA9IGluZGV4ZnVuIGgga2V5IGluXG4gICAgICAgICAgYmVnaW4gbWF0Y2ggbmRhdGFfdGFpbC4obmlkeCkgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gbmRhdGEuKG5pZHgpIDwtIGNlbGw7XG4gICAgICAgICAgfCBDb25zIHRhaWwgLT4gdGFpbC5uZXh0IDwtIGNlbGw7XG4gICAgICAgICAgZW5kO1xuICAgICAgICAgIG5kYXRhX3RhaWwuKG5pZHgpIDwtIGNlbGw7XG4gICAgICAgICAgaW5zZXJ0X2J1Y2tldCBuZXh0XG4gICAgaW5cbiAgICBmb3IgaSA9IDAgdG8gb3NpemUgLSAxIGRvXG4gICAgICBpbnNlcnRfYnVja2V0IG9kYXRhLihpKVxuICAgIGRvbmU7XG4gICAgaWYgaW5wbGFjZSB0aGVuXG4gICAgICBmb3IgaSA9IDAgdG8gbnNpemUgLSAxIGRvXG4gICAgICAgIG1hdGNoIG5kYXRhX3RhaWwuKGkpIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiAoKVxuICAgICAgICB8IENvbnMgdGFpbCAtPiB0YWlsLm5leHQgPC0gRW1wdHlcbiAgICAgIGRvbmU7XG4gIGVuZFxuXG5sZXQga2V5X2luZGV4IGgga2V5ID1cbiAgKCogY29tcGF0aWJpbGl0eSB3aXRoIG9sZCBoYXNoIHRhYmxlcyAqKVxuICBpZiBPYmouc2l6ZSAoT2JqLnJlcHIgaCkgPj0gM1xuICB0aGVuIChzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgaC5zZWVkIGtleSkgbGFuZCAoQXJyYXkubGVuZ3RoIGguZGF0YSAtIDEpXG4gIGVsc2UgKG9sZF9oYXNoX3BhcmFtIDEwIDEwMCBrZXkpIG1vZCAoQXJyYXkubGVuZ3RoIGguZGF0YSlcblxubGV0IGFkZCBoIGtleSBkYXRhID1cbiAgbGV0IGkgPSBrZXlfaW5kZXggaCBrZXkgaW5cbiAgbGV0IGJ1Y2tldCA9IENvbnN7a2V5OyBkYXRhOyBuZXh0PWguZGF0YS4oaSl9IGluXG4gIGguZGF0YS4oaSkgPC0gYnVja2V0O1xuICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgaWYgaC5zaXplID4gQXJyYXkubGVuZ3RoIGguZGF0YSBsc2wgMSB0aGVuIHJlc2l6ZSBrZXlfaW5kZXggaFxuXG5sZXQgcmVjIHJlbW92ZV9idWNrZXQgaCBpIGtleSBwcmVjID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgKClcbiAgfCAoQ29ucyB7a2V5PWs7IG5leHR9KSBhcyBjIC0+XG4gICAgICBpZiBjb21wYXJlIGsga2V5ID0gMFxuICAgICAgdGhlbiBiZWdpblxuICAgICAgICBoLnNpemUgPC0gaC5zaXplIC0gMTtcbiAgICAgICAgbWF0Y2ggcHJlYyB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gaC5kYXRhLihpKSA8LSBuZXh0XG4gICAgICAgIHwgQ29ucyBjIC0+IGMubmV4dCA8LSBuZXh0XG4gICAgICBlbmRcbiAgICAgIGVsc2UgcmVtb3ZlX2J1Y2tldCBoIGkga2V5IGMgbmV4dFxuXG5sZXQgcmVtb3ZlIGgga2V5ID1cbiAgbGV0IGkgPSBrZXlfaW5kZXggaCBrZXkgaW5cbiAgcmVtb3ZlX2J1Y2tldCBoIGkga2V5IEVtcHR5IGguZGF0YS4oaSlcblxubGV0IHJlYyBmaW5kX3JlYyBrZXkgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICByYWlzZSBOb3RfZm91bmRcbiAgfCBDb25ze2tleT1rOyBkYXRhOyBuZXh0fSAtPlxuICAgICAgaWYgY29tcGFyZSBrZXkgayA9IDAgdGhlbiBkYXRhIGVsc2UgZmluZF9yZWMga2V5IG5leHRcblxubGV0IGZpbmQgaCBrZXkgPVxuICBtYXRjaCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSkgd2l0aFxuICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICB8IENvbnN7a2V5PWsxOyBkYXRhPWQxOyBuZXh0PW5leHQxfSAtPlxuICAgICAgaWYgY29tcGFyZSBrZXkgazEgPSAwIHRoZW4gZDEgZWxzZVxuICAgICAgbWF0Y2ggbmV4dDEgd2l0aFxuICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgQ29uc3trZXk9azI7IGRhdGE9ZDI7IG5leHQ9bmV4dDJ9IC0+XG4gICAgICAgICAgaWYgY29tcGFyZSBrZXkgazIgPSAwIHRoZW4gZDIgZWxzZVxuICAgICAgICAgIG1hdGNoIG5leHQyIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgICAgIHwgQ29uc3trZXk9azM7IGRhdGE9ZDM7IG5leHQ9bmV4dDN9IC0+XG4gICAgICAgICAgICAgIGlmIGNvbXBhcmUga2V5IGszID0gMCB0aGVuIGQzIGVsc2UgZmluZF9yZWMga2V5IG5leHQzXG5cbmxldCByZWMgZmluZF9yZWNfb3B0IGtleSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIE5vbmVcbiAgfCBDb25ze2tleT1rOyBkYXRhOyBuZXh0fSAtPlxuICAgICAgaWYgY29tcGFyZSBrZXkgayA9IDAgdGhlbiBTb21lIGRhdGEgZWxzZSBmaW5kX3JlY19vcHQga2V5IG5leHRcblxubGV0IGZpbmRfb3B0IGgga2V5ID1cbiAgbWF0Y2ggaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpIHdpdGhcbiAgfCBFbXB0eSAtPiBOb25lXG4gIHwgQ29uc3trZXk9azE7IGRhdGE9ZDE7IG5leHQ9bmV4dDF9IC0+XG4gICAgICBpZiBjb21wYXJlIGtleSBrMSA9IDAgdGhlbiBTb21lIGQxIGVsc2VcbiAgICAgIG1hdGNoIG5leHQxIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBDb25ze2tleT1rMjsgZGF0YT1kMjsgbmV4dD1uZXh0Mn0gLT5cbiAgICAgICAgICBpZiBjb21wYXJlIGtleSBrMiA9IDAgdGhlbiBTb21lIGQyIGVsc2VcbiAgICAgICAgICBtYXRjaCBuZXh0MiB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiBOb25lXG4gICAgICAgICAgfCBDb25ze2tleT1rMzsgZGF0YT1kMzsgbmV4dD1uZXh0M30gLT5cbiAgICAgICAgICAgICAgaWYgY29tcGFyZSBrZXkgazMgPSAwIHRoZW4gU29tZSBkMyBlbHNlIGZpbmRfcmVjX29wdCBrZXkgbmV4dDNcblxubGV0IGZpbmRfYWxsIGgga2V5ID1cbiAgbGV0IHJlYyBmaW5kX2luX2J1Y2tldCA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIFtdXG4gIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgIGlmIGNvbXBhcmUgayBrZXkgPSAwXG4gICAgICB0aGVuIGRhdGEgOjogZmluZF9pbl9idWNrZXQgbmV4dFxuICAgICAgZWxzZSBmaW5kX2luX2J1Y2tldCBuZXh0IGluXG4gIGZpbmRfaW5fYnVja2V0IGguZGF0YS4oa2V5X2luZGV4IGgga2V5KVxuXG5sZXQgcmVjIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgdHJ1ZVxuICB8IENvbnMgKHtrZXk9azsgbmV4dH0gYXMgc2xvdCkgLT5cbiAgICAgIGlmIGNvbXBhcmUgayBrZXkgPSAwXG4gICAgICB0aGVuIChzbG90LmtleSA8LSBrZXk7IHNsb3QuZGF0YSA8LSBkYXRhOyBmYWxzZSlcbiAgICAgIGVsc2UgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgbmV4dFxuXG5sZXQgcmVwbGFjZSBoIGtleSBkYXRhID1cbiAgbGV0IGkgPSBrZXlfaW5kZXggaCBrZXkgaW5cbiAgbGV0IGwgPSBoLmRhdGEuKGkpIGluXG4gIGlmIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhIGwgdGhlbiBiZWdpblxuICAgIGguZGF0YS4oaSkgPC0gQ29uc3trZXk7IGRhdGE7IG5leHQ9bH07XG4gICAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gICAgaWYgaC5zaXplID4gQXJyYXkubGVuZ3RoIGguZGF0YSBsc2wgMSB0aGVuIHJlc2l6ZSBrZXlfaW5kZXggaFxuICBlbmRcblxubGV0IG1lbSBoIGtleSA9XG4gIGxldCByZWMgbWVtX2luX2J1Y2tldCA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIGZhbHNlXG4gIHwgQ29uc3trZXk9azsgbmV4dH0gLT5cbiAgICAgIGNvbXBhcmUgayBrZXkgPSAwIHx8IG1lbV9pbl9idWNrZXQgbmV4dCBpblxuICBtZW1faW5fYnVja2V0IGguZGF0YS4oa2V5X2luZGV4IGgga2V5KVxuXG5sZXQgaXRlciBmIGggPVxuICBsZXQgcmVjIGRvX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPlxuICAgICAgICAoKVxuICAgIHwgQ29uc3trZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgIGYga2V5IGRhdGE7IGRvX2J1Y2tldCBuZXh0IGluXG4gIGxldCBvbGRfdHJhdiA9IG9uZ29pbmdfdHJhdmVyc2FsIGggaW5cbiAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICB0cnlcbiAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgIGRvX2J1Y2tldCBkLihpKVxuICAgIGRvbmU7XG4gICAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICB3aXRoIGV4biB3aGVuIG5vdCBvbGRfdHJhdiAtPlxuICAgIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgICByYWlzZSBleG5cblxubGV0IHJlYyBmaWx0ZXJfbWFwX2lucGxhY2VfYnVja2V0IGYgaCBpIHByZWMgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICBiZWdpbiBtYXRjaCBwcmVjIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gaC5kYXRhLihpKSA8LSBFbXB0eVxuICAgICAgfCBDb25zIGMgLT4gYy5uZXh0IDwtIEVtcHR5XG4gICAgICBlbmRcbiAgfCAoQ29ucyAoe2tleTsgZGF0YTsgbmV4dH0gYXMgYykpIGFzIHNsb3QgLT5cbiAgICAgIGJlZ2luIG1hdGNoIGYga2V5IGRhdGEgd2l0aFxuICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgaC5zaXplIDwtIGguc2l6ZSAtIDE7XG4gICAgICAgICAgZmlsdGVyX21hcF9pbnBsYWNlX2J1Y2tldCBmIGggaSBwcmVjIG5leHRcbiAgICAgIHwgU29tZSBkYXRhIC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggcHJlYyB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiBoLmRhdGEuKGkpIDwtIHNsb3RcbiAgICAgICAgICB8IENvbnMgYyAtPiBjLm5leHQgPC0gc2xvdFxuICAgICAgICAgIGVuZDtcbiAgICAgICAgICBjLmRhdGEgPC0gZGF0YTtcbiAgICAgICAgICBmaWx0ZXJfbWFwX2lucGxhY2VfYnVja2V0IGYgaCBpIHNsb3QgbmV4dFxuICAgICAgZW5kXG5cbmxldCBmaWx0ZXJfbWFwX2lucGxhY2UgZiBoID1cbiAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgbGV0IG9sZF90cmF2ID0gb25nb2luZ190cmF2ZXJzYWwgaCBpblxuICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gIHRyeVxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgIGZpbHRlcl9tYXBfaW5wbGFjZV9idWNrZXQgZiBoIGkgRW1wdHkgaC5kYXRhLihpKVxuICAgIGRvbmVcbiAgd2l0aCBleG4gd2hlbiBub3Qgb2xkX3RyYXYgLT5cbiAgICBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gICAgcmFpc2UgZXhuXG5cbmxldCBmb2xkIGYgaCBpbml0ID1cbiAgbGV0IHJlYyBkb19idWNrZXQgYiBhY2N1ID1cbiAgICBtYXRjaCBiIHdpdGhcbiAgICAgIEVtcHR5IC0+XG4gICAgICAgIGFjY3VcbiAgICB8IENvbnN7a2V5OyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICBkb19idWNrZXQgbmV4dCAoZiBrZXkgZGF0YSBhY2N1KSBpblxuICBsZXQgb2xkX3RyYXYgPSBvbmdvaW5nX3RyYXZlcnNhbCBoIGluXG4gIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgdHJ5XG4gICAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgICBsZXQgYWNjdSA9IHJlZiBpbml0IGluXG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgYWNjdSA6PSBkb19idWNrZXQgZC4oaSkgIWFjY3VcbiAgICBkb25lO1xuICAgIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgICAhYWNjdVxuICB3aXRoIGV4biB3aGVuIG5vdCBvbGRfdHJhdiAtPlxuICAgIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgICByYWlzZSBleG5cblxudHlwZSBzdGF0aXN0aWNzID0ge1xuICBudW1fYmluZGluZ3M6IGludDtcbiAgbnVtX2J1Y2tldHM6IGludDtcbiAgbWF4X2J1Y2tldF9sZW5ndGg6IGludDtcbiAgYnVja2V0X2hpc3RvZ3JhbTogaW50IGFycmF5XG59XG5cbmxldCByZWMgYnVja2V0X2xlbmd0aCBhY2N1ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPiBhY2N1XG4gIHwgQ29uc3tuZXh0fSAtPiBidWNrZXRfbGVuZ3RoIChhY2N1ICsgMSkgbmV4dFxuXG5sZXQgc3RhdHMgaCA9XG4gIGxldCBtYmwgPVxuICAgIEFycmF5LmZvbGRfbGVmdCAoZnVuIG0gYiAtPiBtYXggbSAoYnVja2V0X2xlbmd0aCAwIGIpKSAwIGguZGF0YSBpblxuICBsZXQgaGlzdG8gPSBBcnJheS5tYWtlIChtYmwgKyAxKSAwIGluXG4gIEFycmF5Lml0ZXJcbiAgICAoZnVuIGIgLT5cbiAgICAgIGxldCBsID0gYnVja2V0X2xlbmd0aCAwIGIgaW5cbiAgICAgIGhpc3RvLihsKSA8LSBoaXN0by4obCkgKyAxKVxuICAgIGguZGF0YTtcbiAgeyBudW1fYmluZGluZ3MgPSBoLnNpemU7XG4gICAgbnVtX2J1Y2tldHMgPSBBcnJheS5sZW5ndGggaC5kYXRhO1xuICAgIG1heF9idWNrZXRfbGVuZ3RoID0gbWJsO1xuICAgIGJ1Y2tldF9oaXN0b2dyYW0gPSBoaXN0byB9XG5cbigqIEZ1bmN0b3JpYWwgaW50ZXJmYWNlICopXG5cbm1vZHVsZSB0eXBlIEhhc2hlZFR5cGUgPVxuICBzaWdcbiAgICB0eXBlIHRcbiAgICB2YWwgZXF1YWw6IHQgLT4gdCAtPiBib29sXG4gICAgdmFsIGhhc2g6IHQgLT4gaW50XG4gIGVuZFxuXG5tb2R1bGUgdHlwZSBTZWVkZWRIYXNoZWRUeXBlID1cbiAgc2lnXG4gICAgdHlwZSB0XG4gICAgdmFsIGVxdWFsOiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBoYXNoOiBpbnQgLT4gdCAtPiBpbnRcbiAgZW5kXG5cbm1vZHVsZSB0eXBlIFMgPVxuICBzaWdcbiAgICB0eXBlIGtleVxuICAgIHR5cGUgJ2EgdFxuICAgIHZhbCBjcmVhdGU6IGludCAtPiAnYSB0XG4gICAgdmFsIGNsZWFyIDogJ2EgdCAtPiB1bml0XG4gICAgdmFsIHJlc2V0IDogJ2EgdCAtPiB1bml0XG4gICAgdmFsIGNvcHk6ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBhZGQ6ICdhIHQgLT4ga2V5IC0+ICdhIC0+IHVuaXRcbiAgICB2YWwgcmVtb3ZlOiAnYSB0IC0+IGtleSAtPiB1bml0XG4gICAgdmFsIGZpbmQ6ICdhIHQgLT4ga2V5IC0+ICdhXG4gICAgdmFsIGZpbmRfb3B0OiAnYSB0IC0+IGtleSAtPiAnYSBvcHRpb25cbiAgICB2YWwgZmluZF9hbGw6ICdhIHQgLT4ga2V5IC0+ICdhIGxpc3RcbiAgICB2YWwgcmVwbGFjZSA6ICdhIHQgLT4ga2V5IC0+ICdhIC0+IHVuaXRcbiAgICB2YWwgbWVtIDogJ2EgdCAtPiBrZXkgLT4gYm9vbFxuICAgIHZhbCBpdGVyOiAoa2V5IC0+ICdhIC0+IHVuaXQpIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmaWx0ZXJfbWFwX2lucGxhY2U6IChrZXkgLT4gJ2EgLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgZm9sZDogKGtleSAtPiAnYSAtPiAnYiAtPiAnYikgLT4gJ2EgdCAtPiAnYiAtPiAnYlxuICAgIHZhbCBsZW5ndGg6ICdhIHQgLT4gaW50XG4gICAgdmFsIHN0YXRzOiAnYSB0IC0+IHN0YXRpc3RpY3NcbiAgZW5kXG5cbm1vZHVsZSB0eXBlIFNlZWRlZFMgPVxuICBzaWdcbiAgICB0eXBlIGtleVxuICAgIHR5cGUgJ2EgdFxuICAgIHZhbCBjcmVhdGUgOiA/cmFuZG9tOmJvb2wgLT4gaW50IC0+ICdhIHRcbiAgICB2YWwgY2xlYXIgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgcmVzZXQgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgY29weSA6ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBhZGQgOiAnYSB0IC0+IGtleSAtPiAnYSAtPiB1bml0XG4gICAgdmFsIHJlbW92ZSA6ICdhIHQgLT4ga2V5IC0+IHVuaXRcbiAgICB2YWwgZmluZCA6ICdhIHQgLT4ga2V5IC0+ICdhXG4gICAgdmFsIGZpbmRfb3B0OiAnYSB0IC0+IGtleSAtPiAnYSBvcHRpb25cbiAgICB2YWwgZmluZF9hbGwgOiAnYSB0IC0+IGtleSAtPiAnYSBsaXN0XG4gICAgdmFsIHJlcGxhY2UgOiAnYSB0IC0+IGtleSAtPiAnYSAtPiB1bml0XG4gICAgdmFsIG1lbSA6ICdhIHQgLT4ga2V5IC0+IGJvb2xcbiAgICB2YWwgaXRlciA6IChrZXkgLT4gJ2EgLT4gdW5pdCkgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZpbHRlcl9tYXBfaW5wbGFjZTogKGtleSAtPiAnYSAtPiAnYSBvcHRpb24pIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmb2xkIDogKGtleSAtPiAnYSAtPiAnYiAtPiAnYikgLT4gJ2EgdCAtPiAnYiAtPiAnYlxuICAgIHZhbCBsZW5ndGggOiAnYSB0IC0+IGludFxuICAgIHZhbCBzdGF0czogJ2EgdCAtPiBzdGF0aXN0aWNzXG4gIGVuZFxuXG5tb2R1bGUgTWFrZVNlZWRlZChIOiBTZWVkZWRIYXNoZWRUeXBlKTogKFNlZWRlZFMgd2l0aCB0eXBlIGtleSA9IEgudCkgPVxuICBzdHJ1Y3RcbiAgICB0eXBlIGtleSA9IEgudFxuICAgIHR5cGUgJ2EgaGFzaHRibCA9IChrZXksICdhKSB0XG4gICAgdHlwZSAnYSB0ID0gJ2EgaGFzaHRibFxuICAgIGxldCBjcmVhdGUgPSBjcmVhdGVcbiAgICBsZXQgY2xlYXIgPSBjbGVhclxuICAgIGxldCByZXNldCA9IHJlc2V0XG4gICAgbGV0IGNvcHkgPSBjb3B5XG5cbiAgICBsZXQga2V5X2luZGV4IGgga2V5ID1cbiAgICAgIChILmhhc2ggaC5zZWVkIGtleSkgbGFuZCAoQXJyYXkubGVuZ3RoIGguZGF0YSAtIDEpXG5cbiAgICBsZXQgYWRkIGgga2V5IGRhdGEgPVxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBrZXkgaW5cbiAgICAgIGxldCBidWNrZXQgPSBDb25ze2tleTsgZGF0YTsgbmV4dD1oLmRhdGEuKGkpfSBpblxuICAgICAgaC5kYXRhLihpKSA8LSBidWNrZXQ7XG4gICAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICAgIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUga2V5X2luZGV4IGhcblxuICAgIGxldCByZWMgcmVtb3ZlX2J1Y2tldCBoIGkga2V5IHByZWMgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgICgpXG4gICAgICB8IChDb25zIHtrZXk9azsgbmV4dH0pIGFzIGMgLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGsga2V5XG4gICAgICAgICAgdGhlbiBiZWdpblxuICAgICAgICAgICAgaC5zaXplIDwtIGguc2l6ZSAtIDE7XG4gICAgICAgICAgICBtYXRjaCBwcmVjIHdpdGhcbiAgICAgICAgICAgIHwgRW1wdHkgLT4gaC5kYXRhLihpKSA8LSBuZXh0XG4gICAgICAgICAgICB8IENvbnMgYyAtPiBjLm5leHQgPC0gbmV4dFxuICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2UgcmVtb3ZlX2J1Y2tldCBoIGkga2V5IGMgbmV4dFxuXG4gICAgbGV0IHJlbW92ZSBoIGtleSA9XG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICAgICAgcmVtb3ZlX2J1Y2tldCBoIGkga2V5IEVtcHR5IGguZGF0YS4oaSlcblxuICAgIGxldCByZWMgZmluZF9yZWMga2V5ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGtleSBrIHRoZW4gZGF0YSBlbHNlIGZpbmRfcmVjIGtleSBuZXh0XG5cbiAgICBsZXQgZmluZCBoIGtleSA9XG4gICAgICBtYXRjaCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSkgd2l0aFxuICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgQ29uc3trZXk9azE7IGRhdGE9ZDE7IG5leHQ9bmV4dDF9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazEgdGhlbiBkMSBlbHNlXG4gICAgICAgICAgbWF0Y2ggbmV4dDEgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgICAgfCBDb25ze2tleT1rMjsgZGF0YT1kMjsgbmV4dD1uZXh0Mn0gLT5cbiAgICAgICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazIgdGhlbiBkMiBlbHNlXG4gICAgICAgICAgICAgIG1hdGNoIG5leHQyIHdpdGhcbiAgICAgICAgICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgICAgICAgICAgfCBDb25ze2tleT1rMzsgZGF0YT1kMzsgbmV4dD1uZXh0M30gLT5cbiAgICAgICAgICAgICAgICAgIGlmIEguZXF1YWwga2V5IGszIHRoZW4gZDMgZWxzZSBmaW5kX3JlYyBrZXkgbmV4dDNcblxuICAgIGxldCByZWMgZmluZF9yZWNfb3B0IGtleSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBDb25ze2tleT1rOyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsgdGhlbiBTb21lIGRhdGEgZWxzZSBmaW5kX3JlY19vcHQga2V5IG5leHRcblxuICAgIGxldCBmaW5kX29wdCBoIGtleSA9XG4gICAgICBtYXRjaCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSkgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBOb25lXG4gICAgICB8IENvbnN7a2V5PWsxOyBkYXRhPWQxOyBuZXh0PW5leHQxfSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsxIHRoZW4gU29tZSBkMSBlbHNlXG4gICAgICAgICAgbWF0Y2ggbmV4dDEgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgICAgICAgIHwgQ29uc3trZXk9azI7IGRhdGE9ZDI7IG5leHQ9bmV4dDJ9IC0+XG4gICAgICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsyIHRoZW4gU29tZSBkMiBlbHNlXG4gICAgICAgICAgICAgIG1hdGNoIG5leHQyIHdpdGhcbiAgICAgICAgICAgICAgfCBFbXB0eSAtPiBOb25lXG4gICAgICAgICAgICAgIHwgQ29uc3trZXk9azM7IGRhdGE9ZDM7IG5leHQ9bmV4dDN9IC0+XG4gICAgICAgICAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMyB0aGVuIFNvbWUgZDMgZWxzZSBmaW5kX3JlY19vcHQga2V5IG5leHQzXG5cbiAgICBsZXQgZmluZF9hbGwgaCBrZXkgPVxuICAgICAgbGV0IHJlYyBmaW5kX2luX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgW11cbiAgICAgIHwgQ29uc3trZXk9azsgZGF0YT1kOyBuZXh0fSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwgayBrZXlcbiAgICAgICAgICB0aGVuIGQgOjogZmluZF9pbl9idWNrZXQgbmV4dFxuICAgICAgICAgIGVsc2UgZmluZF9pbl9idWNrZXQgbmV4dCBpblxuICAgICAgZmluZF9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpXG5cbiAgICBsZXQgcmVjIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICB0cnVlXG4gICAgICB8IENvbnMgKHtrZXk9azsgbmV4dH0gYXMgc2xvdCkgLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGsga2V5XG4gICAgICAgICAgdGhlbiAoc2xvdC5rZXkgPC0ga2V5OyBzbG90LmRhdGEgPC0gZGF0YTsgZmFsc2UpXG4gICAgICAgICAgZWxzZSByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSBuZXh0XG5cbiAgICBsZXQgcmVwbGFjZSBoIGtleSBkYXRhID1cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gICAgICBsZXQgbCA9IGguZGF0YS4oaSkgaW5cbiAgICAgIGlmIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhIGwgdGhlbiBiZWdpblxuICAgICAgICBoLmRhdGEuKGkpIDwtIENvbnN7a2V5OyBkYXRhOyBuZXh0PWx9O1xuICAgICAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICAgICAgaWYgaC5zaXplID4gQXJyYXkubGVuZ3RoIGguZGF0YSBsc2wgMSB0aGVuIHJlc2l6ZSBrZXlfaW5kZXggaFxuICAgICAgZW5kXG5cbiAgICBsZXQgbWVtIGgga2V5ID1cbiAgICAgIGxldCByZWMgbWVtX2luX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgZmFsc2VcbiAgICAgIHwgQ29uc3trZXk9azsgbmV4dH0gLT5cbiAgICAgICAgICBILmVxdWFsIGsga2V5IHx8IG1lbV9pbl9idWNrZXQgbmV4dCBpblxuICAgICAgbWVtX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSlcblxuICAgIGxldCBpdGVyID0gaXRlclxuICAgIGxldCBmaWx0ZXJfbWFwX2lucGxhY2UgPSBmaWx0ZXJfbWFwX2lucGxhY2VcbiAgICBsZXQgZm9sZCA9IGZvbGRcbiAgICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG4gICAgbGV0IHN0YXRzID0gc3RhdHNcbiAgZW5kXG5cbm1vZHVsZSBNYWtlKEg6IEhhc2hlZFR5cGUpOiAoUyB3aXRoIHR5cGUga2V5ID0gSC50KSA9XG4gIHN0cnVjdFxuICAgIGluY2x1ZGUgTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gSC50XG4gICAgICAgIGxldCBlcXVhbCA9IEguZXF1YWxcbiAgICAgICAgbGV0IGhhc2ggKF9zZWVkOiBpbnQpIHggPSBILmhhc2ggeFxuICAgICAgZW5kKVxuICAgIGxldCBjcmVhdGUgc3ogPSBjcmVhdGUgfnJhbmRvbTpmYWxzZSBzelxuICBlbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCoqIFdlYWsgYXJyYXkgb3BlcmF0aW9ucyAqKVxuXG50eXBlICdhIHRcblxuZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+ICdhIHQgPSBcImNhbWxfd2Vha19jcmVhdGVcIlxuXG4oKiogbnVtYmVyIG9mIGFkZGl0aW9uYWwgdmFsdWVzIGluIGEgd2VhayBwb2ludGVyICopXG5sZXQgYWRkaXRpb25hbF92YWx1ZXMgPSAyXG5cbmxldCBsZW5ndGggeCA9IE9iai5zaXplKE9iai5yZXByIHgpIC0gYWRkaXRpb25hbF92YWx1ZXNcblxuZXh0ZXJuYWwgc2V0IDogJ2EgdCAtPiBpbnQgLT4gJ2Egb3B0aW9uIC0+IHVuaXQgPSBcImNhbWxfd2Vha19zZXRcIlxuZXh0ZXJuYWwgZ2V0IDogJ2EgdCAtPiBpbnQgLT4gJ2Egb3B0aW9uID0gXCJjYW1sX3dlYWtfZ2V0XCJcbmV4dGVybmFsIGdldF9jb3B5IDogJ2EgdCAtPiBpbnQgLT4gJ2Egb3B0aW9uID0gXCJjYW1sX3dlYWtfZ2V0X2NvcHlcIlxuZXh0ZXJuYWwgY2hlY2sgOiAnYSB0IC0+IGludCAtPiBib29sID0gXCJjYW1sX3dlYWtfY2hlY2tcIlxuZXh0ZXJuYWwgYmxpdCA6ICdhIHQgLT4gaW50IC0+ICdhIHQgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX3dlYWtfYmxpdFwiXG4oKiBibGl0OiBzcmMgc3Jjb2ZmIGRzdCBkc3RvZmYgbGVuICopXG5cbmxldCBmaWxsIGFyIG9mcyBsZW4geCA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgKyBsZW4gPiBsZW5ndGggYXJcbiAgdGhlbiByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcIldlYWsuZmlsbFwiKVxuICBlbHNlIGJlZ2luXG4gICAgZm9yIGkgPSBvZnMgdG8gKG9mcyArIGxlbiAtIDEpIGRvXG4gICAgICBzZXQgYXIgaSB4XG4gICAgZG9uZVxuICBlbmRcblxuXG4oKiogV2VhayBoYXNoIHRhYmxlcyAqKVxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIHR5cGUgZGF0YVxuICB0eXBlIHRcbiAgdmFsIGNyZWF0ZSA6IGludCAtPiB0XG4gIHZhbCBjbGVhciA6IHQgLT4gdW5pdFxuICB2YWwgbWVyZ2UgOiB0IC0+IGRhdGEgLT4gZGF0YVxuICB2YWwgYWRkIDogdCAtPiBkYXRhIC0+IHVuaXRcbiAgdmFsIHJlbW92ZSA6IHQgLT4gZGF0YSAtPiB1bml0XG4gIHZhbCBmaW5kIDogdCAtPiBkYXRhIC0+IGRhdGFcbiAgdmFsIGZpbmRfb3B0IDogdCAtPiBkYXRhIC0+IGRhdGEgb3B0aW9uXG4gIHZhbCBmaW5kX2FsbCA6IHQgLT4gZGF0YSAtPiBkYXRhIGxpc3RcbiAgdmFsIG1lbSA6IHQgLT4gZGF0YSAtPiBib29sXG4gIHZhbCBpdGVyIDogKGRhdGEgLT4gdW5pdCkgLT4gdCAtPiB1bml0XG4gIHZhbCBmb2xkIDogKGRhdGEgLT4gJ2EgLT4gJ2EpIC0+IHQgLT4gJ2EgLT4gJ2FcbiAgdmFsIGNvdW50IDogdCAtPiBpbnRcbiAgdmFsIHN0YXRzIDogdCAtPiBpbnQgKiBpbnQgKiBpbnQgKiBpbnQgKiBpbnQgKiBpbnRcbmVuZFxuXG5tb2R1bGUgTWFrZSAoSCA6IEhhc2h0YmwuSGFzaGVkVHlwZSkgOiAoUyB3aXRoIHR5cGUgZGF0YSA9IEgudCkgPSBzdHJ1Y3RcblxuICB0eXBlICdhIHdlYWtfdCA9ICdhIHRcbiAgbGV0IHdlYWtfY3JlYXRlID0gY3JlYXRlXG4gIGxldCBlbXB0eWJ1Y2tldCA9IHdlYWtfY3JlYXRlIDBcblxuICB0eXBlIGRhdGEgPSBILnRcblxuICB0eXBlIHQgPSB7XG4gICAgbXV0YWJsZSB0YWJsZSA6IGRhdGEgd2Vha190IGFycmF5O1xuICAgIG11dGFibGUgaGFzaGVzIDogaW50IGFycmF5IGFycmF5O1xuICAgIG11dGFibGUgbGltaXQgOiBpbnQ7ICAgICAgICAgICAgICAgKCogYnVja2V0IHNpemUgbGltaXQgKilcbiAgICBtdXRhYmxlIG92ZXJzaXplIDogaW50OyAgICAgICAgICAgICgqIG51bWJlciBvZiBvdmVyc2l6ZSBidWNrZXRzICopXG4gICAgbXV0YWJsZSByb3ZlciA6IGludDsgICAgICAgICAgICAgICAoKiBmb3IgaW50ZXJuYWwgYm9va2tlZXBpbmcgKilcbiAgfVxuXG4gIGxldCBnZXRfaW5kZXggdCBoID0gKGggbGFuZCBtYXhfaW50KSBtb2QgKEFycmF5Lmxlbmd0aCB0LnRhYmxlKVxuXG4gIGxldCBsaW1pdCA9IDdcbiAgbGV0IG92ZXJfbGltaXQgPSAyXG5cbiAgbGV0IGNyZWF0ZSBzeiA9XG4gICAgbGV0IHN6ID0gaWYgc3ogPCA3IHRoZW4gNyBlbHNlIHN6IGluXG4gICAgbGV0IHN6ID0gaWYgc3ogPiBTeXMubWF4X2FycmF5X2xlbmd0aCB0aGVuIFN5cy5tYXhfYXJyYXlfbGVuZ3RoIGVsc2Ugc3ogaW5cbiAgICB7XG4gICAgICB0YWJsZSA9IEFycmF5Lm1ha2Ugc3ogZW1wdHlidWNrZXQ7XG4gICAgICBoYXNoZXMgPSBBcnJheS5tYWtlIHN6IFt8IHxdO1xuICAgICAgbGltaXQgPSBsaW1pdDtcbiAgICAgIG92ZXJzaXplID0gMDtcbiAgICAgIHJvdmVyID0gMDtcbiAgICB9XG5cbiAgbGV0IGNsZWFyIHQgPVxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggdC50YWJsZSAtIDEgZG9cbiAgICAgIHQudGFibGUuKGkpIDwtIGVtcHR5YnVja2V0O1xuICAgICAgdC5oYXNoZXMuKGkpIDwtIFt8IHxdO1xuICAgIGRvbmU7XG4gICAgdC5saW1pdCA8LSBsaW1pdDtcbiAgICB0Lm92ZXJzaXplIDwtIDBcblxuXG4gIGxldCBmb2xkIGYgdCBpbml0ID1cbiAgICBsZXQgcmVjIGZvbGRfYnVja2V0IGkgYiBhY2N1ID1cbiAgICAgIGlmIGkgPj0gbGVuZ3RoIGIgdGhlbiBhY2N1IGVsc2VcbiAgICAgIG1hdGNoIGdldCBiIGkgd2l0aFxuICAgICAgfCBTb21lIHYgLT4gZm9sZF9idWNrZXQgKGkrMSkgYiAoZiB2IGFjY3UpXG4gICAgICB8IE5vbmUgLT4gZm9sZF9idWNrZXQgKGkrMSkgYiBhY2N1XG4gICAgaW5cbiAgICBBcnJheS5mb2xkX3JpZ2h0IChmb2xkX2J1Y2tldCAwKSB0LnRhYmxlIGluaXRcblxuXG4gIGxldCBpdGVyIGYgdCA9XG4gICAgbGV0IHJlYyBpdGVyX2J1Y2tldCBpIGIgPVxuICAgICAgaWYgaSA+PSBsZW5ndGggYiB0aGVuICgpIGVsc2VcbiAgICAgIG1hdGNoIGdldCBiIGkgd2l0aFxuICAgICAgfCBTb21lIHYgLT4gZiB2OyBpdGVyX2J1Y2tldCAoaSsxKSBiXG4gICAgICB8IE5vbmUgLT4gaXRlcl9idWNrZXQgKGkrMSkgYlxuICAgIGluXG4gICAgQXJyYXkuaXRlciAoaXRlcl9idWNrZXQgMCkgdC50YWJsZVxuXG5cbiAgbGV0IGl0ZXJfd2VhayBmIHQgPVxuICAgIGxldCByZWMgaXRlcl9idWNrZXQgaSBqIGIgPVxuICAgICAgaWYgaSA+PSBsZW5ndGggYiB0aGVuICgpIGVsc2VcbiAgICAgIG1hdGNoIGNoZWNrIGIgaSB3aXRoXG4gICAgICB8IHRydWUgLT4gZiBiIHQuaGFzaGVzLihqKSBpOyBpdGVyX2J1Y2tldCAoaSsxKSBqIGJcbiAgICAgIHwgZmFsc2UgLT4gaXRlcl9idWNrZXQgKGkrMSkgaiBiXG4gICAgaW5cbiAgICBBcnJheS5pdGVyaSAoaXRlcl9idWNrZXQgMCkgdC50YWJsZVxuXG5cbiAgbGV0IHJlYyBjb3VudF9idWNrZXQgaSBiIGFjY3UgPVxuICAgIGlmIGkgPj0gbGVuZ3RoIGIgdGhlbiBhY2N1IGVsc2VcbiAgICBjb3VudF9idWNrZXQgKGkrMSkgYiAoYWNjdSArIChpZiBjaGVjayBiIGkgdGhlbiAxIGVsc2UgMCkpXG5cblxuICBsZXQgY291bnQgdCA9XG4gICAgQXJyYXkuZm9sZF9yaWdodCAoY291bnRfYnVja2V0IDApIHQudGFibGUgMFxuXG5cbiAgbGV0IG5leHRfc3ogbiA9IG1pbiAoMyAqIG4gLyAyICsgMykgU3lzLm1heF9hcnJheV9sZW5ndGhcbiAgbGV0IHByZXZfc3ogbiA9ICgobiAtIDMpICogMiArIDIpIC8gM1xuXG4gIGxldCB0ZXN0X3Nocmlua19idWNrZXQgdCA9XG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKHQucm92ZXIpIGluXG4gICAgbGV0IGhidWNrZXQgPSB0Lmhhc2hlcy4odC5yb3ZlcikgaW5cbiAgICBsZXQgbGVuID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCBwcmV2X2xlbiA9IHByZXZfc3ogbGVuIGluXG4gICAgbGV0IGxpdmUgPSBjb3VudF9idWNrZXQgMCBidWNrZXQgMCBpblxuICAgIGlmIGxpdmUgPD0gcHJldl9sZW4gdGhlbiBiZWdpblxuICAgICAgbGV0IHJlYyBsb29wIGkgaiA9XG4gICAgICAgIGlmIGogPj0gcHJldl9sZW4gdGhlbiBiZWdpblxuICAgICAgICAgIGlmIGNoZWNrIGJ1Y2tldCBpIHRoZW4gbG9vcCAoaSArIDEpIGpcbiAgICAgICAgICBlbHNlIGlmIGNoZWNrIGJ1Y2tldCBqIHRoZW4gYmVnaW5cbiAgICAgICAgICAgIGJsaXQgYnVja2V0IGogYnVja2V0IGkgMTtcbiAgICAgICAgICAgIGhidWNrZXQuKGkpIDwtIGhidWNrZXQuKGopO1xuICAgICAgICAgICAgbG9vcCAoaSArIDEpIChqIC0gMSk7XG4gICAgICAgICAgZW5kIGVsc2UgbG9vcCBpIChqIC0gMSk7XG4gICAgICAgIGVuZDtcbiAgICAgIGluXG4gICAgICBsb29wIDAgKGxlbmd0aCBidWNrZXQgLSAxKTtcbiAgICAgIGlmIHByZXZfbGVuID0gMCB0aGVuIGJlZ2luXG4gICAgICAgIHQudGFibGUuKHQucm92ZXIpIDwtIGVtcHR5YnVja2V0O1xuICAgICAgICB0Lmhhc2hlcy4odC5yb3ZlcikgPC0gW3wgfF07XG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBPYmoudHJ1bmNhdGUgKE9iai5yZXByIGJ1Y2tldCkgKHByZXZfbGVuICsgYWRkaXRpb25hbF92YWx1ZXMpO1xuICAgICAgICBPYmoudHJ1bmNhdGUgKE9iai5yZXByIGhidWNrZXQpIHByZXZfbGVuO1xuICAgICAgZW5kO1xuICAgICAgaWYgbGVuID4gdC5saW1pdCAmJiBwcmV2X2xlbiA8PSB0LmxpbWl0IHRoZW4gdC5vdmVyc2l6ZSA8LSB0Lm92ZXJzaXplIC0gMTtcbiAgICBlbmQ7XG4gICAgdC5yb3ZlciA8LSAodC5yb3ZlciArIDEpIG1vZCAoQXJyYXkubGVuZ3RoIHQudGFibGUpXG5cblxuICBsZXQgcmVjIHJlc2l6ZSB0ID1cbiAgICBsZXQgb2xkbGVuID0gQXJyYXkubGVuZ3RoIHQudGFibGUgaW5cbiAgICBsZXQgbmV3bGVuID0gbmV4dF9zeiBvbGRsZW4gaW5cbiAgICBpZiBuZXdsZW4gPiBvbGRsZW4gdGhlbiBiZWdpblxuICAgICAgbGV0IG5ld3QgPSBjcmVhdGUgbmV3bGVuIGluXG4gICAgICBsZXQgYWRkX3dlYWsgb2Igb2ggb2kgPVxuICAgICAgICBsZXQgc2V0dGVyIG5iIG5pIF8gPSBibGl0IG9iIG9pIG5iIG5pIDEgaW5cbiAgICAgICAgbGV0IGggPSBvaC4ob2kpIGluXG4gICAgICAgIGFkZF9hdXggbmV3dCBzZXR0ZXIgTm9uZSBoIChnZXRfaW5kZXggbmV3dCBoKTtcbiAgICAgIGluXG4gICAgICBpdGVyX3dlYWsgYWRkX3dlYWsgdDtcbiAgICAgIHQudGFibGUgPC0gbmV3dC50YWJsZTtcbiAgICAgIHQuaGFzaGVzIDwtIG5ld3QuaGFzaGVzO1xuICAgICAgdC5saW1pdCA8LSBuZXd0LmxpbWl0O1xuICAgICAgdC5vdmVyc2l6ZSA8LSBuZXd0Lm92ZXJzaXplO1xuICAgICAgdC5yb3ZlciA8LSB0LnJvdmVyIG1vZCBBcnJheS5sZW5ndGggbmV3dC50YWJsZTtcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgdC5saW1pdCA8LSBtYXhfaW50OyAgICAgICAgICAgICAoKiBtYXhpbXVtIHNpemUgYWxyZWFkeSByZWFjaGVkICopXG4gICAgICB0Lm92ZXJzaXplIDwtIDA7XG4gICAgZW5kXG5cbiAgYW5kIGFkZF9hdXggdCBzZXR0ZXIgZCBoIGluZGV4ID1cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4oaW5kZXgpIGluXG4gICAgbGV0IGhhc2hlcyA9IHQuaGFzaGVzLihpbmRleCkgaW5cbiAgICBsZXQgc3ogPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA+PSBzeiB0aGVuIGJlZ2luXG4gICAgICAgIGxldCBuZXdzeiA9XG4gICAgICAgICAgbWluICgzICogc3ogLyAyICsgMykgKFN5cy5tYXhfYXJyYXlfbGVuZ3RoIC0gYWRkaXRpb25hbF92YWx1ZXMpXG4gICAgICAgIGluXG4gICAgICAgIGlmIG5ld3N6IDw9IHN6IHRoZW4gZmFpbHdpdGggXCJXZWFrLk1ha2U6IGhhc2ggYnVja2V0IGNhbm5vdCBncm93IG1vcmVcIjtcbiAgICAgICAgbGV0IG5ld2J1Y2tldCA9IHdlYWtfY3JlYXRlIG5ld3N6IGluXG4gICAgICAgIGxldCBuZXdoYXNoZXMgPSBBcnJheS5tYWtlIG5ld3N6IDAgaW5cbiAgICAgICAgYmxpdCBidWNrZXQgMCBuZXdidWNrZXQgMCBzejtcbiAgICAgICAgQXJyYXkuYmxpdCBoYXNoZXMgMCBuZXdoYXNoZXMgMCBzejtcbiAgICAgICAgc2V0dGVyIG5ld2J1Y2tldCBzeiBkO1xuICAgICAgICBuZXdoYXNoZXMuKHN6KSA8LSBoO1xuICAgICAgICB0LnRhYmxlLihpbmRleCkgPC0gbmV3YnVja2V0O1xuICAgICAgICB0Lmhhc2hlcy4oaW5kZXgpIDwtIG5ld2hhc2hlcztcbiAgICAgICAgaWYgc3ogPD0gdC5saW1pdCAmJiBuZXdzeiA+IHQubGltaXQgdGhlbiBiZWdpblxuICAgICAgICAgIHQub3ZlcnNpemUgPC0gdC5vdmVyc2l6ZSArIDE7XG4gICAgICAgICAgZm9yIF9pID0gMCB0byBvdmVyX2xpbWl0IGRvIHRlc3Rfc2hyaW5rX2J1Y2tldCB0IGRvbmU7XG4gICAgICAgIGVuZDtcbiAgICAgICAgaWYgdC5vdmVyc2l6ZSA+IEFycmF5Lmxlbmd0aCB0LnRhYmxlIC8gb3Zlcl9saW1pdCB0aGVuIHJlc2l6ZSB0O1xuICAgICAgZW5kIGVsc2UgaWYgY2hlY2sgYnVja2V0IGkgdGhlbiBiZWdpblxuICAgICAgICBsb29wIChpICsgMSlcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIHNldHRlciBidWNrZXQgaSBkO1xuICAgICAgICBoYXNoZXMuKGkpIDwtIGg7XG4gICAgICBlbmQ7XG4gICAgaW5cbiAgICBsb29wIDBcblxuXG4gIGxldCBhZGQgdCBkID1cbiAgICBsZXQgaCA9IEguaGFzaCBkIGluXG4gICAgYWRkX2F1eCB0IHNldCAoU29tZSBkKSBoIChnZXRfaW5kZXggdCBoKVxuXG5cbiAgbGV0IGZpbmRfb3IgdCBkIGlmbm90Zm91bmQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBsZXQgaW5kZXggPSBnZXRfaW5kZXggdCBoIGluXG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPj0gc3ogdGhlbiBpZm5vdGZvdW5kIGggaW5kZXhcbiAgICAgIGVsc2UgaWYgaCA9IGhhc2hlcy4oaSkgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBnZXRfY29weSBidWNrZXQgaSB3aXRoXG4gICAgICAgIHwgU29tZSB2IHdoZW4gSC5lcXVhbCB2IGRcbiAgICAgICAgICAgLT4gYmVnaW4gbWF0Y2ggZ2V0IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgICAgICAgfCBTb21lIHYgLT4gdlxuICAgICAgICAgICAgICB8IE5vbmUgLT4gbG9vcCAoaSArIDEpXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICB8IF8gLT4gbG9vcCAoaSArIDEpXG4gICAgICBlbmQgZWxzZSBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3AgMFxuXG5cbiAgbGV0IG1lcmdlIHQgZCA9XG4gICAgZmluZF9vciB0IGQgKGZ1biBoIGluZGV4IC0+IGFkZF9hdXggdCBzZXQgKFNvbWUgZCkgaCBpbmRleDsgZClcblxuXG4gIGxldCBmaW5kIHQgZCA9IGZpbmRfb3IgdCBkIChmdW4gX2ggX2luZGV4IC0+IHJhaXNlIE5vdF9mb3VuZClcblxuICBsZXQgZmluZF9vcHQgdCBkID1cbiAgICBsZXQgaCA9IEguaGFzaCBkIGluXG4gICAgbGV0IGluZGV4ID0gZ2V0X2luZGV4IHQgaCBpblxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLihpbmRleCkgaW5cbiAgICBsZXQgaGFzaGVzID0gdC5oYXNoZXMuKGluZGV4KSBpblxuICAgIGxldCBzeiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID49IHN6IHRoZW4gTm9uZVxuICAgICAgZWxzZSBpZiBoID0gaGFzaGVzLihpKSB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGdldF9jb3B5IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgfCBTb21lIHYgd2hlbiBILmVxdWFsIHYgZFxuICAgICAgICAgICAtPiBiZWdpbiBtYXRjaCBnZXQgYnVja2V0IGkgd2l0aFxuICAgICAgICAgICAgICB8IFNvbWUgXyBhcyB2IC0+IHZcbiAgICAgICAgICAgICAgfCBOb25lIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgfCBfIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgZW5kIGVsc2UgbG9vcCAoaSArIDEpXG4gICAgaW5cbiAgICBsb29wIDBcblxuXG4gIGxldCBmaW5kX3NoYWRvdyB0IGQgaWZmb3VuZCBpZm5vdGZvdW5kID1cbiAgICBsZXQgaCA9IEguaGFzaCBkIGluXG4gICAgbGV0IGluZGV4ID0gZ2V0X2luZGV4IHQgaCBpblxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLihpbmRleCkgaW5cbiAgICBsZXQgaGFzaGVzID0gdC5oYXNoZXMuKGluZGV4KSBpblxuICAgIGxldCBzeiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID49IHN6IHRoZW4gaWZub3Rmb3VuZFxuICAgICAgZWxzZSBpZiBoID0gaGFzaGVzLihpKSB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGdldF9jb3B5IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgfCBTb21lIHYgd2hlbiBILmVxdWFsIHYgZCAtPiBpZmZvdW5kIGJ1Y2tldCBpXG4gICAgICAgIHwgXyAtPiBsb29wIChpICsgMSlcbiAgICAgIGVuZCBlbHNlIGxvb3AgKGkgKyAxKVxuICAgIGluXG4gICAgbG9vcCAwXG5cblxuICBsZXQgcmVtb3ZlIHQgZCA9IGZpbmRfc2hhZG93IHQgZCAoZnVuIHcgaSAtPiBzZXQgdyBpIE5vbmUpICgpXG5cblxuICBsZXQgbWVtIHQgZCA9IGZpbmRfc2hhZG93IHQgZCAoZnVuIF93IF9pIC0+IHRydWUpIGZhbHNlXG5cblxuICBsZXQgZmluZF9hbGwgdCBkID1cbiAgICBsZXQgaCA9IEguaGFzaCBkIGluXG4gICAgbGV0IGluZGV4ID0gZ2V0X2luZGV4IHQgaCBpblxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLihpbmRleCkgaW5cbiAgICBsZXQgaGFzaGVzID0gdC5oYXNoZXMuKGluZGV4KSBpblxuICAgIGxldCBzeiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSBhY2N1ID1cbiAgICAgIGlmIGkgPj0gc3ogdGhlbiBhY2N1XG4gICAgICBlbHNlIGlmIGggPSBoYXNoZXMuKGkpIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggZ2V0X2NvcHkgYnVja2V0IGkgd2l0aFxuICAgICAgICB8IFNvbWUgdiB3aGVuIEguZXF1YWwgdiBkXG4gICAgICAgICAgIC0+IGJlZ2luIG1hdGNoIGdldCBidWNrZXQgaSB3aXRoXG4gICAgICAgICAgICAgIHwgU29tZSB2IC0+IGxvb3AgKGkgKyAxKSAodiA6OiBhY2N1KVxuICAgICAgICAgICAgICB8IE5vbmUgLT4gbG9vcCAoaSArIDEpIGFjY3VcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgXyAtPiBsb29wIChpICsgMSkgYWNjdVxuICAgICAgZW5kIGVsc2UgbG9vcCAoaSArIDEpIGFjY3VcbiAgICBpblxuICAgIGxvb3AgMCBbXVxuXG5cbiAgbGV0IHN0YXRzIHQgPVxuICAgIGxldCBsZW4gPSBBcnJheS5sZW5ndGggdC50YWJsZSBpblxuICAgIGxldCBsZW5zID0gQXJyYXkubWFwIGxlbmd0aCB0LnRhYmxlIGluXG4gICAgQXJyYXkuc29ydCBjb21wYXJlIGxlbnM7XG4gICAgbGV0IHRvdGxlbiA9IEFycmF5LmZvbGRfbGVmdCAoICsgKSAwIGxlbnMgaW5cbiAgICAobGVuLCBjb3VudCB0LCB0b3RsZW4sIGxlbnMuKDApLCBsZW5zLihsZW4vMiksIGxlbnMuKGxlbi0xKSlcblxuXG5lbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFBpZXJyZSBXZWlzLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQSBwcmV0dHktcHJpbnRpbmcgZmFjaWxpdHkgYW5kIGRlZmluaXRpb24gb2YgZm9ybWF0dGVycyBmb3IgJ3BhcmFsbGVsJ1xuICAgKGkuZS4gdW5yZWxhdGVkIG9yIGluZGVwZW5kZW50KSBwcmV0dHktcHJpbnRpbmcgb24gbXVsdGlwbGUgb3V0IGNoYW5uZWxzLiAqKVxuXG4oKlxuICAgVGhlIHByZXR0eS1wcmludGluZyBlbmdpbmUgaW50ZXJuYWwgZGF0YSBzdHJ1Y3R1cmVzLlxuKilcblxuKCogQSBkZXZvdGVkIHR5cGUgZm9yIHNpemVzIHRvIGF2b2lkIGNvbmZ1c2lvblxuICAgYmV0d2VlbiBzaXplcyBhbmQgbWVyZSBpbnRlZ2Vycy4gKilcbnR5cGUgc2l6ZVxuXG5leHRlcm5hbCBzaXplX29mX2ludCA6IGludCAtPiBzaXplID0gXCIlaWRlbnRpdHlcIlxuXG5leHRlcm5hbCBpbnRfb2Zfc2l6ZSA6IHNpemUgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuXG5cbigqIFRoZSBwcmV0dHktcHJpbnRpbmcgYm94ZXMgZGVmaW5pdGlvbjpcbiAgIGEgcHJldHR5LXByaW50aW5nIGJveCBpcyBlaXRoZXJcbiAgIC0gaGJveDogaG9yaXpvbnRhbCBib3ggKG5vIGxpbmUgc3BsaXR0aW5nKVxuICAgLSB2Ym94OiB2ZXJ0aWNhbCBib3ggKGV2ZXJ5IGJyZWFrIGhpbnQgc3BsaXRzIHRoZSBsaW5lKVxuICAgLSBodmJveDogaG9yaXpvbnRhbC92ZXJ0aWNhbCBib3hcbiAgICAgKHRoZSBib3ggYmVoYXZlcyBhcyBhbiBob3Jpem9udGFsIGJveCBpZiBpdCBmaXRzIG9uXG4gICAgICB0aGUgY3VycmVudCBsaW5lLCBvdGhlcndpc2UgdGhlIGJveCBiZWhhdmVzIGFzIGEgdmVydGljYWwgYm94KVxuICAgLSBob3Zib3g6IGhvcml6b250YWwgb3IgdmVydGljYWwgY29tcGFjdGluZyBib3hcbiAgICAgKHRoZSBib3ggaXMgY29tcGFjdGluZyBtYXRlcmlhbCwgcHJpbnRpbmcgYXMgbXVjaCBtYXRlcmlhbCBhcyBwb3NzaWJsZVxuICAgICAgb24gZXZlcnkgbGluZXMpXG4gICAtIGJveDogaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBjb21wYWN0aW5nIGJveCB3aXRoIGVuaGFuY2VkIGJveCBzdHJ1Y3R1cmVcbiAgICAgKHRoZSBib3ggYmVoYXZlcyBhcyBhbiBob3Jpem9udGFsIG9yIHZlcnRpY2FsIGJveCBidXQgYnJlYWsgaGludHMgc3BsaXRcbiAgICAgIHRoZSBsaW5lIGlmIHNwbGl0dGluZyB3b3VsZCBtb3ZlIHRvIHRoZSBsZWZ0KVxuKilcbnR5cGUgYm94X3R5cGUgPSBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuYmxvY2tfdHlwZSA9XG4gIHwgUHBfaGJveCB8IFBwX3Zib3ggfCBQcF9odmJveCB8IFBwX2hvdmJveCB8IFBwX2JveCB8IFBwX2ZpdHNcblxuXG4oKiBUaGUgcHJldHR5LXByaW50aW5nIHRva2VucyBkZWZpbml0aW9uOlxuICAgYXJlIGVpdGhlciB0ZXh0IHRvIHByaW50IG9yIHByZXR0eSBwcmludGluZ1xuICAgZWxlbWVudHMgdGhhdCBkcml2ZSBpbmRlbnRhdGlvbiBhbmQgbGluZSBzcGxpdHRpbmcuICopXG50eXBlIHBwX3Rva2VuID1cbiAgfCBQcF90ZXh0IG9mIHN0cmluZyAgICAgICAgICAoKiBub3JtYWwgdGV4dCAqKVxuICB8IFBwX2JyZWFrIG9mIGludCAqIGludCAgICAgICgqIGNvbXBsZXRlIGJyZWFrICopXG4gIHwgUHBfdGJyZWFrIG9mIGludCAqIGludCAgICAgKCogZ28gdG8gbmV4dCB0YWJ1bGF0aW9uICopXG4gIHwgUHBfc3RhYiAgICAgICAgICAgICAgICAgICAgKCogc2V0IGEgdGFidWxhdGlvbiAqKVxuICB8IFBwX2JlZ2luIG9mIGludCAqIGJveF90eXBlICgqIGJlZ2lubmluZyBvZiBhIGJveCAqKVxuICB8IFBwX2VuZCAgICAgICAgICAgICAgICAgICAgICgqIGVuZCBvZiBhIGJveCAqKVxuICB8IFBwX3RiZWdpbiBvZiB0Ym94ICAgICAgICAgICgqIGJlZ2lubmluZyBvZiBhIHRhYnVsYXRpb24gYm94ICopXG4gIHwgUHBfdGVuZCAgICAgICAgICAgICAgICAgICAgKCogZW5kIG9mIGEgdGFidWxhdGlvbiBib3ggKilcbiAgfCBQcF9uZXdsaW5lICAgICAgICAgICAgICAgICAoKiB0byBmb3JjZSBhIG5ld2xpbmUgaW5zaWRlIGEgYm94ICopXG4gIHwgUHBfaWZfbmV3bGluZSAgICAgICAgICAgICAgKCogdG8gZG8gc29tZXRoaW5nIG9ubHkgaWYgdGhpcyB2ZXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZSBoYXMgYmVlbiBicm9rZW4gKilcbiAgfCBQcF9vcGVuX3RhZyBvZiB0YWcgICAgICAgICAoKiBvcGVuaW5nIGEgdGFnIG5hbWUgKilcbiAgfCBQcF9jbG9zZV90YWcgICAgICAgICAgICAgICAoKiBjbG9zaW5nIHRoZSBtb3N0IHJlY2VudGx5IG9wZW4gdGFnICopXG5cbmFuZCB0YWcgPSBzdHJpbmdcblxuYW5kIHRib3ggPSBQcF90Ym94IG9mIGludCBsaXN0IHJlZiAgKCogVGFidWxhdGlvbiBib3ggKilcblxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgcXVldWUgZGVmaW5pdGlvbjpcbiAgIHByZXR0eS1wcmludGluZyBtYXRlcmlhbCBpcyBub3Qgd3JpdHRlbiBpbiB0aGUgb3V0cHV0IGFzIHNvb24gYXMgZW1pdHRlZDtcbiAgIGluc3RlYWQsIHRoZSBtYXRlcmlhbCBpcyBzaW1wbHkgcmVjb3JkZWQgaW4gdGhlIHByZXR0eS1wcmludGVyIHF1ZXVlLFxuICAgdW50aWwgdGhlIGVuY2xvc2luZyBib3ggaGFzIGEga25vd24gY29tcHV0ZWQgc2l6ZSBhbmQgcHJvcGVyIHNwbGl0dGluZ1xuICAgZGVjaXNpb25zIGNhbiBiZSBtYWRlLlxuXG4gICBUbyBkZWZpbmUgdGhlIHByZXR0eS1wcmludGVyIHF1ZXVlLCB3ZSBmaXJzdCBkZWZpbmUgcG9seW1vcnBoaWMgcXVldWVzLFxuICAgdGhlbiBwcmV0dHktcHJpbnRlciBxdWV1ZSBlbGVtZW50cy5cbiopXG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZTogcG9seW1vcnBoaWMgcXVldWUgZGVmaW5pdGlvbi4gKilcbnR5cGUgJ2EgcXVldWVfZWxlbSA9XG4gIHwgTmlsXG4gIHwgQ29ucyBvZiB7XG4gICAgICBoZWFkIDogJ2E7XG4gICAgICBtdXRhYmxlIHRhaWwgOiAnYSBxdWV1ZV9lbGVtO1xuICAgIH1cblxuXG50eXBlICdhIHF1ZXVlID0ge1xuICBtdXRhYmxlIGluc2VydCA6ICdhIHF1ZXVlX2VsZW07XG4gIG11dGFibGUgYm9keSA6ICdhIHF1ZXVlX2VsZW07XG59XG5cblxuKCogVGhlIHByZXR0eS1wcmludGVyIHF1ZXVlOiBxdWV1ZSBlbGVtZW50IGRlZmluaXRpb24uXG4gICBUaGUgcHJldHR5LXByaW50ZXIgcXVldWUgY29udGFpbnMgZm9ybWF0dGluZyBlbGVtZW50cyB0byBiZSBwcmludGVkLlxuICAgRWFjaCBmb3JtYXR0aW5nIGVsZW1lbnQgaXMgYSB0dXBsZSAoc2l6ZSwgdG9rZW4sIGxlbmd0aCksIHdoZXJlXG4gICAtIGxlbmd0aCBpcyB0aGUgZGVjbGFyZWQgbGVuZ3RoIG9mIHRoZSB0b2tlbixcbiAgIC0gc2l6ZSBpcyBlZmZlY3RpdmUgc2l6ZSBvZiB0aGUgdG9rZW4gd2hlbiBpdCBpcyBwcmludGVkXG4gICAgIChzaXplIGlzIHNldCB3aGVuIHRoZSBzaXplIG9mIHRoZSBib3ggaXMga25vd24sIHNvIHRoYXQgc2l6ZSBvZiBicmVha1xuICAgICAgaGludHMgYXJlIGRlZmluaXRpdmUpLiAqKVxudHlwZSBwcF9xdWV1ZV9lbGVtID0ge1xuICBtdXRhYmxlIGVsZW1fc2l6ZSA6IHNpemU7XG4gIHRva2VuIDogcHBfdG9rZW47XG4gIGxlbmd0aCA6IGludDtcbn1cblxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgcXVldWUgZGVmaW5pdGlvbi4gKilcbnR5cGUgcHBfcXVldWUgPSBwcF9xdWV1ZV9lbGVtIHF1ZXVlXG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBzY2FubmluZyBzdGFjay4gKilcblxuKCogVGhlIHByZXR0eS1wcmludGVyIHNjYW5uaW5nIHN0YWNrOiBzY2FubmluZyBlbGVtZW50IGRlZmluaXRpb24uXG4gICBFYWNoIGVsZW1lbnQgaXMgKGxlZnRfdG90YWwsIHF1ZXVlIGVsZW1lbnQpIHdoZXJlIGxlZnRfdG90YWxcbiAgIGlzIHRoZSB2YWx1ZSBvZiBwcF9sZWZ0X3RvdGFsIHdoZW4gdGhlIGVsZW1lbnQgaGFzIGJlZW4gZW5xdWV1ZWQuICopXG50eXBlIHBwX3NjYW5fZWxlbSA9IFNjYW5fZWxlbSBvZiBpbnQgKiBwcF9xdWV1ZV9lbGVtXG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBzY2FubmluZyBzdGFjayBkZWZpbml0aW9uLiAqKVxudHlwZSBwcF9zY2FuX3N0YWNrID0gcHBfc2Nhbl9lbGVtIGxpc3RcblxuKCogVGhlIHByZXR0eS1wcmludGVyIGZvcm1hdHRpbmcgc3RhY2s6XG4gICB0aGUgZm9ybWF0dGluZyBzdGFjayBjb250YWlucyB0aGUgZGVzY3JpcHRpb24gb2YgYWxsIHRoZSBjdXJyZW50bHkgYWN0aXZlXG4gICBib3hlczsgdGhlIHByZXR0eS1wcmludGVyIGZvcm1hdHRpbmcgc3RhY2sgaXMgdXNlZCB0byBzcGxpdCB0aGUgbGluZXNcbiAgIHdoaWxlIHByaW50aW5nIHRva2Vucy4gKilcblxuKCogVGhlIHByZXR0eS1wcmludGVyIGZvcm1hdHRpbmcgc3RhY2s6IGZvcm1hdHRpbmcgc3RhY2sgZWxlbWVudCBkZWZpbml0aW9uLlxuICAgRWFjaCBzdGFjayBlbGVtZW50IGRlc2NyaWJlcyBhIHByZXR0eS1wcmludGluZyBib3guICopXG50eXBlIHBwX2Zvcm1hdF9lbGVtID0gRm9ybWF0X2VsZW0gb2YgYm94X3R5cGUgKiBpbnRcblxuKCogVGhlIHByZXR0eS1wcmludGVyIGZvcm1hdHRpbmcgc3RhY2sgZGVmaW5pdGlvbi4gKilcbnR5cGUgcHBfZm9ybWF0X3N0YWNrID0gcHBfZm9ybWF0X2VsZW0gbGlzdFxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgc2VtYW50aWNzIHRhZyBzdGFjayBkZWZpbml0aW9uLiAqKVxudHlwZSBwcF90YWdfc3RhY2sgPSB0YWcgbGlzdFxuXG4oKiBUaGUgZm9ybWF0dGVyIGRlZmluaXRpb24uXG4gICBFYWNoIGZvcm1hdHRlciB2YWx1ZSBpcyBhIHByZXR0eS1wcmludGVyIGluc3RhbmNlIHdpdGggYWxsIGl0c1xuICAgbWFjaGluZXJ5LiAqKVxudHlwZSBmb3JtYXR0ZXIgPSB7XG4gICgqIFRoZSB2YXJpb3VzIHN0YWNrcy4gKilcbiAgbXV0YWJsZSBwcF9zY2FuX3N0YWNrIDogcHBfc2Nhbl9zdGFjaztcbiAgbXV0YWJsZSBwcF9mb3JtYXRfc3RhY2sgOiBwcF9mb3JtYXRfc3RhY2s7XG4gIG11dGFibGUgcHBfdGJveF9zdGFjayA6IHRib3ggbGlzdDtcbiAgbXV0YWJsZSBwcF90YWdfc3RhY2sgOiBwcF90YWdfc3RhY2s7XG4gIG11dGFibGUgcHBfbWFya19zdGFjayA6IHBwX3RhZ19zdGFjaztcbiAgKCogVmFsdWUgb2YgcmlnaHQgbWFyZ2luLiAqKVxuICBtdXRhYmxlIHBwX21hcmdpbiA6IGludDtcbiAgKCogTWluaW1hbCBzcGFjZSBsZWZ0IGJlZm9yZSBtYXJnaW4sIHdoZW4gb3BlbmluZyBhIGJveC4gKilcbiAgbXV0YWJsZSBwcF9taW5fc3BhY2VfbGVmdCA6IGludDtcbiAgKCogTWF4aW11bSB2YWx1ZSBvZiBpbmRlbnRhdGlvbjpcbiAgICAgbm8gYm94IGNhbiBiZSBvcGVuZWQgZnVydGhlci4gKilcbiAgbXV0YWJsZSBwcF9tYXhfaW5kZW50IDogaW50O1xuICAoKiBTcGFjZSByZW1haW5pbmcgb24gdGhlIGN1cnJlbnQgbGluZS4gKilcbiAgbXV0YWJsZSBwcF9zcGFjZV9sZWZ0IDogaW50O1xuICAoKiBDdXJyZW50IHZhbHVlIG9mIGluZGVudGF0aW9uLiAqKVxuICBtdXRhYmxlIHBwX2N1cnJlbnRfaW5kZW50IDogaW50O1xuICAoKiBUcnVlIHdoZW4gdGhlIGxpbmUgaGFzIGJlZW4gYnJva2VuIGJ5IHRoZSBwcmV0dHktcHJpbnRlci4gKilcbiAgbXV0YWJsZSBwcF9pc19uZXdfbGluZSA6IGJvb2w7XG4gICgqIFRvdGFsIHdpZHRoIG9mIHRva2VucyBhbHJlYWR5IHByaW50ZWQuICopXG4gIG11dGFibGUgcHBfbGVmdF90b3RhbCA6IGludDtcbiAgKCogVG90YWwgd2lkdGggb2YgdG9rZW5zIGV2ZXIgcHV0IGluIHF1ZXVlLiAqKVxuICBtdXRhYmxlIHBwX3JpZ2h0X3RvdGFsIDogaW50O1xuICAoKiBDdXJyZW50IG51bWJlciBvZiBvcGVuIGJveGVzLiAqKVxuICBtdXRhYmxlIHBwX2N1cnJfZGVwdGggOiBpbnQ7XG4gICgqIE1heGltdW0gbnVtYmVyIG9mIGJveGVzIHdoaWNoIGNhbiBiZSBzaW11bHRhbmVvdXNseSBvcGVuLiAqKVxuICBtdXRhYmxlIHBwX21heF9ib3hlcyA6IGludDtcbiAgKCogRWxsaXBzaXMgc3RyaW5nLiAqKVxuICBtdXRhYmxlIHBwX2VsbGlwc2lzIDogc3RyaW5nO1xuICAoKiBPdXRwdXQgZnVuY3Rpb24uICopXG4gIG11dGFibGUgcHBfb3V0X3N0cmluZyA6IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHVuaXQ7XG4gICgqIEZsdXNoaW5nIGZ1bmN0aW9uLiAqKVxuICBtdXRhYmxlIHBwX291dF9mbHVzaCA6IHVuaXQgLT4gdW5pdDtcbiAgKCogT3V0cHV0IG9mIG5ldyBsaW5lcy4gKilcbiAgbXV0YWJsZSBwcF9vdXRfbmV3bGluZSA6IHVuaXQgLT4gdW5pdDtcbiAgKCogT3V0cHV0IG9mIGJyZWFrIGhpbnRzIHNwYWNlcy4gKilcbiAgbXV0YWJsZSBwcF9vdXRfc3BhY2VzIDogaW50IC0+IHVuaXQ7XG4gICgqIE91dHB1dCBvZiBpbmRlbnRhdGlvbiBvZiBuZXcgbGluZXMuICopXG4gIG11dGFibGUgcHBfb3V0X2luZGVudCA6IGludCAtPiB1bml0O1xuICAoKiBBcmUgdGFncyBwcmludGVkID8gKilcbiAgbXV0YWJsZSBwcF9wcmludF90YWdzIDogYm9vbDtcbiAgKCogQXJlIHRhZ3MgbWFya2VkID8gKilcbiAgbXV0YWJsZSBwcF9tYXJrX3RhZ3MgOiBib29sO1xuICAoKiBGaW5kIG9wZW5pbmcgYW5kIGNsb3NpbmcgbWFya2VycyBvZiB0YWdzLiAqKVxuICBtdXRhYmxlIHBwX21hcmtfb3Blbl90YWcgOiB0YWcgLT4gc3RyaW5nO1xuICBtdXRhYmxlIHBwX21hcmtfY2xvc2VfdGFnIDogdGFnIC0+IHN0cmluZztcbiAgbXV0YWJsZSBwcF9wcmludF9vcGVuX3RhZyA6IHRhZyAtPiB1bml0O1xuICBtdXRhYmxlIHBwX3ByaW50X2Nsb3NlX3RhZyA6IHRhZyAtPiB1bml0O1xuICAoKiBUaGUgcHJldHR5LXByaW50ZXIgcXVldWUuICopXG4gIG11dGFibGUgcHBfcXVldWUgOiBwcF9xdWV1ZTtcbn1cblxuXG4oKiBUaGUgZm9ybWF0dGVyIHNwZWNpZmljIHRhZyBoYW5kbGluZyBmdW5jdGlvbnMuICopXG50eXBlIGZvcm1hdHRlcl90YWdfZnVuY3Rpb25zID0ge1xuICBtYXJrX29wZW5fdGFnIDogdGFnIC0+IHN0cmluZztcbiAgbWFya19jbG9zZV90YWcgOiB0YWcgLT4gc3RyaW5nO1xuICBwcmludF9vcGVuX3RhZyA6IHRhZyAtPiB1bml0O1xuICBwcmludF9jbG9zZV90YWcgOiB0YWcgLT4gdW5pdDtcbn1cblxuXG4oKiBUaGUgZm9ybWF0dGVyIGZ1bmN0aW9ucyB0byBvdXRwdXQgbWF0ZXJpYWwuICopXG50eXBlIGZvcm1hdHRlcl9vdXRfZnVuY3Rpb25zID0ge1xuICBvdXRfc3RyaW5nIDogc3RyaW5nIC0+IGludCAtPiBpbnQgLT4gdW5pdDtcbiAgb3V0X2ZsdXNoIDogdW5pdCAtPiB1bml0O1xuICBvdXRfbmV3bGluZSA6IHVuaXQgLT4gdW5pdDtcbiAgb3V0X3NwYWNlcyA6IGludCAtPiB1bml0O1xuICBvdXRfaW5kZW50IDogaW50IC0+IHVuaXQ7XG59XG5cblxuKCpcblxuICBBdXhpbGlhcmllcyBhbmQgYmFzaWMgZnVuY3Rpb25zLlxuXG4qKVxuXG4oKiBRdWV1ZXMgYXV4aWxpYXJpZXMuICopXG5cbmxldCBtYWtlX3F1ZXVlICgpID0geyBpbnNlcnQgPSBOaWw7IGJvZHkgPSBOaWw7IH1cblxubGV0IGNsZWFyX3F1ZXVlIHEgPSBxLmluc2VydCA8LSBOaWw7IHEuYm9keSA8LSBOaWxcblxubGV0IGFkZF9xdWV1ZSB4IHEgPVxuICBsZXQgYyA9IENvbnMgeyBoZWFkID0geDsgdGFpbCA9IE5pbDsgfSBpblxuICBtYXRjaCBxIHdpdGhcbiAgfCB7IGluc2VydCA9IENvbnMgY2VsbDsgYm9keSA9IF87IH0gLT5cbiAgICBxLmluc2VydCA8LSBjOyBjZWxsLnRhaWwgPC0gY1xuICAoKiBJbnZhcmlhbnQ6IHdoZW4gaW5zZXJ0IGlzIE5pbCBib2R5IHNob3VsZCBiZSBOaWwuICopXG4gIHwgeyBpbnNlcnQgPSBOaWw7IGJvZHkgPSBfOyB9IC0+XG4gICAgcS5pbnNlcnQgPC0gYzsgcS5ib2R5IDwtIGNcblxuXG5leGNlcHRpb24gRW1wdHlfcXVldWVcblxubGV0IHBlZWtfcXVldWUgPSBmdW5jdGlvblxuICB8IHsgYm9keSA9IENvbnMgeyBoZWFkID0geDsgdGFpbCA9IF87IH07IF8gfSAtPiB4XG4gIHwgeyBib2R5ID0gTmlsOyBpbnNlcnQgPSBfOyB9IC0+IHJhaXNlIEVtcHR5X3F1ZXVlXG5cblxubGV0IHRha2VfcXVldWUgPSBmdW5jdGlvblxuICB8IHsgYm9keSA9IENvbnMgeyBoZWFkID0geDsgdGFpbCA9IHRsOyB9OyBfIH0gYXMgcSAtPlxuICAgIHEuYm9keSA8LSB0bDtcbiAgICBpZiB0bCA9IE5pbCB0aGVuIHEuaW5zZXJ0IDwtIE5pbDsgKCogTWFpbnRhaW4gdGhlIGludmFyaWFudC4gKilcbiAgICB4XG4gIHwgeyBib2R5ID0gTmlsOyBpbnNlcnQgPSBfOyB9IC0+IHJhaXNlIEVtcHR5X3F1ZXVlXG5cblxuKCogRW50ZXIgYSB0b2tlbiBpbiB0aGUgcHJldHR5LXByaW50ZXIgcXVldWUuICopXG5sZXQgcHBfZW5xdWV1ZSBzdGF0ZSAoeyBsZW5ndGggPSBsZW47IF99IGFzIHRva2VuKSA9XG4gIHN0YXRlLnBwX3JpZ2h0X3RvdGFsIDwtIHN0YXRlLnBwX3JpZ2h0X3RvdGFsICsgbGVuO1xuICBhZGRfcXVldWUgdG9rZW4gc3RhdGUucHBfcXVldWVcblxuXG5sZXQgcHBfY2xlYXJfcXVldWUgc3RhdGUgPVxuICBzdGF0ZS5wcF9sZWZ0X3RvdGFsIDwtIDE7IHN0YXRlLnBwX3JpZ2h0X3RvdGFsIDwtIDE7XG4gIGNsZWFyX3F1ZXVlIHN0YXRlLnBwX3F1ZXVlXG5cblxuKCogUHBfaW5maW5pdHk6IGxhcmdlIHZhbHVlIGZvciBkZWZhdWx0IHRva2VucyBzaXplLlxuXG4gICBQcF9pbmZpbml0eSBpcyBkb2N1bWVudGVkIGFzIGJlaW5nIGdyZWF0ZXIgdGhhbiAxZTEwOyB0byBhdm9pZFxuICAgY29uZnVzaW9uIGFib3V0IHRoZSB3b3JkICdncmVhdGVyJywgd2UgY2hvb3NlIHBwX2luZmluaXR5IGdyZWF0ZXJcbiAgIHRoYW4gMWUxMCArIDE7IGZvciBjb3JyZWN0IGhhbmRsaW5nIG9mIHRlc3RzIGluIHRoZSBhbGdvcml0aG0sXG4gICBwcF9pbmZpbml0eSBtdXN0IGJlIGV2ZW4gb25lIG1vcmUgdGhhbiAxZTEwICsgMTsgbGV0J3Mgc3RhbmQgb24gdGhlXG4gICBzYWZlIHNpZGUgYnkgY2hvb3NpbmcgMS5lMTArMTAuXG5cbiAgIFBwX2luZmluaXR5IGNvdWxkIHByb2JhYmx5IGJlIDEwNzM3NDE4MjMgdGhhdCBpcyAyXjMwIC0gMSwgdGhhdCBpc1xuICAgdGhlIG1pbmltYWwgdXBwZXIgYm91bmQgZm9yIGludGVnZXJzOyBub3cgdGhhdCBtYXhfaW50IGlzIGRlZmluZWQsXG4gICB0aGlzIGxpbWl0IGNvdWxkIGFsc28gYmUgZGVmaW5lZCBhcyBtYXhfaW50IC0gMS5cblxuICAgSG93ZXZlciwgYmVmb3JlIHNldHRpbmcgcHBfaW5maW5pdHkgdG8gc29tZXRoaW5nIGFyb3VuZCBtYXhfaW50LCB3ZVxuICAgbXVzdCBjYXJlZnVsbHkgZG91YmxlLWNoZWNrIGFsbCB0aGUgaW50ZWdlciBhcml0aG1ldGljIG9wZXJhdGlvbnNcbiAgIHRoYXQgaW52b2x2ZSBwcF9pbmZpbml0eSwgc2luY2UgYW55IG92ZXJmbG93IHdvdWxkIHdyZWNrIGhhdm9jIHRoZVxuICAgcHJldHR5LXByaW50aW5nIGFsZ29yaXRobSdzIGludmFyaWFudHMuIEdpdmVuIHRoYXQgdGhpcyBhcml0aG1ldGljXG4gICBjb3JyZWN0bmVzcyBjaGVjayBpcyBkaWZmaWN1bHQgYW5kIGVycm9yIHByb25lIGFuZCBnaXZlbiB0aGF0IDFlMTBcbiAgICsgMSBpcyBpbiBwcmFjdGljZSBsYXJnZSBlbm91Z2gsIHRoZXJlIGlzIG5vIG5lZWQgdG8gYXR0ZW1wdCB0byBzZXRcbiAgIHBwX2luZmluaXR5IHRvIHRoZSB0aGVvcmV0aWNhbGx5IG1heGltdW0gbGltaXQuIEl0IGlzIG5vdCB3b3J0aCB0aGVcbiAgIGJ1cmRlbiAhICopXG5sZXQgcHBfaW5maW5pdHkgPSAxMDAwMDAwMDEwXG5cbigqIE91dHB1dCBmdW5jdGlvbnMgZm9yIHRoZSBmb3JtYXR0ZXIuICopXG5sZXQgcHBfb3V0cHV0X3N0cmluZyBzdGF0ZSBzID0gc3RhdGUucHBfb3V0X3N0cmluZyBzIDAgKFN0cmluZy5sZW5ndGggcylcbmFuZCBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZSA9IHN0YXRlLnBwX291dF9uZXdsaW5lICgpXG5hbmQgcHBfb3V0cHV0X3NwYWNlcyBzdGF0ZSBuID0gc3RhdGUucHBfb3V0X3NwYWNlcyBuXG5hbmQgcHBfb3V0cHV0X2luZGVudCBzdGF0ZSBuID0gc3RhdGUucHBfb3V0X2luZGVudCBuXG5cbigqIFRvIGZvcm1hdCBhIGJyZWFrLCBpbmRlbnRpbmcgYSBuZXcgbGluZS4gKilcbmxldCBicmVha19uZXdfbGluZSBzdGF0ZSBvZmZzZXQgd2lkdGggPVxuICBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZTtcbiAgc3RhdGUucHBfaXNfbmV3X2xpbmUgPC0gdHJ1ZTtcbiAgbGV0IGluZGVudCA9IHN0YXRlLnBwX21hcmdpbiAtIHdpZHRoICsgb2Zmc2V0IGluXG4gICgqIERvbid0IGluZGVudCBtb3JlIHRoYW4gcHBfbWF4X2luZGVudC4gKilcbiAgbGV0IHJlYWxfaW5kZW50ID0gbWluIHN0YXRlLnBwX21heF9pbmRlbnQgaW5kZW50IGluXG4gIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50IDwtIHJlYWxfaW5kZW50O1xuICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50O1xuICBwcF9vdXRwdXRfaW5kZW50IHN0YXRlIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50XG5cblxuKCogVG8gZm9yY2UgYSBsaW5lIGJyZWFrIGluc2lkZSBhIGJveDogbm8gb2Zmc2V0IGlzIGFkZGVkLiAqKVxubGV0IGJyZWFrX2xpbmUgc3RhdGUgd2lkdGggPSBicmVha19uZXdfbGluZSBzdGF0ZSAwIHdpZHRoXG5cbigqIFRvIGZvcm1hdCBhIGJyZWFrIHRoYXQgZml0cyBvbiB0aGUgY3VycmVudCBsaW5lLiAqKVxubGV0IGJyZWFrX3NhbWVfbGluZSBzdGF0ZSB3aWR0aCA9XG4gIHN0YXRlLnBwX3NwYWNlX2xlZnQgPC0gc3RhdGUucHBfc3BhY2VfbGVmdCAtIHdpZHRoO1xuICBwcF9vdXRwdXRfc3BhY2VzIHN0YXRlIHdpZHRoXG5cblxuKCogVG8gaW5kZW50IG5vIG1vcmUgdGhhbiBwcF9tYXhfaW5kZW50LCBpZiBvbmUgdHJpZXMgdG8gb3BlbiBhIGJveFxuICAgYmV5b25kIHBwX21heF9pbmRlbnQsIHRoZW4gdGhlIGJveCBpcyByZWplY3RlZCBvbiB0aGUgbGVmdFxuICAgYnkgc2ltdWxhdGluZyBhIGJyZWFrLiAqKVxubGV0IHBwX2ZvcmNlX2JyZWFrX2xpbmUgc3RhdGUgPVxuICBtYXRjaCBzdGF0ZS5wcF9mb3JtYXRfc3RhY2sgd2l0aFxuICB8IEZvcm1hdF9lbGVtIChibF90eSwgd2lkdGgpIDo6IF8gLT5cbiAgICBpZiB3aWR0aCA+IHN0YXRlLnBwX3NwYWNlX2xlZnQgdGhlblxuICAgICAgKG1hdGNoIGJsX3R5IHdpdGhcbiAgICAgICB8IFBwX2ZpdHMgLT4gKCkgfCBQcF9oYm94IC0+ICgpXG4gICAgICAgfCBQcF92Ym94IHwgUHBfaHZib3ggfCBQcF9ob3Zib3ggfCBQcF9ib3ggLT5cbiAgICAgICAgIGJyZWFrX2xpbmUgc3RhdGUgd2lkdGgpXG4gIHwgW10gLT4gcHBfb3V0cHV0X25ld2xpbmUgc3RhdGVcblxuXG4oKiBUbyBza2lwIGEgdG9rZW4sIGlmIHRoZSBwcmV2aW91cyBsaW5lIGhhcyBiZWVuIGJyb2tlbi4gKilcbmxldCBwcF9za2lwX3Rva2VuIHN0YXRlID1cbiAgKCogV2hlbiBjYWxsaW5nIHBwX3NraXBfdG9rZW4gdGhlIHF1ZXVlIGNhbm5vdCBiZSBlbXB0eS4gKilcbiAgbWF0Y2ggdGFrZV9xdWV1ZSBzdGF0ZS5wcF9xdWV1ZSB3aXRoXG4gIHwgeyBlbGVtX3NpemUgPSBzaXplOyBsZW5ndGggPSBsZW47IHRva2VuID0gXzsgfSAtPlxuICAgIHN0YXRlLnBwX2xlZnRfdG90YWwgPC0gc3RhdGUucHBfbGVmdF90b3RhbCAtIGxlbjtcbiAgICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX3NwYWNlX2xlZnQgKyBpbnRfb2Zfc2l6ZSBzaXplXG5cblxuKCpcblxuICBUaGUgbWFpbiBwcmV0dHkgcHJpbnRpbmcgZnVuY3Rpb25zLlxuXG4qKVxuXG4oKiBGb3JtYXR0aW5nIGEgdG9rZW4gd2l0aCBhIGdpdmVuIHNpemUuICopXG5sZXQgZm9ybWF0X3BwX3Rva2VuIHN0YXRlIHNpemUgPSBmdW5jdGlvblxuXG4gIHwgUHBfdGV4dCBzIC0+XG4gICAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IC0gc2l6ZTtcbiAgICBwcF9vdXRwdXRfc3RyaW5nIHN0YXRlIHM7XG4gICAgc3RhdGUucHBfaXNfbmV3X2xpbmUgPC0gZmFsc2VcblxuICB8IFBwX2JlZ2luIChvZmYsIHR5KSAtPlxuICAgIGxldCBpbnNlcnRpb25fcG9pbnQgPSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IGluXG4gICAgaWYgaW5zZXJ0aW9uX3BvaW50ID4gc3RhdGUucHBfbWF4X2luZGVudCB0aGVuXG4gICAgICAoKiBjYW4gbm90IG9wZW4gYSBib3ggcmlnaHQgdGhlcmUuICopXG4gICAgICBiZWdpbiBwcF9mb3JjZV9icmVha19saW5lIHN0YXRlIGVuZDtcbiAgICBsZXQgb2Zmc2V0ID0gc3RhdGUucHBfc3BhY2VfbGVmdCAtIG9mZiBpblxuICAgIGxldCBibF90eXBlID1cbiAgICAgIGJlZ2luIG1hdGNoIHR5IHdpdGhcbiAgICAgIHwgUHBfdmJveCAtPiBQcF92Ym94XG4gICAgICB8IFBwX2hib3ggfCBQcF9odmJveCB8IFBwX2hvdmJveCB8IFBwX2JveCB8IFBwX2ZpdHMgLT5cbiAgICAgICAgaWYgc2l6ZSA+IHN0YXRlLnBwX3NwYWNlX2xlZnQgdGhlbiB0eSBlbHNlIFBwX2ZpdHNcbiAgICAgIGVuZCBpblxuICAgIHN0YXRlLnBwX2Zvcm1hdF9zdGFjayA8LVxuICAgICAgRm9ybWF0X2VsZW0gKGJsX3R5cGUsIG9mZnNldCkgOjogc3RhdGUucHBfZm9ybWF0X3N0YWNrXG5cbiAgfCBQcF9lbmQgLT5cbiAgICBiZWdpbiBtYXRjaCBzdGF0ZS5wcF9mb3JtYXRfc3RhY2sgd2l0aFxuICAgIHwgXyA6OiBscyAtPiBzdGF0ZS5wcF9mb3JtYXRfc3RhY2sgPC0gbHNcbiAgICB8IFtdIC0+ICgpICgqIE5vIG1vcmUgYm94IHRvIGNsb3NlLiAqKVxuICAgIGVuZFxuXG4gIHwgUHBfdGJlZ2luIChQcF90Ym94IF8gYXMgdGJveCkgLT5cbiAgICBzdGF0ZS5wcF90Ym94X3N0YWNrIDwtIHRib3ggOjogc3RhdGUucHBfdGJveF9zdGFja1xuXG4gIHwgUHBfdGVuZCAtPlxuICAgIGJlZ2luIG1hdGNoIHN0YXRlLnBwX3Rib3hfc3RhY2sgd2l0aFxuICAgIHwgXyA6OiBscyAtPiBzdGF0ZS5wcF90Ym94X3N0YWNrIDwtIGxzXG4gICAgfCBbXSAtPiAoKSAoKiBObyBtb3JlIHRhYnVsYXRpb24gYm94IHRvIGNsb3NlLiAqKVxuICAgIGVuZFxuXG4gIHwgUHBfc3RhYiAtPlxuICAgIGJlZ2luIG1hdGNoIHN0YXRlLnBwX3Rib3hfc3RhY2sgd2l0aFxuICAgIHwgUHBfdGJveCB0YWJzIDo6IF8gLT5cbiAgICAgIGxldCByZWMgYWRkX3RhYiBuID0gZnVuY3Rpb25cbiAgICAgICAgfCBbXSAtPiBbbl1cbiAgICAgICAgfCB4IDo6IGwgYXMgbHMgLT4gaWYgbiA8IHggdGhlbiBuIDo6IGxzIGVsc2UgeCA6OiBhZGRfdGFiIG4gbCBpblxuICAgICAgdGFicyA6PSBhZGRfdGFiIChzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9zcGFjZV9sZWZ0KSAhdGFic1xuICAgIHwgW10gLT4gKCkgKCogTm8gb3BlbiB0YWJ1bGF0aW9uIGJveC4gKilcbiAgICBlbmRcblxuICB8IFBwX3RicmVhayAobiwgb2ZmKSAtPlxuICAgIGxldCBpbnNlcnRpb25fcG9pbnQgPSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IGluXG4gICAgYmVnaW4gbWF0Y2ggc3RhdGUucHBfdGJveF9zdGFjayB3aXRoXG4gICAgfCBQcF90Ym94IHRhYnMgOjogXyAtPlxuICAgICAgbGV0IHJlYyBmaW5kIG4gPSBmdW5jdGlvblxuICAgICAgICB8IHggOjogbCAtPiBpZiB4ID49IG4gdGhlbiB4IGVsc2UgZmluZCBuIGxcbiAgICAgICAgfCBbXSAtPiByYWlzZSBOb3RfZm91bmQgaW5cbiAgICAgIGxldCB0YWIgPVxuICAgICAgICBtYXRjaCAhdGFicyB3aXRoXG4gICAgICAgIHwgeCA6OiBfIC0+XG4gICAgICAgICAgYmVnaW5cbiAgICAgICAgICAgIHRyeSBmaW5kIGluc2VydGlvbl9wb2ludCAhdGFicyB3aXRoXG4gICAgICAgICAgICB8IE5vdF9mb3VuZCAtPiB4XG4gICAgICAgICAgZW5kXG4gICAgICAgIHwgXyAtPiBpbnNlcnRpb25fcG9pbnQgaW5cbiAgICAgIGxldCBvZmZzZXQgPSB0YWIgLSBpbnNlcnRpb25fcG9pbnQgaW5cbiAgICAgIGlmIG9mZnNldCA+PSAwXG4gICAgICB0aGVuIGJyZWFrX3NhbWVfbGluZSBzdGF0ZSAob2Zmc2V0ICsgbilcbiAgICAgIGVsc2UgYnJlYWtfbmV3X2xpbmUgc3RhdGUgKHRhYiArIG9mZikgc3RhdGUucHBfbWFyZ2luXG4gICAgfCBbXSAtPiAoKSAoKiBObyBvcGVuIHRhYnVsYXRpb24gYm94LiAqKVxuICAgIGVuZFxuXG4gIHwgUHBfbmV3bGluZSAtPlxuICAgIGJlZ2luIG1hdGNoIHN0YXRlLnBwX2Zvcm1hdF9zdGFjayB3aXRoXG4gICAgfCBGb3JtYXRfZWxlbSAoXywgd2lkdGgpIDo6IF8gLT4gYnJlYWtfbGluZSBzdGF0ZSB3aWR0aFxuICAgIHwgW10gLT4gcHBfb3V0cHV0X25ld2xpbmUgc3RhdGUgKCogTm8gb3BlbiBib3guICopXG4gICAgZW5kXG5cbiAgfCBQcF9pZl9uZXdsaW5lIC0+XG4gICAgaWYgc3RhdGUucHBfY3VycmVudF9pbmRlbnQgIT0gc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfc3BhY2VfbGVmdFxuICAgIHRoZW4gcHBfc2tpcF90b2tlbiBzdGF0ZVxuXG4gIHwgUHBfYnJlYWsgKG4sIG9mZikgLT5cbiAgICBiZWdpbiBtYXRjaCBzdGF0ZS5wcF9mb3JtYXRfc3RhY2sgd2l0aFxuICAgIHwgRm9ybWF0X2VsZW0gKHR5LCB3aWR0aCkgOjogXyAtPlxuICAgICAgYmVnaW4gbWF0Y2ggdHkgd2l0aFxuICAgICAgfCBQcF9ob3Zib3ggLT5cbiAgICAgICAgaWYgc2l6ZSA+IHN0YXRlLnBwX3NwYWNlX2xlZnRcbiAgICAgICAgdGhlbiBicmVha19uZXdfbGluZSBzdGF0ZSBvZmYgd2lkdGhcbiAgICAgICAgZWxzZSBicmVha19zYW1lX2xpbmUgc3RhdGUgblxuICAgICAgfCBQcF9ib3ggLT5cbiAgICAgICAgKCogSGF2ZSB0aGUgbGluZSBqdXN0IGJlZW4gYnJva2VuIGhlcmUgPyAqKVxuICAgICAgICBpZiBzdGF0ZS5wcF9pc19uZXdfbGluZSB0aGVuIGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBuIGVsc2VcbiAgICAgICAgaWYgc2l6ZSA+IHN0YXRlLnBwX3NwYWNlX2xlZnRcbiAgICAgICAgIHRoZW4gYnJlYWtfbmV3X2xpbmUgc3RhdGUgb2ZmIHdpZHRoIGVsc2VcbiAgICAgICAgKCogYnJlYWsgdGhlIGxpbmUgaGVyZSBsZWFkcyB0byBuZXcgaW5kZW50YXRpb24gPyAqKVxuICAgICAgICBpZiBzdGF0ZS5wcF9jdXJyZW50X2luZGVudCA+IHN0YXRlLnBwX21hcmdpbiAtIHdpZHRoICsgb2ZmXG4gICAgICAgIHRoZW4gYnJlYWtfbmV3X2xpbmUgc3RhdGUgb2ZmIHdpZHRoXG4gICAgICAgIGVsc2UgYnJlYWtfc2FtZV9saW5lIHN0YXRlIG5cbiAgICAgIHwgUHBfaHZib3ggLT4gYnJlYWtfbmV3X2xpbmUgc3RhdGUgb2ZmIHdpZHRoXG4gICAgICB8IFBwX2ZpdHMgLT4gYnJlYWtfc2FtZV9saW5lIHN0YXRlIG5cbiAgICAgIHwgUHBfdmJveCAtPiBicmVha19uZXdfbGluZSBzdGF0ZSBvZmYgd2lkdGhcbiAgICAgIHwgUHBfaGJveCAtPiBicmVha19zYW1lX2xpbmUgc3RhdGUgblxuICAgICAgZW5kXG4gICAgfCBbXSAtPiAoKSAoKiBObyBvcGVuIGJveC4gKilcbiAgICBlbmRcblxuICAgfCBQcF9vcGVuX3RhZyB0YWdfbmFtZSAtPlxuICAgICBsZXQgbWFya2VyID0gc3RhdGUucHBfbWFya19vcGVuX3RhZyB0YWdfbmFtZSBpblxuICAgICBwcF9vdXRwdXRfc3RyaW5nIHN0YXRlIG1hcmtlcjtcbiAgICAgc3RhdGUucHBfbWFya19zdGFjayA8LSB0YWdfbmFtZSA6OiBzdGF0ZS5wcF9tYXJrX3N0YWNrXG5cbiAgIHwgUHBfY2xvc2VfdGFnIC0+XG4gICAgIGJlZ2luIG1hdGNoIHN0YXRlLnBwX21hcmtfc3RhY2sgd2l0aFxuICAgICB8IHRhZ19uYW1lIDo6IHRhZ3MgLT5cbiAgICAgICBsZXQgbWFya2VyID0gc3RhdGUucHBfbWFya19jbG9zZV90YWcgdGFnX25hbWUgaW5cbiAgICAgICBwcF9vdXRwdXRfc3RyaW5nIHN0YXRlIG1hcmtlcjtcbiAgICAgICBzdGF0ZS5wcF9tYXJrX3N0YWNrIDwtIHRhZ3NcbiAgICAgfCBbXSAtPiAoKSAoKiBObyBtb3JlIHRhZyB0byBjbG9zZS4gKilcbiAgICAgZW5kXG5cblxuKCogUHJpbnQgaWYgdG9rZW4gc2l6ZSBpcyBrbm93biBlbHNlIHByaW50aW5nIGlzIGRlbGF5ZWQuXG4gICBTaXplIGlzIGtub3duIHdoZW4gbm90IG5lZ2F0aXZlLlxuICAgUHJpbnRpbmcgaXMgZGVsYXllZCB3aGVuIHRoZSB0ZXh0IHdhaXRpbmcgaW4gdGhlIHF1ZXVlIHJlcXVpcmVzXG4gICBtb3JlIHJvb20gdG8gZm9ybWF0IHRoYW4gZXhpc3RzIG9uIHRoZSBjdXJyZW50IGxpbmUuXG5cbiAgIE5vdGU6IFthZHZhbmNlX2xvb3BdIG11c3QgYmUgdGFpbCByZWN1cnNpdmUgdG8gcHJldmVudCBzdGFjayBvdmVyZmxvd3MuICopXG5sZXQgcmVjIGFkdmFuY2VfbG9vcCBzdGF0ZSA9XG4gIG1hdGNoIHBlZWtfcXVldWUgc3RhdGUucHBfcXVldWUgd2l0aFxuICB8IHtlbGVtX3NpemUgPSBzaXplOyB0b2tlbiA9IHRvazsgbGVuZ3RoID0gbGVufSAtPlxuICAgIGxldCBzaXplID0gaW50X29mX3NpemUgc2l6ZSBpblxuICAgIGlmIG5vdFxuICAgICAgICAgKHNpemUgPCAwICYmXG4gICAgICAgICAgKHN0YXRlLnBwX3JpZ2h0X3RvdGFsIC0gc3RhdGUucHBfbGVmdF90b3RhbCA8IHN0YXRlLnBwX3NwYWNlX2xlZnQpKVxuICAgIHRoZW4gYmVnaW5cbiAgICAgIGlnbm9yZSAodGFrZV9xdWV1ZSBzdGF0ZS5wcF9xdWV1ZSk7XG4gICAgICBmb3JtYXRfcHBfdG9rZW4gc3RhdGUgKGlmIHNpemUgPCAwIHRoZW4gcHBfaW5maW5pdHkgZWxzZSBzaXplKSB0b2s7XG4gICAgICBzdGF0ZS5wcF9sZWZ0X3RvdGFsIDwtIGxlbiArIHN0YXRlLnBwX2xlZnRfdG90YWw7XG4gICAgICBhZHZhbmNlX2xvb3Agc3RhdGVcbiAgICBlbmRcblxuXG5sZXQgYWR2YW5jZV9sZWZ0IHN0YXRlID1cbiAgdHJ5IGFkdmFuY2VfbG9vcCBzdGF0ZSB3aXRoXG4gIHwgRW1wdHlfcXVldWUgLT4gKClcblxuXG4oKiBUbyBlbnF1ZXVlIGEgdG9rZW4gOiB0cnkgdG8gYWR2YW5jZS4gKilcbmxldCBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgdG9rID0gcHBfZW5xdWV1ZSBzdGF0ZSB0b2s7IGFkdmFuY2VfbGVmdCBzdGF0ZVxuXG4oKiBCdWlsZGluZyBwcmV0dHktcHJpbnRlciBxdWV1ZSBlbGVtZW50cy4gKilcbmxldCBtYWtlX3F1ZXVlX2VsZW0gc2l6ZSB0b2sgbGVuID1cbiAgeyBlbGVtX3NpemUgPSBzaXplOyB0b2tlbiA9IHRvazsgbGVuZ3RoID0gbGVuOyB9XG5cblxuKCogVG8gZW5xdWV1ZSBzdHJpbmdzLiAqKVxubGV0IGVucXVldWVfc3RyaW5nX2FzIHN0YXRlIHNpemUgcyA9XG4gIGxldCBsZW4gPSBpbnRfb2Zfc2l6ZSBzaXplIGluXG4gIGVucXVldWVfYWR2YW5jZSBzdGF0ZSAobWFrZV9xdWV1ZV9lbGVtIHNpemUgKFBwX3RleHQgcykgbGVuKVxuXG5cbmxldCBlbnF1ZXVlX3N0cmluZyBzdGF0ZSBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBlbnF1ZXVlX3N0cmluZ19hcyBzdGF0ZSAoc2l6ZV9vZl9pbnQgbGVuKSBzXG5cblxuKCogUm91dGluZXMgZm9yIHNjYW4gc3RhY2tcbiAgIGRldGVybWluZSBzaXplIG9mIGJveGVzLiAqKVxuXG4oKiBUaGUgc2Nhbl9zdGFjayBpcyBuZXZlciBlbXB0eS4gKilcbmxldCBzY2FuX3N0YWNrX2JvdHRvbSA9XG4gIGxldCBxX2VsZW0gPSBtYWtlX3F1ZXVlX2VsZW0gKHNpemVfb2ZfaW50ICgtMSkpIChQcF90ZXh0IFwiXCIpIDAgaW5cbiAgW1NjYW5fZWxlbSAoLTEsIHFfZWxlbSldXG5cblxuKCogQ2xlYXJpbmcgdGhlIHByZXR0eS1wcmludGVyIHNjYW5uaW5nIHN0YWNrLiAqKVxubGV0IGNsZWFyX3NjYW5fc3RhY2sgc3RhdGUgPSBzdGF0ZS5wcF9zY2FuX3N0YWNrIDwtIHNjYW5fc3RhY2tfYm90dG9tXG5cbigqIFNldHRpbmcgdGhlIHNpemUgb2YgYm94ZXMgb24gc2NhbiBzdGFjazpcbiAgIGlmIHR5ID0gdHJ1ZSB0aGVuIHNpemUgb2YgYnJlYWsgaXMgc2V0IGVsc2Ugc2l6ZSBvZiBib3ggaXMgc2V0O1xuICAgaW4gZWFjaCBjYXNlIHBwX3NjYW5fc3RhY2sgaXMgcG9wcGVkLlxuXG4gICBOb3RlOlxuICAgUGF0dGVybiBtYXRjaGluZyBvbiBzY2FuIHN0YWNrIGlzIGV4aGF1c3RpdmUsIHNpbmNlIHNjYW5fc3RhY2sgaXMgbmV2ZXJcbiAgIGVtcHR5LlxuICAgUGF0dGVybiBtYXRjaGluZyBvbiB0b2tlbiBpbiBzY2FuIHN0YWNrIGlzIGFsc28gZXhoYXVzdGl2ZSxcbiAgIHNpbmNlIHNjYW5fcHVzaCBpcyB1c2VkIG9uIGJyZWFrcyBhbmQgb3BlbmluZyBvZiBib3hlcy4gKilcbmxldCBzZXRfc2l6ZSBzdGF0ZSB0eSA9XG4gIG1hdGNoIHN0YXRlLnBwX3NjYW5fc3RhY2sgd2l0aFxuICB8IFNjYW5fZWxlbVxuICAgICAgKGxlZnRfdG90LFxuICAgICAgICh7IGVsZW1fc2l6ZSA9IHNpemU7IHRva2VuID0gdG9rOyBsZW5ndGggPSBfOyB9IGFzIHF1ZXVlX2VsZW0pKSA6OiB0IC0+XG4gICAgbGV0IHNpemUgPSBpbnRfb2Zfc2l6ZSBzaXplIGluXG4gICAgKCogdGVzdCBpZiBzY2FuIHN0YWNrIGNvbnRhaW5zIGFueSBkYXRhIHRoYXQgaXMgbm90IG9ic29sZXRlLiAqKVxuICAgIGlmIGxlZnRfdG90IDwgc3RhdGUucHBfbGVmdF90b3RhbCB0aGVuIGNsZWFyX3NjYW5fc3RhY2sgc3RhdGUgZWxzZVxuICAgICAgYmVnaW4gbWF0Y2ggdG9rIHdpdGhcbiAgICAgIHwgUHBfYnJlYWsgKF8sIF8pIHwgUHBfdGJyZWFrIChfLCBfKSAtPlxuICAgICAgICBpZiB0eSB0aGVuXG4gICAgICAgIGJlZ2luXG4gICAgICAgICAgcXVldWVfZWxlbS5lbGVtX3NpemUgPC0gc2l6ZV9vZl9pbnQgKHN0YXRlLnBwX3JpZ2h0X3RvdGFsICsgc2l6ZSk7XG4gICAgICAgICAgc3RhdGUucHBfc2Nhbl9zdGFjayA8LSB0XG4gICAgICAgIGVuZFxuICAgICAgfCBQcF9iZWdpbiAoXywgXykgLT5cbiAgICAgICAgaWYgbm90IHR5IHRoZW5cbiAgICAgICAgYmVnaW5cbiAgICAgICAgICBxdWV1ZV9lbGVtLmVsZW1fc2l6ZSA8LSBzaXplX29mX2ludCAoc3RhdGUucHBfcmlnaHRfdG90YWwgKyBzaXplKTtcbiAgICAgICAgICBzdGF0ZS5wcF9zY2FuX3N0YWNrIDwtIHRcbiAgICAgICAgZW5kXG4gICAgICB8IFBwX3RleHQgXyB8IFBwX3N0YWIgfCBQcF90YmVnaW4gXyB8IFBwX3RlbmQgfCBQcF9lbmRcbiAgICAgIHwgUHBfbmV3bGluZSB8IFBwX2lmX25ld2xpbmVcbiAgICAgIHwgUHBfb3Blbl90YWcgXyB8IFBwX2Nsb3NlX3RhZyAtPlxuICAgICAgICAoKSAoKiBzY2FuX3B1c2ggaXMgb25seSB1c2VkIGZvciBicmVha3MgYW5kIGJveGVzLiAqKVxuICAgICAgZW5kXG4gIHwgW10gLT4gKCkgKCogc2Nhbl9zdGFjayBpcyBuZXZlciBlbXB0eS4gKilcblxuXG4oKiBQdXNoIGEgdG9rZW4gb24gcHJldHR5LXByaW50ZXIgc2Nhbm5pbmcgc3RhY2suXG4gICBJZiBiIGlzIHRydWUgc2V0X3NpemUgaXMgY2FsbGVkLiAqKVxubGV0IHNjYW5fcHVzaCBzdGF0ZSBiIHRvayA9XG4gIHBwX2VucXVldWUgc3RhdGUgdG9rO1xuICBpZiBiIHRoZW4gc2V0X3NpemUgc3RhdGUgdHJ1ZTtcbiAgc3RhdGUucHBfc2Nhbl9zdGFjayA8LVxuICAgIFNjYW5fZWxlbSAoc3RhdGUucHBfcmlnaHRfdG90YWwsIHRvaykgOjogc3RhdGUucHBfc2Nhbl9zdGFja1xuXG5cbigqIFRvIG9wZW4gYSBuZXcgYm94IDpcbiAgIHRoZSB1c2VyIG1heSBzZXQgdGhlIGRlcHRoIGJvdW5kIHBwX21heF9ib3hlc1xuICAgYW55IHRleHQgbmVzdGVkIGRlZXBlciBpcyBwcmludGVkIGFzIHRoZSBlbGxpcHNpcyBzdHJpbmcuICopXG5sZXQgcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIGluZGVudCBicl90eSA9XG4gIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gc3RhdGUucHBfY3Vycl9kZXB0aCArIDE7XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBlbGVtID1cbiAgICAgIG1ha2VfcXVldWVfZWxlbVxuICAgICAgICAoc2l6ZV9vZl9pbnQgKC0gc3RhdGUucHBfcmlnaHRfdG90YWwpKVxuICAgICAgICAoUHBfYmVnaW4gKGluZGVudCwgYnJfdHkpKVxuICAgICAgICAwIGluXG4gICAgc2Nhbl9wdXNoIHN0YXRlIGZhbHNlIGVsZW0gZWxzZVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoID0gc3RhdGUucHBfbWF4X2JveGVzXG4gIHRoZW4gZW5xdWV1ZV9zdHJpbmcgc3RhdGUgc3RhdGUucHBfZWxsaXBzaXNcblxuXG4oKiBUaGUgYm94IHdoaWNoIGlzIGFsd2F5cyBvcGVuLiAqKVxubGV0IHBwX29wZW5fc3lzX2JveCBzdGF0ZSA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSAwIFBwX2hvdmJveFxuXG4oKiBDbG9zZSBhIGJveCwgc2V0dGluZyBzaXplcyBvZiBpdHMgc3ViIGJveGVzLiAqKVxubGV0IHBwX2Nsb3NlX2JveCBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPiAxIHRoZW5cbiAgYmVnaW5cbiAgICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBiZWdpblxuICAgICAgcHBfZW5xdWV1ZSBzdGF0ZVxuICAgICAgICB7IGVsZW1fc2l6ZSA9IHNpemVfb2ZfaW50IDA7IHRva2VuID0gUHBfZW5kOyBsZW5ndGggPSAwOyB9O1xuICAgICAgc2V0X3NpemUgc3RhdGUgdHJ1ZTsgc2V0X3NpemUgc3RhdGUgZmFsc2VcbiAgICBlbmQ7XG4gICAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSBzdGF0ZS5wcF9jdXJyX2RlcHRoIC0gMTtcbiAgZW5kXG5cblxuKCogT3BlbiBhIHRhZywgcHVzaGluZyBpdCBvbiB0aGUgdGFnIHN0YWNrLiAqKVxubGV0IHBwX29wZW5fdGFnIHN0YXRlIHRhZ19uYW1lID1cbiAgaWYgc3RhdGUucHBfcHJpbnRfdGFncyB0aGVuXG4gIGJlZ2luXG4gICAgc3RhdGUucHBfdGFnX3N0YWNrIDwtIHRhZ19uYW1lIDo6IHN0YXRlLnBwX3RhZ19zdGFjaztcbiAgICBzdGF0ZS5wcF9wcmludF9vcGVuX3RhZyB0YWdfbmFtZVxuICBlbmQ7XG4gIGlmIHN0YXRlLnBwX21hcmtfdGFncyB0aGVuXG4gICAgcHBfZW5xdWV1ZSBzdGF0ZSB7XG4gICAgICBlbGVtX3NpemUgPSBzaXplX29mX2ludCAwO1xuICAgICAgdG9rZW4gPSBQcF9vcGVuX3RhZyB0YWdfbmFtZTtcbiAgICAgIGxlbmd0aCA9IDA7XG4gICAgfVxuXG5cbigqIENsb3NlIGEgdGFnLCBwb3BwaW5nIGl0IGZyb20gdGhlIHRhZyBzdGFjay4gKilcbmxldCBwcF9jbG9zZV90YWcgc3RhdGUgKCkgPVxuICBpZiBzdGF0ZS5wcF9tYXJrX3RhZ3MgdGhlblxuICAgIHBwX2VucXVldWUgc3RhdGUge1xuICAgICAgZWxlbV9zaXplID0gc2l6ZV9vZl9pbnQgMDtcbiAgICAgIHRva2VuID0gUHBfY2xvc2VfdGFnO1xuICAgICAgbGVuZ3RoID0gMDtcbiAgICB9O1xuICBpZiBzdGF0ZS5wcF9wcmludF90YWdzIHRoZW5cbiAgYmVnaW5cbiAgICBtYXRjaCBzdGF0ZS5wcF90YWdfc3RhY2sgd2l0aFxuICAgIHwgdGFnX25hbWUgOjogdGFncyAtPlxuICAgICAgc3RhdGUucHBfcHJpbnRfY2xvc2VfdGFnIHRhZ19uYW1lO1xuICAgICAgc3RhdGUucHBfdGFnX3N0YWNrIDwtIHRhZ3NcbiAgICB8IF8gLT4gKCkgKCogTm8gbW9yZSB0YWcgdG8gY2xvc2UuICopXG4gIGVuZFxuXG5cbmxldCBwcF9zZXRfcHJpbnRfdGFncyBzdGF0ZSBiID0gc3RhdGUucHBfcHJpbnRfdGFncyA8LSBiXG5sZXQgcHBfc2V0X21hcmtfdGFncyBzdGF0ZSBiID0gc3RhdGUucHBfbWFya190YWdzIDwtIGJcbmxldCBwcF9nZXRfcHJpbnRfdGFncyBzdGF0ZSAoKSA9IHN0YXRlLnBwX3ByaW50X3RhZ3NcbmxldCBwcF9nZXRfbWFya190YWdzIHN0YXRlICgpID0gc3RhdGUucHBfbWFya190YWdzXG5sZXQgcHBfc2V0X3RhZ3Mgc3RhdGUgYiA9XG4gIHBwX3NldF9wcmludF90YWdzIHN0YXRlIGI7IHBwX3NldF9tYXJrX3RhZ3Mgc3RhdGUgYlxuXG5cbigqIEhhbmRsaW5nIHRhZyBoYW5kbGluZyBmdW5jdGlvbnM6IGdldC9zZXQgZnVuY3Rpb25zLiAqKVxubGV0IHBwX2dldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyBzdGF0ZSAoKSA9IHtcbiAgbWFya19vcGVuX3RhZyA9IHN0YXRlLnBwX21hcmtfb3Blbl90YWc7XG4gIG1hcmtfY2xvc2VfdGFnID0gc3RhdGUucHBfbWFya19jbG9zZV90YWc7XG4gIHByaW50X29wZW5fdGFnID0gc3RhdGUucHBfcHJpbnRfb3Blbl90YWc7XG4gIHByaW50X2Nsb3NlX3RhZyA9IHN0YXRlLnBwX3ByaW50X2Nsb3NlX3RhZztcbn1cblxuXG5sZXQgcHBfc2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIHN0YXRlIHtcbiAgICAgbWFya19vcGVuX3RhZyA9IG1vdDtcbiAgICAgbWFya19jbG9zZV90YWcgPSBtY3Q7XG4gICAgIHByaW50X29wZW5fdGFnID0gcG90O1xuICAgICBwcmludF9jbG9zZV90YWcgPSBwY3Q7XG4gIH0gPVxuICBzdGF0ZS5wcF9tYXJrX29wZW5fdGFnIDwtIG1vdDtcbiAgc3RhdGUucHBfbWFya19jbG9zZV90YWcgPC0gbWN0O1xuICBzdGF0ZS5wcF9wcmludF9vcGVuX3RhZyA8LSBwb3Q7XG4gIHN0YXRlLnBwX3ByaW50X2Nsb3NlX3RhZyA8LSBwY3RcblxuXG4oKiBJbml0aWFsaXplIHByZXR0eS1wcmludGVyLiAqKVxubGV0IHBwX3Jpbml0IHN0YXRlID1cbiAgcHBfY2xlYXJfcXVldWUgc3RhdGU7XG4gIGNsZWFyX3NjYW5fc3RhY2sgc3RhdGU7XG4gIHN0YXRlLnBwX2Zvcm1hdF9zdGFjayA8LSBbXTtcbiAgc3RhdGUucHBfdGJveF9zdGFjayA8LSBbXTtcbiAgc3RhdGUucHBfdGFnX3N0YWNrIDwtIFtdO1xuICBzdGF0ZS5wcF9tYXJrX3N0YWNrIDwtIFtdO1xuICBzdGF0ZS5wcF9jdXJyZW50X2luZGVudCA8LSAwO1xuICBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwtIDA7XG4gIHN0YXRlLnBwX3NwYWNlX2xlZnQgPC0gc3RhdGUucHBfbWFyZ2luO1xuICBwcF9vcGVuX3N5c19ib3ggc3RhdGVcblxubGV0IGNsZWFyX3RhZ19zdGFjayBzdGF0ZSA9XG4gIExpc3QuaXRlclxuICAgIChmdW4gXyAtPiBwcF9jbG9zZV90YWcgc3RhdGUgKCkpXG4gICAgc3RhdGUucHBfdGFnX3N0YWNrXG5cblxuKCogRmx1c2hpbmcgcHJldHR5LXByaW50ZXIgcXVldWUuICopXG5sZXQgcHBfZmx1c2hfcXVldWUgc3RhdGUgYiA9XG4gIGNsZWFyX3RhZ19zdGFjayBzdGF0ZTtcbiAgd2hpbGUgc3RhdGUucHBfY3Vycl9kZXB0aCA+IDEgZG9cbiAgICBwcF9jbG9zZV9ib3ggc3RhdGUgKClcbiAgZG9uZTtcbiAgc3RhdGUucHBfcmlnaHRfdG90YWwgPC0gcHBfaW5maW5pdHk7XG4gIGFkdmFuY2VfbGVmdCBzdGF0ZTtcbiAgaWYgYiB0aGVuIHBwX291dHB1dF9uZXdsaW5lIHN0YXRlO1xuICBwcF9yaW5pdCBzdGF0ZVxuXG4oKlxuXG4gIFByb2NlZHVyZXMgdG8gZm9ybWF0IHZhbHVlcyBhbmQgdXNlIGJveGVzLlxuXG4qKVxuXG4oKiBUbyBmb3JtYXQgYSBzdHJpbmcuICopXG5sZXQgcHBfcHJpbnRfYXNfc2l6ZSBzdGF0ZSBzaXplIHMgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzXG4gIHRoZW4gZW5xdWV1ZV9zdHJpbmdfYXMgc3RhdGUgc2l6ZSBzXG5cblxubGV0IHBwX3ByaW50X2FzIHN0YXRlIGlzaXplIHMgPVxuICBwcF9wcmludF9hc19zaXplIHN0YXRlIChzaXplX29mX2ludCBpc2l6ZSkgc1xuXG5cbmxldCBwcF9wcmludF9zdHJpbmcgc3RhdGUgcyA9XG4gIHBwX3ByaW50X2FzIHN0YXRlIChTdHJpbmcubGVuZ3RoIHMpIHNcblxuXG4oKiBUbyBmb3JtYXQgYW4gaW50ZWdlci4gKilcbmxldCBwcF9wcmludF9pbnQgc3RhdGUgaSA9IHBwX3ByaW50X3N0cmluZyBzdGF0ZSAoc3RyaW5nX29mX2ludCBpKVxuXG4oKiBUbyBmb3JtYXQgYSBmbG9hdC4gKilcbmxldCBwcF9wcmludF9mbG9hdCBzdGF0ZSBmID0gcHBfcHJpbnRfc3RyaW5nIHN0YXRlIChzdHJpbmdfb2ZfZmxvYXQgZilcblxuKCogVG8gZm9ybWF0IGEgYm9vbGVhbi4gKilcbmxldCBwcF9wcmludF9ib29sIHN0YXRlIGIgPSBwcF9wcmludF9zdHJpbmcgc3RhdGUgKHN0cmluZ19vZl9ib29sIGIpXG5cbigqIFRvIGZvcm1hdCBhIGNoYXIuICopXG5sZXQgcHBfcHJpbnRfY2hhciBzdGF0ZSBjID1cbiAgcHBfcHJpbnRfYXMgc3RhdGUgMSAoU3RyaW5nLm1ha2UgMSBjKVxuXG5cbigqIE9wZW5pbmcgYm94ZXMuICopXG5sZXQgcHBfb3Blbl9oYm94IHN0YXRlICgpID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIDAgUHBfaGJveFxuYW5kIHBwX29wZW5fdmJveCBzdGF0ZSBpbmRlbnQgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IFBwX3Zib3hcblxuYW5kIHBwX29wZW5faHZib3ggc3RhdGUgaW5kZW50ID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIGluZGVudCBQcF9odmJveFxuYW5kIHBwX29wZW5faG92Ym94IHN0YXRlIGluZGVudCA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgUHBfaG92Ym94XG5hbmQgcHBfb3Blbl9ib3ggc3RhdGUgaW5kZW50ID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIGluZGVudCBQcF9ib3hcblxuXG4oKiBQcmludGluZyBxdWV1ZWQgdGV4dC5cblxuICAgW3BwX3ByaW50X2ZsdXNoXSBwcmludHMgYWxsIHBlbmRpbmcgaXRlbXMgaW4gdGhlIHByZXR0eS1wcmludGVyIHF1ZXVlIGFuZFxuICAgdGhlbiBmbHVzaGVzIHRoZSBsb3cgbGV2ZWwgb3V0cHV0IGRldmljZSBvZiB0aGUgZm9ybWF0dGVyIHRvIGFjdHVhbGx5XG4gICBkaXNwbGF5IHByaW50aW5nIG1hdGVyaWFsLlxuXG4gICBbcHBfcHJpbnRfbmV3bGluZV0gYmVoYXZlcyBhcyBbcHBfcHJpbnRfZmx1c2hdIGFmdGVyIHByaW50aW5nIGFuIGFkZGl0aW9uYWxcbiAgIG5ldyBsaW5lLiAqKVxubGV0IHBwX3ByaW50X25ld2xpbmUgc3RhdGUgKCkgPVxuICBwcF9mbHVzaF9xdWV1ZSBzdGF0ZSB0cnVlOyBzdGF0ZS5wcF9vdXRfZmx1c2ggKClcbmFuZCBwcF9wcmludF9mbHVzaCBzdGF0ZSAoKSA9XG4gIHBwX2ZsdXNoX3F1ZXVlIHN0YXRlIGZhbHNlOyBzdGF0ZS5wcF9vdXRfZmx1c2ggKClcblxuXG4oKiBUbyBnZXQgYSBuZXdsaW5lIHdoZW4gb25lIGRvZXMgbm90IHdhbnQgdG8gY2xvc2UgdGhlIGN1cnJlbnQgYm94LiAqKVxubGV0IHBwX2ZvcmNlX25ld2xpbmUgc3RhdGUgKCkgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgKG1ha2VfcXVldWVfZWxlbSAoc2l6ZV9vZl9pbnQgMCkgUHBfbmV3bGluZSAwKVxuXG5cbigqIFRvIGZvcm1hdCBzb21ldGhpbmcsIG9ubHkgaW4gY2FzZSB0aGUgbGluZSBoYXMganVzdCBiZWVuIGJyb2tlbi4gKilcbmxldCBwcF9wcmludF9pZl9uZXdsaW5lIHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIChtYWtlX3F1ZXVlX2VsZW0gKHNpemVfb2ZfaW50IDApIFBwX2lmX25ld2xpbmUgMClcblxuXG4oKiBQcmludGluZyBicmVhayBoaW50czpcbiAgIEEgYnJlYWsgaGludCBpbmRpY2F0ZXMgd2hlcmUgYSBib3ggbWF5IGJlIGJyb2tlbi5cbiAgIElmIGxpbmUgaXMgYnJva2VuIHRoZW4gb2Zmc2V0IGlzIGFkZGVkIHRvIHRoZSBpbmRlbnRhdGlvbiBvZiB0aGUgY3VycmVudFxuICAgYm94IGVsc2UgKHRoZSB2YWx1ZSBvZikgd2lkdGggYmxhbmtzIGFyZSBwcmludGVkLiAqKVxubGV0IHBwX3ByaW50X2JyZWFrIHN0YXRlIHdpZHRoIG9mZnNldCA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBlbGVtID1cbiAgICAgIG1ha2VfcXVldWVfZWxlbVxuICAgICAgICAoc2l6ZV9vZl9pbnQgKC0gc3RhdGUucHBfcmlnaHRfdG90YWwpKVxuICAgICAgICAoUHBfYnJlYWsgKHdpZHRoLCBvZmZzZXQpKVxuICAgICAgICB3aWR0aCBpblxuICAgIHNjYW5fcHVzaCBzdGF0ZSB0cnVlIGVsZW1cblxuXG4oKiBQcmludCBhIHNwYWNlIDpcbiAgIGEgc3BhY2UgaXMgYSBicmVhayBoaW50IHRoYXQgcHJpbnRzIGEgc2luZ2xlIHNwYWNlIGlmIHRoZSBicmVhayBkb2VzIG5vdFxuICAgc3BsaXQgdGhlIGxpbmU7XG4gICBhIGN1dCBpcyBhIGJyZWFrIGhpbnQgdGhhdCBwcmludHMgbm90aGluZyBpZiB0aGUgYnJlYWsgZG9lcyBub3Qgc3BsaXQgdGhlXG4gICBsaW5lLiAqKVxubGV0IHBwX3ByaW50X3NwYWNlIHN0YXRlICgpID0gcHBfcHJpbnRfYnJlYWsgc3RhdGUgMSAwXG5hbmQgcHBfcHJpbnRfY3V0IHN0YXRlICgpID0gcHBfcHJpbnRfYnJlYWsgc3RhdGUgMCAwXG5cblxuKCogVGFidWxhdGlvbiBib3hlcy4gKilcbmxldCBwcF9vcGVuX3Rib3ggc3RhdGUgKCkgPVxuICBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwtIHN0YXRlLnBwX2N1cnJfZGVwdGggKyAxO1xuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBsZXQgZWxlbSA9XG4gICAgICBtYWtlX3F1ZXVlX2VsZW0gKHNpemVfb2ZfaW50IDApIChQcF90YmVnaW4gKFBwX3Rib3ggKHJlZiBbXSkpKSAwIGluXG4gICAgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIGVsZW1cblxuXG4oKiBDbG9zZSBhIHRhYnVsYXRpb24gYm94LiAqKVxubGV0IHBwX2Nsb3NlX3Rib3ggc3RhdGUgKCkgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoID4gMSB0aGVuXG4gIGJlZ2luXG4gICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICAgbGV0IGVsZW0gPSBtYWtlX3F1ZXVlX2VsZW0gKHNpemVfb2ZfaW50IDApIFBwX3RlbmQgMCBpblxuICAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgZWxlbTtcbiAgICAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSBzdGF0ZS5wcF9jdXJyX2RlcHRoIC0gMVxuICBlbmRcblxuXG4oKiBQcmludCBhIHRhYnVsYXRpb24gYnJlYWsuICopXG5sZXQgcHBfcHJpbnRfdGJyZWFrIHN0YXRlIHdpZHRoIG9mZnNldCA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBlbGVtID1cbiAgICAgIG1ha2VfcXVldWVfZWxlbVxuICAgICAgICAoc2l6ZV9vZl9pbnQgKC0gc3RhdGUucHBfcmlnaHRfdG90YWwpKVxuICAgICAgICAoUHBfdGJyZWFrICh3aWR0aCwgb2Zmc2V0KSlcbiAgICAgICAgd2lkdGggaW5cbiAgICBzY2FuX3B1c2ggc3RhdGUgdHJ1ZSBlbGVtXG5cblxubGV0IHBwX3ByaW50X3RhYiBzdGF0ZSAoKSA9IHBwX3ByaW50X3RicmVhayBzdGF0ZSAwIDBcblxubGV0IHBwX3NldF90YWIgc3RhdGUgKCkgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBsZXQgZWxlbSA9XG4gICAgICBtYWtlX3F1ZXVlX2VsZW0gKHNpemVfb2ZfaW50IDApIFBwX3N0YWIgMCBpblxuICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZSBlbGVtXG5cblxuKCpcblxuICBQcm9jZWR1cmVzIHRvIGNvbnRyb2wgdGhlIHByZXR0eS1wcmludGVyc1xuXG4qKVxuXG4oKiBTZXRfbWF4X2JveGVzLiAqKVxubGV0IHBwX3NldF9tYXhfYm94ZXMgc3RhdGUgbiA9IGlmIG4gPiAxIHRoZW4gc3RhdGUucHBfbWF4X2JveGVzIDwtIG5cblxuKCogVG8ga25vdyB0aGUgY3VycmVudCBtYXhpbXVtIG51bWJlciBvZiBib3hlcyBhbGxvd2VkLiAqKVxubGV0IHBwX2dldF9tYXhfYm94ZXMgc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXhfYm94ZXNcblxubGV0IHBwX292ZXJfbWF4X2JveGVzIHN0YXRlICgpID0gc3RhdGUucHBfY3Vycl9kZXB0aCA9IHN0YXRlLnBwX21heF9ib3hlc1xuXG4oKiBFbGxpcHNpcy4gKilcbmxldCBwcF9zZXRfZWxsaXBzaXNfdGV4dCBzdGF0ZSBzID0gc3RhdGUucHBfZWxsaXBzaXMgPC0gc1xuYW5kIHBwX2dldF9lbGxpcHNpc190ZXh0IHN0YXRlICgpID0gc3RhdGUucHBfZWxsaXBzaXNcblxuXG4oKiBUbyBzZXQgdGhlIG1hcmdpbiBvZiBwcmV0dHktcHJpbnRlci4gKilcbmxldCBwcF9saW1pdCBuID1cbiAgaWYgbiA8IHBwX2luZmluaXR5IHRoZW4gbiBlbHNlIHByZWQgcHBfaW5maW5pdHlcblxuXG4oKiBJbnRlcm5hbCBwcmV0dHktcHJpbnRlciBmdW5jdGlvbnMuICopXG5sZXQgcHBfc2V0X21pbl9zcGFjZV9sZWZ0IHN0YXRlIG4gPVxuICBpZiBuID49IDEgdGhlblxuICAgIGxldCBuID0gcHBfbGltaXQgbiBpblxuICAgIHN0YXRlLnBwX21pbl9zcGFjZV9sZWZ0IDwtIG47XG4gICAgc3RhdGUucHBfbWF4X2luZGVudCA8LSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9taW5fc3BhY2VfbGVmdDtcbiAgICBwcF9yaW5pdCBzdGF0ZVxuXG5cbigqIEluaXRpYWxseSwgd2UgaGF2ZSA6XG4gICBwcF9tYXhfaW5kZW50ID0gcHBfbWFyZ2luIC0gcHBfbWluX3NwYWNlX2xlZnQsIGFuZFxuICAgcHBfc3BhY2VfbGVmdCA9IHBwX21hcmdpbi4gKilcbmxldCBwcF9zZXRfbWF4X2luZGVudCBzdGF0ZSBuID1cbiAgcHBfc2V0X21pbl9zcGFjZV9sZWZ0IHN0YXRlIChzdGF0ZS5wcF9tYXJnaW4gLSBuKVxuXG5cbmxldCBwcF9nZXRfbWF4X2luZGVudCBzdGF0ZSAoKSA9IHN0YXRlLnBwX21heF9pbmRlbnRcblxubGV0IHBwX3NldF9tYXJnaW4gc3RhdGUgbiA9XG4gIGlmIG4gPj0gMSB0aGVuXG4gICAgbGV0IG4gPSBwcF9saW1pdCBuIGluXG4gICAgc3RhdGUucHBfbWFyZ2luIDwtIG47XG4gICAgbGV0IG5ld19tYXhfaW5kZW50ID1cbiAgICAgICgqIFRyeSB0byBtYWludGFpbiBtYXhfaW5kZW50IHRvIGl0cyBhY3R1YWwgdmFsdWUuICopXG4gICAgICBpZiBzdGF0ZS5wcF9tYXhfaW5kZW50IDw9IHN0YXRlLnBwX21hcmdpblxuICAgICAgdGhlbiBzdGF0ZS5wcF9tYXhfaW5kZW50IGVsc2VcbiAgICAgICgqIElmIHBvc3NpYmxlIG1haW50YWluIHBwX21pbl9zcGFjZV9sZWZ0IHRvIGl0cyBhY3R1YWwgdmFsdWUsXG4gICAgICAgICBpZiB0aGlzIGxlYWRzIHRvIGEgdG9vIHNtYWxsIG1heF9pbmRlbnQsIHRha2UgaGFsZiBvZiB0aGVcbiAgICAgICAgIG5ldyBtYXJnaW4sIGlmIGl0IGlzIGdyZWF0ZXIgdGhhbiAxLiAqKVxuICAgICAgIG1heCAobWF4IChzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9taW5fc3BhY2VfbGVmdClcbiAgICAgICAgICAgICAgICAoc3RhdGUucHBfbWFyZ2luIC8gMikpIDEgaW5cbiAgICAoKiBSZWJ1aWxkIGludmFyaWFudHMuICopXG4gICAgcHBfc2V0X21heF9pbmRlbnQgc3RhdGUgbmV3X21heF9pbmRlbnRcblxuXG5sZXQgcHBfZ2V0X21hcmdpbiBzdGF0ZSAoKSA9IHN0YXRlLnBwX21hcmdpblxuXG4oKiBTZXR0aW5nIGEgZm9ybWF0dGVyIGJhc2ljIG91dHB1dCBmdW5jdGlvbnMuICopXG5sZXQgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIHN0YXRlIHtcbiAgICAgIG91dF9zdHJpbmcgPSBmO1xuICAgICAgb3V0X2ZsdXNoID0gZztcbiAgICAgIG91dF9uZXdsaW5lID0gaDtcbiAgICAgIG91dF9zcGFjZXMgPSBpO1xuICAgICAgb3V0X2luZGVudCA9IGo7XG4gICAgfSA9XG4gIHN0YXRlLnBwX291dF9zdHJpbmcgPC0gZjtcbiAgc3RhdGUucHBfb3V0X2ZsdXNoIDwtIGc7XG4gIHN0YXRlLnBwX291dF9uZXdsaW5lIDwtIGg7XG4gIHN0YXRlLnBwX291dF9zcGFjZXMgPC0gaTtcbiAgc3RhdGUucHBfb3V0X2luZGVudCA8LSBqXG5cbmxldCBwcF9nZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgc3RhdGUgKCkgPSB7XG4gIG91dF9zdHJpbmcgPSBzdGF0ZS5wcF9vdXRfc3RyaW5nO1xuICBvdXRfZmx1c2ggPSBzdGF0ZS5wcF9vdXRfZmx1c2g7XG4gIG91dF9uZXdsaW5lID0gc3RhdGUucHBfb3V0X25ld2xpbmU7XG4gIG91dF9zcGFjZXMgPSBzdGF0ZS5wcF9vdXRfc3BhY2VzO1xuICBvdXRfaW5kZW50ID0gc3RhdGUucHBfb3V0X2luZGVudDtcbn1cblxuXG4oKiBTZXR0aW5nIGEgZm9ybWF0dGVyIGJhc2ljIHN0cmluZyBvdXRwdXQgYW5kIGZsdXNoIGZ1bmN0aW9ucy4gKilcbmxldCBwcF9zZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGUgZiBnID1cbiAgc3RhdGUucHBfb3V0X3N0cmluZyA8LSBmOyBzdGF0ZS5wcF9vdXRfZmx1c2ggPC0gZ1xuXG5sZXQgcHBfZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlICgpID1cbiAgKHN0YXRlLnBwX291dF9zdHJpbmcsIHN0YXRlLnBwX291dF9mbHVzaClcblxuXG4oKiBUaGUgZGVmYXVsdCBmdW5jdGlvbiB0byBvdXRwdXQgbmV3IGxpbmVzLiAqKVxubGV0IGRpc3BsYXlfbmV3bGluZSBzdGF0ZSAoKSA9IHN0YXRlLnBwX291dF9zdHJpbmcgXCJcXG5cIiAwICAxXG5cbigqIFRoZSBkZWZhdWx0IGZ1bmN0aW9uIHRvIG91dHB1dCBzcGFjZXMuICopXG5sZXQgYmxhbmtfbGluZSA9IFN0cmluZy5tYWtlIDgwICcgJ1xubGV0IHJlYyBkaXNwbGF5X2JsYW5rcyBzdGF0ZSBuID1cbiAgaWYgbiA+IDAgdGhlblxuICBpZiBuIDw9IDgwIHRoZW4gc3RhdGUucHBfb3V0X3N0cmluZyBibGFua19saW5lIDAgbiBlbHNlXG4gIGJlZ2luXG4gICAgc3RhdGUucHBfb3V0X3N0cmluZyBibGFua19saW5lIDAgODA7XG4gICAgZGlzcGxheV9ibGFua3Mgc3RhdGUgKG4gLSA4MClcbiAgZW5kXG5cblxuKCogVGhlIGRlZmF1bHQgZnVuY3Rpb24gdG8gb3V0cHV0IGluZGVudGF0aW9uIG9mIG5ldyBsaW5lcy4gKilcbmxldCBkaXNwbGF5X2luZGVudCA9IGRpc3BsYXlfYmxhbmtzXG5cbigqIFNldHRpbmcgYSBmb3JtYXR0ZXIgYmFzaWMgb3V0cHV0IGZ1bmN0aW9ucyBhcyBwcmludGluZyB0byBhIGdpdmVuXG4gICBbUGVydmFzaXZlLm91dF9jaGFubmVsXSB2YWx1ZS4gKilcbmxldCBwcF9zZXRfZm9ybWF0dGVyX291dF9jaGFubmVsIHN0YXRlIG9jID1cbiAgc3RhdGUucHBfb3V0X3N0cmluZyA8LSBvdXRwdXRfc3Vic3RyaW5nIG9jO1xuICBzdGF0ZS5wcF9vdXRfZmx1c2ggPC0gKGZ1biAoKSAtPiBmbHVzaCBvYyk7XG4gIHN0YXRlLnBwX291dF9uZXdsaW5lIDwtIGRpc3BsYXlfbmV3bGluZSBzdGF0ZTtcbiAgc3RhdGUucHBfb3V0X3NwYWNlcyA8LSBkaXNwbGF5X2JsYW5rcyBzdGF0ZTtcbiAgc3RhdGUucHBfb3V0X2luZGVudCA8LSBkaXNwbGF5X2luZGVudCBzdGF0ZVxuXG4oKlxuXG4gIERlZmluaW5nIHNwZWNpZmljIGZvcm1hdHRlcnNcblxuKilcblxubGV0IGRlZmF1bHRfcHBfbWFya19vcGVuX3RhZyBzID0gXCI8XCIgXiBzIF4gXCI+XCJcbmxldCBkZWZhdWx0X3BwX21hcmtfY2xvc2VfdGFnIHMgPSBcIjwvXCIgXiBzIF4gXCI+XCJcblxubGV0IGRlZmF1bHRfcHBfcHJpbnRfb3Blbl90YWcgPSBpZ25vcmVcbmxldCBkZWZhdWx0X3BwX3ByaW50X2Nsb3NlX3RhZyA9IGlnbm9yZVxuXG4oKiBCdWlsZGluZyBhIGZvcm1hdHRlciBnaXZlbiBpdHMgYmFzaWMgb3V0cHV0IGZ1bmN0aW9ucy5cbiAgIE90aGVyIGZpZWxkcyBnZXQgcmVhc29uYWJsZSBkZWZhdWx0IHZhbHVlcy4gKilcbmxldCBwcF9tYWtlX2Zvcm1hdHRlciBmIGcgaCBpIGogPVxuICAoKiBUaGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgZm9ybWF0dGVyIGNvbnRhaW5zIGEgZHVtbXkgYm94LiAqKVxuICBsZXQgcHBfcXVldWUgPSBtYWtlX3F1ZXVlICgpIGluXG4gIGxldCBzeXNfdG9rID1cbiAgICBtYWtlX3F1ZXVlX2VsZW0gKHNpemVfb2ZfaW50ICgtMSkpIChQcF9iZWdpbiAoMCwgUHBfaG92Ym94KSkgMCBpblxuICBhZGRfcXVldWUgc3lzX3RvayBwcF9xdWV1ZTtcbiAgbGV0IHN5c19zY2FuX3N0YWNrID1cbiAgICBTY2FuX2VsZW0gKDEsIHN5c190b2spIDo6IHNjYW5fc3RhY2tfYm90dG9tIGluXG4gIGxldCBwcF9tYXJnaW4gPSA3OFxuICBhbmQgcHBfbWluX3NwYWNlX2xlZnQgPSAxMCBpblxuICB7XG4gICAgcHBfc2Nhbl9zdGFjayA9IHN5c19zY2FuX3N0YWNrO1xuICAgIHBwX2Zvcm1hdF9zdGFjayA9IFtdO1xuICAgIHBwX3Rib3hfc3RhY2sgPSBbXTtcbiAgICBwcF90YWdfc3RhY2sgPSBbXTtcbiAgICBwcF9tYXJrX3N0YWNrID0gW107XG4gICAgcHBfbWFyZ2luID0gcHBfbWFyZ2luO1xuICAgIHBwX21pbl9zcGFjZV9sZWZ0ID0gcHBfbWluX3NwYWNlX2xlZnQ7XG4gICAgcHBfbWF4X2luZGVudCA9IHBwX21hcmdpbiAtIHBwX21pbl9zcGFjZV9sZWZ0O1xuICAgIHBwX3NwYWNlX2xlZnQgPSBwcF9tYXJnaW47XG4gICAgcHBfY3VycmVudF9pbmRlbnQgPSAwO1xuICAgIHBwX2lzX25ld19saW5lID0gdHJ1ZTtcbiAgICBwcF9sZWZ0X3RvdGFsID0gMTtcbiAgICBwcF9yaWdodF90b3RhbCA9IDE7XG4gICAgcHBfY3Vycl9kZXB0aCA9IDE7XG4gICAgcHBfbWF4X2JveGVzID0gbWF4X2ludDtcbiAgICBwcF9lbGxpcHNpcyA9IFwiLlwiO1xuICAgIHBwX291dF9zdHJpbmcgPSBmO1xuICAgIHBwX291dF9mbHVzaCA9IGc7XG4gICAgcHBfb3V0X25ld2xpbmUgPSBoO1xuICAgIHBwX291dF9zcGFjZXMgPSBpO1xuICAgIHBwX291dF9pbmRlbnQgPSBqO1xuICAgIHBwX3ByaW50X3RhZ3MgPSBmYWxzZTtcbiAgICBwcF9tYXJrX3RhZ3MgPSBmYWxzZTtcbiAgICBwcF9tYXJrX29wZW5fdGFnID0gZGVmYXVsdF9wcF9tYXJrX29wZW5fdGFnO1xuICAgIHBwX21hcmtfY2xvc2VfdGFnID0gZGVmYXVsdF9wcF9tYXJrX2Nsb3NlX3RhZztcbiAgICBwcF9wcmludF9vcGVuX3RhZyA9IGRlZmF1bHRfcHBfcHJpbnRfb3Blbl90YWc7XG4gICAgcHBfcHJpbnRfY2xvc2VfdGFnID0gZGVmYXVsdF9wcF9wcmludF9jbG9zZV90YWc7XG4gICAgcHBfcXVldWUgPSBwcF9xdWV1ZTtcbiAgfVxuXG5cbigqIEJ1aWxkIGEgZm9ybWF0dGVyIG91dCBvZiBpdHMgb3V0IGZ1bmN0aW9ucy4gKilcbmxldCBmb3JtYXR0ZXJfb2Zfb3V0X2Z1bmN0aW9ucyBvdXRfZnVucyA9XG4gIHBwX21ha2VfZm9ybWF0dGVyXG4gICAgb3V0X2Z1bnMub3V0X3N0cmluZ1xuICAgIG91dF9mdW5zLm91dF9mbHVzaFxuICAgIG91dF9mdW5zLm91dF9uZXdsaW5lXG4gICAgb3V0X2Z1bnMub3V0X3NwYWNlc1xuICAgIG91dF9mdW5zLm91dF9pbmRlbnRcblxuXG4oKiBNYWtlIGEgZm9ybWF0dGVyIHdpdGggZGVmYXVsdCBmdW5jdGlvbnMgdG8gb3V0cHV0IHNwYWNlcyxcbiAgaW5kZW50YXRpb24sIGFuZCBuZXcgbGluZXMuICopXG5sZXQgbWFrZV9mb3JtYXR0ZXIgb3V0cHV0IGZsdXNoID1cbiAgbGV0IHBwZiA9IHBwX21ha2VfZm9ybWF0dGVyIG91dHB1dCBmbHVzaCBpZ25vcmUgaWdub3JlIGlnbm9yZSBpblxuICBwcGYucHBfb3V0X25ld2xpbmUgPC0gZGlzcGxheV9uZXdsaW5lIHBwZjtcbiAgcHBmLnBwX291dF9zcGFjZXMgPC0gZGlzcGxheV9ibGFua3MgcHBmO1xuICBwcGYucHBfb3V0X2luZGVudCA8LSBkaXNwbGF5X2luZGVudCBwcGY7XG4gIHBwZlxuXG5cbigqIE1ha2UgYSBmb3JtYXR0ZXIgd3JpdGluZyB0byBhIGdpdmVuIFtQZXJ2YXNpdmUub3V0X2NoYW5uZWxdIHZhbHVlLiAqKVxubGV0IGZvcm1hdHRlcl9vZl9vdXRfY2hhbm5lbCBvYyA9XG4gIG1ha2VfZm9ybWF0dGVyIChvdXRwdXRfc3Vic3RyaW5nIG9jKSAoZnVuICgpIC0+IGZsdXNoIG9jKVxuXG5cbigqIE1ha2UgYSBmb3JtYXR0ZXIgd3JpdGluZyB0byBhIGdpdmVuIFtCdWZmZXIudF0gdmFsdWUuICopXG5sZXQgZm9ybWF0dGVyX29mX2J1ZmZlciBiID1cbiAgbWFrZV9mb3JtYXR0ZXIgKEJ1ZmZlci5hZGRfc3Vic3RyaW5nIGIpIGlnbm9yZVxuXG5cbigqIEFsbG9jYXRpbmcgYnVmZmVyIGZvciBwcmV0dHktcHJpbnRpbmcgcHVycG9zZXMuXG4gICBEZWZhdWx0IGJ1ZmZlciBzaXplIGlzIHBwX2J1ZmZlcl9zaXplIG9yIDUxMi5cbiopXG5sZXQgcHBfYnVmZmVyX3NpemUgPSA1MTJcbmxldCBwcF9tYWtlX2J1ZmZlciAoKSA9IEJ1ZmZlci5jcmVhdGUgcHBfYnVmZmVyX3NpemVcblxuKCogVGhlIHN0YW5kYXJkIChzaGFyZWQpIGJ1ZmZlci4gKilcbmxldCBzdGRidWYgPSBwcF9tYWtlX2J1ZmZlciAoKVxuXG4oKiBQcmVkZWZpbmVkIGZvcm1hdHRlcnMgc3RhbmRhcmQgZm9ybWF0dGVyIHRvIHByaW50XG4gICB0byBbUGVydmFzaXZlcy5zdGRvdXRdLCBbUGVydmFzaXZlcy5zdGRlcnJdLCBhbmQgeyFzdGRidWZ9LiAqKVxubGV0IHN0ZF9mb3JtYXR0ZXIgPSBmb3JtYXR0ZXJfb2Zfb3V0X2NoYW5uZWwgUGVydmFzaXZlcy5zdGRvdXRcbmFuZCBlcnJfZm9ybWF0dGVyID0gZm9ybWF0dGVyX29mX291dF9jaGFubmVsIFBlcnZhc2l2ZXMuc3RkZXJyXG5hbmQgc3RyX2Zvcm1hdHRlciA9IGZvcm1hdHRlcl9vZl9idWZmZXIgc3RkYnVmXG5cblxuKCogW2ZsdXNoX2J1ZmZlcl9mb3JtYXR0ZXIgYnVmIHBwZl0gZmx1c2hlcyBmb3JtYXR0ZXIgW3BwZl0sXG4gICB0aGVuIHJldHVybnMgdGhlIGNvbnRlbnRzIG9mIGJ1ZmZlciBbYnVmXSB0aGF0IGlzIHJlc2V0LlxuICAgRm9ybWF0dGVyIFtwcGZdIGlzIHN1cHBvc2VkIHRvIHByaW50IHRvIGJ1ZmZlciBbYnVmXSwgb3RoZXJ3aXNlIHRoaXNcbiAgIGZ1bmN0aW9uIGlzIG5vdCByZWFsbHkgdXNlZnVsLiAqKVxubGV0IGZsdXNoX2J1ZmZlcl9mb3JtYXR0ZXIgYnVmIHBwZiA9XG4gIHBwX2ZsdXNoX3F1ZXVlIHBwZiBmYWxzZTtcbiAgbGV0IHMgPSBCdWZmZXIuY29udGVudHMgYnVmIGluXG4gIEJ1ZmZlci5yZXNldCBidWY7XG4gIHNcblxuXG4oKiBGbHVzaCBbc3RyX2Zvcm1hdHRlcl0gYW5kIGdldCB0aGUgY29udGVudHMgb2YgW3N0ZGJ1Zl0uICopXG5sZXQgZmx1c2hfc3RyX2Zvcm1hdHRlciAoKSA9IGZsdXNoX2J1ZmZlcl9mb3JtYXR0ZXIgc3RkYnVmIHN0cl9mb3JtYXR0ZXJcblxuKCpcbiAgU3ltYm9saWMgcHJldHR5LXByaW50aW5nXG4qKVxuXG4oKlxuICBTeW1ib2xpYyBwcmV0dHktcHJpbnRpbmcgaXMgcHJldHR5LXByaW50aW5nIHdpdGggbm8gbG93IGxldmVsIG91dHB1dC5cblxuICBXaGVuIHVzaW5nIGEgc3ltYm9saWMgZm9ybWF0dGVyLCBhbGwgcmVndWxhciBwcmV0dHktcHJpbnRpbmcgYWN0aXZpdGllc1xuICBvY2N1ciBidXQgb3V0cHV0IG1hdGVyaWFsIGlzIHN5bWJvbGljIGFuZCBzdG9yZWQgaW4gYSBidWZmZXIgb2Ygb3V0cHV0XG4gIGl0ZW1zLiBBdCB0aGUgZW5kIG9mIHByZXR0eS1wcmludGluZywgZmx1c2hpbmcgdGhlIG91dHB1dCBidWZmZXIgYWxsb3dzXG4gIHBvc3QtcHJvY2Vzc2luZyBvZiBzeW1ib2xpYyBvdXRwdXQgYmVmb3JlIGxvdyBsZXZlbCBvdXRwdXQgb3BlcmF0aW9ucy5cbiopXG5cbnR5cGUgc3ltYm9saWNfb3V0cHV0X2l0ZW0gPVxuICB8IE91dHB1dF9mbHVzaFxuICB8IE91dHB1dF9uZXdsaW5lXG4gIHwgT3V0cHV0X3N0cmluZyBvZiBzdHJpbmdcbiAgfCBPdXRwdXRfc3BhY2VzIG9mIGludFxuICB8IE91dHB1dF9pbmRlbnQgb2YgaW50XG5cbnR5cGUgc3ltYm9saWNfb3V0cHV0X2J1ZmZlciA9IHtcbiAgbXV0YWJsZSBzeW1ib2xpY19vdXRwdXRfY29udGVudHMgOiBzeW1ib2xpY19vdXRwdXRfaXRlbSBsaXN0O1xufVxuXG5sZXQgbWFrZV9zeW1ib2xpY19vdXRwdXRfYnVmZmVyICgpID1cbiAgeyBzeW1ib2xpY19vdXRwdXRfY29udGVudHMgPSBbXSB9XG5cbmxldCBjbGVhcl9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIHNvYiA9XG4gIHNvYi5zeW1ib2xpY19vdXRwdXRfY29udGVudHMgPC0gW11cblxubGV0IGdldF9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIHNvYiA9XG4gIExpc3QucmV2IHNvYi5zeW1ib2xpY19vdXRwdXRfY29udGVudHNcblxubGV0IGZsdXNoX3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgbGV0IGl0ZW1zID0gZ2V0X3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iIGluXG4gIGNsZWFyX3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iO1xuICBpdGVtc1xuXG5sZXQgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiBpdGVtID1cbiAgc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50cyA8LSBpdGVtIDo6IHNvYi5zeW1ib2xpY19vdXRwdXRfY29udGVudHNcblxubGV0IGZvcm1hdHRlcl9vZl9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIHNvYiA9XG4gIGxldCBzeW1ib2xpY19mbHVzaCBzb2IgKCkgPVxuICAgIGFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSBzb2IgT3V0cHV0X2ZsdXNoXG4gIGFuZCBzeW1ib2xpY19uZXdsaW5lIHNvYiAoKSA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiBPdXRwdXRfbmV3bGluZVxuICBhbmQgc3ltYm9saWNfc3RyaW5nIHNvYiBzIGkgbiA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiAoT3V0cHV0X3N0cmluZyAoU3RyaW5nLnN1YiBzIGkgbikpXG4gIGFuZCBzeW1ib2xpY19zcGFjZXMgc29iIG4gPVxuICAgIGFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSBzb2IgKE91dHB1dF9zcGFjZXMgbilcbiAgYW5kIHN5bWJvbGljX2luZGVudCBzb2IgbiA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiAoT3V0cHV0X2luZGVudCBuKSBpblxuXG4gIGxldCBmID0gc3ltYm9saWNfc3RyaW5nIHNvYlxuICBhbmQgZyA9IHN5bWJvbGljX2ZsdXNoIHNvYlxuICBhbmQgaCA9IHN5bWJvbGljX25ld2xpbmUgc29iXG4gIGFuZCBpID0gc3ltYm9saWNfc3BhY2VzIHNvYlxuICBhbmQgaiA9IHN5bWJvbGljX2luZGVudCBzb2IgaW5cbiAgcHBfbWFrZV9mb3JtYXR0ZXIgZiBnIGggaSBqXG5cbigqXG5cbiAgQmFzaWMgZnVuY3Rpb25zIG9uIHRoZSAnc3RhbmRhcmQnIGZvcm1hdHRlclxuICAodGhlIGZvcm1hdHRlciB0aGF0IHByaW50cyB0byBbUGVydmFzaXZlcy5zdGRvdXRdKS5cblxuKilcblxubGV0IG9wZW5faGJveCA9IHBwX29wZW5faGJveCBzdGRfZm9ybWF0dGVyXG5hbmQgb3Blbl92Ym94ID0gcHBfb3Blbl92Ym94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBvcGVuX2h2Ym94ID0gcHBfb3Blbl9odmJveCBzdGRfZm9ybWF0dGVyXG5hbmQgb3Blbl9ob3Zib3ggPSBwcF9vcGVuX2hvdmJveCBzdGRfZm9ybWF0dGVyXG5hbmQgb3Blbl9ib3ggPSBwcF9vcGVuX2JveCBzdGRfZm9ybWF0dGVyXG5hbmQgY2xvc2VfYm94ID0gcHBfY2xvc2VfYm94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBvcGVuX3RhZyA9IHBwX29wZW5fdGFnIHN0ZF9mb3JtYXR0ZXJcbmFuZCBjbG9zZV90YWcgPSBwcF9jbG9zZV90YWcgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2FzID0gcHBfcHJpbnRfYXMgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X3N0cmluZyA9IHBwX3ByaW50X3N0cmluZyBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfaW50ID0gcHBfcHJpbnRfaW50IHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9mbG9hdCA9IHBwX3ByaW50X2Zsb2F0IHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9jaGFyID0gcHBfcHJpbnRfY2hhciBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfYm9vbCA9IHBwX3ByaW50X2Jvb2wgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2JyZWFrID0gcHBfcHJpbnRfYnJlYWsgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2N1dCA9IHBwX3ByaW50X2N1dCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfc3BhY2UgPSBwcF9wcmludF9zcGFjZSBzdGRfZm9ybWF0dGVyXG5hbmQgZm9yY2VfbmV3bGluZSA9IHBwX2ZvcmNlX25ld2xpbmUgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2ZsdXNoID0gcHBfcHJpbnRfZmx1c2ggc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X25ld2xpbmUgPSBwcF9wcmludF9uZXdsaW5lIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9pZl9uZXdsaW5lID0gcHBfcHJpbnRfaWZfbmV3bGluZSBzdGRfZm9ybWF0dGVyXG5cbmFuZCBvcGVuX3Rib3ggPSBwcF9vcGVuX3Rib3ggc3RkX2Zvcm1hdHRlclxuYW5kIGNsb3NlX3Rib3ggPSBwcF9jbG9zZV90Ym94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF90YnJlYWsgPSBwcF9wcmludF90YnJlYWsgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X3RhYiA9IHBwX3NldF90YWIgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X3RhYiA9IHBwX3ByaW50X3RhYiBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfbWFyZ2luID0gcHBfc2V0X21hcmdpbiBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X21hcmdpbiA9IHBwX2dldF9tYXJnaW4gc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X21heF9pbmRlbnQgPSBwcF9zZXRfbWF4X2luZGVudCBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X21heF9pbmRlbnQgPSBwcF9nZXRfbWF4X2luZGVudCBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfbWF4X2JveGVzID0gcHBfc2V0X21heF9ib3hlcyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X21heF9ib3hlcyA9IHBwX2dldF9tYXhfYm94ZXMgc3RkX2Zvcm1hdHRlclxuYW5kIG92ZXJfbWF4X2JveGVzID0gcHBfb3Zlcl9tYXhfYm94ZXMgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X2VsbGlwc2lzX3RleHQgPSBwcF9zZXRfZWxsaXBzaXNfdGV4dCBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2VsbGlwc2lzX3RleHQgPSBwcF9nZXRfZWxsaXBzaXNfdGV4dCBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZm9ybWF0dGVyX291dF9jaGFubmVsID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfY2hhbm5lbCBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgPVxuICBwcF9zZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyA9XG4gIHBwX2dldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgPVxuICBwcF9zZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyA9XG4gIHBwX2dldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgPVxuICBwcF9zZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyA9XG4gIHBwX2dldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5hbmQgc2V0X3ByaW50X3RhZ3MgPVxuICBwcF9zZXRfcHJpbnRfdGFncyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X3ByaW50X3RhZ3MgPVxuICBwcF9nZXRfcHJpbnRfdGFncyBzdGRfZm9ybWF0dGVyXG5hbmQgc2V0X21hcmtfdGFncyA9XG4gIHBwX3NldF9tYXJrX3RhZ3Mgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9tYXJrX3RhZ3MgPVxuICBwcF9nZXRfbWFya190YWdzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBzZXRfdGFncyA9XG4gIHBwX3NldF90YWdzIHN0ZF9mb3JtYXR0ZXJcblxuXG4oKiBDb252ZW5pZW5jZSBmdW5jdGlvbnMgKilcblxuKCogVG8gZm9ybWF0IGEgbGlzdCAqKVxubGV0IHJlYyBwcF9wcmludF9saXN0ID8ocHBfc2VwID0gcHBfcHJpbnRfY3V0KSBwcF92IHBwZiA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gKClcbiAgfCBbdl0gLT4gcHBfdiBwcGYgdlxuICB8IHYgOjogdnMgLT5cbiAgICBwcF92IHBwZiB2O1xuICAgIHBwX3NlcCBwcGYgKCk7XG4gICAgcHBfcHJpbnRfbGlzdCB+cHBfc2VwIHBwX3YgcHBmIHZzXG5cbigqIFRvIGZvcm1hdCBmcmVlLWZsb3dpbmcgdGV4dCAqKVxubGV0IHBwX3ByaW50X3RleHQgcHBmIHMgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCBsZWZ0ID0gcmVmIDAgaW5cbiAgbGV0IHJpZ2h0ID0gcmVmIDAgaW5cbiAgbGV0IGZsdXNoICgpID1cbiAgICBwcF9wcmludF9zdHJpbmcgcHBmIChTdHJpbmcuc3ViIHMgIWxlZnQgKCFyaWdodCAtICFsZWZ0KSk7XG4gICAgaW5jciByaWdodDsgbGVmdCA6PSAhcmlnaHQ7XG4gIGluXG4gIHdoaWxlICghcmlnaHQgPD4gbGVuKSBkb1xuICAgIG1hdGNoIHMuWyFyaWdodF0gd2l0aFxuICAgICAgfCAnXFxuJyAtPlxuICAgICAgICBmbHVzaCAoKTtcbiAgICAgICAgcHBfZm9yY2VfbmV3bGluZSBwcGYgKClcbiAgICAgIHwgJyAnIC0+XG4gICAgICAgIGZsdXNoICgpOyBwcF9wcmludF9zcGFjZSBwcGYgKClcbiAgICAgICgqIHRoZXJlIGlzIG5vIHNwZWNpZmljIHN1cHBvcnQgZm9yICdcXHQnXG4gICAgICAgICBhcyBpdCBpcyB1bmNsZWFyIHdoYXQgYSByaWdodCBzZW1hbnRpY3Mgd291bGQgYmUgKilcbiAgICAgIHwgXyAtPiBpbmNyIHJpZ2h0XG4gIGRvbmU7XG4gIGlmICFsZWZ0IDw+IGxlbiB0aGVuIGZsdXNoICgpXG5cbiAoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmxldCBjb21wdXRlX3RhZyBvdXRwdXQgdGFnX2FjYyA9XG4gIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIDE2IGluXG4gIGxldCBwcGYgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGJ1ZiBpblxuICBvdXRwdXQgcHBmIHRhZ19hY2M7XG4gIHBwX3ByaW50X2ZsdXNoIHBwZiAoKTtcbiAgbGV0IGxlbiA9IEJ1ZmZlci5sZW5ndGggYnVmIGluXG4gIGlmIGxlbiA8IDIgdGhlbiBCdWZmZXIuY29udGVudHMgYnVmXG4gIGVsc2UgQnVmZmVyLnN1YiBidWYgMSAobGVuIC0gMilcblxuICgqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gIERlZmluaW5nIGNvbnRpbnVhdGlvbnMgdG8gYmUgcGFzc2VkIGFzIGFyZ3VtZW50cyBvZlxuICBDYW1saW50ZXJuYWxGb3JtYXQubWFrZV9wcmludGYuXG5cbiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdFxuXG4oKiBJbnRlcnByZXQgYSBmb3JtYXR0aW5nIGVudGl0eSBvbiBhIGZvcm1hdHRlci4gKilcbmxldCBvdXRwdXRfZm9ybWF0dGluZ19saXQgcHBmIGZtdGluZ19saXQgPSBtYXRjaCBmbXRpbmdfbGl0IHdpdGhcbiAgfCBDbG9zZV9ib3ggICAgICAgICAgICAgICAgIC0+IHBwX2Nsb3NlX2JveCBwcGYgKClcbiAgfCBDbG9zZV90YWcgICAgICAgICAgICAgICAgIC0+IHBwX2Nsb3NlX3RhZyBwcGYgKClcbiAgfCBCcmVhayAoXywgd2lkdGgsIG9mZnNldCkgIC0+IHBwX3ByaW50X2JyZWFrIHBwZiB3aWR0aCBvZmZzZXRcbiAgfCBGRmx1c2ggICAgICAgICAgICAgICAgICAgIC0+IHBwX3ByaW50X2ZsdXNoIHBwZiAoKVxuICB8IEZvcmNlX25ld2xpbmUgICAgICAgICAgICAgLT4gcHBfZm9yY2VfbmV3bGluZSBwcGYgKClcbiAgfCBGbHVzaF9uZXdsaW5lICAgICAgICAgICAgIC0+IHBwX3ByaW50X25ld2xpbmUgcHBmICgpXG4gIHwgTWFnaWNfc2l6ZSAoXywgXykgICAgICAgICAtPiAoKVxuICB8IEVzY2FwZWRfYXQgICAgICAgICAgICAgICAgLT4gcHBfcHJpbnRfY2hhciBwcGYgJ0AnXG4gIHwgRXNjYXBlZF9wZXJjZW50ICAgICAgICAgICAtPiBwcF9wcmludF9jaGFyIHBwZiAnJSdcbiAgfCBTY2FuX2luZGljIGMgICAgICAgICAgICAgIC0+IHBwX3ByaW50X2NoYXIgcHBmICdAJzsgcHBfcHJpbnRfY2hhciBwcGYgY1xuXG4oKiBSZWN1cnNpdmVseSBvdXRwdXQgYW4gXCJhY2N1bXVsYXRvclwiIGNvbnRhaW5pbmcgYSByZXZlcnNlZCBsaXN0IG9mXG4gICBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzLCAuLi4pIGluIGFuIG91dHB1dF9zdHJlYW0uICopXG4oKiBEaWZmZXIgZnJvbSBQcmludGYub3V0cHV0X2FjYyBieSB0aGUgaW50ZXJwcmV0YXRpb24gb2YgZm9ybWF0dGluZy4gKilcbigqIFVzZWQgYXMgYSBjb250aW51YXRpb24gb2YgQ2FtbGludGVybmFsRm9ybWF0Lm1ha2VfcHJpbnRmLiAqKVxubGV0IHJlYyBvdXRwdXRfYWNjIHBwZiBhY2MgPSBtYXRjaCBhY2Mgd2l0aFxuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgcykgLT5cbiAgICBvdXRwdXRfYWNjIHBwZiBwO1xuICAgIHBwX3ByaW50X2FzX3NpemUgcHBmIChzaXplX29mX2ludCBzaXplKSBzO1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBjKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKHNpemVfb2ZfaW50IHNpemUpIChTdHJpbmcubWFrZSAxIGMpO1xuICB8IEFjY19mb3JtYXR0aW5nX2xpdCAocCwgZikgLT5cbiAgICBvdXRwdXRfYWNjIHBwZiBwO1xuICAgIG91dHB1dF9mb3JtYXR0aW5nX2xpdCBwcGYgZjtcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX3RhZyBhY2MnKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgcHBfb3Blbl90YWcgcHBmIChjb21wdXRlX3RhZyBvdXRwdXRfYWNjIGFjYycpXG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBvdXRwdXRfYWNjIHBwZiBwO1xuICAgIGxldCAoaW5kZW50LCBidHkpID0gb3Blbl9ib3hfb2Zfc3RyaW5nIChjb21wdXRlX3RhZyBvdXRwdXRfYWNjIGFjYycpIGluXG4gICAgcHBfb3Blbl9ib3hfZ2VuIHBwZiBpbmRlbnQgYnR5XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBvdXRwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9zdHJpbmcgcHBmIHM7XG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAocCwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChwLCBjKSAgICAgLT4gb3V0cHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfY2hhciBwcGYgYztcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gb3V0cHV0X2FjYyBwcGYgcDsgZiBwcGY7XG4gIHwgQWNjX2ZsdXNoIHAgICAgICAgICAgICAgIC0+IG91dHB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X2ZsdXNoIHBwZiAoKTtcbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gb3V0cHV0X2FjYyBwcGYgcDsgaW52YWxpZF9hcmcgbXNnO1xuICB8IEVuZF9vZl9hY2MgICAgICAgICAgICAgICAtPiAoKVxuXG4oKiBSZWN1cnNpdmVseSBvdXRwdXQgYW4gXCJhY2N1bXVsYXRvclwiIGNvbnRhaW5pbmcgYSByZXZlcnNlZCBsaXN0IG9mXG4gICBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzLCAuLi4pIGluIGEgYnVmZmVyLiAqKVxuKCogRGlmZmVyIGZyb20gUHJpbnRmLmJ1ZnB1dF9hY2MgYnkgdGhlIGludGVycHJldGF0aW9uIG9mIGZvcm1hdHRpbmcuICopXG4oKiBVc2VkIGFzIGEgY29udGludWF0aW9uIG9mIENhbWxpbnRlcm5hbEZvcm1hdC5tYWtlX3ByaW50Zi4gKilcbmxldCByZWMgc3RycHV0X2FjYyBwcGYgYWNjID0gbWF0Y2ggYWNjIHdpdGhcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIHMpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoc2l6ZV9vZl9pbnQgc2l6ZSkgcztcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgYykgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIHBwX3ByaW50X2FzX3NpemUgcHBmIChzaXplX29mX2ludCBzaXplKSAoU3RyaW5nLm1ha2UgMSBjKTtcbiAgfCBBY2NfZGVsYXkgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBmKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKHNpemVfb2ZfaW50IHNpemUpIChmICgpKTtcbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgKHAsIGYpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBvdXRwdXRfZm9ybWF0dGluZ19saXQgcHBmIGY7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl90YWcgYWNjJykgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIHBwX29wZW5fdGFnIHBwZiAoY29tcHV0ZV90YWcgc3RycHV0X2FjYyBhY2MnKVxuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fYm94IGFjYycpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBsZXQgKGluZGVudCwgYnR5KSA9IG9wZW5fYm94X29mX3N0cmluZyAoY29tcHV0ZV90YWcgc3RycHV0X2FjYyBhY2MnKSBpblxuICAgIHBwX29wZW5fYm94X2dlbiBwcGYgaW5kZW50IGJ0eVxuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gc3RycHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfc3RyaW5nIHBwZiBzO1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IHN0cnB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X2NoYXIgcHBmIGM7XG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IHN0cnB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X3N0cmluZyBwcGYgKGYgKCkpO1xuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBzdHJwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9mbHVzaCBwcGYgKCk7XG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IHN0cnB1dF9hY2MgcHBmIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCpcblxuICBEZWZpbmluZyBbZnByaW50Zl0gYW5kIHZhcmlvdXMgZmxhdm9ycyBvZiBbZnByaW50Zl0uXG5cbiopXG5cbmxldCBrZnByaW50ZiBrIHBwZiAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfcHJpbnRmXG4gICAgKGZ1biBwcGYgYWNjIC0+IG91dHB1dF9hY2MgcHBmIGFjYzsgayBwcGYpXG4gICAgcHBmIEVuZF9vZl9hY2MgZm10XG5cbmFuZCBpa2ZwcmludGYgayBwcGYgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX2lwcmludGYgayBwcGYgZm10XG5cbmxldCBmcHJpbnRmIHBwZiA9IGtmcHJpbnRmIGlnbm9yZSBwcGZcbmxldCBpZnByaW50ZiBwcGYgPSBpa2ZwcmludGYgaWdub3JlIHBwZlxubGV0IHByaW50ZiBmbXQgPSBmcHJpbnRmIHN0ZF9mb3JtYXR0ZXIgZm10XG5sZXQgZXByaW50ZiBmbXQgPSBmcHJpbnRmIGVycl9mb3JtYXR0ZXIgZm10XG5cbmxldCBrc3ByaW50ZiBrIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbGV0IGIgPSBwcF9tYWtlX2J1ZmZlciAoKSBpblxuICBsZXQgcHBmID0gZm9ybWF0dGVyX29mX2J1ZmZlciBiIGluXG4gIGxldCBrICgpIGFjYyA9XG4gICAgc3RycHV0X2FjYyBwcGYgYWNjO1xuICAgIGsgKGZsdXNoX2J1ZmZlcl9mb3JtYXR0ZXIgYiBwcGYpIGluXG4gIG1ha2VfcHJpbnRmIGsgKCkgRW5kX29mX2FjYyBmbXRcblxuXG5sZXQgc3ByaW50ZiBmbXQgPSBrc3ByaW50ZiAoZnVuIHMgLT4gcykgZm10XG5cbmxldCBrYXNwcmludGYgayAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIGxldCBiID0gcHBfbWFrZV9idWZmZXIgKCkgaW5cbiAgbGV0IHBwZiA9IGZvcm1hdHRlcl9vZl9idWZmZXIgYiBpblxuICBsZXQgayBwcGYgYWNjID1cbiAgICBvdXRwdXRfYWNjIHBwZiBhY2M7XG4gICAgayAoZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBiIHBwZikgaW5cbiAgbWFrZV9wcmludGYgayBwcGYgRW5kX29mX2FjYyBmbXRcblxuXG5sZXQgYXNwcmludGYgZm10ID0ga2FzcHJpbnRmIChmdW4gcyAtPiBzKSBmbXRcblxuKCogT3V0cHV0IGV2ZXJ5dGhpbmcgbGVmdCBpbiB0aGUgcHJldHR5IHByaW50ZXIgcXVldWUgYXQgZW5kIG9mIGV4ZWN1dGlvbi4gKilcbmxldCAoKSA9IGF0X2V4aXQgcHJpbnRfZmx1c2hcblxuXG4oKlxuXG4gIERlcHJlY2F0ZWQgc3R1ZmYuXG5cbiopXG5cbigqIERlcHJlY2F0ZWQgOiBzdWJzdW1lZCBieSBwcF9zZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgKilcbmxldCBwcF9zZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlXG4gICAgfm91dDpmIH5mbHVzaDpnIH5uZXdsaW5lOmggfnNwYWNlczppID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlIGYgZztcbiAgc3RhdGUucHBfb3V0X25ld2xpbmUgPC0gaDtcbiAgc3RhdGUucHBfb3V0X3NwYWNlcyA8LSBpXG5cbigqIERlcHJlY2F0ZWQgOiBzdWJzdW1lZCBieSBwcF9nZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgKilcbmxldCBwcF9nZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlICgpID1cbiAgKHN0YXRlLnBwX291dF9zdHJpbmcsIHN0YXRlLnBwX291dF9mbHVzaCxcbiAgIHN0YXRlLnBwX291dF9uZXdsaW5lLCBzdGF0ZS5wcF9vdXRfc3BhY2VzKVxuXG5cbigqIERlcHJlY2F0ZWQgOiBzdWJzdW1lZCBieSBzZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgKilcbmxldCBzZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zID1cbiAgcHBfc2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5cblxuKCogRGVwcmVjYXRlZCA6IHN1YnN1bWVkIGJ5IGdldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyAqKVxubGV0IGdldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgPVxuICBwcF9nZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcblxuXG4oKiBEZXByZWNhdGVkIDogZXJyb3IgcHJvbmUgZnVuY3Rpb24sIGRvIG5vdCB1c2UgaXQuXG4gICBUaGlzIGZ1bmN0aW9uIGlzIG5laXRoZXIgY29tcG9zaXRpb25hbCBub3IgaW5jcmVtZW50YWwsIHNpbmNlIGl0IGZsdXNoZXNcbiAgIHRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBhdCBlYWNoIGNhbGwuXG4gICBUbyBnZXQgdGhlIHNhbWUgZnVuY3Rpb25hbGl0eSwgZGVmaW5lIGEgZm9ybWF0dGVyIG9mIHlvdXIgb3duIHdyaXRpbmcgdG9cbiAgIHRoZSBidWZmZXIgYXJndW1lbnQsIGFzIGluXG4gICBsZXQgcHBmID0gZm9ybWF0dGVyX29mX2J1ZmZlciBiXG4gICB0aGVuIHVzZSB7IWZwcmludGYgcHBmfSBhcyB1c3VhbC4gKilcbmxldCBicHJpbnRmIGIgKEZvcm1hdCAoZm10LCBfKSA6ICgnYSwgZm9ybWF0dGVyLCB1bml0KSBmb3JtYXQpID1cbiAgbGV0IGsgcHBmIGFjYyA9IG91dHB1dF9hY2MgcHBmIGFjYzsgcHBfZmx1c2hfcXVldWUgcHBmIGZhbHNlIGluXG4gIG1ha2VfcHJpbnRmIGsgKGZvcm1hdHRlcl9vZl9idWZmZXIgYikgRW5kX29mX2FjYyBmbXRcblxuXG4oKiBEZXByZWNhdGVkIDogYWxpYXMgZm9yIGtzcHJpbnRmLiAqKVxubGV0IGtwcmludGYgPSBrc3ByaW50ZlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgUGllcnJlIFdlaXMsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAwMiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljc1xub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRcblxuKCogYWxpYXMgdG8gYXZvaWQgd2FybmluZyBmb3IgYW1iaWd1aXR5IGJldHdlZW5cbiAgIFBlcnZhc2l2ZXMuZm9ybWF0NlxuICAgYW5kIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mb3JtYXQ2XG5cbiAgICh0aGUgZm9ybWVyIGlzIGluIGZhY3QgYW4gYWxpYXMgZm9yIHRoZSBsYXR0ZXIsXG4gICAgYnV0IHRoZSBhbWJpZ3VpdHkgd2FybmluZyBkb2Vzbid0IGNhcmUpXG4qKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA9XG4gICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBQZXJ2YXNpdmVzLmZvcm1hdDZcblxuXG4oKiBUaGUgcnVuLXRpbWUgbGlicmFyeSBmb3Igc2Nhbm5lcnMuICopXG5cbigqIFNjYW5uaW5nIGJ1ZmZlcnMuICopXG5tb2R1bGUgdHlwZSBTQ0FOTklORyA9IHNpZ1xuXG4gIHR5cGUgaW5fY2hhbm5lbFxuXG4gIHR5cGUgc2NhbmJ1ZiA9IGluX2NoYW5uZWxcblxuICB0eXBlIGZpbGVfbmFtZSA9IHN0cmluZ1xuXG4gIHZhbCBzdGRpbiA6IGluX2NoYW5uZWxcbiAgKCogVGhlIHNjYW5uaW5nIGJ1ZmZlciByZWFkaW5nIGZyb20gW1BlcnZhc2l2ZXMuc3RkaW5dLlxuICAgICBbc3RkaWJdIGlzIGVxdWl2YWxlbnQgdG8gW1NjYW5uaW5nLmZyb21fY2hhbm5lbCBQZXJ2YXNpdmVzLnN0ZGluXS4gKilcblxuICB2YWwgc3RkaWIgOiBpbl9jaGFubmVsXG4gICgqIEFuIGFsaWFzIGZvciBbU2NhbmYuc3RkaW5dLCB0aGUgc2Nhbm5pbmcgYnVmZmVyIHJlYWRpbmcgZnJvbVxuICAgICBbUGVydmFzaXZlcy5zdGRpbl0uICopXG5cbiAgdmFsIG5leHRfY2hhciA6IHNjYW5idWYgLT4gY2hhclxuICAoKiBbU2Nhbm5pbmcubmV4dF9jaGFyIGliXSBhZHZhbmNlIHRoZSBzY2FubmluZyBidWZmZXIgZm9yXG4gICAgIG9uZSBjaGFyYWN0ZXIuXG4gICAgIElmIG5vIG1vcmUgY2hhcmFjdGVyIGNhbiBiZSByZWFkLCBzZXRzIGEgZW5kIG9mIGZpbGUgY29uZGl0aW9uIGFuZFxuICAgICByZXR1cm5zICdcXDAwMCcuICopXG5cbiAgdmFsIGludmFsaWRhdGVfY3VycmVudF9jaGFyIDogc2NhbmJ1ZiAtPiB1bml0XG4gICgqIFtTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYl0gbWFyayB0aGUgY3VycmVudF9jaGFyIGFzIGFscmVhZHlcbiAgICAgc2Nhbm5lZC4gKilcblxuICB2YWwgcGVla19jaGFyIDogc2NhbmJ1ZiAtPiBjaGFyXG4gICgqIFtTY2FubmluZy5wZWVrX2NoYXIgaWJdIHJldHVybnMgdGhlIGN1cnJlbnQgY2hhciBhdmFpbGFibGUgaW5cbiAgICAgdGhlIGJ1ZmZlciBvciByZWFkcyBvbmUgaWYgbmVjZXNzYXJ5ICh3aGVuIHRoZSBjdXJyZW50IGNoYXJhY3RlciBpc1xuICAgICBhbHJlYWR5IHNjYW5uZWQpLlxuICAgICBJZiBubyBjaGFyYWN0ZXIgY2FuIGJlIHJlYWQsIHNldHMgYW4gZW5kIG9mIGZpbGUgY29uZGl0aW9uIGFuZFxuICAgICByZXR1cm5zICdcXDAwMCcuICopXG5cbiAgdmFsIGNoZWNrZWRfcGVla19jaGFyIDogc2NhbmJ1ZiAtPiBjaGFyXG4gICgqIFNhbWUgYXMgW1NjYW5uaW5nLnBlZWtfY2hhcl0gYWJvdmUgYnV0IGFsd2F5cyByZXR1cm5zIGEgdmFsaWQgY2hhciBvclxuICAgICBmYWlsczogaW5zdGVhZCBvZiByZXR1cm5pbmcgYSBudWxsIGNoYXIgd2hlbiB0aGUgcmVhZGluZyBtZXRob2Qgb2YgdGhlXG4gICAgIGlucHV0IGJ1ZmZlciBoYXMgcmVhY2hlZCBhbiBlbmQgb2YgZmlsZSwgdGhlIGZ1bmN0aW9uIHJhaXNlcyBleGNlcHRpb25cbiAgICAgW0VuZF9vZl9maWxlXS4gKilcblxuICB2YWwgc3RvcmVfY2hhciA6IGludCAtPiBzY2FuYnVmIC0+IGNoYXIgLT4gaW50XG4gICgqIFtTY2FubmluZy5zdG9yZV9jaGFyIGxpbSBpYiBjXSBhZGRzIFtjXSB0byB0aGUgdG9rZW4gYnVmZmVyXG4gICAgIG9mIHRoZSBzY2FubmluZyBidWZmZXIgW2liXS4gSXQgYWxzbyBhZHZhbmNlcyB0aGUgc2Nhbm5pbmcgYnVmZmVyIGZvclxuICAgICBvbmUgY2hhcmFjdGVyIGFuZCByZXR1cm5zIFtsaW0gLSAxXSwgaW5kaWNhdGluZyB0aGUgbmV3IGxpbWl0IGZvciB0aGVcbiAgICAgbGVuZ3RoIG9mIHRoZSBjdXJyZW50IHRva2VuLiAqKVxuXG4gIHZhbCBza2lwX2NoYXIgOiBpbnQgLT4gc2NhbmJ1ZiAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLnNraXBfY2hhciBsaW0gaWJdIGlnbm9yZXMgdGhlIGN1cnJlbnQgY2hhcmFjdGVyLiAqKVxuXG4gIHZhbCBpZ25vcmVfY2hhciA6IGludCAtPiBzY2FuYnVmIC0+IGludFxuICAoKiBbU2Nhbm5pbmcuaWdub3JlX2NoYXIgaWIgbGltXSBpZ25vcmVzIHRoZSBjdXJyZW50IGNoYXJhY3RlciBhbmRcbiAgICAgZGVjcmVtZW50cyB0aGUgbGltaXQuICopXG5cbiAgdmFsIHRva2VuIDogc2NhbmJ1ZiAtPiBzdHJpbmdcbiAgKCogW1NjYW5uaW5nLnRva2VuIGliXSByZXR1cm5zIHRoZSBzdHJpbmcgc3RvcmVkIGludG8gdGhlIHRva2VuXG4gICAgIGJ1ZmZlciBvZiB0aGUgc2Nhbm5pbmcgYnVmZmVyOiBpdCByZXR1cm5zIHRoZSB0b2tlbiBtYXRjaGVkIGJ5IHRoZVxuICAgICBmb3JtYXQuICopXG5cbiAgdmFsIHJlc2V0X3Rva2VuIDogc2NhbmJ1ZiAtPiB1bml0XG4gICgqIFtTY2FubmluZy5yZXNldF90b2tlbiBpYl0gcmVzZXRzIHRoZSB0b2tlbiBidWZmZXIgb2ZcbiAgICAgdGhlIGdpdmVuIHNjYW5uaW5nIGJ1ZmZlci4gKilcblxuICB2YWwgY2hhcl9jb3VudCA6IHNjYW5idWYgLT4gaW50XG4gICgqIFtTY2FubmluZy5jaGFyX2NvdW50IGliXSByZXR1cm5zIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVyc1xuICAgICByZWFkIHNvIGZhciBmcm9tIHRoZSBnaXZlbiBidWZmZXIuICopXG5cbiAgdmFsIGxpbmVfY291bnQgOiBzY2FuYnVmIC0+IGludFxuICAoKiBbU2Nhbm5pbmcubGluZV9jb3VudCBpYl0gcmV0dXJucyB0aGUgbnVtYmVyIG9mIG5ldyBsaW5lXG4gICAgIGNoYXJhY3RlcnMgcmVhZCBzbyBmYXIgZnJvbSB0aGUgZ2l2ZW4gYnVmZmVyLiAqKVxuXG4gIHZhbCB0b2tlbl9jb3VudCA6IHNjYW5idWYgLT4gaW50XG4gICgqIFtTY2FubmluZy50b2tlbl9jb3VudCBpYl0gcmV0dXJucyB0aGUgbnVtYmVyIG9mIHRva2VucyByZWFkXG4gICAgIHNvIGZhciBmcm9tIFtpYl0uICopXG5cbiAgdmFsIGVvZiA6IHNjYW5idWYgLT4gYm9vbFxuICAoKiBbU2Nhbm5pbmcuZW9mIGliXSByZXR1cm5zIHRoZSBlbmQgb2YgaW5wdXQgY29uZGl0aW9uXG4gICAgIG9mIHRoZSBnaXZlbiBidWZmZXIuICopXG5cbiAgdmFsIGVuZF9vZl9pbnB1dCA6IHNjYW5idWYgLT4gYm9vbFxuICAoKiBbU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliXSB0ZXN0cyB0aGUgZW5kIG9mIGlucHV0IGNvbmRpdGlvblxuICAgICBvZiB0aGUgZ2l2ZW4gYnVmZmVyIChpZiBubyBjaGFyIGhhcyBldmVyIGJlZW4gcmVhZCwgYW4gYXR0ZW1wdCB0b1xuICAgICByZWFkIG9uZSBpcyBwZXJmb3JtZWQpLiAqKVxuXG4gIHZhbCBiZWdpbm5pbmdfb2ZfaW5wdXQgOiBzY2FuYnVmIC0+IGJvb2xcbiAgKCogW1NjYW5uaW5nLmJlZ2lubmluZ19vZl9pbnB1dCBpYl0gdGVzdHMgdGhlIGJlZ2lubmluZyBvZiBpbnB1dFxuICAgICBjb25kaXRpb24gb2YgdGhlIGdpdmVuIGJ1ZmZlci4gKilcblxuICB2YWwgbmFtZV9vZl9pbnB1dCA6IHNjYW5idWYgLT4gc3RyaW5nXG4gICgqIFtTY2FubmluZy5uYW1lX29mX2lucHV0IGliXSByZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBjaGFyYWN0ZXJcbiAgICAgc291cmNlIGZvciBpbnB1dCBidWZmZXIgW2liXS4gKilcblxuICB2YWwgb3Blbl9pbiA6IGZpbGVfbmFtZSAtPiBpbl9jaGFubmVsXG4gIHZhbCBvcGVuX2luX2JpbiA6IGZpbGVfbmFtZSAtPiBpbl9jaGFubmVsXG4gIHZhbCBmcm9tX2ZpbGUgOiBmaWxlX25hbWUgLT4gaW5fY2hhbm5lbFxuICB2YWwgZnJvbV9maWxlX2JpbiA6IGZpbGVfbmFtZSAtPiBpbl9jaGFubmVsXG4gIHZhbCBmcm9tX3N0cmluZyA6IHN0cmluZyAtPiBpbl9jaGFubmVsXG4gIHZhbCBmcm9tX2Z1bmN0aW9uIDogKHVuaXQgLT4gY2hhcikgLT4gaW5fY2hhbm5lbFxuICB2YWwgZnJvbV9jaGFubmVsIDogUGVydmFzaXZlcy5pbl9jaGFubmVsIC0+IGluX2NoYW5uZWxcblxuICB2YWwgY2xvc2VfaW4gOiBpbl9jaGFubmVsIC0+IHVuaXRcblxuICB2YWwgbWVtb19mcm9tX2NoYW5uZWwgOiBQZXJ2YXNpdmVzLmluX2NoYW5uZWwgLT4gaW5fY2hhbm5lbFxuICAoKiBPYnNvbGV0ZS4gKilcblxuZW5kXG5cblxubW9kdWxlIFNjYW5uaW5nIDogU0NBTk5JTkcgPSBzdHJ1Y3RcblxuICAoKiBUaGUgcnVuLXRpbWUgbGlicmFyeSBmb3Igc2NhbmYuICopXG5cbiAgdHlwZSBmaWxlX25hbWUgPSBzdHJpbmdcblxuICB0eXBlIGluX2NoYW5uZWxfbmFtZSA9XG4gICAgfCBGcm9tX2NoYW5uZWwgb2YgUGVydmFzaXZlcy5pbl9jaGFubmVsXG4gICAgfCBGcm9tX2ZpbGUgb2YgZmlsZV9uYW1lICogUGVydmFzaXZlcy5pbl9jaGFubmVsXG4gICAgfCBGcm9tX2Z1bmN0aW9uXG4gICAgfCBGcm9tX3N0cmluZ1xuXG5cbiAgdHlwZSBpbl9jaGFubmVsID0ge1xuICAgIG11dGFibGUgaWNfZW9mIDogYm9vbDtcbiAgICBtdXRhYmxlIGljX2N1cnJlbnRfY2hhciA6IGNoYXI7XG4gICAgbXV0YWJsZSBpY19jdXJyZW50X2NoYXJfaXNfdmFsaWQgOiBib29sO1xuICAgIG11dGFibGUgaWNfY2hhcl9jb3VudCA6IGludDtcbiAgICBtdXRhYmxlIGljX2xpbmVfY291bnQgOiBpbnQ7XG4gICAgbXV0YWJsZSBpY190b2tlbl9jb3VudCA6IGludDtcbiAgICBtdXRhYmxlIGljX2dldF9uZXh0X2NoYXIgOiB1bml0IC0+IGNoYXI7XG4gICAgaWNfdG9rZW5fYnVmZmVyIDogQnVmZmVyLnQ7XG4gICAgaWNfaW5wdXRfbmFtZSA6IGluX2NoYW5uZWxfbmFtZTtcbiAgfVxuXG5cbiAgdHlwZSBzY2FuYnVmID0gaW5fY2hhbm5lbFxuXG4gIGxldCBudWxsX2NoYXIgPSAnXFwwMDAnXG5cbiAgKCogUmVhZHMgYSBuZXcgY2hhcmFjdGVyIGZyb20gaW5wdXQgYnVmZmVyLlxuICAgICBOZXh0X2NoYXIgbmV2ZXIgZmFpbHMsIGV2ZW4gaW4gY2FzZSBvZiBlbmQgb2YgaW5wdXQ6XG4gICAgIGl0IHRoZW4gc2ltcGx5IHNldHMgdGhlIGVuZCBvZiBmaWxlIGNvbmRpdGlvbi4gKilcbiAgbGV0IG5leHRfY2hhciBpYiA9XG4gICAgdHJ5XG4gICAgICBsZXQgYyA9IGliLmljX2dldF9uZXh0X2NoYXIgKCkgaW5cbiAgICAgIGliLmljX2N1cnJlbnRfY2hhciA8LSBjO1xuICAgICAgaWIuaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkIDwtIHRydWU7XG4gICAgICBpYi5pY19jaGFyX2NvdW50IDwtIHN1Y2MgaWIuaWNfY2hhcl9jb3VudDtcbiAgICAgIGlmIGMgPSAnXFxuJyB0aGVuIGliLmljX2xpbmVfY291bnQgPC0gc3VjYyBpYi5pY19saW5lX2NvdW50O1xuICAgICAgYyB3aXRoXG4gICAgfCBFbmRfb2ZfZmlsZSAtPlxuICAgICAgbGV0IGMgPSBudWxsX2NoYXIgaW5cbiAgICAgIGliLmljX2N1cnJlbnRfY2hhciA8LSBjO1xuICAgICAgaWIuaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkIDwtIGZhbHNlO1xuICAgICAgaWIuaWNfZW9mIDwtIHRydWU7XG4gICAgICBjXG5cblxuICBsZXQgcGVla19jaGFyIGliID1cbiAgICBpZiBpYi5pY19jdXJyZW50X2NoYXJfaXNfdmFsaWRcbiAgICB0aGVuIGliLmljX2N1cnJlbnRfY2hhclxuICAgIGVsc2UgbmV4dF9jaGFyIGliXG5cblxuICAoKiBSZXR1cm5zIGEgdmFsaWQgY3VycmVudCBjaGFyIGZvciB0aGUgaW5wdXQgYnVmZmVyLiBJbiBwYXJ0aWN1bGFyXG4gICAgIG5vIGlycmVsZXZhbnQgbnVsbCBjaGFyYWN0ZXIgKGFzIHNldCBieSBbbmV4dF9jaGFyXSBpbiBjYXNlIG9mIGVuZFxuICAgICBvZiBpbnB1dCkgaXMgcmV0dXJuZWQsIHNpbmNlIFtFbmRfb2ZfZmlsZV0gaXMgcmFpc2VkIHdoZW5cbiAgICAgW25leHRfY2hhcl0gc2V0cyB0aGUgZW5kIG9mIGZpbGUgY29uZGl0aW9uIHdoaWxlIHRyeWluZyB0byByZWFkIGFcbiAgICAgbmV3IGNoYXJhY3Rlci4gKilcbiAgbGV0IGNoZWNrZWRfcGVla19jaGFyIGliID1cbiAgICBsZXQgYyA9IHBlZWtfY2hhciBpYiBpblxuICAgIGlmIGliLmljX2VvZiB0aGVuIHJhaXNlIEVuZF9vZl9maWxlO1xuICAgIGNcblxuXG4gIGxldCBlbmRfb2ZfaW5wdXQgaWIgPVxuICAgIGlnbm9yZSAocGVla19jaGFyIGliKTtcbiAgICBpYi5pY19lb2ZcblxuXG4gIGxldCBlb2YgaWIgPSBpYi5pY19lb2ZcblxuICBsZXQgYmVnaW5uaW5nX29mX2lucHV0IGliID0gaWIuaWNfY2hhcl9jb3VudCA9IDBcblxuICBsZXQgbmFtZV9vZl9pbnB1dCBpYiA9XG4gICAgbWF0Y2ggaWIuaWNfaW5wdXRfbmFtZSB3aXRoXG4gICAgfCBGcm9tX2NoYW5uZWwgX2ljIC0+IFwidW5uYW1lZCBQZXJ2YXNpdmVzIGlucHV0IGNoYW5uZWxcIlxuICAgIHwgRnJvbV9maWxlIChmbmFtZSwgX2ljKSAtPiBmbmFtZVxuICAgIHwgRnJvbV9mdW5jdGlvbiAtPiBcInVubmFtZWQgZnVuY3Rpb25cIlxuICAgIHwgRnJvbV9zdHJpbmcgLT4gXCJ1bm5hbWVkIGNoYXJhY3RlciBzdHJpbmdcIlxuXG5cbiAgbGV0IGNoYXJfY291bnQgaWIgPVxuICAgIGlmIGliLmljX2N1cnJlbnRfY2hhcl9pc192YWxpZFxuICAgIHRoZW4gaWIuaWNfY2hhcl9jb3VudCAtIDFcbiAgICBlbHNlIGliLmljX2NoYXJfY291bnRcblxuXG4gIGxldCBsaW5lX2NvdW50IGliID0gaWIuaWNfbGluZV9jb3VudFxuXG4gIGxldCByZXNldF90b2tlbiBpYiA9IEJ1ZmZlci5yZXNldCBpYi5pY190b2tlbl9idWZmZXJcblxuICBsZXQgaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWIgPSBpYi5pY19jdXJyZW50X2NoYXJfaXNfdmFsaWQgPC0gZmFsc2VcblxuICBsZXQgdG9rZW4gaWIgPVxuICAgIGxldCB0b2tlbl9idWZmZXIgPSBpYi5pY190b2tlbl9idWZmZXIgaW5cbiAgICBsZXQgdG9rID0gQnVmZmVyLmNvbnRlbnRzIHRva2VuX2J1ZmZlciBpblxuICAgIEJ1ZmZlci5jbGVhciB0b2tlbl9idWZmZXI7XG4gICAgaWIuaWNfdG9rZW5fY291bnQgPC0gc3VjYyBpYi5pY190b2tlbl9jb3VudDtcbiAgICB0b2tcblxuXG4gIGxldCB0b2tlbl9jb3VudCBpYiA9IGliLmljX3Rva2VuX2NvdW50XG5cbiAgbGV0IHNraXBfY2hhciB3aWR0aCBpYiA9XG4gICAgaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWI7XG4gICAgd2lkdGhcblxuXG4gIGxldCBpZ25vcmVfY2hhciB3aWR0aCBpYiA9IHNraXBfY2hhciAod2lkdGggLSAxKSBpYlxuXG4gIGxldCBzdG9yZV9jaGFyIHdpZHRoIGliIGMgPVxuICAgIEJ1ZmZlci5hZGRfY2hhciBpYi5pY190b2tlbl9idWZmZXIgYztcbiAgICBpZ25vcmVfY2hhciB3aWR0aCBpYlxuXG5cbiAgbGV0IGRlZmF1bHRfdG9rZW5fYnVmZmVyX3NpemUgPSAxMDI0XG5cbiAgbGV0IGNyZWF0ZSBpbmFtZSBuZXh0ID0ge1xuICAgIGljX2VvZiA9IGZhbHNlO1xuICAgIGljX2N1cnJlbnRfY2hhciA9IG51bGxfY2hhcjtcbiAgICBpY19jdXJyZW50X2NoYXJfaXNfdmFsaWQgPSBmYWxzZTtcbiAgICBpY19jaGFyX2NvdW50ID0gMDtcbiAgICBpY19saW5lX2NvdW50ID0gMDtcbiAgICBpY190b2tlbl9jb3VudCA9IDA7XG4gICAgaWNfZ2V0X25leHRfY2hhciA9IG5leHQ7XG4gICAgaWNfdG9rZW5fYnVmZmVyID0gQnVmZmVyLmNyZWF0ZSBkZWZhdWx0X3Rva2VuX2J1ZmZlcl9zaXplO1xuICAgIGljX2lucHV0X25hbWUgPSBpbmFtZTtcbiAgfVxuXG5cbiAgbGV0IGZyb21fc3RyaW5nIHMgPVxuICAgIGxldCBpID0gcmVmIDAgaW5cbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gICAgbGV0IG5leHQgKCkgPVxuICAgICAgaWYgIWkgPj0gbGVuIHRoZW4gcmFpc2UgRW5kX29mX2ZpbGUgZWxzZVxuICAgICAgbGV0IGMgPSBzLlshaV0gaW5cbiAgICAgIGluY3IgaTtcbiAgICAgIGMgaW5cbiAgICBjcmVhdGUgRnJvbV9zdHJpbmcgbmV4dFxuXG5cbiAgbGV0IGZyb21fZnVuY3Rpb24gPSBjcmVhdGUgRnJvbV9mdW5jdGlvblxuXG4gICgqIFNjYW5uaW5nIGZyb20gYW4gaW5wdXQgY2hhbm5lbC4gKilcblxuICAoKiBQb3NpdGlvbiBvZiB0aGUgcHJvYmxlbTpcblxuICAgICBXZSBjYW5ub3QgcHJldmVudCB0aGUgc2Nhbm5pbmcgbWVjaGFuaXNtIHRvIHVzZSBvbmUgbG9va2FoZWFkIGNoYXJhY3RlcixcbiAgICAgaWYgbmVlZGVkIGJ5IHRoZSBzZW1hbnRpY3Mgb2YgdGhlIGZvcm1hdCBzdHJpbmcgc3BlY2lmaWNhdGlvbnMgKGUuZy4gYVxuICAgICB0cmFpbGluZyAnc2tpcCBzcGFjZScgc3BlY2lmaWNhdGlvbiBpbiB0aGUgZm9ybWF0IHN0cmluZyk7IGluIHRoaXMgY2FzZSxcbiAgICAgdGhlIG1hbmRhdG9yeSBsb29rYWhlYWQgY2hhcmFjdGVyIGlzIGluZGVlZCByZWFkIGZyb20gdGhlIGlucHV0IGFuZCBub3RcbiAgICAgdXNlZCB0byByZXR1cm4gdGhlIHRva2VuIHJlYWQuIEl0IGlzIHRodXMgbWFuZGF0b3J5IHRvIGJlIGFibGUgdG8gc3RvcmVcbiAgICAgYW4gdW51c2VkIGxvb2thaGVhZCBjaGFyYWN0ZXIgc29tZXdoZXJlIHRvIGdldCBpdCBhcyB0aGUgZmlyc3QgY2hhcmFjdGVyXG4gICAgIG9mIHRoZSBuZXh0IHNjYW4uXG5cbiAgICAgVG8gY2lyY3VtdmVudCB0aGlzIHByb2JsZW0sIGFsbCB0aGUgc2Nhbm5pbmcgZnVuY3Rpb25zIGdldCBhIGxvdyBsZXZlbFxuICAgICBpbnB1dCBidWZmZXIgYXJndW1lbnQgd2hlcmUgdGhleSBzdG9yZSB0aGUgbG9va2FoZWFkIGNoYXJhY3RlciB3aGVuXG4gICAgIG5lZWRlZDsgYWRkaXRpb25hbGx5LCB0aGUgaW5wdXQgYnVmZmVyIGlzIHRoZSBvbmx5IHNvdXJjZSBvZiBjaGFyYWN0ZXIgb2ZcbiAgICAgYSBzY2FubmVyLiBUaGUgW3NjYW5idWZdIGlucHV0IGJ1ZmZlcnMgYXJlIGRlZmluZWQgaW4gbW9kdWxlIHshU2Nhbm5pbmd9LlxuXG4gICAgIE5vdyB3ZSB1bmRlcnN0YW5kIHRoYXQgaXQgaXMgZXh0cmVtZWx5IGltcG9ydGFudCB0aGF0IHJlbGF0ZWQgYW5kXG4gICAgIHN1Y2Nlc3NpdmUgY2FsbHMgdG8gc2Nhbm5lcnMgaW5kZWVkIHJlYWQgZnJvbSB0aGUgc2FtZSBpbnB1dCBidWZmZXIuXG4gICAgIEluIGVmZmVjdCwgaWYgYSBzY2FubmVyIFtzY2FuMV0gaXMgcmVhZGluZyBmcm9tIFtpYjFdIGFuZCBzdG9yZXMgYW5cbiAgICAgdW51c2VkIGxvb2thaGVhZCBjaGFyYWN0ZXIgW2MxXSBpbnRvIGl0cyBpbnB1dCBidWZmZXIgW2liMV0sIHRoZW5cbiAgICAgYW5vdGhlciBzY2FubmVyIFtzY2FuMl0gbm90IHJlYWRpbmcgZnJvbSB0aGUgc2FtZSBidWZmZXIgW2liMV0gd2lsbCBtaXNzXG4gICAgIHRoZSBjaGFyYWN0ZXIgW2MxXSwgc2VlbWluZ2x5IHZhbmlzaGVkIGluIHRoZSBhaXIgZnJvbSB0aGUgcG9pbnQgb2Ygdmlld1xuICAgICBvZiBbc2NhbjJdLlxuXG4gICAgIFRoaXMgbWVjaGFuaXNtIHdvcmtzIHBlcmZlY3RseSB0byByZWFkIGZyb20gc3RyaW5ncywgZnJvbSBmaWxlcywgYW5kIGZyb21cbiAgICAgZnVuY3Rpb25zLCBzaW5jZSBpbiB0aG9zZSBjYXNlcywgYWxsb2NhdGluZyB0d28gYnVmZmVycyByZWFkaW5nIGZyb20gdGhlXG4gICAgIHNhbWUgc291cmNlIGlzIHVubmF0dXJhbC5cblxuICAgICBTdGlsbCwgdGhlcmUgaXMgYSBkaWZmaWN1bHR5IGluIHRoZSBjYXNlIG9mIHNjYW5uaW5nIGZyb20gYW4gaW5wdXRcbiAgICAgY2hhbm5lbC4gSW4gZWZmZWN0LCB3aGVuIHNjYW5uaW5nIGZyb20gYW4gaW5wdXQgY2hhbm5lbCBbaWNdLCB0aGlzIGNoYW5uZWxcbiAgICAgbWF5IG5vdCBoYXZlIGJlZW4gYWxsb2NhdGVkIGZyb20gd2l0aGluIHRoaXMgbGlicmFyeS4gSGVuY2UsIGl0IG1heSBiZVxuICAgICBzaGFyZWQgKHR3byBmdW5jdGlvbnMgb2YgdGhlIHVzZXIncyBwcm9ncmFtIG1heSBzdWNjZXNzaXZlbHkgcmVhZCBmcm9tXG4gICAgIFtpY10pLiBUaGlzIGlzIGhpZ2hseSBlcnJvciBwcm9uZSBzaW5jZSwgb25lIG9mIHRoZSBmdW5jdGlvbiBtYXkgc2VlayB0aGVcbiAgICAgaW5wdXQgY2hhbm5lbCwgd2hpbGUgdGhlIG90aGVyIGZ1bmN0aW9uIGhhcyBzdGlsbCBhbiB1bnVzZWQgbG9va2FoZWFkXG4gICAgIGNoYXJhY3RlciBpbiBpdHMgaW5wdXQgYnVmZmVyLiBJbiBjb25jbHVzaW9uLCB5b3Ugc2hvdWxkIG5ldmVyIG1peCBkaXJlY3RcbiAgICAgbG93IGxldmVsIHJlYWRpbmcgYW5kIGhpZ2ggbGV2ZWwgc2Nhbm5pbmcgZnJvbSB0aGUgc2FtZSBpbnB1dCBjaGFubmVsLlxuXG4gICopXG5cbiAgKCogUGVyZm9ybSBidWZmZXJpemVkIGlucHV0IHRvIGltcHJvdmUgZWZmaWNpZW5jeS4gKilcbiAgbGV0IGZpbGVfYnVmZmVyX3NpemUgPSByZWYgMTAyNFxuXG4gICgqIFRoZSBzY2FubmVyIGNsb3NlcyB0aGUgaW5wdXQgY2hhbm5lbCBhdCBlbmQgb2YgaW5wdXQuICopXG4gIGxldCBzY2FuX2Nsb3NlX2F0X2VuZCBpYyA9IFBlcnZhc2l2ZXMuY2xvc2VfaW4gaWM7IHJhaXNlIEVuZF9vZl9maWxlXG5cbiAgKCogVGhlIHNjYW5uZXIgZG9lcyBub3QgY2xvc2UgdGhlIGlucHV0IGNoYW5uZWwgYXQgZW5kIG9mIGlucHV0OlxuICAgICBpdCBqdXN0IHJhaXNlcyBbRW5kX29mX2ZpbGVdLiAqKVxuICBsZXQgc2Nhbl9yYWlzZV9hdF9lbmQgX2ljID0gcmFpc2UgRW5kX29mX2ZpbGVcblxuICBsZXQgZnJvbV9pYyBzY2FuX2Nsb3NlX2ljIGluYW1lIGljID1cbiAgICBsZXQgbGVuID0gIWZpbGVfYnVmZmVyX3NpemUgaW5cbiAgICBsZXQgYnVmID0gQnl0ZXMuY3JlYXRlIGxlbiBpblxuICAgIGxldCBpID0gcmVmIDAgaW5cbiAgICBsZXQgbGltID0gcmVmIDAgaW5cbiAgICBsZXQgZW9mID0gcmVmIGZhbHNlIGluXG4gICAgbGV0IG5leHQgKCkgPVxuICAgICAgaWYgIWkgPCAhbGltIHRoZW4gYmVnaW4gbGV0IGMgPSBCeXRlcy5nZXQgYnVmICFpIGluIGluY3IgaTsgYyBlbmQgZWxzZVxuICAgICAgaWYgIWVvZiB0aGVuIHJhaXNlIEVuZF9vZl9maWxlIGVsc2UgYmVnaW5cbiAgICAgICAgbGltIDo9IGlucHV0IGljIGJ1ZiAwIGxlbjtcbiAgICAgICAgaWYgIWxpbSA9IDAgdGhlbiBiZWdpbiBlb2YgOj0gdHJ1ZTsgc2Nhbl9jbG9zZV9pYyBpYyBlbmQgZWxzZSBiZWdpblxuICAgICAgICAgIGkgOj0gMTtcbiAgICAgICAgICBCeXRlcy5nZXQgYnVmIDBcbiAgICAgICAgZW5kXG4gICAgICBlbmQgaW5cbiAgICBjcmVhdGUgaW5hbWUgbmV4dFxuXG5cbiAgbGV0IGZyb21faWNfY2xvc2VfYXRfZW5kID0gZnJvbV9pYyBzY2FuX2Nsb3NlX2F0X2VuZFxuICBsZXQgZnJvbV9pY19yYWlzZV9hdF9lbmQgPSBmcm9tX2ljIHNjYW5fcmFpc2VfYXRfZW5kXG5cbiAgKCogVGhlIHNjYW5uaW5nIGJ1ZmZlciByZWFkaW5nIGZyb20gW1BlcnZhc2l2ZXMuc3RkaW5dLlxuICAgICBPbmUgY291bGQgdHJ5IHRvIGRlZmluZSBbc3RkaWJdIGFzIGEgc2Nhbm5pbmcgYnVmZmVyIHJlYWRpbmcgYSBjaGFyYWN0ZXJcbiAgICAgYXQgYSB0aW1lIChubyBidWZmZXJpemF0aW9uIGF0IGFsbCksIGJ1dCB1bmZvcnR1bmF0ZWx5IHRoZSB0b3AtbGV2ZWxcbiAgICAgaW50ZXJhY3Rpb24gd291bGQgYmUgd3JvbmcuIFRoaXMgaXMgZHVlIHRvIHNvbWUga2luZCBvZlxuICAgICAncmFjZSBjb25kaXRpb24nIHdoZW4gcmVhZGluZyBmcm9tIFtQZXJ2YXNpdmVzLnN0ZGluXSxcbiAgICAgc2luY2UgdGhlIGludGVyYWN0aXZlIGNvbXBpbGVyIGFuZCBbU2NhbmYuc2NhbmZdIHdpbGwgc2ltdWx0YW5lb3VzbHlcbiAgICAgcmVhZCB0aGUgbWF0ZXJpYWwgdGhleSBuZWVkIGZyb20gW1BlcnZhc2l2ZXMuc3RkaW5dOyB0aGVuLCBjb25mdXNpb25cbiAgICAgd2lsbCByZXN1bHQgZnJvbSB3aGF0IHNob3VsZCBiZSByZWFkIGJ5IHRoZSB0b3AtbGV2ZWwgYW5kIHdoYXQgc2hvdWxkIGJlXG4gICAgIHJlYWQgYnkgW1NjYW5mLnNjYW5mXS5cbiAgICAgVGhpcyBpcyBldmVuIG1vcmUgY29tcGxpY2F0ZWQgYnkgdGhlIG9uZSBjaGFyYWN0ZXIgbG9va2FoZWFkIHRoYXRcbiAgICAgW1NjYW5mLnNjYW5mXSBpcyBzb21ldGltZXMgb2JsaWdlZCB0byBtYWludGFpbjogdGhlIGxvb2thaGVhZCBjaGFyYWN0ZXJcbiAgICAgd2lsbCBiZSBhdmFpbGFibGUgZm9yIHRoZSBuZXh0IFtTY2FuZi5zY2FuZl0gZW50cnksIHNlZW1pbmdseSBjb21pbmcgZnJvbVxuICAgICBub3doZXJlLlxuICAgICBBbHNvIG5vIFtFbmRfb2ZfZmlsZV0gaXMgcmFpc2VkIHdoZW4gcmVhZGluZyBmcm9tIHN0ZGluOiBpZiBub3QgZW5vdWdoXG4gICAgIGNoYXJhY3RlcnMgaGF2ZSBiZWVuIHJlYWQsIHdlIHNpbXBseSBhc2sgdG8gcmVhZCBtb3JlLiAqKVxuICBsZXQgc3RkaW4gPVxuICAgIGZyb21faWMgc2Nhbl9yYWlzZV9hdF9lbmRcbiAgICAgIChGcm9tX2ZpbGUgKFwiLVwiLCBQZXJ2YXNpdmVzLnN0ZGluKSkgUGVydmFzaXZlcy5zdGRpblxuXG5cbiAgbGV0IHN0ZGliID0gc3RkaW5cblxuICBsZXQgb3Blbl9pbl9maWxlIG9wZW5faW4gZm5hbWUgPVxuICAgIG1hdGNoIGZuYW1lIHdpdGhcbiAgICB8IFwiLVwiIC0+IHN0ZGluXG4gICAgfCBmbmFtZSAtPlxuICAgICAgbGV0IGljID0gb3Blbl9pbiBmbmFtZSBpblxuICAgICAgZnJvbV9pY19jbG9zZV9hdF9lbmQgKEZyb21fZmlsZSAoZm5hbWUsIGljKSkgaWNcblxuXG4gIGxldCBvcGVuX2luID0gb3Blbl9pbl9maWxlIFBlcnZhc2l2ZXMub3Blbl9pblxuICBsZXQgb3Blbl9pbl9iaW4gPSBvcGVuX2luX2ZpbGUgUGVydmFzaXZlcy5vcGVuX2luX2JpblxuXG4gIGxldCBmcm9tX2ZpbGUgPSBvcGVuX2luXG4gIGxldCBmcm9tX2ZpbGVfYmluID0gb3Blbl9pbl9iaW5cblxuICBsZXQgZnJvbV9jaGFubmVsIGljID1cbiAgICBmcm9tX2ljX3JhaXNlX2F0X2VuZCAoRnJvbV9jaGFubmVsIGljKSBpY1xuXG5cbiAgbGV0IGNsb3NlX2luIGliID1cbiAgICBtYXRjaCBpYi5pY19pbnB1dF9uYW1lIHdpdGhcbiAgICB8IEZyb21fY2hhbm5lbCBpYyAtPlxuICAgICAgUGVydmFzaXZlcy5jbG9zZV9pbiBpY1xuICAgIHwgRnJvbV9maWxlIChfZm5hbWUsIGljKSAtPiBQZXJ2YXNpdmVzLmNsb3NlX2luIGljXG4gICAgfCBGcm9tX2Z1bmN0aW9uIHwgRnJvbV9zdHJpbmcgLT4gKClcblxuXG4gICgqXG4gICAgIE9ic29sZXRlOiBhIG1lbW8gW2Zyb21fY2hhbm5lbF0gdmVyc2lvbiB0byBidWlsZCBhIFtTY2FubmluZy5pbl9jaGFubmVsXVxuICAgICBzY2FubmluZyBidWZmZXIgb3V0IG9mIGEgW1BlcnZhc2l2ZXMuaW5fY2hhbm5lbF0uXG4gICAgIFRoaXMgZnVuY3Rpb24gd2FzIHVzZWQgdG8gdHJ5IHRvIHByZXNlcnZlIHRoZSBzY2FubmluZ1xuICAgICBzZW1hbnRpY3MgZm9yIHRoZSAobm93IG9ic29sZXRlKSBmdW5jdGlvbiBbZnNjYW5mXS5cbiAgICAgR2l2ZW4gdGhhdCBhbGwgc2Nhbm5lciBtdXN0IHJlYWQgZnJvbSBhIFtTY2FubmluZy5pbl9jaGFubmVsXSBzY2FubmluZ1xuICAgICBidWZmZXIsIFtmc2NhbmZdIG11c3QgcmVhZCBmcm9tIG9uZSFcbiAgICAgTW9yZSBwcmVjaXNlbHksIGdpdmVuIFtpY10sIGFsbCBzdWNjZXNzaXZlIGNhbGxzIFtmc2NhbmYgaWNdIG11c3QgcmVhZFxuICAgICBmcm9tIHRoZSBzYW1lIHNjYW5uaW5nIGJ1ZmZlci5cbiAgICAgVGhpcyBvYmxpZ2VkIHRoaXMgbGlicmFyeSB0byBhbGxvY2F0ZWQgc2Nhbm5pbmcgYnVmZmVycyB0aGF0IHdlcmVcbiAgICAgbm90IHByb3Blcmx5IGdhcmJhZ2UgY29sbGVjdGFibGUsIGhlbmNlIGxlYWRpbmcgdG8gbWVtb3J5IGxlYWtzLlxuICAgICBJZiB5b3UgbmVlZCB0byByZWFkIGZyb20gYSBbUGVydmFzaXZlcy5pbl9jaGFubmVsXSBpbnB1dCBjaGFubmVsXG4gICAgIFtpY10sIHNpbXBseSBkZWZpbmUgYSBbU2Nhbm5pbmcuaW5fY2hhbm5lbF0gZm9ybWF0dGVkIGlucHV0IGNoYW5uZWwgYXMgaW5cbiAgICAgW2xldCBpYiA9IFNjYW5uaW5nLmZyb21fY2hhbm5lbCBpY10sIHRoZW4gdXNlIFtTY2FuZi5ic2NhbmYgaWJdIGFzIHVzdWFsLlxuICAqKVxuICBsZXQgbWVtb19mcm9tX2ljID1cbiAgICBsZXQgbWVtbyA9IHJlZiBbXSBpblxuICAgIChmdW4gc2Nhbl9jbG9zZV9pYyBpYyAtPlxuICAgICB0cnkgTGlzdC5hc3NxIGljICFtZW1vIHdpdGhcbiAgICAgfCBOb3RfZm91bmQgLT5cbiAgICAgICBsZXQgaWIgPVxuICAgICAgICAgZnJvbV9pYyBzY2FuX2Nsb3NlX2ljIChGcm9tX2NoYW5uZWwgaWMpIGljIGluXG4gICAgICAgbWVtbyA6PSAoaWMsIGliKSA6OiAhbWVtbztcbiAgICAgICBpYilcblxuXG4gICgqIE9ic29sZXRlOiBzZWUgeyFtZW1vX2Zyb21faWN9IGFib3ZlLiAqKVxuICBsZXQgbWVtb19mcm9tX2NoYW5uZWwgPSBtZW1vX2Zyb21faWMgc2Nhbl9yYWlzZV9hdF9lbmRcblxuZW5kXG5cblxuKCogRm9ybWF0dGVkIGlucHV0IGZ1bmN0aW9ucy4gKilcblxudHlwZSAoJ2EsICdiLCAnYywgJ2QpIHNjYW5uZXIgPVxuICAgICAoJ2EsIFNjYW5uaW5nLmluX2NoYW5uZWwsICdiLCAnYywgJ2EgLT4gJ2QsICdkKSBmb3JtYXQ2IC0+ICdjXG5cblxuKCogUmVwb3J0aW5nIGVycm9ycy4gKilcbmV4Y2VwdGlvbiBTY2FuX2ZhaWx1cmUgb2Ygc3RyaW5nXG5cbmxldCBiYWRfaW5wdXQgcyA9IHJhaXNlIChTY2FuX2ZhaWx1cmUgcylcblxubGV0IGJhZF9pbnB1dF9lc2NhcGUgYyA9XG4gIGJhZF9pbnB1dCAoUHJpbnRmLnNwcmludGYgXCJpbGxlZ2FsIGVzY2FwZSBjaGFyYWN0ZXIgJUNcIiBjKVxuXG5cbmxldCBiYWRfdG9rZW5fbGVuZ3RoIG1lc3NhZ2UgPVxuICBiYWRfaW5wdXRcbiAgICAoUHJpbnRmLnNwcmludGZcbiAgICAgICBcInNjYW5uaW5nIG9mICVzIGZhaWxlZDogXFxcbiAgICAgICAgdGhlIHNwZWNpZmllZCBsZW5ndGggd2FzIHRvbyBzaG9ydCBmb3IgdG9rZW5cIlxuICAgICAgIG1lc3NhZ2UpXG5cblxubGV0IGJhZF9lbmRfb2ZfaW5wdXQgbWVzc2FnZSA9XG4gIGJhZF9pbnB1dFxuICAgIChQcmludGYuc3ByaW50ZlxuICAgICAgIFwic2Nhbm5pbmcgb2YgJXMgZmFpbGVkOiBcXFxuICAgICAgICBwcmVtYXR1cmUgZW5kIG9mIGZpbGUgb2NjdXJyZWQgYmVmb3JlIGVuZCBvZiB0b2tlblwiXG4gICAgICAgbWVzc2FnZSlcblxuXG5sZXQgYmFkX2Zsb2F0ICgpID1cbiAgYmFkX2lucHV0IFwibm8gZG90IG9yIGV4cG9uZW50IHBhcnQgZm91bmQgaW4gZmxvYXQgdG9rZW5cIlxuXG5cbmxldCBiYWRfaGV4X2Zsb2F0ICgpID1cbiAgYmFkX2lucHV0IFwibm90IGEgdmFsaWQgZmxvYXQgaW4gaGV4YWRlY2ltYWwgbm90YXRpb25cIlxuXG5cbmxldCBjaGFyYWN0ZXJfbWlzbWF0Y2hfZXJyIGMgY2kgPVxuICBQcmludGYuc3ByaW50ZiBcImxvb2tpbmcgZm9yICVDLCBmb3VuZCAlQ1wiIGMgY2lcblxuXG5sZXQgY2hhcmFjdGVyX21pc21hdGNoIGMgY2kgPVxuICBiYWRfaW5wdXQgKGNoYXJhY3Rlcl9taXNtYXRjaF9lcnIgYyBjaSlcblxuXG5sZXQgcmVjIHNraXBfd2hpdGVzIGliID1cbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgbm90IChTY2FubmluZy5lb2YgaWIpIHRoZW4gYmVnaW5cbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8ICcgJyB8ICdcXHQnIHwgJ1xcbicgfCAnXFxyJyAtPlxuICAgICAgU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWI7IHNraXBfd2hpdGVzIGliXG4gICAgfCBfIC0+ICgpXG4gIGVuZFxuXG5cbigqIENoZWNraW5nIHRoYXQgW2NdIGlzIGluZGVlZCBpbiB0aGUgaW5wdXQsIHRoZW4gc2tpcHMgaXQuXG4gICBJbiB0aGlzIGNhc2UsIHRoZSBjaGFyYWN0ZXIgW2NdIGhhcyBiZWVuIGV4cGxpY2l0bHkgc3BlY2lmaWVkIGluIHRoZVxuICAgZm9ybWF0IGFzIGJlaW5nIG1hbmRhdG9yeSBpbiB0aGUgaW5wdXQ7IGhlbmNlIHdlIHNob3VsZCBmYWlsIHdpdGhcbiAgIFtFbmRfb2ZfZmlsZV0gaW4gY2FzZSBvZiBlbmRfb2ZfaW5wdXQuXG4gICAoUmVtZW1iZXIgdGhhdCBbU2Nhbl9mYWlsdXJlXSBpcyByYWlzZWQgb25seSB3aGVuICh3ZSBjYW4gcHJvdmUgYnlcbiAgIGV2aWRlbmNlKSB0aGF0IHRoZSBpbnB1dCBkb2VzIG5vdCBtYXRjaCB0aGUgZm9ybWF0IHN0cmluZyBnaXZlbi4gV2UgbXVzdFxuICAgdGh1cyBkaWZmZXJlbnRpYXRlIFtFbmRfb2ZfZmlsZV0gYXMgYW4gZXJyb3IgZHVlIHRvIGxhY2sgb2YgaW5wdXQsIGFuZFxuICAgW1NjYW5fZmFpbHVyZV0gd2hpY2ggaXMgZHVlIHRvIHByb3ZhYmx5IHdyb25nIGlucHV0LiBJIGFtIG5vdCBzdXJlIHRoaXMgaXNcbiAgIHdvcnRoIHRoZSBidXJkZW46IGl0IGlzIGNvbXBsZXggYW5kIHNvbWVob3cgc3VibGltaW5hbDsgc2hvdWxkIGJlIGNsZWFyZXJcbiAgIHRvIGZhaWwgd2l0aCBTY2FuX2ZhaWx1cmUgXCJOb3QgZW5vdWdoIGlucHV0IHRvIGNvbXBsZXRlIHNjYW5uaW5nXCIhKVxuXG4gICBUaGF0J3Mgd2h5LCB3YWl0aW5nIGZvciBhIGJldHRlciBzb2x1dGlvbiwgd2UgdXNlIGNoZWNrZWRfcGVla19jaGFyIGhlcmUuXG4gICBXZSBhcmUgYWxzbyBjYXJlZnVsIHRvIHRyZWF0IFwiXFxyXFxuXCIgaW4gdGhlIGlucHV0IGFzIGFuIGVuZCBvZiBsaW5lIG1hcmtlcjpcbiAgIGl0IGFsd2F5cyBtYXRjaGVzIGEgJ1xcbicgc3BlY2lmaWNhdGlvbiBpbiB0aGUgaW5wdXQgZm9ybWF0IHN0cmluZy4gKilcbmxldCByZWMgY2hlY2tfY2hhciBpYiBjID1cbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJyAnIC0+IHNraXBfd2hpdGVzIGliXG4gIHwgJ1xcbicgLT4gY2hlY2tfbmV3bGluZSBpYlxuICB8IGMgLT4gY2hlY2tfdGhpc19jaGFyIGliIGNcblxuYW5kIGNoZWNrX3RoaXNfY2hhciBpYiBjID1cbiAgbGV0IGNpID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgaWYgY2kgPSBjIHRoZW4gU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWIgZWxzZVxuICBjaGFyYWN0ZXJfbWlzbWF0Y2ggYyBjaVxuXG5hbmQgY2hlY2tfbmV3bGluZSBpYiA9XG4gIGxldCBjaSA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIG1hdGNoIGNpIHdpdGhcbiAgfCAnXFxuJyAtPiBTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYlxuICB8ICdcXHInIC0+IFNjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliOyBjaGVja190aGlzX2NoYXIgaWIgJ1xcbidcbiAgfCBfIC0+IGNoYXJhY3Rlcl9taXNtYXRjaCAnXFxuJyBjaVxuXG5cbigqIEV4dHJhY3RpbmcgdG9rZW5zIGZyb20gdGhlIG91dHB1dCB0b2tlbiBidWZmZXIuICopXG5cbmxldCB0b2tlbl9jaGFyIGliID0gKFNjYW5uaW5nLnRva2VuIGliKS5bMF1cblxubGV0IHRva2VuX3N0cmluZyA9IFNjYW5uaW5nLnRva2VuXG5cbmxldCB0b2tlbl9ib29sIGliID1cbiAgbWF0Y2ggU2Nhbm5pbmcudG9rZW4gaWIgd2l0aFxuICB8IFwidHJ1ZVwiIC0+IHRydWVcbiAgfCBcImZhbHNlXCIgLT4gZmFsc2VcbiAgfCBzIC0+IGJhZF9pbnB1dCAoUHJpbnRmLnNwcmludGYgXCJpbnZhbGlkIGJvb2xlYW4gJyVzJ1wiIHMpXG5cblxuKCogVGhlIHR5cGUgb2YgaW50ZWdlciBjb252ZXJzaW9ucy4gKilcbnR5cGUgaW50ZWdlcl9jb252ZXJzaW9uID1cbiAgfCBCX2NvbnZlcnNpb24gKCogVW5zaWduZWQgYmluYXJ5IGNvbnZlcnNpb24gKilcbiAgfCBEX2NvbnZlcnNpb24gKCogU2lnbmVkIGRlY2ltYWwgY29udmVyc2lvbiAqKVxuICB8IElfY29udmVyc2lvbiAoKiBTaWduZWQgaW50ZWdlciBjb252ZXJzaW9uICopXG4gIHwgT19jb252ZXJzaW9uICgqIFVuc2lnbmVkIG9jdGFsIGNvbnZlcnNpb24gKilcbiAgfCBVX2NvbnZlcnNpb24gKCogVW5zaWduZWQgZGVjaW1hbCBjb252ZXJzaW9uICopXG4gIHwgWF9jb252ZXJzaW9uICgqIFVuc2lnbmVkIGhleGFkZWNpbWFsIGNvbnZlcnNpb24gKilcblxuXG5sZXQgaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIgPSBmdW5jdGlvblxuICB8ICdiJyAtPiBCX2NvbnZlcnNpb25cbiAgfCAnZCcgLT4gRF9jb252ZXJzaW9uXG4gIHwgJ2knIC0+IElfY29udmVyc2lvblxuICB8ICdvJyAtPiBPX2NvbnZlcnNpb25cbiAgfCAndScgLT4gVV9jb252ZXJzaW9uXG4gIHwgJ3gnIHwgJ1gnIC0+IFhfY29udmVyc2lvblxuICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cblxuKCogRXh0cmFjdCBhbiBpbnRlZ2VyIGxpdGVyYWwgdG9rZW4uXG4gICBTaW5jZSB0aGUgZnVuY3Rpb25zIFBlcnZhc2l2ZXMuKmludCpfb2Zfc3RyaW5nIGRvIG5vdCBhY2NlcHQgYSBsZWFkaW5nICssXG4gICB3ZSBza2lwIGl0IGlmIG5lY2Vzc2FyeS4gKilcbmxldCB0b2tlbl9pbnRfbGl0ZXJhbCBjb252IGliID1cbiAgbGV0IHRvayA9XG4gICAgbWF0Y2ggY29udiB3aXRoXG4gICAgfCBEX2NvbnZlcnNpb24gfCBJX2NvbnZlcnNpb24gLT4gU2Nhbm5pbmcudG9rZW4gaWJcbiAgICB8IFVfY29udmVyc2lvbiAtPiBcIjB1XCIgXiBTY2FubmluZy50b2tlbiBpYlxuICAgIHwgT19jb252ZXJzaW9uIC0+IFwiMG9cIiBeIFNjYW5uaW5nLnRva2VuIGliXG4gICAgfCBYX2NvbnZlcnNpb24gLT4gXCIweFwiIF4gU2Nhbm5pbmcudG9rZW4gaWJcbiAgICB8IEJfY29udmVyc2lvbiAtPiBcIjBiXCIgXiBTY2FubmluZy50b2tlbiBpYiBpblxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggdG9rIGluXG4gIGlmIGwgPSAwIHx8IHRvay5bMF0gPD4gJysnIHRoZW4gdG9rIGVsc2UgU3RyaW5nLnN1YiB0b2sgMSAobCAtIDEpXG5cblxuKCogQWxsIHRoZSBmdW5jdGlvbnMgdGhhdCBjb252ZXJ0IGEgc3RyaW5nIHRvIGEgbnVtYmVyIHJhaXNlIHRoZSBleGNlcHRpb25cbiAgIEZhaWx1cmUgd2hlbiB0aGUgY29udmVyc2lvbiBpcyBub3QgcG9zc2libGUuXG4gICBUaGlzIGV4Y2VwdGlvbiBpcyB0aGVuIHRyYXBwZWQgaW4gW2tzY2FuZl0uICopXG5sZXQgdG9rZW5faW50IGNvbnYgaWIgPSBpbnRfb2Zfc3RyaW5nICh0b2tlbl9pbnRfbGl0ZXJhbCBjb252IGliKVxuXG5sZXQgdG9rZW5fZmxvYXQgaWIgPSBmbG9hdF9vZl9zdHJpbmcgKFNjYW5uaW5nLnRva2VuIGliKVxuXG4oKiBUbyBzY2FuIG5hdGl2ZSBpbnRzLCBpbnQzMiBhbmQgaW50NjQgaW50ZWdlcnMuXG4gICBXZSBjYW5ub3QgYWNjZXNzIHRvIGNvbnZlcnNpb25zIHRvL2Zyb20gc3RyaW5ncyBmb3IgdGhvc2UgdHlwZXMsXG4gICBOYXRpdmVpbnQub2Zfc3RyaW5nLCBJbnQzMi5vZl9zdHJpbmcsIGFuZCBJbnQ2NC5vZl9zdHJpbmcsXG4gICBzaW5jZSB0aG9zZSBtb2R1bGVzIGFyZSBub3QgYXZhaWxhYmxlIHRvIFtTY2FuZl0uXG4gICBIb3dldmVyLCB3ZSBjYW4gYmluZCBhbmQgdXNlIHRoZSBjb3JyZXNwb25kaW5nIHByaW1pdGl2ZXMgdGhhdCBhcmVcbiAgIGF2YWlsYWJsZSBpbiB0aGUgcnVudGltZS4gKilcbmV4dGVybmFsIG5hdGl2ZWludF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gbmF0aXZlaW50XG4gID0gXCJjYW1sX25hdGl2ZWludF9vZl9zdHJpbmdcIlxuXG5leHRlcm5hbCBpbnQzMl9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50MzJcbiAgPSBcImNhbWxfaW50MzJfb2Zfc3RyaW5nXCJcblxuZXh0ZXJuYWwgaW50NjRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludDY0XG4gID0gXCJjYW1sX2ludDY0X29mX3N0cmluZ1wiXG5cblxubGV0IHRva2VuX25hdGl2ZWludCBjb252IGliID0gbmF0aXZlaW50X29mX3N0cmluZyAodG9rZW5faW50X2xpdGVyYWwgY29udiBpYilcbmxldCB0b2tlbl9pbnQzMiBjb252IGliID0gaW50MzJfb2Zfc3RyaW5nICh0b2tlbl9pbnRfbGl0ZXJhbCBjb252IGliKVxubGV0IHRva2VuX2ludDY0IGNvbnYgaWIgPSBpbnQ2NF9vZl9zdHJpbmcgKHRva2VuX2ludF9saXRlcmFsIGNvbnYgaWIpXG5cbigqIFNjYW5uaW5nIG51bWJlcnMuICopXG5cbigqIERpZ2l0cyBzY2FubmluZyBmdW5jdGlvbnMgc3VwcG9zZSB0aGF0IG9uZSBjaGFyYWN0ZXIgaGFzIGJlZW4gY2hlY2tlZCBhbmRcbiAgIGlzIGF2YWlsYWJsZSwgc2luY2UgdGhleSByZXR1cm4gYXQgZW5kIG9mIGZpbGUgd2l0aCB0aGUgY3VycmVudGx5IGZvdW5kXG4gICB0b2tlbiBzZWxlY3RlZC5cblxuICAgUHV0IGl0IGluIGFub3RoZXIgd2F5LCB0aGUgZGlnaXRzIHNjYW5uaW5nIGZ1bmN0aW9ucyBzY2FuIGZvciBhIHBvc3NpYmx5XG4gICBlbXB0eSBzZXF1ZW5jZSBvZiBkaWdpdHMsIChoZW5jZSwgYSBzdWNjZXNzZnVsIHNjYW5uaW5nIGZyb20gb25lIG9mIHRob3NlXG4gICBmdW5jdGlvbnMgZG9lcyBub3QgaW1wbHkgdGhhdCB0aGUgdG9rZW4gaXMgYSB3ZWxsLWZvcm1lZCBudW1iZXI6IHRvIGdldCBhXG4gICB0cnVlIG51bWJlciwgaXQgaXMgbWFuZGF0b3J5IHRvIGNoZWNrIHRoYXQgYXQgbGVhc3Qgb25lIHZhbGlkIGRpZ2l0IGlzXG4gICBhdmFpbGFibGUgYmVmb3JlIGNhbGxpbmcgb25lIG9mIHRoZSBkaWdpdCBzY2FubmluZyBmdW5jdGlvbnMpLiAqKVxuXG4oKiBUaGUgZGVjaW1hbCBjYXNlIGlzIHRyZWF0ZWQgZXNwZWNpYWxseSBmb3Igb3B0aW1pemF0aW9uIHB1cnBvc2VzLiAqKVxubGV0IHJlYyBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYiA9XG4gIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGggZWxzZVxuICBtYXRjaCBjIHdpdGhcbiAgfCAnMCcgLi4gJzknIGFzIGMgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYlxuICB8ICdfJyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliIGluXG4gICAgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWJcbiAgfCBfIC0+IHdpZHRoXG5cblxubGV0IHNjYW5fZGVjaW1hbF9kaWdpdF9wbHVzIHdpZHRoIGliID1cbiAgaWYgd2lkdGggPSAwIHRoZW4gYmFkX3Rva2VuX2xlbmd0aCBcImRlY2ltYWwgZGlnaXRzXCIgZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcwJyAuLiAnOScgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYlxuICB8IGMgLT5cbiAgICBiYWRfaW5wdXQgKFByaW50Zi5zcHJpbnRmIFwiY2hhcmFjdGVyICVDIGlzIG5vdCBhIGRlY2ltYWwgZGlnaXRcIiBjKVxuXG5cbigqIFRvIHNjYW4gbnVtYmVycyBmcm9tIG90aGVyIGJhc2VzLCB3ZSB1c2UgYSBwcmVkaWNhdGUgYXJndW1lbnQgdG9cbiAgIHNjYW4gZGlnaXRzLiAqKVxubGV0IHNjYW5fZGlnaXRfc3RhciBkaWdpdHAgd2lkdGggaWIgPVxuICBsZXQgcmVjIHNjYW5fZGlnaXRzIHdpZHRoIGliID1cbiAgICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gICAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgbWF0Y2ggYyB3aXRoXG4gICAgfCBjIHdoZW4gZGlnaXRwIGMgLT5cbiAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgc2Nhbl9kaWdpdHMgd2lkdGggaWJcbiAgICB8ICdfJyAtPlxuICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIgaW5cbiAgICAgIHNjYW5fZGlnaXRzIHdpZHRoIGliXG4gICAgfCBfIC0+IHdpZHRoIGluXG4gIHNjYW5fZGlnaXRzIHdpZHRoIGliXG5cblxubGV0IHNjYW5fZGlnaXRfcGx1cyBiYXNpcyBkaWdpdHAgd2lkdGggaWIgPVxuICAoKiBFbnN1cmUgd2UgaGF2ZSBnb3QgZW5vdWdoIHdpZHRoIGxlZnQsXG4gICAgIGFuZCByZWFkIGF0IGxlYXN0IG9uZSBkaWdpdC4gKilcbiAgaWYgd2lkdGggPSAwIHRoZW4gYmFkX3Rva2VuX2xlbmd0aCBcImRpZ2l0c1wiIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBpZiBkaWdpdHAgYyB0aGVuXG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgc2Nhbl9kaWdpdF9zdGFyIGRpZ2l0cCB3aWR0aCBpYlxuICBlbHNlXG4gICAgYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcImNoYXJhY3RlciAlQyBpcyBub3QgYSB2YWxpZCAlcyBkaWdpdFwiIGMgYmFzaXMpXG5cblxubGV0IGlzX2JpbmFyeV9kaWdpdCA9IGZ1bmN0aW9uXG4gIHwgJzAnIC4uICcxJyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuXG5cbmxldCBzY2FuX2JpbmFyeV9pbnQgPSBzY2FuX2RpZ2l0X3BsdXMgXCJiaW5hcnlcIiBpc19iaW5hcnlfZGlnaXRcblxubGV0IGlzX29jdGFsX2RpZ2l0ID0gZnVuY3Rpb25cbiAgfCAnMCcgLi4gJzcnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cblxubGV0IHNjYW5fb2N0YWxfaW50ID0gc2Nhbl9kaWdpdF9wbHVzIFwib2N0YWxcIiBpc19vY3RhbF9kaWdpdFxuXG5sZXQgaXNfaGV4YV9kaWdpdCA9IGZ1bmN0aW9uXG4gIHwgJzAnIC4uICc5JyB8ICdhJyAuLiAnZicgfCAnQScgLi4gJ0YnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cblxubGV0IHNjYW5faGV4YWRlY2ltYWxfaW50ID0gc2Nhbl9kaWdpdF9wbHVzIFwiaGV4YWRlY2ltYWxcIiBpc19oZXhhX2RpZ2l0XG5cbigqIFNjYW4gYSBkZWNpbWFsIGludGVnZXIuICopXG5sZXQgc2Nhbl91bnNpZ25lZF9kZWNpbWFsX2ludCA9IHNjYW5fZGVjaW1hbF9kaWdpdF9wbHVzXG5cbmxldCBzY2FuX3NpZ24gd2lkdGggaWIgPVxuICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcrJyAtPiBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGNcbiAgfCAnLScgLT4gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjXG4gIHwgXyAtPiB3aWR0aFxuXG5cbmxldCBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliID1cbiAgbGV0IHdpZHRoID0gc2Nhbl9zaWduIHdpZHRoIGliIGluXG4gIHNjYW5fdW5zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcblxuXG4oKiBTY2FuIGFuIHVuc2lnbmVkIGludGVnZXIgdGhhdCBjb3VsZCBiZSBnaXZlbiBpbiBhbnkgKGNvbW1vbikgYmFzaXMuXG4gICBJZiBkaWdpdHMgYXJlIHByZWZpeGVkIGJ5IG9uZSBvZiAweCwgMFgsIDBvLCBvciAwYiwgdGhlIG51bWJlciBpc1xuICAgYXNzdW1lZCB0byBiZSB3cml0dGVuIHJlc3BlY3RpdmVseSBpbiBoZXhhZGVjaW1hbCwgaGV4YWRlY2ltYWwsXG4gICBvY3RhbCwgb3IgYmluYXJ5LiAqKVxubGV0IHNjYW5fdW5zaWduZWRfaW50IHdpZHRoIGliID1cbiAgbWF0Y2ggU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgd2l0aFxuICB8ICcwJyBhcyBjIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICAgIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGggZWxzZVxuICAgIGJlZ2luIG1hdGNoIGMgd2l0aFxuICAgIHwgJ3gnIHwgJ1gnIC0+IHNjYW5faGV4YWRlY2ltYWxfaW50IChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGliXG4gICAgfCAnbycgLT4gc2Nhbl9vY3RhbF9pbnQgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaWJcbiAgICB8ICdiJyAtPiBzY2FuX2JpbmFyeV9pbnQgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaWJcbiAgICB8IF8gLT4gc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWIgZW5kXG4gIHwgXyAtPiBzY2FuX3Vuc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG5cblxubGV0IHNjYW5fb3B0aW9uYWxseV9zaWduZWRfaW50IHdpZHRoIGliID1cbiAgbGV0IHdpZHRoID0gc2Nhbl9zaWduIHdpZHRoIGliIGluXG4gIHNjYW5fdW5zaWduZWRfaW50IHdpZHRoIGliXG5cblxubGV0IHNjYW5faW50X2NvbnZlcnNpb24gY29udiB3aWR0aCBpYiA9XG4gIG1hdGNoIGNvbnYgd2l0aFxuICB8IEJfY29udmVyc2lvbiAtPiBzY2FuX2JpbmFyeV9pbnQgd2lkdGggaWJcbiAgfCBEX2NvbnZlcnNpb24gLT4gc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuICB8IElfY29udmVyc2lvbiAtPiBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2ludCB3aWR0aCBpYlxuICB8IE9fY29udmVyc2lvbiAtPiBzY2FuX29jdGFsX2ludCB3aWR0aCBpYlxuICB8IFVfY29udmVyc2lvbiAtPiBzY2FuX3Vuc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG4gIHwgWF9jb252ZXJzaW9uIC0+IHNjYW5faGV4YWRlY2ltYWxfaW50IHdpZHRoIGliXG5cblxuKCogU2Nhbm5pbmcgZmxvYXRpbmcgcG9pbnQgbnVtYmVycy4gKilcblxuKCogRnJhY3Rpb25hbCBwYXJ0IGlzIG9wdGlvbmFsIGFuZCBjYW4gYmUgcmVkdWNlZCB0byAwIGRpZ2l0cy4gKilcbmxldCBzY2FuX2ZyYWN0aW9uYWxfcGFydCB3aWR0aCBpYiA9XG4gIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGggZWxzZVxuICBtYXRjaCBjIHdpdGhcbiAgfCAnMCcgLi4gJzknIGFzIGMgLT5cbiAgICBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpYlxuICB8IF8gLT4gd2lkdGhcblxuXG4oKiBFeHAgcGFydCBpcyBvcHRpb25hbCBhbmQgY2FuIGJlIHJlZHVjZWQgdG8gMCBkaWdpdHMuICopXG5sZXQgc2Nhbl9leHBvbmVudF9wYXJ0IHdpZHRoIGliID1cbiAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gIG1hdGNoIGMgd2l0aFxuICB8ICdlJyB8ICdFJyBhcyBjIC0+XG4gICAgc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsX2ludCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpYlxuICB8IF8gLT4gd2lkdGhcblxuXG4oKiBTY2FuIHRoZSBpbnRlZ2VyIHBhcnQgb2YgYSBmbG9hdGluZyBwb2ludCBudW1iZXIsIChub3QgdXNpbmcgdGhlXG4gICBPQ2FtbCBsZXhpY2FsIGNvbnZlbnRpb24gc2luY2UgdGhlIGludGVnZXIgcGFydCBjYW4gYmUgZW1wdHkpOlxuICAgYW4gb3B0aW9uYWwgc2lnbiwgZm9sbG93ZWQgYnkgYSBwb3NzaWJseSBlbXB0eSBzZXF1ZW5jZSBvZiBkZWNpbWFsXG4gICBkaWdpdHMgKGUuZy4gLS4xKS4gKilcbmxldCBzY2FuX2ludGVnZXJfcGFydCB3aWR0aCBpYiA9XG4gIGxldCB3aWR0aCA9IHNjYW5fc2lnbiB3aWR0aCBpYiBpblxuICBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYlxuXG5cbigqXG4gICBGb3IgdGhlIHRpbWUgYmVpbmcgd2UgaGF2ZSAoYXMgZm91bmQgaW4gc2NhbmYubWxpKTpcbiAgIHRoZSBmaWVsZCB3aWR0aCBpcyBjb21wb3NlZCBvZiBhbiBvcHRpb25hbCBpbnRlZ2VyIGxpdGVyYWxcbiAgIGluZGljYXRpbmcgdGhlIG1heGltYWwgd2lkdGggb2YgdGhlIHRva2VuIHRvIHJlYWQuXG4gICBVbmZvcnR1bmF0ZWx5LCB0aGUgdHlwZS1jaGVja2VyIGxldCB0aGUgdXNlciB3cml0ZSBhbiBvcHRpb25hbCBwcmVjaXNpb24sXG4gICBzaW5jZSB0aGlzIGlzIHZhbGlkIGZvciBwcmludGYgZm9ybWF0IHN0cmluZ3MuXG5cbiAgIFRodXMsIHRoZSBuZXh0IHN0ZXAgZm9yIFNjYW5mIGlzIHRvIHN1cHBvcnQgYSBmdWxsIHdpZHRoIGFuZCBwcmVjaXNpb25cbiAgIGluZGljYXRpb24sIG1vcmUgb3IgbGVzcyBzaW1pbGFyIHRvIHRoZSBvbmUgZm9yIHByaW50ZiwgcG9zc2libHkgZXh0ZW5kZWRcbiAgIHRvIHRoZSBzcGVjaWZpY2F0aW9uIG9mIGEgW21heCwgbWluXSByYW5nZSBmb3IgdGhlIHdpZHRoIG9mIHRoZSB0b2tlbiByZWFkXG4gICBmb3Igc3RyaW5ncy4gU29tZXRoaW5nIGxpa2UgdGhlIGZvbGxvd2luZyBzcGVjIGZvciBzY2FuZi5tbGk6XG5cbiAgIFRoZSBvcHRpb25hbCBbd2lkdGhdIGlzIGFuIGludGVnZXIgaW5kaWNhdGluZyB0aGUgbWF4aW1hbFxuICAgd2lkdGggb2YgdGhlIHRva2VuIHJlYWQuIEZvciBpbnN0YW5jZSwgWyU2ZF0gcmVhZHMgYW4gaW50ZWdlcixcbiAgIGhhdmluZyBhdCBtb3N0IDYgY2hhcmFjdGVycy5cblxuICAgVGhlIG9wdGlvbmFsIFtwcmVjaXNpb25dIGlzIGEgZG90IFsuXSBmb2xsb3dlZCBieSBhbiBpbnRlZ2VyOlxuXG4gICAtIGluIHRoZSBmbG9hdGluZyBwb2ludCBudW1iZXIgY29udmVyc2lvbnMgKFslZl0sIFslZV0sIFslZ10sIFslRl0sIFslRV0sXG4gICBhbmQgWyVGXSBjb252ZXJzaW9ucywgdGhlIFtwcmVjaXNpb25dIGluZGljYXRlcyB0aGUgbWF4aW11bSBudW1iZXIgb2ZcbiAgIGRpZ2l0cyB0aGF0IG1heSBmb2xsb3cgdGhlIGRlY2ltYWwgcG9pbnQuIEZvciBpbnN0YW5jZSwgWyUuNGZdIHJlYWRzIGFcbiAgIFtmbG9hdF0gd2l0aCBhdCBtb3N0IDQgZnJhY3Rpb25hbCBkaWdpdHMsXG5cbiAgIC0gaW4gdGhlIHN0cmluZyBjb252ZXJzaW9ucyAoWyVzXSwgWyVTXSwgWyVcXFsgcmFuZ2UgXFxdXSksIGFuZCBpbiB0aGVcbiAgIGludGVnZXIgbnVtYmVyIGNvbnZlcnNpb25zIChbJWldLCBbJWRdLCBbJXVdLCBbJXhdLCBbJW9dLCBhbmQgdGhlaXJcbiAgIFtpbnQzMl0sIFtpbnQ2NF0sIGFuZCBbbmF0aXZlX2ludF0gY29ycmVzcG9uZGVudCksIHRoZSBbcHJlY2lzaW9uXVxuICAgaW5kaWNhdGVzIHRoZSByZXF1aXJlZCBtaW5pbXVtIHdpZHRoIG9mIHRoZSB0b2tlbiByZWFkLFxuXG4gICAtIG9uIGFsbCBvdGhlciBjb252ZXJzaW9ucywgdGhlIHdpZHRoIGFuZCBwcmVjaXNpb24gc3BlY2lmeSB0aGUgW21heCwgbWluXVxuICAgcmFuZ2UgZm9yIHRoZSB3aWR0aCBvZiB0aGUgdG9rZW4gcmVhZC5cbiopXG5sZXQgc2Nhbl9mbG9hdCB3aWR0aCBwcmVjaXNpb24gaWIgPVxuICBsZXQgd2lkdGggPSBzY2FuX2ludGVnZXJfcGFydCB3aWR0aCBpYiBpblxuICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCwgcHJlY2lzaW9uIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGgsIHByZWNpc2lvbiBlbHNlXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcuJyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGxldCBwcmVjaXNpb24gPSBtaW4gd2lkdGggcHJlY2lzaW9uIGluXG4gICAgbGV0IHdpZHRoID0gd2lkdGggLSAocHJlY2lzaW9uIC0gc2Nhbl9mcmFjdGlvbmFsX3BhcnQgcHJlY2lzaW9uIGliKSBpblxuICAgIHNjYW5fZXhwb25lbnRfcGFydCB3aWR0aCBpYiwgcHJlY2lzaW9uXG4gIHwgXyAtPlxuICAgIHNjYW5fZXhwb25lbnRfcGFydCB3aWR0aCBpYiwgcHJlY2lzaW9uXG5cblxubGV0IGNoZWNrX2Nhc2VfaW5zZW5zaXRpdmVfc3RyaW5nIHdpZHRoIGliIGVycm9yIHN0ciA9XG4gIGxldCBsb3dlcmNhc2UgYyA9XG4gICAgbWF0Y2ggYyB3aXRoXG4gICAgfCAnQScgLi4gJ1onIC0+XG4gICAgICBjaGFyX29mX2ludCAoaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICdBJyArIGludF9vZl9jaGFyICdhJylcbiAgICB8IF8gLT4gYyBpblxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbGV0IHdpZHRoID0gcmVmIHdpZHRoIGluXG4gIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBsb3dlcmNhc2UgYyA8PiBsb3dlcmNhc2Ugc3RyLltpXSB0aGVuIGVycm9yICgpO1xuICAgIGlmICF3aWR0aCA9IDAgdGhlbiBlcnJvciAoKTtcbiAgICB3aWR0aCA6PSBTY2FubmluZy5zdG9yZV9jaGFyICF3aWR0aCBpYiBjO1xuICBkb25lO1xuICAhd2lkdGhcblxuXG5sZXQgc2Nhbl9oZXhfZmxvYXQgd2lkdGggcHJlY2lzaW9uIGliID1cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gIGxldCB3aWR0aCA9IHNjYW5fc2lnbiB3aWR0aCBpYiBpblxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgfCAnMCcgYXMgYyAtPiAoXG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gICAgbGV0IHdpZHRoID0gY2hlY2tfY2FzZV9pbnNlbnNpdGl2ZV9zdHJpbmcgd2lkdGggaWIgYmFkX2hleF9mbG9hdCBcInhcIiBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICBsZXQgd2lkdGggPSBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICB8ICcuJyB8ICdwJyB8ICdQJyAtPiB3aWR0aFxuICAgICAgICB8IF8gLT4gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgd2lkdGggaWIgaW5cbiAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICAgIGxldCB3aWR0aCA9IG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgICAgfCAnLicgYXMgYyAtPiAoXG4gICAgICAgICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgICAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICAgICAgICAgIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgICAgICAgIHwgJ3AnIHwgJ1AnIC0+IHdpZHRoXG4gICAgICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICAgIGxldCBwcmVjaXNpb24gPSBtaW4gd2lkdGggcHJlY2lzaW9uIGluXG4gICAgICAgICAgICAgICAgd2lkdGggLSAocHJlY2lzaW9uIC0gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgcHJlY2lzaW9uIGliKVxuICAgICAgICAgIClcbiAgICAgICAgICB8IF8gLT4gd2lkdGggaW5cbiAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgICAgICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICAgIHwgJ3AnIHwgJ1AnIGFzIGMgLT5cbiAgICAgICAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gICAgICAgICAgICBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG4gICAgICAgICAgfCBfIC0+IHdpZHRoXG4gIClcbiAgfCAnbicgfCAnTicgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICAgIGNoZWNrX2Nhc2VfaW5zZW5zaXRpdmVfc3RyaW5nIHdpZHRoIGliIGJhZF9oZXhfZmxvYXQgXCJhblwiXG4gIHwgJ2knIHwgJ0knIGFzIGMgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICBjaGVja19jYXNlX2luc2Vuc2l0aXZlX3N0cmluZyB3aWR0aCBpYiBiYWRfaGV4X2Zsb2F0IFwibmZpbml0eVwiXG4gIHwgXyAtPiBiYWRfaGV4X2Zsb2F0ICgpXG5cblxubGV0IHNjYW5fY2FtbF9mbG9hdF9yZXN0IHdpZHRoIHByZWNpc2lvbiBpYiA9XG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gIGxldCB3aWR0aCA9IHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliIGluXG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcuJyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICgqIFRoZSBlZmZlY3RpdmUgd2lkdGggYXZhaWxhYmxlIGZvciBzY2FubmluZyB0aGUgZnJhY3Rpb25hbCBwYXJ0IGlzXG4gICAgICAgdGhlIG1pbmltdW0gb2YgZGVjbGFyZWQgcHJlY2lzaW9uIGFuZCB3aWR0aCBsZWZ0LiAqKVxuICAgIGxldCBwcmVjaXNpb24gPSBtaW4gd2lkdGggcHJlY2lzaW9uIGluXG4gICAgKCogQWZ0ZXIgc2Nhbm5pbmcgdGhlIGZyYWN0aW9uYWwgcGFydCB3aXRoIFtwcmVjaXNpb25dIHByb3Zpc2lvbmFsIHdpZHRoLFxuICAgICAgIFt3aWR0aF9wcmVjaXNpb25dIGlzIGxlZnQuICopXG4gICAgbGV0IHdpZHRoX3ByZWNpc2lvbiA9IHNjYW5fZnJhY3Rpb25hbF9wYXJ0IHByZWNpc2lvbiBpYiBpblxuICAgICgqIEhlbmNlLCBzY2FubmluZyB0aGUgZnJhY3Rpb25hbCBwYXJ0IHRvb2sgZXhhY3RseVxuICAgICAgIFtwcmVjaXNpb24gLSB3aWR0aF9wcmVjaXNpb25dIGNoYXJzLiAqKVxuICAgIGxldCBmcmFjX3dpZHRoID0gcHJlY2lzaW9uIC0gd2lkdGhfcHJlY2lzaW9uIGluXG4gICAgKCogQW5kIG5ldyBwcm92aXNpb25hbCB3aWR0aCBpcyBbd2lkdGggLSB3aWR0aF9wcmVjaXNpb24uICopXG4gICAgbGV0IHdpZHRoID0gd2lkdGggLSBmcmFjX3dpZHRoIGluXG4gICAgc2Nhbl9leHBvbmVudF9wYXJ0IHdpZHRoIGliXG4gIHwgJ2UnIHwgJ0UnIC0+XG4gICAgc2Nhbl9leHBvbmVudF9wYXJ0IHdpZHRoIGliXG4gIHwgXyAtPiBiYWRfZmxvYXQgKClcblxuXG5sZXQgc2Nhbl9jYW1sX2Zsb2F0IHdpZHRoIHByZWNpc2lvbiBpYiA9XG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gIGxldCB3aWR0aCA9IHNjYW5fc2lnbiB3aWR0aCBpYiBpblxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICB8ICcwJyBhcyBjIC0+IChcbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICAgIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgfCAneCcgfCAnWCcgYXMgYyAtPiAoXG4gICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gICAgICBsZXQgd2lkdGggPSBzY2FuX2hleGFkZWNpbWFsX2ludCB3aWR0aCBpYiBpblxuICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgICAgIGxldCB3aWR0aCA9IG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgIHwgJy4nIGFzIGMgLT4gKFxuICAgICAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICAgICAgICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICAgICAgfCAncCcgfCAnUCcgLT4gd2lkdGhcbiAgICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICBsZXQgcHJlY2lzaW9uID0gbWluIHdpZHRoIHByZWNpc2lvbiBpblxuICAgICAgICAgICAgICB3aWR0aCAtIChwcmVjaXNpb24gLSBzY2FuX2hleGFkZWNpbWFsX2ludCBwcmVjaXNpb24gaWIpXG4gICAgICAgIClcbiAgICAgICAgfCAncCcgfCAnUCcgLT4gd2lkdGhcbiAgICAgICAgfCBfIC0+IGJhZF9mbG9hdCAoKSBpblxuICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgICAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgfCAncCcgfCAnUCcgYXMgYyAtPlxuICAgICAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICAgICAgICAgIHNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcbiAgICAgICAgfCBfIC0+IHdpZHRoXG4gICAgKVxuICAgIHwgXyAtPlxuICAgICAgc2Nhbl9jYW1sX2Zsb2F0X3Jlc3Qgd2lkdGggcHJlY2lzaW9uIGliXG4gIClcbiAgfCAnMScgLi4gJzknIGFzIGMgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICAgIHNjYW5fY2FtbF9mbG9hdF9yZXN0IHdpZHRoIHByZWNpc2lvbiBpYlxuKCogU3BlY2lhbCBjYXNlIG9mIG5hbiBhbmQgaW5maW5pdHk6XG4gIHwgJ2knIC0+XG4gIHwgJ24nIC0+XG4qKVxuICB8IF8gLT4gYmFkX2Zsb2F0ICgpXG5cblxuKCogU2NhbiBhIHJlZ3VsYXIgc3RyaW5nOlxuICAgc3RvcHMgd2hlbiBlbmNvdW50ZXJpbmcgYSBzcGFjZSwgaWYgbm8gc2Nhbm5pbmcgaW5kaWNhdGlvbiBoYXMgYmVlbiBnaXZlbjtcbiAgIG90aGVyd2lzZSwgc3RvcHMgd2hlbiBlbmNvdW50ZXJpbmcgdGhlIGNoYXJhY3RlcnMgaW4gdGhlIHNjYW5uaW5nXG4gICBpbmRpY2F0aW9uIFtzdHBdLlxuICAgSXQgYWxzbyBzdG9wcyBhdCBlbmQgb2YgZmlsZSBvciB3aGVuIHRoZSBtYXhpbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIGhhc1xuICAgYmVlbiByZWFkLiAqKVxubGV0IHNjYW5fc3RyaW5nIHN0cCB3aWR0aCBpYiA9XG4gIGxldCByZWMgbG9vcCB3aWR0aCA9XG4gICAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICAgIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgbWF0Y2ggc3RwIHdpdGhcbiAgICAgIHwgU29tZSBjJyB3aGVuIGMgPSBjJyAtPiBTY2FubmluZy5za2lwX2NoYXIgd2lkdGggaWJcbiAgICAgIHwgU29tZSBfIC0+IGxvb3AgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYylcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICBtYXRjaCBjIHdpdGhcbiAgICAgICAgfCAnICcgfCAnXFx0JyB8ICdcXG4nIHwgJ1xccicgLT4gd2lkdGhcbiAgICAgICAgfCBfIC0+IGxvb3AgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaW5cbiAgbG9vcCB3aWR0aFxuXG5cbigqIFNjYW4gYSBjaGFyOiBwZWVrIHN0cmljdGx5IG9uZSBjaGFyYWN0ZXIgaW4gdGhlIGlucHV0LCB3aGF0c29ldmVyLiAqKVxubGV0IHNjYW5fY2hhciB3aWR0aCBpYiA9XG4gICgqIFRoZSBjYXNlIHdpZHRoID0gMCBjb3VsZCBub3QgaGFwcGVuIGhlcmUsIHNpbmNlIGl0IGlzIHRlc3RlZCBiZWZvcmVcbiAgICAgY2FsbGluZyBzY2FuX2NoYXIsIGluIHRoZSBtYWluIHNjYW5uaW5nIGZ1bmN0aW9uLlxuICAgIGlmIHdpZHRoID0gMCB0aGVuIGJhZF90b2tlbl9sZW5ndGggXCJhIGNoYXJhY3RlclwiIGVsc2UgKilcbiAgU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiAoU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIpXG5cblxubGV0IGNoYXJfZm9yX2JhY2tzbGFzaCA9IGZ1bmN0aW9uXG4gIHwgJ24nIC0+ICdcXDAxMCdcbiAgfCAncicgLT4gJ1xcMDEzJ1xuICB8ICdiJyAtPiAnXFwwMDgnXG4gIHwgJ3QnIC0+ICdcXDAwOSdcbiAgfCBjIC0+IGNcblxuXG4oKiBUaGUgaW50ZWdlciB2YWx1ZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBmYWNpYWwgdmFsdWUgb2YgYSB2YWxpZFxuICAgZGVjaW1hbCBkaWdpdCBjaGFyYWN0ZXIuICopXG5sZXQgZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMgPSBpbnRfb2ZfY2hhciBjIC0gaW50X29mX2NoYXIgJzAnXG5cbmxldCBjaGFyX2Zvcl9kZWNpbWFsX2NvZGUgYzAgYzEgYzIgPVxuICBsZXQgYyA9XG4gICAgMTAwICogZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMwICtcbiAgICAgMTAgKiBkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYzEgK1xuICAgICAgICAgIGRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMiBpblxuICBpZiBjIDwgMCB8fCBjID4gMjU1IHRoZW5cbiAgICBiYWRfaW5wdXRcbiAgICAgIChQcmludGYuc3ByaW50ZlxuICAgICAgICAgXCJiYWQgY2hhcmFjdGVyIGRlY2ltYWwgZW5jb2RpbmcgXFxcXCVjJWMlY1wiIGMwIGMxIGMyKSBlbHNlXG4gIGNoYXJfb2ZfaW50IGNcblxuXG4oKiBUaGUgaW50ZWdlciB2YWx1ZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBmYWNpYWwgdmFsdWUgb2YgYSB2YWxpZFxuICAgaGV4YWRlY2ltYWwgZGlnaXQgY2hhcmFjdGVyLiAqKVxubGV0IGhleGFkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYyA9XG4gIGxldCBkID0gaW50X29mX2NoYXIgYyBpblxuICAoKiBDb3VsZCBhbHNvIGJlOlxuICAgIGlmIGQgPD0gaW50X29mX2NoYXIgJzknIHRoZW4gZCAtIGludF9vZl9jaGFyICcwJyBlbHNlXG4gICAgaWYgZCA8PSBpbnRfb2ZfY2hhciAnRicgdGhlbiAxMCArIGQgLSBpbnRfb2ZfY2hhciAnQScgZWxzZVxuICAgIGlmIGQgPD0gaW50X29mX2NoYXIgJ2YnIHRoZW4gMTAgKyBkIC0gaW50X29mX2NoYXIgJ2EnIGVsc2UgYXNzZXJ0IGZhbHNlXG4gICopXG4gIGlmIGQgPj0gaW50X29mX2NoYXIgJ2EnIHRoZW5cbiAgICBkIC0gODcgKCogMTAgKyBpbnRfb2ZfY2hhciBjIC0gaW50X29mX2NoYXIgJ2EnICopIGVsc2VcbiAgaWYgZCA+PSBpbnRfb2ZfY2hhciAnQScgdGhlblxuICAgIGQgLSA1NSAgKCogMTAgKyBpbnRfb2ZfY2hhciBjIC0gaW50X29mX2NoYXIgJ0EnICopIGVsc2VcbiAgICBkIC0gaW50X29mX2NoYXIgJzAnXG5cblxubGV0IGNoYXJfZm9yX2hleGFkZWNpbWFsX2NvZGUgYzEgYzIgPVxuICBsZXQgYyA9XG4gICAgMTYgKiBoZXhhZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMxICtcbiAgICAgICAgIGhleGFkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYzIgaW5cbiAgaWYgYyA8IDAgfHwgYyA+IDI1NSB0aGVuXG4gICAgYmFkX2lucHV0XG4gICAgICAoUHJpbnRmLnNwcmludGYgXCJiYWQgY2hhcmFjdGVyIGhleGFkZWNpbWFsIGVuY29kaW5nIFxcXFwlYyVjXCIgYzEgYzIpIGVsc2VcbiAgY2hhcl9vZl9pbnQgY1xuXG5cbigqIENhbGxlZCBpbiBwYXJ0aWN1bGFyIHdoZW4gZW5jb3VudGVyaW5nICdcXFxcJyBhcyBzdGFydGVyIG9mIGEgY2hhci5cbiAgIFN0b3BzIGJlZm9yZSB0aGUgY29ycmVzcG9uZGluZyAnXFwnJy4gKilcbmxldCBjaGVja19uZXh0X2NoYXIgbWVzc2FnZSB3aWR0aCBpYiA9XG4gIGlmIHdpZHRoID0gMCB0aGVuIGJhZF90b2tlbl9sZW5ndGggbWVzc2FnZSBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIGJhZF9lbmRfb2ZfaW5wdXQgbWVzc2FnZSBlbHNlXG4gIGNcblxuXG5sZXQgY2hlY2tfbmV4dF9jaGFyX2Zvcl9jaGFyID0gY2hlY2tfbmV4dF9jaGFyIFwiYSBDaGFyXCJcbmxldCBjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyA9IGNoZWNrX25leHRfY2hhciBcImEgU3RyaW5nXCJcblxubGV0IHNjYW5fYmFja3NsYXNoX2NoYXIgd2lkdGggaWIgPVxuICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX2NoYXIgd2lkdGggaWIgd2l0aFxuICB8ICdcXFxcJyB8ICdcXCcnIHwgJ1xcXCInIHwgJ24nIHwgJ3QnIHwgJ2InIHwgJ3InIGFzIGMgLT5cbiAgICBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIChjaGFyX2Zvcl9iYWNrc2xhc2ggYylcbiAgfCAnMCcgLi4gJzknIGFzIGMgLT5cbiAgICBsZXQgZ2V0X2RpZ2l0ICgpID1cbiAgICAgIGxldCBjID0gU2Nhbm5pbmcubmV4dF9jaGFyIGliIGluXG4gICAgICBtYXRjaCBjIHdpdGhcbiAgICAgIHwgJzAnIC4uICc5JyBhcyBjIC0+IGNcbiAgICAgIHwgYyAtPiBiYWRfaW5wdXRfZXNjYXBlIGMgaW5cbiAgICBsZXQgYzAgPSBjIGluXG4gICAgbGV0IGMxID0gZ2V0X2RpZ2l0ICgpIGluXG4gICAgbGV0IGMyID0gZ2V0X2RpZ2l0ICgpIGluXG4gICAgU2Nhbm5pbmcuc3RvcmVfY2hhciAod2lkdGggLSAyKSBpYiAoY2hhcl9mb3JfZGVjaW1hbF9jb2RlIGMwIGMxIGMyKVxuICB8ICd4JyAtPlxuICAgIGxldCBnZXRfZGlnaXQgKCkgPVxuICAgICAgbGV0IGMgPSBTY2FubmluZy5uZXh0X2NoYXIgaWIgaW5cbiAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgfCAnMCcgLi4gJzknIHwgJ0EnIC4uICdGJyB8ICdhJyAuLiAnZicgYXMgYyAtPiBjXG4gICAgICB8IGMgLT4gYmFkX2lucHV0X2VzY2FwZSBjIGluXG4gICAgbGV0IGMxID0gZ2V0X2RpZ2l0ICgpIGluXG4gICAgbGV0IGMyID0gZ2V0X2RpZ2l0ICgpIGluXG4gICAgU2Nhbm5pbmcuc3RvcmVfY2hhciAod2lkdGggLSAyKSBpYiAoY2hhcl9mb3JfaGV4YWRlY2ltYWxfY29kZSBjMSBjMilcbiAgfCBjIC0+XG4gICAgYmFkX2lucHV0X2VzY2FwZSBjXG5cblxuKCogU2NhbiBhIGNoYXJhY3RlciAoYW4gT0NhbWwgdG9rZW4pLiAqKVxubGV0IHNjYW5fY2FtbF9jaGFyIHdpZHRoIGliID1cblxuICBsZXQgcmVjIGZpbmRfc3RhcnQgd2lkdGggPVxuICAgIG1hdGNoIFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIHdpdGhcbiAgICB8ICdcXCcnIC0+IGZpbmRfY2hhciAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBjIC0+IGNoYXJhY3Rlcl9taXNtYXRjaCAnXFwnJyBjXG5cbiAgYW5kIGZpbmRfY2hhciB3aWR0aCA9XG4gICAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9jaGFyIHdpZHRoIGliIHdpdGhcbiAgICB8ICdcXFxcJyAtPlxuICAgICAgZmluZF9zdG9wIChzY2FuX2JhY2tzbGFzaF9jaGFyIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYikgaWIpXG4gICAgfCBjIC0+XG4gICAgICBmaW5kX3N0b3AgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYylcblxuICBhbmQgZmluZF9zdG9wIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX2NoYXIgd2lkdGggaWIgd2l0aFxuICAgIHwgJ1xcJycgLT4gU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWJcbiAgICB8IGMgLT4gY2hhcmFjdGVyX21pc21hdGNoICdcXCcnIGMgaW5cblxuICBmaW5kX3N0YXJ0IHdpZHRoXG5cblxuKCogU2NhbiBhIGRlbGltaXRlZCBzdHJpbmcgKGFuIE9DYW1sIHRva2VuKS4gKilcbmxldCBzY2FuX2NhbWxfc3RyaW5nIHdpZHRoIGliID1cblxuICBsZXQgcmVjIGZpbmRfc3RhcnQgd2lkdGggPVxuICAgIG1hdGNoIFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIHdpdGhcbiAgICB8ICdcXFwiJyAtPiBmaW5kX3N0b3AgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgYyAtPiBjaGFyYWN0ZXJfbWlzbWF0Y2ggJ1xcXCInIGNcblxuICBhbmQgZmluZF9zdG9wIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFxcIicgLT4gU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWJcbiAgICB8ICdcXFxcJyAtPiBzY2FuX2JhY2tzbGFzaCAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBjIC0+IGZpbmRfc3RvcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKVxuXG4gIGFuZCBzY2FuX2JhY2tzbGFzaCB3aWR0aCA9XG4gICAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmcgd2lkdGggaWIgd2l0aFxuICAgIHwgJ1xccicgLT4gc2tpcF9uZXdsaW5lIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8ICdcXG4nIC0+IHNraXBfc3BhY2VzIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IF8gLT4gZmluZF9zdG9wIChzY2FuX2JhY2tzbGFzaF9jaGFyIHdpZHRoIGliKVxuXG4gIGFuZCBza2lwX25ld2xpbmUgd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nIHdpZHRoIGliIHdpdGhcbiAgICB8ICdcXG4nIC0+IHNraXBfc3BhY2VzIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IF8gLT4gZmluZF9zdG9wIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliICdcXHInKVxuXG4gIGFuZCBza2lwX3NwYWNlcyB3aWR0aCA9XG4gICAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmcgd2lkdGggaWIgd2l0aFxuICAgIHwgJyAnIC0+IHNraXBfc3BhY2VzIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IF8gLT4gZmluZF9zdG9wIHdpZHRoIGluXG5cbiAgZmluZF9zdGFydCB3aWR0aFxuXG5cbigqIFNjYW4gYSBib29sZWFuIChhbiBPQ2FtbCB0b2tlbikuICopXG5sZXQgc2Nhbl9ib29sIGliID1cbiAgbGV0IGMgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBsZXQgbSA9XG4gICAgbWF0Y2ggYyB3aXRoXG4gICAgfCAndCcgLT4gNFxuICAgIHwgJ2YnIC0+IDVcbiAgICB8IGMgLT5cbiAgICAgIGJhZF9pbnB1dFxuICAgICAgICAoUHJpbnRmLnNwcmludGYgXCJ0aGUgY2hhcmFjdGVyICVDIGNhbm5vdCBzdGFydCBhIGJvb2xlYW5cIiBjKSBpblxuICBzY2FuX3N0cmluZyBOb25lIG0gaWJcblxuXG4oKiBTY2FuIGEgc3RyaW5nIGNvbnRhaW5pbmcgZWxlbWVudHMgaW4gY2hhcl9zZXQgYW5kIHRlcm1pbmF0ZWQgYnkgc2Nhbl9pbmRpY1xuICAgaWYgcHJvdmlkZWQuICopXG5sZXQgc2Nhbl9jaGFyc19pbl9jaGFyX3NldCBjaGFyX3NldCBzY2FuX2luZGljIHdpZHRoIGliID1cbiAgbGV0IHJlYyBzY2FuX2NoYXJzIGkgc3RwID1cbiAgICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgIGlmIGkgPiAwICYmIG5vdCAoU2Nhbm5pbmcuZW9mIGliKSAmJlxuICAgICAgIGlzX2luX2NoYXJfc2V0IGNoYXJfc2V0IGMgJiZcbiAgICAgICBpbnRfb2ZfY2hhciBjIDw+IHN0cCB0aGVuXG4gICAgICBsZXQgXyA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgbWF4X2ludCBpYiBjIGluXG4gICAgICBzY2FuX2NoYXJzIChpIC0gMSkgc3RwIGluXG4gIG1hdGNoIHNjYW5faW5kaWMgd2l0aFxuICB8IE5vbmUgLT4gc2Nhbl9jaGFycyB3aWR0aCAoLTEpO1xuICB8IFNvbWUgYyAtPlxuICAgIHNjYW5fY2hhcnMgd2lkdGggKGludF9vZl9jaGFyIGMpO1xuICAgIGlmIG5vdCAoU2Nhbm5pbmcuZW9mIGliKSB0aGVuXG4gICAgICBsZXQgY2kgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICAgIGlmIGMgPSBjaVxuICAgICAgdGhlbiBTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYlxuICAgICAgZWxzZSBjaGFyYWN0ZXJfbWlzbWF0Y2ggYyBjaVxuXG5cbigqIFRoZSBnbG9iYWwgZXJyb3IgcmVwb3J0IGZ1bmN0aW9uIGZvciBbU2NhbmZdLiAqKVxubGV0IHNjYW5mX2JhZF9pbnB1dCBpYiA9IGZ1bmN0aW9uXG4gIHwgU2Nhbl9mYWlsdXJlIHMgfCBGYWlsdXJlIHMgLT5cbiAgICBsZXQgaSA9IFNjYW5uaW5nLmNoYXJfY291bnQgaWIgaW5cbiAgICBiYWRfaW5wdXQgKFByaW50Zi5zcHJpbnRmIFwic2NhbmY6IGJhZCBpbnB1dCBhdCBjaGFyIG51bWJlciAlaTogJXNcIiBpIHMpXG4gIHwgeCAtPiByYWlzZSB4XG5cblxuKCogR2V0IHRoZSBjb250ZW50IG9mIGEgY291bnRlciBmcm9tIGFuIGlucHV0IGJ1ZmZlci4gKilcbmxldCBnZXRfY291bnRlciBpYiBjb3VudGVyID1cbiAgbWF0Y2ggY291bnRlciB3aXRoXG4gIHwgTGluZV9jb3VudGVyIC0+IFNjYW5uaW5nLmxpbmVfY291bnQgaWJcbiAgfCBDaGFyX2NvdW50ZXIgLT4gU2Nhbm5pbmcuY2hhcl9jb3VudCBpYlxuICB8IFRva2VuX2NvdW50ZXIgLT4gU2Nhbm5pbmcudG9rZW5fY291bnQgaWJcblxuXG4oKiBDb21wdXRlIHRoZSB3aWR0aCBvZiBhIHBhZGRpbmcgb3B0aW9uIChzZWUgXCIlNDJ7XCIgYW5kIFwiJTEyMyhcIikuICopXG5sZXQgd2lkdGhfb2ZfcGFkX29wdCBwYWRfb3B0ID0gbWF0Y2ggcGFkX29wdCB3aXRoXG4gIHwgTm9uZSAtPiBtYXhfaW50XG4gIHwgU29tZSB3aWR0aCAtPiB3aWR0aFxuXG5cbmxldCBzdG9wcGVyX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZyA9XG4gIGlmIGZtdGluZyA9IEVzY2FwZWRfcGVyY2VudCB0aGVuICclJywgXCJcIiBlbHNlXG4gICAgbGV0IHN0ciA9IHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmcgaW5cbiAgICBsZXQgc3RwID0gc3RyLlsxXSBpblxuICAgIGxldCBzdWJfc3RyID0gU3RyaW5nLnN1YiBzdHIgMiAoU3RyaW5nLmxlbmd0aCBzdHIgLSAyKSBpblxuICAgIHN0cCwgc3ViX3N0clxuXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBSZWFkZXIgbWFuYWdlbWVudCAqKVxuXG4oKiBBIGNhbGwgdG8gdGFrZV9mb3JtYXRfcmVhZGVycyBvbiBhIGZvcm1hdCBpcyBldmFsdWF0ZWQgaW50byBmdW5jdGlvbnNcbiAgIHRha2luZyByZWFkZXJzIGFzIGFyZ3VtZW50cyBhbmQgYWdncmVnYXRlIHRoZW0gaW50byBhbiBoZXRlcm9nZW5lb3VzIGxpc3QgKilcbigqIFdoZW4gYWxsIHJlYWRlcnMgYXJlIHRha2VuLCBmaW5hbGx5IHBhc3MgdGhlIGxpc3Qgb2YgdGhlIHJlYWRlcnMgdG8gdGhlXG4gICBjb250aW51YXRpb24gay4gKilcbmxldCByZWMgdGFrZV9mb3JtYXRfcmVhZGVycyA6IHR5cGUgYSBjIGQgZSBmIC5cbiAgICAoKGQsIGUpIGhldGVyX2xpc3QgLT4gZSkgLT4gKGEsIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgIGQgPVxuZnVuIGsgZm10IC0+IG1hdGNoIGZtdCB3aXRoXG4gIHwgUmVhZGVyIGZtdF9yZXN0IC0+XG4gICAgZnVuIHJlYWRlciAtPlxuICAgICAgbGV0IG5ld19rIHJlYWRlcnNfcmVzdCA9IGsgKENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSkgaW5cbiAgICAgIHRha2VfZm9ybWF0X3JlYWRlcnMgbmV3X2sgZm10X3Jlc3RcbiAgfCBDaGFyIHJlc3QgICAgICAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IENhbWxfY2hhciByZXN0ICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgU3RyaW5nIChfLCByZXN0KSAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBDYW1sX3N0cmluZyAoXywgcmVzdCkgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEludCAoXywgXywgXywgcmVzdCkgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgSW50MzIgKF8sIF8sIF8sIHJlc3QpICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBOYXRpdmVpbnQgKF8sIF8sIF8sIHJlc3QpICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEludDY0IChfLCBfLCBfLCByZXN0KSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgRmxvYXQgKF8sIF8sIF8sIHJlc3QpICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBCb29sIChfLCByZXN0KSAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEFscGhhIHJlc3QgICAgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgVGhldGEgcmVzdCAgICAgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBGbHVzaCByZXN0ICAgICAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IFN0cmluZ19saXRlcmFsIChfLCByZXN0KSAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQ2hhcl9saXRlcmFsIChfLCByZXN0KSAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBDdXN0b20gKF8sIF8sIHJlc3QpICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuXG4gIHwgU2Nhbl9jaGFyX3NldCAoXywgXywgcmVzdCkgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBTY2FuX2dldF9jb3VudGVyIChfLCByZXN0KSAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG5cbiAgfCBGb3JtYXR0aW5nX2xpdCAoXywgcmVzdCkgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX3RhZyAoRm9ybWF0IChmbXQsIF8pKSwgcmVzdCkgLT5cbiAgICAgIHRha2VfZm9ybWF0X3JlYWRlcnMgayAoY29uY2F0X2ZtdCBmbXQgcmVzdClcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10LCBfKSksIHJlc3QpIC0+XG4gICAgICB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgKGNvbmNhdF9mbXQgZm10IHJlc3QpXG5cbiAgfCBGb3JtYXRfYXJnIChfLCBfLCByZXN0KSAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEZvcm1hdF9zdWJzdCAoXywgZm10dHksIHJlc3QpICAgIC0+XG4gICAgIHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayAoZXJhc2VfcmVsIChzeW1tIGZtdHR5KSkgcmVzdFxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgICAgICAgIC0+IHRha2VfaWdub3JlZF9mb3JtYXRfcmVhZGVycyBrIGlnbiByZXN0XG5cbiAgfCBFbmRfb2ZfZm9ybWF0ICAgICAgICAgICAgICAgICAgICAtPiBrIE5pbFxuXG4oKiBUYWtlIHJlYWRlcnMgYXNzb2NpYXRlZCB0byBhbiBmbXR0eSBjb21pbmcgZnJvbSBhIEZvcm1hdF9zdWJzdCBcIiUoLi4uJSlcIi4gKilcbmFuZCB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIDogdHlwZSB4IHkgYSBjIGQgZSBmIC5cbiAgICAoKGQsIGUpIGhldGVyX2xpc3QgLT4gZSkgLT4gKGEsIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIGQsIHgsIHkpIGZtdHR5IC0+XG4gICAgICAoeSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgeCwgZSwgZikgZm10IC0+IGQgPVxuZnVuIGsgZm10dHkgZm10IC0+IG1hdGNoIGZtdHR5IHdpdGhcbiAgfCBSZWFkZXJfdHkgZm10X3Jlc3QgLT5cbiAgICBmdW4gcmVhZGVyIC0+XG4gICAgICBsZXQgbmV3X2sgcmVhZGVyc19yZXN0ID0gayAoQ29ucyAocmVhZGVyLCByZWFkZXJzX3Jlc3QpKSBpblxuICAgICAgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBuZXdfayBmbXRfcmVzdCBmbXRcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSBmbXRfcmVzdCAtPlxuICAgIGZ1biByZWFkZXIgLT5cbiAgICAgIGxldCBuZXdfayByZWFkZXJzX3Jlc3QgPSBrIChDb25zIChyZWFkZXIsIHJlYWRlcnNfcmVzdCkpIGluXG4gICAgICB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIG5ld19rIGZtdF9yZXN0IGZtdFxuICB8IENoYXJfdHkgcmVzdCAgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBTdHJpbmdfdHkgcmVzdCAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgSW50X3R5IHJlc3QgICAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEludDMyX3R5IHJlc3QgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgSW50NjRfdHkgcmVzdCAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEZsb2F0X3R5IHJlc3QgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBCb29sX3R5IHJlc3QgICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgQWxwaGFfdHkgcmVzdCAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IFRoZXRhX3R5IHJlc3QgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBBbnlfdHkgcmVzdCAgICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgRm9ybWF0X2FyZ190eSAoXywgcmVzdCkgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEVuZF9vZl9mbXR0eSAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgcmVzdCkgLT5cbiAgICBsZXQgdHkgPSB0cmFucyAoc3ltbSB0eTEpIHR5MiBpblxuICAgIHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayAoY29uY2F0X2ZtdHR5IHR5IHJlc3QpIGZtdFxuXG4oKiBUYWtlIHJlYWRlcnMgYXNzb2NpYXRlZCB0byBhbiBpZ25vcmVkIHBhcmFtZXRlci4gKilcbmFuZCB0YWtlX2lnbm9yZWRfZm9ybWF0X3JlYWRlcnMgOiB0eXBlIHggeSBhIGMgZCBlIGYgLlxuICAgICgoZCwgZSkgaGV0ZXJfbGlzdCAtPiBlKSAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgeCwgeSkgaWdub3JlZCAtPlxuICAgICAgKHksIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIHgsIGUsIGYpIGZtdCAtPiBkID1cbmZ1biBrIGlnbiBmbXQgLT4gbWF0Y2ggaWduIHdpdGhcbiAgfCBJZ25vcmVkX3JlYWRlciAtPlxuICAgIGZ1biByZWFkZXIgLT5cbiAgICAgIGxldCBuZXdfayByZWFkZXJzX3Jlc3QgPSBrIChDb25zIChyZWFkZXIsIHJlYWRlcnNfcmVzdCkpIGluXG4gICAgICB0YWtlX2Zvcm1hdF9yZWFkZXJzIG5ld19rIGZtdFxuICB8IElnbm9yZWRfY2hhciAgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfY2FtbF9jaGFyICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfc3RyaW5nIF8gICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgXyAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfaW50IChfLCBfKSAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfaW50MzIgKF8sIF8pICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfbmF0aXZlaW50IChfLCBfKSAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfaW50NjQgKF8sIF8pICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfZmxvYXQgKF8sIF8pICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfYm9vbCBfICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfZm9ybWF0X2FyZyBfICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IChfLCBmbXR0eSkgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIGZtdHR5IGZtdFxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCBfICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBfICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBHZW5lcmljIHNjYW5uaW5nICopXG5cbigqIE1ha2UgYSBnZW5lcmljIHNjYW5uaW5nIGZ1bmN0aW9uLiAqKVxuKCogU2NhbiBhIHN0cmVhbSBhY2NvcmRpbmcgdG8gYSBmb3JtYXQgYW5kIHJlYWRlcnMgb2J0YWluZWQgYnlcbiAgIHRha2VfZm9ybWF0X3JlYWRlcnMsIGFuZCBhZ2dyZWdhdGUgc2Nhbm5lZCB2YWx1ZXMgaW50byBhblxuICAgaGV0ZXJvZ2VuZW91cyBsaXN0LiAqKVxuKCogUmV0dXJuIHRoZSBoZXRlcm9nZW5lb3VzIGxpc3Qgb2Ygc2Nhbm5lZCB2YWx1ZXMuICopXG5sZXQgcmVjIG1ha2Vfc2NhbmYgOiB0eXBlIGEgYyBkIGUgZi5cbiAgICBTY2FubmluZy5pbl9jaGFubmVsIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAgIChkLCBlKSBoZXRlcl9saXN0IC0+IChhLCBmKSBoZXRlcl9saXN0ID1cbmZ1biBpYiBmbXQgcmVhZGVycyAtPiBtYXRjaCBmbXQgd2l0aFxuICB8IENoYXIgcmVzdCAtPlxuICAgIGxldCBfID0gc2Nhbl9jaGFyIDAgaWIgaW5cbiAgICBsZXQgYyA9IHRva2VuX2NoYXIgaWIgaW5cbiAgICBDb25zIChjLCBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVycylcbiAgfCBDYW1sX2NoYXIgcmVzdCAtPlxuICAgIGxldCBfID0gc2Nhbl9jYW1sX2NoYXIgMCBpYiBpblxuICAgIGxldCBjID0gdG9rZW5fY2hhciBpYiBpblxuICAgIENvbnMgKGMsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuXG4gIHwgU3RyaW5nIChwYWQsIEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCByZXN0KSkgLT5cbiAgICBsZXQgc3RwLCBzdHIgPSBzdG9wcGVyX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQgaW5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9zdHJpbmcgKFNvbWUgc3RwKSB3aWR0aCBpYiBpblxuICAgIGxldCBzdHJfcmVzdCA9IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgc3RyX3Jlc3QgcmVhZGVycyBwYWQgTm9fcHJlY2lzaW9uIHNjYW4gdG9rZW5fc3RyaW5nXG4gIHwgU3RyaW5nIChwYWQsIEZvcm1hdHRpbmdfZ2VuIChPcGVuX3RhZyAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpKSAtPlxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX3N0cmluZyAoU29tZSAneycpIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgKGNvbmNhdF9mbXQgZm10JyByZXN0KSByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhblxuICAgICAgICAgICAgICAgICAgIHRva2VuX3N0cmluZ1xuICB8IFN0cmluZyAocGFkLCBGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSkgLT5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9zdHJpbmcgKFNvbWUgJ1snKSB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIChjb25jYXRfZm10IGZtdCcgcmVzdCkgcmVhZGVycyBwYWQgTm9fcHJlY2lzaW9uIHNjYW5cbiAgICAgICAgICAgICAgICAgICB0b2tlbl9zdHJpbmdcbiAgfCBTdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9zdHJpbmcgTm9uZSB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgTm9fcHJlY2lzaW9uIHNjYW4gdG9rZW5fc3RyaW5nXG5cbiAgfCBDYW1sX3N0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX2NhbWxfc3RyaW5nIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhbiB0b2tlbl9zdHJpbmdcbiAgfCBJbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IGMgPSBpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciAoY2hhcl9vZl9pY29udiBpY29udikgaW5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9pbnRfY29udmVyc2lvbiBjIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW4gKHRva2VuX2ludCBjKVxuICB8IEludDMyIChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCBjID0gaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpIGluXG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5faW50X2NvbnZlcnNpb24gYyB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuICh0b2tlbl9pbnQzMiBjKVxuICB8IE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgYyA9IGludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyIChjaGFyX29mX2ljb252IGljb252KSBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX2ludF9jb252ZXJzaW9uIGMgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2NhbiAodG9rZW5fbmF0aXZlaW50IGMpXG4gIHwgSW50NjQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IGMgPSBpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciAoY2hhcl9vZl9pY29udiBpY29udikgaW5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9pbnRfY29udmVyc2lvbiBjIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW4gKHRva2VuX2ludDY0IGMpXG4gIHwgRmxvYXQgKEZsb2F0X0YsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2Nhbl9jYW1sX2Zsb2F0IHRva2VuX2Zsb2F0XG4gIHwgRmxvYXQgKChGbG9hdF9mIHwgRmxvYXRfcGYgfCBGbG9hdF9zZiB8IEZsb2F0X2UgfCBGbG9hdF9wZSB8IEZsb2F0X3NlXG4gICAgICAgICAgICAgICB8IEZsb2F0X0UgfCBGbG9hdF9wRSB8IEZsb2F0X3NFIHwgRmxvYXRfZyB8IEZsb2F0X3BnIHwgRmxvYXRfc2dcbiAgICAgICAgICAgICAgIHwgRmxvYXRfRyB8IEZsb2F0X3BHIHwgRmxvYXRfc0cpLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW5fZmxvYXQgdG9rZW5fZmxvYXRcbiAgfCBGbG9hdCAoKEZsb2F0X2ggfCBGbG9hdF9waCB8IEZsb2F0X3NoIHwgRmxvYXRfSCB8IEZsb2F0X3BIIHwgRmxvYXRfc0gpLFxuICAgICAgICAgICBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW5faGV4X2Zsb2F0IHRva2VuX2Zsb2F0XG4gIHwgQm9vbCAocGFkLCByZXN0KSAtPlxuICAgIGxldCBzY2FuIF8gXyBpYiA9IHNjYW5fYm9vbCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgTm9fcHJlY2lzaW9uIHNjYW4gdG9rZW5fYm9vbFxuICB8IEFscGhhIF8gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJWFcXFwiXCJcbiAgfCBUaGV0YSBfIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiV0XFxcIlwiXG4gIHwgQ3VzdG9tIF8gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJT9cXFwiIChjdXN0b20gY29udmVydGVyKVwiXG4gIHwgUmVhZGVyIGZtdF9yZXN0IC0+XG4gICAgYmVnaW4gbWF0Y2ggcmVhZGVycyB3aXRoXG4gICAgfCBDb25zIChyZWFkZXIsIHJlYWRlcnNfcmVzdCkgLT5cbiAgICAgICAgbGV0IHggPSByZWFkZXIgaWIgaW5cbiAgICAgICAgQ29ucyAoeCwgbWFrZV9zY2FuZiBpYiBmbXRfcmVzdCByZWFkZXJzX3Jlc3QpXG4gICAgfCBOaWwgLT5cbiAgICAgICAgaW52YWxpZF9hcmcgXCJzY2FuZjogbWlzc2luZyByZWFkZXJcIlxuICAgIGVuZFxuICB8IEZsdXNoIHJlc3QgLT5cbiAgICBpZiBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVyc1xuICAgIGVsc2UgYmFkX2lucHV0IFwiZW5kIG9mIGlucHV0IG5vdCBmb3VuZFwiXG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSAtPlxuICAgIFN0cmluZy5pdGVyIChjaGVja19jaGFyIGliKSBzdHI7XG4gICAgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnNcbiAgfCBDaGFyX2xpdGVyYWwgKGNociwgcmVzdCkgLT5cbiAgICBjaGVja19jaGFyIGliIGNocjtcbiAgICBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVyc1xuXG4gIHwgRm9ybWF0X2FyZyAocGFkX29wdCwgZm10dHksIHJlc3QpIC0+XG4gICAgbGV0IF8gPSBzY2FuX2NhbWxfc3RyaW5nICh3aWR0aF9vZl9wYWRfb3B0IHBhZF9vcHQpIGliIGluXG4gICAgbGV0IHMgPSB0b2tlbl9zdHJpbmcgaWIgaW5cbiAgICBsZXQgZm10ID1cbiAgICAgIHRyeSBmb3JtYXRfb2Zfc3RyaW5nX2ZtdHR5IHMgZm10dHlcbiAgICAgIHdpdGggRmFpbHVyZSBtc2cgLT4gYmFkX2lucHV0IG1zZ1xuICAgIGluXG4gICAgQ29ucyAoZm10LCBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVycylcbiAgfCBGb3JtYXRfc3Vic3QgKHBhZF9vcHQsIGZtdHR5LCByZXN0KSAtPlxuICAgIGxldCBfID0gc2Nhbl9jYW1sX3N0cmluZyAod2lkdGhfb2ZfcGFkX29wdCBwYWRfb3B0KSBpYiBpblxuICAgIGxldCBzID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgbGV0IGZtdCwgZm10JyA9XG4gICAgICB0cnlcbiAgICAgICAgbGV0IEZtdF9FQkIgZm10ID0gZm10X2ViYl9vZl9zdHJpbmcgcyBpblxuICAgICAgICBsZXQgRm10X0VCQiBmbXQnID0gZm10X2ViYl9vZl9zdHJpbmcgcyBpblxuICAgICAgICAoKiBUT0RPOiBmaW5kIGEgd2F5IHRvIGF2b2lkIHJlcGFyc2luZyB0d2ljZSAqKVxuXG4gICAgICAgICgqIFRPRE86IHRoZXNlIHR5cGUtY2hlY2tzIGJlbG93ICpjYW4qIGZhaWwgYmVjYXVzZSBvZiB0eXBlXG4gICAgICAgICAgIGFtYmlndWl0eSBpbiBwcmVzZW5jZSBvZiBpZ25vcmVkLXJlYWRlcnM6IFwiJV9yJWRcIiBhbmQgXCIlZCVfclwiXG4gICAgICAgICAgIGFyZSB0eXBlZCBpbiB0aGUgc2FtZSB3YXkuXG5cbiAgICAgICAgICAgIyBTY2FuZi5zc2NhbmYgXCJcXFwiJV9yJWRcXFwiM1wiIFwiJSglZCVfciUpXCIgaWdub3JlXG4gICAgICAgICAgICAgKGZ1biBmbXQgbiAtPiBzdHJpbmdfb2ZfZm9ybWF0IGZtdCwgbilcbiAgICAgICAgICAgRXhjZXB0aW9uOiBDYW1saW50ZXJuYWxGb3JtYXQuVHlwZV9taXNtYXRjaC5cblxuICAgICAgICAgICBXZSBzaG91bGQgcHJvcGVybHkgY2F0Y2ggdGhpcyBleGNlcHRpb24uXG4gICAgICAgICopXG4gICAgICAgIHR5cGVfZm9ybWF0IGZtdCAoZXJhc2VfcmVsIGZtdHR5KSxcbiAgICAgICAgdHlwZV9mb3JtYXQgZm10JyAoZXJhc2VfcmVsIChzeW1tIGZtdHR5KSlcbiAgICAgIHdpdGggRmFpbHVyZSBtc2cgLT4gYmFkX2lucHV0IG1zZ1xuICAgIGluXG4gICAgQ29ucyAoRm9ybWF0IChmbXQsIHMpLFxuICAgICAgICAgIG1ha2Vfc2NhbmYgaWIgKGNvbmNhdF9mbXQgZm10JyByZXN0KSByZWFkZXJzKVxuXG4gIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpKSAtPlxuICAgIGxldCBzdHAsIHN0ciA9IHN0b3BwZXJfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIGxldCB3aWR0aCA9IHdpZHRoX29mX3BhZF9vcHQgd2lkdGhfb3B0IGluXG4gICAgc2Nhbl9jaGFyc19pbl9jaGFyX3NldCBjaGFyX3NldCAoU29tZSBzdHApIHdpZHRoIGliO1xuICAgIGxldCBzID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgbGV0IHN0cl9yZXN0ID0gU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgaW5cbiAgICBDb25zIChzLCBtYWtlX3NjYW5mIGliIHN0cl9yZXN0IHJlYWRlcnMpXG4gIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgcmVzdCkgLT5cbiAgICBsZXQgd2lkdGggPSB3aWR0aF9vZl9wYWRfb3B0IHdpZHRoX29wdCBpblxuICAgIHNjYW5fY2hhcnNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgTm9uZSB3aWR0aCBpYjtcbiAgICBsZXQgcyA9IHRva2VuX3N0cmluZyBpYiBpblxuICAgIENvbnMgKHMsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIHJlc3QpIC0+XG4gICAgbGV0IGNvdW50ID0gZ2V0X2NvdW50ZXIgaWIgY291bnRlciBpblxuICAgIENvbnMgKGNvdW50LCBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVycylcbiAgfCBTY2FuX25leHRfY2hhciByZXN0IC0+XG4gICAgbGV0IGMgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICAgIENvbnMgKGMsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuXG4gIHwgRm9ybWF0dGluZ19saXQgKGZvcm1hdHRpbmdfbGl0LCByZXN0KSAtPlxuICAgIFN0cmluZy5pdGVyIChjaGVja19jaGFyIGliKSAoc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZvcm1hdHRpbmdfbGl0KTtcbiAgICBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVyc1xuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX3RhZyAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgY2hlY2tfY2hhciBpYiAnQCc7IGNoZWNrX2NoYXIgaWIgJ3snO1xuICAgIG1ha2Vfc2NhbmYgaWIgKGNvbmNhdF9mbXQgZm10JyByZXN0KSByZWFkZXJzXG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICBjaGVja19jaGFyIGliICdAJzsgY2hlY2tfY2hhciBpYiAnWyc7XG4gICAgbWFrZV9zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnNcblxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICBsZXQgUGFyYW1fZm9ybWF0X0VCQiBmbXQnID0gcGFyYW1fZm9ybWF0X29mX2lnbm9yZWRfZm9ybWF0IGlnbiByZXN0IGluXG4gICAgYmVnaW4gbWF0Y2ggbWFrZV9zY2FuZiBpYiBmbXQnIHJlYWRlcnMgd2l0aFxuICAgIHwgQ29ucyAoXywgYXJnX3Jlc3QpIC0+IGFyZ19yZXN0XG4gICAgfCBOaWwgLT4gYXNzZXJ0IGZhbHNlXG4gICAgZW5kXG5cbiAgfCBFbmRfb2ZfZm9ybWF0IC0+XG4gICAgTmlsXG5cbigqIENhc2UgYW5hbHlzaXMgb24gcGFkZGluZyBhbmQgcHJlY2lzaW9uLiAqKVxuKCogUmVqZWN0IGZvcm1hdHMgY29udGFpbmluZyBcIiUqXCIgb3IgXCIlLipcIi4gKilcbigqIFBhc3MgcGFkZGluZyBhbmQgcHJlY2lzaW9uIHRvIHRoZSBnZW5lcmljIHNjYW5uZXIgYHNjYW4nLiAqKVxuYW5kIHBhZF9wcmVjX3NjYW5mIDogdHlwZSBhIGMgZCBlIGYgeCB5IHogdCAuXG4gICAgU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgICAoZCwgZSkgaGV0ZXJfbGlzdCAtPiAoeCwgeSkgcGFkZGluZyAtPiAoeSwgeiAtPiBhKSBwcmVjaXNpb24gLT5cbiAgICAgIChpbnQgLT4gaW50IC0+IFNjYW5uaW5nLmluX2NoYW5uZWwgLT4gdCkgLT5cbiAgICAgIChTY2FubmluZy5pbl9jaGFubmVsIC0+IHopIC0+XG4gICAgICAoeCwgZikgaGV0ZXJfbGlzdCA9XG5mdW4gaWIgZm10IHJlYWRlcnMgcGFkIHByZWMgc2NhbiB0b2tlbiAtPiBtYXRjaCBwYWQsIHByZWMgd2l0aFxuICB8IE5vX3BhZGRpbmcsIE5vX3ByZWNpc2lvbiAtPlxuICAgIGxldCBfID0gc2NhbiBtYXhfaW50IG1heF9pbnQgaWIgaW5cbiAgICBsZXQgeCA9IHRva2VuIGliIGluXG4gICAgQ29ucyAoeCwgbWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycylcbiAgfCBOb19wYWRkaW5nLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBsZXQgXyA9IHNjYW4gbWF4X2ludCBwIGliIGluXG4gICAgbGV0IHggPSB0b2tlbiBpYiBpblxuICAgIENvbnMgKHgsIG1ha2Vfc2NhbmYgaWIgZm10IHJlYWRlcnMpXG4gIHwgTGl0X3BhZGRpbmcgKChSaWdodCB8IFplcm9zKSwgdyksIE5vX3ByZWNpc2lvbiAtPlxuICAgIGxldCBfID0gc2NhbiB3IG1heF9pbnQgaWIgaW5cbiAgICBsZXQgeCA9IHRva2VuIGliIGluXG4gICAgQ29ucyAoeCwgbWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycylcbiAgfCBMaXRfcGFkZGluZyAoKFJpZ2h0IHwgWmVyb3MpLCB3KSwgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgbGV0IF8gPSBzY2FuIHcgcCBpYiBpblxuICAgIGxldCB4ID0gdG9rZW4gaWIgaW5cbiAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdCByZWFkZXJzKVxuICB8IExpdF9wYWRkaW5nIChMZWZ0LCBfKSwgXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlLVxcXCJcIlxuICB8IExpdF9wYWRkaW5nICgoUmlnaHQgfCBaZXJvcyksIF8pLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiUqXFxcIlwiXG4gIHwgQXJnX3BhZGRpbmcgXywgXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlKlxcXCJcIlxuICB8IE5vX3BhZGRpbmcsIEFyZ19wcmVjaXNpb24gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJSpcXFwiXCJcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICgqIERlZmluaW5nIFtzY2FuZl0gYW5kIHZhcmlvdXMgZmxhdm9ycyBvZiBbc2NhbmZdICopXG5cbnR5cGUgJ2Ega3NjYW5mX3Jlc3VsdCA9IEFyZ3Mgb2YgJ2EgfCBFeGMgb2YgZXhuXG5cbmxldCBrc2NhbmYgaWIgZWYgKEZvcm1hdCAoZm10LCBzdHIpKSA9XG4gIGxldCByZWMgYXBwbHkgOiB0eXBlIGEgYiAuIGEgLT4gKGEsIGIpIGhldGVyX2xpc3QgLT4gYiA9XG4gICAgZnVuIGYgYXJncyAtPiBtYXRjaCBhcmdzIHdpdGhcbiAgICB8IENvbnMgKHgsIHIpIC0+IGFwcGx5IChmIHgpIHJcbiAgICB8IE5pbCAtPiBmXG4gIGluXG4gIGxldCBrIHJlYWRlcnMgZiA9XG4gICAgU2Nhbm5pbmcucmVzZXRfdG9rZW4gaWI7XG4gICAgbWF0Y2ggdHJ5IEFyZ3MgKG1ha2Vfc2NhbmYgaWIgZm10IHJlYWRlcnMpIHdpdGhcbiAgICAgIHwgKFNjYW5fZmFpbHVyZSBfIHwgRmFpbHVyZSBfIHwgRW5kX29mX2ZpbGUpIGFzIGV4YyAtPiBFeGMgZXhjXG4gICAgICB8IEludmFsaWRfYXJndW1lbnQgbXNnIC0+XG4gICAgICAgIGludmFsaWRfYXJnIChtc2cgXiBcIiBpbiBmb3JtYXQgXFxcIlwiIF4gU3RyaW5nLmVzY2FwZWQgc3RyIF4gXCJcXFwiXCIpXG4gICAgd2l0aFxuICAgICAgfCBBcmdzIGFyZ3MgLT4gYXBwbHkgZiBhcmdzXG4gICAgICB8IEV4YyBleGMgLT4gZWYgaWIgZXhjXG4gIGluXG4gIHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcblxuKCoqKilcblxubGV0IGtic2NhbmYgPSBrc2NhbmZcbmxldCBic2NhbmYgaWIgZm10ID0ga2JzY2FuZiBpYiBzY2FuZl9iYWRfaW5wdXQgZm10XG5cbmxldCBrc3NjYW5mIHMgZWYgZm10ID0ga2JzY2FuZiAoU2Nhbm5pbmcuZnJvbV9zdHJpbmcgcykgZWYgZm10XG5sZXQgc3NjYW5mIHMgZm10ID0ga2JzY2FuZiAoU2Nhbm5pbmcuZnJvbV9zdHJpbmcgcykgc2NhbmZfYmFkX2lucHV0IGZtdFxuXG5sZXQgc2NhbmYgZm10ID0ga3NjYW5mIFNjYW5uaW5nLnN0ZGliIHNjYW5mX2JhZF9pbnB1dCBmbXRcblxuKCoqKilcblxuKCogU2Nhbm5pbmcgZm9ybWF0IHN0cmluZ3MuICopXG5sZXQgYnNjYW5mX2Zvcm1hdCA6XG4gIFNjYW5uaW5nLmluX2NoYW5uZWwgLT4gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT5cbiAgKCgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+ICdnKSAtPiAnZyA9XG4gIGZ1biBpYiBmb3JtYXQgZiAtPlxuICAgIGxldCBfID0gc2Nhbl9jYW1sX3N0cmluZyBtYXhfaW50IGliIGluXG4gICAgbGV0IHN0ciA9IHRva2VuX3N0cmluZyBpYiBpblxuICAgIGxldCBmbXQnID1cbiAgICAgIHRyeSBmb3JtYXRfb2Zfc3RyaW5nX2Zvcm1hdCBzdHIgZm9ybWF0XG4gICAgICB3aXRoIEZhaWx1cmUgbXNnIC0+IGJhZF9pbnB1dCBtc2cgaW5cbiAgICBmIGZtdCdcblxuXG5sZXQgc3NjYW5mX2Zvcm1hdCA6XG4gIHN0cmluZyAtPiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPlxuICAoKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT4gJ2cpIC0+ICdnID1cbiAgZnVuIHMgZm9ybWF0IGYgLT4gYnNjYW5mX2Zvcm1hdCAoU2Nhbm5pbmcuZnJvbV9zdHJpbmcgcykgZm9ybWF0IGZcblxuXG5sZXQgc3RyaW5nX3RvX1N0cmluZyBzID1cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIChsICsgMikgaW5cbiAgQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXCInO1xuICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICBsZXQgYyA9IHMuW2ldIGluXG4gICAgaWYgYyA9ICdcXFwiJyB0aGVuIEJ1ZmZlci5hZGRfY2hhciBiICdcXFxcJztcbiAgICBCdWZmZXIuYWRkX2NoYXIgYiBjO1xuICBkb25lO1xuICBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcIic7XG4gIEJ1ZmZlci5jb250ZW50cyBiXG5cblxubGV0IGZvcm1hdF9mcm9tX3N0cmluZyBzIGZtdCA9XG4gIHNzY2FuZl9mb3JtYXQgKHN0cmluZ190b19TdHJpbmcgcykgZm10IChmdW4geCAtPiB4KVxuXG5cbmxldCB1bmVzY2FwZWQgcyA9XG4gIHNzY2FuZiAoXCJcXFwiXCIgXiBzIF4gXCJcXFwiXCIpIFwiJVMlIVwiIChmdW4geCAtPiB4KVxuXG5cbigqIERlcHJlY2F0ZWQgKilcbmxldCBrZnNjYW5mIGljIGVmIGZtdCA9IGtic2NhbmYgKFNjYW5uaW5nLm1lbW9fZnJvbV9jaGFubmVsIGljKSBlZiBmbXRcbmxldCBmc2NhbmYgaWMgZm10ID0ga3NjYW5mIChTY2FubmluZy5tZW1vX2Zyb21fY2hhbm5lbCBpYykgc2NhbmZfYmFkX2lucHV0IGZtdFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBSZWdpc3RlcmluZyBPQ2FtbCB2YWx1ZXMgd2l0aCB0aGUgQyBydW50aW1lIGZvciBsYXRlciBjYWxsYmFja3MgKilcblxuZXh0ZXJuYWwgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgOiBzdHJpbmcgLT4gT2JqLnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWVcIlxuXG5sZXQgcmVnaXN0ZXIgbmFtZSB2ID1cbiAgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgbmFtZSAoT2JqLnJlcHIgdilcblxubGV0IHJlZ2lzdGVyX2V4Y2VwdGlvbiBuYW1lIChleG4gOiBleG4pID1cbiAgbGV0IGV4biA9IE9iai5yZXByIGV4biBpblxuICBsZXQgc2xvdCA9IGlmIE9iai50YWcgZXhuID0gT2JqLm9iamVjdF90YWcgdGhlbiBleG4gZWxzZSBPYmouZmllbGQgZXhuIDAgaW5cbiAgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgbmFtZSBzbG90XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICBKZXJvbWUgVm91aWxsb24sIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gT2JqXG5cbigqKioqIE9iamVjdCByZXByZXNlbnRhdGlvbiAqKioqKVxuXG5leHRlcm5hbCBzZXRfaWQ6ICdhIC0+ICdhID0gXCJjYW1sX3NldF9vb19pZFwiIFtAQG5vYWxsb2NdXG5cbigqKioqIE9iamVjdCBjb3B5ICoqKiopXG5cbmxldCBjb3B5IG8gPVxuICBsZXQgbyA9IChPYmoub2JqIChPYmouZHVwIChPYmoucmVwciBvKSkpIGluXG4gIHNldF9pZCBvXG5cbigqKioqIENvbXByZXNzaW9uIG9wdGlvbnMgKioqKilcbigqIFBhcmFtZXRlcnMgKilcbnR5cGUgcGFyYW1zID0ge1xuICAgIG11dGFibGUgY29tcGFjdF90YWJsZSA6IGJvb2w7XG4gICAgbXV0YWJsZSBjb3B5X3BhcmVudCA6IGJvb2w7XG4gICAgbXV0YWJsZSBjbGVhbl93aGVuX2NvcHlpbmcgOiBib29sO1xuICAgIG11dGFibGUgcmV0cnlfY291bnQgOiBpbnQ7XG4gICAgbXV0YWJsZSBidWNrZXRfc21hbGxfc2l6ZSA6IGludFxuICB9XG5cbmxldCBwYXJhbXMgPSB7XG4gIGNvbXBhY3RfdGFibGUgPSB0cnVlO1xuICBjb3B5X3BhcmVudCA9IHRydWU7XG4gIGNsZWFuX3doZW5fY29weWluZyA9IHRydWU7XG4gIHJldHJ5X2NvdW50ID0gMztcbiAgYnVja2V0X3NtYWxsX3NpemUgPSAxNlxufVxuXG4oKioqKiBQYXJhbWV0ZXJzICoqKiopXG5cbmxldCBpbml0aWFsX29iamVjdF9zaXplID0gMlxuXG4oKioqKiBJdGVtcyAqKioqKVxuXG50eXBlIGl0ZW0gPSBEdW1teUEgfCBEdW1teUIgfCBEdW1teUMgb2YgaW50XG5sZXQgXyA9IFtEdW1teUE7IER1bW15QjsgRHVtbXlDIDBdICgqIHRvIGF2b2lkIHdhcm5pbmdzICopXG5cbmxldCBkdW1teV9pdGVtID0gKG1hZ2ljICgpIDogaXRlbSlcblxuKCoqKiogVHlwZXMgKioqKilcblxudHlwZSB0YWdcbnR5cGUgbGFiZWwgPSBpbnRcbnR5cGUgY2xvc3VyZSA9IGl0ZW1cbnR5cGUgdCA9IER1bW15QSB8IER1bW15QiB8IER1bW15QyBvZiBpbnRcbmxldCBfID0gW0R1bW15QTsgRHVtbXlCOyBEdW1teUMgMF0gKCogdG8gYXZvaWQgd2FybmluZ3MgKilcblxudHlwZSBvYmogPSB0IGFycmF5XG5leHRlcm5hbCByZXQgOiAob2JqIC0+ICdhKSAtPiBjbG9zdXJlID0gXCIlaWRlbnRpdHlcIlxuXG4oKioqKiBMYWJlbHMgKioqKilcblxubGV0IHB1YmxpY19tZXRob2RfbGFiZWwgcyA6IHRhZyA9XG4gIGxldCBhY2N1ID0gcmVmIDAgaW5cbiAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggcyAtIDEgZG9cbiAgICBhY2N1IDo9IDIyMyAqICFhY2N1ICsgQ2hhci5jb2RlIHMuW2ldXG4gIGRvbmU7XG4gICgqIHJlZHVjZSB0byAzMSBiaXRzICopXG4gIGFjY3UgOj0gIWFjY3UgbGFuZCAoMSBsc2wgMzEgLSAxKTtcbiAgKCogbWFrZSBpdCBzaWduZWQgZm9yIDY0IGJpdHMgYXJjaGl0ZWN0dXJlcyAqKVxuICBsZXQgdGFnID0gaWYgIWFjY3UgPiAweDNGRkZGRkZGIHRoZW4gIWFjY3UgLSAoMSBsc2wgMzEpIGVsc2UgIWFjY3UgaW5cbiAgKCogUHJpbnRmLmVwcmludGYgXCIlcyA9ICVkXFxuXCIgcyB0YWc7IGZsdXNoIHN0ZGVycjsgKilcbiAgbWFnaWMgdGFnXG5cbigqKioqIFNwYXJzZSBhcnJheSAqKioqKVxuXG5tb2R1bGUgVmFycyA9XG4gIE1hcC5NYWtlKHN0cnVjdCB0eXBlIHQgPSBzdHJpbmcgbGV0IGNvbXBhcmUgKHg6dCkgeSA9IGNvbXBhcmUgeCB5IGVuZClcbnR5cGUgdmFycyA9IGludCBWYXJzLnRcblxubW9kdWxlIE1ldGhzID1cbiAgTWFwLk1ha2Uoc3RydWN0IHR5cGUgdCA9IHN0cmluZyBsZXQgY29tcGFyZSAoeDp0KSB5ID0gY29tcGFyZSB4IHkgZW5kKVxudHlwZSBtZXRocyA9IGxhYmVsIE1ldGhzLnRcbm1vZHVsZSBMYWJzID1cbiAgTWFwLk1ha2Uoc3RydWN0IHR5cGUgdCA9IGxhYmVsIGxldCBjb21wYXJlICh4OnQpIHkgPSBjb21wYXJlIHggeSBlbmQpXG50eXBlIGxhYnMgPSBib29sIExhYnMudFxuXG4oKiBUaGUgY29tcGlsZXIgYXNzdW1lcyB0aGF0IHRoZSBmaXJzdCBmaWVsZCBvZiB0aGlzIHN0cnVjdHVyZSBpcyBbc2l6ZV0uICopXG50eXBlIHRhYmxlID1cbiB7IG11dGFibGUgc2l6ZTogaW50O1xuICAgbXV0YWJsZSBtZXRob2RzOiBjbG9zdXJlIGFycmF5O1xuICAgbXV0YWJsZSBtZXRob2RzX2J5X25hbWU6IG1ldGhzO1xuICAgbXV0YWJsZSBtZXRob2RzX2J5X2xhYmVsOiBsYWJzO1xuICAgbXV0YWJsZSBwcmV2aW91c19zdGF0ZXM6XG4gICAgIChtZXRocyAqIGxhYnMgKiAobGFiZWwgKiBpdGVtKSBsaXN0ICogdmFycyAqXG4gICAgICBsYWJlbCBsaXN0ICogc3RyaW5nIGxpc3QpIGxpc3Q7XG4gICBtdXRhYmxlIGhpZGRlbl9tZXRoczogKGxhYmVsICogaXRlbSkgbGlzdDtcbiAgIG11dGFibGUgdmFyczogdmFycztcbiAgIG11dGFibGUgaW5pdGlhbGl6ZXJzOiAob2JqIC0+IHVuaXQpIGxpc3QgfVxuXG5sZXQgZHVtbXlfdGFibGUgPVxuICB7IG1ldGhvZHMgPSBbfCBkdW1teV9pdGVtIHxdO1xuICAgIG1ldGhvZHNfYnlfbmFtZSA9IE1ldGhzLmVtcHR5O1xuICAgIG1ldGhvZHNfYnlfbGFiZWwgPSBMYWJzLmVtcHR5O1xuICAgIHByZXZpb3VzX3N0YXRlcyA9IFtdO1xuICAgIGhpZGRlbl9tZXRocyA9IFtdO1xuICAgIHZhcnMgPSBWYXJzLmVtcHR5O1xuICAgIGluaXRpYWxpemVycyA9IFtdO1xuICAgIHNpemUgPSAwIH1cblxubGV0IHRhYmxlX2NvdW50ID0gcmVmIDBcblxuKCogZHVtbXlfbWV0IHNob3VsZCBiZSBhIHBvaW50ZXIsIHNvIHVzZSBhbiBhdG9tICopXG5sZXQgZHVtbXlfbWV0IDogaXRlbSA9IG9iaiAoT2JqLm5ld19ibG9jayAwIDApXG4oKiBpZiBkZWJ1Z2dpbmcgaXMgbmVlZGVkLCB0aGlzIGNvdWxkIGJlIGEgZ29vZCBpZGVhOiAqKVxuKCogbGV0IGR1bW15X21ldCAoKSA9IGZhaWx3aXRoIFwiVW5kZWZpbmVkIG1ldGhvZFwiICopXG5cbmxldCByZWMgZml0X3NpemUgbiA9XG4gIGlmIG4gPD0gMiB0aGVuIG4gZWxzZVxuICBmaXRfc2l6ZSAoKG4rMSkvMikgKiAyXG5cbmxldCBuZXdfdGFibGUgcHViX2xhYmVscyA9XG4gIGluY3IgdGFibGVfY291bnQ7XG4gIGxldCBsZW4gPSBBcnJheS5sZW5ndGggcHViX2xhYmVscyBpblxuICBsZXQgbWV0aG9kcyA9IEFycmF5Lm1ha2UgKGxlbioyKzIpIGR1bW15X21ldCBpblxuICBtZXRob2RzLigwKSA8LSBtYWdpYyBsZW47XG4gIG1ldGhvZHMuKDEpIDwtIG1hZ2ljIChmaXRfc2l6ZSBsZW4gKiBTeXMud29yZF9zaXplIC8gOCAtIDEpO1xuICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkbyBtZXRob2RzLihpKjIrMykgPC0gbWFnaWMgcHViX2xhYmVscy4oaSkgZG9uZTtcbiAgeyBtZXRob2RzID0gbWV0aG9kcztcbiAgICBtZXRob2RzX2J5X25hbWUgPSBNZXRocy5lbXB0eTtcbiAgICBtZXRob2RzX2J5X2xhYmVsID0gTGFicy5lbXB0eTtcbiAgICBwcmV2aW91c19zdGF0ZXMgPSBbXTtcbiAgICBoaWRkZW5fbWV0aHMgPSBbXTtcbiAgICB2YXJzID0gVmFycy5lbXB0eTtcbiAgICBpbml0aWFsaXplcnMgPSBbXTtcbiAgICBzaXplID0gaW5pdGlhbF9vYmplY3Rfc2l6ZSB9XG5cbmxldCByZXNpemUgYXJyYXkgbmV3X3NpemUgPVxuICBsZXQgb2xkX3NpemUgPSBBcnJheS5sZW5ndGggYXJyYXkubWV0aG9kcyBpblxuICBpZiBuZXdfc2l6ZSA+IG9sZF9zaXplIHRoZW4gYmVnaW5cbiAgICBsZXQgbmV3X2J1Y2sgPSBBcnJheS5tYWtlIG5ld19zaXplIGR1bW15X21ldCBpblxuICAgIEFycmF5LmJsaXQgYXJyYXkubWV0aG9kcyAwIG5ld19idWNrIDAgb2xkX3NpemU7XG4gICAgYXJyYXkubWV0aG9kcyA8LSBuZXdfYnVja1xuIGVuZFxuXG5sZXQgcHV0IGFycmF5IGxhYmVsIGVsZW1lbnQgPVxuICByZXNpemUgYXJyYXkgKGxhYmVsICsgMSk7XG4gIGFycmF5Lm1ldGhvZHMuKGxhYmVsKSA8LSBlbGVtZW50XG5cbigqKioqIENsYXNzZXMgKioqKilcblxubGV0IG1ldGhvZF9jb3VudCA9IHJlZiAwXG5sZXQgaW5zdF92YXJfY291bnQgPSByZWYgMFxuXG4oKiB0eXBlIHQgKilcbnR5cGUgbWV0aCA9IGl0ZW1cblxubGV0IG5ld19tZXRob2QgdGFibGUgPVxuICBsZXQgaW5kZXggPSBBcnJheS5sZW5ndGggdGFibGUubWV0aG9kcyBpblxuICByZXNpemUgdGFibGUgKGluZGV4ICsgMSk7XG4gIGluZGV4XG5cbmxldCBnZXRfbWV0aG9kX2xhYmVsIHRhYmxlIG5hbWUgPVxuICB0cnlcbiAgICBNZXRocy5maW5kIG5hbWUgdGFibGUubWV0aG9kc19ieV9uYW1lXG4gIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgbGV0IGxhYmVsID0gbmV3X21ldGhvZCB0YWJsZSBpblxuICAgIHRhYmxlLm1ldGhvZHNfYnlfbmFtZSA8LSBNZXRocy5hZGQgbmFtZSBsYWJlbCB0YWJsZS5tZXRob2RzX2J5X25hbWU7XG4gICAgdGFibGUubWV0aG9kc19ieV9sYWJlbCA8LSBMYWJzLmFkZCBsYWJlbCB0cnVlIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWw7XG4gICAgbGFiZWxcblxubGV0IGdldF9tZXRob2RfbGFiZWxzIHRhYmxlIG5hbWVzID1cbiAgQXJyYXkubWFwIChnZXRfbWV0aG9kX2xhYmVsIHRhYmxlKSBuYW1lc1xuXG5sZXQgc2V0X21ldGhvZCB0YWJsZSBsYWJlbCBlbGVtZW50ID1cbiAgaW5jciBtZXRob2RfY291bnQ7XG4gIGlmIExhYnMuZmluZCBsYWJlbCB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIHRoZW5cbiAgICBwdXQgdGFibGUgbGFiZWwgZWxlbWVudFxuICBlbHNlXG4gICAgdGFibGUuaGlkZGVuX21ldGhzIDwtIChsYWJlbCwgZWxlbWVudCkgOjogdGFibGUuaGlkZGVuX21ldGhzXG5cbmxldCBnZXRfbWV0aG9kIHRhYmxlIGxhYmVsID1cbiAgdHJ5IExpc3QuYXNzb2MgbGFiZWwgdGFibGUuaGlkZGVuX21ldGhzXG4gIHdpdGggTm90X2ZvdW5kIC0+IHRhYmxlLm1ldGhvZHMuKGxhYmVsKVxuXG5sZXQgdG9fbGlzdCBhcnIgPVxuICBpZiBhcnIgPT0gbWFnaWMgMCB0aGVuIFtdIGVsc2UgQXJyYXkudG9fbGlzdCBhcnJcblxubGV0IG5hcnJvdyB0YWJsZSB2YXJzIHZpcnRfbWV0aHMgY29uY3JfbWV0aHMgPVxuICBsZXQgdmFycyA9IHRvX2xpc3QgdmFyc1xuICBhbmQgdmlydF9tZXRocyA9IHRvX2xpc3QgdmlydF9tZXRoc1xuICBhbmQgY29uY3JfbWV0aHMgPSB0b19saXN0IGNvbmNyX21ldGhzIGluXG4gIGxldCB2aXJ0X21ldGhfbGFicyA9IExpc3QubWFwIChnZXRfbWV0aG9kX2xhYmVsIHRhYmxlKSB2aXJ0X21ldGhzIGluXG4gIGxldCBjb25jcl9tZXRoX2xhYnMgPSBMaXN0Lm1hcCAoZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSkgY29uY3JfbWV0aHMgaW5cbiAgdGFibGUucHJldmlvdXNfc3RhdGVzIDwtXG4gICAgICh0YWJsZS5tZXRob2RzX2J5X25hbWUsIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwsIHRhYmxlLmhpZGRlbl9tZXRocyxcbiAgICAgIHRhYmxlLnZhcnMsIHZpcnRfbWV0aF9sYWJzLCB2YXJzKVxuICAgICA6OiB0YWJsZS5wcmV2aW91c19zdGF0ZXM7XG4gIHRhYmxlLnZhcnMgPC1cbiAgICBWYXJzLmZvbGRcbiAgICAgIChmdW4gbGFiIGluZm8gdHZhcnMgLT5cbiAgICAgICAgaWYgTGlzdC5tZW0gbGFiIHZhcnMgdGhlbiBWYXJzLmFkZCBsYWIgaW5mbyB0dmFycyBlbHNlIHR2YXJzKVxuICAgICAgdGFibGUudmFycyBWYXJzLmVtcHR5O1xuICBsZXQgYnlfbmFtZSA9IHJlZiBNZXRocy5lbXB0eSBpblxuICBsZXQgYnlfbGFiZWwgPSByZWYgTGFicy5lbXB0eSBpblxuICBMaXN0Lml0ZXIyXG4gICAgKGZ1biBtZXQgbGFiZWwgLT5cbiAgICAgICBieV9uYW1lIDo9IE1ldGhzLmFkZCBtZXQgbGFiZWwgIWJ5X25hbWU7XG4gICAgICAgYnlfbGFiZWwgOj1cbiAgICAgICAgICBMYWJzLmFkZCBsYWJlbFxuICAgICAgICAgICAgKHRyeSBMYWJzLmZpbmQgbGFiZWwgdGFibGUubWV0aG9kc19ieV9sYWJlbCB3aXRoIE5vdF9mb3VuZCAtPiB0cnVlKVxuICAgICAgICAgICAgIWJ5X2xhYmVsKVxuICAgIGNvbmNyX21ldGhzIGNvbmNyX21ldGhfbGFicztcbiAgTGlzdC5pdGVyMlxuICAgIChmdW4gbWV0IGxhYmVsIC0+XG4gICAgICAgYnlfbmFtZSA6PSBNZXRocy5hZGQgbWV0IGxhYmVsICFieV9uYW1lO1xuICAgICAgIGJ5X2xhYmVsIDo9IExhYnMuYWRkIGxhYmVsIGZhbHNlICFieV9sYWJlbClcbiAgICB2aXJ0X21ldGhzIHZpcnRfbWV0aF9sYWJzO1xuICB0YWJsZS5tZXRob2RzX2J5X25hbWUgPC0gIWJ5X25hbWU7XG4gIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgPC0gIWJ5X2xhYmVsO1xuICB0YWJsZS5oaWRkZW5fbWV0aHMgPC1cbiAgICAgTGlzdC5mb2xkX3JpZ2h0XG4gICAgICAgKGZ1biAoKGxhYiwgXykgYXMgbWV0KSBobSAtPlxuICAgICAgICAgIGlmIExpc3QubWVtIGxhYiB2aXJ0X21ldGhfbGFicyB0aGVuIGhtIGVsc2UgbWV0OjpobSlcbiAgICAgICB0YWJsZS5oaWRkZW5fbWV0aHNcbiAgICAgICBbXVxuXG5sZXQgd2lkZW4gdGFibGUgPVxuICBsZXQgKGJ5X25hbWUsIGJ5X2xhYmVsLCBzYXZlZF9oaWRkZW5fbWV0aHMsIHNhdmVkX3ZhcnMsIHZpcnRfbWV0aHMsIHZhcnMpID1cbiAgICBMaXN0LmhkIHRhYmxlLnByZXZpb3VzX3N0YXRlc1xuICBpblxuICB0YWJsZS5wcmV2aW91c19zdGF0ZXMgPC0gTGlzdC50bCB0YWJsZS5wcmV2aW91c19zdGF0ZXM7XG4gIHRhYmxlLnZhcnMgPC1cbiAgICAgTGlzdC5mb2xkX2xlZnRcbiAgICAgICAoZnVuIHMgdiAtPiBWYXJzLmFkZCB2IChWYXJzLmZpbmQgdiB0YWJsZS52YXJzKSBzKVxuICAgICAgIHNhdmVkX3ZhcnMgdmFycztcbiAgdGFibGUubWV0aG9kc19ieV9uYW1lIDwtIGJ5X25hbWU7XG4gIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgPC0gYnlfbGFiZWw7XG4gIHRhYmxlLmhpZGRlbl9tZXRocyA8LVxuICAgICBMaXN0LmZvbGRfcmlnaHRcbiAgICAgICAoZnVuICgobGFiLCBfKSBhcyBtZXQpIGhtIC0+XG4gICAgICAgICAgaWYgTGlzdC5tZW0gbGFiIHZpcnRfbWV0aHMgdGhlbiBobSBlbHNlIG1ldDo6aG0pXG4gICAgICAgdGFibGUuaGlkZGVuX21ldGhzXG4gICAgICAgc2F2ZWRfaGlkZGVuX21ldGhzXG5cbmxldCBuZXdfc2xvdCB0YWJsZSA9XG4gIGxldCBpbmRleCA9IHRhYmxlLnNpemUgaW5cbiAgdGFibGUuc2l6ZSA8LSBpbmRleCArIDE7XG4gIGluZGV4XG5cbmxldCBuZXdfdmFyaWFibGUgdGFibGUgbmFtZSA9XG4gIHRyeSBWYXJzLmZpbmQgbmFtZSB0YWJsZS52YXJzXG4gIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgbGV0IGluZGV4ID0gbmV3X3Nsb3QgdGFibGUgaW5cbiAgICBpZiBuYW1lIDw+IFwiXCIgdGhlbiB0YWJsZS52YXJzIDwtIFZhcnMuYWRkIG5hbWUgaW5kZXggdGFibGUudmFycztcbiAgICBpbmRleFxuXG5sZXQgdG9fYXJyYXkgYXJyID1cbiAgaWYgYXJyID0gT2JqLm1hZ2ljIDAgdGhlbiBbfHxdIGVsc2UgYXJyXG5cbmxldCBuZXdfbWV0aG9kc192YXJpYWJsZXMgdGFibGUgbWV0aHMgdmFscyA9XG4gIGxldCBtZXRocyA9IHRvX2FycmF5IG1ldGhzIGluXG4gIGxldCBubWV0aHMgPSBBcnJheS5sZW5ndGggbWV0aHMgYW5kIG52YWxzID0gQXJyYXkubGVuZ3RoIHZhbHMgaW5cbiAgbGV0IHJlcyA9IEFycmF5Lm1ha2UgKG5tZXRocyArIG52YWxzKSAwIGluXG4gIGZvciBpID0gMCB0byBubWV0aHMgLSAxIGRvXG4gICAgcmVzLihpKSA8LSBnZXRfbWV0aG9kX2xhYmVsIHRhYmxlIG1ldGhzLihpKVxuICBkb25lO1xuICBmb3IgaSA9IDAgdG8gbnZhbHMgLSAxIGRvXG4gICAgcmVzLihpK25tZXRocykgPC0gbmV3X3ZhcmlhYmxlIHRhYmxlIHZhbHMuKGkpXG4gIGRvbmU7XG4gIHJlc1xuXG5sZXQgZ2V0X3ZhcmlhYmxlIHRhYmxlIG5hbWUgPVxuICB0cnkgVmFycy5maW5kIG5hbWUgdGFibGUudmFycyB3aXRoIE5vdF9mb3VuZCAtPiBhc3NlcnQgZmFsc2VcblxubGV0IGdldF92YXJpYWJsZXMgdGFibGUgbmFtZXMgPVxuICBBcnJheS5tYXAgKGdldF92YXJpYWJsZSB0YWJsZSkgbmFtZXNcblxubGV0IGFkZF9pbml0aWFsaXplciB0YWJsZSBmID1cbiAgdGFibGUuaW5pdGlhbGl6ZXJzIDwtIGY6OnRhYmxlLmluaXRpYWxpemVyc1xuXG4oKlxubW9kdWxlIEtleXMgPVxuICBNYXAuTWFrZShzdHJ1Y3QgdHlwZSB0ID0gdGFnIGFycmF5IGxldCBjb21wYXJlICh4OnQpIHkgPSBjb21wYXJlIHggeSBlbmQpXG5sZXQga2V5X21hcCA9IHJlZiBLZXlzLmVtcHR5XG5sZXQgZ2V0X2tleSB0YWdzIDogaXRlbSA9XG4gIHRyeSBtYWdpYyAoS2V5cy5maW5kIHRhZ3MgIWtleV9tYXAgOiB0YWcgYXJyYXkpXG4gIHdpdGggTm90X2ZvdW5kIC0+XG4gICAga2V5X21hcCA6PSBLZXlzLmFkZCB0YWdzIHRhZ3MgIWtleV9tYXA7XG4gICAgbWFnaWMgdGFnc1xuKilcblxubGV0IGNyZWF0ZV90YWJsZSBwdWJsaWNfbWV0aG9kcyA9XG4gIGlmIHB1YmxpY19tZXRob2RzID09IG1hZ2ljIDAgdGhlbiBuZXdfdGFibGUgW3x8XSBlbHNlXG4gICgqIFtwdWJsaWNfbWV0aG9kc10gbXVzdCBiZSBpbiBhc2NlbmRpbmcgb3JkZXIgZm9yIGJ5dGVjb2RlICopXG4gIGxldCB0YWdzID0gQXJyYXkubWFwIHB1YmxpY19tZXRob2RfbGFiZWwgcHVibGljX21ldGhvZHMgaW5cbiAgbGV0IHRhYmxlID0gbmV3X3RhYmxlIHRhZ3MgaW5cbiAgQXJyYXkuaXRlcmlcbiAgICAoZnVuIGkgbWV0IC0+XG4gICAgICBsZXQgbGFiID0gaSoyKzIgaW5cbiAgICAgIHRhYmxlLm1ldGhvZHNfYnlfbmFtZSAgPC0gTWV0aHMuYWRkIG1ldCBsYWIgdGFibGUubWV0aG9kc19ieV9uYW1lO1xuICAgICAgdGFibGUubWV0aG9kc19ieV9sYWJlbCA8LSBMYWJzLmFkZCBsYWIgdHJ1ZSB0YWJsZS5tZXRob2RzX2J5X2xhYmVsKVxuICAgIHB1YmxpY19tZXRob2RzO1xuICB0YWJsZVxuXG5sZXQgaW5pdF9jbGFzcyB0YWJsZSA9XG4gIGluc3RfdmFyX2NvdW50IDo9ICFpbnN0X3Zhcl9jb3VudCArIHRhYmxlLnNpemUgLSAxO1xuICB0YWJsZS5pbml0aWFsaXplcnMgPC0gTGlzdC5yZXYgdGFibGUuaW5pdGlhbGl6ZXJzO1xuICByZXNpemUgdGFibGUgKDMgKyBtYWdpYyB0YWJsZS5tZXRob2RzLigxKSAqIDE2IC8gU3lzLndvcmRfc2l6ZSlcblxubGV0IGluaGVyaXRzIGNsYSB2YWxzIHZpcnRfbWV0aHMgY29uY3JfbWV0aHMgKF8sIHN1cGVyLCBfLCBlbnYpIHRvcCA9XG4gIG5hcnJvdyBjbGEgdmFscyB2aXJ0X21ldGhzIGNvbmNyX21ldGhzO1xuICBsZXQgaW5pdCA9XG4gICAgaWYgdG9wIHRoZW4gc3VwZXIgY2xhIGVudiBlbHNlIE9iai5yZXByIChzdXBlciBjbGEpIGluXG4gIHdpZGVuIGNsYTtcbiAgQXJyYXkuY29uY2F0XG4gICAgW1t8IHJlcHIgaW5pdCB8XTtcbiAgICAgbWFnaWMgKEFycmF5Lm1hcCAoZ2V0X3ZhcmlhYmxlIGNsYSkgKHRvX2FycmF5IHZhbHMpIDogaW50IGFycmF5KTtcbiAgICAgQXJyYXkubWFwXG4gICAgICAgKGZ1biBubSAtPiByZXByIChnZXRfbWV0aG9kIGNsYSAoZ2V0X21ldGhvZF9sYWJlbCBjbGEgbm0pIDogY2xvc3VyZSkpXG4gICAgICAgKHRvX2FycmF5IGNvbmNyX21ldGhzKSBdXG5cbmxldCBtYWtlX2NsYXNzIHB1Yl9tZXRocyBjbGFzc19pbml0ID1cbiAgbGV0IHRhYmxlID0gY3JlYXRlX3RhYmxlIHB1Yl9tZXRocyBpblxuICBsZXQgZW52X2luaXQgPSBjbGFzc19pbml0IHRhYmxlIGluXG4gIGluaXRfY2xhc3MgdGFibGU7XG4gIChlbnZfaW5pdCAoT2JqLnJlcHIgMCksIGNsYXNzX2luaXQsIGVudl9pbml0LCBPYmoucmVwciAwKVxuXG50eXBlIGluaXRfdGFibGUgPSB7IG11dGFibGUgZW52X2luaXQ6IHQ7IG11dGFibGUgY2xhc3NfaW5pdDogdGFibGUgLT4gdCB9XG5cbmxldCBtYWtlX2NsYXNzX3N0b3JlIHB1Yl9tZXRocyBjbGFzc19pbml0IGluaXRfdGFibGUgPVxuICBsZXQgdGFibGUgPSBjcmVhdGVfdGFibGUgcHViX21ldGhzIGluXG4gIGxldCBlbnZfaW5pdCA9IGNsYXNzX2luaXQgdGFibGUgaW5cbiAgaW5pdF9jbGFzcyB0YWJsZTtcbiAgaW5pdF90YWJsZS5jbGFzc19pbml0IDwtIGNsYXNzX2luaXQ7XG4gIGluaXRfdGFibGUuZW52X2luaXQgPC0gZW52X2luaXRcblxubGV0IGR1bW15X2NsYXNzIGxvYyA9XG4gIGxldCB1bmRlZiA9IGZ1biBfIC0+IHJhaXNlIChVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZSBsb2MpIGluXG4gIChPYmoubWFnaWMgdW5kZWYsIHVuZGVmLCB1bmRlZiwgT2JqLnJlcHIgMClcblxuKCoqKiogT2JqZWN0cyAqKioqKVxuXG5sZXQgY3JlYXRlX29iamVjdCB0YWJsZSA9XG4gICgqIFhYWCBBcHBlbCBkZSBbb2JqX2Jsb2NrXSB8IENhbGwgdG8gW29ial9ibG9ja10gICopXG4gIGxldCBvYmogPSBPYmoubmV3X2Jsb2NrIE9iai5vYmplY3RfdGFnIHRhYmxlLnNpemUgaW5cbiAgKCogWFhYIEFwcGVsIGRlIFtjYW1sX21vZGlmeV0gfCBDYWxsIHRvIFtjYW1sX21vZGlmeV0gKilcbiAgT2JqLnNldF9maWVsZCBvYmogMCAoT2JqLnJlcHIgdGFibGUubWV0aG9kcyk7XG4gIE9iai5vYmogKHNldF9pZCBvYmopXG5cbmxldCBjcmVhdGVfb2JqZWN0X29wdCBvYmpfMCB0YWJsZSA9XG4gIGlmIChPYmoubWFnaWMgb2JqXzAgOiBib29sKSB0aGVuIG9ial8wIGVsc2UgYmVnaW5cbiAgICAoKiBYWFggQXBwZWwgZGUgW29ial9ibG9ja10gfCBDYWxsIHRvIFtvYmpfYmxvY2tdICAqKVxuICAgIGxldCBvYmogPSBPYmoubmV3X2Jsb2NrIE9iai5vYmplY3RfdGFnIHRhYmxlLnNpemUgaW5cbiAgICAoKiBYWFggQXBwZWwgZGUgW2NhbWxfbW9kaWZ5XSB8IENhbGwgdG8gW2NhbWxfbW9kaWZ5XSAqKVxuICAgIE9iai5zZXRfZmllbGQgb2JqIDAgKE9iai5yZXByIHRhYmxlLm1ldGhvZHMpO1xuICAgIE9iai5vYmogKHNldF9pZCBvYmopXG4gIGVuZFxuXG5sZXQgcmVjIGl0ZXJfZiBvYmogPVxuICBmdW5jdGlvblxuICAgIFtdICAgLT4gKClcbiAgfCBmOjpsIC0+IGYgb2JqOyBpdGVyX2Ygb2JqIGxcblxubGV0IHJ1bl9pbml0aWFsaXplcnMgb2JqIHRhYmxlID1cbiAgbGV0IGluaXRzID0gdGFibGUuaW5pdGlhbGl6ZXJzIGluXG4gIGlmIGluaXRzIDw+IFtdIHRoZW5cbiAgICBpdGVyX2Ygb2JqIGluaXRzXG5cbmxldCBydW5faW5pdGlhbGl6ZXJzX29wdCBvYmpfMCBvYmogdGFibGUgPVxuICBpZiAoT2JqLm1hZ2ljIG9ial8wIDogYm9vbCkgdGhlbiBvYmogZWxzZSBiZWdpblxuICAgIGxldCBpbml0cyA9IHRhYmxlLmluaXRpYWxpemVycyBpblxuICAgIGlmIGluaXRzIDw+IFtdIHRoZW4gaXRlcl9mIG9iaiBpbml0cztcbiAgICBvYmpcbiAgZW5kXG5cbmxldCBjcmVhdGVfb2JqZWN0X2FuZF9ydW5faW5pdGlhbGl6ZXJzIG9ial8wIHRhYmxlID1cbiAgaWYgKE9iai5tYWdpYyBvYmpfMCA6IGJvb2wpIHRoZW4gb2JqXzAgZWxzZSBiZWdpblxuICAgIGxldCBvYmogPSBjcmVhdGVfb2JqZWN0IHRhYmxlIGluXG4gICAgcnVuX2luaXRpYWxpemVycyBvYmogdGFibGU7XG4gICAgb2JqXG4gIGVuZFxuXG4oKiBFcXVpdmFsZW50IHByaW1pdGl2ZSBiZWxvd1xubGV0IHNlbmRzZWxmIG9iaiBsYWIgPVxuICAobWFnaWMgb2JqIDogKG9iaiAtPiB0KSBhcnJheSBhcnJheSkuKDApLihsYWIpIG9ialxuKilcbmV4dGVybmFsIHNlbmQgOiBvYmogLT4gdGFnIC0+ICdhID0gXCIlc2VuZFwiXG5leHRlcm5hbCBzZW5kY2FjaGUgOiBvYmogLT4gdGFnIC0+IHQgLT4gaW50IC0+ICdhID0gXCIlc2VuZGNhY2hlXCJcbmV4dGVybmFsIHNlbmRzZWxmIDogb2JqIC0+IGxhYmVsIC0+ICdhID0gXCIlc2VuZHNlbGZcIlxuZXh0ZXJuYWwgZ2V0X3B1YmxpY19tZXRob2QgOiBvYmogLT4gdGFnIC0+IGNsb3N1cmVcbiAgICA9IFwiY2FtbF9nZXRfcHVibGljX21ldGhvZFwiIFtAQG5vYWxsb2NdXG5cbigqKioqIHRhYmxlIGNvbGxlY3Rpb24gYWNjZXNzICoqKiopXG5cbnR5cGUgdGFibGVzID1cbiAgfCBFbXB0eVxuICB8IENvbnMgb2Yge2tleSA6IGNsb3N1cmU7IG11dGFibGUgZGF0YTogdGFibGVzOyBtdXRhYmxlIG5leHQ6IHRhYmxlc31cblxubGV0IHNldF9kYXRhIHRhYmxlcyB2ID0gbWF0Y2ggdGFibGVzIHdpdGhcbiAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgfCBDb25zIHRhYmxlcyAtPiB0YWJsZXMuZGF0YSA8LSB2XG5sZXQgc2V0X25leHQgdGFibGVzIHYgPSBtYXRjaCB0YWJsZXMgd2l0aFxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5uZXh0IDwtIHZcbmxldCBnZXRfa2V5ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgfCBDb25zIHRhYmxlcyAtPiB0YWJsZXMua2V5XG5sZXQgZ2V0X2RhdGEgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5kYXRhXG5sZXQgZ2V0X25leHQgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5uZXh0XG5cbmxldCBidWlsZF9wYXRoIG4ga2V5cyB0YWJsZXMgPVxuICBsZXQgcmVzID0gQ29ucyB7a2V5ID0gT2JqLm1hZ2ljIDA7IGRhdGEgPSBFbXB0eTsgbmV4dCA9IEVtcHR5fSBpblxuICBsZXQgciA9IHJlZiByZXMgaW5cbiAgZm9yIGkgPSAwIHRvIG4gZG9cbiAgICByIDo9IENvbnMge2tleSA9IGtleXMuKGkpOyBkYXRhID0gIXI7IG5leHQgPSBFbXB0eX1cbiAgZG9uZTtcbiAgc2V0X2RhdGEgdGFibGVzICFyO1xuICByZXNcblxubGV0IHJlYyBsb29rdXBfa2V5cyBpIGtleXMgdGFibGVzID1cbiAgaWYgaSA8IDAgdGhlbiB0YWJsZXMgZWxzZVxuICBsZXQga2V5ID0ga2V5cy4oaSkgaW5cbiAgbGV0IHJlYyBsb29rdXBfa2V5ICh0YWJsZXM6dGFibGVzKSA9XG4gICAgaWYgZ2V0X2tleSB0YWJsZXMgPT0ga2V5IHRoZW5cbiAgICAgIG1hdGNoIGdldF9kYXRhIHRhYmxlcyB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICAgICAgfCBDb25zIF8gYXMgdGFibGVzX2RhdGEgLT5cbiAgICAgICAgICBsb29rdXBfa2V5cyAoaS0xKSBrZXlzIHRhYmxlc19kYXRhXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggZ2V0X25leHQgdGFibGVzIHdpdGhcbiAgICAgIHwgQ29ucyBfIGFzIG5leHQgLT4gbG9va3VwX2tleSBuZXh0XG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgbGV0IG5leHQgOiB0YWJsZXMgPSBDb25zIHtrZXk7IGRhdGEgPSBFbXB0eTsgbmV4dCA9IEVtcHR5fSBpblxuICAgICAgICAgIHNldF9uZXh0IHRhYmxlcyBuZXh0O1xuICAgICAgICAgIGJ1aWxkX3BhdGggKGktMSkga2V5cyBuZXh0XG4gIGluXG4gIGxvb2t1cF9rZXkgdGFibGVzXG5cbmxldCBsb29rdXBfdGFibGVzIHJvb3Qga2V5cyA9XG4gIG1hdGNoIGdldF9kYXRhIHJvb3Qgd2l0aFxuICB8IENvbnMgXyBhcyByb290X2RhdGEgLT5cbiAgICBsb29rdXBfa2V5cyAoQXJyYXkubGVuZ3RoIGtleXMgLSAxKSBrZXlzIHJvb3RfZGF0YVxuICB8IEVtcHR5IC0+XG4gICAgYnVpbGRfcGF0aCAoQXJyYXkubGVuZ3RoIGtleXMgLSAxKSBrZXlzIHJvb3RcblxuKCoqKiogYnVpbHRpbiBtZXRob2RzICoqKiopXG5cbmxldCBnZXRfY29uc3QgeCA9IHJldCAoZnVuIF9vYmogLT4geClcbmxldCBnZXRfdmFyIG4gICA9IHJldCAoZnVuIG9iaiAtPiBBcnJheS51bnNhZmVfZ2V0IG9iaiBuKVxubGV0IGdldF9lbnYgZSBuID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgQXJyYXkudW5zYWZlX2dldCAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbilcbmxldCBnZXRfbWV0aCBuICA9IHJldCAoZnVuIG9iaiAtPiBzZW5kc2VsZiBvYmogbilcbmxldCBzZXRfdmFyIG4gICA9IHJldCAoZnVuIG9iaiB4IC0+IEFycmF5LnVuc2FmZV9zZXQgb2JqIG4geClcbmxldCBhcHBfY29uc3QgZiB4ID0gcmV0IChmdW4gX29iaiAtPiBmIHgpXG5sZXQgYXBwX3ZhciBmIG4gICA9IHJldCAoZnVuIG9iaiAtPiBmIChBcnJheS51bnNhZmVfZ2V0IG9iaiBuKSlcbmxldCBhcHBfZW52IGYgZSBuID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgZiAoQXJyYXkudW5zYWZlX2dldCAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbikpXG5sZXQgYXBwX21ldGggZiBuICA9IHJldCAoZnVuIG9iaiAtPiBmIChzZW5kc2VsZiBvYmogbikpXG5sZXQgYXBwX2NvbnN0X2NvbnN0IGYgeCB5ID0gcmV0IChmdW4gX29iaiAtPiBmIHggeSlcbmxldCBhcHBfY29uc3RfdmFyIGYgeCBuICAgPSByZXQgKGZ1biBvYmogLT4gZiB4IChBcnJheS51bnNhZmVfZ2V0IG9iaiBuKSlcbmxldCBhcHBfY29uc3RfbWV0aCBmIHggbiA9IHJldCAoZnVuIG9iaiAtPiBmIHggKHNlbmRzZWxmIG9iaiBuKSlcbmxldCBhcHBfdmFyX2NvbnN0IGYgbiB4ID0gcmV0IChmdW4gb2JqIC0+IGYgKEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pIHgpXG5sZXQgYXBwX21ldGhfY29uc3QgZiBuIHggPSByZXQgKGZ1biBvYmogLT4gZiAoc2VuZHNlbGYgb2JqIG4pIHgpXG5sZXQgYXBwX2NvbnN0X2VudiBmIHggZSBuID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgZiB4IChBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKSlcbmxldCBhcHBfZW52X2NvbnN0IGYgZSBuIHggPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBmIChBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKSB4KVxubGV0IG1ldGhfYXBwX2NvbnN0IG4geCA9IHJldCAoZnVuIG9iaiAtPiAoc2VuZHNlbGYgb2JqIG4gOiBfIC0+IF8pIHgpXG5sZXQgbWV0aF9hcHBfdmFyIG4gbSA9XG4gIHJldCAoZnVuIG9iaiAtPiAoc2VuZHNlbGYgb2JqIG4gOiBfIC0+IF8pIChBcnJheS51bnNhZmVfZ2V0IG9iaiBtKSlcbmxldCBtZXRoX2FwcF9lbnYgbiBlIG0gPVxuICByZXQgKGZ1biBvYmogLT4gKHNlbmRzZWxmIG9iaiBuIDogXyAtPiBfKVxuICAgICAgKEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG0pKVxubGV0IG1ldGhfYXBwX21ldGggbiBtID1cbiAgcmV0IChmdW4gb2JqIC0+IChzZW5kc2VsZiBvYmogbiA6IF8gLT4gXykgKHNlbmRzZWxmIG9iaiBtKSlcbmxldCBzZW5kX2NvbnN0IG0geCBjID1cbiAgcmV0IChmdW4gb2JqIC0+IHNlbmRjYWNoZSB4IG0gKEFycmF5LnVuc2FmZV9nZXQgb2JqIDApIGMpXG5sZXQgc2VuZF92YXIgbSBuIGMgPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBzZW5kY2FjaGUgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogbikgOiBvYmopIG1cbiAgICAgIChBcnJheS51bnNhZmVfZ2V0IG9iaiAwKSBjKVxubGV0IHNlbmRfZW52IG0gZSBuIGMgPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBzZW5kY2FjaGVcbiAgICAgIChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXRcbiAgICAgICAgICAgICAgICAgICAgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pIDogb2JqKVxuICAgICAgbSAoQXJyYXkudW5zYWZlX2dldCBvYmogMCkgYylcbmxldCBzZW5kX21ldGggbSBuIGMgPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBzZW5kY2FjaGUgKHNlbmRzZWxmIG9iaiBuKSBtIChBcnJheS51bnNhZmVfZ2V0IG9iaiAwKSBjKVxubGV0IG5ld19jYWNoZSB0YWJsZSA9XG4gIGxldCBuID0gbmV3X21ldGhvZCB0YWJsZSBpblxuICBsZXQgbiA9XG4gICAgaWYgbiBtb2QgMiA9IDAgfHwgbiA+IDIgKyBtYWdpYyB0YWJsZS5tZXRob2RzLigxKSAqIDE2IC8gU3lzLndvcmRfc2l6ZVxuICAgIHRoZW4gbiBlbHNlIG5ld19tZXRob2QgdGFibGVcbiAgaW5cbiAgdGFibGUubWV0aG9kcy4obikgPC0gT2JqLm1hZ2ljIDA7XG4gIG5cblxudHlwZSBpbXBsID1cbiAgICBHZXRDb25zdFxuICB8IEdldFZhclxuICB8IEdldEVudlxuICB8IEdldE1ldGhcbiAgfCBTZXRWYXJcbiAgfCBBcHBDb25zdFxuICB8IEFwcFZhclxuICB8IEFwcEVudlxuICB8IEFwcE1ldGhcbiAgfCBBcHBDb25zdENvbnN0XG4gIHwgQXBwQ29uc3RWYXJcbiAgfCBBcHBDb25zdEVudlxuICB8IEFwcENvbnN0TWV0aFxuICB8IEFwcFZhckNvbnN0XG4gIHwgQXBwRW52Q29uc3RcbiAgfCBBcHBNZXRoQ29uc3RcbiAgfCBNZXRoQXBwQ29uc3RcbiAgfCBNZXRoQXBwVmFyXG4gIHwgTWV0aEFwcEVudlxuICB8IE1ldGhBcHBNZXRoXG4gIHwgU2VuZENvbnN0XG4gIHwgU2VuZFZhclxuICB8IFNlbmRFbnZcbiAgfCBTZW5kTWV0aFxuICB8IENsb3N1cmUgb2YgY2xvc3VyZVxuXG5sZXQgbWV0aG9kX2ltcGwgdGFibGUgaSBhcnIgPVxuICBsZXQgbmV4dCAoKSA9IGluY3IgaTsgbWFnaWMgYXJyLighaSkgaW5cbiAgbWF0Y2ggbmV4dCgpIHdpdGhcbiAgICBHZXRDb25zdCAtPiBsZXQgeCA6IHQgPSBuZXh0KCkgaW4gZ2V0X2NvbnN0IHhcbiAgfCBHZXRWYXIgICAtPiBsZXQgbiA9IG5leHQoKSBpbiBnZXRfdmFyIG5cbiAgfCBHZXRFbnYgICAtPiBsZXQgZSA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpbiBnZXRfZW52IGUgblxuICB8IEdldE1ldGggIC0+IGxldCBuID0gbmV4dCgpIGluIGdldF9tZXRoIG5cbiAgfCBTZXRWYXIgICAtPiBsZXQgbiA9IG5leHQoKSBpbiBzZXRfdmFyIG5cbiAgfCBBcHBDb25zdCAtPiBsZXQgZiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBhcHBfY29uc3QgZiB4XG4gIHwgQXBwVmFyICAgLT4gbGV0IGYgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0ICgpIGluIGFwcF92YXIgZiBuXG4gIHwgQXBwRW52ICAgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluICBsZXQgZSA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpblxuICAgICAgYXBwX2VudiBmIGUgblxuICB8IEFwcE1ldGggIC0+IGxldCBmID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCAoKSBpbiBhcHBfbWV0aCBmIG5cbiAgfCBBcHBDb25zdENvbnN0IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBsZXQgeSA9IG5leHQoKSBpblxuICAgICAgYXBwX2NvbnN0X2NvbnN0IGYgeCB5XG4gIHwgQXBwQ29uc3RWYXIgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfdmFyIGYgeCBuXG4gIHwgQXBwQ29uc3RFbnYgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGxldCBlID0gbmV4dCAoKSBpbiBsZXQgbiA9IG5leHQoKSBpblxuICAgICAgYXBwX2NvbnN0X2VudiBmIHggZSBuXG4gIHwgQXBwQ29uc3RNZXRoIC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpblxuICAgICAgYXBwX2NvbnN0X21ldGggZiB4IG5cbiAgfCBBcHBWYXJDb25zdCAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW5cbiAgICAgIGFwcF92YXJfY29uc3QgZiBuIHhcbiAgfCBBcHBFbnZDb25zdCAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0ICgpIGluIGxldCBuID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluXG4gICAgICBhcHBfZW52X2NvbnN0IGYgZSBuIHhcbiAgfCBBcHBNZXRoQ29uc3QgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluXG4gICAgICBhcHBfbWV0aF9jb25zdCBmIG4geFxuICB8IE1ldGhBcHBDb25zdCAtPlxuICAgICAgbGV0IG4gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbWV0aF9hcHBfY29uc3QgbiB4XG4gIHwgTWV0aEFwcFZhciAtPlxuICAgICAgbGV0IG4gPSBuZXh0KCkgaW4gbGV0IG0gPSBuZXh0KCkgaW4gbWV0aF9hcHBfdmFyIG4gbVxuICB8IE1ldGhBcHBFbnYgLT5cbiAgICAgIGxldCBuID0gbmV4dCgpIGluIGxldCBlID0gbmV4dCgpIGluIGxldCBtID0gbmV4dCgpIGluXG4gICAgICBtZXRoX2FwcF9lbnYgbiBlIG1cbiAgfCBNZXRoQXBwTWV0aCAtPlxuICAgICAgbGV0IG4gPSBuZXh0KCkgaW4gbGV0IG0gPSBuZXh0KCkgaW4gbWV0aF9hcHBfbWV0aCBuIG1cbiAgfCBTZW5kQ29uc3QgLT5cbiAgICAgIGxldCBtID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIHNlbmRfY29uc3QgbSB4IChuZXdfY2FjaGUgdGFibGUpXG4gIHwgU2VuZFZhciAtPlxuICAgICAgbGV0IG0gPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0ICgpIGluIHNlbmRfdmFyIG0gbiAobmV3X2NhY2hlIHRhYmxlKVxuICB8IFNlbmRFbnYgLT5cbiAgICAgIGxldCBtID0gbmV4dCgpIGluIGxldCBlID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBzZW5kX2VudiBtIGUgbiAobmV3X2NhY2hlIHRhYmxlKVxuICB8IFNlbmRNZXRoIC0+XG4gICAgICBsZXQgbSA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQgKCkgaW4gc2VuZF9tZXRoIG0gbiAobmV3X2NhY2hlIHRhYmxlKVxuICB8IENsb3N1cmUgXyBhcyBjbG8gLT4gbWFnaWMgY2xvXG5cbmxldCBzZXRfbWV0aG9kcyB0YWJsZSBtZXRob2RzID1cbiAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBtZXRob2RzIGluIGxldCBpID0gcmVmIDAgaW5cbiAgd2hpbGUgIWkgPCBsZW4gZG9cbiAgICBsZXQgbGFiZWwgPSBtZXRob2RzLighaSkgaW4gbGV0IGNsbyA9IG1ldGhvZF9pbXBsIHRhYmxlIGkgbWV0aG9kcyBpblxuICAgIHNldF9tZXRob2QgdGFibGUgbGFiZWwgY2xvO1xuICAgIGluY3IgaVxuICBkb25lXG5cbigqKioqIFN0YXRpc3RpY3MgKioqKilcblxudHlwZSBzdGF0cyA9XG4gIHsgY2xhc3NlczogaW50OyBtZXRob2RzOiBpbnQ7IGluc3RfdmFyczogaW50OyB9XG5cbmxldCBzdGF0cyAoKSA9XG4gIHsgY2xhc3NlcyA9ICF0YWJsZV9jb3VudDtcbiAgICBtZXRob2RzID0gIW1ldGhvZF9jb3VudDsgaW5zdF92YXJzID0gIWluc3RfdmFyX2NvdW50OyB9XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgdG9rZW4gPVxuICAgIEt3ZCBvZiBzdHJpbmdcbiAgfCBJZGVudCBvZiBzdHJpbmdcbiAgfCBJbnQgb2YgaW50XG4gIHwgRmxvYXQgb2YgZmxvYXRcbiAgfCBTdHJpbmcgb2Ygc3RyaW5nXG4gIHwgQ2hhciBvZiBjaGFyXG5cbigqIFRoZSBzdHJpbmcgYnVmZmVyaW5nIG1hY2hpbmVyeSAqKVxuXG5sZXQgaW5pdGlhbF9idWZmZXIgPSBCeXRlcy5jcmVhdGUgMzJcblxubGV0IGJ1ZmZlciA9IHJlZiBpbml0aWFsX2J1ZmZlclxubGV0IGJ1ZnBvcyA9IHJlZiAwXG5cbmxldCByZXNldF9idWZmZXIgKCkgPSBidWZmZXIgOj0gaW5pdGlhbF9idWZmZXI7IGJ1ZnBvcyA6PSAwXG5cbmxldCBzdG9yZSBjID1cbiAgaWYgIWJ1ZnBvcyA+PSBCeXRlcy5sZW5ndGggIWJ1ZmZlciB0aGVuIGJlZ2luXG4gICAgbGV0IG5ld2J1ZmZlciA9IEJ5dGVzLmNyZWF0ZSAoMiAqICFidWZwb3MpIGluXG4gICAgQnl0ZXMuYmxpdCAhYnVmZmVyIDAgbmV3YnVmZmVyIDAgIWJ1ZnBvcztcbiAgICBidWZmZXIgOj0gbmV3YnVmZmVyXG4gIGVuZDtcbiAgQnl0ZXMuc2V0ICFidWZmZXIgIWJ1ZnBvcyBjO1xuICBpbmNyIGJ1ZnBvc1xuXG5sZXQgZ2V0X3N0cmluZyAoKSA9XG4gIGxldCBzID0gQnl0ZXMuc3ViX3N0cmluZyAhYnVmZmVyIDAgIWJ1ZnBvcyBpbiBidWZmZXIgOj0gaW5pdGlhbF9idWZmZXI7IHNcblxuKCogVGhlIGxleGVyICopXG5cbmxldCBtYWtlX2xleGVyIGtleXdvcmRzID1cbiAgbGV0IGt3ZF90YWJsZSA9IEhhc2h0YmwuY3JlYXRlIDE3IGluXG4gIExpc3QuaXRlciAoZnVuIHMgLT4gSGFzaHRibC5hZGQga3dkX3RhYmxlIHMgKEt3ZCBzKSkga2V5d29yZHM7XG4gIGxldCBpZGVudF9vcl9rZXl3b3JkIGlkID1cbiAgICB0cnkgSGFzaHRibC5maW5kIGt3ZF90YWJsZSBpZCB3aXRoXG4gICAgICBOb3RfZm91bmQgLT4gSWRlbnQgaWRcbiAgYW5kIGtleXdvcmRfb3JfZXJyb3IgYyA9XG4gICAgbGV0IHMgPSBTdHJpbmcubWFrZSAxIGMgaW5cbiAgICB0cnkgSGFzaHRibC5maW5kIGt3ZF90YWJsZSBzIHdpdGhcbiAgICAgIE5vdF9mb3VuZCAtPiByYWlzZSAoU3RyZWFtLkVycm9yIChcIklsbGVnYWwgY2hhcmFjdGVyIFwiIF4gcykpXG4gIGluXG4gIGxldCByZWMgbmV4dF90b2tlbiAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICgnICcgfCAnXFwwMTAnIHwgJ1xcMDEzJyB8ICdcXDAwOScgfCAnXFwwMjYnIHwgJ1xcMDEyJykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBuZXh0X3Rva2VuIHN0cm1fX1xuICAgIHwgU29tZSAoJ0EnLi4nWicgfCAnYScuLid6JyB8ICdfJyB8ICdcXDE5MicuLidcXDI1NScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgcyA9IHN0cm1fXyBpbiByZXNldF9idWZmZXIgKCk7IHN0b3JlIGM7IGlkZW50IHNcbiAgICB8IFNvbWVcbiAgICAgICAgKCchJyB8ICclJyB8ICcmJyB8ICckJyB8ICcjJyB8ICcrJyB8ICcvJyB8ICc6JyB8ICc8JyB8ICc9JyB8ICc+JyB8XG4gICAgICAgICAnPycgfCAnQCcgfCAnXFxcXCcgfCAnficgfCAnXicgfCAnfCcgfCAnKicgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgcyA9IHN0cm1fXyBpbiByZXNldF9idWZmZXIgKCk7IHN0b3JlIGM7IGlkZW50MiBzXG4gICAgfCBTb21lICgnMCcuLic5JyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHJlc2V0X2J1ZmZlciAoKTsgc3RvcmUgYzsgbnVtYmVyIHNcbiAgICB8IFNvbWUgJ1xcJycgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgYyA9XG4gICAgICAgICAgdHJ5IGNoYXIgc3RybV9fIHdpdGhcbiAgICAgICAgICAgIFN0cmVhbS5GYWlsdXJlIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgXCJcIilcbiAgICAgICAgaW5cbiAgICAgICAgYmVnaW4gbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgICAgICBTb21lICdcXCcnIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgU29tZSAoQ2hhciBjKVxuICAgICAgICB8IF8gLT4gcmFpc2UgKFN0cmVhbS5FcnJvciBcIlwiKVxuICAgICAgICBlbmRcbiAgICB8IFNvbWUgJ1xcXCInIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IHMgPSBzdHJtX18gaW4gcmVzZXRfYnVmZmVyICgpOyBTb21lIChTdHJpbmcgKHN0cmluZyBzKSlcbiAgICB8IFNvbWUgJy0nIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgbmVnX251bWJlciBzdHJtX19cbiAgICB8IFNvbWUgJygnIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgbWF5YmVfY29tbWVudCBzdHJtX19cbiAgICB8IFNvbWUgYyAtPiBTdHJlYW0uanVuayBzdHJtX187IFNvbWUgKGtleXdvcmRfb3JfZXJyb3IgYylcbiAgICB8IF8gLT4gTm9uZVxuICBhbmQgaWRlbnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZVxuICAgICAgICAoJ0EnLi4nWicgfCAnYScuLid6JyB8ICdcXDE5MicuLidcXDI1NScgfCAnMCcuLic5JyB8ICdfJyB8ICdcXCcnIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgaWRlbnQgc1xuICAgIHwgXyAtPiBTb21lIChpZGVudF9vcl9rZXl3b3JkIChnZXRfc3RyaW5nICgpKSlcbiAgYW5kIGlkZW50MiAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lXG4gICAgICAgICgnIScgfCAnJScgfCAnJicgfCAnJCcgfCAnIycgfCAnKycgfCAnLScgfCAnLycgfCAnOicgfCAnPCcgfCAnPScgfFxuICAgICAgICAgJz4nIHwgJz8nIHwgJ0AnIHwgJ1xcXFwnIHwgJ34nIHwgJ14nIHwgJ3wnIHwgJyonIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgaWRlbnQyIHNcbiAgICB8IF8gLT4gU29tZSAoaWRlbnRfb3Jfa2V5d29yZCAoZ2V0X3N0cmluZyAoKSkpXG4gIGFuZCBuZWdfbnVtYmVyIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgKCcwJy4uJzknIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IHMgPSBzdHJtX18gaW4gcmVzZXRfYnVmZmVyICgpOyBzdG9yZSAnLSc7IHN0b3JlIGM7IG51bWJlciBzXG4gICAgfCBfIC0+IGxldCBzID0gc3RybV9fIGluIHJlc2V0X2J1ZmZlciAoKTsgc3RvcmUgJy0nOyBpZGVudDIgc1xuICBhbmQgbnVtYmVyIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgKCcwJy4uJzknIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgbnVtYmVyIHNcbiAgICB8IFNvbWUgJy4nIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgJy4nOyBkZWNpbWFsX3BhcnQgc1xuICAgIHwgU29tZSAoJ2UnIHwgJ0UnKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlICdFJzsgZXhwb25lbnRfcGFydCBzXG4gICAgfCBfIC0+IFNvbWUgKEludCAoaW50X29mX3N0cmluZyAoZ2V0X3N0cmluZyAoKSkpKVxuICBhbmQgZGVjaW1hbF9wYXJ0IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgKCcwJy4uJzknIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgZGVjaW1hbF9wYXJ0IHNcbiAgICB8IFNvbWUgKCdlJyB8ICdFJykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSAnRSc7IGV4cG9uZW50X3BhcnQgc1xuICAgIHwgXyAtPiBTb21lIChGbG9hdCAoZmxvYXRfb2Zfc3RyaW5nIChnZXRfc3RyaW5nICgpKSkpXG4gIGFuZCBleHBvbmVudF9wYXJ0IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgKCcrJyB8ICctJyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IGVuZF9leHBvbmVudF9wYXJ0IHNcbiAgICB8IF8gLT4gZW5kX2V4cG9uZW50X3BhcnQgc3RybV9fXG4gIGFuZCBlbmRfZXhwb25lbnRfcGFydCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICgnMCcuLic5JyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IGVuZF9leHBvbmVudF9wYXJ0IHNcbiAgICB8IF8gLT4gU29tZSAoRmxvYXQgKGZsb2F0X29mX3N0cmluZyAoZ2V0X3N0cmluZyAoKSkpKVxuICBhbmQgc3RyaW5nIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJ1xcXCInIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgZ2V0X3N0cmluZyAoKVxuICAgIHwgU29tZSAnXFxcXCcgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgYyA9XG4gICAgICAgICAgdHJ5IGVzY2FwZSBzdHJtX18gd2l0aFxuICAgICAgICAgICAgU3RyZWFtLkZhaWx1cmUgLT4gcmFpc2UgKFN0cmVhbS5FcnJvciBcIlwiKVxuICAgICAgICBpblxuICAgICAgICBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBzdHJpbmcgc1xuICAgIHwgU29tZSBjIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgc3RyaW5nIHNcbiAgICB8IF8gLT4gcmFpc2UgU3RyZWFtLkZhaWx1cmVcbiAgYW5kIGNoYXIgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnXFxcXCcgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBiZWdpbiB0cnkgZXNjYXBlIHN0cm1fXyB3aXRoXG4gICAgICAgICAgU3RyZWFtLkZhaWx1cmUgLT4gcmFpc2UgKFN0cmVhbS5FcnJvciBcIlwiKVxuICAgICAgICBlbmRcbiAgICB8IFNvbWUgYyAtPiBTdHJlYW0uanVuayBzdHJtX187IGNcbiAgICB8IF8gLT4gcmFpc2UgU3RyZWFtLkZhaWx1cmVcbiAgYW5kIGVzY2FwZSAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICduJyAtPiBTdHJlYW0uanVuayBzdHJtX187ICdcXG4nXG4gICAgfCBTb21lICdyJyAtPiBTdHJlYW0uanVuayBzdHJtX187ICdcXHInXG4gICAgfCBTb21lICd0JyAtPiBTdHJlYW0uanVuayBzdHJtX187ICdcXHQnXG4gICAgfCBTb21lICgnMCcuLic5JyBhcyBjMSkgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBiZWdpbiBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgICAgIFNvbWUgKCcwJy4uJzknIGFzIGMyKSAtPlxuICAgICAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgICAgICAgICAgU29tZSAoJzAnLi4nOScgYXMgYzMpIC0+XG4gICAgICAgICAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICAgICAgICAgIENoYXIuY2hyXG4gICAgICAgICAgICAgICAgICAoKENoYXIuY29kZSBjMSAtIDQ4KSAqIDEwMCArIChDaGFyLmNvZGUgYzIgLSA0OCkgKiAxMCArXG4gICAgICAgICAgICAgICAgICAgICAoQ2hhci5jb2RlIGMzIC0gNDgpKVxuICAgICAgICAgICAgfCBfIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgXCJcIilcbiAgICAgICAgICAgIGVuZFxuICAgICAgICB8IF8gLT4gcmFpc2UgKFN0cmVhbS5FcnJvciBcIlwiKVxuICAgICAgICBlbmRcbiAgICB8IFNvbWUgYyAtPiBTdHJlYW0uanVuayBzdHJtX187IGNcbiAgICB8IF8gLT4gcmFpc2UgU3RyZWFtLkZhaWx1cmVcbiAgYW5kIG1heWJlX2NvbW1lbnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnKicgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBjb21tZW50IHM7IG5leHRfdG9rZW4gc1xuICAgIHwgXyAtPiBTb21lIChrZXl3b3JkX29yX2Vycm9yICcoJylcbiAgYW5kIGNvbW1lbnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnKCcgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBtYXliZV9uZXN0ZWRfY29tbWVudCBzdHJtX19cbiAgICB8IFNvbWUgJyonIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgbWF5YmVfZW5kX2NvbW1lbnQgc3RybV9fXG4gICAgfCBTb21lIF8gLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBjb21tZW50IHN0cm1fX1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBhbmQgbWF5YmVfbmVzdGVkX2NvbW1lbnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnKicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBjb21tZW50IHM7IGNvbW1lbnQgc1xuICAgIHwgU29tZSBfIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgY29tbWVudCBzdHJtX19cbiAgICB8IF8gLT4gcmFpc2UgU3RyZWFtLkZhaWx1cmVcbiAgYW5kIG1heWJlX2VuZF9jb21tZW50IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJyknIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgKClcbiAgICB8IFNvbWUgJyonIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgbWF5YmVfZW5kX2NvbW1lbnQgc3RybV9fXG4gICAgfCBTb21lIF8gLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBjb21tZW50IHN0cm1fX1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBpblxuICBmdW4gaW5wdXQgLT4gU3RyZWFtLmZyb20gKGZ1biBfY291bnQgLT4gbmV4dF90b2tlbiBpbnB1dClcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubW9kdWxlIHR5cGUgU2VlZGVkUyA9IHNpZ1xuICBpbmNsdWRlIEhhc2h0YmwuU2VlZGVkU1xuICB2YWwgY2xlYW46ICdhIHQgLT4gdW5pdFxuICB2YWwgc3RhdHNfYWxpdmU6ICdhIHQgLT4gSGFzaHRibC5zdGF0aXN0aWNzXG4gICAgKCoqIHNhbWUgYXMgeyFzdGF0c30gYnV0IG9ubHkgY291bnQgdGhlIGFsaXZlIGJpbmRpbmdzICopXG5lbmRcblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICBpbmNsdWRlIEhhc2h0YmwuU1xuICB2YWwgY2xlYW46ICdhIHQgLT4gdW5pdFxuICB2YWwgc3RhdHNfYWxpdmU6ICdhIHQgLT4gSGFzaHRibC5zdGF0aXN0aWNzXG4gICAgKCoqIHNhbWUgYXMgeyFzdGF0c30gYnV0IG9ubHkgY291bnQgdGhlIGFsaXZlIGJpbmRpbmdzICopXG5lbmRcblxubW9kdWxlIEdlbkhhc2hUYWJsZSA9IHN0cnVjdFxuXG4gIHR5cGUgZXF1YWwgPVxuICB8IEVUcnVlIHwgRUZhbHNlXG4gIHwgRURlYWQgKCoqIHRoZSBnYXJiYWdlIGNvbGxlY3RvciByZWNsYWltZWQgdGhlIGRhdGEgKilcblxuICBtb2R1bGUgTWFrZVNlZWRlZChIOiBzaWdcbiAgICB0eXBlIHRcbiAgICB0eXBlICdhIGNvbnRhaW5lclxuICAgIHZhbCBjcmVhdGU6IHQgLT4gJ2EgLT4gJ2EgY29udGFpbmVyXG4gICAgdmFsIGhhc2g6IGludCAtPiB0IC0+IGludFxuICAgIHZhbCBlcXVhbDogJ2EgY29udGFpbmVyIC0+IHQgLT4gZXF1YWxcbiAgICB2YWwgZ2V0X2RhdGE6ICdhIGNvbnRhaW5lciAtPiAnYSBvcHRpb25cbiAgICB2YWwgZ2V0X2tleTogJ2EgY29udGFpbmVyIC0+IHQgb3B0aW9uXG4gICAgdmFsIHNldF9rZXlfZGF0YTogJ2EgY29udGFpbmVyIC0+IHQgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCBjaGVja19rZXk6ICdhIGNvbnRhaW5lciAtPiBib29sXG4gIGVuZCkgOiBTZWVkZWRTIHdpdGggdHlwZSBrZXkgPSBILnRcbiAgPSBzdHJ1Y3RcblxuICAgIHR5cGUgJ2EgdCA9XG4gICAgICB7IG11dGFibGUgc2l6ZTogaW50OyAgICAgICAgICAgICAgICAgICgqIG51bWJlciBvZiBlbnRyaWVzICopXG4gICAgICAgIG11dGFibGUgZGF0YTogJ2EgYnVja2V0bGlzdCBhcnJheTsgICgqIHRoZSBidWNrZXRzICopXG4gICAgICAgIG11dGFibGUgc2VlZDogaW50OyAgICAgICAgICAgICAgICAgICgqIGZvciByYW5kb21pemF0aW9uICopXG4gICAgICAgIGluaXRpYWxfc2l6ZTogaW50OyAgICAgICAgICAgICAgICAgICgqIGluaXRpYWwgYXJyYXkgc2l6ZSAqKVxuICAgICAgfVxuXG4gICAgYW5kICdhIGJ1Y2tldGxpc3QgPVxuICAgIHwgRW1wdHlcbiAgICB8IENvbnMgb2YgaW50ICgqIGhhc2ggb2YgdGhlIGtleSAqKSAqICdhIEguY29udGFpbmVyICogJ2EgYnVja2V0bGlzdFxuXG4gICAgKCoqIHRoZSBoYXNoIG9mIHRoZSBrZXkgaXMga2VwdCBpbiBvcmRlciB0byB0ZXN0IHRoZSBlcXVhbGl0eSBvZiB0aGUgaGFzaFxuICAgICAgYmVmb3JlIHRoZSBrZXkuIFNhbWUgcmVhc29uIGFzIGZvciBXZWFrLk1ha2UgKilcblxuICAgIHR5cGUga2V5ID0gSC50XG5cbiAgICBsZXQgcmVjIHBvd2VyXzJfYWJvdmUgeCBuID1cbiAgICAgIGlmIHggPj0gbiB0aGVuIHhcbiAgICAgIGVsc2UgaWYgeCAqIDIgPiBTeXMubWF4X2FycmF5X2xlbmd0aCB0aGVuIHhcbiAgICAgIGVsc2UgcG93ZXJfMl9hYm92ZSAoeCAqIDIpIG5cblxuICAgIGxldCBwcm5nID0gbGF6eSAoUmFuZG9tLlN0YXRlLm1ha2Vfc2VsZl9pbml0KCkpXG5cbiAgICBsZXQgY3JlYXRlID8ocmFuZG9tID0gKEhhc2h0YmwuaXNfcmFuZG9taXplZCAoKSkpIGluaXRpYWxfc2l6ZSA9XG4gICAgICBsZXQgcyA9IHBvd2VyXzJfYWJvdmUgMTYgaW5pdGlhbF9zaXplIGluXG4gICAgICBsZXQgc2VlZCA9IGlmIHJhbmRvbSB0aGVuIFJhbmRvbS5TdGF0ZS5iaXRzIChMYXp5LmZvcmNlIHBybmcpIGVsc2UgMCBpblxuICAgICAgeyBpbml0aWFsX3NpemUgPSBzOyBzaXplID0gMDsgc2VlZCA9IHNlZWQ7IGRhdGEgPSBBcnJheS5tYWtlIHMgRW1wdHkgfVxuXG4gICAgbGV0IGNsZWFyIGggPVxuICAgICAgaC5zaXplIDwtIDA7XG4gICAgICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIGguZGF0YSBpblxuICAgICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgICAgaC5kYXRhLihpKSA8LSBFbXB0eVxuICAgICAgZG9uZVxuXG4gICAgbGV0IHJlc2V0IGggPVxuICAgICAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBoLmRhdGEgaW5cbiAgICAgIGlmIGxlbiA9IGguaW5pdGlhbF9zaXplIHRoZW5cbiAgICAgICAgY2xlYXIgaFxuICAgICAgZWxzZSBiZWdpblxuICAgICAgICBoLnNpemUgPC0gMDtcbiAgICAgICAgaC5kYXRhIDwtIEFycmF5Lm1ha2UgaC5pbml0aWFsX3NpemUgRW1wdHlcbiAgICAgIGVuZFxuXG4gICAgbGV0IGNvcHkgaCA9IHsgaCB3aXRoIGRhdGEgPSBBcnJheS5jb3B5IGguZGF0YSB9XG5cbiAgICBsZXQga2V5X2luZGV4IGggaGtleSA9XG4gICAgICBoa2V5IGxhbmQgKEFycmF5Lmxlbmd0aCBoLmRhdGEgLSAxKVxuXG4gICAgbGV0IGNsZWFuIGggPVxuICAgICAgbGV0IHJlYyBkb19idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgICBFbXB0eVxuICAgICAgICB8IENvbnMoXywgYywgcmVzdCkgd2hlbiBub3QgKEguY2hlY2tfa2V5IGMpIC0+XG4gICAgICAgICAgICBoLnNpemUgPC0gaC5zaXplIC0gMTtcbiAgICAgICAgICAgIGRvX2J1Y2tldCByZXN0XG4gICAgICAgIHwgQ29ucyhoa2V5LCBjLCByZXN0KSAtPlxuICAgICAgICAgICAgQ29ucyhoa2V5LCBjLCBkb19idWNrZXQgcmVzdClcbiAgICAgIGluXG4gICAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgICBkLihpKSA8LSBkb19idWNrZXQgZC4oaSlcbiAgICAgIGRvbmVcblxuICAgICgqKiByZXNpemUgaXMgdGhlIG9ubHkgZnVuY3Rpb24gdG8gZG8gdGhlIGFjdHVhbCBjbGVhbmluZyBvZiBkZWFkIGtleXNcbiAgICAgICAgKHJlbW92ZSBkb2VzIGl0IGp1c3QgYmVjYXVzZSBpdCBjb3VsZCkuXG5cbiAgICAgICAgVGhlIGdvYWwgaXMgdG86XG5cbiAgICAgICAgLSBub3QgcmVzaXplIGluZmluaXRlbHkgd2hlbiB0aGUgYWN0dWFsIG51bWJlciBvZiBhbGl2ZSBrZXlzIGlzXG4gICAgICAgIGJvdW5kZWQgYnV0IGtleXMgYXJlIGNvbnRpbnVvdXNseSBhZGRlZC4gVGhhdCB3b3VsZCBoYXBwZW4gaWZcbiAgICAgICAgdGhpcyBmdW5jdGlvbiBhbHdheXMgcmVzaXplLlxuICAgICAgICAtIG5vdCBjYWxsIHRoaXMgZnVuY3Rpb24gYWZ0ZXIgZWFjaCBhZGRpdGlvbiwgdGhhdCB3b3VsZCBoYXBwZW4gaWYgdGhpc1xuICAgICAgICBmdW5jdGlvbiBkb24ndCByZXNpemUgZXZlbiB3aGVuIG9ubHkgb25lIGtleSBpcyBkZWFkLlxuXG4gICAgICAgIFNvIHRoZSBhbGdvcml0aG06XG4gICAgICAgIC0gY2xlYW4gdGhlIGtleXMgYmVmb3JlIHJlc2l6aW5nXG4gICAgICAgIC0gaWYgdGhlIG51bWJlciBvZiByZW1haW5pbmcga2V5cyBpcyBsZXNzIHRoYW4gaGFsZiB0aGUgc2l6ZSBvZiB0aGVcbiAgICAgICAgYXJyYXksIGRvbid0IHJlc2l6ZS5cbiAgICAgICAgLSBpZiBpdCBpcyBtb3JlLCByZXNpemUuXG5cbiAgICAgICAgVGhlIHNlY29uZCBwcm9ibGVtIHJlbWFpbnMgaWYgdGhlIHRhYmxlIHJlYWNoZXMgeyFTeXMubWF4X2FycmF5X2xlbmd0aH0uXG5cbiAgICAqKVxuICAgIGxldCByZXNpemUgaCA9XG4gICAgICBsZXQgb2RhdGEgPSBoLmRhdGEgaW5cbiAgICAgIGxldCBvc2l6ZSA9IEFycmF5Lmxlbmd0aCBvZGF0YSBpblxuICAgICAgbGV0IG5zaXplID0gb3NpemUgKiAyIGluXG4gICAgICBjbGVhbiBoO1xuICAgICAgaWYgbnNpemUgPCBTeXMubWF4X2FycmF5X2xlbmd0aCAmJiBoLnNpemUgPj0gb3NpemUgbHNyIDEgdGhlbiBiZWdpblxuICAgICAgICBsZXQgbmRhdGEgPSBBcnJheS5tYWtlIG5zaXplIEVtcHR5IGluXG4gICAgICAgIGguZGF0YSA8LSBuZGF0YTsgICAgICAgKCogc28gdGhhdCBrZXlfaW5kZXggc2VlcyB0aGUgbmV3IGJ1Y2tldCBjb3VudCAqKVxuICAgICAgICBsZXQgcmVjIGluc2VydF9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICAgICAgRW1wdHkgLT4gKClcbiAgICAgICAgICB8IENvbnMoaGtleSwgZGF0YSwgcmVzdCkgLT5cbiAgICAgICAgICAgICAgaW5zZXJ0X2J1Y2tldCByZXN0OyAoKiBwcmVzZXJ2ZSBvcmlnaW5hbCBvcmRlciBvZiBlbGVtZW50cyAqKVxuICAgICAgICAgICAgICBsZXQgbmlkeCA9IGtleV9pbmRleCBoIGhrZXkgaW5cbiAgICAgICAgICAgICAgbmRhdGEuKG5pZHgpIDwtIENvbnMoaGtleSwgZGF0YSwgbmRhdGEuKG5pZHgpKSBpblxuICAgICAgICBmb3IgaSA9IDAgdG8gb3NpemUgLSAxIGRvXG4gICAgICAgICAgaW5zZXJ0X2J1Y2tldCBvZGF0YS4oaSlcbiAgICAgICAgZG9uZVxuICAgICAgZW5kXG5cbiAgICBsZXQgYWRkIGgga2V5IGluZm8gPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBoa2V5IGluXG4gICAgICBsZXQgY29udGFpbmVyID0gSC5jcmVhdGUga2V5IGluZm8gaW5cbiAgICAgIGxldCBidWNrZXQgPSBDb25zKGhrZXksIGNvbnRhaW5lciwgaC5kYXRhLihpKSkgaW5cbiAgICAgIGguZGF0YS4oaSkgPC0gYnVja2V0O1xuICAgICAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gICAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGhcblxuICAgIGxldCByZW1vdmUgaCBrZXkgPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgbGV0IHJlYyByZW1vdmVfYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgICAgfCBFbXB0eSAtPiBFbXB0eVxuICAgICAgICB8IENvbnMoaGssIGMsIG5leHQpIHdoZW4gaGtleSA9IGhrIC0+XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICAgIHwgRVRydWUgLT4gaC5zaXplIDwtIGguc2l6ZSAtIDE7IG5leHRcbiAgICAgICAgICAgIHwgRUZhbHNlIC0+IENvbnMoaGssIGMsIHJlbW92ZV9idWNrZXQgbmV4dClcbiAgICAgICAgICAgIHwgRURlYWQgLT5cbiAgICAgICAgICAgICAgICAoKiBUaGUgZGVhZCBrZXkgaXMgYXV0b21hdGljYWxseSByZW1vdmVkLiBJdCBpcyBhY2NlcHRhYmxlXG4gICAgICAgICAgICAgICAgICAgIGZvciB0aGlzIGZ1bmN0aW9uIHNpbmNlIGl0IGFscmVhZHkgcmVtb3ZlcyBhIGJpbmRpbmcgKilcbiAgICAgICAgICAgICAgICBoLnNpemUgPC0gaC5zaXplIC0gMTtcbiAgICAgICAgICAgICAgICByZW1vdmVfYnVja2V0IG5leHRcbiAgICAgICAgICAgIGVuZFxuICAgICAgICB8IENvbnMoaGssYyxuZXh0KSAtPiBDb25zKGhrLCBjLCByZW1vdmVfYnVja2V0IG5leHQpIGluXG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGhrZXkgaW5cbiAgICAgIGguZGF0YS4oaSkgPC0gcmVtb3ZlX2J1Y2tldCBoLmRhdGEuKGkpXG5cbiAgICAoKiogeyFmaW5kfSBkb24ndCByZW1vdmUgZGVhZCBrZXlzIGJlY2F1c2UgaXQgd291bGQgYmUgc3VycHJpc2luZyBmb3JcbiAgICAgICAgdGhlIHVzZXIgdGhhdCBhIHJlYWQtb25seSBmdW5jdGlvbiBtdXRhdGVzIHRoZSBzdGF0ZSAoZWcuIGNvbmN1cnJlbnRcbiAgICAgICAgYWNjZXNzKS4gU2FtZSBmb3IgeyFpdGVyfSwgeyFmb2xkfSwgeyFtZW19LlxuICAgICopXG4gICAgbGV0IHJlYyBmaW5kX3JlYyBrZXkgaGtleSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IENvbnMoaGssIGMsIHJlc3QpIHdoZW4gaGtleSA9IGhrICAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgIHwgRVRydWUgLT5cbiAgICAgICAgICAgICAgYmVnaW4gbWF0Y2ggSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgICAoKiBUaGlzIGNhc2UgaXMgbm90IGltcG9zc2libGUgYmVjYXVzZSB0aGUgZ2MgY2FuIHJ1biBiZXR3ZWVuXG4gICAgICAgICAgICAgICAgICAgICAgSC5lcXVhbCBhbmQgSC5nZXRfZGF0YSAqKVxuICAgICAgICAgICAgICAgICAgZmluZF9yZWMga2V5IGhrZXkgcmVzdFxuICAgICAgICAgICAgICB8IFNvbWUgZCAtPiBkXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgIHwgRUZhbHNlIC0+IGZpbmRfcmVjIGtleSBoa2V5IHJlc3RcbiAgICAgICAgICB8IEVEZWFkIC0+XG4gICAgICAgICAgICAgIGZpbmRfcmVjIGtleSBoa2V5IHJlc3RcbiAgICAgICAgICBlbmRcbiAgICAgIHwgQ29ucyhfLCBfLCByZXN0KSAtPlxuICAgICAgICAgIGZpbmRfcmVjIGtleSBoa2V5IHJlc3RcblxuICAgIGxldCBmaW5kIGgga2V5ID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgICgqIFRPRE8gaW5saW5lIDMgaXRlcmF0aW9ucyAqKVxuICAgICAgZmluZF9yZWMga2V5IGhrZXkgKGguZGF0YS4oa2V5X2luZGV4IGggaGtleSkpXG5cbiAgICBsZXQgcmVjIGZpbmRfcmVjX29wdCBrZXkgaGtleSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBDb25zKGhrLCBjLCByZXN0KSB3aGVuIGhrZXkgPSBoayAgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICB8IEVUcnVlIC0+XG4gICAgICAgICAgICAgIGJlZ2luIG1hdGNoIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgICAgKCogVGhpcyBjYXNlIGlzIG5vdCBpbXBvc3NpYmxlIGJlY2F1c2UgdGhlIGdjIGNhbiBydW4gYmV0d2VlblxuICAgICAgICAgICAgICAgICAgICAgIEguZXF1YWwgYW5kIEguZ2V0X2RhdGEgKilcbiAgICAgICAgICAgICAgICAgIGZpbmRfcmVjX29wdCBrZXkgaGtleSByZXN0XG4gICAgICAgICAgICAgIHwgU29tZSBfIGFzIGQgLT4gZFxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICB8IEVGYWxzZSAtPiBmaW5kX3JlY19vcHQga2V5IGhrZXkgcmVzdFxuICAgICAgICAgIHwgRURlYWQgLT5cbiAgICAgICAgICAgICAgZmluZF9yZWNfb3B0IGtleSBoa2V5IHJlc3RcbiAgICAgICAgICBlbmRcbiAgICAgIHwgQ29ucyhfLCBfLCByZXN0KSAtPlxuICAgICAgICAgIGZpbmRfcmVjX29wdCBrZXkgaGtleSByZXN0XG5cbiAgICBsZXQgZmluZF9vcHQgaCBrZXkgPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgKCogVE9ETyBpbmxpbmUgMyBpdGVyYXRpb25zICopXG4gICAgICBmaW5kX3JlY19vcHQga2V5IGhrZXkgKGguZGF0YS4oa2V5X2luZGV4IGggaGtleSkpXG5cbiAgICBsZXQgZmluZF9hbGwgaCBrZXkgPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgbGV0IHJlYyBmaW5kX2luX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IFtdXG4gICAgICB8IENvbnMoaGssIGMsIHJlc3QpIHdoZW4gaGtleSA9IGhrICAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgIHwgRVRydWUgLT4gYmVnaW4gbWF0Y2ggSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgICBmaW5kX2luX2J1Y2tldCByZXN0XG4gICAgICAgICAgICAgIHwgU29tZSBkIC0+IGQ6OmZpbmRfaW5fYnVja2V0IHJlc3RcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIHwgRUZhbHNlIC0+IGZpbmRfaW5fYnVja2V0IHJlc3RcbiAgICAgICAgICB8IEVEZWFkIC0+XG4gICAgICAgICAgICAgIGZpbmRfaW5fYnVja2V0IHJlc3RcbiAgICAgICAgICBlbmRcbiAgICAgIHwgQ29ucyhfLCBfLCByZXN0KSAtPlxuICAgICAgICAgIGZpbmRfaW5fYnVja2V0IHJlc3QgaW5cbiAgICAgIGZpbmRfaW5fYnVja2V0IGguZGF0YS4oa2V5X2luZGV4IGggaGtleSlcblxuXG4gICAgbGV0IHJlcGxhY2UgaCBrZXkgaW5mbyA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICBsZXQgcmVjIHJlcGxhY2VfYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgICAgfCBDb25zKGhrLCBjLCBuZXh0KSB3aGVuIGhrZXkgPSBoayAtPlxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgICB8IEVUcnVlIC0+IEguc2V0X2tleV9kYXRhIGMga2V5IGluZm9cbiAgICAgICAgICAgIHwgRUZhbHNlIHwgRURlYWQgLT4gcmVwbGFjZV9idWNrZXQgbmV4dFxuICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgQ29ucyhfLF8sbmV4dCkgLT4gcmVwbGFjZV9idWNrZXQgbmV4dFxuICAgICAgaW5cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGggaGtleSBpblxuICAgICAgbGV0IGwgPSBoLmRhdGEuKGkpIGluXG4gICAgICB0cnlcbiAgICAgICAgcmVwbGFjZV9idWNrZXQgbFxuICAgICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgICAgbGV0IGNvbnRhaW5lciA9IEguY3JlYXRlIGtleSBpbmZvIGluXG4gICAgICAgIGguZGF0YS4oaSkgPC0gQ29ucyhoa2V5LCBjb250YWluZXIsIGwpO1xuICAgICAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICAgICAgaWYgaC5zaXplID4gQXJyYXkubGVuZ3RoIGguZGF0YSBsc2wgMSB0aGVuIHJlc2l6ZSBoXG5cbiAgICBsZXQgbWVtIGgga2V5ID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgIGxldCByZWMgbWVtX2luX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgZmFsc2VcbiAgICAgIHwgQ29ucyhoaywgYywgcmVzdCkgd2hlbiBoayA9IGhrZXkgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICB8IEVUcnVlIC0+IHRydWVcbiAgICAgICAgICB8IEVGYWxzZSB8IEVEZWFkIC0+IG1lbV9pbl9idWNrZXQgcmVzdFxuICAgICAgICAgIGVuZFxuICAgICAgfCBDb25zKF9oaywgX2MsIHJlc3QpIC0+IG1lbV9pbl9idWNrZXQgcmVzdCBpblxuICAgICAgbWVtX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGhrZXkpXG5cbiAgICBsZXQgaXRlciBmIGggPVxuICAgICAgbGV0IHJlYyBkb19idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgICAoKVxuICAgICAgICB8IENvbnMoXywgYywgcmVzdCkgLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIEguZ2V0X2tleSBjLCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgfCBOb25lLCBfIHwgXywgTm9uZSAtPiAoKVxuICAgICAgICAgICAgfCBTb21lIGssIFNvbWUgZCAtPiBmIGsgZFxuICAgICAgICAgICAgZW5kOyBkb19idWNrZXQgcmVzdCBpblxuICAgICAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgICAgZG9fYnVja2V0IGQuKGkpXG4gICAgICBkb25lXG5cbiAgICBsZXQgZm9sZCBmIGggaW5pdCA9XG4gICAgICBsZXQgcmVjIGRvX2J1Y2tldCBiIGFjY3UgPVxuICAgICAgICBtYXRjaCBiIHdpdGhcbiAgICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgICAgYWNjdVxuICAgICAgICB8IENvbnMoXywgYywgcmVzdCkgLT5cbiAgICAgICAgICAgIGxldCBhY2N1ID0gYmVnaW4gbWF0Y2ggSC5nZXRfa2V5IGMsIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSwgXyB8IF8sIE5vbmUgLT4gYWNjdVxuICAgICAgICAgICAgICB8IFNvbWUgaywgU29tZSBkIC0+IGYgayBkIGFjY3VcbiAgICAgICAgICAgIGVuZCBpblxuICAgICAgICAgICAgZG9fYnVja2V0IHJlc3QgYWNjdSAgaW5cbiAgICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgICBsZXQgYWNjdSA9IHJlZiBpbml0IGluXG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICAgIGFjY3UgOj0gZG9fYnVja2V0IGQuKGkpICFhY2N1XG4gICAgICBkb25lO1xuICAgICAgIWFjY3VcblxuICAgIGxldCBmaWx0ZXJfbWFwX2lucGxhY2UgZiBoID1cbiAgICAgIGxldCByZWMgZG9fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgICAgRW1wdHlcbiAgICAgICAgfCBDb25zKGhrLCBjLCByZXN0KSAtPlxuICAgICAgICAgICAgbWF0Y2ggSC5nZXRfa2V5IGMsIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUsIF8gfCBfLCBOb25lIC0+XG4gICAgICAgICAgICAgICAgZG9fYnVja2V0IHJlc3RcbiAgICAgICAgICAgIHwgU29tZSBrLCBTb21lIGQgLT5cbiAgICAgICAgICAgICAgICBtYXRjaCBmIGsgZCB3aXRoXG4gICAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgICAgIGRvX2J1Y2tldCByZXN0XG4gICAgICAgICAgICAgICAgfCBTb21lIG5ld19kIC0+XG4gICAgICAgICAgICAgICAgICAgIEguc2V0X2tleV9kYXRhIGMgayBuZXdfZDtcbiAgICAgICAgICAgICAgICAgICAgQ29ucyhoaywgYywgZG9fYnVja2V0IHJlc3QpXG4gICAgICBpblxuICAgICAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgICAgZC4oaSkgPC0gZG9fYnVja2V0IGQuKGkpXG4gICAgICBkb25lXG5cbiAgICBsZXQgbGVuZ3RoIGggPSBoLnNpemVcblxuICAgIGxldCByZWMgYnVja2V0X2xlbmd0aCBhY2N1ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+IGJ1Y2tldF9sZW5ndGggKGFjY3UgKyAxKSByZXN0XG5cbiAgICBsZXQgc3RhdHMgaCA9XG4gICAgICBsZXQgbWJsID1cbiAgICAgICAgQXJyYXkuZm9sZF9sZWZ0IChmdW4gbSBiIC0+IG1heCBtIChidWNrZXRfbGVuZ3RoIDAgYikpIDAgaC5kYXRhIGluXG4gICAgICBsZXQgaGlzdG8gPSBBcnJheS5tYWtlIChtYmwgKyAxKSAwIGluXG4gICAgICBBcnJheS5pdGVyXG4gICAgICAgIChmdW4gYiAtPlxuICAgICAgICAgICBsZXQgbCA9IGJ1Y2tldF9sZW5ndGggMCBiIGluXG4gICAgICAgICAgIGhpc3RvLihsKSA8LSBoaXN0by4obCkgKyAxKVxuICAgICAgICBoLmRhdGE7XG4gICAgICB7IEhhc2h0YmwubnVtX2JpbmRpbmdzID0gaC5zaXplO1xuICAgICAgICBudW1fYnVja2V0cyA9IEFycmF5Lmxlbmd0aCBoLmRhdGE7XG4gICAgICAgIG1heF9idWNrZXRfbGVuZ3RoID0gbWJsO1xuICAgICAgICBidWNrZXRfaGlzdG9ncmFtID0gaGlzdG8gfVxuXG4gICAgbGV0IHJlYyBidWNrZXRfbGVuZ3RoX2FsaXZlIGFjY3UgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgICB8IENvbnMoXywgYywgcmVzdCkgd2hlbiBILmNoZWNrX2tleSBjIC0+XG4gICAgICAgICAgYnVja2V0X2xlbmd0aF9hbGl2ZSAoYWNjdSArIDEpIHJlc3RcbiAgICAgIHwgQ29ucyhfLCBfLCByZXN0KSAtPiBidWNrZXRfbGVuZ3RoX2FsaXZlIGFjY3UgcmVzdFxuXG4gICAgbGV0IHN0YXRzX2FsaXZlIGggPVxuICAgICAgbGV0IHNpemUgPSByZWYgMCBpblxuICAgICAgbGV0IG1ibCA9XG4gICAgICAgIEFycmF5LmZvbGRfbGVmdCAoZnVuIG0gYiAtPiBtYXggbSAoYnVja2V0X2xlbmd0aF9hbGl2ZSAwIGIpKSAwIGguZGF0YSBpblxuICAgICAgbGV0IGhpc3RvID0gQXJyYXkubWFrZSAobWJsICsgMSkgMCBpblxuICAgICAgQXJyYXkuaXRlclxuICAgICAgICAoZnVuIGIgLT5cbiAgICAgICAgICAgbGV0IGwgPSBidWNrZXRfbGVuZ3RoX2FsaXZlIDAgYiBpblxuICAgICAgICAgICBzaXplIDo9ICFzaXplICsgbDtcbiAgICAgICAgICAgaGlzdG8uKGwpIDwtIGhpc3RvLihsKSArIDEpXG4gICAgICAgIGguZGF0YTtcbiAgICAgIHsgSGFzaHRibC5udW1fYmluZGluZ3MgPSAhc2l6ZTtcbiAgICAgICAgbnVtX2J1Y2tldHMgPSBBcnJheS5sZW5ndGggaC5kYXRhO1xuICAgICAgICBtYXhfYnVja2V0X2xlbmd0aCA9IG1ibDtcbiAgICAgICAgYnVja2V0X2hpc3RvZ3JhbSA9IGhpc3RvIH1cblxuXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBPYmpFcGggPSBPYmouRXBoZW1lcm9uXG5cbmxldCBfb2JqX29wdCA6IE9iai50IG9wdGlvbiAtPiAnYSBvcHRpb24gPSBmdW4geCAtPlxuICBtYXRjaCB4IHdpdGhcbiAgfCBOb25lIC0+IHhcbiAgfCBTb21lIHYgLT4gU29tZSAoT2JqLm9iaiB2KVxuXG4oKiogVGhlIHByZXZpb3VzIGZ1bmN0aW9uIGlzIHR5cGVkIHNvIHRoaXMgb25lIGlzIGFsc28gY29ycmVjdCAqKVxubGV0IG9ial9vcHQgOiBPYmoudCBvcHRpb24gLT4gJ2Egb3B0aW9uID0gZnVuIHggLT4gT2JqLm1hZ2ljIHhcblxuXG5tb2R1bGUgSzEgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2ssJ2QpIHQgPSBPYmpFcGgudFxuXG4gIGxldCBjcmVhdGUgKCkgOiAoJ2ssJ2QpIHQgPSBPYmpFcGguY3JlYXRlIDFcblxuICBsZXQgZ2V0X2tleSAodDooJ2ssJ2QpIHQpIDogJ2sgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9rZXkgdCAwKVxuICBsZXQgZ2V0X2tleV9jb3B5ICh0OignaywnZCkgdCkgOiAnayBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2tleV9jb3B5IHQgMClcbiAgbGV0IHNldF9rZXkgKHQ6KCdrLCdkKSB0KSAoazonaykgOiB1bml0ID0gT2JqRXBoLnNldF9rZXkgdCAwIChPYmoucmVwciBrKVxuICBsZXQgdW5zZXRfa2V5ICh0OignaywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2tleSB0IDBcbiAgbGV0IGNoZWNrX2tleSAodDooJ2ssJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19rZXkgdCAwXG5cbiAgbGV0IGJsaXRfa2V5ICh0MTooJ2ssJ2QpIHQpICh0MjooJ2ssJ2QpIHQpOiB1bml0ID1cbiAgICBPYmpFcGguYmxpdF9rZXkgdDEgMCB0MiAwIDFcblxuICBsZXQgZ2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSA6ICdkIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfZGF0YSB0KVxuICBsZXQgZ2V0X2RhdGFfY29weSAodDooJ2ssJ2QpIHQpIDogJ2Qgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhX2NvcHkgdClcbiAgbGV0IHNldF9kYXRhICh0OignaywnZCkgdCkgKGQ6J2QpIDogdW5pdCA9IE9iakVwaC5zZXRfZGF0YSB0IChPYmoucmVwciBkKVxuICBsZXQgdW5zZXRfZGF0YSAodDooJ2ssJ2QpIHQpIDogdW5pdCA9IE9iakVwaC51bnNldF9kYXRhIHRcbiAgbGV0IGNoZWNrX2RhdGEgKHQ6KCdrLCdkKSB0KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfZGF0YSB0XG4gIGxldCBibGl0X2RhdGEgKHQxOihfLCdkKSB0KSAodDI6KF8sJ2QpIHQpIDogdW5pdCA9IE9iakVwaC5ibGl0X2RhdGEgdDEgdDJcblxuICBtb2R1bGUgTWFrZVNlZWRlZCAoSDpIYXNodGJsLlNlZWRlZEhhc2hlZFR5cGUpID1cbiAgICBHZW5IYXNoVGFibGUuTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgY29udGFpbmVyID0gKEgudCwnYSkgdFxuICAgICAgdHlwZSB0ID0gSC50XG4gICAgICBsZXQgY3JlYXRlIGsgZCA9XG4gICAgICAgIGxldCBjID0gY3JlYXRlICgpIGluXG4gICAgICAgIHNldF9kYXRhIGMgZDtcbiAgICAgICAgc2V0X2tleSBjIGs7XG4gICAgICAgIGNcbiAgICAgIGxldCBoYXNoID0gSC5oYXNoXG4gICAgICBsZXQgZXF1YWwgYyBrID1cbiAgICAgICAgKCogeyFnZXRfa2V5X2NvcHl9IGlzIG5vdCB1c2VkIGJlY2F1c2UgdGhlIGVxdWFsaXR5IG9mIHRoZSB1c2VyIGNhbiBiZVxuICAgICAgICAgICAgdGhlIHBoeXNpY2FsIGVxdWFsaXR5ICopXG4gICAgICAgIG1hdGNoIGdldF9rZXkgYyB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBHZW5IYXNoVGFibGUuRURlYWRcbiAgICAgICAgfCBTb21lIGsnIC0+XG4gICAgICAgICAgICBpZiBILmVxdWFsIGsgaycgdGhlbiBHZW5IYXNoVGFibGUuRVRydWUgZWxzZSBHZW5IYXNoVGFibGUuRUZhbHNlXG4gICAgICBsZXQgZ2V0X2RhdGEgPSBnZXRfZGF0YVxuICAgICAgbGV0IGdldF9rZXkgPSBnZXRfa2V5XG4gICAgICBsZXQgc2V0X2tleV9kYXRhIGMgayBkID1cbiAgICAgICAgdW5zZXRfZGF0YSBjO1xuICAgICAgICBzZXRfa2V5IGMgaztcbiAgICAgICAgc2V0X2RhdGEgYyBkXG4gICAgICBsZXQgY2hlY2tfa2V5ID0gY2hlY2tfa2V5XG4gICAgZW5kKVxuXG4gIG1vZHVsZSBNYWtlKEg6IEhhc2h0YmwuSGFzaGVkVHlwZSk6IChTIHdpdGggdHlwZSBrZXkgPSBILnQpID1cbiAgc3RydWN0XG4gICAgaW5jbHVkZSBNYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBILnRcbiAgICAgICAgbGV0IGVxdWFsID0gSC5lcXVhbFxuICAgICAgICBsZXQgaGFzaCAoX3NlZWQ6IGludCkgeCA9IEguaGFzaCB4XG4gICAgICBlbmQpXG4gICAgbGV0IGNyZWF0ZSBzeiA9IGNyZWF0ZSB+cmFuZG9tOmZhbHNlIHN6XG4gIGVuZFxuXG5lbmRcblxubW9kdWxlIEsyID0gc3RydWN0XG4gIHR5cGUgKCdrMSwgJ2syLCAnZCkgdCA9IE9iakVwaC50XG5cbiAgbGV0IGNyZWF0ZSAoKSA6ICgnazEsJ2syLCdkKSB0ID0gT2JqRXBoLmNyZWF0ZSAyXG5cbiAgbGV0IGdldF9rZXkxICh0OignazEsJ2syLCdkKSB0KSA6ICdrMSBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2tleSB0IDApXG4gIGxldCBnZXRfa2V5MV9jb3B5ICh0OignazEsJ2syLCdkKSB0KSA6ICdrMSBvcHRpb24gPVxuICAgIG9ial9vcHQgKE9iakVwaC5nZXRfa2V5X2NvcHkgdCAwKVxuICBsZXQgc2V0X2tleTEgKHQ6KCdrMSwnazIsJ2QpIHQpIChrOidrMSkgOiB1bml0ID1cbiAgICBPYmpFcGguc2V0X2tleSB0IDAgKE9iai5yZXByIGspXG4gIGxldCB1bnNldF9rZXkxICh0OignazEsJ2syLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfa2V5IHQgMFxuICBsZXQgY2hlY2tfa2V5MSAodDooJ2sxLCdrMiwnZCkgdCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2tleSB0IDBcblxuICBsZXQgZ2V0X2tleTIgKHQ6KCdrMSwnazIsJ2QpIHQpIDogJ2syIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfa2V5IHQgMSlcbiAgbGV0IGdldF9rZXkyX2NvcHkgKHQ6KCdrMSwnazIsJ2QpIHQpIDogJ2syIG9wdGlvbiA9XG4gICAgb2JqX29wdCAoT2JqRXBoLmdldF9rZXlfY29weSB0IDEpXG4gIGxldCBzZXRfa2V5MiAodDooJ2sxLCdrMiwnZCkgdCkgKGs6J2syKSA6IHVuaXQgPVxuICAgIE9iakVwaC5zZXRfa2V5IHQgMSAoT2JqLnJlcHIgaylcbiAgbGV0IHVuc2V0X2tleTIgKHQ6KCdrMSwnazIsJ2QpIHQpIDogdW5pdCA9IE9iakVwaC51bnNldF9rZXkgdCAxXG4gIGxldCBjaGVja19rZXkyICh0OignazEsJ2syLCdkKSB0KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfa2V5IHQgMVxuXG5cbiAgbGV0IGJsaXRfa2V5MSAodDE6KCdrMSxfLF8pIHQpICh0MjooJ2sxLF8sXykgdCkgOiB1bml0ID1cbiAgICBPYmpFcGguYmxpdF9rZXkgdDEgMCB0MiAwIDFcbiAgbGV0IGJsaXRfa2V5MiAodDE6KF8sJ2syLF8pIHQpICh0MjooXywnazIsXykgdCkgOiB1bml0ID1cbiAgICBPYmpFcGguYmxpdF9rZXkgdDEgMSB0MiAxIDFcbiAgbGV0IGJsaXRfa2V5MTIgKHQxOignazEsJ2syLF8pIHQpICh0MjooJ2sxLCdrMixfKSB0KSA6IHVuaXQgPVxuICAgIE9iakVwaC5ibGl0X2tleSB0MSAwIHQyIDAgMlxuXG4gIGxldCBnZXRfZGF0YSAodDooJ2sxLCdrMiwnZCkgdCkgOiAnZCBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2RhdGEgdClcbiAgbGV0IGdldF9kYXRhX2NvcHkgKHQ6KCdrMSwnazIsJ2QpIHQpIDogJ2Qgb3B0aW9uID1cbiAgICBvYmpfb3B0IChPYmpFcGguZ2V0X2RhdGFfY29weSB0KVxuICBsZXQgc2V0X2RhdGEgKHQ6KCdrMSwnazIsJ2QpIHQpIChkOidkKSA6IHVuaXQgPVxuICAgIE9iakVwaC5zZXRfZGF0YSB0IChPYmoucmVwciBkKVxuICBsZXQgdW5zZXRfZGF0YSAodDooJ2sxLCdrMiwnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2RhdGEgdFxuICBsZXQgY2hlY2tfZGF0YSAodDooJ2sxLCdrMiwnZCkgdCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2RhdGEgdFxuICBsZXQgYmxpdF9kYXRhICh0MTooXyxfLCdkKSB0KSAodDI6KF8sXywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLmJsaXRfZGF0YSB0MSB0MlxuXG4gIG1vZHVsZSBNYWtlU2VlZGVkXG4gICAgICAoSDE6SGFzaHRibC5TZWVkZWRIYXNoZWRUeXBlKVxuICAgICAgKEgyOkhhc2h0YmwuU2VlZGVkSGFzaGVkVHlwZSkgPVxuICAgIEdlbkhhc2hUYWJsZS5NYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgdHlwZSAnYSBjb250YWluZXIgPSAoSDEudCxIMi50LCdhKSB0XG4gICAgICB0eXBlIHQgPSBIMS50ICogSDIudFxuICAgICAgbGV0IGNyZWF0ZSAoazEsazIpIGQgPVxuICAgICAgICBsZXQgYyA9IGNyZWF0ZSAoKSBpblxuICAgICAgICBzZXRfZGF0YSBjIGQ7XG4gICAgICAgIHNldF9rZXkxIGMgazE7IHNldF9rZXkyIGMgazI7XG4gICAgICAgIGNcbiAgICAgIGxldCBoYXNoIHNlZWQgKGsxLGsyKSA9XG4gICAgICAgIEgxLmhhc2ggc2VlZCBrMSArIEgyLmhhc2ggc2VlZCBrMiAqIDY1NTk5XG4gICAgICBsZXQgZXF1YWwgYyAoazEsazIpID1cbiAgICAgICAgbWF0Y2ggZ2V0X2tleTEgYywgZ2V0X2tleTIgYyB3aXRoXG4gICAgICAgIHwgTm9uZSwgXyB8IF8gLCBOb25lIC0+IEdlbkhhc2hUYWJsZS5FRGVhZFxuICAgICAgICB8IFNvbWUgazEnLCBTb21lIGsyJyAtPlxuICAgICAgICAgICAgaWYgSDEuZXF1YWwgazEgazEnICYmIEgyLmVxdWFsIGsyIGsyJ1xuICAgICAgICAgICAgdGhlbiBHZW5IYXNoVGFibGUuRVRydWUgZWxzZSBHZW5IYXNoVGFibGUuRUZhbHNlXG4gICAgICBsZXQgZ2V0X2RhdGEgPSBnZXRfZGF0YVxuICAgICAgbGV0IGdldF9rZXkgYyA9XG4gICAgICAgIG1hdGNoIGdldF9rZXkxIGMsIGdldF9rZXkyIGMgd2l0aFxuICAgICAgICB8IE5vbmUsIF8gfCBfICwgTm9uZSAtPiBOb25lXG4gICAgICAgIHwgU29tZSBrMScsIFNvbWUgazInIC0+IFNvbWUgKGsxJywgazInKVxuICAgICAgbGV0IHNldF9rZXlfZGF0YSBjIChrMSxrMikgZCA9XG4gICAgICAgIHVuc2V0X2RhdGEgYztcbiAgICAgICAgc2V0X2tleTEgYyBrMTsgc2V0X2tleTIgYyBrMjtcbiAgICAgICAgc2V0X2RhdGEgYyBkXG4gICAgICBsZXQgY2hlY2tfa2V5IGMgPSBjaGVja19rZXkxIGMgJiYgY2hlY2tfa2V5MiBjXG4gICAgZW5kKVxuXG4gIG1vZHVsZSBNYWtlKEgxOiBIYXNodGJsLkhhc2hlZFR5cGUpKEgyOiBIYXNodGJsLkhhc2hlZFR5cGUpOlxuICAgIChTIHdpdGggdHlwZSBrZXkgPSBIMS50ICogSDIudCkgPVxuICBzdHJ1Y3RcbiAgICBpbmNsdWRlIE1ha2VTZWVkZWRcbiAgICAgICAgKHN0cnVjdFxuICAgICAgICAgIHR5cGUgdCA9IEgxLnRcbiAgICAgICAgICBsZXQgZXF1YWwgPSBIMS5lcXVhbFxuICAgICAgICAgIGxldCBoYXNoIChfc2VlZDogaW50KSB4ID0gSDEuaGFzaCB4XG4gICAgICAgIGVuZClcbiAgICAgICAgKHN0cnVjdFxuICAgICAgICAgIHR5cGUgdCA9IEgyLnRcbiAgICAgICAgICBsZXQgZXF1YWwgPSBIMi5lcXVhbFxuICAgICAgICAgIGxldCBoYXNoIChfc2VlZDogaW50KSB4ID0gSDIuaGFzaCB4XG4gICAgICAgIGVuZClcbiAgICBsZXQgY3JlYXRlIHN6ID0gY3JlYXRlIH5yYW5kb206ZmFsc2Ugc3pcbiAgZW5kXG5cbmVuZFxuXG5tb2R1bGUgS24gPSBzdHJ1Y3RcbiAgdHlwZSAoJ2ssJ2QpIHQgPSBPYmpFcGgudFxuXG4gIGxldCBjcmVhdGUgbiA6ICgnaywnZCkgdCA9IE9iakVwaC5jcmVhdGUgblxuICBsZXQgbGVuZ3RoIChrOignaywnZCkgdCkgOiBpbnQgPSBPYmpFcGgubGVuZ3RoIGtcblxuICBsZXQgZ2V0X2tleSAodDooJ2ssJ2QpIHQpIChuOmludCkgOiAnayBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2tleSB0IG4pXG4gIGxldCBnZXRfa2V5X2NvcHkgKHQ6KCdrLCdkKSB0KSAobjppbnQpIDogJ2sgb3B0aW9uID1cbiAgICBvYmpfb3B0IChPYmpFcGguZ2V0X2tleV9jb3B5IHQgbilcbiAgbGV0IHNldF9rZXkgKHQ6KCdrLCdkKSB0KSAobjppbnQpIChrOidrKSA6IHVuaXQgPVxuICAgIE9iakVwaC5zZXRfa2V5IHQgbiAoT2JqLnJlcHIgaylcbiAgbGV0IHVuc2V0X2tleSAodDooJ2ssJ2QpIHQpIChuOmludCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2tleSB0IG5cbiAgbGV0IGNoZWNrX2tleSAodDooJ2ssJ2QpIHQpIChuOmludCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2tleSB0IG5cblxuICBsZXQgYmxpdF9rZXkgKHQxOignaywnZCkgdCkgKG8xOmludCkgKHQyOignaywnZCkgdCkgKG8yOmludCkgKGw6aW50KSA6IHVuaXQgPVxuICAgIE9iakVwaC5ibGl0X2tleSB0MSBvMSB0MiBvMiBsXG5cbiAgbGV0IGdldF9kYXRhICh0OignaywnZCkgdCkgOiAnZCBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2RhdGEgdClcbiAgbGV0IGdldF9kYXRhX2NvcHkgKHQ6KCdrLCdkKSB0KSA6ICdkIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfZGF0YV9jb3B5IHQpXG4gIGxldCBzZXRfZGF0YSAodDooJ2ssJ2QpIHQpIChkOidkKSA6IHVuaXQgPSBPYmpFcGguc2V0X2RhdGEgdCAoT2JqLnJlcHIgZClcbiAgbGV0IHVuc2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfZGF0YSB0XG4gIGxldCBjaGVja19kYXRhICh0OignaywnZCkgdCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2RhdGEgdFxuICBsZXQgYmxpdF9kYXRhICh0MTooXywnZCkgdCkgKHQyOihfLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGguYmxpdF9kYXRhIHQxIHQyXG5cbiAgbW9kdWxlIE1ha2VTZWVkZWQgKEg6SGFzaHRibC5TZWVkZWRIYXNoZWRUeXBlKSA9XG4gICAgR2VuSGFzaFRhYmxlLk1ha2VTZWVkZWQoc3RydWN0XG4gICAgICB0eXBlICdhIGNvbnRhaW5lciA9IChILnQsJ2EpIHRcbiAgICAgIHR5cGUgdCA9IEgudCBhcnJheVxuICAgICAgbGV0IGNyZWF0ZSBrIGQgPVxuICAgICAgICBsZXQgYyA9IGNyZWF0ZSAoQXJyYXkubGVuZ3RoIGspIGluXG4gICAgICAgIHNldF9kYXRhIGMgZDtcbiAgICAgICAgZm9yIGk9MCB0byBBcnJheS5sZW5ndGggayAtMSBkb1xuICAgICAgICAgIHNldF9rZXkgYyBpIGsuKGkpO1xuICAgICAgICBkb25lO1xuICAgICAgICBjXG4gICAgICBsZXQgaGFzaCBzZWVkIGsgPVxuICAgICAgICBsZXQgaCA9IHJlZiAwIGluXG4gICAgICAgIGZvciBpPTAgdG8gQXJyYXkubGVuZ3RoIGsgLTEgZG9cbiAgICAgICAgICBoIDo9IEguaGFzaCBzZWVkIGsuKGkpICogNjU1OTkgKyAhaDtcbiAgICAgICAgZG9uZTtcbiAgICAgICAgIWhcbiAgICAgIGxldCBlcXVhbCBjIGsgPVxuICAgICAgICBsZXQgbGVuICA9IEFycmF5Lmxlbmd0aCBrIGluXG4gICAgICAgIGxldCBsZW4nID0gbGVuZ3RoIGMgaW5cbiAgICAgICAgaWYgbGVuICE9IGxlbicgdGhlbiBHZW5IYXNoVGFibGUuRUZhbHNlXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsZXQgcmVjIGVxdWFsX2FycmF5IGsgYyBpID1cbiAgICAgICAgICAgIGlmIGkgPCAwIHRoZW4gR2VuSGFzaFRhYmxlLkVUcnVlXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIG1hdGNoIGdldF9rZXkgYyBpIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+IEdlbkhhc2hUYWJsZS5FRGVhZFxuICAgICAgICAgICAgICB8IFNvbWUga2kgLT5cbiAgICAgICAgICAgICAgICAgIGlmIEguZXF1YWwgay4oaSkga2lcbiAgICAgICAgICAgICAgICAgIHRoZW4gZXF1YWxfYXJyYXkgayBjIChpLTEpXG4gICAgICAgICAgICAgICAgICBlbHNlIEdlbkhhc2hUYWJsZS5FRmFsc2VcbiAgICAgICAgICBpblxuICAgICAgICAgIGVxdWFsX2FycmF5IGsgYyAobGVuLTEpXG4gICAgICBsZXQgZ2V0X2RhdGEgPSBnZXRfZGF0YVxuICAgICAgbGV0IGdldF9rZXkgYyA9XG4gICAgICAgIGxldCBsZW4gPSBsZW5ndGggYyBpblxuICAgICAgICBpZiBsZW4gPSAwIHRoZW4gU29tZSBbfHxdXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBtYXRjaCBnZXRfa2V5IGMgMCB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgICAgICB8IFNvbWUgazAgLT5cbiAgICAgICAgICAgICAgbGV0IHJlYyBmaWxsIGEgaSA9XG4gICAgICAgICAgICAgICAgaWYgaSA8IDEgdGhlbiBTb21lIGFcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICBtYXRjaCBnZXRfa2V5IGMgaSB3aXRoXG4gICAgICAgICAgICAgICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgICAgICAgICAgICAgfCBTb21lIGtpIC0+XG4gICAgICAgICAgICAgICAgICAgICAgYS4oaSkgPC0ga2k7XG4gICAgICAgICAgICAgICAgICAgICAgZmlsbCBhIChpLTEpXG4gICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgIGxldCBhID0gQXJyYXkubWFrZSBsZW4gazAgaW5cbiAgICAgICAgICAgICAgZmlsbCBhIChsZW4tMSlcbiAgICAgIGxldCBzZXRfa2V5X2RhdGEgYyBrIGQgPVxuICAgICAgICB1bnNldF9kYXRhIGM7XG4gICAgICAgIGZvciBpPTAgdG8gQXJyYXkubGVuZ3RoIGsgLTEgZG9cbiAgICAgICAgICBzZXRfa2V5IGMgaSBrLihpKTtcbiAgICAgICAgZG9uZTtcbiAgICAgICAgc2V0X2RhdGEgYyBkXG4gICAgICBsZXQgY2hlY2tfa2V5IGMgPVxuICAgICAgICBsZXQgcmVjIGNoZWNrIGMgaSA9XG4gICAgICAgICAgaSA8IDAgfHwgKGNoZWNrX2tleSBjIGkgJiYgY2hlY2sgYyAoaS0xKSkgaW5cbiAgICAgICAgY2hlY2sgYyAobGVuZ3RoIGMgLSAxKVxuICAgIGVuZClcblxuICBtb2R1bGUgTWFrZShIOiBIYXNodGJsLkhhc2hlZFR5cGUpOiAoUyB3aXRoIHR5cGUga2V5ID0gSC50IGFycmF5KSA9XG4gIHN0cnVjdFxuICAgIGluY2x1ZGUgTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gSC50XG4gICAgICAgIGxldCBlcXVhbCA9IEguZXF1YWxcbiAgICAgICAgbGV0IGhhc2ggKF9zZWVkOiBpbnQpIHggPSBILmhhc2ggeFxuICAgICAgZW5kKVxuICAgIGxldCBjcmVhdGUgc3ogPSBjcmVhdGUgfnJhbmRvbTpmYWxzZSBzelxuICBlbmRcbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgIE1hcmsgU2hpbndlbGwgYW5kIExlbyBXaGl0ZSwgSmFuZSBTdHJlZXQgRXVyb3BlICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNS0tMjAxNiBKYW5lIFN0cmVldCBHcm91cCBMTEMgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5leHRlcm5hbCBzcGFjZXRpbWVfZW5hYmxlZCA6IHVuaXQgLT4gYm9vbFxuICA9IFwiY2FtbF9zcGFjZXRpbWVfZW5hYmxlZFwiIFtAQG5vYWxsb2NdXG5cbmxldCBlbmFibGVkID0gc3BhY2V0aW1lX2VuYWJsZWQgKClcblxubGV0IGlmX3NwYWNldGltZV9lbmFibGVkIGYgPVxuICBpZiBlbmFibGVkIHRoZW4gZiAoKSBlbHNlICgpXG5cbm1vZHVsZSBTZXJpZXMgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0ge1xuICAgIGNoYW5uZWwgOiBvdXRfY2hhbm5lbDtcbiAgICBtdXRhYmxlIGNsb3NlZCA6IGJvb2w7XG4gIH1cblxuICBleHRlcm5hbCB3cml0ZV9tYWdpY19udW1iZXIgOiBvdXRfY2hhbm5lbCAtPiB1bml0XG4gICAgPSBcImNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlXCJcbiAgICAgIFwiY2FtbF9zcGFjZXRpbWVfd3JpdGVfbWFnaWNfbnVtYmVyXCJcblxuICBleHRlcm5hbCByZWdpc3Rlcl9jaGFubmVsX2Zvcl9zcGFjZXRpbWUgOiBvdXRfY2hhbm5lbCAtPiB1bml0XG4gICAgPSBcImNhbWxfcmVnaXN0ZXJfY2hhbm5lbF9mb3Jfc3BhY2V0aW1lXCJcblxuICBsZXQgY3JlYXRlIH5wYXRoID1cbiAgICBpZiBzcGFjZXRpbWVfZW5hYmxlZCAoKSB0aGVuIGJlZ2luXG4gICAgICBsZXQgY2hhbm5lbCA9IG9wZW5fb3V0IHBhdGggaW5cbiAgICAgIHJlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZSBjaGFubmVsO1xuICAgICAgbGV0IHQgPVxuICAgICAgICB7IGNoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgICAgIGNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICBpblxuICAgICAgd3JpdGVfbWFnaWNfbnVtYmVyIHQuY2hhbm5lbDtcbiAgICAgIHRcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgeyBjaGFubmVsID0gc3Rkb3V0OyAgKCogYXJiaXRyYXJ5IHZhbHVlICopXG4gICAgICAgIGNsb3NlZCA9IHRydWU7XG4gICAgICB9XG4gICAgZW5kXG5cbiAgZXh0ZXJuYWwgc2F2ZV9ldmVudCA6ID90aW1lOmZsb2F0IC0+IG91dF9jaGFubmVsIC0+IGV2ZW50X25hbWU6c3RyaW5nIC0+IHVuaXRcbiAgICA9IFwiY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGVcIlxuICAgICAgXCJjYW1sX3NwYWNldGltZV9zYXZlX2V2ZW50XCJcblxuICBsZXQgc2F2ZV9ldmVudCA/dGltZSB0IH5ldmVudF9uYW1lID1cbiAgICBpZl9zcGFjZXRpbWVfZW5hYmxlZCAoZnVuICgpIC0+XG4gICAgICBzYXZlX2V2ZW50ID90aW1lIHQuY2hhbm5lbCB+ZXZlbnRfbmFtZSlcblxuICBleHRlcm5hbCBzYXZlX3RyaWUgOiA/dGltZTpmbG9hdCAtPiBvdXRfY2hhbm5lbCAtPiB1bml0XG4gICAgPSBcImNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlXCJcbiAgICAgIFwiY2FtbF9zcGFjZXRpbWVfc2F2ZV90cmllXCJcblxuICBsZXQgc2F2ZV9hbmRfY2xvc2UgP3RpbWUgdCA9XG4gICAgaWZfc3BhY2V0aW1lX2VuYWJsZWQgKGZ1biAoKSAtPlxuICAgICAgaWYgdC5jbG9zZWQgdGhlbiBmYWlsd2l0aCBcIlNlcmllcyBpcyBjbG9zZWRcIjtcbiAgICAgIHNhdmVfdHJpZSA/dGltZSB0LmNoYW5uZWw7XG4gICAgICBjbG9zZV9vdXQgdC5jaGFubmVsO1xuICAgICAgdC5jbG9zZWQgPC0gdHJ1ZSlcbmVuZFxuXG5tb2R1bGUgU25hcHNob3QgPSBzdHJ1Y3RcbiAgZXh0ZXJuYWwgdGFrZSA6ID90aW1lOmZsb2F0IC0+IG91dF9jaGFubmVsIC0+IHVuaXRcbiAgICA9IFwiY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGVcIlxuICAgICAgXCJjYW1sX3NwYWNldGltZV90YWtlX3NuYXBzaG90XCJcblxuICBsZXQgdGFrZSA/dGltZSB7IFNlcmllcy5jbG9zZWQ7IGNoYW5uZWwgfSA9XG4gICAgaWZfc3BhY2V0aW1lX2VuYWJsZWQgKGZ1biAoKSAtPlxuICAgICAgaWYgY2xvc2VkIHRoZW4gZmFpbHdpdGggXCJTZXJpZXMgaXMgY2xvc2VkXCI7XG4gICAgICBHYy5taW5vciAoKTtcbiAgICAgIHRha2UgP3RpbWUgY2hhbm5lbClcbmVuZFxuXG5leHRlcm5hbCBzYXZlX2V2ZW50X2Zvcl9hdXRvbWF0aWNfc25hcHNob3RzIDogZXZlbnRfbmFtZTpzdHJpbmcgLT4gdW5pdFxuICA9IFwiY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGVcIlxuICAgIFwiY2FtbF9zcGFjZXRpbWVfc2F2ZV9ldmVudF9mb3JfYXV0b21hdGljX3NuYXBzaG90c1wiXG5cbmxldCBzYXZlX2V2ZW50X2Zvcl9hdXRvbWF0aWNfc25hcHNob3RzIH5ldmVudF9uYW1lID1cbiAgaWZfc3BhY2V0aW1lX2VuYWJsZWQgKGZ1biAoKSAtPlxuICAgIHNhdmVfZXZlbnRfZm9yX2F1dG9tYXRpY19zbmFwc2hvdHMgfmV2ZW50X25hbWUpXG4iLCJvcGVuIExleGluZ1xuKCogQXV0aG9yOiBTdGV2ZSBaZGFuY2V3aWMgKilcblxudHlwZSBwb3MgPSBpbnQgKiBpbnQgICAgKCogTGluZSBudW1iZXIgYW5kIGNvbHVtbiAqKVxudHlwZSB0ID0gc3RyaW5nICogcG9zICogcG9zXG5cbmxldCBsaW5lX29mX3BvcyAobCxfKSA9IGxcbmxldCBjb2xfb2ZfcG9zIChfLGMpID0gY1xubGV0IG1rX3BvcyBsaW5lIGNvbCA9IChsaW5lLCBjb2wpXG5cbmxldCBmaWxlX29mX3JhbmdlIChmLF8sXykgPSBmXG5sZXQgc3RhcnRfb2ZfcmFuZ2UgKF8scyxfKSA9IHNcbmxldCBlbmRfb2ZfcmFuZ2UgKF8sXyxlKSA9IGVcbmxldCBta19yYW5nZSBmIHMgZSA9IChmLHMsZSlcbmxldCB2YWxpZF9wb3MgKGwsYykgPSBsID49IDAgJiYgYyA+PTBcblxubGV0IG1lcmdlX3JhbmdlICgoZixzMSxlMSkgYXMgcjEpICgoZicsczIsZTIpIGFzIHIyKSA9XG4gIGlmIGYgPD4gZicgdGhlbiBmYWlsd2l0aCBAQCBQcmludGYuc3ByaW50ZiBcIm1lcmdlX3JhbmdlIGNhbGxlZCBvbiBkaWZmZXJlbnQgZmlsZXM6ICVzIGFuZCAlc1wiIGYgZidcbiAgZWxzZVxuICBpZiBub3QgKHZhbGlkX3BvcyBzMSkgdGhlbiByMiBlbHNlXG4gIGlmIG5vdCAodmFsaWRfcG9zIHMyKSB0aGVuIHIxIGVsc2VcbiAgbWtfcmFuZ2UgZiAobWluIHMxIHMyKSAobWF4IGUxIGUyKVxuXG5sZXQgc3RyaW5nX29mX3JhbmdlIChmLChzbCxzYyksKGVsLGVjKSkgPVxuICBQcmludGYuc3ByaW50ZiBcIiVzOlslZC4lZC0lZC4lZF1cIiBmIHNsIHNjIGVsIGVjXG5cbmxldCBtbF9zdHJpbmdfb2ZfcmFuZ2UgKGYsKHNsLHNjKSwoZWwsZWMpKSA9XG4gIFByaW50Zi5zcHJpbnRmIFwiKFxcXCIlc1xcXCIsICglZCwgJWQpLCAoJWQsICVkKSlcIiBmIHNsIHNjIGVsIGVjXG5cbmxldCBub3JhbmdlID0gKFwiX19pbnRlcm5hbFwiLCAoMCwwKSwgKDAsMCkpXG5cbigqIENyZWF0ZXMgYSBSYW5nZS5wb3MgZnJvbSB0aGUgTGV4aW5nLnBvc2l0aW9uIGRhdGEgKilcbmxldCBwb3Nfb2ZfbGV4cG9zIChwOnBvc2l0aW9uKSA6IHBvcyA9XG4gIG1rX3BvcyAocC5wb3NfbG51bSkgKHAucG9zX2NudW0gLSBwLnBvc19ib2wpXG5cbmxldCBta19sZXhfcmFuZ2UgKHAxOnBvc2l0aW9uKSAocDI6cG9zaXRpb24pIDogdCA9XG4gIG1rX3JhbmdlIHAxLnBvc19mbmFtZSAocG9zX29mX2xleHBvcyBwMSkgKHBvc19vZl9sZXhwb3MgcDIpXG5cbigqIEV4cG9zZSB0aGUgbGV4ZXIgc3RhdGUgYXMgYSBSYW5nZS50IHZhbHVlICopXG5sZXQgbGV4X3JhbmdlIGxleGJ1ZiA6IHQgPSBcbiAgbWtfbGV4X3JhbmdlIChsZXhlbWVfc3RhcnRfcCBsZXhidWYpIChsZXhlbWVfZW5kX3AgbGV4YnVmKVxuICAgIFxuIiwiXG50eXBlICdhIG5vZGUgPSB7IGVsdCA6ICdhOyBsb2MgOiBSYW5nZS50IH1cblxuKCoqIHZhbCBub19sb2MgOiAnYTEgLT4gJ2ExIG5vZGUgKiopXG5cbmxldCBub19sb2MgeCA9XG4gIHsgZWx0ID0geDsgbG9jID0gUmFuZ2Uubm9yYW5nZSB9XG5cbnR5cGUgaWQgPSBzdHJpbmdcblxudHlwZSB0eSA9XG58IFRCb29sXG58IFRJbnRcbnwgVFJlZiBvZiBydHlcbmFuZCBydHkgPVxufCBSU3RyaW5nXG58IFJBcnJheSBvZiB0eVxufCBSRnVuIG9mIHR5IGxpc3QgKiByZXRfdHlcbmFuZCByZXRfdHkgPVxufCBSZXRWb2lkXG58IFJldFZhbCBvZiB0eVxuXG50eXBlIHVub3AgPVxufCBOZWdcbnwgTG9nbm90XG58IEJpdG5vdFxuXG50eXBlIGJpbm9wID1cbnwgQWRkXG58IFN1YlxufCBNdWxcbnwgRXFcbnwgTmVxXG58IEx0XG58IEx0ZVxufCBHdFxufCBHdGVcbnwgQW5kXG58IE9yXG58IElBbmRcbnwgSU9yXG58IFNobFxufCBTaHJcbnwgU2FyXG5cbnR5cGUgZXhwID1cbnwgQ051bGwgb2YgcnR5XG58IENCb29sIG9mIGJvb2xcbnwgQ0ludCBvZiBpbnQ2NFxufCBDU3RyIG9mIHN0cmluZ1xufCBDQXJyIG9mIHR5ICogZXhwIG5vZGUgbGlzdFxufCBOZXdBcnIgb2YgdHkgKiBleHAgbm9kZVxufCBJZCBvZiBpZFxufCBJbmRleCBvZiBleHAgbm9kZSAqIGV4cCBub2RlXG58IENhbGwgb2YgZXhwIG5vZGUgKiBleHAgbm9kZSBsaXN0XG58IEJvcCBvZiBiaW5vcCAqIGV4cCBub2RlICogZXhwIG5vZGVcbnwgVW9wIG9mIHVub3AgKiBleHAgbm9kZVxuXG50eXBlIGNmaWVsZCA9IGlkICogZXhwIG5vZGVcblxudHlwZSB2ZGVjbCA9IGlkICogZXhwIG5vZGVcblxudHlwZSBzdG10ID1cbnwgQXNzbiBvZiBleHAgbm9kZSAqIGV4cCBub2RlXG58IERlY2wgb2YgdmRlY2xcbnwgUmV0IG9mIGV4cCBub2RlIG9wdGlvblxufCBTQ2FsbCBvZiBleHAgbm9kZSAqIGV4cCBub2RlIGxpc3RcbnwgSWYgb2YgZXhwIG5vZGUgKiBzdG10IG5vZGUgbGlzdCAqIHN0bXQgbm9kZSBsaXN0XG58IEZvciBvZiB2ZGVjbCBsaXN0ICogZXhwIG5vZGUgb3B0aW9uICogc3RtdCBub2RlIG9wdGlvbiAqIHN0bXQgbm9kZSBsaXN0XG58IFdoaWxlIG9mIGV4cCBub2RlICogc3RtdCBub2RlIGxpc3RcblxudHlwZSBibG9jayA9IHN0bXQgbm9kZSBsaXN0XG5cbnR5cGUgZ2RlY2wgPSB7IG5hbWUgOiBpZDsgaW5pdCA6IGV4cCBub2RlIH1cblxudHlwZSBmZGVjbCA9IHsgZnJ0eXAgOiByZXRfdHk7IGZuYW1lIDogaWQ7IGFyZ3MgOiAodHkgKiBpZCkgbGlzdDsgYm9keSA6IGJsb2NrIH1cblxudHlwZSBmaWVsZCA9IHsgZmllbGROYW1lIDogaWQ7IGZ0eXAgOiB0eSB9XG5cbnR5cGUgZGVjbCA9XG58IEd2ZGVjbCBvZiBnZGVjbCBub2RlXG58IEdmZGVjbCBvZiBmZGVjbCBub2RlXG5cbnR5cGUgcHJvZyA9IGRlY2wgbGlzdFxuIiwiXG4oKiBUaGlzIGdlbmVyYXRlZCBjb2RlIHJlcXVpcmVzIHRoZSBmb2xsb3dpbmcgdmVyc2lvbiBvZiBNZW5oaXJMaWI6ICopXG5cbmxldCAoKSA9XG4gIE1lbmhpckxpYi5TdGF0aWNWZXJzaW9uLnJlcXVpcmVfMjAyMDAyMTFcblxubW9kdWxlIE1lbmhpckJhc2ljcyA9IHN0cnVjdFxuICBcbiAgZXhjZXB0aW9uIEVycm9yXG4gIFxuICB0eXBlIHRva2VuID0gXG4gICAgfCBXSElMRVxuICAgIHwgVkFSXG4gICAgfCBUVk9JRFxuICAgIHwgVFNUUklOR1xuICAgIHwgVFJVRVxuICAgIHwgVElOVFxuICAgIHwgVElMREVcbiAgICB8IFRCT09MXG4gICAgfCBTVFJJTkcgb2YgKFxuIyAxMyBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgKHN0cmluZylcbiMgMjQgXCJodzAzL3BhcnNlci5tbFwiXG4gIClcbiAgICB8IFNUQVJcbiAgICB8IFNIUlxuICAgIHwgU0hMXG4gICAgfCBTRU1JXG4gICAgfCBTQVJcbiAgICB8IFJQQVJFTlxuICAgIHwgUkVUVVJOXG4gICAgfCBSQlJBQ0tFVFxuICAgIHwgUkJSQUNFXG4gICAgfCBQTFVTXG4gICAgfCBPUlxuICAgIHwgTlVMTFxuICAgIHwgTkVXXG4gICAgfCBORVFcbiAgICB8IExURVxuICAgIHwgTFRcbiAgICB8IExQQVJFTlxuICAgIHwgTEJSQUNLRVRcbiAgICB8IExCUkFDRVxuICAgIHwgSU9SXG4gICAgfCBJTlQgb2YgKFxuIyAxMSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgKGludDY0KVxuIyA0OSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgKVxuICAgIHwgSUZcbiAgICB8IElERU5UIG9mIChcbiMgMTQgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgIChzdHJpbmcpXG4jIDU1IFwiaHcwMy9wYXJzZXIubWxcIlxuICApXG4gICAgfCBJQU5EXG4gICAgfCBHVEVcbiAgICB8IEdUXG4gICAgfCBHTE9CQUxcbiAgICB8IEZPUlxuICAgIHwgRkFMU0VcbiAgICB8IEVRRVFcbiAgICB8IEVRXG4gICAgfCBFT0ZcbiAgICB8IEVMU0VcbiAgICB8IERBU0hcbiAgICB8IENPTU1BXG4gICAgfCBCQU5HXG4gICAgfCBBTkRcbiAgXG5lbmRcblxuaW5jbHVkZSBNZW5oaXJCYXNpY3NcblxubGV0IF9lUlIgPVxuICBNZW5oaXJCYXNpY3MuRXJyb3JcblxuIyAxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgXG5vcGVuIEFzdFxuXG5sZXQgbG9jIChzdGFydHBvczpMZXhpbmcucG9zaXRpb24pIChlbmRwb3M6TGV4aW5nLnBvc2l0aW9uKSAoZWx0OidhKSA6ICdhIG5vZGUgPVxuICB7IGVsdCA7IGxvYz1SYW5nZS5ta19sZXhfcmFuZ2Ugc3RhcnRwb3MgZW5kcG9zIH1cblxuXG4jIDg3IFwiaHcwMy9wYXJzZXIubWxcIlxuXG5tb2R1bGUgVGFibGVzID0gc3RydWN0XG4gIFxuICBpbmNsdWRlIE1lbmhpckJhc2ljc1xuICBcbiAgbGV0IHRva2VuMnRlcm1pbmFsIDogdG9rZW4gLT4gaW50ID1cbiAgICBmdW4gX3RvayAtPlxuICAgICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgICB8IEFORCAtPlxuICAgICAgICAgIDQ2XG4gICAgICB8IEJBTkcgLT5cbiAgICAgICAgICA0NVxuICAgICAgfCBDT01NQSAtPlxuICAgICAgICAgIDQ0XG4gICAgICB8IERBU0ggLT5cbiAgICAgICAgICA0M1xuICAgICAgfCBFTFNFIC0+XG4gICAgICAgICAgNDJcbiAgICAgIHwgRU9GIC0+XG4gICAgICAgICAgNDFcbiAgICAgIHwgRVEgLT5cbiAgICAgICAgICA0MFxuICAgICAgfCBFUUVRIC0+XG4gICAgICAgICAgMzlcbiAgICAgIHwgRkFMU0UgLT5cbiAgICAgICAgICAzOFxuICAgICAgfCBGT1IgLT5cbiAgICAgICAgICAzN1xuICAgICAgfCBHTE9CQUwgLT5cbiAgICAgICAgICAzNlxuICAgICAgfCBHVCAtPlxuICAgICAgICAgIDM1XG4gICAgICB8IEdURSAtPlxuICAgICAgICAgIDM0XG4gICAgICB8IElBTkQgLT5cbiAgICAgICAgICAzM1xuICAgICAgfCBJREVOVCBfIC0+XG4gICAgICAgICAgMzJcbiAgICAgIHwgSUYgLT5cbiAgICAgICAgICAzMVxuICAgICAgfCBJTlQgXyAtPlxuICAgICAgICAgIDMwXG4gICAgICB8IElPUiAtPlxuICAgICAgICAgIDI5XG4gICAgICB8IExCUkFDRSAtPlxuICAgICAgICAgIDI4XG4gICAgICB8IExCUkFDS0VUIC0+XG4gICAgICAgICAgMjdcbiAgICAgIHwgTFBBUkVOIC0+XG4gICAgICAgICAgMjZcbiAgICAgIHwgTFQgLT5cbiAgICAgICAgICAyNVxuICAgICAgfCBMVEUgLT5cbiAgICAgICAgICAyNFxuICAgICAgfCBORVEgLT5cbiAgICAgICAgICAyM1xuICAgICAgfCBORVcgLT5cbiAgICAgICAgICAyMlxuICAgICAgfCBOVUxMIC0+XG4gICAgICAgICAgMjFcbiAgICAgIHwgT1IgLT5cbiAgICAgICAgICAyMFxuICAgICAgfCBQTFVTIC0+XG4gICAgICAgICAgMTlcbiAgICAgIHwgUkJSQUNFIC0+XG4gICAgICAgICAgMThcbiAgICAgIHwgUkJSQUNLRVQgLT5cbiAgICAgICAgICAxN1xuICAgICAgfCBSRVRVUk4gLT5cbiAgICAgICAgICAxNlxuICAgICAgfCBSUEFSRU4gLT5cbiAgICAgICAgICAxNVxuICAgICAgfCBTQVIgLT5cbiAgICAgICAgICAxNFxuICAgICAgfCBTRU1JIC0+XG4gICAgICAgICAgMTNcbiAgICAgIHwgU0hMIC0+XG4gICAgICAgICAgMTJcbiAgICAgIHwgU0hSIC0+XG4gICAgICAgICAgMTFcbiAgICAgIHwgU1RBUiAtPlxuICAgICAgICAgIDEwXG4gICAgICB8IFNUUklORyBfIC0+XG4gICAgICAgICAgOVxuICAgICAgfCBUQk9PTCAtPlxuICAgICAgICAgIDhcbiAgICAgIHwgVElMREUgLT5cbiAgICAgICAgICA3XG4gICAgICB8IFRJTlQgLT5cbiAgICAgICAgICA2XG4gICAgICB8IFRSVUUgLT5cbiAgICAgICAgICA1XG4gICAgICB8IFRTVFJJTkcgLT5cbiAgICAgICAgICA0XG4gICAgICB8IFRWT0lEIC0+XG4gICAgICAgICAgM1xuICAgICAgfCBWQVIgLT5cbiAgICAgICAgICAyXG4gICAgICB8IFdISUxFIC0+XG4gICAgICAgICAgMVxuICBcbiAgYW5kIGVycm9yX3Rlcm1pbmFsID1cbiAgICAwXG4gIFxuICBhbmQgdG9rZW4ydmFsdWUgOiB0b2tlbiAtPiBPYmoudCA9XG4gICAgZnVuIF90b2sgLT5cbiAgICAgIG1hdGNoIF90b2sgd2l0aFxuICAgICAgfCBBTkQgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBCQU5HIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgQ09NTUEgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBEQVNIIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgRUxTRSAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IEVPRiAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IEVRIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgRVFFUSAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IEZBTFNFIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgRk9SIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgR0xPQkFMIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgR1QgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBHVEUgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBJQU5EIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgSURFTlQgX3YgLT5cbiAgICAgICAgICBPYmoucmVwciBfdlxuICAgICAgfCBJRiAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IElOVCBfdiAtPlxuICAgICAgICAgIE9iai5yZXByIF92XG4gICAgICB8IElPUiAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IExCUkFDRSAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IExCUkFDS0VUIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgTFBBUkVOIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgTFQgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBMVEUgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBORVEgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBORVcgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBOVUxMIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgT1IgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBQTFVTIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgUkJSQUNFIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgUkJSQUNLRVQgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBSRVRVUk4gLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBSUEFSRU4gLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBTQVIgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBTRU1JIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgU0hMIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgU0hSIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgU1RBUiAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IFNUUklORyBfdiAtPlxuICAgICAgICAgIE9iai5yZXByIF92XG4gICAgICB8IFRCT09MIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgVElMREUgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBUSU5UIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgVFJVRSAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IFRTVFJJTkcgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBUVk9JRCAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IFZBUiAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IFdISUxFIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgXG4gIGFuZCBkZWZhdWx0X3JlZHVjdGlvbiA9XG4gICAgKDgsIFwiXFwwMDBcXDAwMFxcMDE1XFwwMTdYXFwwMDBZXFwwMTRcXDAwMFpcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxyXFwwMTJcXDAxOFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAxNlxcMDAwXFwwMDA9XFwwMDBcXDAyMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDE5XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwRlxcMDAwXFwwMDAqXFwwMDBcXDAyMVxcMDAwXFwwMjJcXDAwMFxcMDAxXFwwMDAtXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwW1xcMDAwXFwwMDBKQVxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBTXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFFcXDAwMFJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAxMVxcbjVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwTVxcMDAwXFwwMDBUVlxcMDAwXFwwMDBcXDAwME5QXFwwMDBcXDAwMFxcMDAwXFwwMDBPXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwTENdXFwwMDA7XFwwMDBcXDAwNVxcMDA3XFwwMDBcXDAwMFxcMDAwXFwwMDAwMi9cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwLjNcXDAwMFxcMDAwXFwwMDAxP1xcMDAwNFxcMDAwXFwwMDBIXFwwMDBcXDAwNlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXGJcXDAwMlxcMDAwRFxcMDAwOVxcMDAwXFwwMDNcXDAwMFdcIilcbiAgXG4gIGFuZCBlcnJvciA9XG4gICAgKDQ3LCBcIlxcMDE1XFwxOTJcXDAwMlxcXCJcXDEzMFxcMDIwXFwwMDBcXDAwMFxcYiBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAxXFwyNDhcXDAwMERQQlxcMTI4XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcblxcMTI4XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBAXFwwMDBcXDAwMH5cXDAwMlxcMDE3XFwwMjBcXDAxNlxcMTYwXFwwMDBcXDAwMFxcMDAxXFwxMjhcXDAwMFxcMDAxXFwyNDhcXDAwNERQQlxcMTMxXFwyNDBcXDAwMFxcMTM2XFwxNjBcXDEzM1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMD9cXDAwMFxcYlxcMTM4XFxiUH5cXDAwMFxcMDE3XFwwMjBcXDAxNlxcMTYwXFwwMDBcXDAwMFxcMDAxXFwwMDBcXDAwMFxcMDAwXFwwMDBcXGJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDFcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMD95XFwyNDRxWlxcMDMxXFwxMzBcXDAwNEVcXDAwNChcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcYlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDdnPlxcMTQyI0NcXDI0MFxcMDAwXFwxMzZcXDE2MFxcMTMzXFwwMDBcXDAzMVxcMTg4XFwyNTA4XFwxNzNcXDAxNVxcMTkyXFwwMDJcXFwiXFwxMzBcXDAyMFxcMDAwdFxcMTc5XFwyMzJcXDIyNiQ/XFwwMDBcXGJcXDEzOFxcYlBcXDAwMVxcMjUxXFwyMDdcXDE2M1xcMTM4XFwyMDhcXDI1MlxcMDAwXFxcIighQFxcMDA3XFwyMzk+XFwxNDIrQ1xcMjQwXFwwMDBcXDEzNlxcMTYwXFwxMzNcXDAwMFxcMDMxXFwxODhcXDI1MDhcXDE3M1xcMDE1XFwxOTJcXDAwMlxcXCJcXDEzMFxcMDIwXFwwMDB+XFwyNDNcXDIzMlxcMjI2XFwxODA/XFwwMDBcXGJcXDEzOFxcYlBcXDAwMVxcMjUxXFwyMDdcXDE2M1xcMTM4XFwyMDhcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDFcXDI0OFxcMDAwRFBCXFwxMjhcXDAxNVxcMjIyfVxcMDI4VlxcMTM1XFwyMjRcXDAwMVxcMDE3QVxcblxcMDAwP3lcXDI0NHFaXFwwMzFcXDEyOFxcMDA0RVxcMDA0KFxcMDAwXFwyNTNcXDIzMVxcMjA5XFwxOTdoflxcMDAwXFwwMTdcXDAyMFxcMDE2XFwxNjBcXDAwM1xcMjQ3XFwxNTlHXFwwMjFcXDE2MVxcMjQ4XFwwMDBEUEJcXDEyOFxcMDE1XFwyMjJ9XFwwMjhWXFwxMzVcXDIyNFxcMDAxXFwwMTdBXFxuXFwwMDA/eVxcMjQ0cVpcXDAzMVxcMTI4XFwwMDRFXFwwMDQoXFwwMDBcXDI1M1xcMjMxXFwyMDlcXDE5N2h+XFwwMDBcXDAxN1xcMDIwXFwwMTZcXDE2MFxcMDAzXFwyNDdcXDE1OUdcXDAyMVxcMTYxXFwyNDhcXDAwMERQQlxcMTI4XFwwMTVcXDIyMn1cXDAyOFZcXDEzNVxcMjI0XFwwMDFcXDAxN0FcXG5cXDAwMD95XFwyNDRxWlxcMDMxXFwxMjhcXDAwNEVcXDAwNChcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMVxcMjUxXFwyMDdcXDE2M1xcMTM4XFwyMDhcXDAwM1xcMTc3XFwxNTlHXFwwMTcgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXGJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMDpZXFwyNDRxXFwwMThcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMjUzXFwyMzFcXDIwOVxcMTk3aFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAzXFwxNjFcXDE1OUdcXDAyMSBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDZcXDE2MFxcMDAwXFwwMDBcXDAwMlxcMDE2XFwwMDBcXDAwMFxcMDAwXFwwMDBAXFwwMDBcXDAwMFxcMDAwXFwwMDAgXFwwMDBcXDAwMFxcMDIxXFwwMDJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMEJcXDAwMFxcMDAwXFwwMDBcXDAwMlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDAgXFwwMDBcXDAwMFxcMDAxXFwwMDJcXDE2MFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwQFxcMDAwXFwwMDZcXDI1MlxcblxcXCI4YUBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDNcXDI0MFxcMDAwXFwxMzZcXDE2MFxcMTMzXFwwMDBcXDAyOVxcMTQwXFwyNTA4XFwxMzdcXDAwMFxcMDAwXFwwMDBcXGJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwyNTJcXDAwMFxcXCIoIUBcXDAwN1xcMTk1PlxcMTQyI0NcXDI0MVxcMDAwXFwxMzZcXDE2MFxcMTMzXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDA+XFwwMjVcXDI0NHFcXDAxOFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMTI4XFwwMDBcXDAwMH5cXDAwMFxcMDE3XFwwMjBcXDAxNlxcMTYwXFwwMDNcXDE3N1xcMTU5R1xcMDE3IFxcMDAwXFwwMDBcXDAwMVxcMDAwXFwwMDBcXDAyN1xcMjQwaFxcMTM2XFwyMjVcXDE1N1xcMDAwXFwwMDBcXDAwMFxcMDA0XFwxMjhcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAxXFwyMDhcXDIwN1xcMTYzXFwxNDBcXDE0NFxcMDAwXFwwMDBcXDAwMlxcMDAwXFwwMDBcXDAwNFxcMDAwXFwxMjhcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAxXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwN1xcMjI2XFwwMDFcXDAxN0FcXG5cXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDIyM1xcMTMxXFwwMDRHXFwwMTIoXFwwMDBcXDAxNlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAxNlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAxXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDEyOFxcMDMxXFwxMjhcXDAwNEVcXDAwNChcXDAwMFxcMjQ4Z1xcMjA5XFwxOTZIXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDdDPlxcMTQyXFxcIkNcXDI0MEBcXDEzNlxcMTYwXFwxMzNcXDAwMFxcMDAwXFwxMjhcXDAwMFxcMDAwXFwwMDBcXDAwMD5cXDAyNVxcMjQ0cVxcMDE4XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwP1xcMDAwXFxiXFwxMzhcXGJQXFwwMDFcXDIxMFxcMjA3XFwxNjNcXDEzNlxcMTQ0XFwwMDNcXDE2MVxcMTU5R1xcMDI1IFxcMDA3XFwxOTU+XFwxNDJcXFwiQFxcMDAxXFwwMDBcXDAwMFxcMDAwXFwwMDJcXDAxNlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDN+XFwwMDVcXDAxN1xcMDI4MFxcMTYwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwxMjhcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDFcXDAwMDtcXDAwMFxcYlxcYlxcYlxcMDAwXFwwMDBcXDAwMCBcXDEyOFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDVAXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAxNlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwxMjhcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBgXFwwMDBcXDAwMHZcXDAwMVxcMDE2XFwwMTZcXDAxNlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMTZcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMVxcMDAzXFwxNzZcXDAwMFxcMTI4XFwxMjhcXDEyOFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMEJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAxXFwwMDBcXDAwMFxcMDAwXFwxNjhcXDAxNlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMTI4XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyMTJcXDAwMFxcMDAwXFwwMDBCXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxyXFwyNDhcXDAxNkRwXFwxOTRcXDEyOFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFwiKVxuICBcbiAgYW5kIHN0YXJ0ID1cbiAgICAzXG4gIFxuICBhbmQgYWN0aW9uID1cbiAgICAoKDE2LCBcIlxcYlxcMTQwXFwwMDBcXDAzMVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcYlxcMTQwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDI4XFwwMDBcXDAwMFxcMDAwIVxcYlxcMTQwXFwwMDBcXDAwM1xcYlxcMTQwXFxiXFwxNDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXGJcXDE0MFxcYlxcMTQwXFwwMDAqXFwwMDBkXFwwMDAsXFwwMDBcXDAwMFxcMDAwXFwwMjFcXGJcXDE0MFxcMDAwXFwwMDBcXDAwMHJcXDAwMFxcMDAwXFwwMDVcXDE5NlxcYlxcMTQwXFwwMDA2XFxiXFwxNDBcXDAwNVxcMTk2XFxiXFwxNDBcXDAwMFxcMTI4XFxiXFwxNDBcXDAwMFxcMjAyXFxiXFwxNDBcXDAwMVxcMDIwXFxiXFwxNDBcXDAwMV5cXGJcXDE0MFxcMDAxXFwxNjhcXDAwMFxcMDAwXFxiXFwxNDBcXDAwMVxcMjQyXFxiXFwxNDBcXDAwMjxcXGJcXDE0MFxcMDAyXFwxMzRcXGJcXDE0MFxcMDAyXFwyMDhcXGJcXDE0MFxcMDAzXFwwMjZcXGJcXDE0MFxcMDAzZFxcYlxcMTQwXFwwMDNcXDE3NFxcYlxcMTQwXFwwMDNcXDI0OFxcYlxcMTQwXFwwMDRCXFxiXFwxNDBcXDAwNFxcMTQwXFxiXFwxNDBcXDAwMFxcMDAwXFwwMDRcXDIxNFxcMDA2XFwwMTRcXDAwMFxcMDAwXFwwMDBcXDE0OFxcMDAwXFwwMDBcXDAwNlxcMDE0XFwwMDBcXDAwMFxcMDA1IFxcMDAwXFwwMDBcXDAwNVxcMTk2XFwwMDBcXDAwMFxcMDA1ZFxcMDAwXFwxMjhcXDAwMFxcMTQ4XFwwMDVkXFwwMDBcXDAwNlxcMDAwXFwxNzBcXDAwMFxcMDAwXFwwMDBcXDAyNlxcMDAwXFwwMjhcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMTc4XFwwMDA2XFwwMDZqXFwwMDBcXDE2NlxcYlxcMTQwXFwwMDZcXDE3OFxcMDAwNlxcMDAwXFwwMDBcXDAwMFxcMTcwXFwwMDBcXDE2NFxcYlxcMTQwXFwwMDZcXDAxNFxcYlxcMTQwXFwwMDBcXDAwMFxcMDA1XFwxOTZcXDAwMFxcMDAwXFwwMDBcXDE5NFxcYlxcMTQwXFwwMDZcXDIzOFxcMDAwNlxcMDA1fFxcMDAwNlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA3KlxcMDAwXFwyMDZcXDAwMCZcXDAwMFxcMjM2XFxiXFwyMjRcXDAwMFxcMjM4XFwwMDZqXFwwMDBcXDI0MFxcMDAwXFwwMDBcXDAwMFxcMjQ0XFwwMDA2XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMTk2XFxiXFwxNDBcXDAwNlxcMTc4XFwwMDBcXDAwMFxcMDAwXFwwMDBcXGI2XFxiXFwxNDBcXDAwMFxcMjQ4XFwwMDd0XFwwMDBcXDAwMFxcYlxcMTQwXFwwMDZcXDE3OFxcMDA3XFwxNzZcXDAwN1xcMjUwXFwwMDBkXFwwMDAmXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDZqXFwwMDBcXDAwMFxcMDAwXFwyNDZcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyMjJcXDAwMFxcMjEyXFxidlxcMDAwTFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMjhcXDAwMFxcMjU0XFwwMDFcXDAyOFxcMDAwdFxcYlxcMjM2XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMVxcblxcMDAxKlxcMDAwXFwxNDhcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAxLFxcMDAwXFwwMDBcXDAwMHxcXGJ2XFwwMDBcXDAwMFxcMDAxOFxcMDAwXFwwMDBcXDAwMEpcXDAwMSBcXDAwNWRcXDAwMT5cXDAwMDZcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAxXFwwMTJcXDAwMFxcMDAwXFwwMDVkXFwwMDBcXDAwMFxcMDA2alxcMDAwXFwwMDBcXDAwMVxcMDE0XFwwMDBcXDAwMFwiKSwgKDE2LCBcIlxcMDAwXFwxNTdcXDAwMFxcMTU3XFwwMDBcXDE1N1xcMDAwXFwxNTdcXDAwMFxcMTU3XFwwMDBcXDE1N1xcMDAwXFxuXFwwMDBcXDE1N1xcMDAwXFwxNTdcXDAwMFxcMTU3XFwwMDBcXDE1N1xcMDAwLlxcMDAxZVxcMDAwXFwxNTdcXDAwMFxcMTU3XFwwMDBcXDE1N1xcMDAwZlxcMDAwXFwxMzBcXDAwMCZcXDAwMFxcMTU3XFwwMDBcXDAxOFxcMDAxXFwxMzhcXDAwMFxcMDI2XFwwMDBcXDE1N1xcMDAwXFwxNTdcXDAwMFxcMTU3XFwwMDFpXFwwMDA2XFwwMDEhXFwwMDBcXDE1N1xcMDAxTlxcMDAwXFwxNTdcXDAwMVxcMDA1XFwwMDBcXDE1N1xcMDAwXFwxNTdcXDAwMVZcXDAwMFxcMTU3XFwwMDBhXFwwMDBhXFwwMDBhXFwwMDBhXFwwMDBhXFwwMDBhXFwwMDBeXFwwMDBhXFwwMDBhXFwwMDBhXFwwMDBhXFwwMDBWXFwwMDFpXFwwMDBhXFwwMDBhXFwwMDBhXFwwMDBmXFwwMDBcXDEzMFxcMDAxclxcMDAwYVxcMDAxWlxcMDAxXFwxNzBcXDAwMnJcXDAwMGFcXDAwMGFcXDAwMGFcXDAwMSlcXDAwMU5cXDAwMWVcXDAwMGFcXDAwMFpcXDAwMGFcXDAwMlxcMjA2XFwwMDBhXFwwMDBhXFwwMDByXFwwMDBhXFwwMDB6XFwwMDBcXDE0NVxcMDAwXFwxNDVcXDAwMFxcMTQ1XFwwMDBcXDE0NVxcMDAwXFwxNDVcXDAwMVxcMDI1XFwwMDBcXDE0NVxcMDAwXFwxNDVcXDAwMFxcMTQ2XFwwMDBcXDE0NVxcMDAxaVxcMDAyXFwxNDJcXDAwMFxcMTQ1XFwwMDBcXDE0NVxcMDAwXFwxNDVcXDAwMGZcXDAwMFxcMTMwXFwwMDFcXDAzMFxcMDAwXFwxNDVcXDAwMj5cXDAwMlxcMTY2XFwwMDFCXFwwMDBcXDE0NVxcMDAwXFwxNDVcXDAwMFxcMTQ1XFwwMDFGXFwwMDFpXFwwMDFSXFwwMDBcXDE0NVxcMDAxblxcMDAwXFwxNDVcXDAwMlxcMTg2XFwwMDBcXDE1NFxcMDAwXFwxNDVcXDAwMXpcXDAwMFxcMTQ1XFwwMDB6XFwwMDBZXFwwMDBZXFwwMDBZXFwwMDBZXFwwMDBZXFwwMDFcXDE0MlxcMDAwWVxcMDAwWVxcMDAwWVxcMDAwWVxcMDAxXFwxNDZcXDAwMVxcMTc0XFwwMDBZXFwwMDBZXFwwMDBZXFwwMDBmXFwwMDBcXDEzMFxcMDAxXFwyMTRcXDAwMFlcXDAwMVxcMjIyXFwwMDFcXDIzMFxcMDAxXFwyMzhcXDAwMFlcXDAwMFlcXDAwMFlcXDAwMVxcMjQ2XFwwMDJcXDAwNlxcMDAyXFxcIlxcMDAwWVxcMDAyWlxcMDAwWVxcMDAyZlxcMDAwWVxcMDAwWVxcMDAyalxcMDAwWVxcMDAwelxcMDAwXVxcMDAwXVxcMDAwXVxcMDAwXVxcMDAwXVxcMDAyXFwxMzRcXDAwMF1cXDAwMF1cXDAwMF1cXDAwMF1cXDAwMlxcMTM4XFwwMDJcXDE1OFxcMDAwXVxcMDAwXVxcMDAwXVxcMDAwZlxcMDAwXFwxMzBcXDAwMlxcMTYyXFwwMDBdXFwwMDJcXDE3OFxcMDAyXFwxOThcXDAwMlxcMjEwXFwwMDBdXFwwMDBdXFwwMDBdXFwwMDJcXDIxOFxcMDAyXFwyMzVcXDAwM1xcMDAzXFwwMDBdXFwwMDBcXDAwMFxcMDAwXVxcMDAwXFwwMDBcXDAwMF1cXDAwMF1cXDAwMFxcMDAwXFwwMDBdXFwwMDB6XFwwMDBcXDE0MVxcMDAwXFwxNDFcXDAwMFxcMTQxXFwwMDBcXDE0MVxcMDAwXFwxNDFcXDAwMFxcMDAwXFwwMDBcXDE0MVxcMDAwXFwxNDFcXDAwMFxcMTQ2XFwwMDBcXDE0MVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDE0MVxcMDAwXFwxNDFcXDAwMFxcMTQxXFwwMDBmXFwwMDBcXDEzMFxcMDAwXFwwMDBcXDAwMFxcMTQxXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDE0MVxcMDAwXFwxNDFcXDAwMFxcMTQxXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDE0MVxcMDAwXFwwMDBcXDAwMFxcMTQxXFwwMDBcXDAwMFxcMDAwXFwxNTRcXDAwMFxcMTQxXFwwMDBcXDAwMFxcMDAwXFwxNDFcXDAwMHpcXDAwMFxcMTQ5XFwwMDBcXDE0OVxcMDAwXFwxNDlcXDAwMFxcMTQ5XFwwMDBcXDE0OVxcMDAwXFwwMDBcXDAwMFxcMTQ5XFwwMDBcXDE0OVxcMDAwXFwxNDZcXDAwMFxcMTQ5XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMTQ5XFwwMDBcXDE0OVxcMDAwXFwxNDlcXDAwMGZcXDAwMFxcMTMwXFwwMDBcXDAwMFxcMDAwXFwxNDlcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMTQ5XFwwMDBcXDE0OVxcMDAwXFwxNDlcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMTQ5XFwwMDBcXDAwMFxcMDAwXFwxNDlcXDAwMFxcMDAwXFwwMDBcXDE1NFxcMDAwXFwxNDlcXDAwMFxcMDAwXFwwMDBcXDE0OVxcMDAwelxcMDAwXFwxMzhcXDAwMFxcMTYyXFwwMDBcXDEyOVxcMDAwXFwxNzBcXDAwMFxcMTI5XFwwMDBcXDAwMFxcMDAwXFwxMjlcXDAwMFxcMTI5XFwwMDBcXDE0NlxcMDAwXFwxMjlcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwxOTBcXDAwMFxcMTk4XFwwMDBcXDIwNlxcMDAwZlxcMDAwXFwxMzBcXDAwMFxcMDAwXFwwMDBcXDEyOVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwxMjlcXDAwMFxcMjE0XFwwMDBcXDIyMlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyMzBcXDAwMFxcMDAwXFwwMDBcXDEyOVxcMDAwXFwwMDBcXDAwMFxcMTU0XFwwMDBcXDEyOVxcMDAwXFwwMDBcXDAwMFxcMjM4XFwwMDB6XFwwMDBcXDEzOFxcMDAwXFwxNjJcXDAwMGlcXDAwMFxcMTcwXFwwMDBpXFwwMDBcXDAwMFxcMDAwaVxcMDAwaVxcMDAwXFwxNDZcXDAwMGlcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwaVxcMDAwXFwxOThcXDAwMFxcMjA2XFwwMDBmXFwwMDBcXDEzMFxcMDAwXFwwMDBcXDAwMGlcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMGlcXDAwMFxcMjE0XFwwMDBcXDIyMlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwaVxcMDAwXFwwMDBcXDAwMGlcXDAwMFxcMDAwXFwwMDBcXDE1NFxcMDAwaVxcMDAwXFwwMDBcXDAwMGlcXDAwMHpcXDAwMFxcMTM4XFwwMDBcXDE2MlxcMDAwcVxcMDAwXFwxNzBcXDAwMHFcXDAwMFxcMDAwXFwwMDBxXFwwMDBxXFwwMDBcXDE0NlxcMDAwcVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBxXFwwMDBxXFwwMDBxXFwwMDBmXFwwMDBcXDEzMFxcMDAwXFwwMDBcXDAwMHFcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMHFcXDAwMHFcXDAwMHFcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMHFcXDAwMFxcMDAwXFwwMDBxXFwwMDBcXDAwMFxcMDAwXFwxNTRcXDAwMHFcXDAwMFxcMDAwXFwwMDBxXFwwMDB6XFwwMDBcXDEzOFxcMDAwXFwxNjJcXDAwMG1cXDAwMFxcMTcwXFwwMDBtXFwwMDBcXDAwMFxcMDAwbVxcMDAwbVxcMDAwXFwxNDZcXDAwMG1cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwbVxcMDAwbVxcMDAwbVxcMDAwZlxcMDAwXFwxMzBcXDAwMFxcMDAwXFwwMDBtXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBtXFwwMDBtXFwwMDBtXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBtXFwwMDBcXDAwMFxcMDAwbVxcMDAwXFwwMDBcXDAwMFxcMTU0XFwwMDBtXFwwMDBcXDAwMFxcMDAwbVxcMDAwelxcMDAwXFwxMzhcXDAwMFxcMTYyXFwwMDB5XFwwMDBcXDE3MFxcMDAweVxcMDAwXFwwMDBcXDAwMHlcXDAwMHlcXDAwMFxcMTQ2XFwwMDB5XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMHlcXDAwMHlcXDAwMHlcXDAwMGZcXDAwMFxcMTMwXFwwMDBcXDAwMFxcMDAweVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAweVxcMDAweVxcMDAweVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAweVxcMDAwXFwwMDBcXDAwMHlcXDAwMFxcMDAwXFwwMDBcXDE1NFxcMDAweVxcMDAwXFwwMDBcXDAwMHlcXDAwMHpcXDAwMFxcMTM4XFwwMDBcXDE2MlxcMDAwdVxcMDAwXFwxNzBcXDAwMHVcXDAwMFxcMDAwXFwwMDB1XFwwMDB1XFwwMDBcXDE0NlxcMDAwdVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDB1XFwwMDB1XFwwMDB1XFwwMDBmXFwwMDBcXDEzMFxcMDAwXFwwMDBcXDAwMHVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMHVcXDAwMHVcXDAwMHVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMHVcXDAwMFxcMDAwXFwwMDB1XFwwMDBcXDAwMFxcMDAwXFwxNTRcXDAwMHVcXDAwMFxcMDAwXFwwMDB1XFwwMDB6XFwwMDBcXDEzOFxcMDAwXFwxNjJcXDAwMGVcXDAwMFxcMTcwXFwwMDBlXFwwMDBcXDAwMFxcMDAwZVxcMDAwZVxcMDAwXFwxNDZcXDAwMGVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwZVxcMDAwXFwxOThcXDAwMFxcMjA2XFwwMDBmXFwwMDBcXDEzMFxcMDAwXFwwMDBcXDAwMGVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMGVcXDAwMFxcMjE0XFwwMDBcXDIyMlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwZVxcMDAwXFwwMDBcXDAwMGVcXDAwMFxcMDAwXFwwMDBcXDE1NFxcMDAwZVxcMDAwXFwwMDBcXDAwMGVcXDAwMHpcXDAwMFxcMTM4XFwwMDBcXDE2MlxcMDAwfVxcMDAwXFwxNzBcXDAwMH1cXDAwMFxcMDAwXFwwMDB9XFwwMDB9XFwwMDBcXDE0NlxcMDAwfVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDE5MFxcMDAwXFwxOThcXDAwMFxcMjA2XFwwMDBmXFwwMDBcXDEzMFxcMDAwXFwwMDBcXDAwMH1cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMH1cXDAwMFxcMjE0XFwwMDBcXDIyMlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyMzBcXDAwMFxcMDAwXFwwMDB9XFwwMDBcXDAwMFxcMDAwXFwxNTRcXDAwMH1cXDAwMFxcMDAwXFwwMDB9XFwwMDB6XFwwMDBcXDEzOFxcMDAwXFwxNjJcXDAwMFxcMTM3XFwwMDBcXDE3MFxcMDAwXFwxMzdcXDAwMFxcMDAwXFwwMDBcXDEzN1xcMDAwXFwxMzdcXDAwMFxcMTQ2XFwwMDBcXDE4MlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDE5MFxcMDAwXFwxOThcXDAwMFxcMjA2XFwwMDBmXFwwMDBcXDEzMFxcMDAwXFwwMDBcXDAwMFxcMTM3XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDI1NFxcMDAwXFwyMTRcXDAwMFxcMjIyXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDIzMFxcMDAwXFwwMDBcXDAwMFxcMTM3XFwwMDBcXDAwMFxcMDAwXFwxNTRcXDAwMFxcMTM3XFwwMDBcXDAwMFxcMDAwXFwyMzhcXDAwMHpcXDAwMFxcMTM4XFwwMDBcXDE2MlxcMDAwXFwxMzNcXDAwMFxcMTcwXFwwMDBcXDEzM1xcMDAwXFwwMDBcXDAwMFxcMTMzXFwwMDBcXDEzM1xcMDAwXFwxNDZcXDAwMFxcMTgyXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMTkwXFwwMDBcXDE5OFxcMDAwXFwyMDZcXDAwMGZcXDAwMFxcMTMwXFwwMDBcXDAwMFxcMDAwXFwxMzNcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMTMzXFwwMDBcXDIxNFxcMDAwXFwyMjJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMjMwXFwwMDBcXDAwMFxcMDAwXFwxMzNcXDAwMFxcMDAwXFwwMDBcXDE1NFxcMDAwXFwxMzNcXDAwMFxcMDAwXFwwMDBcXDIzOFxcMDAwelxcMDAwXFwxNTNcXDAwMFxcMTUzXFwwMDBcXDE1M1xcMDAwXFwxNTNcXDAwMFxcMTUzXFwwMDBcXDAwMFxcMDAwXFwxNTNcXDAwMFxcMTUzXFwwMDBcXDE1M1xcMDAwXFwxNTNcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwxNTNcXDAwMFxcMTUzXFwwMDBcXDE1M1xcMDAwZlxcMDAwXFwxMzBcXDAwMFxcMDAwXFwwMDBcXDE1M1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwxNTNcXDAwMFxcMTUzXFwwMDBcXDE1M1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwxNTNcXDAwMFxcMDAwXFwwMDBcXDE1M1xcMDAwXFwwMDBcXDAwMFxcMTUzXFwwMDBcXDE1M1xcMDAwXFwwMDBcXDAwMFxcMTUzXFwwMDBcXDE2MVxcMDAwXFwxNjFcXDAwMFxcMTYxXFwwMDBcXDE2MVxcMDAwXFwxNjFcXDAwMFxcMTYxXFwwMDBcXDAwMFxcMDAwXFwxNjFcXDAwMFxcMTYxXFwwMDBcXDE2MVxcMDAwXFwxNjFcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwxNjFcXDAwMFxcMTYxXFwwMDBcXDE2MVxcMDAwZlxcMDAwXFwxMzBcXDAwMFxcMDAwXFwwMDBcXDE2MVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwxNjFcXDAwMFxcMTYxXFwwMDBcXDE2MVxcMDAwXFwwMDBcXDAwMT5cXDAwMCZcXDAwMFxcMTYxXFwwMDBcXDAxOFxcMDAwXFwxNjFcXDAwMFxcMDI2XFwwMDBcXDE2MVxcMDAwXFwxNjFcXDAwMFxcMDAwXFwwMDBcXDE2MVxcMDAwIVxcMDAwIVxcMDAwXFwyNTNcXDAwMCFcXDAwMCFcXDAwMCFcXDAwMCFcXDAwMCFcXDAwMCFcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwIVxcMDAwIVxcMDAwXFwwMDBcXDAwMCFcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMCFcXDAwMFxcMDAwXFwwMDJiXFwwMDBcXDAwMFxcMDAwIVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDIyMVxcMDAwIVxcMDAwIVxcMDAwIVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMCFcXDAwMCFcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwIVxcMDAxXFwxOTBcXDAwMCFcXDAwMFxcMDAwXFwwMDAhXFwwMDB6XFwwMDBcXDEzOFxcMDAwXFwxNjJcXDAwMVxcMTY2XFwwMDBcXDE3MFxcMDAxXFwwMTdcXDAwMFxcMDAwXFwwMDBcXDE3OFxcMDAxXFwwMTdcXDAwMFxcMTQ2XFwwMDBcXDE4MlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDE5MFxcMDAwXFwxOThcXDAwMFxcMjA2XFwwMDBmXFwwMDBcXDEzMFxcMDAwXFwwMDBcXDAwMFxcMjQ2XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDI1NFxcMDAwXFwyMTRcXDAwMFxcMjIyXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDIzMFxcMDAwXFwwMDBcXDAwMTdcXDAwMFxcMDAwXFwwMDBcXDE1NFxcMDAxXFwwMDZcXDAwMFxcMDAwXFwwMDBcXDIzOFxcMDAwelxcMDAwXFwxMzhcXDAwMFxcMTYyXFwwMDFtXFwwMDBcXDE3MFxcMDAxXFwwMjJcXDAwMFxcMDAwXFwwMDEmXFwwMDBcXDAwMFxcMDAwXFwxNDZcXDAwMFxcMTgyXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMTkwXFwwMDBcXDE5OFxcMDAwXFwyMDZcXDAwMGZcXDAwMFxcMTMwXFwwMDBcXDAwMFxcMDAwXFwyNDZcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMjU0XFwwMDBcXDIxNFxcMDAwXFwyMjJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMjMwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDE1NFxcMDAxbVxcMDAwXFwwMDBcXDAwMFxcMjM4XFwwMDF2XFwwMDFcXDEzOFxcMDAwXFwwMDBcXDAwMFxcMDA2XFwwMDBcXDAxNFxcMDAwXFwwMThcXDAwMFxcMDIyXFwwMDBcXDAyNlxcMDAwXFwwMzBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAxUVxcMDAxXFwxNTRcXDAwMFxcMDAwXFwwMDBcXDIyOVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcIlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwOlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwPlxcMDAxXFwxNzBcXDAwMVxcMjA2XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAxXFwyMTBcXDAwMEZcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBKXFwwMDBcXDAwMFxcMDAwTlxcMDAwelxcMDAwXFwxMzhcXDAwMFxcMTYyXFwwMDJcXDAxNFxcMDAwXFwxNzBcXDAwMVxcMTMwXFwwMDBcXDAwMFxcMDAyMlxcMDAwXFwwMDBcXDAwMFxcMTQ2XFwwMDBcXDE4MlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDE5MFxcMDAwXFwxOThcXDAwMFxcMjA2XFwwMDBmXFwwMDBcXDEzMFxcMDAwXFwwMDBcXDAwMFxcMjQ2XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDI1NFxcMDAwXFwyMTRcXDAwMFxcMjIyXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDIzMFxcMDAwelxcMDAwXFwxMzhcXDAwMFxcMTYyXFwwMDBcXDE1NFxcMDAwXFwxNzBcXDAwMVxcMTgyXFwwMDBcXDIzOFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDE0NlxcMDAwXFwxODJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwxOTBcXDAwMFxcMTk4XFwwMDBcXDIwNlxcMDAwZlxcMDAwXFwxMzBcXDAwMFxcMDAwXFwwMDBcXDI0NlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyNTRcXDAwMFxcMjE0XFwwMDBcXDIyMlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyMzBcXDAwMC1cXDAwMC1cXDAwMC1cXDAwMFxcMTU0XFwwMDAtXFwwMDBcXDAwMFxcMDAwXFwyMzhcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwLVxcMDAwLVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDAtXFwwMDAtXFwwMDAtXFwwMDAtXFwwMDAtXFwwMDBcXDAwMFxcMDAwLVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwLVxcMDAwLVxcMDAwLVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwLVxcMDAwXFwyMTNcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwLVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDAtXFwwMDBNXFwwMDBNXFwwMDBNXFwwMDImXFwwMDBNXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwTVxcMDAwTVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBNXFwwMDBNXFwwMDBNXFwwMDBNXFwwMDBNXFwwMDBcXDAwMFxcMDAwTVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwTVxcMDAwTVxcMDAwTVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwTVxcMDAwSVxcMDAwSVxcMDAwSVxcMDAwTVxcMDAwSVxcMDAwXFwwMDBcXDAwME1cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwSVxcMDAwSVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBJXFwwMDBJXFwwMDBJXFwwMDBJXFwwMDBJXFwwMDBcXDAwMFxcMDAwSVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwSVxcMDAwSVxcMDAwSVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwSVxcMDAwXFwyMTdcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwSVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBJXFwwMDB6XFwwMDBcXDEzOFxcMDAwXFwxNjJcXDAwMFxcMTczXFwwMDBcXDE3MFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMTQ2XFwwMDBcXDE4MlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDE5MFxcMDAwXFwxOThcXDAwMFxcMjA2XFwwMDBmXFwwMDBcXDEzMFxcMDAwXFwwMDBcXDAwMFxcMjQ2XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDI1NFxcMDAwXFwyMTRcXDAwMFxcMjIyXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDIzMFxcMDAwelxcMDAwXFwxMzhcXDAwMFxcMTYyXFwwMDBcXDE1NFxcMDAwXFwxNzBcXDAwMFxcMDAwXFwwMDBcXDIzOFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDE0NlxcMDAwXFwxODJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwxOTBcXDAwMFxcMTk4XFwwMDBcXDIwNlxcMDAyXFwwMjZcXDAwMipcXDAwMFxcMDAwXFwwMDBcXDI0NlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyNTRcXDAwMFxcMjE0XFwwMDBcXDIyMlxcMDAyblxcMDAydlxcMDAwXFwwMThcXDAwMFxcMjMwXFwwMDBcXDAyNlxcMDAyelxcMDAwXFwwMDBcXDAwMFxcMTU0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMjM4XFwwMDBcXDAwNlxcMDAwXFwwMTRcXDAwMFxcMDE4XFwwMDBcXDAyMlxcMDAwXFwwMjZcXDAwMFxcMDMwXFwwMDBcXDAwMFxcMDAyflxcMDAwXFwwMDBcXDAwMVxcMTU4XFwwMDBcXDAwMFxcMDAwXFwyMzdcXDAwMFxcMDAwXFwwMDAyXFwwMDBcXDIzN1xcMDAyXFwxNDZcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcIlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwOlxcMDAyXFwxNTBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwPlxcMDAwXFwwMDBcXDAwMEJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwRlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMEpcXDAwMFxcMDAwXFwwMDBOXFwwMDBcXDAwNlxcMDAwXFwwMTRcXDAwMFxcMDE4XFwwMDBcXDAyMlxcMDAwXFwwMjZcXDAwMFxcMDMwXFwwMDJuXFwwMDJ2XFwwMDBcXDAxOFxcMDAwXFwxNjlcXDAwMFxcMDI2XFwwMDJ6XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFwiXFwwMDBcXDAwMFxcMDAwXFwyNDVcXDAwMFxcMDAwXFwwMDA6XFwwMDBcXDAwMFxcMDAyflxcMDAwXFwwMDBcXDAwMD5cXDAwMFxcMDAwXFwwMDBCXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDJcXDE0NlxcMDAwXFwwMDBcXDAwMEZcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBKXFwwMDJcXDE1MFxcMDAwTlwiKSlcbiAgXG4gIGFuZCBsaHMgPVxuICAgICg4LCBcIlxcMDAyXFwwMDFcXDAwMFxcMDI5XFwwMjhcXDAyN1xcMDI3XFwwMjdcXDAyNlxcMDI2XFwwMjZcXDAyNVxcMDI1XFwwMjVcXDAyNVxcMDI1XFwwMjVcXDAyNVxcMDI1XFwwMjVcXDAyNVxcMDI1XFwwMjVcXDAyNVxcMDI1XFwwMjVcXDAyNVxcMDI1XFwwMjVcXDAyNVxcMDI1XFwwMjVcXDAyNVxcMDI1XFwwMjVcXDAyNVxcMDI1XFwwMjVcXDAyNVxcMDI1XFwwMjVcXDAyNVxcMDI0XFwwMjRcXDAyM1xcMDIyXFwwMjJcXDAyMlxcMDIyXFwwMjJcXDAyMlxcMDIyXFwwMjFcXDAyMFxcMDIwXFwwMTlcXDAxOVxcMDE4XFwwMThcXDAxN1xcMDE3XFwwMTZcXDAxNlxcMDE1XFwwMTVcXDAxNFxcMDE0XFxyXFwwMTJcXDAxMlxcMDExXFwwMTFcXG5cXG5cXHRcXHRcXGJcXGJcXGJcXGJcXGJcXGJcXGJcXGJcXDAwN1xcMDA3XFwwMDZcXDAwNVxcMDA1XFwwMDVcXDAwNVxcMDA0XFwwMDNcIilcbiAgXG4gIGFuZCBnb3RvID1cbiAgICAoKDE2LCBcIlxcMDAwalxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDEyXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFJcXDAwMFxcMDAwXFwwMDA2XFwwMDBcXDEzMlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwxMzZcXDAwMFxcMTM4XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMDhcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDE1NFxcMDAwXFwwMDBcXDAwMFxcMTU2XFwwMDBcXDAwMFxcMDAwXFwxNjBcXDAwMFxcMDAwXFwwMDBcXDE2OFxcMDAwXFwwMDBcXDAwMFxcMTcwXFwwMDBcXDAwMFxcMDAwXFwxODBcXDAwMFxcMDAwXFwwMDBcXDE4MlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDE4NFxcMDAwXFwwMDBcXDAwMFxcMTg4XFwwMDBcXDAwMFxcMDAwXFwxOTBcXDAwMFxcMDAwXFwwMDBcXDE5MlxcMDAwXFwwMDBcXDAwMFxcMTk4XFwwMDBcXDAwMFxcMDAwXFwyMDJcXDAwMFxcMDAwXFwwMDBcXDIwNFxcMDAwXFwwMDBcXDAwMFxcMjA2XFwwMDBcXDAwMFxcMDAwXFwyMTJcXDAwMFxcMDAwXFwwMDBcXDIxNFxcMDAwXFwwMDBcXDAwMH5cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMEhcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxuXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyMTZcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAzMVxcMDAwXFx0XFwwMDBcXDAwMFxcMDAwXFwyMThcXDAwMFxcMDAwXFwwMDBcXDAxNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyMzRcXDAwMFxcMDAwXFwwMDBcXDIzNlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMjQwXFwwMDBcXDAwMFxcMDAwXFwwMTZcXDAwMFxcMDIyXFwwMDBcXDIxNlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBeXFwwMDBcXDAwMFxcMDAwblxcMDAwXFwwMDBcXDAwMFxcMDA1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAyMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyNTBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBoXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDFcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMVxcMDA2XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXGJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMVxcYlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMVxcblxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwVlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMTUyXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMHJcXDAwMFxcMDAwXFwwMDBcXDIyMlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMTMwXFwwMDBcXDAwMFxcMDAwLFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFwiKSwgKDgsIFwie1xcMDIxe1xcMDIxXFwxNDh9XFwxMjhcXDAxMXtcXDAyMVNcXDAyMVxcMTQ4XFwxNTJcXDE1MFlcXDEyOVxcMTMzXFwxMjlcXDEzM1pcXDEzNFxcMTQ5XFwxMzRcXDEyOVxcMTMze1xcMDIxXFwxOTFcXDEzNFxcMTkyS1xcMDIxXFwwMjFbYm9zXFwxMjdcXDAyN1xcMDI3XFwxNzlcXDEyOVxcMTMzR1xcMDI4XFwwMjFcXDEzNFxcMTY3XFwxODV3XFwxNDNcXDAzMFxcMDMwXFwxNzFcXDE4NlxcMTQ2XFwwMjFcXDAyMVxcMTcyXFwwMjFcXDE0N1NcXDE4OFxcMDI3XFwxNzRJWVxcMDIxXFwxMzZcXDE3OVxcMDIxWlxcMDIxXFwwMjFDTFxcMDMwTXlcXDE0MlxcMTY3XFwwMjFcXDAyMVxcMTg5XFwwMjFcXDE4MlxcMTc2XFwwMzBcXDAyMVxcMDIxRVxcMTg4RFxcMDI1XFwwMjFcXDAyMVxcMDIxXFwxNzRcXDAyMVxcMDIxXFwwMjEgXFxcIlxcMDIxJFxcMDIxXFwwMjFcXDAyMSYoXFwwMjFcXDAyMVNcXDAyMSosL1gxMzVcXDAyMVxcMDIxN1xcMDIxOTs9cVxcMDIxP0FcXDAyMWBcXDE0M3JcXDE2N1xcMTYxXFwxODRcXDE0NVxcMDAwZmlcXDAwMG1cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMTMxXFwwMDBcXDAwMFxcMTQwXFwxNzdcIikpXG4gIFxuICBhbmQgc2VtYW50aWNfYWN0aW9uID1cbiAgICBbfFxuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHhzO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfeHNfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc194c187XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgeHMgOiAndHZfbG9wdGlvbl9zZXBhcmF0ZWRfbm9uZW1wdHlfbGlzdF9DT01NQV9wYWlyX3R5X0lERU5UX19fID0gT2JqLm1hZ2ljIHhzIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc194c18gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3hzXyBpblxuICAgICAgICBsZXQgX3YgOiAndHZfYXJnbGlzdCA9IGxldCBsID0gXG4jIDIzMiBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIHhzIClcbiMgMzI0IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgXG4jIDEwMyBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggbCApXG4jIDMyOSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18zXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzNfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gc3RtdHM7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3N0bXRzXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19zdG10c187XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgXzMgOiB1bml0ID0gT2JqLm1hZ2ljIF8zIGluXG4gICAgICAgIGxldCBzdG10cyA6ICd0dl9saXN0X3N0bXRfID0gT2JqLm1hZ2ljIHN0bXRzIGluXG4gICAgICAgIGxldCBfMSA6IHVuaXQgPSBPYmoubWFnaWMgXzEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzNfIGluXG4gICAgICAgIGxldCBfdiA6IChcbiMgODMgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5ibG9jaylcbiMgMzY4IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gXG4jIDIwMyBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggc3RtdHMgKVxuIyAzNzIgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzU7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fNV87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX181XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGluaXQ7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2luaXRfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2luaXRfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzM7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzNfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzNfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gbmFtZTtcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX25hbWVfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19uYW1lXztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF81IDogdW5pdCA9IE9iai5tYWdpYyBfNSBpblxuICAgICAgICBsZXQgaW5pdCA6ICd0dl9nZXhwID0gT2JqLm1hZ2ljIGluaXQgaW5cbiAgICAgICAgbGV0IF8zIDogdW5pdCA9IE9iai5tYWdpYyBfMyBpblxuICAgICAgICBsZXQgbmFtZSA6IChcbiMgMTQgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgIChzdHJpbmcpXG4jIDQyMCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBuYW1lIGluXG4gICAgICAgIGxldCBfMSA6IHVuaXQgPSBPYmoubWFnaWMgXzEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzVfIGluXG4gICAgICAgIGxldCBfdiA6ICd0dl9kZWNsID0gbGV0IF9lbmRwb3MgPSBfZW5kcG9zX181XyBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBcbiMgOTggXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICggR3ZkZWNsIChsb2MgX3N0YXJ0cG9zIF9lbmRwb3MgeyBuYW1lOyBpbml0IH0pIClcbiMgNDMxIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGJvZHk7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19ib2R5XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfYm9keV87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfNTtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzVfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX181XztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGFyZ3M7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfYXJnc187XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19hcmdzXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8zO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzNfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fM187XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBmbmFtZTtcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZm5hbWVfO1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2ZuYW1lXztcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBib2R5IDogKFxuIyA4MyBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmJsb2NrKVxuIyA0ODIgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgYm9keSBpblxuICAgICAgICBsZXQgXzUgOiB1bml0ID0gT2JqLm1hZ2ljIF81IGluXG4gICAgICAgIGxldCBhcmdzIDogJ3R2X2FyZ2xpc3QgPSBPYmoubWFnaWMgYXJncyBpblxuICAgICAgICBsZXQgXzMgOiB1bml0ID0gT2JqLm1hZ2ljIF8zIGluXG4gICAgICAgIGxldCBmbmFtZSA6IChcbiMgMTQgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgIChzdHJpbmcpXG4jIDQ5MCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBmbmFtZSBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2JvZHlfIGluXG4gICAgICAgIGxldCBfdiA6ICd0dl9kZWNsID0gbGV0IGZydHlwID0gXG4jIDExMiBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICggUmV0Vm9pZCApXG4jIDQ5OSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3NfZnJ0eXBfID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfYm9keV8gaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19mcnR5cF8gaW5cbiAgICAgICAgXG4jIDEwMCBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgKCBHZmRlY2wgKGxvYyBfc3RhcnRwb3MgX2VuZHBvcyB7IGZydHlwOyBmbmFtZTsgYXJnczsgYm9keSB9KSApXG4jIDUwNyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBib2R5O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfYm9keV87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2JvZHlfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzU7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX181XztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fNV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBhcmdzO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2FyZ3NfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfYXJnc187XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18zXztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzNfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZm5hbWU7XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2ZuYW1lXztcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19mbmFtZV87XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHQ7XG4gICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfdF87XG4gICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc190XztcbiAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgYm9keSA6IChcbiMgODMgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5ibG9jaylcbiMgNTU4IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGJvZHkgaW5cbiAgICAgICAgbGV0IF81IDogdW5pdCA9IE9iai5tYWdpYyBfNSBpblxuICAgICAgICBsZXQgYXJncyA6ICd0dl9hcmdsaXN0ID0gT2JqLm1hZ2ljIGFyZ3MgaW5cbiAgICAgICAgbGV0IF8zIDogdW5pdCA9IE9iai5tYWdpYyBfMyBpblxuICAgICAgICBsZXQgZm5hbWUgOiAoXG4jIDE0IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyA1NjYgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgZm5hbWUgaW5cbiAgICAgICAgbGV0IHQgOiAoXG4jIDg0IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QudHkpXG4jIDU3MSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyB0IGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc190XyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfYm9keV8gaW5cbiAgICAgICAgbGV0IF92IDogJ3R2X2RlY2wgPSBsZXQgZnJ0eXAgPSBcbiMgMTEzIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgKCBSZXRWYWwgdCApXG4jIDU3OSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3NfZnJ0eXBfID0gX3N0YXJ0cG9zX3RfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19ib2R5XyBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2ZydHlwXyBpblxuICAgICAgICBcbiMgMTAwIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAoIEdmZGVjbCAobG9jIF9zdGFydHBvcyBfZW5kcG9zIHsgZnJ0eXA7IGZuYW1lOyBhcmdzOyBib2R5IH0pIClcbiMgNTg3IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCBfbWVuaGlyX3MgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuY3VycmVudCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX3N0YXJ0cG9zIGluXG4gICAgICAgIGxldCBfdiA6ICd0dl9lbHNlX3N0bXQgPSBcbiMgMjEwIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAoIFtdIClcbiMgNjA1IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGI7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19iXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfYl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBiIDogKFxuIyA4MyBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmJsb2NrKVxuIyA2MzIgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgYiBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2JfIGluXG4gICAgICAgIGxldCBfdiA6ICd0dl9lbHNlX3N0bXQgPSBcbiMgMjExIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAoIGIgKVxuIyA2NDEgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gaWZzO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfaWZzXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfaWZzXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IGlmcyA6ICd0dl9pZl9zdG10ID0gT2JqLm1hZ2ljIGlmcyBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2lmc18gaW5cbiAgICAgICAgbGV0IF92IDogJ3R2X2Vsc2Vfc3RtdCA9IFxuIyAyMTIgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICggWyBpZnMgXSApXG4jIDY3MyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGlkO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfaWRfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19pZF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgaWQgOiAoXG4jIDE0IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyA2OTQgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgaWQgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2lkXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfaWRfIGluXG4gICAgICAgIGxldCBfdiA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDcwMiBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IGxldCBfZW5kcG9zID0gX2VuZHBvc19pZF8gaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19pZF8gaW5cbiAgICAgICAgXG4jIDE1NyBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAoIGxvYyBfc3RhcnRwb3MgX2VuZHBvcyBAQCBJZCBpZCApXG4jIDcwOCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGk7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19pXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfaV87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgaSA6IChcbiMgMTEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgIChpbnQ2NClcbiMgNzI5IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGkgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2lfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19pXyBpblxuICAgICAgICBsZXQgX3YgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyA3MzcgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfaV8gaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19pXyBpblxuICAgICAgICBcbiMgMTU4IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICggbG9jIF9zdGFydHBvcyBfZW5kcG9zIEBAIENJbnQgaSApXG4jIDc0MyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHM7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19zXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3Nfc187XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgcyA6IChcbiMgMTMgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgIChzdHJpbmcpXG4jIDc2NCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBzIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19zXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3Nfc18gaW5cbiAgICAgICAgbGV0IF92IDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgNzcyIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3NfIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3Nfc18gaW5cbiAgICAgICAgXG4jIDE1OSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAoIGxvYyBfc3RhcnRwb3MgX2VuZHBvcyBAQCBDU3RyIHMgKVxuIyA3NzggXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzI7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18yXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF8yIDogdW5pdCA9IE9iai5tYWdpYyBfMiBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX18yXyBpblxuICAgICAgICBsZXQgX3YgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyA4MTAgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBsZXQgdCA9IFxuIyAxMTYgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgKCBSU3RyaW5nIClcbiMgODE0IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvc190XyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX18yXyBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3RfIGluXG4gICAgICAgIFxuIyAxNjAgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoIGxvYyBfc3RhcnRwb3MgX2VuZHBvcyBAQCBDTnVsbCB0IClcbiMgODIyIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8yO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzNfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18zXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8yX2lubGluZWQxO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18yX2lubGluZWQxXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18yX2lubGluZWQxXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gdDtcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3RfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc190XztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfMiA6IHVuaXQgPSBPYmoubWFnaWMgXzIgaW5cbiAgICAgICAgbGV0IF8zIDogdW5pdCA9IE9iai5tYWdpYyBfMyBpblxuICAgICAgICBsZXQgXzJfaW5saW5lZDEgOiB1bml0ID0gT2JqLm1hZ2ljIF8yX2lubGluZWQxIGluXG4gICAgICAgIGxldCB0IDogKFxuIyA4NCBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LnR5KVxuIyA4NjQgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgdCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfdF8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX18yXyBpblxuICAgICAgICBsZXQgX3YgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyA4NzIgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBsZXQgdCA9XG4gICAgICAgICAgbGV0IF8yID0gXzJfaW5saW5lZDEgaW5cbiAgICAgICAgICBcbiMgMTE3IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICggUkFycmF5IHQgKVxuIyA4NzggXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICAgXG4gICAgICAgIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fMl8gaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc190XyBpblxuICAgICAgICBcbiMgMTYwIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCBsb2MgX3N0YXJ0cG9zIF9lbmRwb3MgQEAgQ051bGwgdCApXG4jIDg4NiBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX18xXyBpblxuICAgICAgICBsZXQgX3YgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyA5MTEgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIFxuIyAxNjEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKCBsb2MgX3N0YXJ0cG9zIF9lbmRwb3MgQEAgQ0Jvb2wgdHJ1ZSApXG4jIDkxNyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX18xXyBpblxuICAgICAgICBsZXQgX3YgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyA5NDIgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIFxuIyAxNjIgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICggbG9jIF9zdGFydHBvcyBfZW5kcG9zIEBAIENCb29sIGZhbHNlIClcbiMgOTQ4IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF80O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzRfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fNF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBpO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19pXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19pXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8yO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18yXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18yXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZTtcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2VfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19lXztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfNCA6IHVuaXQgPSBPYmoubWFnaWMgXzQgaW5cbiAgICAgICAgbGV0IGkgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyA5ODggXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgaSBpblxuICAgICAgICBsZXQgXzIgOiB1bml0ID0gT2JqLm1hZ2ljIF8yIGluXG4gICAgICAgIGxldCBlIDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgOTk0IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGUgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2VfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fNF8gaW5cbiAgICAgICAgbGV0IF92IDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMTAwMiBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IGxldCBfZW5kcG9zID0gX2VuZHBvc19fNF8gaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19lXyBpblxuICAgICAgICBcbiMgMTY0IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICggbG9jIF9zdGFydHBvcyBfZW5kcG9zIEBAIEluZGV4IChlLCBpKSApXG4jIDEwMDggXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzQ7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fNF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX180XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHhzO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc194c187XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeHNfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzI7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzJfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzJfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBlO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZV87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2VfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF80IDogdW5pdCA9IE9iai5tYWdpYyBfNCBpblxuICAgICAgICBsZXQgeHMgOiAndHZfbG9wdGlvbl9zZXBhcmF0ZWRfbm9uZW1wdHlfbGlzdF9DT01NQV9leHBfXyA9IE9iai5tYWdpYyB4cyBpblxuICAgICAgICBsZXQgXzIgOiB1bml0ID0gT2JqLm1hZ2ljIF8yIGluXG4gICAgICAgIGxldCBlIDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMTA1MCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBlIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19lXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzRfIGluXG4gICAgICAgIGxldCBfdiA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDEwNTggXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBsZXQgZXMgPSBcbiMgMjMyIFwiPHN0YW5kYXJkLm1seT5cIlxuICAgICggeHMgKVxuIyAxMDYyIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX180XyBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2VfIGluXG4gICAgICAgIFxuIyAxNjYgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKCBsb2MgX3N0YXJ0cG9zIF9lbmRwb3MgQEAgQ2FsbCAoZSxlcykgKVxuIyAxMDY5IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF83O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzdfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fN187XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB4cztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfeHNfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3hzXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF81O1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX181XztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX181XztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF80O1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzRfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fNF87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMztcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzNfO1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18zXztcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHQ7XG4gICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfdF87XG4gICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc190XztcbiAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfNyA6IHVuaXQgPSBPYmoubWFnaWMgXzcgaW5cbiAgICAgICAgbGV0IHhzIDogJ3R2X2xvcHRpb25fc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQ09NTUFfZXhwX18gPSBPYmoubWFnaWMgeHMgaW5cbiAgICAgICAgbGV0IF81IDogdW5pdCA9IE9iai5tYWdpYyBfNSBpblxuICAgICAgICBsZXQgXzQgOiB1bml0ID0gT2JqLm1hZ2ljIF80IGluXG4gICAgICAgIGxldCBfMyA6IHVuaXQgPSBPYmoubWFnaWMgXzMgaW5cbiAgICAgICAgbGV0IHQgOiAoXG4jIDg0IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QudHkpXG4jIDExMzEgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgdCBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX183XyBpblxuICAgICAgICBsZXQgX3YgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAxMTQwIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gbGV0IGVzID0gXG4jIDIzMiBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIHhzIClcbiMgMTE0NCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fN18gaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgXG4jIDE2OCBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAoIGxvYyBfc3RhcnRwb3MgX2VuZHBvcyBAQCBDQXJyKHQsIGVzKSApXG4jIDExNTEgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzU7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fNV87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX181XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGU7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2VfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2VfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzM7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzNfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzNfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gdDtcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3RfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc190XztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF81IDogdW5pdCA9IE9iai5tYWdpYyBfNSBpblxuICAgICAgICBsZXQgZSA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDExOTcgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgZSBpblxuICAgICAgICBsZXQgXzMgOiB1bml0ID0gT2JqLm1hZ2ljIF8zIGluXG4gICAgICAgIGxldCB0IDogKFxuIyA4NCBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LnR5KVxuIyAxMjAzIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIHQgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fNV8gaW5cbiAgICAgICAgbGV0IF92IDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMTIxMiBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IGxldCBfZW5kcG9zID0gX2VuZHBvc19fNV8gaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgXG4jIDE3MCBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAoIGxvYyBfc3RhcnRwb3MgX2VuZHBvcyBAQCBOZXdBcnIodCwgZSkgKVxuIyAxMjE4IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGUyO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZTJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19lMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZTE7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZTFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZTFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBlMiA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDEyNTEgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgZTIgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgZTEgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAxMjU3IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGUxIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19lMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2UyXyBpblxuICAgICAgICBsZXQgX3YgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAxMjY1IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gbGV0IGIgPSBcbiMgMTIwIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgKCBBZGQgKVxuIyAxMjY5IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2UyXyBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2UxXyBpblxuICAgICAgICBcbiMgMTcxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICggbG9jIF9zdGFydHBvcyBfZW5kcG9zIEBAIEJvcCAoYiwgZTEsIGUyKSApXG4jIDEyNzYgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZTI7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19lMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2UyXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBlMTtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19lMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19lMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IGUyIDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMTMwOSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBlMiBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBlMSA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDEzMTUgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgZTEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2UxXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfZTJfIGluXG4gICAgICAgIGxldCBfdiA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDEzMjMgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBsZXQgYiA9IFxuIyAxMjEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAoIFN1YiApXG4jIDEzMjcgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfZTJfIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfZTFfIGluXG4gICAgICAgIFxuIyAxNzEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKCBsb2MgX3N0YXJ0cG9zIF9lbmRwb3MgQEAgQm9wIChiLCBlMSwgZTIpIClcbiMgMTMzNCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBlMjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2UyXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZTJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGUxO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2UxXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2UxXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgZTIgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAxMzY3IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGUyIGluXG4gICAgICAgIGxldCBfMSA6IHVuaXQgPSBPYmoubWFnaWMgXzEgaW5cbiAgICAgICAgbGV0IGUxIDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMTM3MyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBlMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfZTFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19lMl8gaW5cbiAgICAgICAgbGV0IF92IDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMTM4MSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IGxldCBiID0gXG4jIDEyMiBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICggTXVsIClcbiMgMTM4NSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19lMl8gaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19lMV8gaW5cbiAgICAgICAgXG4jIDE3MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAoIGxvYyBfc3RhcnRwb3MgX2VuZHBvcyBAQCBCb3AgKGIsIGUxLCBlMikgKVxuIyAxMzkyIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGUyO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZTJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19lMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZTE7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZTFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZTFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBlMiA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDE0MjUgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgZTIgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgZTEgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAxNDMxIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGUxIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19lMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2UyXyBpblxuICAgICAgICBsZXQgX3YgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAxNDM5IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gbGV0IGIgPSBcbiMgMTIzIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgKCBFcSApXG4jIDE0NDMgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfZTJfIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfZTFfIGluXG4gICAgICAgIFxuIyAxNzEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKCBsb2MgX3N0YXJ0cG9zIF9lbmRwb3MgQEAgQm9wIChiLCBlMSwgZTIpIClcbiMgMTQ1MCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBlMjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2UyXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZTJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGUxO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2UxXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2UxXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgZTIgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAxNDgzIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGUyIGluXG4gICAgICAgIGxldCBfMSA6IHVuaXQgPSBPYmoubWFnaWMgXzEgaW5cbiAgICAgICAgbGV0IGUxIDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMTQ4OSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBlMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfZTFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19lMl8gaW5cbiAgICAgICAgbGV0IF92IDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMTQ5NyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IGxldCBiID0gXG4jIDEyNCBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgKCBOZXEgKVxuIyAxNTAxIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2UyXyBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2UxXyBpblxuICAgICAgICBcbiMgMTcxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICggbG9jIF9zdGFydHBvcyBfZW5kcG9zIEBAIEJvcCAoYiwgZTEsIGUyKSApXG4jIDE1MDggXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZTI7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19lMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2UyXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBlMTtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19lMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19lMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IGUyIDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMTU0MSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBlMiBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBlMSA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDE1NDcgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgZTEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2UxXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfZTJfIGluXG4gICAgICAgIGxldCBfdiA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDE1NTUgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBsZXQgYiA9IFxuIyAxMjUgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgKCBMdCApXG4jIDE1NTkgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfZTJfIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfZTFfIGluXG4gICAgICAgIFxuIyAxNzEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKCBsb2MgX3N0YXJ0cG9zIF9lbmRwb3MgQEAgQm9wIChiLCBlMSwgZTIpIClcbiMgMTU2NiBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBlMjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2UyXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZTJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGUxO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2UxXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2UxXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgZTIgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAxNTk5IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGUyIGluXG4gICAgICAgIGxldCBfMSA6IHVuaXQgPSBPYmoubWFnaWMgXzEgaW5cbiAgICAgICAgbGV0IGUxIDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMTYwNSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBlMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfZTFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19lMl8gaW5cbiAgICAgICAgbGV0IF92IDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMTYxMyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IGxldCBiID0gXG4jIDEyNiBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgKCBMdGUgKVxuIyAxNjE3IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2UyXyBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2UxXyBpblxuICAgICAgICBcbiMgMTcxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICggbG9jIF9zdGFydHBvcyBfZW5kcG9zIEBAIEJvcCAoYiwgZTEsIGUyKSApXG4jIDE2MjQgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZTI7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19lMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2UyXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBlMTtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19lMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19lMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IGUyIDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMTY1NyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBlMiBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBlMSA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDE2NjMgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgZTEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2UxXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfZTJfIGluXG4gICAgICAgIGxldCBfdiA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDE2NzEgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBsZXQgYiA9IFxuIyAxMjcgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgKCBHdCApXG4jIDE2NzUgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfZTJfIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfZTFfIGluXG4gICAgICAgIFxuIyAxNzEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKCBsb2MgX3N0YXJ0cG9zIF9lbmRwb3MgQEAgQm9wIChiLCBlMSwgZTIpIClcbiMgMTY4MiBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBlMjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2UyXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZTJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGUxO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2UxXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2UxXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgZTIgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAxNzE1IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGUyIGluXG4gICAgICAgIGxldCBfMSA6IHVuaXQgPSBPYmoubWFnaWMgXzEgaW5cbiAgICAgICAgbGV0IGUxIDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMTcyMSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBlMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfZTFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19lMl8gaW5cbiAgICAgICAgbGV0IF92IDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMTcyOSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IGxldCBiID0gXG4jIDEyOCBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgKCBHdGUgKVxuIyAxNzMzIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2UyXyBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2UxXyBpblxuICAgICAgICBcbiMgMTcxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICggbG9jIF9zdGFydHBvcyBfZW5kcG9zIEBAIEJvcCAoYiwgZTEsIGUyKSApXG4jIDE3NDAgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZTI7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19lMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2UyXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBlMTtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19lMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19lMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IGUyIDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMTc3MyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBlMiBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBlMSA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDE3NzkgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgZTEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2UxXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfZTJfIGluXG4gICAgICAgIGxldCBfdiA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDE3ODcgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBsZXQgYiA9IFxuIyAxMjkgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICggQW5kIClcbiMgMTc5MSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19lMl8gaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19lMV8gaW5cbiAgICAgICAgXG4jIDE3MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAoIGxvYyBfc3RhcnRwb3MgX2VuZHBvcyBAQCBCb3AgKGIsIGUxLCBlMikgKVxuIyAxNzk4IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGUyO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZTJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19lMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZTE7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZTFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZTFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBlMiA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDE4MzEgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgZTIgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgZTEgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAxODM3IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGUxIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19lMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2UyXyBpblxuICAgICAgICBsZXQgX3YgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAxODQ1IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gbGV0IGIgPSBcbiMgMTMwIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICggT3IgKVxuIyAxODQ5IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2UyXyBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2UxXyBpblxuICAgICAgICBcbiMgMTcxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICggbG9jIF9zdGFydHBvcyBfZW5kcG9zIEBAIEJvcCAoYiwgZTEsIGUyKSApXG4jIDE4NTYgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZTI7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19lMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2UyXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBlMTtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19lMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19lMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IGUyIDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMTg4OSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBlMiBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBlMSA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDE4OTUgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgZTEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2UxXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfZTJfIGluXG4gICAgICAgIGxldCBfdiA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDE5MDMgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBsZXQgYiA9IFxuIyAxMzEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAoIElBbmQgKVxuIyAxOTA3IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2UyXyBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2UxXyBpblxuICAgICAgICBcbiMgMTcxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICggbG9jIF9zdGFydHBvcyBfZW5kcG9zIEBAIEJvcCAoYiwgZTEsIGUyKSApXG4jIDE5MTQgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZTI7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19lMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2UyXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBlMTtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19lMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19lMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IGUyIDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMTk0NyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBlMiBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBlMSA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDE5NTMgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgZTEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2UxXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfZTJfIGluXG4gICAgICAgIGxldCBfdiA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDE5NjEgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBsZXQgYiA9IFxuIyAxMzIgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICggSU9yIClcbiMgMTk2NSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19lMl8gaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19lMV8gaW5cbiAgICAgICAgXG4jIDE3MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAoIGxvYyBfc3RhcnRwb3MgX2VuZHBvcyBAQCBCb3AgKGIsIGUxLCBlMikgKVxuIyAxOTcyIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGUyO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZTJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19lMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZTE7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZTFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZTFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBlMiA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDIwMDUgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgZTIgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgZTEgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAyMDExIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGUxIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19lMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2UyXyBpblxuICAgICAgICBsZXQgX3YgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAyMDE5IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gbGV0IGIgPSBcbiMgMTMzIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgKCBTaGwgKVxuIyAyMDIzIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2UyXyBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2UxXyBpblxuICAgICAgICBcbiMgMTcxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICggbG9jIF9zdGFydHBvcyBfZW5kcG9zIEBAIEJvcCAoYiwgZTEsIGUyKSApXG4jIDIwMzAgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZTI7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19lMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2UyXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBlMTtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19lMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19lMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IGUyIDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMjA2MyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBlMiBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBlMSA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDIwNjkgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgZTEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2UxXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfZTJfIGluXG4gICAgICAgIGxldCBfdiA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDIwNzcgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBsZXQgYiA9IFxuIyAxMzQgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAoIFNociApXG4jIDIwODEgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfZTJfIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfZTFfIGluXG4gICAgICAgIFxuIyAxNzEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKCBsb2MgX3N0YXJ0cG9zIF9lbmRwb3MgQEAgQm9wIChiLCBlMSwgZTIpIClcbiMgMjA4OCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBlMjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2UyXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZTJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGUxO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2UxXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2UxXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgZTIgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAyMTIxIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGUyIGluXG4gICAgICAgIGxldCBfMSA6IHVuaXQgPSBPYmoubWFnaWMgXzEgaW5cbiAgICAgICAgbGV0IGUxIDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMjEyNyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBlMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfZTFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19lMl8gaW5cbiAgICAgICAgbGV0IF92IDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMjEzNSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IGxldCBiID0gXG4jIDEzNSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICggU2FyIClcbiMgMjEzOSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19lMl8gaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19lMV8gaW5cbiAgICAgICAgXG4jIDE3MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAoIGxvYyBfc3RhcnRwb3MgX2VuZHBvcyBAQCBCb3AgKGIsIGUxLCBlMikgKVxuIyAyMTQ2IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGU7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19lXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZV87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBlIDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMjE3MyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBlIGluXG4gICAgICAgIGxldCBfMSA6IHVuaXQgPSBPYmoubWFnaWMgXzEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfZV8gaW5cbiAgICAgICAgbGV0IF92IDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMjE4MiBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IGxldCB1ID0gXG4jIDEzOCBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgKCBOZWcgKVxuIyAyMTg2IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvc191XyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2VfIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfdV8gaW5cbiAgICAgICAgXG4jIDE3MiBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAoIGxvYyBfc3RhcnRwb3MgX2VuZHBvcyBAQCBVb3AgKHUsIGUpIClcbiMgMjE5NCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBlO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZV87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2VfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgZSA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDIyMjEgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgZSBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2VfIGluXG4gICAgICAgIGxldCBfdiA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDIyMzAgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBsZXQgdSA9IFxuIyAxMzkgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICggTG9nbm90IClcbiMgMjIzNCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3NfdV8gPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19lXyBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3VfIGluXG4gICAgICAgIFxuIyAxNzIgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKCBsb2MgX3N0YXJ0cG9zIF9lbmRwb3MgQEAgVW9wICh1LCBlKSApXG4jIDIyNDIgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZTtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2VfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19lXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IGUgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAyMjY5IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGUgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19lXyBpblxuICAgICAgICBsZXQgX3YgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAyMjc4IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gbGV0IHUgPSBcbiMgMTQwIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAoIEJpdG5vdCApXG4jIDIyODIgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zX3VfID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfZV8gaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc191XyBpblxuICAgICAgICBcbiMgMTcyIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICggbG9jIF9zdGFydHBvcyBfZW5kcG9zIEBAIFVvcCAodSwgZSkgKVxuIyAyMjkwIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzNfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fM187XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBlO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19lXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19lXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfMyA6IHVuaXQgPSBPYmoubWFnaWMgXzMgaW5cbiAgICAgICAgbGV0IGUgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAyMzI0IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGUgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fM18gaW5cbiAgICAgICAgbGV0IF92IDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMjMzMyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IFxuIyAxNzMgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKCBlIClcbiMgMjMzNyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQgX21lbmhpcl9zID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLmN1cnJlbnQgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9zdGFydHBvcyBpblxuICAgICAgICBsZXQgX3YgOiAndHZfZXhwX29wdCA9IFxuIyAxODIgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICggTm9uZSApXG4jIDIzNTUgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBlO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZV87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2VfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IGUgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAyMzc2IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGUgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2VfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19lXyBpblxuICAgICAgICBsZXQgX3YgOiAndHZfZXhwX29wdCA9IFxuIyAxODMgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICggU29tZSBlIClcbiMgMjM4NCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18yXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBlO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19lXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19lXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgXzIgOiB1bml0ID0gT2JqLm1hZ2ljIF8yIGluXG4gICAgICAgIGxldCBlIDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMjQxMiBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBlIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19lXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzJfIGluXG4gICAgICAgIGxldCBfdiA6IChcbiMgNzcgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDI0MjAgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBcbiMgODggXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAoIGUgKVxuIyAyNDI0IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gaTtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2lfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19pXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBpIDogKFxuIyAxMSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgKGludDY0KVxuIyAyNDQ1IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGkgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2lfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19pXyBpblxuICAgICAgICBsZXQgX3YgOiAndHZfZ2V4cCA9IGxldCBfZW5kcG9zID0gX2VuZHBvc19pXyBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2lfIGluXG4gICAgICAgIFxuIyAxNDMgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgKCBsb2MgX3N0YXJ0cG9zIF9lbmRwb3MgQEAgQ0ludCBpIClcbiMgMjQ1NSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHM7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19zXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3Nfc187XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgcyA6IChcbiMgMTMgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgIChzdHJpbmcpXG4jIDI0NzYgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgcyBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3Nfc18gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3NfIGluXG4gICAgICAgIGxldCBfdiA6ICd0dl9nZXhwID0gbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3NfIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3Nfc18gaW5cbiAgICAgICAgXG4jIDE0NCBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAoIGxvYyBfc3RhcnRwb3MgX2VuZHBvcyBAQCBDU3RyIHMgKVxuIyAyNDg2IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8yO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfMiA6IHVuaXQgPSBPYmoubWFnaWMgXzIgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fMl8gaW5cbiAgICAgICAgbGV0IF92IDogJ3R2X2dleHAgPSBsZXQgdCA9IFxuIyAxMTYgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgKCBSU3RyaW5nIClcbiMgMjUxOCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3NfdF8gPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fMl8gaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc190XyBpblxuICAgICAgICBcbiMgMTQ1IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgKCBsb2MgX3N0YXJ0cG9zIF9lbmRwb3MgQEAgQ051bGwgdCApXG4jIDI1MjYgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzI7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18yXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8zO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fM187XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzNfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzJfaW5saW5lZDE7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzJfaW5saW5lZDFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzJfaW5saW5lZDFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB0O1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfdF87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3RfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF8yIDogdW5pdCA9IE9iai5tYWdpYyBfMiBpblxuICAgICAgICBsZXQgXzMgOiB1bml0ID0gT2JqLm1hZ2ljIF8zIGluXG4gICAgICAgIGxldCBfMl9pbmxpbmVkMSA6IHVuaXQgPSBPYmoubWFnaWMgXzJfaW5saW5lZDEgaW5cbiAgICAgICAgbGV0IHQgOiAoXG4jIDg0IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QudHkpXG4jIDI1NjggXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgdCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfdF8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX18yXyBpblxuICAgICAgICBsZXQgX3YgOiAndHZfZ2V4cCA9IGxldCB0ID1cbiAgICAgICAgICBsZXQgXzIgPSBfMl9pbmxpbmVkMSBpblxuICAgICAgICAgIFxuIyAxMTcgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBSQXJyYXkgdCApXG4jIDI1NzggXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICAgXG4gICAgICAgIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fMl8gaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc190XyBpblxuICAgICAgICBcbiMgMTQ1IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgKCBsb2MgX3N0YXJ0cG9zIF9lbmRwb3MgQEAgQ051bGwgdCApXG4jIDI1ODYgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF92IDogJ3R2X2dleHAgPSBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIFxuIyAxNDYgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgKGxvYyBfc3RhcnRwb3MgX2VuZHBvcyBAQCBDQm9vbCB0cnVlIClcbiMgMjYxMyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX18xXyBpblxuICAgICAgICBsZXQgX3YgOiAndHZfZ2V4cCA9IGxldCBfZW5kcG9zID0gX2VuZHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgXG4jIDE0NyBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgKGxvYyBfc3RhcnRwb3MgX2VuZHBvcyBAQCBDQm9vbCBmYWxzZSApXG4jIDI2NDAgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzc7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fN187XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX183XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHhzO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc194c187XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeHNfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzU7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzVfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzVfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzQ7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fNF87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX180XztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8zO1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fM187XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzNfO1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gdDtcbiAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc190XztcbiAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3RfO1xuICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF83IDogdW5pdCA9IE9iai5tYWdpYyBfNyBpblxuICAgICAgICBsZXQgeHMgOiAndHZfbG9wdGlvbl9zZXBhcmF0ZWRfbm9uZW1wdHlfbGlzdF9DT01NQV9nZXhwX18gPSBPYmoubWFnaWMgeHMgaW5cbiAgICAgICAgbGV0IF81IDogdW5pdCA9IE9iai5tYWdpYyBfNSBpblxuICAgICAgICBsZXQgXzQgOiB1bml0ID0gT2JqLm1hZ2ljIF80IGluXG4gICAgICAgIGxldCBfMyA6IHVuaXQgPSBPYmoubWFnaWMgXzMgaW5cbiAgICAgICAgbGV0IHQgOiAoXG4jIDg0IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QudHkpXG4jIDI3MDIgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgdCBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX183XyBpblxuICAgICAgICBsZXQgX3YgOiAndHZfZ2V4cCA9IGxldCBlcyA9IFxuIyAyMzIgXCI8c3RhbmRhcmQubWx5PlwiXG4gICAgKCB4cyApXG4jIDI3MTEgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzdfIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIFxuIyAxNDkgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICggbG9jIF9zdGFydHBvcyBfZW5kcG9zIEBAIENBcnIodCwgZXMpIClcbiMgMjcxOCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBiMjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2IyXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfYjJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gYjE7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2IxXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19iMV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfNDtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fNF87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fNF87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBlO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZV87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2VfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzI7XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18yXztcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMl87XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgYjIgOiAndHZfZWxzZV9zdG10ID0gT2JqLm1hZ2ljIGIyIGluXG4gICAgICAgIGxldCBiMSA6IChcbiMgODMgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5ibG9jaylcbiMgMjc3MCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBiMSBpblxuICAgICAgICBsZXQgXzQgOiB1bml0ID0gT2JqLm1hZ2ljIF80IGluXG4gICAgICAgIGxldCBlIDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMjc3NiBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBlIGluXG4gICAgICAgIGxldCBfMiA6IHVuaXQgPSBPYmoubWFnaWMgXzIgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19iMl8gaW5cbiAgICAgICAgbGV0IF92IDogJ3R2X2lmX3N0bXQgPSBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfYjJfIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIFxuIyAyMDcgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICggbG9jIF9zdGFydHBvcyBfZW5kcG9zIEBAIElmKGUsYjEsYjIpIClcbiMgMjc4OCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGlkO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfaWRfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19pZF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgaWQgOiAoXG4jIDE0IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAyODA5IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGlkIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19pZF8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2lkXyBpblxuICAgICAgICBsZXQgX3YgOiAndHZfbGhzID0gbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2lkXyBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2lkXyBpblxuICAgICAgICBcbiMgMTUyIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICggbG9jIF9zdGFydHBvcyBfZW5kcG9zIEBAIElkIGlkIClcbiMgMjgxOSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfNDtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX180XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzRfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gaTtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfaV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfaV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMjtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMl87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMl87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGU7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19lXztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZV87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgXzQgOiB1bml0ID0gT2JqLm1hZ2ljIF80IGluXG4gICAgICAgIGxldCBpIDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMjg1OSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBpIGluXG4gICAgICAgIGxldCBfMiA6IHVuaXQgPSBPYmoubWFnaWMgXzIgaW5cbiAgICAgICAgbGV0IGUgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAyODY1IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGUgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2VfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fNF8gaW5cbiAgICAgICAgbGV0IF92IDogJ3R2X2xocyA9IGxldCBfZW5kcG9zID0gX2VuZHBvc19fNF8gaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19lXyBpblxuICAgICAgICBcbiMgMTU0IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICggbG9jIF9zdGFydHBvcyBfZW5kcG9zIEBAIEluZGV4IChlLCBpKSApXG4jIDI4NzUgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfcyA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5jdXJyZW50IGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfc3RhcnRwb3MgaW5cbiAgICAgICAgbGV0IF92IDogJ3R2X2xpc3RfZGVjbF8gPSBcbiMgMjExIFwiPHN0YW5kYXJkLm1seT5cIlxuICAgICggW10gKVxuIyAyODkzIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHhzO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfeHNfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc194c187XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHg7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3hfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3hfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCB4cyA6ICd0dl9saXN0X2RlY2xfID0gT2JqLm1hZ2ljIHhzIGluXG4gICAgICAgIGxldCB4IDogJ3R2X2RlY2wgPSBPYmoubWFnaWMgeCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfeF8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3hzXyBpblxuICAgICAgICBsZXQgX3YgOiAndHZfbGlzdF9kZWNsXyA9IFxuIyAyMTMgXCI8c3RhbmRhcmQubWx5PlwiXG4gICAgKCB4IDo6IHhzIClcbiMgMjkyNSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQgX21lbmhpcl9zID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLmN1cnJlbnQgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9zdGFydHBvcyBpblxuICAgICAgICBsZXQgX3YgOiAndHZfbGlzdF9zdG10XyA9IFxuIyAyMTEgXCI8c3RhbmRhcmQubWx5PlwiXG4gICAgKCBbXSApXG4jIDI5NDMgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0geHM7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc194c187XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3hzXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0geDtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfeF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IHhzIDogJ3R2X2xpc3Rfc3RtdF8gPSBPYmoubWFnaWMgeHMgaW5cbiAgICAgICAgbGV0IHggOiAoXG4jIDgyIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3Quc3RtdCBBc3Qubm9kZSlcbiMgMjk3MSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyB4IGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc194XyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfeHNfIGluXG4gICAgICAgIGxldCBfdiA6ICd0dl9saXN0X3N0bXRfID0gXG4jIDIxMyBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIHggOjogeHMgKVxuIyAyOTc5IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCBfbWVuaGlyX3MgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuY3VycmVudCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX3N0YXJ0cG9zIGluXG4gICAgICAgIGxldCBfdiA6ICd0dl9sb3B0aW9uX3NlcGFyYXRlZF9ub25lbXB0eV9saXN0X0NPTU1BX2V4cF9fID0gXG4jIDE0MiBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIFtdIClcbiMgMjk5NyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHg7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc194XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgeCA6ICd0dl9zZXBhcmF0ZWRfbm9uZW1wdHlfbGlzdF9DT01NQV9leHBfID0gT2JqLm1hZ2ljIHggaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3hfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc194XyBpblxuICAgICAgICBsZXQgX3YgOiAndHZfbG9wdGlvbl9zZXBhcmF0ZWRfbm9uZW1wdHlfbGlzdF9DT01NQV9leHBfXyA9IFxuIyAxNDQgXCI8c3RhbmRhcmQubWx5PlwiXG4gICAgKCB4IClcbiMgMzAyMiBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQgX21lbmhpcl9zID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLmN1cnJlbnQgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9zdGFydHBvcyBpblxuICAgICAgICBsZXQgX3YgOiAndHZfbG9wdGlvbl9zZXBhcmF0ZWRfbm9uZW1wdHlfbGlzdF9DT01NQV9nZXhwX18gPSBcbiMgMTQyIFwiPHN0YW5kYXJkLm1seT5cIlxuICAgICggW10gKVxuIyAzMDQwIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0geDtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3hfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc194XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCB4IDogJ3R2X3NlcGFyYXRlZF9ub25lbXB0eV9saXN0X0NPTU1BX2dleHBfID0gT2JqLm1hZ2ljIHggaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3hfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc194XyBpblxuICAgICAgICBsZXQgX3YgOiAndHZfbG9wdGlvbl9zZXBhcmF0ZWRfbm9uZW1wdHlfbGlzdF9DT01NQV9nZXhwX18gPSBcbiMgMTQ0IFwiPHN0YW5kYXJkLm1seT5cIlxuICAgICggeCApXG4jIDMwNjUgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfcyA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5jdXJyZW50IGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfc3RhcnRwb3MgaW5cbiAgICAgICAgbGV0IF92IDogJ3R2X2xvcHRpb25fc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQ09NTUFfcGFpcl90eV9JREVOVF9fXyA9IFxuIyAxNDIgXCI8c3RhbmRhcmQubWx5PlwiXG4gICAgKCBbXSApXG4jIDMwODMgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB4O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfeF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3hfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IHggOiAndHZfc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQ09NTUFfcGFpcl90eV9JREVOVF9fID0gT2JqLm1hZ2ljIHggaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3hfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc194XyBpblxuICAgICAgICBsZXQgX3YgOiAndHZfbG9wdGlvbl9zZXBhcmF0ZWRfbm9uZW1wdHlfbGlzdF9DT01NQV9wYWlyX3R5X0lERU5UX19fID0gXG4jIDE0NCBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIHggKVxuIyAzMTA4IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCBfbWVuaGlyX3MgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuY3VycmVudCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX3N0YXJ0cG9zIGluXG4gICAgICAgIGxldCBfdiA6ICd0dl9sb3B0aW9uX3NlcGFyYXRlZF9ub25lbXB0eV9saXN0X0NPTU1BX3ZkZWNsX18gPSBcbiMgMTQyIFwiPHN0YW5kYXJkLm1seT5cIlxuICAgICggW10gKVxuIyAzMTI2IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0geDtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3hfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc194XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCB4IDogJ3R2X3NlcGFyYXRlZF9ub25lbXB0eV9saXN0X0NPTU1BX3ZkZWNsXyA9IE9iai5tYWdpYyB4IGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc194XyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfeF8gaW5cbiAgICAgICAgbGV0IF92IDogJ3R2X2xvcHRpb25fc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQ09NTUFfdmRlY2xfXyA9IFxuIyAxNDQgXCI8c3RhbmRhcmQubWx5PlwiXG4gICAgKCB4IClcbiMgMzE1MSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18yXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBwO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19wXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19wXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgXzIgOiB1bml0ID0gT2JqLm1hZ2ljIF8yIGluXG4gICAgICAgIGxldCBwIDogJ3R2X2xpc3RfZGVjbF8gPSBPYmoubWFnaWMgcCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfcF8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX18yXyBpblxuICAgICAgICBsZXQgX3YgOiAoXG4jIDgwIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QucHJvZylcbiMgMzE4MyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IFxuIyA5NCBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgKCBwIClcbiMgMzE4NyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHg7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc194XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgeCA6IChcbiMgODEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDMyMDggXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgeCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfeF8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3hfIGluXG4gICAgICAgIGxldCBfdiA6ICd0dl9zZXBhcmF0ZWRfbm9uZW1wdHlfbGlzdF9DT01NQV9leHBfID0gXG4jIDI0MSBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIFsgeCBdIClcbiMgMzIxNiBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB4cztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3hzXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeHNfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzI7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18yXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMl87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHg7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfeF87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc194XztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgeHMgOiAndHZfc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQ09NTUFfZXhwXyA9IE9iai5tYWdpYyB4cyBpblxuICAgICAgICBsZXQgXzIgOiB1bml0ID0gT2JqLm1hZ2ljIF8yIGluXG4gICAgICAgIGxldCB4IDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMzI1MSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyB4IGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc194XyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfeHNfIGluXG4gICAgICAgIGxldCBfdiA6ICd0dl9zZXBhcmF0ZWRfbm9uZW1wdHlfbGlzdF9DT01NQV9leHBfID0gXG4jIDI0MyBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIHggOjogeHMgKVxuIyAzMjU5IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0geDtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3hfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc194XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCB4IDogJ3R2X2dleHAgPSBPYmoubWFnaWMgeCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfeF8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3hfIGluXG4gICAgICAgIGxldCBfdiA6ICd0dl9zZXBhcmF0ZWRfbm9uZW1wdHlfbGlzdF9DT01NQV9nZXhwXyA9IFxuIyAyNDEgXCI8c3RhbmRhcmQubWx5PlwiXG4gICAgKCBbIHggXSApXG4jIDMyODQgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0geHM7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc194c187XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3hzXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8yO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMl87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzJfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB4O1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3hfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeF87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IHhzIDogJ3R2X3NlcGFyYXRlZF9ub25lbXB0eV9saXN0X0NPTU1BX2dleHBfID0gT2JqLm1hZ2ljIHhzIGluXG4gICAgICAgIGxldCBfMiA6IHVuaXQgPSBPYmoubWFnaWMgXzIgaW5cbiAgICAgICAgbGV0IHggOiAndHZfZ2V4cCA9IE9iai5tYWdpYyB4IGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc194XyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfeHNfIGluXG4gICAgICAgIGxldCBfdiA6ICd0dl9zZXBhcmF0ZWRfbm9uZW1wdHlfbGlzdF9DT01NQV9nZXhwXyA9IFxuIyAyNDMgXCI8c3RhbmRhcmQubWx5PlwiXG4gICAgKCB4IDo6IHhzIClcbiMgMzMyMyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB5O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfeV87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3lfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB4O1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc194XztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc194XztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgeSA6IChcbiMgMTQgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgIChzdHJpbmcpXG4jIDMzNTAgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgeSBpblxuICAgICAgICBsZXQgeCA6IChcbiMgODQgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC50eSlcbiMgMzM1NSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyB4IGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc194XyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfeV8gaW5cbiAgICAgICAgbGV0IF92IDogJ3R2X3NlcGFyYXRlZF9ub25lbXB0eV9saXN0X0NPTU1BX3BhaXJfdHlfSURFTlRfXyA9IGxldCB4ID0gXG4jIDE2NyBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoICh4LCB5KSApXG4jIDMzNjMgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICBcbiMgMjQxIFwiPHN0YW5kYXJkLm1seT5cIlxuICAgICggWyB4IF0gKVxuIyAzMzY4IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHhzO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfeHNfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc194c187XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMjtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzJfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18yXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHk7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfeV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc195XztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0geDtcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3hfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc194XztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCB4cyA6ICd0dl9zZXBhcmF0ZWRfbm9uZW1wdHlfbGlzdF9DT01NQV9wYWlyX3R5X0lERU5UX18gPSBPYmoubWFnaWMgeHMgaW5cbiAgICAgICAgbGV0IF8yIDogdW5pdCA9IE9iai5tYWdpYyBfMiBpblxuICAgICAgICBsZXQgeSA6IChcbiMgMTQgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgIChzdHJpbmcpXG4jIDM0MDkgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgeSBpblxuICAgICAgICBsZXQgeCA6IChcbiMgODQgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC50eSlcbiMgMzQxNCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyB4IGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc194XyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfeHNfIGluXG4gICAgICAgIGxldCBfdiA6ICd0dl9zZXBhcmF0ZWRfbm9uZW1wdHlfbGlzdF9DT01NQV9wYWlyX3R5X0lERU5UX18gPSBsZXQgeCA9IFxuIyAxNjcgXCI8c3RhbmRhcmQubWx5PlwiXG4gICAgKCAoeCwgeSkgKVxuIyAzNDIyIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgXG4jIDI0MyBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIHggOjogeHMgKVxuIyAzNDI3IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0geDtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3hfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc194XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCB4IDogJ3R2X3ZkZWNsID0gT2JqLm1hZ2ljIHggaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3hfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc194XyBpblxuICAgICAgICBsZXQgX3YgOiAndHZfc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQ09NTUFfdmRlY2xfID0gXG4jIDI0MSBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIFsgeCBdIClcbiMgMzQ1MiBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB4cztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3hzXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeHNfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzI7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18yXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMl87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHg7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfeF87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc194XztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgeHMgOiAndHZfc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQ09NTUFfdmRlY2xfID0gT2JqLm1hZ2ljIHhzIGluXG4gICAgICAgIGxldCBfMiA6IHVuaXQgPSBPYmoubWFnaWMgXzIgaW5cbiAgICAgICAgbGV0IHggOiAndHZfdmRlY2wgPSBPYmoubWFnaWMgeCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfeF8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3hzXyBpblxuICAgICAgICBsZXQgX3YgOiAndHZfc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQ09NTUFfdmRlY2xfID0gXG4jIDI0MyBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIHggOjogeHMgKVxuIyAzNDkxIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8yO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGQ7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2RfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2RfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfMiA6IHVuaXQgPSBPYmoubWFnaWMgXzIgaW5cbiAgICAgICAgbGV0IGQgOiAndHZfdmRlY2wgPSBPYmoubWFnaWMgZCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfZF8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX18yXyBpblxuICAgICAgICBsZXQgX3YgOiAoXG4jIDgyIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3Quc3RtdCBBc3Qubm9kZSlcbiMgMzUyMyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IGxldCBfZW5kcG9zID0gX2VuZHBvc19fMl8gaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19kXyBpblxuICAgICAgICBcbiMgMTkwIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICggbG9jIF9zdGFydHBvcyBfZW5kcG9zIEBAIERlY2woZCkgKVxuIyAzNTI5IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF80O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzRfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fNF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBlO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19lXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19lXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8yO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18yXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18yXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gcDtcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3BfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19wXztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfNCA6IHVuaXQgPSBPYmoubWFnaWMgXzQgaW5cbiAgICAgICAgbGV0IGUgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAzNTY5IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGUgaW5cbiAgICAgICAgbGV0IF8yIDogdW5pdCA9IE9iai5tYWdpYyBfMiBpblxuICAgICAgICBsZXQgcCA6ICd0dl9saHMgPSBPYmoubWFnaWMgcCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfcF8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX180XyBpblxuICAgICAgICBsZXQgX3YgOiAoXG4jIDgyIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3Quc3RtdCBBc3Qubm9kZSlcbiMgMzU3OSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IGxldCBfZW5kcG9zID0gX2VuZHBvc19fNF8gaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19wXyBpblxuICAgICAgICBcbiMgMTkxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICggbG9jIF9zdGFydHBvcyBfZW5kcG9zIEBAIEFzc24ocCxlKSApXG4jIDM1ODUgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzU7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fNV87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX181XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF80O1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fNF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzRfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0geHM7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfeHNfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeHNfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzI7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMl87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18yXztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZTtcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZV87XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZV87XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF81IDogdW5pdCA9IE9iai5tYWdpYyBfNSBpblxuICAgICAgICBsZXQgXzQgOiB1bml0ID0gT2JqLm1hZ2ljIF80IGluXG4gICAgICAgIGxldCB4cyA6ICd0dl9sb3B0aW9uX3NlcGFyYXRlZF9ub25lbXB0eV9saXN0X0NPTU1BX2V4cF9fID0gT2JqLm1hZ2ljIHhzIGluXG4gICAgICAgIGxldCBfMiA6IHVuaXQgPSBPYmoubWFnaWMgXzIgaW5cbiAgICAgICAgbGV0IGUgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAzNjM0IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGUgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2VfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fNV8gaW5cbiAgICAgICAgbGV0IF92IDogKFxuIyA4MiBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LnN0bXQgQXN0Lm5vZGUpXG4jIDM2NDIgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBsZXQgZXMgPSBcbiMgMjMyIFwiPHN0YW5kYXJkLm1seT5cIlxuICAgICggeHMgKVxuIyAzNjQ2IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX181XyBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2VfIGluXG4gICAgICAgIFxuIyAxOTMgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKCBsb2MgX3N0YXJ0cG9zIF9lbmRwb3MgQEAgU0NhbGwgKGUsIGVzKSApXG4jIDM2NTMgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBpZnM7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19pZnNfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19pZnNfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IGlmcyA6ICd0dl9pZl9zdG10ID0gT2JqLm1hZ2ljIGlmcyBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfaWZzXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfaWZzXyBpblxuICAgICAgICBsZXQgX3YgOiAoXG4jIDgyIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3Quc3RtdCBBc3Qubm9kZSlcbiMgMzY3OCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IFxuIyAxOTQgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKCBpZnMgKVxuIyAzNjgyIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8yO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfMiA6IHVuaXQgPSBPYmoubWFnaWMgXzIgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fMl8gaW5cbiAgICAgICAgbGV0IF92IDogKFxuIyA4MiBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LnN0bXQgQXN0Lm5vZGUpXG4jIDM3MTQgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzJfIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIFxuIyAxOTUgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKCBsb2MgX3N0YXJ0cG9zIF9lbmRwb3MgQEAgUmV0KE5vbmUpIClcbiMgMzcyMCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18zXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzNfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gZTtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgXzMgOiB1bml0ID0gT2JqLm1hZ2ljIF8zIGluXG4gICAgICAgIGxldCBlIDogKFxuIyA4MSBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmV4cCBBc3Qubm9kZSlcbiMgMzc1NCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBlIGluXG4gICAgICAgIGxldCBfMSA6IHVuaXQgPSBPYmoubWFnaWMgXzEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzNfIGluXG4gICAgICAgIGxldCBfdiA6IChcbiMgODIgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5zdG10IEFzdC5ub2RlKVxuIyAzNzYzIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gbGV0IF9lbmRwb3MgPSBfZW5kcG9zX18zXyBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBcbiMgMTk2IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICggbG9jIF9zdGFydHBvcyBfZW5kcG9zIEBAIFJldChTb21lIGUpIClcbiMgMzc2OSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBiO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfYl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2JfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzQ7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX180XztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fNF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBlO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2VfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfZV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMjtcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18yXztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzJfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgYiA6IChcbiMgODMgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5ibG9jaylcbiMgMzgxNCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyBiIGluXG4gICAgICAgIGxldCBfNCA6IHVuaXQgPSBPYmoubWFnaWMgXzQgaW5cbiAgICAgICAgbGV0IGUgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyAzODIwIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGUgaW5cbiAgICAgICAgbGV0IF8yIDogdW5pdCA9IE9iai5tYWdpYyBfMiBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2JfIGluXG4gICAgICAgIGxldCBfdiA6IChcbiMgODIgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5zdG10IEFzdC5ub2RlKVxuIyAzODMwIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gbGV0IF9lbmRwb3MgPSBfZW5kcG9zX2JfIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIFxuIyAxOTggXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKCBsb2MgX3N0YXJ0cG9zIF9lbmRwb3MgQEAgV2hpbGUoZSwgYikgKVxuIyAzODM2IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGI7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19iXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfYl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfODtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzhfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX184XztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHM7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3Nfc187XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19zXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF82O1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzZfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fNl87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBlO1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19lXztcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19lXztcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF80O1xuICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX180XztcbiAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX180XztcbiAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGRzO1xuICAgICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfZHNfO1xuICAgICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19kc187XG4gICAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzJfO1xuICAgICAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18yXztcbiAgICAgICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBiIDogKFxuIyA4MyBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LmJsb2NrKVxuIyAzOTA1IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGIgaW5cbiAgICAgICAgbGV0IF84IDogdW5pdCA9IE9iai5tYWdpYyBfOCBpblxuICAgICAgICBsZXQgcyA6ICd0dl9zdG10X29wdCA9IE9iai5tYWdpYyBzIGluXG4gICAgICAgIGxldCBfNiA6IHVuaXQgPSBPYmoubWFnaWMgXzYgaW5cbiAgICAgICAgbGV0IGUgOiAndHZfZXhwX29wdCA9IE9iai5tYWdpYyBlIGluXG4gICAgICAgIGxldCBfNCA6IHVuaXQgPSBPYmoubWFnaWMgXzQgaW5cbiAgICAgICAgbGV0IGRzIDogJ3R2X3ZkZWNscyA9IE9iai5tYWdpYyBkcyBpblxuICAgICAgICBsZXQgXzIgOiB1bml0ID0gT2JqLm1hZ2ljIF8yIGluXG4gICAgICAgIGxldCBfMSA6IHVuaXQgPSBPYmoubWFnaWMgXzEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfYl8gaW5cbiAgICAgICAgbGV0IF92IDogKFxuIyA4MiBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LnN0bXQgQXN0Lm5vZGUpXG4jIDM5MjEgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfYl8gaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgXG4jIDIwMCBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAoIGxvYyBfc3RhcnRwb3MgX2VuZHBvcyBAQCBGb3IoZHMsIGUsIHMsIGIpIClcbiMgMzkyNyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQgX21lbmhpcl9zID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLmN1cnJlbnQgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9zdGFydHBvcyBpblxuICAgICAgICBsZXQgX3YgOiAndHZfc3RtdF9vcHQgPSBcbiMgMTg2IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAoIE5vbmUgKVxuIyAzOTQ1IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3NfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19zXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBzIDogKFxuIyA4MiBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LnN0bXQgQXN0Lm5vZGUpXG4jIDM5NjYgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgcyBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3Nfc18gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3NfIGluXG4gICAgICAgIGxldCBfdiA6ICd0dl9zdG10X29wdCA9IFxuIyAxODcgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAoIFNvbWUgcyApXG4jIDM5NzQgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzI7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18yXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gcztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3Nfc187XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3Nfc187XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF8yIDogdW5pdCA9IE9iai5tYWdpYyBfMiBpblxuICAgICAgICBsZXQgcyA6IChcbiMgODIgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5zdG10IEFzdC5ub2RlKVxuIyA0MDAyIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIHMgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3NfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fMl8gaW5cbiAgICAgICAgbGV0IF92IDogKFxuIyA3OCBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LnN0bXQgQXN0Lm5vZGUpXG4jIDQwMTAgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBcbiMgOTEgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgKCBzIClcbiMgNDAxNCBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX18xXyBpblxuICAgICAgICBsZXQgX3YgOiAoXG4jIDg0IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QudHkpXG4jIDQwMzkgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBcbiMgMTA2IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgKCBUSW50IClcbiMgNDA0MyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX18xXyBpblxuICAgICAgICBsZXQgX3YgOiAoXG4jIDg0IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QudHkpXG4jIDQwNjggXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBcbiMgMTA3IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgKCBUQm9vbCApXG4jIDQwNzIgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF92IDogKFxuIyA4NCBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LnR5KVxuIyA0MDk3IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gbGV0IHIgPSBcbiMgMTE2IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICggUlN0cmluZyApXG4jIDQxMDEgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICBcbiMgMTA4IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgKCBUUmVmIHIgKVxuIyA0MTA2IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzNfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fM187XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMjtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzJfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18yXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gdDtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc190XztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3RfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfMyA6IHVuaXQgPSBPYmoubWFnaWMgXzMgaW5cbiAgICAgICAgbGV0IF8yIDogdW5pdCA9IE9iai5tYWdpYyBfMiBpblxuICAgICAgICBsZXQgdCA6IChcbiMgODQgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC50eSlcbiMgNDE0MSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyB0IGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc190XyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzNfIGluXG4gICAgICAgIGxldCBfdiA6IChcbiMgODQgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC50eSlcbiMgNDE0OSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IGxldCByID0gXG4jIDExNyBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoIFJBcnJheSB0IClcbiMgNDE1MyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIFxuIyAxMDggXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAoIFRSZWYgciApXG4jIDQxNTggXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gaW5pdDtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2luaXRfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19pbml0XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8zO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fM187XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzNfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gaWQ7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfaWRfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfaWRfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IGluaXQgOiAoXG4jIDgxIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QuZXhwIEFzdC5ub2RlKVxuIyA0MTk3IFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGluaXQgaW5cbiAgICAgICAgbGV0IF8zIDogdW5pdCA9IE9iai5tYWdpYyBfMyBpblxuICAgICAgICBsZXQgaWQgOiAoXG4jIDE0IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyA0MjAzIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIGlkIGluXG4gICAgICAgIGxldCBfMSA6IHVuaXQgPSBPYmoubWFnaWMgXzEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfaW5pdF8gaW5cbiAgICAgICAgbGV0IF92IDogJ3R2X3ZkZWNsID0gXG4jIDE3NiBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICggKGlkLCBpbml0KSApXG4jIDQyMTIgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB4cztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3hzXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeHNfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IHhzIDogJ3R2X2xvcHRpb25fc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQ09NTUFfdmRlY2xfXyA9IE9iai5tYWdpYyB4cyBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfeHNfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc194c18gaW5cbiAgICAgICAgbGV0IF92IDogJ3R2X3ZkZWNscyA9IGxldCBkcyA9IFxuIyAyMzIgXCI8c3RhbmRhcmQubWx5PlwiXG4gICAgKCB4cyApXG4jIDQyMzcgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICBcbiMgMTc5IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggZHMgKVxuIyA0MjQyIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgfF1cbiAgXG4gIGFuZCB0cmFjZSA9XG4gICAgTm9uZVxuICBcbmVuZFxuXG5tb2R1bGUgTWVuaGlySW50ZXJwcmV0ZXIgPSBzdHJ1Y3RcbiAgXG4gIG1vZHVsZSBFVCA9IE1lbmhpckxpYi5UYWJsZUludGVycHJldGVyLk1ha2VFbmdpbmVUYWJsZSAoVGFibGVzKVxuICBcbiAgbW9kdWxlIFRJID0gTWVuaGlyTGliLkVuZ2luZS5NYWtlIChFVClcbiAgXG4gIGluY2x1ZGUgVElcbiAgXG5lbmRcblxubGV0IHN0bXRfdG9wID1cbiAgZnVuIGxleGVyIGxleGJ1ZiAtPlxuICAgIChPYmoubWFnaWMgKE1lbmhpckludGVycHJldGVyLmVudHJ5IDE4OSBsZXhlciBsZXhidWYpIDogKFxuIyA3OCBcImh3MDMvcGFyc2VyLm1seVwiXG4gICAgICAoQXN0LnN0bXQgQXN0Lm5vZGUpXG4jIDQyNzMgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgKSlcblxuYW5kIHByb2cgPVxuICBmdW4gbGV4ZXIgbGV4YnVmIC0+XG4gICAgKE9iai5tYWdpYyAoTWVuaGlySW50ZXJwcmV0ZXIuZW50cnkgNzggbGV4ZXIgbGV4YnVmKSA6IChcbiMgODAgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5wcm9nKVxuIyA0MjgxIFwiaHcwMy9wYXJzZXIubWxcIlxuICAgICkpXG5cbmFuZCBleHBfdG9wID1cbiAgZnVuIGxleGVyIGxleGJ1ZiAtPlxuICAgIChPYmoubWFnaWMgKE1lbmhpckludGVycHJldGVyLmVudHJ5IDAgbGV4ZXIgbGV4YnVmKSA6IChcbiMgNzcgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDQyODkgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgKSlcblxubW9kdWxlIEluY3JlbWVudGFsID0gc3RydWN0XG4gIFxuICBsZXQgc3RtdF90b3AgPVxuICAgIGZ1biBpbml0aWFsX3Bvc2l0aW9uIC0+XG4gICAgICAoT2JqLm1hZ2ljIChNZW5oaXJJbnRlcnByZXRlci5zdGFydCAxODkgaW5pdGlhbF9wb3NpdGlvbikgOiAoXG4jIDc4IFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3Quc3RtdCBBc3Qubm9kZSlcbiMgNDI5OSBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICkgTWVuaGlySW50ZXJwcmV0ZXIuY2hlY2twb2ludClcbiAgXG4gIGFuZCBwcm9nID1cbiAgICBmdW4gaW5pdGlhbF9wb3NpdGlvbiAtPlxuICAgICAgKE9iai5tYWdpYyAoTWVuaGlySW50ZXJwcmV0ZXIuc3RhcnQgNzggaW5pdGlhbF9wb3NpdGlvbikgOiAoXG4jIDgwIFwiaHcwMy9wYXJzZXIubWx5XCJcbiAgICAgIChBc3QucHJvZylcbiMgNDMwNyBcImh3MDMvcGFyc2VyLm1sXCJcbiAgICAgICkgTWVuaGlySW50ZXJwcmV0ZXIuY2hlY2twb2ludClcbiAgXG4gIGFuZCBleHBfdG9wID1cbiAgICBmdW4gaW5pdGlhbF9wb3NpdGlvbiAtPlxuICAgICAgKE9iai5tYWdpYyAoTWVuaGlySW50ZXJwcmV0ZXIuc3RhcnQgMCBpbml0aWFsX3Bvc2l0aW9uKSA6IChcbiMgNzcgXCJodzAzL3BhcnNlci5tbHlcIlxuICAgICAgKEFzdC5leHAgQXN0Lm5vZGUpXG4jIDQzMTUgXCJodzAzL3BhcnNlci5tbFwiXG4gICAgICApIE1lbmhpckludGVycHJldGVyLmNoZWNrcG9pbnQpXG4gIFxuZW5kXG5cbiMgMjY5IFwiPHN0YW5kYXJkLm1seT5cIlxuICBcblxuIyA0MzIzIFwiaHcwMy9wYXJzZXIubWxcIlxuIiwiJXtcbm9wZW4gQXN0XG5cbmxldCBsb2MgKHN0YXJ0cG9zOkxleGluZy5wb3NpdGlvbikgKGVuZHBvczpMZXhpbmcucG9zaXRpb24pIChlbHQ6J2EpIDogJ2Egbm9kZSA9XG4gIHsgZWx0IDsgbG9jPVJhbmdlLm1rX2xleF9yYW5nZSBzdGFydHBvcyBlbmRwb3MgfVxuXG4lfVxuXG4vKiBEZWNsYXJlIHlvdXIgdG9rZW5zIGhlcmUuICovXG4ldG9rZW4gRU9GXG4ldG9rZW4gPGludDY0PiAgSU5UXG4ldG9rZW4gTlVMTFxuJXRva2VuIDxzdHJpbmc+IFNUUklOR1xuJXRva2VuIDxzdHJpbmc+IElERU5UXG5cbiV0b2tlbiBUSU5UICAgICAvKiBpbnQgKi9cbiV0b2tlbiBUVk9JRCAgICAvKiB2b2lkICovXG4ldG9rZW4gVFNUUklORyAgLyogc3RyaW5nICovXG4ldG9rZW4gVEJPT0wgICAgLyogYm9vbCAqL1xuJXRva2VuIE5FVyAgICAgIC8qIG5ldyAqL1xuJXRva2VuIFRSVUUgICAgIC8qIHRydWUgKi9cbiV0b2tlbiBGQUxTRSAgICAvKiBmYWxzZSAqL1xuJXRva2VuIElGICAgICAgIC8qIGlmICovXG4ldG9rZW4gRUxTRSAgICAgLyogZWxzZSAqL1xuJXRva2VuIFdISUxFICAgIC8qIHdoaWxlICovXG4ldG9rZW4gRk9SICAgICAgLyogZm9yICovXG4ldG9rZW4gUkVUVVJOICAgLyogcmV0dXJuICovXG4ldG9rZW4gVkFSICAgICAgLyogdmFyICovXG4ldG9rZW4gU0VNSSAgICAgLyogOyAqL1xuJXRva2VuIENPTU1BICAgIC8qICwgKi9cbiV0b2tlbiBMQlJBQ0UgICAvKiB7ICovXG4ldG9rZW4gUkJSQUNFICAgLyogfSAqL1xuJXRva2VuIExQQVJFTiAgIC8qICggKi9cbiV0b2tlbiBSUEFSRU4gICAvKiApICovXG4ldG9rZW4gTEJSQUNLRVQgLyogWyAqL1xuJXRva2VuIFJCUkFDS0VUIC8qIF0gKi9cbiV0b2tlbiBFUSAgICAgICAvKiA9ICovXG4ldG9rZW4gUExVUyAgICAgLyogKyAqL1xuJXRva2VuIERBU0ggICAgIC8qIC0gKi9cbiV0b2tlbiBTVEFSICAgICAvKiAqICovXG4ldG9rZW4gRVFFUSAgICAgLyogPT0gKi9cbiV0b2tlbiBORVEgICAgICAvKiAhPSAqL1xuJXRva2VuIExUICAgICAgIC8qIDwgKi9cbiV0b2tlbiBMVEUgICAgICAvKiA8PSAqL1xuJXRva2VuIEdUICAgICAgIC8qID4gKi9cbiV0b2tlbiBHVEUgICAgICAvKiA+PSAqL1xuJXRva2VuIEFORCAgICAgLyogJiAqL1xuJXRva2VuIE9SICAgICAgLyogfCAqL1xuJXRva2VuIElBTkQgICAvKiBbJl0gKi9cbiV0b2tlbiBJT1IgICAgLyogW3xdICovXG4ldG9rZW4gU0hMICAgICAgLyogPDwgKi9cbiV0b2tlbiBTSFIgICAgICAvKiA+PiAqL1xuJXRva2VuIFNBUiAgICAgIC8qID4+PiAqL1xuJXRva2VuIEJBTkcgICAgIC8qICEgKi9cbiV0b2tlbiBUSUxERSAgICAvKiB+ICovXG4ldG9rZW4gR0xPQkFMICAgLyogZ2xvYmFsICovXG5cbiVsZWZ0IElPUiAvKiBwcmVjZWRlbmNlIDIwICovXG4lbGVmdCBJQU5EIC8qIHByZWNlZGVuY2UgMzAgKi9cbiVsZWZ0IE9SIC8qIHByZWNlZGVuY2UgNDAgKi9cbiVsZWZ0IEFORCAvKiBwcmVjZWRlbmNlIDUwICovXG4lbGVmdCBFUUVRIE5FUSAvKiBwcmVjZWRlbmNlIDYwICovXG4lbGVmdCBMVCBMVEUgR1QgR1RFIC8qIHByZWNlZGVuY2UgNzAgKi9cbiVsZWZ0IFNITCBTSFIgU0FSIC8qIHByZWNlZGVuY2UgODAgKi9cbiVsZWZ0IFBMVVMgREFTSCAvKiBwcmVjZWRlbmNlIDkwICovXG4lbGVmdCBTVEFSIC8qIHByZWNlZGVuY2UgMTAwICovXG4lbm9uYXNzb2MgQkFOR1xuJW5vbmFzc29jIFRJTERFXG4lbm9uYXNzb2MgTEJSQUNLRVRcbiVub25hc3NvYyBMUEFSRU5cblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4lc3RhcnQgcHJvZ1xuJXN0YXJ0IGV4cF90b3BcbiVzdGFydCBzdG10X3RvcFxuJXR5cGUgPEFzdC5leHAgQXN0Lm5vZGU+IGV4cF90b3BcbiV0eXBlIDxBc3Quc3RtdCBBc3Qubm9kZT4gc3RtdF90b3BcblxuJXR5cGUgPEFzdC5wcm9nPiBwcm9nXG4ldHlwZSA8QXN0LmV4cCBBc3Qubm9kZT4gZXhwXG4ldHlwZSA8QXN0LnN0bXQgQXN0Lm5vZGU+IHN0bXRcbiV0eXBlIDxBc3QuYmxvY2s+IGJsb2NrXG4ldHlwZSA8QXN0LnR5PiB0eVxuJSVcblxuZXhwX3RvcDpcbiAgfCBlPWV4cCBFT0YgeyBlIH1cblxuc3RtdF90b3A6XG4gIHwgcz1zdG10IEVPRiB7IHMgfVxuXG5wcm9nOlxuICB8IHA9bGlzdChkZWNsKSBFT0YgIHsgcCB9XG5cbmRlY2w6XG4gIHwgR0xPQkFMIG5hbWU9SURFTlQgRVEgaW5pdD1nZXhwIFNFTUlcbiAgICB7IEd2ZGVjbCAobG9jICRzdGFydHBvcyAkZW5kcG9zIHsgbmFtZTsgaW5pdCB9KSB9XG4gIHwgZnJ0eXA9cmV0X3R5IGZuYW1lPUlERU5UIExQQVJFTiBhcmdzPWFyZ2xpc3QgUlBBUkVOIGJvZHk9YmxvY2tcbiAgICB7IEdmZGVjbCAobG9jICRzdGFydHBvcyAkZW5kcG9zIHsgZnJ0eXA7IGZuYW1lOyBhcmdzOyBib2R5IH0pIH1cblxuYXJnbGlzdDpcbiAgfCBsPXNlcGFyYXRlZF9saXN0KENPTU1BLCBwYWlyKHR5LElERU5UKSkgeyBsIH1cbiAgICBcbnR5OlxuICB8IFRJTlQgICB7IFRJbnQgfVxuICB8IFRCT09MICB7IFRCb29sIH1cbiAgfCByPXJ0eXAgeyBUUmVmIHIgfSBcblxuXG4laW5saW5lIHJldF90eTpcbiAgfCBUVk9JRCAgeyBSZXRWb2lkIH1cbiAgfCB0PXR5ICAgeyBSZXRWYWwgdCB9XG5cbiVpbmxpbmUgcnR5cDpcbiAgfCBUU1RSSU5HIHsgUlN0cmluZyB9XG4gIHwgdD10eSBMQlJBQ0tFVCBSQlJBQ0tFVCB7IFJBcnJheSB0IH1cblxuJWlubGluZSBib3A6XG4gIHwgUExVUyAgIHsgQWRkIH1cbiAgfCBEQVNIICAgeyBTdWIgfVxuICB8IFNUQVIgICB7IE11bCB9XG4gIHwgRVFFUSAgIHsgRXEgfSBcbiAgfCBORVEgICB7IE5lcSB9IFxuICB8IExUICAgeyBMdCB9IFxuICB8IExURSAgIHsgTHRlIH0gXG4gIHwgR1QgICB7IEd0IH0gXG4gIHwgR1RFICAgeyBHdGUgfSBcbiAgfCBBTkQgICB7IEFuZCB9IFxuICB8IE9SICAgeyBPciB9IFxuICB8IElBTkQgICB7IElBbmQgfSBcbiAgfCBJT1IgICB7IElPciB9IFxuICB8IFNITCAgICB7IFNobCB9XG4gIHwgU0hSICAgIHsgU2hyIH1cbiAgfCBTQVIgICAgeyBTYXIgfVxuXG4laW5saW5lIHVvcDpcbiAgfCBEQVNIICB7IE5lZyB9XG4gIHwgQkFORyAgeyBMb2dub3QgfVxuICB8IFRJTERFIHsgQml0bm90IH1cblxuZ2V4cDpcbiAgfCBpPUlOVCAgICAgIHsgbG9jICRzdGFydHBvcyAkZW5kcG9zIEBAIENJbnQgaSB9XG4gIHwgcz1TVFJJTkcgICB7IGxvYyAkc3RhcnRwb3MgJGVuZHBvcyBAQCBDU3RyIHMgfVxuICB8IHQ9cnR5cCBOVUxMICB7IGxvYyAkc3RhcnRwb3MgJGVuZHBvcyBAQCBDTnVsbCB0IH1cbiAgfCBUUlVFIHtsb2MgJHN0YXJ0cG9zICRlbmRwb3MgQEAgQ0Jvb2wgdHJ1ZSB9XG4gIHwgRkFMU0Uge2xvYyAkc3RhcnRwb3MgJGVuZHBvcyBAQCBDQm9vbCBmYWxzZSB9XG4gIHwgTkVXIHQ9dHkgTEJSQUNLRVQgUkJSQUNLRVQgTEJSQUNFIGVzPXNlcGFyYXRlZF9saXN0KENPTU1BLCBnZXhwKSBSQlJBQ0VcbiAgICAgICAgICB7IGxvYyAkc3RhcnRwb3MgJGVuZHBvcyBAQCBDQXJyKHQsIGVzKSB9XG4oKiBzcGVjIGRvZXMgbm90IHJlcXVpcmUgTkVXIGJ1dCB0ZXN0cyBkbyAqKVxubGhzOiAgXG4gIHwgaWQ9SURFTlQgICAgICAgICAgICB7IGxvYyAkc3RhcnRwb3MgJGVuZHBvcyBAQCBJZCBpZCB9XG4gIHwgZT1leHAgTEJSQUNLRVQgaT1leHAgUkJSQUNLRVRcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbG9jICRzdGFydHBvcyAkZW5kcG9zIEBAIEluZGV4IChlLCBpKSB9XG5cbmV4cDpcbiAgfCBpZD1JREVOVCAgICAgICAgICAgIHsgbG9jICRzdGFydHBvcyAkZW5kcG9zIEBAIElkIGlkIH1cbiAgfCBpPUlOVCAgICAgICAgICAgICAgIHsgbG9jICRzdGFydHBvcyAkZW5kcG9zIEBAIENJbnQgaSB9XG4gIHwgcz1TVFJJTkcgICAgICAgICAgICB7IGxvYyAkc3RhcnRwb3MgJGVuZHBvcyBAQCBDU3RyIHMgfVxuICB8IHQ9cnR5cCBOVUxMICAgICAgICAgICB7IGxvYyAkc3RhcnRwb3MgJGVuZHBvcyBAQCBDTnVsbCB0IH1cbiAgfCBUUlVFICAgICAgICAgICAgICAgIHsgbG9jICRzdGFydHBvcyAkZW5kcG9zIEBAIENCb29sIHRydWUgfVxuICB8IEZBTFNFICAgICAgICAgICAgICAgIHsgbG9jICRzdGFydHBvcyAkZW5kcG9zIEBAIENCb29sIGZhbHNlIH1cbiAgfCBlPWV4cCBMQlJBQ0tFVCBpPWV4cCBSQlJBQ0tFVFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBsb2MgJHN0YXJ0cG9zICRlbmRwb3MgQEAgSW5kZXggKGUsIGkpIH1cbiAgfCBlPWV4cCBMUEFSRU4gZXM9c2VwYXJhdGVkX2xpc3QoQ09NTUEsIGV4cCkgUlBBUkVOXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGxvYyAkc3RhcnRwb3MgJGVuZHBvcyBAQCBDYWxsIChlLGVzKSB9XG4gIHwgTkVXIHQ9dHkgTEJSQUNLRVQgUkJSQUNLRVQgTEJSQUNFIGVzPXNlcGFyYXRlZF9saXN0KENPTU1BLCBleHApIFJCUkFDRVxuICAgICAgICAgICAgICAgICAgICAgICAgeyBsb2MgJHN0YXJ0cG9zICRlbmRwb3MgQEAgQ0Fycih0LCBlcykgfVxuICB8IE5FVyB0PXR5IExCUkFDS0VUIGU9ZXhwIFJCUkFDS0VUXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGxvYyAkc3RhcnRwb3MgJGVuZHBvcyBAQCBOZXdBcnIodCwgZSkgfVxuICB8IGUxPWV4cCBiPWJvcCBlMj1leHAgeyBsb2MgJHN0YXJ0cG9zICRlbmRwb3MgQEAgQm9wIChiLCBlMSwgZTIpIH1cbiAgfCB1PXVvcCBlPWV4cCAgICAgICAgIHsgbG9jICRzdGFydHBvcyAkZW5kcG9zIEBAIFVvcCAodSwgZSkgfVxuICB8IExQQVJFTiBlPWV4cCBSUEFSRU4geyBlIH0gXG5cbnZkZWNsOlxuICB8IFZBUiBpZD1JREVOVCBFUSBpbml0PWV4cCB7IChpZCwgaW5pdCkgfVxuXG52ZGVjbHM6XG4gIHwgZHM9c2VwYXJhdGVkX2xpc3QoQ09NTUEsIHZkZWNsKSB7IGRzIH1cblxuZXhwX29wdDpcbiAgfCAoKiBlbXB0eSAqKSB7IE5vbmUgfVxuICB8IGU9ZXhwIHsgU29tZSBlIH1cblxuc3RtdF9vcHQ6XG4gIHwgKCogZW1wdHkgKikgeyBOb25lIH1cbiAgfCBzPXN0bXQgeyBTb21lIHMgfVxuXG5zdG10OiBcbiAgfCBkPXZkZWNsIFNFTUkgICAgICAgIHsgbG9jICRzdGFydHBvcyAkZW5kcG9zIEBAIERlY2woZCkgfVxuICB8IHA9bGhzIEVRIGU9ZXhwIFNFTUkgeyBsb2MgJHN0YXJ0cG9zICRlbmRwb3MgQEAgQXNzbihwLGUpIH1cbiAgfCBlPWV4cCBMUEFSRU4gZXM9c2VwYXJhdGVkX2xpc3QoQ09NTUEsIGV4cCkgUlBBUkVOIFNFTUlcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbG9jICRzdGFydHBvcyAkZW5kcG9zIEBAIFNDYWxsIChlLCBlcykgfVxuICB8IGlmcz1pZl9zdG10ICAgICAgICAgeyBpZnMgfVxuICB8IFJFVFVSTiBTRU1JICAgICAgICAgeyBsb2MgJHN0YXJ0cG9zICRlbmRwb3MgQEAgUmV0KE5vbmUpIH1cbiAgfCBSRVRVUk4gZT1leHAgU0VNSSAgIHsgbG9jICRzdGFydHBvcyAkZW5kcG9zIEBAIFJldChTb21lIGUpIH1cbiAgfCBXSElMRSBMUEFSRU4gZT1leHAgUlBBUkVOIGI9YmxvY2sgIFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBsb2MgJHN0YXJ0cG9zICRlbmRwb3MgQEAgV2hpbGUoZSwgYikgfVxuICB8IEZPUiBMUEFSRU4gZHM9dmRlY2xzIFNFTUkgZT1leHBfb3B0IFNFTUkgcz1zdG10X29wdCBSUEFSRU4gYj1ibG9ja1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBsb2MgJHN0YXJ0cG9zICRlbmRwb3MgQEAgRm9yKGRzLCBlLCBzLCBiKSB9XG5cbmJsb2NrOlxuICB8IExCUkFDRSBzdG10cz1saXN0KHN0bXQpIFJCUkFDRSB7IHN0bXRzIH1cblxuaWZfc3RtdDpcbiAgfCBJRiBMUEFSRU4gZT1leHAgUlBBUkVOIGIxPWJsb2NrIGIyPWVsc2Vfc3RtdFxuICAgIHsgbG9jICRzdGFydHBvcyAkZW5kcG9zIEBAIElmKGUsYjEsYjIpIH1cblxuZWxzZV9zdG10OlxuICB8ICgqIGVtcHR5ICopICAgICAgIHsgW10gfVxuICB8IEVMU0UgYj1ibG9jayAgICAgIHsgYiB9XG4gIHwgRUxTRSBpZnM9aWZfc3RtdCAgeyBbIGlmcyBdIH1cbiIsIntcbiAgb3BlbiBMZXhpbmdcbiAgb3BlbiBQYXJzZXJcbiAgb3BlbiBSYW5nZVxuICBcbiAgZXhjZXB0aW9uIExleGVyX2Vycm9yIG9mIFJhbmdlLnQgKiBzdHJpbmdcblxuICBsZXQgcmVzZXRfbGV4YnVmIChmaWxlbmFtZTpzdHJpbmcpIChsbnVtOmludCkgbGV4YnVmIDogdW5pdCA9XG4gICAgbGV4YnVmLmxleF9jdXJyX3AgPC0ge1xuICAgICAgcG9zX2ZuYW1lID0gZmlsZW5hbWU7XG4gICAgICBwb3NfY251bSA9IDA7XG4gICAgICBwb3NfYm9sID0gMDtcbiAgICAgIHBvc19sbnVtID0gbG51bTtcbiAgICB9XG5cbiAgbGV0IG5ld2xpbmUgbGV4YnVmID1cbiAgICBsZXhidWYubGV4X2N1cnJfcCA8LSB7IChsZXhlbWVfZW5kX3AgbGV4YnVmKSB3aXRoXG4gICAgICBwb3NfbG51bSA9IChsZXhlbWVfZW5kX3AgbGV4YnVmKS5wb3NfbG51bSArIDE7XG4gICAgICBwb3NfYm9sID0gKGxleGVtZV9lbmQgbGV4YnVmKSB9XG4gICAgXG4gICgqIEJvaWxlcnBsYXRlIHRvIGRlZmluZSBleGNlcHRpb25hbCBjYXNlcyBpbiB0aGUgbGV4ZXIuICopXG4gIGxldCB1bmV4cGVjdGVkX2NoYXIgbGV4YnVmIChjOmNoYXIpIDogJ2EgPVxuICAgIHJhaXNlIChMZXhlcl9lcnJvciAoUmFuZ2UubGV4X3JhbmdlIGxleGJ1ZixcbiAgICAgICAgUHJpbnRmLnNwcmludGYgXCJVbmV4cGVjdGVkIGNoYXJhY3RlcjogJyVjJ1wiIGMpKVxuXG4gICgqIExleGluZyByZXNlcnZlZCB3b3JkcyAqKVxuICBsZXQgcmVzZXJ2ZWRfd29yZHMgPSBbXG4gICgqIEtleXdvcmRzICopXG4gIChcIm51bGxcIiwgTlVMTCk7XG4gIChcInRydWVcIiwgVFJVRSk7XG4gIChcImZhbHNlXCIsIEZBTFNFKTtcbiAgKFwidm9pZFwiLCBUVk9JRCk7XG4gIChcImJvb2xcIiwgVEJPT0wpO1xuICAoXCJpbnRcIiwgVElOVCk7XG4gIChcInN0cmluZ1wiLCBUU1RSSU5HKTtcbiAgKFwibmV3XCIsIE5FVyk7XG4gIChcImVsc2VcIiwgRUxTRSk7XG4gIChcImlmXCIsIElGKTtcbiAgKFwid2hpbGVcIiwgV0hJTEUpO1xuICAoXCJmb3JcIiwgRk9SKTtcbiAgKFwicmV0dXJuXCIsIFJFVFVSTik7XG4gIChcInZhclwiLCBWQVIpO1xuICAoXCJnbG9iYWxcIiwgR0xPQkFMKTtcblxuICAoKiBTeW1ib2xzICopXG4gICggXCI7XCIsIFNFTUkpO1xuICAoIFwiLFwiLCBDT01NQSk7XG4gICggXCJ7XCIsIExCUkFDRSk7XG4gICggXCJ9XCIsIFJCUkFDRSk7XG4gICggXCIoXCIsIExQQVJFTik7XG4gICggXCIpXCIsIFJQQVJFTik7XG4gICggXCJbXCIsIExCUkFDS0VUKTtcbiAgKCBcIl1cIiwgUkJSQUNLRVQpO1xuICAoIFwiPVwiLCBFUSk7XG4gICgqIEJpbmFyeSBPcGVyYXRvcnMgKilcbiAgKCBcIitcIiwgUExVUyk7XG4gICggXCItXCIsIERBU0gpOyAoKiBBbHNvIFVuYXJ5ICopXG4gICggXCIqXCIsIFNUQVIpO1xuICAoIFwiPT1cIiwgRVFFUSk7XG4gICggXCIhPVwiLCBORVEpO1xuICAoIFwiPFwiLCBMVCk7XG4gICggXCI8PVwiLCBMVEUpO1xuICAoIFwiPlwiLCBHVCk7XG4gICggXCI+PVwiLCBHVEUpO1xuICAoIFwiJlwiLCBBTkQpO1xuICAoIFwifFwiLCBPUik7XG4gICggXCJbJl1cIiwgSUFORCk7XG4gICggXCJbfF1cIiwgSU9SKTtcbiAgKCBcIjw8XCIsIFNITCk7XG4gICggXCI+PlwiLCBTSFIpO1xuICAoIFwiPj4+XCIsIFNBUik7XG4gICgqIFVuYXJ5IE9wZXJhdG9ycyAqKVxuICAoIFwiIVwiLCBCQU5HKTtcbiAgKCBcIn5cIiwgVElMREUpO1xuICBcbiAgXVxuXG5sZXQgKHN5bWJvbF90YWJsZSA6IChzdHJpbmcsIFBhcnNlci50b2tlbikgSGFzaHRibC50KSA9IEhhc2h0YmwuY3JlYXRlIDEwMjRcbiAgbGV0IF8gPVxuICAgIExpc3QuaXRlciAoZnVuIChzdHIsdCkgLT4gSGFzaHRibC5hZGQgc3ltYm9sX3RhYmxlIHN0ciB0KSByZXNlcnZlZF93b3Jkc1xuXG4gIGxldCBjcmVhdGVfdG9rZW4gbGV4YnVmID1cbiAgICBsZXQgc3RyID0gbGV4ZW1lIGxleGJ1ZiBpbiBcbiAgICB0cnkgKEhhc2h0YmwuZmluZCBzeW1ib2xfdGFibGUgc3RyKSBcbiAgICB3aXRoIF8gLT4gSURFTlQgc3RyXG5cbiAgKCogTGV4aW5nIGNvbW1lbnRzIGFuZCBzdHJpbmdzICopXG4gIGxldCBzdHJpbmdfYnVmZmVyID0gcmVmIChCeXRlcy5jcmVhdGUgMjA0OClcbiAgbGV0IHN0cmluZ19lbmQgPSByZWYgMFxuICBsZXQgc3RhcnRfbGV4ID0gcmVmIChSYW5nZS5zdGFydF9vZl9yYW5nZSBSYW5nZS5ub3JhbmdlKVxuXG4gIGxldCBzdGFydF9wb3Nfb2ZfbGV4YnVmIGxleGJ1ZiA6IHBvcyA9XG4gICAgKFJhbmdlLnBvc19vZl9sZXhwb3MgKGxleGVtZV9zdGFydF9wIGxleGJ1ZikpXG5cbiAgbGV0IGxleF9sb25nX3JhbmdlIGxleGJ1ZiA6IFJhbmdlLnQgPVxuICAgIGxldCBlbmRfcCA9IGxleGVtZV9lbmRfcCBsZXhidWYgaW5cbiAgICBta19yYW5nZSBlbmRfcC5wb3NfZm5hbWUgKCFzdGFydF9sZXgpIChwb3Nfb2ZfbGV4cG9zIGVuZF9wKSAgXG5cbiAgbGV0IHJlc2V0X3N0ciAoKSA9IHN0cmluZ19lbmQgOj0gMFxuXG4gIGxldCBhZGRfc3RyIGNoID1cbiAgICBsZXQgeCA9ICFzdHJpbmdfZW5kIGluXG4gICAgbGV0IGJ1ZmZlciA9ICFzdHJpbmdfYnVmZmVyXG4gICAgaW5cbiAgICAgIGlmIHggPSBCeXRlcy5sZW5ndGggYnVmZmVyIHRoZW5cbiAgICAgICAgYmVnaW5cbiAgICAgICAgICBsZXQgbmV3X2J1ZmZlciA9IEJ5dGVzLmNyZWF0ZSAoeCoyKSBpblxuICAgICAgICAgIEJ5dGVzLmJsaXQgYnVmZmVyIDAgbmV3X2J1ZmZlciAwIHg7XG4gICAgICAgICAgQnl0ZXMuc2V0IG5ld19idWZmZXIgeCBjaDtcbiAgICAgICAgICBzdHJpbmdfYnVmZmVyIDo9IG5ld19idWZmZXI7XG4gICAgICAgICAgc3RyaW5nX2VuZCA6PSB4KzFcbiAgICAgICAgZW5kXG4gICAgICBlbHNlXG4gICAgICAgIGJlZ2luXG4gICAgICAgICAgQnl0ZXMuc2V0IGJ1ZmZlciB4IGNoO1xuICAgICAgICAgIHN0cmluZ19lbmQgOj0geCsxXG4gICAgICAgIGVuZFxuXG4gIGxldCBnZXRfc3RyICgpID0gQnl0ZXMuc3ViX3N0cmluZyAoIXN0cmluZ19idWZmZXIpIDAgKCFzdHJpbmdfZW5kKVxuXG4gICgqIExleGluZyBkaXJlY3RpdmVzICopXG4gIGxldCBsbnVtID0gcmVmIDFcbn1cblxuKCogRGVjbGFyZSB5b3VyIGFsaWFzZXMgKGxldCBmb28gPSByZWdleCkgYW5kIHJ1bGVzIGhlcmUuICopXG5sZXQgbmV3bGluZSA9ICdcXG4nIHwgKCdcXHInICdcXG4nKSB8ICdcXHInXG5sZXQgbG93ZXJjYXNlID0gWydhJy0neiddXG5sZXQgdXBwZXJjYXNlID0gWydBJy0nWiddXG5sZXQgY2hhcmFjdGVyID0gdXBwZXJjYXNlIHwgbG93ZXJjYXNlXG5sZXQgd2hpdGVzcGFjZSA9IFsnXFx0JyAnICddXG5sZXQgZGlnaXQgPSBbJzAnLSc5J11cbmxldCBoZXhkaWdpdCA9IFsnMCctJzknXSB8IFsnYSctJ2YnXSB8IFsnQSctJ0YnXVxuXG5ydWxlIHRva2VuID0gcGFyc2VcbiAgfCBlb2YgeyBFT0YgfVxuXG4gIHwgXCIvKlwiIHsgc3RhcnRfbGV4IDo9IHN0YXJ0X3Bvc19vZl9sZXhidWYgbGV4YnVmOyBjb21tZW50cyAwIGxleGJ1ZiB9XG4gIHwgJ1wiJyB7IHJlc2V0X3N0cigpOyBzdGFydF9sZXggOj0gc3RhcnRfcG9zX29mX2xleGJ1ZiBsZXhidWY7IHN0cmluZyBmYWxzZSBsZXhidWYgfVxuICB8ICcjJyB7IGxldCBwID0gbGV4ZW1lX3N0YXJ0X3AgbGV4YnVmIGluXG4gICAgICAgICAgaWYgcC5wb3NfY251bSAtIHAucG9zX2JvbCA9IDAgdGhlbiBkaXJlY3RpdmUgMCBsZXhidWYgXG4gICAgICAgICAgZWxzZSByYWlzZSAoTGV4ZXJfZXJyb3IgKGxleF9sb25nX3JhbmdlIGxleGJ1ZixcbiAgICAgICAgICAgIFByaW50Zi5zcHJpbnRmIFwiIyBjYW4gb25seSBiZSB0aGUgMXN0IGNoYXIgaW4gYSBsaW5lLlwiKSkgfVxuXG4gIHwgbG93ZXJjYXNlIChkaWdpdCB8IGNoYXJhY3RlciB8ICdfJykqIHsgY3JlYXRlX3Rva2VuIGxleGJ1ZiB9XG4gIHwgZGlnaXQrIHwgXCIweFwiIGhleGRpZ2l0KyB7IElOVCAoSW50NjQub2Zfc3RyaW5nIChsZXhlbWUgbGV4YnVmKSkgfVxuICB8IHdoaXRlc3BhY2UrIHsgdG9rZW4gbGV4YnVmIH1cbiAgfCBuZXdsaW5lIHsgbmV3bGluZSBsZXhidWY7IHRva2VuIGxleGJ1ZiB9XG5cbiAgfCAnOycgfCAnLCcgfCAneycgfCAnfScgfCAnKycgfCAnLScgfCAnKicgfCAnPScgfCBcIj09XCIgXG4gIHwgXCIhPVwiIHwgJyEnIHwgJ34nIHwgJygnIHwgJyknIHwgJ1snIHwgJ10nIFxuICB8ICc8JyB8IFwiPD1cIiB8ICc+JyB8IFwiPj1cIiB8ICcmJyB8ICd8J1xuICB8IFwiWyZdXCIgfCBcIlt8XVwiIHwgXCI8PFwiIHwgXCI+Pj5cIiB8IFwiPj5cIlxuICAgIHsgY3JlYXRlX3Rva2VuIGxleGJ1ZiB9XG5cbiAgfCBfIGFzIGMgeyB1bmV4cGVjdGVkX2NoYXIgbGV4YnVmIGMgfVxuXG5hbmQgZGlyZWN0aXZlIHN0YXRlID0gcGFyc2VcbiAgfCB3aGl0ZXNwYWNlKyB7IGRpcmVjdGl2ZSBzdGF0ZSBsZXhidWYgfSBcbiAgfCBkaWdpdCsgeyBpZiBzdGF0ZSA9IDAgdGhlbiBcbiAgICAgICAgICAgICAgIChsbnVtIDo9IGludF9vZl9zdHJpbmcgKGxleGVtZSBsZXhidWYpOyBcbiAgICAgICAgICAgICAgICBkaXJlY3RpdmUgMSBsZXhidWYpXG4gICAgICAgICAgICAgZWxzZSBpZiBzdGF0ZSA9IDIgdGhlbiBkaXJlY3RpdmUgMyBsZXhidWZcbiAgICAgICAgICAgICBlbHNlIHJhaXNlIChMZXhlcl9lcnJvciAobGV4X2xvbmdfcmFuZ2UgbGV4YnVmLFxuICAgICAgICAgICAgICAgUHJpbnRmLnNwcmludGYgXCJJbGxlZ2FsIGRpcmVjdGl2ZXNcIikpIH1cbiAgfCAnXCInIHsgaWYgc3RhdGUgPSAxIHRoZW5cbiAgICAgICAgICAgIGJlZ2luXG4gICAgICAgICAgICAgIHJlc2V0X3N0cigpOyBcbiAgICAgICAgICAgICAgc3RhcnRfbGV4IDo9IHN0YXJ0X3Bvc19vZl9sZXhidWYgbGV4YnVmOyBcbiAgICAgICAgICAgICAgc3RyaW5nIHRydWUgbGV4YnVmXG4gICAgICAgICAgICBlbmQgXG4gICAgICAgICAgZWxzZSByYWlzZSAoTGV4ZXJfZXJyb3IgKGxleF9sb25nX3JhbmdlIGxleGJ1ZixcbiAgICAgICAgICAgIFByaW50Zi5zcHJpbnRmIFwiSWxsZWdhbCBkaXJlY3RpdmVzXCIpKSBcbiAgICAgICAgIH1cbiAgfCBuZXdsaW5lIHsgaWYgc3RhdGUgPSAyIHx8IHN0YXRlID0gMyB0aGVuXG4gICAgICAgICAgICAgICAgYmVnaW4gXG4gICAgICAgICAgICAgICAgICByZXNldF9sZXhidWYgKGdldF9zdHIoKSkgIWxudW0gbGV4YnVmO1xuICAgICAgICAgICAgICAgICAgdG9rZW4gbGV4YnVmXG4gICAgICAgICAgICAgICAgZW5kIFxuICAgICAgICAgICAgICBlbHNlIHJhaXNlIChMZXhlcl9lcnJvciAobGV4X2xvbmdfcmFuZ2UgbGV4YnVmLFxuICAgICAgICAgICAgICAgIFByaW50Zi5zcHJpbnRmIFwiSWxsZWdhbCBkaXJlY3RpdmVzXCIpKSB9XG4gIHwgXyB7IHJhaXNlIChMZXhlcl9lcnJvciAobGV4X2xvbmdfcmFuZ2UgbGV4YnVmLCBcbiAgICAgICAgICBQcmludGYuc3ByaW50ZiBcIklsbGVnYWwgZGlyZWN0aXZlc1wiKSkgfVxuXG5hbmQgY29tbWVudHMgbGV2ZWwgPSBwYXJzZVxuICB8IFwiKi9cIiB7IGlmIGxldmVsID0gMCB0aGVuIHRva2VuIGxleGJ1ZlxuXHQgICBlbHNlIGNvbW1lbnRzIChsZXZlbC0xKSBsZXhidWYgfVxuICB8IFwiLypcIiB7IGNvbW1lbnRzIChsZXZlbCsxKSBsZXhidWZ9XG4gIHwgW14gJ1xcbiddIHsgY29tbWVudHMgbGV2ZWwgbGV4YnVmIH1cbiAgfCBcIlxcblwiIHsgbmV3bGluZSBsZXhidWY7IGNvbW1lbnRzIGxldmVsIGxleGJ1ZiB9XG4gIHwgZW9mXHQgeyByYWlzZSAoTGV4ZXJfZXJyb3IgKGxleF9sb25nX3JhbmdlIGxleGJ1ZixcbiAgICAgICAgICAgICBQcmludGYuc3ByaW50ZiBcImNvbW1lbnRzIGFyZSBub3QgY2xvc2VkXCIpKSB9XG5cbmFuZCBzdHJpbmcgaW5fZGlyZWN0aXZlID0gcGFyc2VcbiAgfCAnXCInICB7IGlmIGluX2RpcmVjdGl2ZSA9IGZhbHNlIHRoZW5cbiAgICAgICAgICAgICBTVFJJTkcgKGdldF9zdHIoKSlcbiAgICAgICAgICAgZWxzZSBkaXJlY3RpdmUgMiBsZXhidWYgfSAgXG4gIHwgJ1xcXFwnIHsgYWRkX3N0cihlc2NhcGVkIGxleGJ1Zik7IHN0cmluZyBpbl9kaXJlY3RpdmUgbGV4YnVmIH1cbiAgfCAnXFxuJyB7IGFkZF9zdHIgJ1xcbic7IG5ld2xpbmUgbGV4YnVmOyBzdHJpbmcgaW5fZGlyZWN0aXZlIGxleGJ1ZiB9XG4gIHwgZW9mICB7IHJhaXNlIChMZXhlcl9lcnJvciAobGV4X2xvbmdfcmFuZ2UgbGV4YnVmLFxuICAgICAgICAgICAgIFByaW50Zi5zcHJpbnRmIFwiU3RyaW5nIGlzIG5vdCB0ZXJtaW5hdGVkXCIpKSB9XG4gIHwgXyAgICB7IGFkZF9zdHIgKExleGluZy5sZXhlbWVfY2hhciBsZXhidWYgMCk7IHN0cmluZyBpbl9kaXJlY3RpdmUgbGV4YnVmIH1cblxuYW5kIGVzY2FwZWQgPSBwYXJzZVxuICB8ICduJyAgICB7ICdcXG4nIH1cbiAgfCAndCcgICAgeyAnXFx0JyB9XG4gIHwgJ1xcXFwnICAgeyAnXFxcXCcgfVxuICB8ICdcIicgICAgeyAnXFwwMzQnICB9XG4gIHwgJ1xcJycgICB7ICdcXCcnIH1cbiAgfCBbJzAnLSc5J11bJzAnLSc5J11bJzAnLSc5J11cbiAgICB7XG4gICAgICBsZXQgeCA9IGludF9vZl9zdHJpbmcobGV4ZW1lIGxleGJ1ZikgaW5cbiAgICAgIGlmIHggPiAyNTUgdGhlblxuICAgICAgICByYWlzZSAoTGV4ZXJfZXJyb3IgKGxleF9sb25nX3JhbmdlIGxleGJ1ZixcbiAgICAgICAgICAoUHJpbnRmLnNwcmludGYgXCIlcyBpcyBhbiBpbGxlZ2FsIGVzY2FwZWQgY2hhcmFjdGVyIGNvbnN0YW50XCIgKGxleGVtZSBsZXhidWYpKSkpXG4gICAgICBlbHNlXG4gICAgICAgIENoYXIuY2hyIHhcbiAgICB9XG4gIHwgW14gJ1wiJyAnXFxcXCcgJ3QnICduJyAnXFwnJ11cbiAgICB7IHJhaXNlIChMZXhlcl9lcnJvciAobGV4X2xvbmdfcmFuZ2UgbGV4YnVmLFxuICAgICAgICAoUHJpbnRmLnNwcmludGYgXCIlcyBpcyBhbiBpbGxlZ2FsIGVzY2FwZWQgY2hhcmFjdGVyIGNvbnN0YW50XCIgKGxleGVtZSBsZXhidWYpICkpKSB9XG5cbiIsIiMgMSBcImh3MDMvbGV4ZXIubWxsXCJcbiBcbiAgb3BlbiBMZXhpbmdcbiAgb3BlbiBQYXJzZXJcbiAgb3BlbiBSYW5nZVxuICBcbiAgZXhjZXB0aW9uIExleGVyX2Vycm9yIG9mIFJhbmdlLnQgKiBzdHJpbmdcblxuICBsZXQgcmVzZXRfbGV4YnVmIChmaWxlbmFtZTpzdHJpbmcpIChsbnVtOmludCkgbGV4YnVmIDogdW5pdCA9XG4gICAgbGV4YnVmLmxleF9jdXJyX3AgPC0ge1xuICAgICAgcG9zX2ZuYW1lID0gZmlsZW5hbWU7XG4gICAgICBwb3NfY251bSA9IDA7XG4gICAgICBwb3NfYm9sID0gMDtcbiAgICAgIHBvc19sbnVtID0gbG51bTtcbiAgICB9XG5cbiAgbGV0IG5ld2xpbmUgbGV4YnVmID1cbiAgICBsZXhidWYubGV4X2N1cnJfcCA8LSB7IChsZXhlbWVfZW5kX3AgbGV4YnVmKSB3aXRoXG4gICAgICBwb3NfbG51bSA9IChsZXhlbWVfZW5kX3AgbGV4YnVmKS5wb3NfbG51bSArIDE7XG4gICAgICBwb3NfYm9sID0gKGxleGVtZV9lbmQgbGV4YnVmKSB9XG4gICAgXG4gICgqIEJvaWxlcnBsYXRlIHRvIGRlZmluZSBleGNlcHRpb25hbCBjYXNlcyBpbiB0aGUgbGV4ZXIuICopXG4gIGxldCB1bmV4cGVjdGVkX2NoYXIgbGV4YnVmIChjOmNoYXIpIDogJ2EgPVxuICAgIHJhaXNlIChMZXhlcl9lcnJvciAoUmFuZ2UubGV4X3JhbmdlIGxleGJ1ZixcbiAgICAgICAgUHJpbnRmLnNwcmludGYgXCJVbmV4cGVjdGVkIGNoYXJhY3RlcjogJyVjJ1wiIGMpKVxuXG4gICgqIExleGluZyByZXNlcnZlZCB3b3JkcyAqKVxuICBsZXQgcmVzZXJ2ZWRfd29yZHMgPSBbXG4gICgqIEtleXdvcmRzICopXG4gIChcIm51bGxcIiwgTlVMTCk7XG4gIChcInRydWVcIiwgVFJVRSk7XG4gIChcImZhbHNlXCIsIEZBTFNFKTtcbiAgKFwidm9pZFwiLCBUVk9JRCk7XG4gIChcImJvb2xcIiwgVEJPT0wpO1xuICAoXCJpbnRcIiwgVElOVCk7XG4gIChcInN0cmluZ1wiLCBUU1RSSU5HKTtcbiAgKFwibmV3XCIsIE5FVyk7XG4gIChcImVsc2VcIiwgRUxTRSk7XG4gIChcImlmXCIsIElGKTtcbiAgKFwid2hpbGVcIiwgV0hJTEUpO1xuICAoXCJmb3JcIiwgRk9SKTtcbiAgKFwicmV0dXJuXCIsIFJFVFVSTik7XG4gIChcInZhclwiLCBWQVIpO1xuICAoXCJnbG9iYWxcIiwgR0xPQkFMKTtcblxuICAoKiBTeW1ib2xzICopXG4gICggXCI7XCIsIFNFTUkpO1xuICAoIFwiLFwiLCBDT01NQSk7XG4gICggXCJ7XCIsIExCUkFDRSk7XG4gICggXCJ9XCIsIFJCUkFDRSk7XG4gICggXCIoXCIsIExQQVJFTik7XG4gICggXCIpXCIsIFJQQVJFTik7XG4gICggXCJbXCIsIExCUkFDS0VUKTtcbiAgKCBcIl1cIiwgUkJSQUNLRVQpO1xuICAoIFwiPVwiLCBFUSk7XG4gICgqIEJpbmFyeSBPcGVyYXRvcnMgKilcbiAgKCBcIitcIiwgUExVUyk7XG4gICggXCItXCIsIERBU0gpOyAoKiBBbHNvIFVuYXJ5ICopXG4gICggXCIqXCIsIFNUQVIpO1xuICAoIFwiPT1cIiwgRVFFUSk7XG4gICggXCIhPVwiLCBORVEpO1xuICAoIFwiPFwiLCBMVCk7XG4gICggXCI8PVwiLCBMVEUpO1xuICAoIFwiPlwiLCBHVCk7XG4gICggXCI+PVwiLCBHVEUpO1xuICAoIFwiJlwiLCBBTkQpO1xuICAoIFwifFwiLCBPUik7XG4gICggXCJbJl1cIiwgSUFORCk7XG4gICggXCJbfF1cIiwgSU9SKTtcbiAgKCBcIjw8XCIsIFNITCk7XG4gICggXCI+PlwiLCBTSFIpO1xuICAoIFwiPj4+XCIsIFNBUik7XG4gICgqIFVuYXJ5IE9wZXJhdG9ycyAqKVxuICAoIFwiIVwiLCBCQU5HKTtcbiAgKCBcIn5cIiwgVElMREUpO1xuICBcbiAgXVxuXG5sZXQgKHN5bWJvbF90YWJsZSA6IChzdHJpbmcsIFBhcnNlci50b2tlbikgSGFzaHRibC50KSA9IEhhc2h0YmwuY3JlYXRlIDEwMjRcbiAgbGV0IF8gPVxuICAgIExpc3QuaXRlciAoZnVuIChzdHIsdCkgLT4gSGFzaHRibC5hZGQgc3ltYm9sX3RhYmxlIHN0ciB0KSByZXNlcnZlZF93b3Jkc1xuXG4gIGxldCBjcmVhdGVfdG9rZW4gbGV4YnVmID1cbiAgICBsZXQgc3RyID0gbGV4ZW1lIGxleGJ1ZiBpbiBcbiAgICB0cnkgKEhhc2h0YmwuZmluZCBzeW1ib2xfdGFibGUgc3RyKSBcbiAgICB3aXRoIF8gLT4gSURFTlQgc3RyXG5cbiAgKCogTGV4aW5nIGNvbW1lbnRzIGFuZCBzdHJpbmdzICopXG4gIGxldCBzdHJpbmdfYnVmZmVyID0gcmVmIChCeXRlcy5jcmVhdGUgMjA0OClcbiAgbGV0IHN0cmluZ19lbmQgPSByZWYgMFxuICBsZXQgc3RhcnRfbGV4ID0gcmVmIChSYW5nZS5zdGFydF9vZl9yYW5nZSBSYW5nZS5ub3JhbmdlKVxuXG4gIGxldCBzdGFydF9wb3Nfb2ZfbGV4YnVmIGxleGJ1ZiA6IHBvcyA9XG4gICAgKFJhbmdlLnBvc19vZl9sZXhwb3MgKGxleGVtZV9zdGFydF9wIGxleGJ1ZikpXG5cbiAgbGV0IGxleF9sb25nX3JhbmdlIGxleGJ1ZiA6IFJhbmdlLnQgPVxuICAgIGxldCBlbmRfcCA9IGxleGVtZV9lbmRfcCBsZXhidWYgaW5cbiAgICBta19yYW5nZSBlbmRfcC5wb3NfZm5hbWUgKCFzdGFydF9sZXgpIChwb3Nfb2ZfbGV4cG9zIGVuZF9wKSAgXG5cbiAgbGV0IHJlc2V0X3N0ciAoKSA9IHN0cmluZ19lbmQgOj0gMFxuXG4gIGxldCBhZGRfc3RyIGNoID1cbiAgICBsZXQgeCA9ICFzdHJpbmdfZW5kIGluXG4gICAgbGV0IGJ1ZmZlciA9ICFzdHJpbmdfYnVmZmVyXG4gICAgaW5cbiAgICAgIGlmIHggPSBCeXRlcy5sZW5ndGggYnVmZmVyIHRoZW5cbiAgICAgICAgYmVnaW5cbiAgICAgICAgICBsZXQgbmV3X2J1ZmZlciA9IEJ5dGVzLmNyZWF0ZSAoeCoyKSBpblxuICAgICAgICAgIEJ5dGVzLmJsaXQgYnVmZmVyIDAgbmV3X2J1ZmZlciAwIHg7XG4gICAgICAgICAgQnl0ZXMuc2V0IG5ld19idWZmZXIgeCBjaDtcbiAgICAgICAgICBzdHJpbmdfYnVmZmVyIDo9IG5ld19idWZmZXI7XG4gICAgICAgICAgc3RyaW5nX2VuZCA6PSB4KzFcbiAgICAgICAgZW5kXG4gICAgICBlbHNlXG4gICAgICAgIGJlZ2luXG4gICAgICAgICAgQnl0ZXMuc2V0IGJ1ZmZlciB4IGNoO1xuICAgICAgICAgIHN0cmluZ19lbmQgOj0geCsxXG4gICAgICAgIGVuZFxuXG4gIGxldCBnZXRfc3RyICgpID0gQnl0ZXMuc3ViX3N0cmluZyAoIXN0cmluZ19idWZmZXIpIDAgKCFzdHJpbmdfZW5kKVxuXG4gICgqIExleGluZyBkaXJlY3RpdmVzICopXG4gIGxldCBsbnVtID0gcmVmIDFcblxuIyAxMjYgXCJodzAzL2xleGVyLm1sXCJcbmxldCBfX29jYW1sX2xleF90YWJsZXMgPSB7XG4gIExleGluZy5sZXhfYmFzZSA9XG4gICBcIlxcMDAwXFwwMDBcXDI0NlxcMjU1XFwyNDdcXDI1NVxcMDAyXFwwMDBcXDAwNVxcMDAwXFwwMDhcXDAwMFxcMDA2XFwwMDBcXDAwN1xcMDAwXFxcbiAgICBcXDAwMVxcMDAwXFwyNDhcXDI1NVxcMDA1XFwwMDBcXDAyMVxcMDAwXFwwMzFcXDAwMFxcMDg3XFwwMDBcXDI1MlxcMjU1XFwyNTNcXDI1NVxcXG4gICAgXFwwMTZcXDAwMFxcMjU1XFwyNTVcXDI1NFxcMjU1XFwxNjJcXDAwMFxcMTg1XFwwMDBcXDAwMVxcMDAwXFwwMDJcXDAwMFxcMDI3XFwwMDBcXFxuICAgIFxcMDAwXFwwMDFcXDI1MVxcMjU1XFwwMDJcXDAwMFxcMjUyXFwyNTVcXDI1M1xcMjU1XFwyMjJcXDAwMFxcMDA3XFwwMDBcXDA4NlxcMDAwXFxcbiAgICBcXDI1MVxcMjU1XFwyNTJcXDI1NVxcMjUzXFwyNTVcXDA0OFxcMDAwXFwwNDVcXDAwMFxcMjU1XFwyNTVcXDI1NFxcMjU1XFwyMTBcXDAwMFxcXG4gICAgXFwyNTFcXDI1NVxcMjUyXFwyNTVcXDI1M1xcMjU1XFwyNTRcXDI1NVxcMjU1XFwyNTVcXDAyNFxcMDAxXFwyNDlcXDI1NVxcMjQzXFwwMDBcXFxuICAgIFxcMjUxXFwyNTVcXDI1MlxcMjU1XFwyNTNcXDI1NVxcMjU0XFwyNTVcXDI1NVxcMjU1XFwwMzlcXDAwMVxcMjUwXFwyNTVcIjtcbiAgTGV4aW5nLmxleF9iYWNrdHJrID1cbiAgIFwiXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDhcXDAwMFxcMDA4XFwwMDBcXDAwOFxcMDAwXFwwMDhcXDAwMFxcMDA4XFwwMDBcXFxuICAgIFxcMDA3XFwwMDBcXDI1NVxcMjU1XFwwMDZcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDRcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDAwOVxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDVcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDhcXDAwMFxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwM1xcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwMVxcMDAwXFwwMDBcXDAwMFxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDAyXFwwMDBcXDAwMlxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDZcXDAwMFxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVwiO1xuICBMZXhpbmcubGV4X2RlZmF1bHQgPVxuICAgXCJcXDAwMVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDAwXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDAyNVxcMDAwXFwwMDBcXDAwMFxcMjU1XFwyNTVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMzRcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDQwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwNDZcXDAwMFxcMDAwXFwwMDBcXDI1NVxcMjU1XFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMjU1XFwyNTVcXDAwMFxcMDAwXCI7XG4gIExleGluZy5sZXhfdHJhbnMgPVxuICAgXCJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDEwXFwwMDBcXDAwOVxcMDAwXFwwMDlcXDAwMFxcMDI3XFwwMDBcXDAwOFxcMDAwXFwwMTBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDMwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMTBcXDAwMFxcMDA2XFwwMDBcXDAxNVxcMDAwXFwwMTRcXDAwMFxcMDAwXFwwMDBcXDAxMFxcMDAwXFwwMDJcXDAwMFxcMDMwXFwwMDBcXFxuICAgIFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDIyXFwwMDBcXDAxNlxcMDAwXFxcbiAgICBcXDAxMlxcMDAwXFwwMTFcXDAwMFxcMDExXFwwMDBcXDAxMVxcMDAwXFwwMTFcXDAwMFxcMDExXFwwMDBcXDAxMVxcMDAwXFwwMTFcXDAwMFxcXG4gICAgXFwwMTFcXDAwMFxcMDExXFwwMDBcXDAxOFxcMDAwXFwwMDJcXDAwMFxcMDA0XFwwMDBcXDAwN1xcMDAwXFwwMDNcXDAwMFxcMDAyXFwwMDBcXFxuICAgIFxcMDIzXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMTFcXDAwMFxcMDExXFwwMDBcXDAxMVxcMDAwXFxcbiAgICBcXDAxMVxcMDAwXFwwMTFcXDAwMFxcMDExXFwwMDBcXDAxMVxcMDAwXFwwMTFcXDAwMFxcMDExXFwwMDBcXDAxMVxcMDAwXFwwMTFcXDAwMFxcXG4gICAgXFwwMTFcXDAwMFxcMDExXFwwMDBcXDAxMVxcMDAwXFwwMTFcXDAwMFxcMDExXFwwMDBcXDAxMVxcMDAwXFwwMTFcXDAwMFxcMDExXFwwMDBcXFxuICAgIFxcMDExXFwwMDBcXDAwMlxcMDAwXFwwMzhcXDAwMFxcMDA1XFwwMDBcXDAzN1xcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFxcbiAgICBcXDAzM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcXG4gICAgXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXFxuICAgIFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFxcbiAgICBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMzZcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDIxXFwwMDBcXDAzNVxcMDAwXFwwMDBcXDAwMFxcMDEzXFwwMDBcXFxuICAgIFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFxcbiAgICBcXDAxM1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXFxuICAgIFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFxcbiAgICBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcXG4gICAgXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMTNcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFxcbiAgICBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcXG4gICAgXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXFxuICAgIFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFxcbiAgICBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwNDJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXFxuICAgIFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFxcbiAgICBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAwMFxcMDAwXFwwNDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXFxuICAgIFxcMDE3XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFxcbiAgICBcXDAyMFxcMDAwXFwwMzBcXDAwMFxcMDI3XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDI2XFwwMDBcXDAyOVxcMDAwXFwwMjlcXDAwMFxcXG4gICAgXFwwMjlcXDAwMFxcMDI5XFwwMDBcXDAyOVxcMDAwXFwwMjlcXDAwMFxcMDI5XFwwMDBcXDAyOVxcMDAwXFwwMjlcXDAwMFxcMDI5XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFxcbiAgICBcXDAzMFxcMDAwXFwwMDBcXDAwMFxcMDI4XFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcXG4gICAgXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDAwMFxcMDAwXFwwNDNcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDI5XFwwMDBcXDAyOVxcMDAwXFwwMjlcXDAwMFxcMDI5XFwwMDBcXDAyOVxcMDAwXFwwMjlcXDAwMFxcMDI5XFwwMDBcXDAyOVxcMDAwXFxcbiAgICBcXDAyOVxcMDAwXFwwMjlcXDAwMFxcMDQ5XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwNDhcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFxcbiAgICBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAzMlxcMDAwXFwwNTRcXDAwMFxcXG4gICAgXFwwNTRcXDAwMFxcMDU0XFwwMDBcXDA1NFxcMDAwXFwwNTRcXDAwMFxcMDU0XFwwMDBcXDA1NFxcMDAwXFwwNTRcXDAwMFxcMDU0XFwwMDBcXFxuICAgIFxcMDU0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDUwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDA1MlxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDUxXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDA0MVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwyNTVcXDI1NVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwyNTVcXDI1NVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcIjtcbiAgTGV4aW5nLmxleF9jaGVjayA9XG4gICBcIlxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwOFxcMDAwXFwwMjZcXDAwMFxcMDAwXFwwMDBcXDAxMFxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwwMzBcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyNTVcXDI1NVxcMDEwXFwwMDBcXDAwMFxcMDAwXFwwMzBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDVcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDE2XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDNcXDAwMFxcXG4gICAgXFwwMDNcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDZcXDAwMFxcMDA3XFwwMDBcXDAxMVxcMDAwXFwwMTFcXDAwMFxcMDExXFwwMDBcXFxuICAgIFxcMDExXFwwMDBcXDAxMVxcMDAwXFwwMTFcXDAwMFxcMDExXFwwMDBcXDAxMVxcMDAwXFwwMTFcXDAwMFxcMDExXFwwMDBcXDAxMlxcMDAwXFxcbiAgICBcXDAxMlxcMDAwXFwwMTJcXDAwMFxcMDEyXFwwMDBcXDAxMlxcMDAwXFwwMTJcXDAwMFxcMDEyXFwwMDBcXDAxMlxcMDAwXFwwMTJcXDAwMFxcXG4gICAgXFwwMTJcXDAwMFxcMDIzXFwwMDBcXDAzNVxcMDAwXFwwMDBcXDAwMFxcMDM2XFwwMDBcXDAwMFxcMDAwXFwwMjFcXDAwMFxcMDIyXFwwMDBcXFxuICAgIFxcMDMxXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDI1NVxcMjU1XFxcbiAgICBcXDAzMVxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDVcXDAwMFxcMDMxXFwwMDBcXDI1NVxcMjU1XFwwMTNcXDAwMFxcXG4gICAgXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXFxuICAgIFxcMDEzXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAxMlxcMDAwXFxcbiAgICBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcXG4gICAgXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXFxuICAgIFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFxcbiAgICBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAxM1xcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXFxuICAgIFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFxcbiAgICBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcXG4gICAgXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAzOVxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXFxuICAgIFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMjU1XFwyNTVcXDAzOVxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAyNFxcMDAwXFwwMjRcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMjRcXDAwMFxcMDI5XFwwMDBcXDAyOVxcMDAwXFxcbiAgICBcXDAyOVxcMDAwXFwwMjlcXDAwMFxcMDI5XFwwMDBcXDAyOVxcMDAwXFwwMjlcXDAwMFxcMDI5XFwwMDBcXDAyOVxcMDAwXFwwMjlcXDAwMFxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXFxuICAgIFxcMDI0XFwwMDBcXDI1NVxcMjU1XFwwMjRcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFxcbiAgICBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMjU1XFwyNTVcXDAzOVxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwwMjRcXDAwMFxcMDI0XFwwMDBcXDAyNFxcMDAwXFwwMjRcXDAwMFxcMDI0XFwwMDBcXDAyNFxcMDAwXFwwMjRcXDAwMFxcMDI0XFwwMDBcXFxuICAgIFxcMDI0XFwwMDBcXDAyNFxcMDAwXFwwNDVcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA0NVxcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXFxuICAgIFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDMxXFwwMDBcXDA1M1xcMDAwXFxcbiAgICBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcXG4gICAgXFwwNTNcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNDVcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDQ1XFwwMDBcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNDVcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDM5XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDAyNFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDA0NVxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFwiO1xuICBMZXhpbmcubGV4X2Jhc2VfY29kZSA9XG4gICBcIlwiO1xuICBMZXhpbmcubGV4X2JhY2t0cmtfY29kZSA9XG4gICBcIlwiO1xuICBMZXhpbmcubGV4X2RlZmF1bHRfY29kZSA9XG4gICBcIlwiO1xuICBMZXhpbmcubGV4X3RyYW5zX2NvZGUgPVxuICAgXCJcIjtcbiAgTGV4aW5nLmxleF9jaGVja19jb2RlID1cbiAgIFwiXCI7XG4gIExleGluZy5sZXhfY29kZSA9XG4gICBcIlwiO1xufVxuXG5sZXQgcmVjIHRva2VuIGxleGJ1ZiA9XG4gICBfX29jYW1sX2xleF90b2tlbl9yZWMgbGV4YnVmIDBcbmFuZCBfX29jYW1sX2xleF90b2tlbl9yZWMgbGV4YnVmIF9fb2NhbWxfbGV4X3N0YXRlID1cbiAgbWF0Y2ggTGV4aW5nLmVuZ2luZSBfX29jYW1sX2xleF90YWJsZXMgX19vY2FtbF9sZXhfc3RhdGUgbGV4YnVmIHdpdGhcbiAgICAgIHwgMCAtPlxuIyAxMzUgXCJodzAzL2xleGVyLm1sbFwiXG4gICAgICAgICggRU9GIClcbiMgMzE1IFwiaHcwMy9sZXhlci5tbFwiXG5cbiAgfCAxIC0+XG4jIDEzNyBcImh3MDMvbGV4ZXIubWxsXCJcbiAgICAgICAgICggc3RhcnRfbGV4IDo9IHN0YXJ0X3Bvc19vZl9sZXhidWYgbGV4YnVmOyBjb21tZW50cyAwIGxleGJ1ZiApXG4jIDMyMCBcImh3MDMvbGV4ZXIubWxcIlxuXG4gIHwgMiAtPlxuIyAxMzggXCJodzAzL2xleGVyLm1sbFwiXG4gICAgICAgICggcmVzZXRfc3RyKCk7IHN0YXJ0X2xleCA6PSBzdGFydF9wb3Nfb2ZfbGV4YnVmIGxleGJ1Zjsgc3RyaW5nIGZhbHNlIGxleGJ1ZiApXG4jIDMyNSBcImh3MDMvbGV4ZXIubWxcIlxuXG4gIHwgMyAtPlxuIyAxMzkgXCJodzAzL2xleGVyLm1sbFwiXG4gICAgICAgICggbGV0IHAgPSBsZXhlbWVfc3RhcnRfcCBsZXhidWYgaW5cbiAgICAgICAgICBpZiBwLnBvc19jbnVtIC0gcC5wb3NfYm9sID0gMCB0aGVuIGRpcmVjdGl2ZSAwIGxleGJ1ZiBcbiAgICAgICAgICBlbHNlIHJhaXNlIChMZXhlcl9lcnJvciAobGV4X2xvbmdfcmFuZ2UgbGV4YnVmLFxuICAgICAgICAgICAgUHJpbnRmLnNwcmludGYgXCIjIGNhbiBvbmx5IGJlIHRoZSAxc3QgY2hhciBpbiBhIGxpbmUuXCIpKSApXG4jIDMzMyBcImh3MDMvbGV4ZXIubWxcIlxuXG4gIHwgNCAtPlxuIyAxNDQgXCJodzAzL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggY3JlYXRlX3Rva2VuIGxleGJ1ZiApXG4jIDMzOCBcImh3MDMvbGV4ZXIubWxcIlxuXG4gIHwgNSAtPlxuIyAxNDUgXCJodzAzL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBJTlQgKEludDY0Lm9mX3N0cmluZyAobGV4ZW1lIGxleGJ1ZikpIClcbiMgMzQzIFwiaHcwMy9sZXhlci5tbFwiXG5cbiAgfCA2IC0+XG4jIDE0NiBcImh3MDMvbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgICAoIHRva2VuIGxleGJ1ZiApXG4jIDM0OCBcImh3MDMvbGV4ZXIubWxcIlxuXG4gIHwgNyAtPlxuIyAxNDcgXCJodzAzL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAoIG5ld2xpbmUgbGV4YnVmOyB0b2tlbiBsZXhidWYgKVxuIyAzNTMgXCJodzAzL2xleGVyLm1sXCJcblxuICB8IDggLT5cbiMgMTUzIFwiaHcwMy9sZXhlci5tbGxcIlxuICAgICggY3JlYXRlX3Rva2VuIGxleGJ1ZiApXG4jIDM1OCBcImh3MDMvbGV4ZXIubWxcIlxuXG4gIHwgOSAtPlxubGV0XG4jIDE1NSBcImh3MDMvbGV4ZXIubWxsXCJcbiAgICAgICAgIGNcbiMgMzY0IFwiaHcwMy9sZXhlci5tbFwiXG49IExleGluZy5zdWJfbGV4ZW1lX2NoYXIgbGV4YnVmIGxleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BvcyBpblxuIyAxNTUgXCJodzAzL2xleGVyLm1sbFwiXG4gICAgICAgICAgICggdW5leHBlY3RlZF9jaGFyIGxleGJ1ZiBjIClcbiMgMzY4IFwiaHcwMy9sZXhlci5tbFwiXG5cbiAgfCBfX29jYW1sX2xleF9zdGF0ZSAtPiBsZXhidWYuTGV4aW5nLnJlZmlsbF9idWZmIGxleGJ1ZjtcbiAgICAgIF9fb2NhbWxfbGV4X3Rva2VuX3JlYyBsZXhidWYgX19vY2FtbF9sZXhfc3RhdGVcblxuYW5kIGRpcmVjdGl2ZSBzdGF0ZSBsZXhidWYgPVxuICAgX19vY2FtbF9sZXhfZGlyZWN0aXZlX3JlYyBzdGF0ZSBsZXhidWYgMjRcbmFuZCBfX29jYW1sX2xleF9kaXJlY3RpdmVfcmVjIHN0YXRlIGxleGJ1ZiBfX29jYW1sX2xleF9zdGF0ZSA9XG4gIG1hdGNoIExleGluZy5lbmdpbmUgX19vY2FtbF9sZXhfdGFibGVzIF9fb2NhbWxfbGV4X3N0YXRlIGxleGJ1ZiB3aXRoXG4gICAgICB8IDAgLT5cbiMgMTU4IFwiaHcwMy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAgICggZGlyZWN0aXZlIHN0YXRlIGxleGJ1ZiApXG4jIDM4MCBcImh3MDMvbGV4ZXIubWxcIlxuXG4gIHwgMSAtPlxuIyAxNTkgXCJodzAzL2xleGVyLm1sbFwiXG4gICAgICAgICAgICggaWYgc3RhdGUgPSAwIHRoZW4gXG4gICAgICAgICAgICAgICAobG51bSA6PSBpbnRfb2Zfc3RyaW5nIChsZXhlbWUgbGV4YnVmKTsgXG4gICAgICAgICAgICAgICAgZGlyZWN0aXZlIDEgbGV4YnVmKVxuICAgICAgICAgICAgIGVsc2UgaWYgc3RhdGUgPSAyIHRoZW4gZGlyZWN0aXZlIDMgbGV4YnVmXG4gICAgICAgICAgICAgZWxzZSByYWlzZSAoTGV4ZXJfZXJyb3IgKGxleF9sb25nX3JhbmdlIGxleGJ1ZixcbiAgICAgICAgICAgICAgIFByaW50Zi5zcHJpbnRmIFwiSWxsZWdhbCBkaXJlY3RpdmVzXCIpKSApXG4jIDM5MCBcImh3MDMvbGV4ZXIubWxcIlxuXG4gIHwgMiAtPlxuIyAxNjUgXCJodzAzL2xleGVyLm1sbFwiXG4gICAgICAgICggaWYgc3RhdGUgPSAxIHRoZW5cbiAgICAgICAgICAgIGJlZ2luXG4gICAgICAgICAgICAgIHJlc2V0X3N0cigpOyBcbiAgICAgICAgICAgICAgc3RhcnRfbGV4IDo9IHN0YXJ0X3Bvc19vZl9sZXhidWYgbGV4YnVmOyBcbiAgICAgICAgICAgICAgc3RyaW5nIHRydWUgbGV4YnVmXG4gICAgICAgICAgICBlbmQgXG4gICAgICAgICAgZWxzZSByYWlzZSAoTGV4ZXJfZXJyb3IgKGxleF9sb25nX3JhbmdlIGxleGJ1ZixcbiAgICAgICAgICAgIFByaW50Zi5zcHJpbnRmIFwiSWxsZWdhbCBkaXJlY3RpdmVzXCIpKSBcbiAgICAgICAgIClcbiMgNDAzIFwiaHcwMy9sZXhlci5tbFwiXG5cbiAgfCAzIC0+XG4jIDE3NCBcImh3MDMvbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICggaWYgc3RhdGUgPSAyIHx8IHN0YXRlID0gMyB0aGVuXG4gICAgICAgICAgICAgICAgYmVnaW4gXG4gICAgICAgICAgICAgICAgICByZXNldF9sZXhidWYgKGdldF9zdHIoKSkgIWxudW0gbGV4YnVmO1xuICAgICAgICAgICAgICAgICAgdG9rZW4gbGV4YnVmXG4gICAgICAgICAgICAgICAgZW5kIFxuICAgICAgICAgICAgICBlbHNlIHJhaXNlIChMZXhlcl9lcnJvciAobGV4X2xvbmdfcmFuZ2UgbGV4YnVmLFxuICAgICAgICAgICAgICAgIFByaW50Zi5zcHJpbnRmIFwiSWxsZWdhbCBkaXJlY3RpdmVzXCIpKSApXG4jIDQxNCBcImh3MDMvbGV4ZXIubWxcIlxuXG4gIHwgNCAtPlxuIyAxODEgXCJodzAzL2xleGVyLm1sbFwiXG4gICAgICAoIHJhaXNlIChMZXhlcl9lcnJvciAobGV4X2xvbmdfcmFuZ2UgbGV4YnVmLCBcbiAgICAgICAgICBQcmludGYuc3ByaW50ZiBcIklsbGVnYWwgZGlyZWN0aXZlc1wiKSkgKVxuIyA0MjAgXCJodzAzL2xleGVyLm1sXCJcblxuICB8IF9fb2NhbWxfbGV4X3N0YXRlIC0+IGxleGJ1Zi5MZXhpbmcucmVmaWxsX2J1ZmYgbGV4YnVmO1xuICAgICAgX19vY2FtbF9sZXhfZGlyZWN0aXZlX3JlYyBzdGF0ZSBsZXhidWYgX19vY2FtbF9sZXhfc3RhdGVcblxuYW5kIGNvbW1lbnRzIGxldmVsIGxleGJ1ZiA9XG4gICBfX29jYW1sX2xleF9jb21tZW50c19yZWMgbGV2ZWwgbGV4YnVmIDMxXG5hbmQgX19vY2FtbF9sZXhfY29tbWVudHNfcmVjIGxldmVsIGxleGJ1ZiBfX29jYW1sX2xleF9zdGF0ZSA9XG4gIG1hdGNoIExleGluZy5lbmdpbmUgX19vY2FtbF9sZXhfdGFibGVzIF9fb2NhbWxfbGV4X3N0YXRlIGxleGJ1ZiB3aXRoXG4gICAgICB8IDAgLT5cbiMgMTg1IFwiaHcwMy9sZXhlci5tbGxcIlxuICAgICAgICAgKCBpZiBsZXZlbCA9IDAgdGhlbiB0b2tlbiBsZXhidWZcblx0ICAgZWxzZSBjb21tZW50cyAobGV2ZWwtMSkgbGV4YnVmIClcbiMgNDMzIFwiaHcwMy9sZXhlci5tbFwiXG5cbiAgfCAxIC0+XG4jIDE4NyBcImh3MDMvbGV4ZXIubWxsXCJcbiAgICAgICAgICggY29tbWVudHMgKGxldmVsKzEpIGxleGJ1ZilcbiMgNDM4IFwiaHcwMy9sZXhlci5tbFwiXG5cbiAgfCAyIC0+XG4jIDE4OCBcImh3MDMvbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAoIGNvbW1lbnRzIGxldmVsIGxleGJ1ZiApXG4jIDQ0MyBcImh3MDMvbGV4ZXIubWxcIlxuXG4gIHwgMyAtPlxuIyAxODkgXCJodzAzL2xleGVyLm1sbFwiXG4gICAgICAgICAoIG5ld2xpbmUgbGV4YnVmOyBjb21tZW50cyBsZXZlbCBsZXhidWYgKVxuIyA0NDggXCJodzAzL2xleGVyLm1sXCJcblxuICB8IDQgLT5cbiMgMTkwIFwiaHcwMy9sZXhlci5tbGxcIlxuICAgICAgICAgKCByYWlzZSAoTGV4ZXJfZXJyb3IgKGxleF9sb25nX3JhbmdlIGxleGJ1ZixcbiAgICAgICAgICAgICBQcmludGYuc3ByaW50ZiBcImNvbW1lbnRzIGFyZSBub3QgY2xvc2VkXCIpKSApXG4jIDQ1NCBcImh3MDMvbGV4ZXIubWxcIlxuXG4gIHwgX19vY2FtbF9sZXhfc3RhdGUgLT4gbGV4YnVmLkxleGluZy5yZWZpbGxfYnVmZiBsZXhidWY7XG4gICAgICBfX29jYW1sX2xleF9jb21tZW50c19yZWMgbGV2ZWwgbGV4YnVmIF9fb2NhbWxfbGV4X3N0YXRlXG5cbmFuZCBzdHJpbmcgaW5fZGlyZWN0aXZlIGxleGJ1ZiA9XG4gICBfX29jYW1sX2xleF9zdHJpbmdfcmVjIGluX2RpcmVjdGl2ZSBsZXhidWYgMzlcbmFuZCBfX29jYW1sX2xleF9zdHJpbmdfcmVjIGluX2RpcmVjdGl2ZSBsZXhidWYgX19vY2FtbF9sZXhfc3RhdGUgPVxuICBtYXRjaCBMZXhpbmcuZW5naW5lIF9fb2NhbWxfbGV4X3RhYmxlcyBfX29jYW1sX2xleF9zdGF0ZSBsZXhidWYgd2l0aFxuICAgICAgfCAwIC0+XG4jIDE5NCBcImh3MDMvbGV4ZXIubWxsXCJcbiAgICAgICAgICggaWYgaW5fZGlyZWN0aXZlID0gZmFsc2UgdGhlblxuICAgICAgICAgICAgIFNUUklORyAoZ2V0X3N0cigpKVxuICAgICAgICAgICBlbHNlIGRpcmVjdGl2ZSAyIGxleGJ1ZiApXG4jIDQ2OCBcImh3MDMvbGV4ZXIubWxcIlxuXG4gIHwgMSAtPlxuIyAxOTcgXCJodzAzL2xleGVyLm1sbFwiXG4gICAgICAgICAoIGFkZF9zdHIoZXNjYXBlZCBsZXhidWYpOyBzdHJpbmcgaW5fZGlyZWN0aXZlIGxleGJ1ZiApXG4jIDQ3MyBcImh3MDMvbGV4ZXIubWxcIlxuXG4gIHwgMiAtPlxuIyAxOTggXCJodzAzL2xleGVyLm1sbFwiXG4gICAgICAgICAoIGFkZF9zdHIgJ1xcbic7IG5ld2xpbmUgbGV4YnVmOyBzdHJpbmcgaW5fZGlyZWN0aXZlIGxleGJ1ZiApXG4jIDQ3OCBcImh3MDMvbGV4ZXIubWxcIlxuXG4gIHwgMyAtPlxuIyAxOTkgXCJodzAzL2xleGVyLm1sbFwiXG4gICAgICAgICAoIHJhaXNlIChMZXhlcl9lcnJvciAobGV4X2xvbmdfcmFuZ2UgbGV4YnVmLFxuICAgICAgICAgICAgIFByaW50Zi5zcHJpbnRmIFwiU3RyaW5nIGlzIG5vdCB0ZXJtaW5hdGVkXCIpKSApXG4jIDQ4NCBcImh3MDMvbGV4ZXIubWxcIlxuXG4gIHwgNCAtPlxuIyAyMDEgXCJodzAzL2xleGVyLm1sbFwiXG4gICAgICAgICAoIGFkZF9zdHIgKExleGluZy5sZXhlbWVfY2hhciBsZXhidWYgMCk7IHN0cmluZyBpbl9kaXJlY3RpdmUgbGV4YnVmIClcbiMgNDg5IFwiaHcwMy9sZXhlci5tbFwiXG5cbiAgfCBfX29jYW1sX2xleF9zdGF0ZSAtPiBsZXhidWYuTGV4aW5nLnJlZmlsbF9idWZmIGxleGJ1ZjtcbiAgICAgIF9fb2NhbWxfbGV4X3N0cmluZ19yZWMgaW5fZGlyZWN0aXZlIGxleGJ1ZiBfX29jYW1sX2xleF9zdGF0ZVxuXG5hbmQgZXNjYXBlZCBsZXhidWYgPVxuICAgX19vY2FtbF9sZXhfZXNjYXBlZF9yZWMgbGV4YnVmIDQ1XG5hbmQgX19vY2FtbF9sZXhfZXNjYXBlZF9yZWMgbGV4YnVmIF9fb2NhbWxfbGV4X3N0YXRlID1cbiAgbWF0Y2ggTGV4aW5nLmVuZ2luZSBfX29jYW1sX2xleF90YWJsZXMgX19vY2FtbF9sZXhfc3RhdGUgbGV4YnVmIHdpdGhcbiAgICAgIHwgMCAtPlxuIyAyMDQgXCJodzAzL2xleGVyLm1sbFwiXG4gICAgICAgICAgICggJ1xcbicgKVxuIyA1MDEgXCJodzAzL2xleGVyLm1sXCJcblxuICB8IDEgLT5cbiMgMjA1IFwiaHcwMy9sZXhlci5tbGxcIlxuICAgICAgICAgICAoICdcXHQnIClcbiMgNTA2IFwiaHcwMy9sZXhlci5tbFwiXG5cbiAgfCAyIC0+XG4jIDIwNiBcImh3MDMvbGV4ZXIubWxsXCJcbiAgICAgICAgICAgKCAnXFxcXCcgKVxuIyA1MTEgXCJodzAzL2xleGVyLm1sXCJcblxuICB8IDMgLT5cbiMgMjA3IFwiaHcwMy9sZXhlci5tbGxcIlxuICAgICAgICAgICAoICdcXDAzNCcgIClcbiMgNTE2IFwiaHcwMy9sZXhlci5tbFwiXG5cbiAgfCA0IC0+XG4jIDIwOCBcImh3MDMvbGV4ZXIubWxsXCJcbiAgICAgICAgICAgKCAnXFwnJyApXG4jIDUyMSBcImh3MDMvbGV4ZXIubWxcIlxuXG4gIHwgNSAtPlxuIyAyMTAgXCJodzAzL2xleGVyLm1sbFwiXG4gICAgKFxuICAgICAgbGV0IHggPSBpbnRfb2Zfc3RyaW5nKGxleGVtZSBsZXhidWYpIGluXG4gICAgICBpZiB4ID4gMjU1IHRoZW5cbiAgICAgICAgcmFpc2UgKExleGVyX2Vycm9yIChsZXhfbG9uZ19yYW5nZSBsZXhidWYsXG4gICAgICAgICAgKFByaW50Zi5zcHJpbnRmIFwiJXMgaXMgYW4gaWxsZWdhbCBlc2NhcGVkIGNoYXJhY3RlciBjb25zdGFudFwiIChsZXhlbWUgbGV4YnVmKSkpKVxuICAgICAgZWxzZVxuICAgICAgICBDaGFyLmNociB4XG4gICAgKVxuIyA1MzMgXCJodzAzL2xleGVyLm1sXCJcblxuICB8IDYgLT5cbiMgMjE5IFwiaHcwMy9sZXhlci5tbGxcIlxuICAgICggcmFpc2UgKExleGVyX2Vycm9yIChsZXhfbG9uZ19yYW5nZSBsZXhidWYsXG4gICAgICAgIChQcmludGYuc3ByaW50ZiBcIiVzIGlzIGFuIGlsbGVnYWwgZXNjYXBlZCBjaGFyYWN0ZXIgY29uc3RhbnRcIiAobGV4ZW1lIGxleGJ1ZikgKSkpIClcbiMgNTM5IFwiaHcwMy9sZXhlci5tbFwiXG5cbiAgfCBfX29jYW1sX2xleF9zdGF0ZSAtPiBsZXhidWYuTGV4aW5nLnJlZmlsbF9idWZmIGxleGJ1ZjtcbiAgICAgIF9fb2NhbWxfbGV4X2VzY2FwZWRfcmVjIGxleGJ1ZiBfX29jYW1sX2xleF9zdGF0ZVxuXG47O1xuXG4iLCJtb2R1bGUgSSA9XG4gIFBhcnNlci5NZW5oaXJJbnRlcnByZXRlclxuXG5sZXQgcmVhZF9maWxlIGZpbGVuYW1lIDogc3RyaW5nID1cbiAgUHJpbnRmLnByaW50ZiBcIkZJTEVOQU1FICVzIFxcblxcblxcblwiIGZpbGVuYW1lO1xuICBsZXQgbGluZXMgPSByZWYgW10gaW5cbiAgbGV0IGNoYW5uZWwgPSBvcGVuX2luIGZpbGVuYW1lIGluXG4gIHRyeSB3aGlsZSB0cnVlOyBkb1xuICAgICAgbGluZXMgOj0gaW5wdXRfbGluZSBjaGFubmVsIDo6ICFsaW5lc1xuICBkb25lOyBcIlwiXG4gIHdpdGggRW5kX29mX2ZpbGUgLT5cbiAgICBjbG9zZV9pbiBjaGFubmVsO1xuICAgIFN0cmluZy5jb25jYXQgXCJcXG5cIiAoTGlzdC5yZXYgIWxpbmVzKVxuXG5cbmxldCBzdWNjZWVkIChfIDogQXN0LnByb2cpID0gW11cblxuKCogQ29uc3VtZSB1bnRpbCBlaXRoZXIgc2VtaWNvbG9uIG9yIG9wZW4gYnJhY2VcbiAgSWYgb3BlbiBicmFjZSwgY29uc3VtZSB1bnRpbCBpdCBpcyBtYXRjaGVkICopXG5sZXQgcmVjIHJlY292ZXJfZnJvbV9lcnJvciAoc3VwcGxpZXI6SS5zdXBwbGllcikgOiB1bml0ID1cbiAgXG4gIGxldCByZWMgY29uc3VtZV9ibG9jayBzdXBwbGllciBkZXB0aCA6IHVuaXQgPVxuICAgIGlmIGRlcHRoID0gMCB0aGVuICgpIGVsc2VcbiAgICBtYXRjaCBzdXBwbGllciAoKSB3aXRoXG4gICAgfCAoUGFyc2VyLkxCUkFDRSxfLF8pIC0+IGNvbnN1bWVfYmxvY2sgc3VwcGxpZXIgKGRlcHRoICsgMSlcbiAgICB8IChQYXJzZXIuUkJSQUNFLF8sXykgLT4gY29uc3VtZV9ibG9jayBzdXBwbGllciAoZGVwdGggLSAxKVxuICAgIHwgKF8sc3RhcnQsc3RvcCkgd2hlbiBzdGFydCA9IHN0b3AgLT4gKCkgKCogdGVybWluYXRlIGF0IEVPRiAqKVxuICAgIHwgXyAtPiBjb25zdW1lX2Jsb2NrIHN1cHBsaWVyIGRlcHRoXG4gIGluXG5cblxuICBtYXRjaCBzdXBwbGllciAoKSB3aXRoXG4gIHwgKFBhcnNlci5TRU1JLF8sXykgLT4gKClcbiAgfCAoUGFyc2VyLkxCUkFDRSxfLF8pIC0+IGNvbnN1bWVfYmxvY2sgc3VwcGxpZXIgMVxuICB8IChfLHN0YXJ0LHN0b3ApIHdoZW4gc3RhcnQgPSBzdG9wIC0+ICgpICgqIHRlcm1pbmF0ZSBhdCBFT0YgKilcbiAgfCBfIC0+IFxuICByZWNvdmVyX2Zyb21fZXJyb3Igc3VwcGxpZXJcblxuKCogVGhlIHBhcnNlciBoYXMgc3VzcGVuZGVkIGl0c2VsZiBiZWNhdXNlIG9mIGEgc3ludGF4IGVycm9yLlxuICBDb25zdW1lIHRvIG5leHQgZW5kIG9mIHN0YXRlbWVudCBhbmQgY29udGludWUgKilcbmxldCByZWMgZmFpbCBmaWxlbmFtZSBsZXhidWYgKGJhY2tlZF91cCA6IEFzdC5wcm9nIEkuY2hlY2twb2ludCkgKCBfIDogQXN0LnByb2cgSS5jaGVja3BvaW50KSA9XG4gIGxldCBfLGEsYiA9IFJhbmdlLmxleF9yYW5nZSBsZXhidWYgaW5cbiAgbGV0IHN1cHBsaWVyID0gSS5sZXhlcl9sZXhidWZfdG9fc3VwcGxpZXIgTGV4ZXIudG9rZW4gbGV4YnVmIGluXG4gIHJlY292ZXJfZnJvbV9lcnJvciBzdXBwbGllcjtcbiAgKGZpbGVuYW1lLCBhLCBiKSA6OlxuICBJLmxvb3BfaGFuZGxlX3VuZG8gc3VjY2VlZCAoZmFpbCBmaWxlbmFtZSBsZXhidWYpIHN1cHBsaWVyIGJhY2tlZF91cFxuXG5cblxubGV0IGZpbmRfZXJyb3JzIChmaWxlbmFtZSA6IHN0cmluZykgOiBSYW5nZS50IGxpc3QgPVxuICBsZXQgbGV4YnVmID0gcmVhZF9maWxlIGZpbGVuYW1lIHw+IExleGluZy5mcm9tX3N0cmluZyBpblxuICBsZXQgcmVzdWx0ID0gUGFyc2VyLkluY3JlbWVudGFsLnByb2cgbGV4YnVmLmxleF9jdXJyX3AgaW5cbiAgbGV0IHN1cHBsaWVyID0gSS5sZXhlcl9sZXhidWZfdG9fc3VwcGxpZXIgTGV4ZXIudG9rZW4gbGV4YnVmIGluXG4gIEkubG9vcF9oYW5kbGVfdW5kbyBzdWNjZWVkIChmYWlsIGZpbGVuYW1lIGxleGJ1Zikgc3VwcGxpZXIgcmVzdWx0XG5cblxuXG4oKmZyb20gT2NhbWwgNC4wOCopXG5sZXQgcmVjIGZpbHRlcl9tYXAgKGwgOiAnYSBvcHRpb24gbGlzdCkgOiAnYSBsaXN0ID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgTm9uZTo6dGwgLT4gZmlsdGVyX21hcCB0bFxuICB8IFNvbWUgeDo6dGwgLT4geCA6OiBmaWx0ZXJfbWFwIHRsXG4gIHwgW10gLT4gW11cblxubGV0IHByaW50X2Vycm9yIChsb2MgOiBSYW5nZS50KSA9XG4gIFByaW50Zi5wcmludGYgXCJQYXJzZSBlcnJvciBhdDogJXNcXG5cIiAoUmFuZ2Uuc3RyaW5nX29mX3JhbmdlIGxvYykgXG5cbm9wZW4gSnNfb2Zfb2NhbWxcbmxldCBqc19vZl9yYW5nZSAobG9jIDogUmFuZ2UudCkgPVxuICBsZXQganNfb2ZfcG9zIChwb3MgOiBSYW5nZS5wb3MpID1cbiAgICBsZXQgbGluZSxjaGFyID0gcG9zIGluXG4gICAgKG9iamVjdCVqc1xuICAgICAgdmFsIGxpbmUgPSBsaW5lXG4gICAgICB2YWwgY2hhciA9IGNoYXJcbiAgICBlbmQpXG4gIGluXG4gIGxldCBmaWxlLCBzdGFydCwgZmluaXNoID0gbG9jIGluXG4gIChvYmplY3QlanNcbiAgICB2YWwgZmlsZSA9IEpzLnN0cmluZyBmaWxlXG4gICAgdmFsIHN0YXJ0ID0ganNfb2ZfcG9zIHN0YXJ0XG4gICAgdmFsIGZpbmlzaCA9IGpzX29mX3BvcyBmaW5pc2hcbiAgZW5kKVxuXG5sZXQgbWFpbiBmaWxlcyA9XG4gIGZpbGVzXG4gIHw+IEpzLnRvX2FycmF5IHw+IEFycmF5LnRvX2xpc3RcbiAgfD4gTGlzdC5tYXAgSnMudG9fc3RyaW5nXG4gIHw+IExpc3QubWFwIGZpbmRfZXJyb3JzXG4gIHw+IExpc3QuZmxhdHRlblxuICB8PiBMaXN0Lm1hcCBqc19vZl9yYW5nZVxuICB8PiBBcnJheS5vZl9saXN0IHw+IEpzLmFycmF5XG5cbmxldCBfID1cbiAgSnMuZXhwb3J0X2FsbFxuICAgIChvYmplY3QlanNcbiAgICAgIG1ldGhvZCBjb21waWxlIGZpbGVzID0gbWFpbiBmaWxlc1xuICAgIGVuZCkiXX0=